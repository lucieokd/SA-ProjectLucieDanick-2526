import _m0 from "protobufjs/minimal.js";
import { ChainConfig } from "./chain_config";
export declare const protobufPackage = "injective.evm.v1";
/** TraceConfig holds extra parameters to trace functions. */
export interface TraceConfig {
    /** tracer is a custom javascript tracer */
    tracer: string;
    /**
     * timeout overrides the default timeout of 5 seconds for JavaScript-based
     * tracing calls
     */
    timeout: string;
    /** reexec defines the number of blocks the tracer is willing to go back */
    reexec: string;
    /** disable_stack switches stack capture */
    disableStack: boolean;
    /** disable_storage switches storage capture */
    disableStorage: boolean;
    /** debug can be used to print output during capture end */
    debug: boolean;
    /** limit defines the maximum length of output, but zero means unlimited */
    limit: number;
    /** overrides can be used to execute a trace using future fork rules */
    overrides: ChainConfig | undefined;
    /** enable_memory switches memory capture */
    enableMemory: boolean;
    /** enable_return_data switches the capture of return data */
    enableReturnData: boolean;
    /** tracer_json_config configures the tracer using a JSON string */
    tracerJsonConfig: string;
    /**
     * temporary state modifications to Geth in order to simulate the effects of
     * eth_call
     */
    stateOverrides: Uint8Array;
    /** block overrides block context fields encoded as json */
    blockOverrides: Uint8Array;
}
export declare const TraceConfig: {
    encode(message: TraceConfig, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): TraceConfig;
    fromJSON(object: any): TraceConfig;
    toJSON(message: TraceConfig): unknown;
    create(base?: DeepPartial<TraceConfig>): TraceConfig;
    fromPartial(object: DeepPartial<TraceConfig>): TraceConfig;
};
type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;
export type DeepPartial<T> = T extends Builtin ? T : T extends Array<infer U> ? Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial<T[K]>;
} : Partial<T>;
export {};
