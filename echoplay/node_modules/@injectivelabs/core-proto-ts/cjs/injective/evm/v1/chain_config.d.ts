import _m0 from "protobufjs/minimal.js";
export declare const protobufPackage = "injective.evm.v1";
/**
 * ChainConfig defines the Ethereum ChainConfig parameters using *sdkmath.Int
 * values instead of *big.Int.
 */
export interface ChainConfig {
    /** homestead_block switch (nil no fork, 0 = already homestead) */
    homesteadBlock: string;
    /** dao_fork_block corresponds to TheDAO hard-fork switch block (nil no fork) */
    daoForkBlock: string;
    /**
     * dao_fork_support defines whether the nodes supports or opposes the DAO
     * hard-fork
     */
    daoForkSupport: boolean;
    /**
     * eip150_block: EIP150 implements the Gas price changes
     * (https://github.com/ethereum/EIPs/issues/150) EIP150 HF block (nil no fork)
     */
    eip150Block: string;
    /**
     * eip150_hash: EIP150 HF hash (needed for header only clients as only gas
     * pricing changed)
     */
    eip150Hash: string;
    /** eip155_block: EIP155Block HF block */
    eip155Block: string;
    /** eip158_block: EIP158 HF block */
    eip158Block: string;
    /**
     * byzantium_block: Byzantium switch block (nil no fork, 0 = already on
     * byzantium)
     */
    byzantiumBlock: string;
    /**
     * constantinople_block: Constantinople switch block (nil no fork, 0 = already
     * activated)
     */
    constantinopleBlock: string;
    /** petersburg_block: Petersburg switch block (nil same as Constantinople) */
    petersburgBlock: string;
    /**
     * istanbul_block: Istanbul switch block (nil no fork, 0 = already on
     * istanbul)
     */
    istanbulBlock: string;
    /**
     * muir_glacier_block: Eip-2384 (bomb delay) switch block (nil no fork, 0 =
     * already activated)
     */
    muirGlacierBlock: string;
    /** berlin_block: Berlin switch block (nil = no fork, 0 = already on berlin) */
    berlinBlock: string;
    /** london_block: London switch block (nil = no fork, 0 = already on london) */
    londonBlock: string;
    /**
     * arrow_glacier_block: Eip-4345 (bomb delay) switch block (nil = no fork, 0 =
     * already activated)
     */
    arrowGlacierBlock: string;
    /**
     * gray_glacier_block: EIP-5133 (bomb delay) switch block (nil = no fork, 0 =
     * already activated)
     */
    grayGlacierBlock: string;
    /**
     * merge_netsplit_block: Virtual fork after The Merge to use as a network
     * splitter
     */
    mergeNetsplitBlock: string;
    /** shanghai switch time (nil = no fork, 0 = already on shanghai) */
    shanghaiTime: string;
    /** cancun switch time (nil = no fork, 0 = already on cancun) */
    cancunTime: string;
    /** prague switch time (nil = no fork, 0 = already on prague) */
    pragueTime: string;
    /** eip155_chain_id: identifies the chain and is used for replay protection */
    eip155ChainId: string;
    /**
     * eip7840: per-fork schedule of max and target blob counts in client
     * configuration files
     */
    blobScheduleConfig: BlobScheduleConfig | undefined;
}
export interface BlobScheduleConfig {
    cancun: BlobConfig | undefined;
    prague: BlobConfig | undefined;
    osaka: BlobConfig | undefined;
    verkle: BlobConfig | undefined;
}
export interface BlobConfig {
    target: string;
    max: string;
    baseFeeUpdateFraction: string;
}
export declare const ChainConfig: {
    encode(message: ChainConfig, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ChainConfig;
    fromJSON(object: any): ChainConfig;
    toJSON(message: ChainConfig): unknown;
    create(base?: DeepPartial<ChainConfig>): ChainConfig;
    fromPartial(object: DeepPartial<ChainConfig>): ChainConfig;
};
export declare const BlobScheduleConfig: {
    encode(message: BlobScheduleConfig, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): BlobScheduleConfig;
    fromJSON(object: any): BlobScheduleConfig;
    toJSON(message: BlobScheduleConfig): unknown;
    create(base?: DeepPartial<BlobScheduleConfig>): BlobScheduleConfig;
    fromPartial(object: DeepPartial<BlobScheduleConfig>): BlobScheduleConfig;
};
export declare const BlobConfig: {
    encode(message: BlobConfig, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): BlobConfig;
    fromJSON(object: any): BlobConfig;
    toJSON(message: BlobConfig): unknown;
    create(base?: DeepPartial<BlobConfig>): BlobConfig;
    fromPartial(object: DeepPartial<BlobConfig>): BlobConfig;
};
type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;
export type DeepPartial<T> = T extends Builtin ? T : T extends Array<infer U> ? Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial<T[K]>;
} : Partial<T>;
export {};
