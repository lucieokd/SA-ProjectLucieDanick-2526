import _m0 from "protobufjs/minimal.js";
import { DerivativeLimitOrder, DerivativeMarketOrder, SpotLimitOrder } from "./order";
export declare const protobufPackage = "injective.exchange.v2";
/** Spot Exchange Limit Orderbook */
export interface SpotOrderBook {
    marketId: string;
    isBuySide: boolean;
    orders: SpotLimitOrder[];
}
/** Derivative Exchange Limit Orderbook */
export interface DerivativeOrderBook {
    marketId: string;
    isBuySide: boolean;
    orders: DerivativeLimitOrder[];
}
/** Orderbook containing limit & market conditional orders */
export interface ConditionalDerivativeOrderBook {
    marketId: string;
    limitBuyOrders: DerivativeLimitOrder[];
    marketBuyOrders: DerivativeMarketOrder[];
    limitSellOrders: DerivativeLimitOrder[];
    marketSellOrders: DerivativeMarketOrder[];
}
export interface SubaccountOrderbookMetadata {
    /** The number of vanilla limit orders */
    vanillaLimitOrderCount: number;
    /** The number of reduce-only limit orders */
    reduceOnlyLimitOrderCount: number;
    /**
     * The aggregate quantity of the subaccount's reduce-only limit orders (in
     * human readable format)
     */
    aggregateReduceOnlyQuantity: string;
    /**
     * The aggregate quantity of the subaccount's vanilla limit orders (in human
     * readable format)
     */
    aggregateVanillaQuantity: string;
    /** The number of vanilla conditional orders */
    vanillaConditionalOrderCount: number;
    /** The number of reduce-only conditional orders */
    reduceOnlyConditionalOrderCount: number;
}
export declare const SpotOrderBook: {
    encode(message: SpotOrderBook, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): SpotOrderBook;
    fromJSON(object: any): SpotOrderBook;
    toJSON(message: SpotOrderBook): unknown;
    create(base?: DeepPartial<SpotOrderBook>): SpotOrderBook;
    fromPartial(object: DeepPartial<SpotOrderBook>): SpotOrderBook;
};
export declare const DerivativeOrderBook: {
    encode(message: DerivativeOrderBook, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): DerivativeOrderBook;
    fromJSON(object: any): DerivativeOrderBook;
    toJSON(message: DerivativeOrderBook): unknown;
    create(base?: DeepPartial<DerivativeOrderBook>): DerivativeOrderBook;
    fromPartial(object: DeepPartial<DerivativeOrderBook>): DerivativeOrderBook;
};
export declare const ConditionalDerivativeOrderBook: {
    encode(message: ConditionalDerivativeOrderBook, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ConditionalDerivativeOrderBook;
    fromJSON(object: any): ConditionalDerivativeOrderBook;
    toJSON(message: ConditionalDerivativeOrderBook): unknown;
    create(base?: DeepPartial<ConditionalDerivativeOrderBook>): ConditionalDerivativeOrderBook;
    fromPartial(object: DeepPartial<ConditionalDerivativeOrderBook>): ConditionalDerivativeOrderBook;
};
export declare const SubaccountOrderbookMetadata: {
    encode(message: SubaccountOrderbookMetadata, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): SubaccountOrderbookMetadata;
    fromJSON(object: any): SubaccountOrderbookMetadata;
    toJSON(message: SubaccountOrderbookMetadata): unknown;
    create(base?: DeepPartial<SubaccountOrderbookMetadata>): SubaccountOrderbookMetadata;
    fromPartial(object: DeepPartial<SubaccountOrderbookMetadata>): SubaccountOrderbookMetadata;
};
type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;
export type DeepPartial<T> = T extends Builtin ? T : T extends Array<infer U> ? Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial<T[K]>;
} : Partial<T>;
export {};
