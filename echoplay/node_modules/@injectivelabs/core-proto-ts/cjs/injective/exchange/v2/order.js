"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DerivativeLimitOrder = exports.DerivativeMarketOrder = exports.DerivativeOrder = exports.SpotLimitOrder = exports.SpotMarketOrder = exports.SpotOrder = exports.OrderInfo = exports.AtomicMarketOrderAccessLevel = exports.OrderMask = exports.OrderType = exports.protobufPackage = void 0;
exports.orderTypeFromJSON = orderTypeFromJSON;
exports.orderTypeToJSON = orderTypeToJSON;
exports.orderMaskFromJSON = orderMaskFromJSON;
exports.orderMaskToJSON = orderMaskToJSON;
exports.atomicMarketOrderAccessLevelFromJSON = atomicMarketOrderAccessLevelFromJSON;
exports.atomicMarketOrderAccessLevelToJSON = atomicMarketOrderAccessLevelToJSON;
/* eslint-disable */
var long_1 = __importDefault(require("long"));
var minimal_js_1 = __importDefault(require("protobufjs/minimal.js"));
exports.protobufPackage = "injective.exchange.v2";
exports.OrderType = {
    UNSPECIFIED: 0,
    BUY: 1,
    SELL: 2,
    STOP_BUY: 3,
    STOP_SELL: 4,
    TAKE_BUY: 5,
    TAKE_SELL: 6,
    BUY_PO: 7,
    SELL_PO: 8,
    BUY_ATOMIC: 9,
    SELL_ATOMIC: 10,
    UNRECOGNIZED: -1,
};
function orderTypeFromJSON(object) {
    switch (object) {
        case 0:
        case "UNSPECIFIED":
            return exports.OrderType.UNSPECIFIED;
        case 1:
        case "BUY":
            return exports.OrderType.BUY;
        case 2:
        case "SELL":
            return exports.OrderType.SELL;
        case 3:
        case "STOP_BUY":
            return exports.OrderType.STOP_BUY;
        case 4:
        case "STOP_SELL":
            return exports.OrderType.STOP_SELL;
        case 5:
        case "TAKE_BUY":
            return exports.OrderType.TAKE_BUY;
        case 6:
        case "TAKE_SELL":
            return exports.OrderType.TAKE_SELL;
        case 7:
        case "BUY_PO":
            return exports.OrderType.BUY_PO;
        case 8:
        case "SELL_PO":
            return exports.OrderType.SELL_PO;
        case 9:
        case "BUY_ATOMIC":
            return exports.OrderType.BUY_ATOMIC;
        case 10:
        case "SELL_ATOMIC":
            return exports.OrderType.SELL_ATOMIC;
        case -1:
        case "UNRECOGNIZED":
        default:
            return exports.OrderType.UNRECOGNIZED;
    }
}
function orderTypeToJSON(object) {
    switch (object) {
        case exports.OrderType.UNSPECIFIED:
            return "UNSPECIFIED";
        case exports.OrderType.BUY:
            return "BUY";
        case exports.OrderType.SELL:
            return "SELL";
        case exports.OrderType.STOP_BUY:
            return "STOP_BUY";
        case exports.OrderType.STOP_SELL:
            return "STOP_SELL";
        case exports.OrderType.TAKE_BUY:
            return "TAKE_BUY";
        case exports.OrderType.TAKE_SELL:
            return "TAKE_SELL";
        case exports.OrderType.BUY_PO:
            return "BUY_PO";
        case exports.OrderType.SELL_PO:
            return "SELL_PO";
        case exports.OrderType.BUY_ATOMIC:
            return "BUY_ATOMIC";
        case exports.OrderType.SELL_ATOMIC:
            return "SELL_ATOMIC";
        case exports.OrderType.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
exports.OrderMask = {
    UNUSED: 0,
    ANY: 1,
    REGULAR: 2,
    CONDITIONAL: 4,
    /** DIRECTION_BUY_OR_HIGHER - for conditional orders means HIGHER */
    DIRECTION_BUY_OR_HIGHER: 8,
    /** DIRECTION_SELL_OR_LOWER - for conditional orders means LOWER */
    DIRECTION_SELL_OR_LOWER: 16,
    TYPE_MARKET: 32,
    TYPE_LIMIT: 64,
    UNRECOGNIZED: -1,
};
function orderMaskFromJSON(object) {
    switch (object) {
        case 0:
        case "UNUSED":
            return exports.OrderMask.UNUSED;
        case 1:
        case "ANY":
            return exports.OrderMask.ANY;
        case 2:
        case "REGULAR":
            return exports.OrderMask.REGULAR;
        case 4:
        case "CONDITIONAL":
            return exports.OrderMask.CONDITIONAL;
        case 8:
        case "DIRECTION_BUY_OR_HIGHER":
            return exports.OrderMask.DIRECTION_BUY_OR_HIGHER;
        case 16:
        case "DIRECTION_SELL_OR_LOWER":
            return exports.OrderMask.DIRECTION_SELL_OR_LOWER;
        case 32:
        case "TYPE_MARKET":
            return exports.OrderMask.TYPE_MARKET;
        case 64:
        case "TYPE_LIMIT":
            return exports.OrderMask.TYPE_LIMIT;
        case -1:
        case "UNRECOGNIZED":
        default:
            return exports.OrderMask.UNRECOGNIZED;
    }
}
function orderMaskToJSON(object) {
    switch (object) {
        case exports.OrderMask.UNUSED:
            return "UNUSED";
        case exports.OrderMask.ANY:
            return "ANY";
        case exports.OrderMask.REGULAR:
            return "REGULAR";
        case exports.OrderMask.CONDITIONAL:
            return "CONDITIONAL";
        case exports.OrderMask.DIRECTION_BUY_OR_HIGHER:
            return "DIRECTION_BUY_OR_HIGHER";
        case exports.OrderMask.DIRECTION_SELL_OR_LOWER:
            return "DIRECTION_SELL_OR_LOWER";
        case exports.OrderMask.TYPE_MARKET:
            return "TYPE_MARKET";
        case exports.OrderMask.TYPE_LIMIT:
            return "TYPE_LIMIT";
        case exports.OrderMask.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
exports.AtomicMarketOrderAccessLevel = {
    Nobody: 0,
    /** BeginBlockerSmartContractsOnly - currently unsupported */
    BeginBlockerSmartContractsOnly: 1,
    SmartContractsOnly: 2,
    Everyone: 3,
    UNRECOGNIZED: -1,
};
function atomicMarketOrderAccessLevelFromJSON(object) {
    switch (object) {
        case 0:
        case "Nobody":
            return exports.AtomicMarketOrderAccessLevel.Nobody;
        case 1:
        case "BeginBlockerSmartContractsOnly":
            return exports.AtomicMarketOrderAccessLevel.BeginBlockerSmartContractsOnly;
        case 2:
        case "SmartContractsOnly":
            return exports.AtomicMarketOrderAccessLevel.SmartContractsOnly;
        case 3:
        case "Everyone":
            return exports.AtomicMarketOrderAccessLevel.Everyone;
        case -1:
        case "UNRECOGNIZED":
        default:
            return exports.AtomicMarketOrderAccessLevel.UNRECOGNIZED;
    }
}
function atomicMarketOrderAccessLevelToJSON(object) {
    switch (object) {
        case exports.AtomicMarketOrderAccessLevel.Nobody:
            return "Nobody";
        case exports.AtomicMarketOrderAccessLevel.BeginBlockerSmartContractsOnly:
            return "BeginBlockerSmartContractsOnly";
        case exports.AtomicMarketOrderAccessLevel.SmartContractsOnly:
            return "SmartContractsOnly";
        case exports.AtomicMarketOrderAccessLevel.Everyone:
            return "Everyone";
        case exports.AtomicMarketOrderAccessLevel.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
function createBaseOrderInfo() {
    return { subaccountId: "", feeRecipient: "", price: "", quantity: "", cid: "" };
}
exports.OrderInfo = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_js_1.default.Writer.create(); }
        if (message.subaccountId !== "") {
            writer.uint32(10).string(message.subaccountId);
        }
        if (message.feeRecipient !== "") {
            writer.uint32(18).string(message.feeRecipient);
        }
        if (message.price !== "") {
            writer.uint32(26).string(message.price);
        }
        if (message.quantity !== "") {
            writer.uint32(34).string(message.quantity);
        }
        if (message.cid !== "") {
            writer.uint32(42).string(message.cid);
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_js_1.default.Reader ? input : new minimal_js_1.default.Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseOrderInfo();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.subaccountId = reader.string();
                    break;
                case 2:
                    message.feeRecipient = reader.string();
                    break;
                case 3:
                    message.price = reader.string();
                    break;
                case 4:
                    message.quantity = reader.string();
                    break;
                case 5:
                    message.cid = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            subaccountId: isSet(object.subaccountId) ? String(object.subaccountId) : "",
            feeRecipient: isSet(object.feeRecipient) ? String(object.feeRecipient) : "",
            price: isSet(object.price) ? String(object.price) : "",
            quantity: isSet(object.quantity) ? String(object.quantity) : "",
            cid: isSet(object.cid) ? String(object.cid) : "",
        };
    },
    toJSON: function (message) {
        var obj = {};
        message.subaccountId !== undefined && (obj.subaccountId = message.subaccountId);
        message.feeRecipient !== undefined && (obj.feeRecipient = message.feeRecipient);
        message.price !== undefined && (obj.price = message.price);
        message.quantity !== undefined && (obj.quantity = message.quantity);
        message.cid !== undefined && (obj.cid = message.cid);
        return obj;
    },
    create: function (base) {
        return exports.OrderInfo.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var _a, _b, _c, _d, _e;
        var message = createBaseOrderInfo();
        message.subaccountId = (_a = object.subaccountId) !== null && _a !== void 0 ? _a : "";
        message.feeRecipient = (_b = object.feeRecipient) !== null && _b !== void 0 ? _b : "";
        message.price = (_c = object.price) !== null && _c !== void 0 ? _c : "";
        message.quantity = (_d = object.quantity) !== null && _d !== void 0 ? _d : "";
        message.cid = (_e = object.cid) !== null && _e !== void 0 ? _e : "";
        return message;
    },
};
function createBaseSpotOrder() {
    return { marketId: "", orderInfo: undefined, orderType: 0, triggerPrice: "", expirationBlock: "0" };
}
exports.SpotOrder = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_js_1.default.Writer.create(); }
        if (message.marketId !== "") {
            writer.uint32(10).string(message.marketId);
        }
        if (message.orderInfo !== undefined) {
            exports.OrderInfo.encode(message.orderInfo, writer.uint32(18).fork()).ldelim();
        }
        if (message.orderType !== 0) {
            writer.uint32(24).int32(message.orderType);
        }
        if (message.triggerPrice !== "") {
            writer.uint32(34).string(message.triggerPrice);
        }
        if (message.expirationBlock !== "0") {
            writer.uint32(40).int64(message.expirationBlock);
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_js_1.default.Reader ? input : new minimal_js_1.default.Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseSpotOrder();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.marketId = reader.string();
                    break;
                case 2:
                    message.orderInfo = exports.OrderInfo.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.orderType = reader.int32();
                    break;
                case 4:
                    message.triggerPrice = reader.string();
                    break;
                case 5:
                    message.expirationBlock = longToString(reader.int64());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            marketId: isSet(object.marketId) ? String(object.marketId) : "",
            orderInfo: isSet(object.orderInfo) ? exports.OrderInfo.fromJSON(object.orderInfo) : undefined,
            orderType: isSet(object.orderType) ? orderTypeFromJSON(object.orderType) : 0,
            triggerPrice: isSet(object.triggerPrice) ? String(object.triggerPrice) : "",
            expirationBlock: isSet(object.expirationBlock) ? String(object.expirationBlock) : "0",
        };
    },
    toJSON: function (message) {
        var obj = {};
        message.marketId !== undefined && (obj.marketId = message.marketId);
        message.orderInfo !== undefined &&
            (obj.orderInfo = message.orderInfo ? exports.OrderInfo.toJSON(message.orderInfo) : undefined);
        message.orderType !== undefined && (obj.orderType = orderTypeToJSON(message.orderType));
        message.triggerPrice !== undefined && (obj.triggerPrice = message.triggerPrice);
        message.expirationBlock !== undefined && (obj.expirationBlock = message.expirationBlock);
        return obj;
    },
    create: function (base) {
        return exports.SpotOrder.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var _a, _b, _c, _d;
        var message = createBaseSpotOrder();
        message.marketId = (_a = object.marketId) !== null && _a !== void 0 ? _a : "";
        message.orderInfo = (object.orderInfo !== undefined && object.orderInfo !== null)
            ? exports.OrderInfo.fromPartial(object.orderInfo)
            : undefined;
        message.orderType = (_b = object.orderType) !== null && _b !== void 0 ? _b : 0;
        message.triggerPrice = (_c = object.triggerPrice) !== null && _c !== void 0 ? _c : "";
        message.expirationBlock = (_d = object.expirationBlock) !== null && _d !== void 0 ? _d : "0";
        return message;
    },
};
function createBaseSpotMarketOrder() {
    return { orderInfo: undefined, balanceHold: "", orderHash: new Uint8Array(), orderType: 0, triggerPrice: "" };
}
exports.SpotMarketOrder = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_js_1.default.Writer.create(); }
        if (message.orderInfo !== undefined) {
            exports.OrderInfo.encode(message.orderInfo, writer.uint32(10).fork()).ldelim();
        }
        if (message.balanceHold !== "") {
            writer.uint32(18).string(message.balanceHold);
        }
        if (message.orderHash.length !== 0) {
            writer.uint32(26).bytes(message.orderHash);
        }
        if (message.orderType !== 0) {
            writer.uint32(32).int32(message.orderType);
        }
        if (message.triggerPrice !== "") {
            writer.uint32(42).string(message.triggerPrice);
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_js_1.default.Reader ? input : new minimal_js_1.default.Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseSpotMarketOrder();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.orderInfo = exports.OrderInfo.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.balanceHold = reader.string();
                    break;
                case 3:
                    message.orderHash = reader.bytes();
                    break;
                case 4:
                    message.orderType = reader.int32();
                    break;
                case 5:
                    message.triggerPrice = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            orderInfo: isSet(object.orderInfo) ? exports.OrderInfo.fromJSON(object.orderInfo) : undefined,
            balanceHold: isSet(object.balanceHold) ? String(object.balanceHold) : "",
            orderHash: isSet(object.orderHash) ? bytesFromBase64(object.orderHash) : new Uint8Array(),
            orderType: isSet(object.orderType) ? orderTypeFromJSON(object.orderType) : 0,
            triggerPrice: isSet(object.triggerPrice) ? String(object.triggerPrice) : "",
        };
    },
    toJSON: function (message) {
        var obj = {};
        message.orderInfo !== undefined &&
            (obj.orderInfo = message.orderInfo ? exports.OrderInfo.toJSON(message.orderInfo) : undefined);
        message.balanceHold !== undefined && (obj.balanceHold = message.balanceHold);
        message.orderHash !== undefined &&
            (obj.orderHash = base64FromBytes(message.orderHash !== undefined ? message.orderHash : new Uint8Array()));
        message.orderType !== undefined && (obj.orderType = orderTypeToJSON(message.orderType));
        message.triggerPrice !== undefined && (obj.triggerPrice = message.triggerPrice);
        return obj;
    },
    create: function (base) {
        return exports.SpotMarketOrder.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var _a, _b, _c, _d;
        var message = createBaseSpotMarketOrder();
        message.orderInfo = (object.orderInfo !== undefined && object.orderInfo !== null)
            ? exports.OrderInfo.fromPartial(object.orderInfo)
            : undefined;
        message.balanceHold = (_a = object.balanceHold) !== null && _a !== void 0 ? _a : "";
        message.orderHash = (_b = object.orderHash) !== null && _b !== void 0 ? _b : new Uint8Array();
        message.orderType = (_c = object.orderType) !== null && _c !== void 0 ? _c : 0;
        message.triggerPrice = (_d = object.triggerPrice) !== null && _d !== void 0 ? _d : "";
        return message;
    },
};
function createBaseSpotLimitOrder() {
    return {
        orderInfo: undefined,
        orderType: 0,
        fillable: "",
        triggerPrice: "",
        orderHash: new Uint8Array(),
        expirationBlock: "0",
    };
}
exports.SpotLimitOrder = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_js_1.default.Writer.create(); }
        if (message.orderInfo !== undefined) {
            exports.OrderInfo.encode(message.orderInfo, writer.uint32(10).fork()).ldelim();
        }
        if (message.orderType !== 0) {
            writer.uint32(16).int32(message.orderType);
        }
        if (message.fillable !== "") {
            writer.uint32(26).string(message.fillable);
        }
        if (message.triggerPrice !== "") {
            writer.uint32(34).string(message.triggerPrice);
        }
        if (message.orderHash.length !== 0) {
            writer.uint32(42).bytes(message.orderHash);
        }
        if (message.expirationBlock !== "0") {
            writer.uint32(48).int64(message.expirationBlock);
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_js_1.default.Reader ? input : new minimal_js_1.default.Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseSpotLimitOrder();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.orderInfo = exports.OrderInfo.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.orderType = reader.int32();
                    break;
                case 3:
                    message.fillable = reader.string();
                    break;
                case 4:
                    message.triggerPrice = reader.string();
                    break;
                case 5:
                    message.orderHash = reader.bytes();
                    break;
                case 6:
                    message.expirationBlock = longToString(reader.int64());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            orderInfo: isSet(object.orderInfo) ? exports.OrderInfo.fromJSON(object.orderInfo) : undefined,
            orderType: isSet(object.orderType) ? orderTypeFromJSON(object.orderType) : 0,
            fillable: isSet(object.fillable) ? String(object.fillable) : "",
            triggerPrice: isSet(object.triggerPrice) ? String(object.triggerPrice) : "",
            orderHash: isSet(object.orderHash) ? bytesFromBase64(object.orderHash) : new Uint8Array(),
            expirationBlock: isSet(object.expirationBlock) ? String(object.expirationBlock) : "0",
        };
    },
    toJSON: function (message) {
        var obj = {};
        message.orderInfo !== undefined &&
            (obj.orderInfo = message.orderInfo ? exports.OrderInfo.toJSON(message.orderInfo) : undefined);
        message.orderType !== undefined && (obj.orderType = orderTypeToJSON(message.orderType));
        message.fillable !== undefined && (obj.fillable = message.fillable);
        message.triggerPrice !== undefined && (obj.triggerPrice = message.triggerPrice);
        message.orderHash !== undefined &&
            (obj.orderHash = base64FromBytes(message.orderHash !== undefined ? message.orderHash : new Uint8Array()));
        message.expirationBlock !== undefined && (obj.expirationBlock = message.expirationBlock);
        return obj;
    },
    create: function (base) {
        return exports.SpotLimitOrder.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var _a, _b, _c, _d, _e;
        var message = createBaseSpotLimitOrder();
        message.orderInfo = (object.orderInfo !== undefined && object.orderInfo !== null)
            ? exports.OrderInfo.fromPartial(object.orderInfo)
            : undefined;
        message.orderType = (_a = object.orderType) !== null && _a !== void 0 ? _a : 0;
        message.fillable = (_b = object.fillable) !== null && _b !== void 0 ? _b : "";
        message.triggerPrice = (_c = object.triggerPrice) !== null && _c !== void 0 ? _c : "";
        message.orderHash = (_d = object.orderHash) !== null && _d !== void 0 ? _d : new Uint8Array();
        message.expirationBlock = (_e = object.expirationBlock) !== null && _e !== void 0 ? _e : "0";
        return message;
    },
};
function createBaseDerivativeOrder() {
    return { marketId: "", orderInfo: undefined, orderType: 0, margin: "", triggerPrice: "", expirationBlock: "0" };
}
exports.DerivativeOrder = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_js_1.default.Writer.create(); }
        if (message.marketId !== "") {
            writer.uint32(10).string(message.marketId);
        }
        if (message.orderInfo !== undefined) {
            exports.OrderInfo.encode(message.orderInfo, writer.uint32(18).fork()).ldelim();
        }
        if (message.orderType !== 0) {
            writer.uint32(24).int32(message.orderType);
        }
        if (message.margin !== "") {
            writer.uint32(34).string(message.margin);
        }
        if (message.triggerPrice !== "") {
            writer.uint32(42).string(message.triggerPrice);
        }
        if (message.expirationBlock !== "0") {
            writer.uint32(48).int64(message.expirationBlock);
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_js_1.default.Reader ? input : new minimal_js_1.default.Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseDerivativeOrder();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.marketId = reader.string();
                    break;
                case 2:
                    message.orderInfo = exports.OrderInfo.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.orderType = reader.int32();
                    break;
                case 4:
                    message.margin = reader.string();
                    break;
                case 5:
                    message.triggerPrice = reader.string();
                    break;
                case 6:
                    message.expirationBlock = longToString(reader.int64());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            marketId: isSet(object.marketId) ? String(object.marketId) : "",
            orderInfo: isSet(object.orderInfo) ? exports.OrderInfo.fromJSON(object.orderInfo) : undefined,
            orderType: isSet(object.orderType) ? orderTypeFromJSON(object.orderType) : 0,
            margin: isSet(object.margin) ? String(object.margin) : "",
            triggerPrice: isSet(object.triggerPrice) ? String(object.triggerPrice) : "",
            expirationBlock: isSet(object.expirationBlock) ? String(object.expirationBlock) : "0",
        };
    },
    toJSON: function (message) {
        var obj = {};
        message.marketId !== undefined && (obj.marketId = message.marketId);
        message.orderInfo !== undefined &&
            (obj.orderInfo = message.orderInfo ? exports.OrderInfo.toJSON(message.orderInfo) : undefined);
        message.orderType !== undefined && (obj.orderType = orderTypeToJSON(message.orderType));
        message.margin !== undefined && (obj.margin = message.margin);
        message.triggerPrice !== undefined && (obj.triggerPrice = message.triggerPrice);
        message.expirationBlock !== undefined && (obj.expirationBlock = message.expirationBlock);
        return obj;
    },
    create: function (base) {
        return exports.DerivativeOrder.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var _a, _b, _c, _d, _e;
        var message = createBaseDerivativeOrder();
        message.marketId = (_a = object.marketId) !== null && _a !== void 0 ? _a : "";
        message.orderInfo = (object.orderInfo !== undefined && object.orderInfo !== null)
            ? exports.OrderInfo.fromPartial(object.orderInfo)
            : undefined;
        message.orderType = (_b = object.orderType) !== null && _b !== void 0 ? _b : 0;
        message.margin = (_c = object.margin) !== null && _c !== void 0 ? _c : "";
        message.triggerPrice = (_d = object.triggerPrice) !== null && _d !== void 0 ? _d : "";
        message.expirationBlock = (_e = object.expirationBlock) !== null && _e !== void 0 ? _e : "0";
        return message;
    },
};
function createBaseDerivativeMarketOrder() {
    return {
        orderInfo: undefined,
        orderType: 0,
        margin: "",
        marginHold: "",
        triggerPrice: "",
        orderHash: new Uint8Array(),
    };
}
exports.DerivativeMarketOrder = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_js_1.default.Writer.create(); }
        if (message.orderInfo !== undefined) {
            exports.OrderInfo.encode(message.orderInfo, writer.uint32(10).fork()).ldelim();
        }
        if (message.orderType !== 0) {
            writer.uint32(16).int32(message.orderType);
        }
        if (message.margin !== "") {
            writer.uint32(26).string(message.margin);
        }
        if (message.marginHold !== "") {
            writer.uint32(34).string(message.marginHold);
        }
        if (message.triggerPrice !== "") {
            writer.uint32(42).string(message.triggerPrice);
        }
        if (message.orderHash.length !== 0) {
            writer.uint32(50).bytes(message.orderHash);
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_js_1.default.Reader ? input : new minimal_js_1.default.Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseDerivativeMarketOrder();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.orderInfo = exports.OrderInfo.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.orderType = reader.int32();
                    break;
                case 3:
                    message.margin = reader.string();
                    break;
                case 4:
                    message.marginHold = reader.string();
                    break;
                case 5:
                    message.triggerPrice = reader.string();
                    break;
                case 6:
                    message.orderHash = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            orderInfo: isSet(object.orderInfo) ? exports.OrderInfo.fromJSON(object.orderInfo) : undefined,
            orderType: isSet(object.orderType) ? orderTypeFromJSON(object.orderType) : 0,
            margin: isSet(object.margin) ? String(object.margin) : "",
            marginHold: isSet(object.marginHold) ? String(object.marginHold) : "",
            triggerPrice: isSet(object.triggerPrice) ? String(object.triggerPrice) : "",
            orderHash: isSet(object.orderHash) ? bytesFromBase64(object.orderHash) : new Uint8Array(),
        };
    },
    toJSON: function (message) {
        var obj = {};
        message.orderInfo !== undefined &&
            (obj.orderInfo = message.orderInfo ? exports.OrderInfo.toJSON(message.orderInfo) : undefined);
        message.orderType !== undefined && (obj.orderType = orderTypeToJSON(message.orderType));
        message.margin !== undefined && (obj.margin = message.margin);
        message.marginHold !== undefined && (obj.marginHold = message.marginHold);
        message.triggerPrice !== undefined && (obj.triggerPrice = message.triggerPrice);
        message.orderHash !== undefined &&
            (obj.orderHash = base64FromBytes(message.orderHash !== undefined ? message.orderHash : new Uint8Array()));
        return obj;
    },
    create: function (base) {
        return exports.DerivativeMarketOrder.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var _a, _b, _c, _d, _e;
        var message = createBaseDerivativeMarketOrder();
        message.orderInfo = (object.orderInfo !== undefined && object.orderInfo !== null)
            ? exports.OrderInfo.fromPartial(object.orderInfo)
            : undefined;
        message.orderType = (_a = object.orderType) !== null && _a !== void 0 ? _a : 0;
        message.margin = (_b = object.margin) !== null && _b !== void 0 ? _b : "";
        message.marginHold = (_c = object.marginHold) !== null && _c !== void 0 ? _c : "";
        message.triggerPrice = (_d = object.triggerPrice) !== null && _d !== void 0 ? _d : "";
        message.orderHash = (_e = object.orderHash) !== null && _e !== void 0 ? _e : new Uint8Array();
        return message;
    },
};
function createBaseDerivativeLimitOrder() {
    return {
        orderInfo: undefined,
        orderType: 0,
        margin: "",
        fillable: "",
        triggerPrice: "",
        orderHash: new Uint8Array(),
        expirationBlock: "0",
    };
}
exports.DerivativeLimitOrder = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_js_1.default.Writer.create(); }
        if (message.orderInfo !== undefined) {
            exports.OrderInfo.encode(message.orderInfo, writer.uint32(10).fork()).ldelim();
        }
        if (message.orderType !== 0) {
            writer.uint32(16).int32(message.orderType);
        }
        if (message.margin !== "") {
            writer.uint32(26).string(message.margin);
        }
        if (message.fillable !== "") {
            writer.uint32(34).string(message.fillable);
        }
        if (message.triggerPrice !== "") {
            writer.uint32(42).string(message.triggerPrice);
        }
        if (message.orderHash.length !== 0) {
            writer.uint32(50).bytes(message.orderHash);
        }
        if (message.expirationBlock !== "0") {
            writer.uint32(56).int64(message.expirationBlock);
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_js_1.default.Reader ? input : new minimal_js_1.default.Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseDerivativeLimitOrder();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.orderInfo = exports.OrderInfo.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.orderType = reader.int32();
                    break;
                case 3:
                    message.margin = reader.string();
                    break;
                case 4:
                    message.fillable = reader.string();
                    break;
                case 5:
                    message.triggerPrice = reader.string();
                    break;
                case 6:
                    message.orderHash = reader.bytes();
                    break;
                case 7:
                    message.expirationBlock = longToString(reader.int64());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            orderInfo: isSet(object.orderInfo) ? exports.OrderInfo.fromJSON(object.orderInfo) : undefined,
            orderType: isSet(object.orderType) ? orderTypeFromJSON(object.orderType) : 0,
            margin: isSet(object.margin) ? String(object.margin) : "",
            fillable: isSet(object.fillable) ? String(object.fillable) : "",
            triggerPrice: isSet(object.triggerPrice) ? String(object.triggerPrice) : "",
            orderHash: isSet(object.orderHash) ? bytesFromBase64(object.orderHash) : new Uint8Array(),
            expirationBlock: isSet(object.expirationBlock) ? String(object.expirationBlock) : "0",
        };
    },
    toJSON: function (message) {
        var obj = {};
        message.orderInfo !== undefined &&
            (obj.orderInfo = message.orderInfo ? exports.OrderInfo.toJSON(message.orderInfo) : undefined);
        message.orderType !== undefined && (obj.orderType = orderTypeToJSON(message.orderType));
        message.margin !== undefined && (obj.margin = message.margin);
        message.fillable !== undefined && (obj.fillable = message.fillable);
        message.triggerPrice !== undefined && (obj.triggerPrice = message.triggerPrice);
        message.orderHash !== undefined &&
            (obj.orderHash = base64FromBytes(message.orderHash !== undefined ? message.orderHash : new Uint8Array()));
        message.expirationBlock !== undefined && (obj.expirationBlock = message.expirationBlock);
        return obj;
    },
    create: function (base) {
        return exports.DerivativeLimitOrder.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var _a, _b, _c, _d, _e, _f;
        var message = createBaseDerivativeLimitOrder();
        message.orderInfo = (object.orderInfo !== undefined && object.orderInfo !== null)
            ? exports.OrderInfo.fromPartial(object.orderInfo)
            : undefined;
        message.orderType = (_a = object.orderType) !== null && _a !== void 0 ? _a : 0;
        message.margin = (_b = object.margin) !== null && _b !== void 0 ? _b : "";
        message.fillable = (_c = object.fillable) !== null && _c !== void 0 ? _c : "";
        message.triggerPrice = (_d = object.triggerPrice) !== null && _d !== void 0 ? _d : "";
        message.orderHash = (_e = object.orderHash) !== null && _e !== void 0 ? _e : new Uint8Array();
        message.expirationBlock = (_f = object.expirationBlock) !== null && _f !== void 0 ? _f : "0";
        return message;
    },
};
var tsProtoGlobalThis = (function () {
    if (typeof globalThis !== "undefined") {
        return globalThis;
    }
    if (typeof self !== "undefined") {
        return self;
    }
    if (typeof window !== "undefined") {
        return window;
    }
    if (typeof global !== "undefined") {
        return global;
    }
    throw "Unable to locate global object";
})();
function bytesFromBase64(b64) {
    if (tsProtoGlobalThis.Buffer) {
        return Uint8Array.from(tsProtoGlobalThis.Buffer.from(b64, "base64"));
    }
    else {
        var bin = tsProtoGlobalThis.atob(b64);
        var arr = new Uint8Array(bin.length);
        for (var i = 0; i < bin.length; ++i) {
            arr[i] = bin.charCodeAt(i);
        }
        return arr;
    }
}
function base64FromBytes(arr) {
    if (tsProtoGlobalThis.Buffer) {
        return tsProtoGlobalThis.Buffer.from(arr).toString("base64");
    }
    else {
        var bin_1 = [];
        arr.forEach(function (byte) {
            bin_1.push(String.fromCharCode(byte));
        });
        return tsProtoGlobalThis.btoa(bin_1.join(""));
    }
}
function longToString(long) {
    return long.toString();
}
if (minimal_js_1.default.util.Long !== long_1.default) {
    minimal_js_1.default.util.Long = long_1.default;
    minimal_js_1.default.configure();
}
function isSet(value) {
    return value !== null && value !== undefined;
}
