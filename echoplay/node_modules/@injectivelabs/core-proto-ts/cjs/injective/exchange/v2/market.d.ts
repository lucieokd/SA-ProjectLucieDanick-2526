import _m0 from "protobufjs/minimal.js";
import { OracleType } from "../../oracle/v1beta1/oracle";
export declare const protobufPackage = "injective.exchange.v2";
export declare const MarketStatus: {
    readonly Unspecified: 0;
    readonly Active: 1;
    readonly Paused: 2;
    readonly Demolished: 3;
    readonly Expired: 4;
    readonly UNRECOGNIZED: -1;
};
export type MarketStatus = typeof MarketStatus[keyof typeof MarketStatus];
export declare function marketStatusFromJSON(object: any): MarketStatus;
export declare function marketStatusToJSON(object: MarketStatus): string;
export interface MarketFeeMultiplier {
    marketId: string;
    feeMultiplier: string;
}
/** An object describing trade pair of two assets. */
export interface SpotMarket {
    /**
     * A name of the pair in format AAA/BBB, where AAA is base asset, BBB is quote
     * asset.
     */
    ticker: string;
    /** Coin denom used for the base asset */
    baseDenom: string;
    /** Coin used for the quote asset */
    quoteDenom: string;
    /** maker_fee_rate defines the fee percentage makers pay when trading */
    makerFeeRate: string;
    /** taker_fee_rate defines the fee percentage takers pay when trading */
    takerFeeRate: string;
    /**
     * relayer_fee_share_rate defines the percentage of the transaction fee shared
     * with the relayer in a derivative market
     */
    relayerFeeShareRate: string;
    /** Unique market ID. */
    marketId: string;
    /** Status of the market */
    status: MarketStatus;
    /**
     * min_price_tick_size defines the minimum tick size that the price required
     * for orders in the market (in human readable format)
     */
    minPriceTickSize: string;
    /**
     * min_quantity_tick_size defines the minimum tick size of the quantity
     * required for orders in the market (in human readable format)
     */
    minQuantityTickSize: string;
    /**
     * min_notional defines the minimum notional (in quote asset) required for
     * orders in the market (in human readable format)
     */
    minNotional: string;
    /** current market admin */
    admin: string;
    /** level of admin permissions */
    adminPermissions: number;
    /** base token decimals */
    baseDecimals: number;
    /** quote token decimals */
    quoteDecimals: number;
}
/** An object describing a binary options market in Injective Protocol. */
export interface BinaryOptionsMarket {
    /** Ticker for the derivative contract. */
    ticker: string;
    /** Oracle symbol */
    oracleSymbol: string;
    /** Oracle Provider */
    oracleProvider: string;
    /** Oracle type */
    oracleType: OracleType;
    /** Scale factor for oracle prices. */
    oracleScaleFactor: number;
    /** expiration timestamp */
    expirationTimestamp: string;
    /** expiration timestamp */
    settlementTimestamp: string;
    /** admin of the market */
    admin: string;
    /** Address of the quote currency denomination for the binary options contract */
    quoteDenom: string;
    /** Unique market ID. */
    marketId: string;
    /** maker_fee_rate defines the maker fee rate of a binary options market */
    makerFeeRate: string;
    /** taker_fee_rate defines the taker fee rate of a derivative market */
    takerFeeRate: string;
    /**
     * relayer_fee_share_rate defines the percentage of the transaction fee shared
     * with the relayer in a derivative market
     */
    relayerFeeShareRate: string;
    /** Status of the market */
    status: MarketStatus;
    /**
     * min_price_tick_size defines the minimum tick size that the price and margin
     * required for orders in the market (in human readable format)
     */
    minPriceTickSize: string;
    /**
     * min_quantity_tick_size defines the minimum tick size of the quantity
     * required for orders in the market (in human readable format)
     */
    minQuantityTickSize: string;
    /**
     * settlement_price defines the settlement price of the binary options market
     * (in human readable format)
     */
    settlementPrice: string;
    /**
     * min_notional defines the minimum notional (in quote asset) required for
     * orders in the market (in human readable format)
     */
    minNotional: string;
    /** level of admin permissions */
    adminPermissions: number;
    /** quote token decimals */
    quoteDecimals: number;
}
/** An object describing a derivative market in the Injective Futures Protocol. */
export interface DerivativeMarket {
    /** Ticker for the derivative contract. */
    ticker: string;
    /** Oracle base currency */
    oracleBase: string;
    /** Oracle quote currency */
    oracleQuote: string;
    /** Oracle type */
    oracleType: OracleType;
    /** Scale factor for oracle prices. */
    oracleScaleFactor: number;
    /** Address of the quote currency denomination for the derivative contract */
    quoteDenom: string;
    /** Unique market ID. */
    marketId: string;
    /**
     * initial_margin_ratio defines the initial margin ratio of a derivative
     * market
     */
    initialMarginRatio: string;
    /**
     * maintenance_margin_ratio defines the maintenance margin ratio of a
     * derivative market
     */
    maintenanceMarginRatio: string;
    /** maker_fee_rate defines the maker fee rate of a derivative market */
    makerFeeRate: string;
    /** taker_fee_rate defines the taker fee rate of a derivative market */
    takerFeeRate: string;
    /**
     * relayer_fee_share_rate defines the percentage of the transaction fee shared
     * with the relayer in a derivative market
     */
    relayerFeeShareRate: string;
    /**
     * true if the market is a perpetual market. false if the market is an expiry
     * futures market
     */
    isPerpetual: boolean;
    /** Status of the market */
    status: MarketStatus;
    /**
     * min_price_tick_size defines the minimum tick size that the price and margin
     * required for orders in the market (in human readable format)
     */
    minPriceTickSize: string;
    /**
     * min_quantity_tick_size defines the minimum tick size of the quantity
     * required for orders in the market (in human readable format)
     */
    minQuantityTickSize: string;
    /**
     * min_notional defines the minimum notional (in quote asset) required for
     * orders in the market (in human readable format)
     */
    minNotional: string;
    /** current market admin */
    admin: string;
    /** level of admin permissions */
    adminPermissions: number;
    /** quote token decimals */
    quoteDecimals: number;
    /** reduce_margin_ratio defines the ratio of the margin that is reduced */
    reduceMarginRatio: string;
}
export interface DerivativeMarketSettlementInfo {
    /** market ID. */
    marketId: string;
    /** settlement_price defines the settlement price */
    settlementPrice: string;
}
export interface MarketVolume {
    /** the market ID */
    marketId: string;
    /** the market volume */
    volume: VolumeRecord | undefined;
}
export interface VolumeRecord {
    /** the market's maker volume (in human readable format) */
    makerVolume: string;
    /** the market's taker volume (in human readable format) */
    takerVolume: string;
}
export interface ExpiryFuturesMarketInfoState {
    marketId: string;
    marketInfo: ExpiryFuturesMarketInfo | undefined;
}
export interface PerpetualMarketFundingState {
    marketId: string;
    funding: PerpetualMarketFunding | undefined;
}
export interface ExpiryFuturesMarketInfo {
    /** market ID. */
    marketId: string;
    /**
     * expiration_timestamp defines the expiration time for a time expiry futures
     * market.
     */
    expirationTimestamp: string;
    /**
     * expiration_twap_start_timestamp defines the start time of the TWAP
     * calculation window
     */
    twapStartTimestamp: string;
    /**
     * expiration_twap_start_price_cumulative defines the cumulative price for the
     * start of the TWAP window (in human readable format)
     */
    expirationTwapStartPriceCumulative: string;
    /**
     * settlement_price defines the settlement price for a time expiry futures
     * market (in human readable format)
     */
    settlementPrice: string;
}
export interface PerpetualMarketInfo {
    /** market ID. */
    marketId: string;
    /**
     * hourly_funding_rate_cap defines the maximum absolute value of the hourly
     * funding rate
     */
    hourlyFundingRateCap: string;
    /** hourly_interest_rate defines the hourly interest rate */
    hourlyInterestRate: string;
    /**
     * next_funding_timestamp defines the next funding timestamp in seconds of a
     * perpetual market
     */
    nextFundingTimestamp: string;
    /**
     * funding_interval defines the next funding interval in seconds of a
     * perpetual market.
     */
    fundingInterval: string;
}
export interface PerpetualMarketFunding {
    /** cumulative_funding defines the cumulative funding of a perpetual market. */
    cumulativeFunding: string;
    /**
     * cumulative_price defines the running time-integral of the perp premium
     * ((VWAP - mark_price) / mark_price) i.e., sum(premium * seconds)
     * used to compute the intervalâ€™s average premium for funding
     */
    cumulativePrice: string;
    /** the last funding timestamp in seconds */
    lastTimestamp: string;
}
export declare const MarketFeeMultiplier: {
    encode(message: MarketFeeMultiplier, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MarketFeeMultiplier;
    fromJSON(object: any): MarketFeeMultiplier;
    toJSON(message: MarketFeeMultiplier): unknown;
    create(base?: DeepPartial<MarketFeeMultiplier>): MarketFeeMultiplier;
    fromPartial(object: DeepPartial<MarketFeeMultiplier>): MarketFeeMultiplier;
};
export declare const SpotMarket: {
    encode(message: SpotMarket, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): SpotMarket;
    fromJSON(object: any): SpotMarket;
    toJSON(message: SpotMarket): unknown;
    create(base?: DeepPartial<SpotMarket>): SpotMarket;
    fromPartial(object: DeepPartial<SpotMarket>): SpotMarket;
};
export declare const BinaryOptionsMarket: {
    encode(message: BinaryOptionsMarket, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): BinaryOptionsMarket;
    fromJSON(object: any): BinaryOptionsMarket;
    toJSON(message: BinaryOptionsMarket): unknown;
    create(base?: DeepPartial<BinaryOptionsMarket>): BinaryOptionsMarket;
    fromPartial(object: DeepPartial<BinaryOptionsMarket>): BinaryOptionsMarket;
};
export declare const DerivativeMarket: {
    encode(message: DerivativeMarket, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): DerivativeMarket;
    fromJSON(object: any): DerivativeMarket;
    toJSON(message: DerivativeMarket): unknown;
    create(base?: DeepPartial<DerivativeMarket>): DerivativeMarket;
    fromPartial(object: DeepPartial<DerivativeMarket>): DerivativeMarket;
};
export declare const DerivativeMarketSettlementInfo: {
    encode(message: DerivativeMarketSettlementInfo, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): DerivativeMarketSettlementInfo;
    fromJSON(object: any): DerivativeMarketSettlementInfo;
    toJSON(message: DerivativeMarketSettlementInfo): unknown;
    create(base?: DeepPartial<DerivativeMarketSettlementInfo>): DerivativeMarketSettlementInfo;
    fromPartial(object: DeepPartial<DerivativeMarketSettlementInfo>): DerivativeMarketSettlementInfo;
};
export declare const MarketVolume: {
    encode(message: MarketVolume, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MarketVolume;
    fromJSON(object: any): MarketVolume;
    toJSON(message: MarketVolume): unknown;
    create(base?: DeepPartial<MarketVolume>): MarketVolume;
    fromPartial(object: DeepPartial<MarketVolume>): MarketVolume;
};
export declare const VolumeRecord: {
    encode(message: VolumeRecord, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): VolumeRecord;
    fromJSON(object: any): VolumeRecord;
    toJSON(message: VolumeRecord): unknown;
    create(base?: DeepPartial<VolumeRecord>): VolumeRecord;
    fromPartial(object: DeepPartial<VolumeRecord>): VolumeRecord;
};
export declare const ExpiryFuturesMarketInfoState: {
    encode(message: ExpiryFuturesMarketInfoState, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ExpiryFuturesMarketInfoState;
    fromJSON(object: any): ExpiryFuturesMarketInfoState;
    toJSON(message: ExpiryFuturesMarketInfoState): unknown;
    create(base?: DeepPartial<ExpiryFuturesMarketInfoState>): ExpiryFuturesMarketInfoState;
    fromPartial(object: DeepPartial<ExpiryFuturesMarketInfoState>): ExpiryFuturesMarketInfoState;
};
export declare const PerpetualMarketFundingState: {
    encode(message: PerpetualMarketFundingState, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): PerpetualMarketFundingState;
    fromJSON(object: any): PerpetualMarketFundingState;
    toJSON(message: PerpetualMarketFundingState): unknown;
    create(base?: DeepPartial<PerpetualMarketFundingState>): PerpetualMarketFundingState;
    fromPartial(object: DeepPartial<PerpetualMarketFundingState>): PerpetualMarketFundingState;
};
export declare const ExpiryFuturesMarketInfo: {
    encode(message: ExpiryFuturesMarketInfo, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ExpiryFuturesMarketInfo;
    fromJSON(object: any): ExpiryFuturesMarketInfo;
    toJSON(message: ExpiryFuturesMarketInfo): unknown;
    create(base?: DeepPartial<ExpiryFuturesMarketInfo>): ExpiryFuturesMarketInfo;
    fromPartial(object: DeepPartial<ExpiryFuturesMarketInfo>): ExpiryFuturesMarketInfo;
};
export declare const PerpetualMarketInfo: {
    encode(message: PerpetualMarketInfo, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): PerpetualMarketInfo;
    fromJSON(object: any): PerpetualMarketInfo;
    toJSON(message: PerpetualMarketInfo): unknown;
    create(base?: DeepPartial<PerpetualMarketInfo>): PerpetualMarketInfo;
    fromPartial(object: DeepPartial<PerpetualMarketInfo>): PerpetualMarketInfo;
};
export declare const PerpetualMarketFunding: {
    encode(message: PerpetualMarketFunding, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): PerpetualMarketFunding;
    fromJSON(object: any): PerpetualMarketFunding;
    toJSON(message: PerpetualMarketFunding): unknown;
    create(base?: DeepPartial<PerpetualMarketFunding>): PerpetualMarketFunding;
    fromPartial(object: DeepPartial<PerpetualMarketFunding>): PerpetualMarketFunding;
};
type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;
export type DeepPartial<T> = T extends Builtin ? T : T extends Array<infer U> ? Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial<T[K]>;
} : Partial<T>;
export {};
