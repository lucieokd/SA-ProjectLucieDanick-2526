/* eslint-disable */
import _m0 from "protobufjs/minimal.js";
import { DerivativeLimitOrder, DerivativeMarketOrder, SpotLimitOrder } from "./order.js";
export const protobufPackage = "injective.exchange.v2";
function createBaseSpotOrderBook() {
    return { marketId: "", isBuySide: false, orders: [] };
}
export const SpotOrderBook = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.marketId !== "") {
            writer.uint32(10).string(message.marketId);
        }
        if (message.isBuySide === true) {
            writer.uint32(16).bool(message.isBuySide);
        }
        for (const v of message.orders) {
            SpotLimitOrder.encode(v, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSpotOrderBook();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.marketId = reader.string();
                    break;
                case 2:
                    message.isBuySide = reader.bool();
                    break;
                case 3:
                    message.orders.push(SpotLimitOrder.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            marketId: isSet(object.marketId) ? String(object.marketId) : "",
            isBuySide: isSet(object.isBuySide) ? Boolean(object.isBuySide) : false,
            orders: Array.isArray(object?.orders) ? object.orders.map((e) => SpotLimitOrder.fromJSON(e)) : [],
        };
    },
    toJSON(message) {
        const obj = {};
        message.marketId !== undefined && (obj.marketId = message.marketId);
        message.isBuySide !== undefined && (obj.isBuySide = message.isBuySide);
        if (message.orders) {
            obj.orders = message.orders.map((e) => e ? SpotLimitOrder.toJSON(e) : undefined);
        }
        else {
            obj.orders = [];
        }
        return obj;
    },
    create(base) {
        return SpotOrderBook.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseSpotOrderBook();
        message.marketId = object.marketId ?? "";
        message.isBuySide = object.isBuySide ?? false;
        message.orders = object.orders?.map((e) => SpotLimitOrder.fromPartial(e)) || [];
        return message;
    },
};
function createBaseDerivativeOrderBook() {
    return { marketId: "", isBuySide: false, orders: [] };
}
export const DerivativeOrderBook = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.marketId !== "") {
            writer.uint32(10).string(message.marketId);
        }
        if (message.isBuySide === true) {
            writer.uint32(16).bool(message.isBuySide);
        }
        for (const v of message.orders) {
            DerivativeLimitOrder.encode(v, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDerivativeOrderBook();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.marketId = reader.string();
                    break;
                case 2:
                    message.isBuySide = reader.bool();
                    break;
                case 3:
                    message.orders.push(DerivativeLimitOrder.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            marketId: isSet(object.marketId) ? String(object.marketId) : "",
            isBuySide: isSet(object.isBuySide) ? Boolean(object.isBuySide) : false,
            orders: Array.isArray(object?.orders) ? object.orders.map((e) => DerivativeLimitOrder.fromJSON(e)) : [],
        };
    },
    toJSON(message) {
        const obj = {};
        message.marketId !== undefined && (obj.marketId = message.marketId);
        message.isBuySide !== undefined && (obj.isBuySide = message.isBuySide);
        if (message.orders) {
            obj.orders = message.orders.map((e) => e ? DerivativeLimitOrder.toJSON(e) : undefined);
        }
        else {
            obj.orders = [];
        }
        return obj;
    },
    create(base) {
        return DerivativeOrderBook.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseDerivativeOrderBook();
        message.marketId = object.marketId ?? "";
        message.isBuySide = object.isBuySide ?? false;
        message.orders = object.orders?.map((e) => DerivativeLimitOrder.fromPartial(e)) || [];
        return message;
    },
};
function createBaseConditionalDerivativeOrderBook() {
    return { marketId: "", limitBuyOrders: [], marketBuyOrders: [], limitSellOrders: [], marketSellOrders: [] };
}
export const ConditionalDerivativeOrderBook = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.marketId !== "") {
            writer.uint32(10).string(message.marketId);
        }
        for (const v of message.limitBuyOrders) {
            DerivativeLimitOrder.encode(v, writer.uint32(18).fork()).ldelim();
        }
        for (const v of message.marketBuyOrders) {
            DerivativeMarketOrder.encode(v, writer.uint32(26).fork()).ldelim();
        }
        for (const v of message.limitSellOrders) {
            DerivativeLimitOrder.encode(v, writer.uint32(34).fork()).ldelim();
        }
        for (const v of message.marketSellOrders) {
            DerivativeMarketOrder.encode(v, writer.uint32(42).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseConditionalDerivativeOrderBook();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.marketId = reader.string();
                    break;
                case 2:
                    message.limitBuyOrders.push(DerivativeLimitOrder.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.marketBuyOrders.push(DerivativeMarketOrder.decode(reader, reader.uint32()));
                    break;
                case 4:
                    message.limitSellOrders.push(DerivativeLimitOrder.decode(reader, reader.uint32()));
                    break;
                case 5:
                    message.marketSellOrders.push(DerivativeMarketOrder.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            marketId: isSet(object.marketId) ? String(object.marketId) : "",
            limitBuyOrders: Array.isArray(object?.limitBuyOrders)
                ? object.limitBuyOrders.map((e) => DerivativeLimitOrder.fromJSON(e))
                : [],
            marketBuyOrders: Array.isArray(object?.marketBuyOrders)
                ? object.marketBuyOrders.map((e) => DerivativeMarketOrder.fromJSON(e))
                : [],
            limitSellOrders: Array.isArray(object?.limitSellOrders)
                ? object.limitSellOrders.map((e) => DerivativeLimitOrder.fromJSON(e))
                : [],
            marketSellOrders: Array.isArray(object?.marketSellOrders)
                ? object.marketSellOrders.map((e) => DerivativeMarketOrder.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        message.marketId !== undefined && (obj.marketId = message.marketId);
        if (message.limitBuyOrders) {
            obj.limitBuyOrders = message.limitBuyOrders.map((e) => e ? DerivativeLimitOrder.toJSON(e) : undefined);
        }
        else {
            obj.limitBuyOrders = [];
        }
        if (message.marketBuyOrders) {
            obj.marketBuyOrders = message.marketBuyOrders.map((e) => e ? DerivativeMarketOrder.toJSON(e) : undefined);
        }
        else {
            obj.marketBuyOrders = [];
        }
        if (message.limitSellOrders) {
            obj.limitSellOrders = message.limitSellOrders.map((e) => e ? DerivativeLimitOrder.toJSON(e) : undefined);
        }
        else {
            obj.limitSellOrders = [];
        }
        if (message.marketSellOrders) {
            obj.marketSellOrders = message.marketSellOrders.map((e) => e ? DerivativeMarketOrder.toJSON(e) : undefined);
        }
        else {
            obj.marketSellOrders = [];
        }
        return obj;
    },
    create(base) {
        return ConditionalDerivativeOrderBook.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseConditionalDerivativeOrderBook();
        message.marketId = object.marketId ?? "";
        message.limitBuyOrders = object.limitBuyOrders?.map((e) => DerivativeLimitOrder.fromPartial(e)) || [];
        message.marketBuyOrders = object.marketBuyOrders?.map((e) => DerivativeMarketOrder.fromPartial(e)) || [];
        message.limitSellOrders = object.limitSellOrders?.map((e) => DerivativeLimitOrder.fromPartial(e)) || [];
        message.marketSellOrders = object.marketSellOrders?.map((e) => DerivativeMarketOrder.fromPartial(e)) || [];
        return message;
    },
};
function createBaseSubaccountOrderbookMetadata() {
    return {
        vanillaLimitOrderCount: 0,
        reduceOnlyLimitOrderCount: 0,
        aggregateReduceOnlyQuantity: "",
        aggregateVanillaQuantity: "",
        vanillaConditionalOrderCount: 0,
        reduceOnlyConditionalOrderCount: 0,
    };
}
export const SubaccountOrderbookMetadata = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.vanillaLimitOrderCount !== 0) {
            writer.uint32(8).uint32(message.vanillaLimitOrderCount);
        }
        if (message.reduceOnlyLimitOrderCount !== 0) {
            writer.uint32(16).uint32(message.reduceOnlyLimitOrderCount);
        }
        if (message.aggregateReduceOnlyQuantity !== "") {
            writer.uint32(26).string(message.aggregateReduceOnlyQuantity);
        }
        if (message.aggregateVanillaQuantity !== "") {
            writer.uint32(34).string(message.aggregateVanillaQuantity);
        }
        if (message.vanillaConditionalOrderCount !== 0) {
            writer.uint32(40).uint32(message.vanillaConditionalOrderCount);
        }
        if (message.reduceOnlyConditionalOrderCount !== 0) {
            writer.uint32(48).uint32(message.reduceOnlyConditionalOrderCount);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSubaccountOrderbookMetadata();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.vanillaLimitOrderCount = reader.uint32();
                    break;
                case 2:
                    message.reduceOnlyLimitOrderCount = reader.uint32();
                    break;
                case 3:
                    message.aggregateReduceOnlyQuantity = reader.string();
                    break;
                case 4:
                    message.aggregateVanillaQuantity = reader.string();
                    break;
                case 5:
                    message.vanillaConditionalOrderCount = reader.uint32();
                    break;
                case 6:
                    message.reduceOnlyConditionalOrderCount = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            vanillaLimitOrderCount: isSet(object.vanillaLimitOrderCount) ? Number(object.vanillaLimitOrderCount) : 0,
            reduceOnlyLimitOrderCount: isSet(object.reduceOnlyLimitOrderCount) ? Number(object.reduceOnlyLimitOrderCount) : 0,
            aggregateReduceOnlyQuantity: isSet(object.aggregateReduceOnlyQuantity)
                ? String(object.aggregateReduceOnlyQuantity)
                : "",
            aggregateVanillaQuantity: isSet(object.aggregateVanillaQuantity) ? String(object.aggregateVanillaQuantity) : "",
            vanillaConditionalOrderCount: isSet(object.vanillaConditionalOrderCount)
                ? Number(object.vanillaConditionalOrderCount)
                : 0,
            reduceOnlyConditionalOrderCount: isSet(object.reduceOnlyConditionalOrderCount)
                ? Number(object.reduceOnlyConditionalOrderCount)
                : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        message.vanillaLimitOrderCount !== undefined &&
            (obj.vanillaLimitOrderCount = Math.round(message.vanillaLimitOrderCount));
        message.reduceOnlyLimitOrderCount !== undefined &&
            (obj.reduceOnlyLimitOrderCount = Math.round(message.reduceOnlyLimitOrderCount));
        message.aggregateReduceOnlyQuantity !== undefined &&
            (obj.aggregateReduceOnlyQuantity = message.aggregateReduceOnlyQuantity);
        message.aggregateVanillaQuantity !== undefined && (obj.aggregateVanillaQuantity = message.aggregateVanillaQuantity);
        message.vanillaConditionalOrderCount !== undefined &&
            (obj.vanillaConditionalOrderCount = Math.round(message.vanillaConditionalOrderCount));
        message.reduceOnlyConditionalOrderCount !== undefined &&
            (obj.reduceOnlyConditionalOrderCount = Math.round(message.reduceOnlyConditionalOrderCount));
        return obj;
    },
    create(base) {
        return SubaccountOrderbookMetadata.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseSubaccountOrderbookMetadata();
        message.vanillaLimitOrderCount = object.vanillaLimitOrderCount ?? 0;
        message.reduceOnlyLimitOrderCount = object.reduceOnlyLimitOrderCount ?? 0;
        message.aggregateReduceOnlyQuantity = object.aggregateReduceOnlyQuantity ?? "";
        message.aggregateVanillaQuantity = object.aggregateVanillaQuantity ?? "";
        message.vanillaConditionalOrderCount = object.vanillaConditionalOrderCount ?? 0;
        message.reduceOnlyConditionalOrderCount = object.reduceOnlyConditionalOrderCount ?? 0;
        return message;
    },
};
function isSet(value) {
    return value !== null && value !== undefined;
}
