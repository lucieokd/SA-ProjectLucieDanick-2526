import _m0 from "protobufjs/minimal.js";
export declare const protobufPackage = "injective.exchange.v2";
export declare const OrderType: {
    readonly UNSPECIFIED: 0;
    readonly BUY: 1;
    readonly SELL: 2;
    readonly STOP_BUY: 3;
    readonly STOP_SELL: 4;
    readonly TAKE_BUY: 5;
    readonly TAKE_SELL: 6;
    readonly BUY_PO: 7;
    readonly SELL_PO: 8;
    readonly BUY_ATOMIC: 9;
    readonly SELL_ATOMIC: 10;
    readonly UNRECOGNIZED: -1;
};
export type OrderType = typeof OrderType[keyof typeof OrderType];
export declare function orderTypeFromJSON(object: any): OrderType;
export declare function orderTypeToJSON(object: OrderType): string;
export declare const OrderMask: {
    readonly UNUSED: 0;
    readonly ANY: 1;
    readonly REGULAR: 2;
    readonly CONDITIONAL: 4;
    /** DIRECTION_BUY_OR_HIGHER - for conditional orders means HIGHER */
    readonly DIRECTION_BUY_OR_HIGHER: 8;
    /** DIRECTION_SELL_OR_LOWER - for conditional orders means LOWER */
    readonly DIRECTION_SELL_OR_LOWER: 16;
    readonly TYPE_MARKET: 32;
    readonly TYPE_LIMIT: 64;
    readonly UNRECOGNIZED: -1;
};
export type OrderMask = typeof OrderMask[keyof typeof OrderMask];
export declare function orderMaskFromJSON(object: any): OrderMask;
export declare function orderMaskToJSON(object: OrderMask): string;
export declare const AtomicMarketOrderAccessLevel: {
    readonly Nobody: 0;
    /** BeginBlockerSmartContractsOnly - currently unsupported */
    readonly BeginBlockerSmartContractsOnly: 1;
    readonly SmartContractsOnly: 2;
    readonly Everyone: 3;
    readonly UNRECOGNIZED: -1;
};
export type AtomicMarketOrderAccessLevel = typeof AtomicMarketOrderAccessLevel[keyof typeof AtomicMarketOrderAccessLevel];
export declare function atomicMarketOrderAccessLevelFromJSON(object: any): AtomicMarketOrderAccessLevel;
export declare function atomicMarketOrderAccessLevelToJSON(object: AtomicMarketOrderAccessLevel): string;
export interface OrderInfo {
    /** bytes32 subaccount ID that created the order */
    subaccountId: string;
    /** address fee_recipient address that will receive fees for the order */
    feeRecipient: string;
    /** price of the order (in human readable format) */
    price: string;
    /** quantity of the order (in human readable format) */
    quantity: string;
    /** the client order ID (optional) */
    cid: string;
}
export interface SpotOrder {
    /** market_id represents the unique ID of the market */
    marketId: string;
    /** order_info contains the information of the order */
    orderInfo: OrderInfo | undefined;
    /** order types */
    orderType: OrderType;
    /**
     * trigger_price is the trigger price used by stop/take orders (in human
     * readable format) (optional)
     */
    triggerPrice: string;
    /** expiration block is the block number at which the order will expire */
    expirationBlock: string;
}
/** A valid Spot market order with Metadata. */
export interface SpotMarketOrder {
    /** order_info contains the information of the order */
    orderInfo: OrderInfo | undefined;
    balanceHold: string;
    orderHash: Uint8Array;
    /** order types */
    orderType: OrderType;
    /** trigger_price is the trigger price used by stop/take orders */
    triggerPrice: string;
}
/** A valid Spot limit order with Metadata. */
export interface SpotLimitOrder {
    /** order_info contains the information of the order */
    orderInfo: OrderInfo | undefined;
    /** order types */
    orderType: OrderType;
    /** the amount of the quantity remaining fillable */
    fillable: string;
    /** trigger_price is the trigger price used by stop/take orders */
    triggerPrice: string;
    /** order hash */
    orderHash: Uint8Array;
    /** expiration block is the block number at which the order will expire */
    expirationBlock: string;
}
export interface DerivativeOrder {
    /** market_id represents the unique ID of the market */
    marketId: string;
    /** order_info contains the information of the order */
    orderInfo: OrderInfo | undefined;
    /** order types */
    orderType: OrderType;
    /** margin is the margin used by the limit order (in human readable format) */
    margin: string;
    /**
     * trigger_price is the trigger price used by stop/take orders (in human
     * readable format) (optional)
     */
    triggerPrice: string;
    /** expiration block is the block number at which the order will expire */
    expirationBlock: string;
}
/** A valid Derivative market order with Metadata. */
export interface DerivativeMarketOrder {
    /** order_info contains the information of the order */
    orderInfo: OrderInfo | undefined;
    /** order types */
    orderType: OrderType;
    margin: string;
    marginHold: string;
    /** trigger_price is the trigger price used by stop/take orders */
    triggerPrice: string;
    orderHash: Uint8Array;
}
/** A valid Derivative limit order with Metadata. */
export interface DerivativeLimitOrder {
    /** order_info contains the information of the order */
    orderInfo: OrderInfo | undefined;
    /** order types */
    orderType: OrderType;
    /** margin is the margin used by the limit order */
    margin: string;
    /** the amount of the quantity remaining fillable */
    fillable: string;
    /** trigger_price is the trigger price used by stop/take orders */
    triggerPrice: string;
    orderHash: Uint8Array;
    /** expiration block is the block number at which the order will expire */
    expirationBlock: string;
}
export declare const OrderInfo: {
    encode(message: OrderInfo, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): OrderInfo;
    fromJSON(object: any): OrderInfo;
    toJSON(message: OrderInfo): unknown;
    create(base?: DeepPartial<OrderInfo>): OrderInfo;
    fromPartial(object: DeepPartial<OrderInfo>): OrderInfo;
};
export declare const SpotOrder: {
    encode(message: SpotOrder, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): SpotOrder;
    fromJSON(object: any): SpotOrder;
    toJSON(message: SpotOrder): unknown;
    create(base?: DeepPartial<SpotOrder>): SpotOrder;
    fromPartial(object: DeepPartial<SpotOrder>): SpotOrder;
};
export declare const SpotMarketOrder: {
    encode(message: SpotMarketOrder, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): SpotMarketOrder;
    fromJSON(object: any): SpotMarketOrder;
    toJSON(message: SpotMarketOrder): unknown;
    create(base?: DeepPartial<SpotMarketOrder>): SpotMarketOrder;
    fromPartial(object: DeepPartial<SpotMarketOrder>): SpotMarketOrder;
};
export declare const SpotLimitOrder: {
    encode(message: SpotLimitOrder, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): SpotLimitOrder;
    fromJSON(object: any): SpotLimitOrder;
    toJSON(message: SpotLimitOrder): unknown;
    create(base?: DeepPartial<SpotLimitOrder>): SpotLimitOrder;
    fromPartial(object: DeepPartial<SpotLimitOrder>): SpotLimitOrder;
};
export declare const DerivativeOrder: {
    encode(message: DerivativeOrder, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): DerivativeOrder;
    fromJSON(object: any): DerivativeOrder;
    toJSON(message: DerivativeOrder): unknown;
    create(base?: DeepPartial<DerivativeOrder>): DerivativeOrder;
    fromPartial(object: DeepPartial<DerivativeOrder>): DerivativeOrder;
};
export declare const DerivativeMarketOrder: {
    encode(message: DerivativeMarketOrder, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): DerivativeMarketOrder;
    fromJSON(object: any): DerivativeMarketOrder;
    toJSON(message: DerivativeMarketOrder): unknown;
    create(base?: DeepPartial<DerivativeMarketOrder>): DerivativeMarketOrder;
    fromPartial(object: DeepPartial<DerivativeMarketOrder>): DerivativeMarketOrder;
};
export declare const DerivativeLimitOrder: {
    encode(message: DerivativeLimitOrder, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): DerivativeLimitOrder;
    fromJSON(object: any): DerivativeLimitOrder;
    toJSON(message: DerivativeLimitOrder): unknown;
    create(base?: DeepPartial<DerivativeLimitOrder>): DerivativeLimitOrder;
    fromPartial(object: DeepPartial<DerivativeLimitOrder>): DerivativeLimitOrder;
};
type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;
export type DeepPartial<T> = T extends Builtin ? T : T extends Array<infer U> ? Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial<T[K]>;
} : Partial<T>;
export {};
