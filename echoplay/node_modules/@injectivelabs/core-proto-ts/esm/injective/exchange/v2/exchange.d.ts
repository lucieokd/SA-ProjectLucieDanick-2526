import _m0 from "protobufjs/minimal.js";
import { Coin } from "../../../cosmos/base/v1beta1/coin";
import { MarketVolume } from "./market";
import { AtomicMarketOrderAccessLevel } from "./order";
export declare const protobufPackage = "injective.exchange.v2";
export declare const ExecutionType: {
    readonly UnspecifiedExecutionType: 0;
    readonly Market: 1;
    readonly LimitFill: 2;
    readonly LimitMatchRestingOrder: 3;
    readonly LimitMatchNewOrder: 4;
    readonly MarketLiquidation: 5;
    readonly ExpiryMarketSettlement: 6;
    readonly UNRECOGNIZED: -1;
};
export type ExecutionType = typeof ExecutionType[keyof typeof ExecutionType];
export declare function executionTypeFromJSON(object: any): ExecutionType;
export declare function executionTypeToJSON(object: ExecutionType): string;
export interface Params {
    /**
     * spot_market_instant_listing_fee defines the expedited fee in INJ required
     * to create a spot market by bypassing governance
     */
    spotMarketInstantListingFee: Coin | undefined;
    /**
     * derivative_market_instant_listing_fee defines the expedited fee in INJ
     * required to create a derivative market by bypassing governance
     */
    derivativeMarketInstantListingFee: Coin | undefined;
    /**
     * default_spot_maker_fee defines the default exchange trade fee for makers on
     * a spot market
     */
    defaultSpotMakerFeeRate: string;
    /**
     * default_spot_taker_fee_rate defines the default exchange trade fee rate for
     * takers on a new spot market
     */
    defaultSpotTakerFeeRate: string;
    /**
     * default_derivative_maker_fee defines the default exchange trade fee for
     * makers on a new derivative market
     */
    defaultDerivativeMakerFeeRate: string;
    /**
     * default_derivative_taker_fee defines the default exchange trade fee for
     * takers on a new derivative market
     */
    defaultDerivativeTakerFeeRate: string;
    /**
     * default_initial_margin_ratio defines the default initial margin ratio on a
     * new derivative market
     */
    defaultInitialMarginRatio: string;
    /**
     * default_maintenance_margin_ratio defines the default maintenance margin
     * ratio on a new derivative market
     */
    defaultMaintenanceMarginRatio: string;
    /**
     * default_funding_interval defines the default funding interval on a
     * derivative market
     */
    defaultFundingInterval: string;
    /**
     * funding_multiple defines the timestamp multiple that the funding timestamp
     * should be a multiple of
     */
    fundingMultiple: string;
    /**
     * relayer_fee_share_rate defines the trade fee share percentage that goes to
     * relayers
     */
    relayerFeeShareRate: string;
    /**
     * default_hourly_funding_rate_cap defines the default maximum absolute value
     * of the hourly funding rate
     */
    defaultHourlyFundingRateCap: string;
    /** hourly_interest_rate defines the hourly interest rate */
    defaultHourlyInterestRate: string;
    /**
     * max_derivative_order_side_count defines the maximum number of derivative
     * active orders a subaccount can have for a given orderbook side
     */
    maxDerivativeOrderSideCount: number;
    /**
     * inj_reward_staked_requirement_threshold defines the threshold on INJ
     * rewards after which one also needs staked INJ to receive more
     */
    injRewardStakedRequirementThreshold: string;
    /**
     * the trading_rewards_vesting_duration defines the vesting times for trading
     * rewards
     */
    tradingRewardsVestingDuration: string;
    /**
     * liquidator_reward_share_rate defines the ratio of the split of the surplus
     * collateral that goes to the liquidator
     */
    liquidatorRewardShareRate: string;
    /**
     * binary_options_market_instant_listing_fee defines the expedited fee in INJ
     * required to create a derivative market by bypassing governance
     */
    binaryOptionsMarketInstantListingFee: Coin | undefined;
    /**
     * atomic_market_order_access_level defines the required access permissions
     * for executing atomic market orders
     */
    atomicMarketOrderAccessLevel: AtomicMarketOrderAccessLevel;
    /**
     * spot_atomic_market_order_fee_multiplier defines the default multiplier for
     * executing atomic market orders in spot markets
     */
    spotAtomicMarketOrderFeeMultiplier: string;
    /**
     * derivative_atomic_market_order_fee_multiplier defines the default
     * multiplier for executing atomic market orders in derivative markets
     */
    derivativeAtomicMarketOrderFeeMultiplier: string;
    /**
     * binary_options_atomic_market_order_fee_multiplier defines the default
     * multiplier for executing atomic market orders in binary markets
     */
    binaryOptionsAtomicMarketOrderFeeMultiplier: string;
    /** minimal_protocol_fee_rate defines the minimal protocol fee rate */
    minimalProtocolFeeRate: string;
    /**
     * is_instant_derivative_market_launch_enabled defines whether instant
     * derivative market launch is enabled
     */
    isInstantDerivativeMarketLaunchEnabled: boolean;
    postOnlyModeHeightThreshold: string;
    /**
     * Maximum time in seconds since the last mark price update to allow a
     * decrease in margin
     */
    marginDecreasePriceTimestampThresholdSeconds: string;
    /** List of addresses that are allowed to perform exchange admin operations */
    exchangeAdmins: string[];
    /** inj_auction_max_cap defines the maximum cap for INJ sent to auction */
    injAuctionMaxCap: string;
    /**
     * fixed_gas_enabled indicates if msg server will consume fixed gas amount for
     * certain msg types
     */
    fixedGasEnabled: boolean;
    /**
     * emit_legacy_version_events indicates if events of legacy version types
     * should be emitted in parallel to the new version events
     */
    emitLegacyVersionEvents: boolean;
    /**
     * default_reduce_margin_ratio defines the default reduce margin ratio on a
     * new derivative market
     */
    defaultReduceMarginRatio: string;
    /**
     * DO NOT USE THIS FIELD. It was introduced for a temporary bug fix.
     *
     * @deprecated
     */
    humanReadableUpgradeBlockHeight: string;
    /**
     * post_only_mode_blocks_amount defines the amount of blocks the post only
     * mode will be enabled
     */
    postOnlyModeBlocksAmount: string;
    /**
     * min_post_only_mode_downtime_duration defines the minimum downtime duration
     * that must pass before the post only mode is automatically enabled. The
     * accepted values are the Downtime enum values from the downtime_duration
     * module
     */
    minPostOnlyModeDowntimeDuration: string;
}
export interface NextFundingTimestamp {
    nextTimestamp: string;
}
export interface MidPriceAndTOB {
    /** mid price of the market (in human readable format) */
    midPrice: string;
    /** best buy price of the market (in human readable format) */
    bestBuyPrice: string;
    /** best sell price of the market (in human readable format) */
    bestSellPrice: string;
}
/** A subaccount's deposit for a given base currency */
export interface Deposit {
    /** the available balance (in chain format) */
    availableBalance: string;
    /** the total balance (in chain format) */
    totalBalance: string;
}
export interface SubaccountTradeNonce {
    nonce: number;
}
export interface SubaccountOrder {
    /** price of the order */
    price: string;
    /** the amount of the quantity remaining fillable */
    quantity: string;
    isReduceOnly: boolean;
    cid: string;
}
export interface SubaccountOrderData {
    order: SubaccountOrder | undefined;
    orderHash: Uint8Array;
}
export interface Position {
    /** True if the position is long. False if the position is short. */
    isLong: boolean;
    /** The quantity of the position (in human readable format) */
    quantity: string;
    /** The entry price of the position (in human readable format) */
    entryPrice: string;
    /** The margin of the position (in human readable format) */
    margin: string;
    /** The cumulative funding */
    cumulativeFundingEntry: string;
}
export interface Balance {
    /** the subaccount ID */
    subaccountId: string;
    /** the denom of the balance */
    denom: string;
    /** the token deposits details */
    deposits: Deposit | undefined;
}
export interface DerivativePosition {
    /** the subaccount ID */
    subaccountId: string;
    /** the market ID */
    marketId: string;
    /** the position details */
    position: Position | undefined;
}
export interface MarketOrderIndicator {
    /** market_id represents the unique ID of the market */
    marketId: string;
    isBuy: boolean;
}
export interface TradeLog {
    quantity: string;
    price: string;
    /** bytes32 subaccount ID that executed the trade */
    subaccountId: Uint8Array;
    fee: string;
    orderHash: Uint8Array;
    feeRecipientAddress: Uint8Array;
    cid: string;
}
export interface PositionDelta {
    isLong: boolean;
    executionQuantity: string;
    executionMargin: string;
    executionPrice: string;
}
export interface DerivativeTradeLog {
    subaccountId: Uint8Array;
    positionDelta: PositionDelta | undefined;
    payout: string;
    fee: string;
    orderHash: Uint8Array;
    feeRecipientAddress: Uint8Array;
    cid: string;
    pnl: string;
}
export interface SubaccountPosition {
    position: Position | undefined;
    subaccountId: Uint8Array;
}
export interface SubaccountDeposit {
    subaccountId: Uint8Array;
    deposit: Deposit | undefined;
}
export interface DepositUpdate {
    denom: string;
    deposits: SubaccountDeposit[];
}
export interface PointsMultiplier {
    makerPointsMultiplier: string;
    takerPointsMultiplier: string;
}
export interface TradingRewardCampaignBoostInfo {
    boostedSpotMarketIds: string[];
    spotMarketMultipliers: PointsMultiplier[];
    boostedDerivativeMarketIds: string[];
    derivativeMarketMultipliers: PointsMultiplier[];
}
export interface CampaignRewardPool {
    /** the campaign start timestamp in seconds */
    startTimestamp: string;
    /**
     * max_campaign_rewards are the maximum reward amounts to be disbursed at the
     * end of the campaign
     */
    maxCampaignRewards: Coin[];
}
export interface TradingRewardCampaignInfo {
    /** number of seconds of the duration of each campaign */
    campaignDurationSeconds: string;
    /** the trading fee quote denoms which will be counted for the rewards */
    quoteDenoms: string[];
    /** the optional boost info for markets */
    tradingRewardBoostInfo: TradingRewardCampaignBoostInfo | undefined;
    /** the marketIDs which are disqualified from being rewarded */
    disqualifiedMarketIds: string[];
}
export interface FeeDiscountTierInfo {
    /** the maker discount rate */
    makerDiscountRate: string;
    /** the taker discount rate */
    takerDiscountRate: string;
    /** the staked amount required to qualify for the discount (in chain format) */
    stakedAmount: string;
    /** the volume required to qualify for the discount (in human readable format) */
    volume: string;
}
export interface FeeDiscountSchedule {
    /** the bucket number */
    bucketCount: string;
    /** the bucket duration in seconds */
    bucketDuration: string;
    /**
     * the trading fee quote denoms which will be counted for the fee paid
     * contribution
     */
    quoteDenoms: string[];
    /** the fee discount tiers */
    tierInfos: FeeDiscountTierInfo[];
    /**
     * the marketIDs which are disqualified from contributing to the fee paid
     * amount
     */
    disqualifiedMarketIds: string[];
}
export interface FeeDiscountTierTTL {
    /** the tier number */
    tier: string;
    /** the TTL timestamp in seconds */
    ttlTimestamp: string;
}
export interface AccountRewards {
    account: string;
    rewards: Coin[];
}
export interface TradeRecords {
    marketId: string;
    latestTradeRecords: TradeRecord[];
}
export interface SubaccountIDs {
    subaccountIds: Uint8Array[];
}
export interface TradeRecord {
    /** the timestamp of the trade */
    timestamp: string;
    /** the price of the trade (in human readable format) */
    price: string;
    /** the quantity of the trade (in human readable format) */
    quantity: string;
}
export interface Level {
    /** price (in human readable format) */
    p: string;
    /** quantity (in human readable format) */
    q: string;
}
export interface AggregateSubaccountVolumeRecord {
    /** the subaccount ID */
    subaccountId: string;
    /** the subaccount volumes for each market */
    marketVolumes: MarketVolume[];
}
export interface AggregateAccountVolumeRecord {
    /** account the volume belongs to */
    account: string;
    /** the aggregate volumes for each market */
    marketVolumes: MarketVolume[];
}
export interface DenomDecimals {
    /** the denom of the token */
    denom: string;
    /** the decimals of the token */
    decimals: string;
}
export interface GrantAuthorization {
    /** the grantee address */
    grantee: string;
    /** the amount of stake granted (INJ in chain format) */
    amount: string;
}
export interface ActiveGrant {
    granter: string;
    amount: string;
}
export interface EffectiveGrant {
    granter: string;
    netGrantedStake: string;
    isValid: boolean;
}
export interface DenomMinNotional {
    /** the denom of the token */
    denom: string;
    /** the minimum notional value for the token (in human readable format) */
    minNotional: string;
}
export declare const Params: {
    encode(message: Params, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): Params;
    fromJSON(object: any): Params;
    toJSON(message: Params): unknown;
    create(base?: DeepPartial<Params>): Params;
    fromPartial(object: DeepPartial<Params>): Params;
};
export declare const NextFundingTimestamp: {
    encode(message: NextFundingTimestamp, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): NextFundingTimestamp;
    fromJSON(object: any): NextFundingTimestamp;
    toJSON(message: NextFundingTimestamp): unknown;
    create(base?: DeepPartial<NextFundingTimestamp>): NextFundingTimestamp;
    fromPartial(object: DeepPartial<NextFundingTimestamp>): NextFundingTimestamp;
};
export declare const MidPriceAndTOB: {
    encode(message: MidPriceAndTOB, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MidPriceAndTOB;
    fromJSON(object: any): MidPriceAndTOB;
    toJSON(message: MidPriceAndTOB): unknown;
    create(base?: DeepPartial<MidPriceAndTOB>): MidPriceAndTOB;
    fromPartial(object: DeepPartial<MidPriceAndTOB>): MidPriceAndTOB;
};
export declare const Deposit: {
    encode(message: Deposit, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): Deposit;
    fromJSON(object: any): Deposit;
    toJSON(message: Deposit): unknown;
    create(base?: DeepPartial<Deposit>): Deposit;
    fromPartial(object: DeepPartial<Deposit>): Deposit;
};
export declare const SubaccountTradeNonce: {
    encode(message: SubaccountTradeNonce, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): SubaccountTradeNonce;
    fromJSON(object: any): SubaccountTradeNonce;
    toJSON(message: SubaccountTradeNonce): unknown;
    create(base?: DeepPartial<SubaccountTradeNonce>): SubaccountTradeNonce;
    fromPartial(object: DeepPartial<SubaccountTradeNonce>): SubaccountTradeNonce;
};
export declare const SubaccountOrder: {
    encode(message: SubaccountOrder, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): SubaccountOrder;
    fromJSON(object: any): SubaccountOrder;
    toJSON(message: SubaccountOrder): unknown;
    create(base?: DeepPartial<SubaccountOrder>): SubaccountOrder;
    fromPartial(object: DeepPartial<SubaccountOrder>): SubaccountOrder;
};
export declare const SubaccountOrderData: {
    encode(message: SubaccountOrderData, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): SubaccountOrderData;
    fromJSON(object: any): SubaccountOrderData;
    toJSON(message: SubaccountOrderData): unknown;
    create(base?: DeepPartial<SubaccountOrderData>): SubaccountOrderData;
    fromPartial(object: DeepPartial<SubaccountOrderData>): SubaccountOrderData;
};
export declare const Position: {
    encode(message: Position, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): Position;
    fromJSON(object: any): Position;
    toJSON(message: Position): unknown;
    create(base?: DeepPartial<Position>): Position;
    fromPartial(object: DeepPartial<Position>): Position;
};
export declare const Balance: {
    encode(message: Balance, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): Balance;
    fromJSON(object: any): Balance;
    toJSON(message: Balance): unknown;
    create(base?: DeepPartial<Balance>): Balance;
    fromPartial(object: DeepPartial<Balance>): Balance;
};
export declare const DerivativePosition: {
    encode(message: DerivativePosition, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): DerivativePosition;
    fromJSON(object: any): DerivativePosition;
    toJSON(message: DerivativePosition): unknown;
    create(base?: DeepPartial<DerivativePosition>): DerivativePosition;
    fromPartial(object: DeepPartial<DerivativePosition>): DerivativePosition;
};
export declare const MarketOrderIndicator: {
    encode(message: MarketOrderIndicator, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MarketOrderIndicator;
    fromJSON(object: any): MarketOrderIndicator;
    toJSON(message: MarketOrderIndicator): unknown;
    create(base?: DeepPartial<MarketOrderIndicator>): MarketOrderIndicator;
    fromPartial(object: DeepPartial<MarketOrderIndicator>): MarketOrderIndicator;
};
export declare const TradeLog: {
    encode(message: TradeLog, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): TradeLog;
    fromJSON(object: any): TradeLog;
    toJSON(message: TradeLog): unknown;
    create(base?: DeepPartial<TradeLog>): TradeLog;
    fromPartial(object: DeepPartial<TradeLog>): TradeLog;
};
export declare const PositionDelta: {
    encode(message: PositionDelta, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): PositionDelta;
    fromJSON(object: any): PositionDelta;
    toJSON(message: PositionDelta): unknown;
    create(base?: DeepPartial<PositionDelta>): PositionDelta;
    fromPartial(object: DeepPartial<PositionDelta>): PositionDelta;
};
export declare const DerivativeTradeLog: {
    encode(message: DerivativeTradeLog, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): DerivativeTradeLog;
    fromJSON(object: any): DerivativeTradeLog;
    toJSON(message: DerivativeTradeLog): unknown;
    create(base?: DeepPartial<DerivativeTradeLog>): DerivativeTradeLog;
    fromPartial(object: DeepPartial<DerivativeTradeLog>): DerivativeTradeLog;
};
export declare const SubaccountPosition: {
    encode(message: SubaccountPosition, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): SubaccountPosition;
    fromJSON(object: any): SubaccountPosition;
    toJSON(message: SubaccountPosition): unknown;
    create(base?: DeepPartial<SubaccountPosition>): SubaccountPosition;
    fromPartial(object: DeepPartial<SubaccountPosition>): SubaccountPosition;
};
export declare const SubaccountDeposit: {
    encode(message: SubaccountDeposit, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): SubaccountDeposit;
    fromJSON(object: any): SubaccountDeposit;
    toJSON(message: SubaccountDeposit): unknown;
    create(base?: DeepPartial<SubaccountDeposit>): SubaccountDeposit;
    fromPartial(object: DeepPartial<SubaccountDeposit>): SubaccountDeposit;
};
export declare const DepositUpdate: {
    encode(message: DepositUpdate, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): DepositUpdate;
    fromJSON(object: any): DepositUpdate;
    toJSON(message: DepositUpdate): unknown;
    create(base?: DeepPartial<DepositUpdate>): DepositUpdate;
    fromPartial(object: DeepPartial<DepositUpdate>): DepositUpdate;
};
export declare const PointsMultiplier: {
    encode(message: PointsMultiplier, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): PointsMultiplier;
    fromJSON(object: any): PointsMultiplier;
    toJSON(message: PointsMultiplier): unknown;
    create(base?: DeepPartial<PointsMultiplier>): PointsMultiplier;
    fromPartial(object: DeepPartial<PointsMultiplier>): PointsMultiplier;
};
export declare const TradingRewardCampaignBoostInfo: {
    encode(message: TradingRewardCampaignBoostInfo, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): TradingRewardCampaignBoostInfo;
    fromJSON(object: any): TradingRewardCampaignBoostInfo;
    toJSON(message: TradingRewardCampaignBoostInfo): unknown;
    create(base?: DeepPartial<TradingRewardCampaignBoostInfo>): TradingRewardCampaignBoostInfo;
    fromPartial(object: DeepPartial<TradingRewardCampaignBoostInfo>): TradingRewardCampaignBoostInfo;
};
export declare const CampaignRewardPool: {
    encode(message: CampaignRewardPool, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): CampaignRewardPool;
    fromJSON(object: any): CampaignRewardPool;
    toJSON(message: CampaignRewardPool): unknown;
    create(base?: DeepPartial<CampaignRewardPool>): CampaignRewardPool;
    fromPartial(object: DeepPartial<CampaignRewardPool>): CampaignRewardPool;
};
export declare const TradingRewardCampaignInfo: {
    encode(message: TradingRewardCampaignInfo, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): TradingRewardCampaignInfo;
    fromJSON(object: any): TradingRewardCampaignInfo;
    toJSON(message: TradingRewardCampaignInfo): unknown;
    create(base?: DeepPartial<TradingRewardCampaignInfo>): TradingRewardCampaignInfo;
    fromPartial(object: DeepPartial<TradingRewardCampaignInfo>): TradingRewardCampaignInfo;
};
export declare const FeeDiscountTierInfo: {
    encode(message: FeeDiscountTierInfo, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): FeeDiscountTierInfo;
    fromJSON(object: any): FeeDiscountTierInfo;
    toJSON(message: FeeDiscountTierInfo): unknown;
    create(base?: DeepPartial<FeeDiscountTierInfo>): FeeDiscountTierInfo;
    fromPartial(object: DeepPartial<FeeDiscountTierInfo>): FeeDiscountTierInfo;
};
export declare const FeeDiscountSchedule: {
    encode(message: FeeDiscountSchedule, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): FeeDiscountSchedule;
    fromJSON(object: any): FeeDiscountSchedule;
    toJSON(message: FeeDiscountSchedule): unknown;
    create(base?: DeepPartial<FeeDiscountSchedule>): FeeDiscountSchedule;
    fromPartial(object: DeepPartial<FeeDiscountSchedule>): FeeDiscountSchedule;
};
export declare const FeeDiscountTierTTL: {
    encode(message: FeeDiscountTierTTL, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): FeeDiscountTierTTL;
    fromJSON(object: any): FeeDiscountTierTTL;
    toJSON(message: FeeDiscountTierTTL): unknown;
    create(base?: DeepPartial<FeeDiscountTierTTL>): FeeDiscountTierTTL;
    fromPartial(object: DeepPartial<FeeDiscountTierTTL>): FeeDiscountTierTTL;
};
export declare const AccountRewards: {
    encode(message: AccountRewards, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): AccountRewards;
    fromJSON(object: any): AccountRewards;
    toJSON(message: AccountRewards): unknown;
    create(base?: DeepPartial<AccountRewards>): AccountRewards;
    fromPartial(object: DeepPartial<AccountRewards>): AccountRewards;
};
export declare const TradeRecords: {
    encode(message: TradeRecords, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): TradeRecords;
    fromJSON(object: any): TradeRecords;
    toJSON(message: TradeRecords): unknown;
    create(base?: DeepPartial<TradeRecords>): TradeRecords;
    fromPartial(object: DeepPartial<TradeRecords>): TradeRecords;
};
export declare const SubaccountIDs: {
    encode(message: SubaccountIDs, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): SubaccountIDs;
    fromJSON(object: any): SubaccountIDs;
    toJSON(message: SubaccountIDs): unknown;
    create(base?: DeepPartial<SubaccountIDs>): SubaccountIDs;
    fromPartial(object: DeepPartial<SubaccountIDs>): SubaccountIDs;
};
export declare const TradeRecord: {
    encode(message: TradeRecord, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): TradeRecord;
    fromJSON(object: any): TradeRecord;
    toJSON(message: TradeRecord): unknown;
    create(base?: DeepPartial<TradeRecord>): TradeRecord;
    fromPartial(object: DeepPartial<TradeRecord>): TradeRecord;
};
export declare const Level: {
    encode(message: Level, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): Level;
    fromJSON(object: any): Level;
    toJSON(message: Level): unknown;
    create(base?: DeepPartial<Level>): Level;
    fromPartial(object: DeepPartial<Level>): Level;
};
export declare const AggregateSubaccountVolumeRecord: {
    encode(message: AggregateSubaccountVolumeRecord, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): AggregateSubaccountVolumeRecord;
    fromJSON(object: any): AggregateSubaccountVolumeRecord;
    toJSON(message: AggregateSubaccountVolumeRecord): unknown;
    create(base?: DeepPartial<AggregateSubaccountVolumeRecord>): AggregateSubaccountVolumeRecord;
    fromPartial(object: DeepPartial<AggregateSubaccountVolumeRecord>): AggregateSubaccountVolumeRecord;
};
export declare const AggregateAccountVolumeRecord: {
    encode(message: AggregateAccountVolumeRecord, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): AggregateAccountVolumeRecord;
    fromJSON(object: any): AggregateAccountVolumeRecord;
    toJSON(message: AggregateAccountVolumeRecord): unknown;
    create(base?: DeepPartial<AggregateAccountVolumeRecord>): AggregateAccountVolumeRecord;
    fromPartial(object: DeepPartial<AggregateAccountVolumeRecord>): AggregateAccountVolumeRecord;
};
export declare const DenomDecimals: {
    encode(message: DenomDecimals, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): DenomDecimals;
    fromJSON(object: any): DenomDecimals;
    toJSON(message: DenomDecimals): unknown;
    create(base?: DeepPartial<DenomDecimals>): DenomDecimals;
    fromPartial(object: DeepPartial<DenomDecimals>): DenomDecimals;
};
export declare const GrantAuthorization: {
    encode(message: GrantAuthorization, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): GrantAuthorization;
    fromJSON(object: any): GrantAuthorization;
    toJSON(message: GrantAuthorization): unknown;
    create(base?: DeepPartial<GrantAuthorization>): GrantAuthorization;
    fromPartial(object: DeepPartial<GrantAuthorization>): GrantAuthorization;
};
export declare const ActiveGrant: {
    encode(message: ActiveGrant, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ActiveGrant;
    fromJSON(object: any): ActiveGrant;
    toJSON(message: ActiveGrant): unknown;
    create(base?: DeepPartial<ActiveGrant>): ActiveGrant;
    fromPartial(object: DeepPartial<ActiveGrant>): ActiveGrant;
};
export declare const EffectiveGrant: {
    encode(message: EffectiveGrant, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): EffectiveGrant;
    fromJSON(object: any): EffectiveGrant;
    toJSON(message: EffectiveGrant): unknown;
    create(base?: DeepPartial<EffectiveGrant>): EffectiveGrant;
    fromPartial(object: DeepPartial<EffectiveGrant>): EffectiveGrant;
};
export declare const DenomMinNotional: {
    encode(message: DenomMinNotional, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): DenomMinNotional;
    fromJSON(object: any): DenomMinNotional;
    toJSON(message: DenomMinNotional): unknown;
    create(base?: DeepPartial<DenomMinNotional>): DenomMinNotional;
    fromPartial(object: DeepPartial<DenomMinNotional>): DenomMinNotional;
};
type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;
export type DeepPartial<T> = T extends Builtin ? T : T extends Array<infer U> ? Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial<T[K]>;
} : Partial<T>;
export {};
