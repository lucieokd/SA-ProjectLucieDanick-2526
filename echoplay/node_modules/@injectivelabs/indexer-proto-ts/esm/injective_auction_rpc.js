/* eslint-disable */
import { grpc } from "@injectivelabs/grpc-web";
import { BrowserHeaders } from "browser-headers";
import Long from "long";
import _m0 from "protobufjs/minimal.js";
import { Observable } from "rxjs";
import { share } from "rxjs/operators";
export const protobufPackage = "injective_auction_rpc";
function createBaseAuctionEndpointRequest() {
    return { round: "0" };
}
export const AuctionEndpointRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.round !== "0") {
            writer.uint32(8).sint64(message.round);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAuctionEndpointRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.round = longToString(reader.sint64());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return { round: isSet(object.round) ? String(object.round) : "0" };
    },
    toJSON(message) {
        const obj = {};
        message.round !== undefined && (obj.round = message.round);
        return obj;
    },
    create(base) {
        return AuctionEndpointRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseAuctionEndpointRequest();
        message.round = object.round ?? "0";
        return message;
    },
};
function createBaseAuctionEndpointResponse() {
    return { auction: undefined, bids: [] };
}
export const AuctionEndpointResponse = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.auction !== undefined) {
            Auction.encode(message.auction, writer.uint32(10).fork()).ldelim();
        }
        for (const v of message.bids) {
            Bid.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAuctionEndpointResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.auction = Auction.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.bids.push(Bid.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            auction: isSet(object.auction) ? Auction.fromJSON(object.auction) : undefined,
            bids: Array.isArray(object?.bids) ? object.bids.map((e) => Bid.fromJSON(e)) : [],
        };
    },
    toJSON(message) {
        const obj = {};
        message.auction !== undefined && (obj.auction = message.auction ? Auction.toJSON(message.auction) : undefined);
        if (message.bids) {
            obj.bids = message.bids.map((e) => e ? Bid.toJSON(e) : undefined);
        }
        else {
            obj.bids = [];
        }
        return obj;
    },
    create(base) {
        return AuctionEndpointResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseAuctionEndpointResponse();
        message.auction = (object.auction !== undefined && object.auction !== null)
            ? Auction.fromPartial(object.auction)
            : undefined;
        message.bids = object.bids?.map((e) => Bid.fromPartial(e)) || [];
        return message;
    },
};
function createBaseAuction() {
    return {
        winner: "",
        basket: [],
        winningBidAmount: "",
        round: "0",
        endTimestamp: "0",
        updatedAt: "0",
        contract: undefined,
    };
}
export const Auction = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.winner !== "") {
            writer.uint32(10).string(message.winner);
        }
        for (const v of message.basket) {
            Coin.encode(v, writer.uint32(18).fork()).ldelim();
        }
        if (message.winningBidAmount !== "") {
            writer.uint32(26).string(message.winningBidAmount);
        }
        if (message.round !== "0") {
            writer.uint32(32).uint64(message.round);
        }
        if (message.endTimestamp !== "0") {
            writer.uint32(40).sint64(message.endTimestamp);
        }
        if (message.updatedAt !== "0") {
            writer.uint32(48).sint64(message.updatedAt);
        }
        if (message.contract !== undefined) {
            AuctionContract.encode(message.contract, writer.uint32(58).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAuction();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.winner = reader.string();
                    break;
                case 2:
                    message.basket.push(Coin.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.winningBidAmount = reader.string();
                    break;
                case 4:
                    message.round = longToString(reader.uint64());
                    break;
                case 5:
                    message.endTimestamp = longToString(reader.sint64());
                    break;
                case 6:
                    message.updatedAt = longToString(reader.sint64());
                    break;
                case 7:
                    message.contract = AuctionContract.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            winner: isSet(object.winner) ? String(object.winner) : "",
            basket: Array.isArray(object?.basket) ? object.basket.map((e) => Coin.fromJSON(e)) : [],
            winningBidAmount: isSet(object.winningBidAmount) ? String(object.winningBidAmount) : "",
            round: isSet(object.round) ? String(object.round) : "0",
            endTimestamp: isSet(object.endTimestamp) ? String(object.endTimestamp) : "0",
            updatedAt: isSet(object.updatedAt) ? String(object.updatedAt) : "0",
            contract: isSet(object.contract) ? AuctionContract.fromJSON(object.contract) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.winner !== undefined && (obj.winner = message.winner);
        if (message.basket) {
            obj.basket = message.basket.map((e) => e ? Coin.toJSON(e) : undefined);
        }
        else {
            obj.basket = [];
        }
        message.winningBidAmount !== undefined && (obj.winningBidAmount = message.winningBidAmount);
        message.round !== undefined && (obj.round = message.round);
        message.endTimestamp !== undefined && (obj.endTimestamp = message.endTimestamp);
        message.updatedAt !== undefined && (obj.updatedAt = message.updatedAt);
        message.contract !== undefined &&
            (obj.contract = message.contract ? AuctionContract.toJSON(message.contract) : undefined);
        return obj;
    },
    create(base) {
        return Auction.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseAuction();
        message.winner = object.winner ?? "";
        message.basket = object.basket?.map((e) => Coin.fromPartial(e)) || [];
        message.winningBidAmount = object.winningBidAmount ?? "";
        message.round = object.round ?? "0";
        message.endTimestamp = object.endTimestamp ?? "0";
        message.updatedAt = object.updatedAt ?? "0";
        message.contract = (object.contract !== undefined && object.contract !== null)
            ? AuctionContract.fromPartial(object.contract)
            : undefined;
        return message;
    },
};
function createBaseCoin() {
    return { denom: "", amount: "", usdValue: "" };
}
export const Coin = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.denom !== "") {
            writer.uint32(10).string(message.denom);
        }
        if (message.amount !== "") {
            writer.uint32(18).string(message.amount);
        }
        if (message.usdValue !== "") {
            writer.uint32(26).string(message.usdValue);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCoin();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.denom = reader.string();
                    break;
                case 2:
                    message.amount = reader.string();
                    break;
                case 3:
                    message.usdValue = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            denom: isSet(object.denom) ? String(object.denom) : "",
            amount: isSet(object.amount) ? String(object.amount) : "",
            usdValue: isSet(object.usdValue) ? String(object.usdValue) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.denom !== undefined && (obj.denom = message.denom);
        message.amount !== undefined && (obj.amount = message.amount);
        message.usdValue !== undefined && (obj.usdValue = message.usdValue);
        return obj;
    },
    create(base) {
        return Coin.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseCoin();
        message.denom = object.denom ?? "";
        message.amount = object.amount ?? "";
        message.usdValue = object.usdValue ?? "";
        return message;
    },
};
function createBaseAuctionContract() {
    return {
        id: "0",
        bidTarget: "",
        currentSlots: "0",
        totalSlots: "0",
        maxUserAllocation: "",
        totalCommitted: "",
        whitelistAddresses: [],
        startTimestamp: "0",
        endTimestamp: "0",
        maxRoundAllocation: "",
    };
}
export const AuctionContract = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.id !== "0") {
            writer.uint32(8).uint64(message.id);
        }
        if (message.bidTarget !== "") {
            writer.uint32(18).string(message.bidTarget);
        }
        if (message.currentSlots !== "0") {
            writer.uint32(24).uint64(message.currentSlots);
        }
        if (message.totalSlots !== "0") {
            writer.uint32(32).uint64(message.totalSlots);
        }
        if (message.maxUserAllocation !== "") {
            writer.uint32(42).string(message.maxUserAllocation);
        }
        if (message.totalCommitted !== "") {
            writer.uint32(50).string(message.totalCommitted);
        }
        for (const v of message.whitelistAddresses) {
            writer.uint32(58).string(v);
        }
        if (message.startTimestamp !== "0") {
            writer.uint32(64).uint64(message.startTimestamp);
        }
        if (message.endTimestamp !== "0") {
            writer.uint32(72).uint64(message.endTimestamp);
        }
        if (message.maxRoundAllocation !== "") {
            writer.uint32(82).string(message.maxRoundAllocation);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAuctionContract();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.id = longToString(reader.uint64());
                    break;
                case 2:
                    message.bidTarget = reader.string();
                    break;
                case 3:
                    message.currentSlots = longToString(reader.uint64());
                    break;
                case 4:
                    message.totalSlots = longToString(reader.uint64());
                    break;
                case 5:
                    message.maxUserAllocation = reader.string();
                    break;
                case 6:
                    message.totalCommitted = reader.string();
                    break;
                case 7:
                    message.whitelistAddresses.push(reader.string());
                    break;
                case 8:
                    message.startTimestamp = longToString(reader.uint64());
                    break;
                case 9:
                    message.endTimestamp = longToString(reader.uint64());
                    break;
                case 10:
                    message.maxRoundAllocation = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            id: isSet(object.id) ? String(object.id) : "0",
            bidTarget: isSet(object.bidTarget) ? String(object.bidTarget) : "",
            currentSlots: isSet(object.currentSlots) ? String(object.currentSlots) : "0",
            totalSlots: isSet(object.totalSlots) ? String(object.totalSlots) : "0",
            maxUserAllocation: isSet(object.maxUserAllocation) ? String(object.maxUserAllocation) : "",
            totalCommitted: isSet(object.totalCommitted) ? String(object.totalCommitted) : "",
            whitelistAddresses: Array.isArray(object?.whitelistAddresses)
                ? object.whitelistAddresses.map((e) => String(e))
                : [],
            startTimestamp: isSet(object.startTimestamp) ? String(object.startTimestamp) : "0",
            endTimestamp: isSet(object.endTimestamp) ? String(object.endTimestamp) : "0",
            maxRoundAllocation: isSet(object.maxRoundAllocation) ? String(object.maxRoundAllocation) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.id !== undefined && (obj.id = message.id);
        message.bidTarget !== undefined && (obj.bidTarget = message.bidTarget);
        message.currentSlots !== undefined && (obj.currentSlots = message.currentSlots);
        message.totalSlots !== undefined && (obj.totalSlots = message.totalSlots);
        message.maxUserAllocation !== undefined && (obj.maxUserAllocation = message.maxUserAllocation);
        message.totalCommitted !== undefined && (obj.totalCommitted = message.totalCommitted);
        if (message.whitelistAddresses) {
            obj.whitelistAddresses = message.whitelistAddresses.map((e) => e);
        }
        else {
            obj.whitelistAddresses = [];
        }
        message.startTimestamp !== undefined && (obj.startTimestamp = message.startTimestamp);
        message.endTimestamp !== undefined && (obj.endTimestamp = message.endTimestamp);
        message.maxRoundAllocation !== undefined && (obj.maxRoundAllocation = message.maxRoundAllocation);
        return obj;
    },
    create(base) {
        return AuctionContract.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseAuctionContract();
        message.id = object.id ?? "0";
        message.bidTarget = object.bidTarget ?? "";
        message.currentSlots = object.currentSlots ?? "0";
        message.totalSlots = object.totalSlots ?? "0";
        message.maxUserAllocation = object.maxUserAllocation ?? "";
        message.totalCommitted = object.totalCommitted ?? "";
        message.whitelistAddresses = object.whitelistAddresses?.map((e) => e) || [];
        message.startTimestamp = object.startTimestamp ?? "0";
        message.endTimestamp = object.endTimestamp ?? "0";
        message.maxRoundAllocation = object.maxRoundAllocation ?? "";
        return message;
    },
};
function createBaseBid() {
    return { bidder: "", amount: "", timestamp: "0" };
}
export const Bid = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.bidder !== "") {
            writer.uint32(10).string(message.bidder);
        }
        if (message.amount !== "") {
            writer.uint32(18).string(message.amount);
        }
        if (message.timestamp !== "0") {
            writer.uint32(24).sint64(message.timestamp);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBid();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.bidder = reader.string();
                    break;
                case 2:
                    message.amount = reader.string();
                    break;
                case 3:
                    message.timestamp = longToString(reader.sint64());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            bidder: isSet(object.bidder) ? String(object.bidder) : "",
            amount: isSet(object.amount) ? String(object.amount) : "",
            timestamp: isSet(object.timestamp) ? String(object.timestamp) : "0",
        };
    },
    toJSON(message) {
        const obj = {};
        message.bidder !== undefined && (obj.bidder = message.bidder);
        message.amount !== undefined && (obj.amount = message.amount);
        message.timestamp !== undefined && (obj.timestamp = message.timestamp);
        return obj;
    },
    create(base) {
        return Bid.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseBid();
        message.bidder = object.bidder ?? "";
        message.amount = object.amount ?? "";
        message.timestamp = object.timestamp ?? "0";
        return message;
    },
};
function createBaseAuctionsRequest() {
    return {};
}
export const AuctionsRequest = {
    encode(_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAuctionsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return AuctionsRequest.fromPartial(base ?? {});
    },
    fromPartial(_) {
        const message = createBaseAuctionsRequest();
        return message;
    },
};
function createBaseAuctionsResponse() {
    return { auctions: [] };
}
export const AuctionsResponse = {
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.auctions) {
            Auction.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAuctionsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.auctions.push(Auction.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return { auctions: Array.isArray(object?.auctions) ? object.auctions.map((e) => Auction.fromJSON(e)) : [] };
    },
    toJSON(message) {
        const obj = {};
        if (message.auctions) {
            obj.auctions = message.auctions.map((e) => e ? Auction.toJSON(e) : undefined);
        }
        else {
            obj.auctions = [];
        }
        return obj;
    },
    create(base) {
        return AuctionsResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseAuctionsResponse();
        message.auctions = object.auctions?.map((e) => Auction.fromPartial(e)) || [];
        return message;
    },
};
function createBaseAuctionsHistoryV2Request() {
    return { perPage: 0, token: "", endTime: "0" };
}
export const AuctionsHistoryV2Request = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.perPage !== 0) {
            writer.uint32(8).sint32(message.perPage);
        }
        if (message.token !== "") {
            writer.uint32(18).string(message.token);
        }
        if (message.endTime !== "0") {
            writer.uint32(24).sint64(message.endTime);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAuctionsHistoryV2Request();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.perPage = reader.sint32();
                    break;
                case 2:
                    message.token = reader.string();
                    break;
                case 3:
                    message.endTime = longToString(reader.sint64());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            perPage: isSet(object.perPage) ? Number(object.perPage) : 0,
            token: isSet(object.token) ? String(object.token) : "",
            endTime: isSet(object.endTime) ? String(object.endTime) : "0",
        };
    },
    toJSON(message) {
        const obj = {};
        message.perPage !== undefined && (obj.perPage = Math.round(message.perPage));
        message.token !== undefined && (obj.token = message.token);
        message.endTime !== undefined && (obj.endTime = message.endTime);
        return obj;
    },
    create(base) {
        return AuctionsHistoryV2Request.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseAuctionsHistoryV2Request();
        message.perPage = object.perPage ?? 0;
        message.token = object.token ?? "";
        message.endTime = object.endTime ?? "0";
        return message;
    },
};
function createBaseAuctionsHistoryV2Response() {
    return { auctions: [], next: [] };
}
export const AuctionsHistoryV2Response = {
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.auctions) {
            AuctionV2Result.encode(v, writer.uint32(10).fork()).ldelim();
        }
        for (const v of message.next) {
            writer.uint32(18).string(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAuctionsHistoryV2Response();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.auctions.push(AuctionV2Result.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.next.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            auctions: Array.isArray(object?.auctions) ? object.auctions.map((e) => AuctionV2Result.fromJSON(e)) : [],
            next: Array.isArray(object?.next) ? object.next.map((e) => String(e)) : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.auctions) {
            obj.auctions = message.auctions.map((e) => e ? AuctionV2Result.toJSON(e) : undefined);
        }
        else {
            obj.auctions = [];
        }
        if (message.next) {
            obj.next = message.next.map((e) => e);
        }
        else {
            obj.next = [];
        }
        return obj;
    },
    create(base) {
        return AuctionsHistoryV2Response.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseAuctionsHistoryV2Response();
        message.auctions = object.auctions?.map((e) => AuctionV2Result.fromPartial(e)) || [];
        message.next = object.next?.map((e) => e) || [];
        return message;
    },
};
function createBaseAuctionV2Result() {
    return {
        winner: "",
        basket: [],
        winningBidAmount: "",
        round: "0",
        endTimestamp: "0",
        updatedAt: "0",
        contract: undefined,
        winningBidAmountUsd: "",
    };
}
export const AuctionV2Result = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.winner !== "") {
            writer.uint32(10).string(message.winner);
        }
        for (const v of message.basket) {
            CoinPrices.encode(v, writer.uint32(18).fork()).ldelim();
        }
        if (message.winningBidAmount !== "") {
            writer.uint32(26).string(message.winningBidAmount);
        }
        if (message.round !== "0") {
            writer.uint32(32).uint64(message.round);
        }
        if (message.endTimestamp !== "0") {
            writer.uint32(40).sint64(message.endTimestamp);
        }
        if (message.updatedAt !== "0") {
            writer.uint32(48).sint64(message.updatedAt);
        }
        if (message.contract !== undefined) {
            AuctionContract.encode(message.contract, writer.uint32(58).fork()).ldelim();
        }
        if (message.winningBidAmountUsd !== "") {
            writer.uint32(66).string(message.winningBidAmountUsd);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAuctionV2Result();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.winner = reader.string();
                    break;
                case 2:
                    message.basket.push(CoinPrices.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.winningBidAmount = reader.string();
                    break;
                case 4:
                    message.round = longToString(reader.uint64());
                    break;
                case 5:
                    message.endTimestamp = longToString(reader.sint64());
                    break;
                case 6:
                    message.updatedAt = longToString(reader.sint64());
                    break;
                case 7:
                    message.contract = AuctionContract.decode(reader, reader.uint32());
                    break;
                case 8:
                    message.winningBidAmountUsd = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            winner: isSet(object.winner) ? String(object.winner) : "",
            basket: Array.isArray(object?.basket) ? object.basket.map((e) => CoinPrices.fromJSON(e)) : [],
            winningBidAmount: isSet(object.winningBidAmount) ? String(object.winningBidAmount) : "",
            round: isSet(object.round) ? String(object.round) : "0",
            endTimestamp: isSet(object.endTimestamp) ? String(object.endTimestamp) : "0",
            updatedAt: isSet(object.updatedAt) ? String(object.updatedAt) : "0",
            contract: isSet(object.contract) ? AuctionContract.fromJSON(object.contract) : undefined,
            winningBidAmountUsd: isSet(object.winningBidAmountUsd) ? String(object.winningBidAmountUsd) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.winner !== undefined && (obj.winner = message.winner);
        if (message.basket) {
            obj.basket = message.basket.map((e) => e ? CoinPrices.toJSON(e) : undefined);
        }
        else {
            obj.basket = [];
        }
        message.winningBidAmount !== undefined && (obj.winningBidAmount = message.winningBidAmount);
        message.round !== undefined && (obj.round = message.round);
        message.endTimestamp !== undefined && (obj.endTimestamp = message.endTimestamp);
        message.updatedAt !== undefined && (obj.updatedAt = message.updatedAt);
        message.contract !== undefined &&
            (obj.contract = message.contract ? AuctionContract.toJSON(message.contract) : undefined);
        message.winningBidAmountUsd !== undefined && (obj.winningBidAmountUsd = message.winningBidAmountUsd);
        return obj;
    },
    create(base) {
        return AuctionV2Result.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseAuctionV2Result();
        message.winner = object.winner ?? "";
        message.basket = object.basket?.map((e) => CoinPrices.fromPartial(e)) || [];
        message.winningBidAmount = object.winningBidAmount ?? "";
        message.round = object.round ?? "0";
        message.endTimestamp = object.endTimestamp ?? "0";
        message.updatedAt = object.updatedAt ?? "0";
        message.contract = (object.contract !== undefined && object.contract !== null)
            ? AuctionContract.fromPartial(object.contract)
            : undefined;
        message.winningBidAmountUsd = object.winningBidAmountUsd ?? "";
        return message;
    },
};
function createBaseCoinPrices() {
    return { denom: "", amount: "", prices: {} };
}
export const CoinPrices = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.denom !== "") {
            writer.uint32(10).string(message.denom);
        }
        if (message.amount !== "") {
            writer.uint32(18).string(message.amount);
        }
        Object.entries(message.prices).forEach(([key, value]) => {
            CoinPrices_PricesEntry.encode({ key: key, value }, writer.uint32(26).fork()).ldelim();
        });
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCoinPrices();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.denom = reader.string();
                    break;
                case 2:
                    message.amount = reader.string();
                    break;
                case 3:
                    const entry3 = CoinPrices_PricesEntry.decode(reader, reader.uint32());
                    if (entry3.value !== undefined) {
                        message.prices[entry3.key] = entry3.value;
                    }
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            denom: isSet(object.denom) ? String(object.denom) : "",
            amount: isSet(object.amount) ? String(object.amount) : "",
            prices: isObject(object.prices)
                ? Object.entries(object.prices).reduce((acc, [key, value]) => {
                    acc[key] = String(value);
                    return acc;
                }, {})
                : {},
        };
    },
    toJSON(message) {
        const obj = {};
        message.denom !== undefined && (obj.denom = message.denom);
        message.amount !== undefined && (obj.amount = message.amount);
        obj.prices = {};
        if (message.prices) {
            Object.entries(message.prices).forEach(([k, v]) => {
                obj.prices[k] = v;
            });
        }
        return obj;
    },
    create(base) {
        return CoinPrices.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseCoinPrices();
        message.denom = object.denom ?? "";
        message.amount = object.amount ?? "";
        message.prices = Object.entries(object.prices ?? {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = String(value);
            }
            return acc;
        }, {});
        return message;
    },
};
function createBaseCoinPrices_PricesEntry() {
    return { key: "", value: "" };
}
export const CoinPrices_PricesEntry = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== "") {
            writer.uint32(18).string(message.value);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCoinPrices_PricesEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return { key: isSet(object.key) ? String(object.key) : "", value: isSet(object.value) ? String(object.value) : "" };
    },
    toJSON(message) {
        const obj = {};
        message.key !== undefined && (obj.key = message.key);
        message.value !== undefined && (obj.value = message.value);
        return obj;
    },
    create(base) {
        return CoinPrices_PricesEntry.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseCoinPrices_PricesEntry();
        message.key = object.key ?? "";
        message.value = object.value ?? "";
        return message;
    },
};
function createBaseAuctionV2Request() {
    return { round: "0" };
}
export const AuctionV2Request = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.round !== "0") {
            writer.uint32(8).sint64(message.round);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAuctionV2Request();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.round = longToString(reader.sint64());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return { round: isSet(object.round) ? String(object.round) : "0" };
    },
    toJSON(message) {
        const obj = {};
        message.round !== undefined && (obj.round = message.round);
        return obj;
    },
    create(base) {
        return AuctionV2Request.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseAuctionV2Request();
        message.round = object.round ?? "0";
        return message;
    },
};
function createBaseAuctionV2Response() {
    return {
        winner: "",
        basket: [],
        winningBidAmount: "",
        round: "0",
        endTimestamp: "0",
        updatedAt: "0",
        contract: undefined,
        winningBidAmountUsd: "",
    };
}
export const AuctionV2Response = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.winner !== "") {
            writer.uint32(10).string(message.winner);
        }
        for (const v of message.basket) {
            CoinPrices.encode(v, writer.uint32(18).fork()).ldelim();
        }
        if (message.winningBidAmount !== "") {
            writer.uint32(26).string(message.winningBidAmount);
        }
        if (message.round !== "0") {
            writer.uint32(32).uint64(message.round);
        }
        if (message.endTimestamp !== "0") {
            writer.uint32(40).sint64(message.endTimestamp);
        }
        if (message.updatedAt !== "0") {
            writer.uint32(48).sint64(message.updatedAt);
        }
        if (message.contract !== undefined) {
            AuctionContract.encode(message.contract, writer.uint32(58).fork()).ldelim();
        }
        if (message.winningBidAmountUsd !== "") {
            writer.uint32(66).string(message.winningBidAmountUsd);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAuctionV2Response();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.winner = reader.string();
                    break;
                case 2:
                    message.basket.push(CoinPrices.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.winningBidAmount = reader.string();
                    break;
                case 4:
                    message.round = longToString(reader.uint64());
                    break;
                case 5:
                    message.endTimestamp = longToString(reader.sint64());
                    break;
                case 6:
                    message.updatedAt = longToString(reader.sint64());
                    break;
                case 7:
                    message.contract = AuctionContract.decode(reader, reader.uint32());
                    break;
                case 8:
                    message.winningBidAmountUsd = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            winner: isSet(object.winner) ? String(object.winner) : "",
            basket: Array.isArray(object?.basket) ? object.basket.map((e) => CoinPrices.fromJSON(e)) : [],
            winningBidAmount: isSet(object.winningBidAmount) ? String(object.winningBidAmount) : "",
            round: isSet(object.round) ? String(object.round) : "0",
            endTimestamp: isSet(object.endTimestamp) ? String(object.endTimestamp) : "0",
            updatedAt: isSet(object.updatedAt) ? String(object.updatedAt) : "0",
            contract: isSet(object.contract) ? AuctionContract.fromJSON(object.contract) : undefined,
            winningBidAmountUsd: isSet(object.winningBidAmountUsd) ? String(object.winningBidAmountUsd) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.winner !== undefined && (obj.winner = message.winner);
        if (message.basket) {
            obj.basket = message.basket.map((e) => e ? CoinPrices.toJSON(e) : undefined);
        }
        else {
            obj.basket = [];
        }
        message.winningBidAmount !== undefined && (obj.winningBidAmount = message.winningBidAmount);
        message.round !== undefined && (obj.round = message.round);
        message.endTimestamp !== undefined && (obj.endTimestamp = message.endTimestamp);
        message.updatedAt !== undefined && (obj.updatedAt = message.updatedAt);
        message.contract !== undefined &&
            (obj.contract = message.contract ? AuctionContract.toJSON(message.contract) : undefined);
        message.winningBidAmountUsd !== undefined && (obj.winningBidAmountUsd = message.winningBidAmountUsd);
        return obj;
    },
    create(base) {
        return AuctionV2Response.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseAuctionV2Response();
        message.winner = object.winner ?? "";
        message.basket = object.basket?.map((e) => CoinPrices.fromPartial(e)) || [];
        message.winningBidAmount = object.winningBidAmount ?? "";
        message.round = object.round ?? "0";
        message.endTimestamp = object.endTimestamp ?? "0";
        message.updatedAt = object.updatedAt ?? "0";
        message.contract = (object.contract !== undefined && object.contract !== null)
            ? AuctionContract.fromPartial(object.contract)
            : undefined;
        message.winningBidAmountUsd = object.winningBidAmountUsd ?? "";
        return message;
    },
};
function createBaseAccountAuctionsV2Request() {
    return { address: "", perPage: 0, token: "" };
}
export const AccountAuctionsV2Request = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.address !== "") {
            writer.uint32(10).string(message.address);
        }
        if (message.perPage !== 0) {
            writer.uint32(16).sint32(message.perPage);
        }
        if (message.token !== "") {
            writer.uint32(26).string(message.token);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAccountAuctionsV2Request();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.address = reader.string();
                    break;
                case 2:
                    message.perPage = reader.sint32();
                    break;
                case 3:
                    message.token = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            address: isSet(object.address) ? String(object.address) : "",
            perPage: isSet(object.perPage) ? Number(object.perPage) : 0,
            token: isSet(object.token) ? String(object.token) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.address !== undefined && (obj.address = message.address);
        message.perPage !== undefined && (obj.perPage = Math.round(message.perPage));
        message.token !== undefined && (obj.token = message.token);
        return obj;
    },
    create(base) {
        return AccountAuctionsV2Request.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseAccountAuctionsV2Request();
        message.address = object.address ?? "";
        message.perPage = object.perPage ?? 0;
        message.token = object.token ?? "";
        return message;
    },
};
function createBaseAccountAuctionsV2Response() {
    return { auctions: [], next: [], total: "0" };
}
export const AccountAuctionsV2Response = {
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.auctions) {
            AccountAuctionV2.encode(v, writer.uint32(10).fork()).ldelim();
        }
        for (const v of message.next) {
            writer.uint32(18).string(v);
        }
        if (message.total !== "0") {
            writer.uint32(24).sint64(message.total);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAccountAuctionsV2Response();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.auctions.push(AccountAuctionV2.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.next.push(reader.string());
                    break;
                case 3:
                    message.total = longToString(reader.sint64());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            auctions: Array.isArray(object?.auctions) ? object.auctions.map((e) => AccountAuctionV2.fromJSON(e)) : [],
            next: Array.isArray(object?.next) ? object.next.map((e) => String(e)) : [],
            total: isSet(object.total) ? String(object.total) : "0",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.auctions) {
            obj.auctions = message.auctions.map((e) => e ? AccountAuctionV2.toJSON(e) : undefined);
        }
        else {
            obj.auctions = [];
        }
        if (message.next) {
            obj.next = message.next.map((e) => e);
        }
        else {
            obj.next = [];
        }
        message.total !== undefined && (obj.total = message.total);
        return obj;
    },
    create(base) {
        return AccountAuctionsV2Response.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseAccountAuctionsV2Response();
        message.auctions = object.auctions?.map((e) => AccountAuctionV2.fromPartial(e)) || [];
        message.next = object.next?.map((e) => e) || [];
        message.total = object.total ?? "0";
        return message;
    },
};
function createBaseAccountAuctionV2() {
    return { id: "0", round: "0", amountDeposited: "", isClaimable: false, claimedAssets: [] };
}
export const AccountAuctionV2 = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.id !== "0") {
            writer.uint32(8).uint64(message.id);
        }
        if (message.round !== "0") {
            writer.uint32(16).uint64(message.round);
        }
        if (message.amountDeposited !== "") {
            writer.uint32(26).string(message.amountDeposited);
        }
        if (message.isClaimable === true) {
            writer.uint32(32).bool(message.isClaimable);
        }
        for (const v of message.claimedAssets) {
            CoinPrices.encode(v, writer.uint32(42).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAccountAuctionV2();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.id = longToString(reader.uint64());
                    break;
                case 2:
                    message.round = longToString(reader.uint64());
                    break;
                case 3:
                    message.amountDeposited = reader.string();
                    break;
                case 4:
                    message.isClaimable = reader.bool();
                    break;
                case 5:
                    message.claimedAssets.push(CoinPrices.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            id: isSet(object.id) ? String(object.id) : "0",
            round: isSet(object.round) ? String(object.round) : "0",
            amountDeposited: isSet(object.amountDeposited) ? String(object.amountDeposited) : "",
            isClaimable: isSet(object.isClaimable) ? Boolean(object.isClaimable) : false,
            claimedAssets: Array.isArray(object?.claimedAssets)
                ? object.claimedAssets.map((e) => CoinPrices.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        message.id !== undefined && (obj.id = message.id);
        message.round !== undefined && (obj.round = message.round);
        message.amountDeposited !== undefined && (obj.amountDeposited = message.amountDeposited);
        message.isClaimable !== undefined && (obj.isClaimable = message.isClaimable);
        if (message.claimedAssets) {
            obj.claimedAssets = message.claimedAssets.map((e) => e ? CoinPrices.toJSON(e) : undefined);
        }
        else {
            obj.claimedAssets = [];
        }
        return obj;
    },
    create(base) {
        return AccountAuctionV2.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseAccountAuctionV2();
        message.id = object.id ?? "0";
        message.round = object.round ?? "0";
        message.amountDeposited = object.amountDeposited ?? "";
        message.isClaimable = object.isClaimable ?? false;
        message.claimedAssets = object.claimedAssets?.map((e) => CoinPrices.fromPartial(e)) || [];
        return message;
    },
};
function createBaseStreamBidsRequest() {
    return {};
}
export const StreamBidsRequest = {
    encode(_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseStreamBidsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return StreamBidsRequest.fromPartial(base ?? {});
    },
    fromPartial(_) {
        const message = createBaseStreamBidsRequest();
        return message;
    },
};
function createBaseStreamBidsResponse() {
    return { bidder: "", bidAmount: "", round: "0", timestamp: "0" };
}
export const StreamBidsResponse = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.bidder !== "") {
            writer.uint32(10).string(message.bidder);
        }
        if (message.bidAmount !== "") {
            writer.uint32(18).string(message.bidAmount);
        }
        if (message.round !== "0") {
            writer.uint32(24).uint64(message.round);
        }
        if (message.timestamp !== "0") {
            writer.uint32(32).sint64(message.timestamp);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseStreamBidsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.bidder = reader.string();
                    break;
                case 2:
                    message.bidAmount = reader.string();
                    break;
                case 3:
                    message.round = longToString(reader.uint64());
                    break;
                case 4:
                    message.timestamp = longToString(reader.sint64());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            bidder: isSet(object.bidder) ? String(object.bidder) : "",
            bidAmount: isSet(object.bidAmount) ? String(object.bidAmount) : "",
            round: isSet(object.round) ? String(object.round) : "0",
            timestamp: isSet(object.timestamp) ? String(object.timestamp) : "0",
        };
    },
    toJSON(message) {
        const obj = {};
        message.bidder !== undefined && (obj.bidder = message.bidder);
        message.bidAmount !== undefined && (obj.bidAmount = message.bidAmount);
        message.round !== undefined && (obj.round = message.round);
        message.timestamp !== undefined && (obj.timestamp = message.timestamp);
        return obj;
    },
    create(base) {
        return StreamBidsResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseStreamBidsResponse();
        message.bidder = object.bidder ?? "";
        message.bidAmount = object.bidAmount ?? "";
        message.round = object.round ?? "0";
        message.timestamp = object.timestamp ?? "0";
        return message;
    },
};
function createBaseInjBurntEndpointRequest() {
    return {};
}
export const InjBurntEndpointRequest = {
    encode(_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseInjBurntEndpointRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return InjBurntEndpointRequest.fromPartial(base ?? {});
    },
    fromPartial(_) {
        const message = createBaseInjBurntEndpointRequest();
        return message;
    },
};
function createBaseInjBurntEndpointResponse() {
    return { totalInjBurnt: "" };
}
export const InjBurntEndpointResponse = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.totalInjBurnt !== "") {
            writer.uint32(10).string(message.totalInjBurnt);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseInjBurntEndpointResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.totalInjBurnt = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return { totalInjBurnt: isSet(object.totalInjBurnt) ? String(object.totalInjBurnt) : "" };
    },
    toJSON(message) {
        const obj = {};
        message.totalInjBurnt !== undefined && (obj.totalInjBurnt = message.totalInjBurnt);
        return obj;
    },
    create(base) {
        return InjBurntEndpointResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseInjBurntEndpointResponse();
        message.totalInjBurnt = object.totalInjBurnt ?? "";
        return message;
    },
};
function createBaseAuctionsStatsRequest() {
    return {};
}
export const AuctionsStatsRequest = {
    encode(_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAuctionsStatsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return AuctionsStatsRequest.fromPartial(base ?? {});
    },
    fromPartial(_) {
        const message = createBaseAuctionsStatsRequest();
        return message;
    },
};
function createBaseAuctionsStatsResponse() {
    return { totalBurnt: "", totalUsdValue: "" };
}
export const AuctionsStatsResponse = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.totalBurnt !== "") {
            writer.uint32(10).string(message.totalBurnt);
        }
        if (message.totalUsdValue !== "") {
            writer.uint32(18).string(message.totalUsdValue);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAuctionsStatsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.totalBurnt = reader.string();
                    break;
                case 2:
                    message.totalUsdValue = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            totalBurnt: isSet(object.totalBurnt) ? String(object.totalBurnt) : "",
            totalUsdValue: isSet(object.totalUsdValue) ? String(object.totalUsdValue) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.totalBurnt !== undefined && (obj.totalBurnt = message.totalBurnt);
        message.totalUsdValue !== undefined && (obj.totalUsdValue = message.totalUsdValue);
        return obj;
    },
    create(base) {
        return AuctionsStatsResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseAuctionsStatsResponse();
        message.totalBurnt = object.totalBurnt ?? "";
        message.totalUsdValue = object.totalUsdValue ?? "";
        return message;
    },
};
export class InjectiveAuctionRPCClientImpl {
    rpc;
    constructor(rpc) {
        this.rpc = rpc;
        this.AuctionEndpoint = this.AuctionEndpoint.bind(this);
        this.Auctions = this.Auctions.bind(this);
        this.AuctionsHistoryV2 = this.AuctionsHistoryV2.bind(this);
        this.AuctionV2 = this.AuctionV2.bind(this);
        this.AccountAuctionsV2 = this.AccountAuctionsV2.bind(this);
        this.StreamBids = this.StreamBids.bind(this);
        this.InjBurntEndpoint = this.InjBurntEndpoint.bind(this);
        this.AuctionsStats = this.AuctionsStats.bind(this);
    }
    AuctionEndpoint(request, metadata) {
        return this.rpc.unary(InjectiveAuctionRPCAuctionEndpointDesc, AuctionEndpointRequest.fromPartial(request), metadata);
    }
    Auctions(request, metadata) {
        return this.rpc.unary(InjectiveAuctionRPCAuctionsDesc, AuctionsRequest.fromPartial(request), metadata);
    }
    AuctionsHistoryV2(request, metadata) {
        return this.rpc.unary(InjectiveAuctionRPCAuctionsHistoryV2Desc, AuctionsHistoryV2Request.fromPartial(request), metadata);
    }
    AuctionV2(request, metadata) {
        return this.rpc.unary(InjectiveAuctionRPCAuctionV2Desc, AuctionV2Request.fromPartial(request), metadata);
    }
    AccountAuctionsV2(request, metadata) {
        return this.rpc.unary(InjectiveAuctionRPCAccountAuctionsV2Desc, AccountAuctionsV2Request.fromPartial(request), metadata);
    }
    StreamBids(request, metadata) {
        return this.rpc.invoke(InjectiveAuctionRPCStreamBidsDesc, StreamBidsRequest.fromPartial(request), metadata);
    }
    InjBurntEndpoint(request, metadata) {
        return this.rpc.unary(InjectiveAuctionRPCInjBurntEndpointDesc, InjBurntEndpointRequest.fromPartial(request), metadata);
    }
    AuctionsStats(request, metadata) {
        return this.rpc.unary(InjectiveAuctionRPCAuctionsStatsDesc, AuctionsStatsRequest.fromPartial(request), metadata);
    }
}
export const InjectiveAuctionRPCDesc = { serviceName: "injective_auction_rpc.InjectiveAuctionRPC" };
export const InjectiveAuctionRPCAuctionEndpointDesc = {
    methodName: "AuctionEndpoint",
    service: InjectiveAuctionRPCDesc,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return AuctionEndpointRequest.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = AuctionEndpointResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
export const InjectiveAuctionRPCAuctionsDesc = {
    methodName: "Auctions",
    service: InjectiveAuctionRPCDesc,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return AuctionsRequest.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = AuctionsResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
export const InjectiveAuctionRPCAuctionsHistoryV2Desc = {
    methodName: "AuctionsHistoryV2",
    service: InjectiveAuctionRPCDesc,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return AuctionsHistoryV2Request.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = AuctionsHistoryV2Response.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
export const InjectiveAuctionRPCAuctionV2Desc = {
    methodName: "AuctionV2",
    service: InjectiveAuctionRPCDesc,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return AuctionV2Request.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = AuctionV2Response.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
export const InjectiveAuctionRPCAccountAuctionsV2Desc = {
    methodName: "AccountAuctionsV2",
    service: InjectiveAuctionRPCDesc,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return AccountAuctionsV2Request.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = AccountAuctionsV2Response.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
export const InjectiveAuctionRPCStreamBidsDesc = {
    methodName: "StreamBids",
    service: InjectiveAuctionRPCDesc,
    requestStream: false,
    responseStream: true,
    requestType: {
        serializeBinary() {
            return StreamBidsRequest.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = StreamBidsResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
export const InjectiveAuctionRPCInjBurntEndpointDesc = {
    methodName: "InjBurntEndpoint",
    service: InjectiveAuctionRPCDesc,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return InjBurntEndpointRequest.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = InjBurntEndpointResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
export const InjectiveAuctionRPCAuctionsStatsDesc = {
    methodName: "AuctionsStats",
    service: InjectiveAuctionRPCDesc,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return AuctionsStatsRequest.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = AuctionsStatsResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
export class GrpcWebImpl {
    host;
    options;
    constructor(host, options) {
        this.host = host;
        this.options = options;
    }
    unary(methodDesc, _request, metadata) {
        const request = { ..._request, ...methodDesc.requestType };
        const maybeCombinedMetadata = metadata && this.options.metadata
            ? new BrowserHeaders({ ...this.options?.metadata.headersMap, ...metadata?.headersMap })
            : metadata || this.options.metadata;
        return new Promise((resolve, reject) => {
            grpc.unary(methodDesc, {
                request,
                host: this.host,
                metadata: maybeCombinedMetadata,
                transport: this.options.transport,
                debug: this.options.debug,
                onEnd: function (response) {
                    if (response.status === grpc.Code.OK) {
                        resolve(response.message.toObject());
                    }
                    else {
                        const err = new GrpcWebError(response.statusMessage, response.status, response.trailers);
                        reject(err);
                    }
                },
            });
        });
    }
    invoke(methodDesc, _request, metadata) {
        const upStreamCodes = this.options.upStreamRetryCodes || [];
        const DEFAULT_TIMEOUT_TIME = 3_000;
        const request = { ..._request, ...methodDesc.requestType };
        const maybeCombinedMetadata = metadata && this.options.metadata
            ? new BrowserHeaders({ ...this.options?.metadata.headersMap, ...metadata?.headersMap })
            : metadata || this.options.metadata;
        return new Observable((observer) => {
            const upStream = (() => {
                const client = grpc.invoke(methodDesc, {
                    host: this.host,
                    request,
                    transport: this.options.streamingTransport || this.options.transport,
                    metadata: maybeCombinedMetadata,
                    debug: this.options.debug,
                    onMessage: (next) => observer.next(next),
                    onEnd: (code, message, trailers) => {
                        if (code === 0) {
                            observer.complete();
                        }
                        else if (upStreamCodes.includes(code)) {
                            setTimeout(upStream, DEFAULT_TIMEOUT_TIME);
                        }
                        else {
                            const err = new Error(message);
                            err.code = code;
                            err.metadata = trailers;
                            observer.error(err);
                        }
                    },
                });
                observer.add(() => {
                    if (!observer.closed) {
                        return client.close();
                    }
                });
            });
            upStream();
        }).pipe(share());
    }
}
var tsProtoGlobalThis = (() => {
    if (typeof globalThis !== "undefined") {
        return globalThis;
    }
    if (typeof self !== "undefined") {
        return self;
    }
    if (typeof window !== "undefined") {
        return window;
    }
    if (typeof global !== "undefined") {
        return global;
    }
    throw "Unable to locate global object";
})();
function longToString(long) {
    return long.toString();
}
if (_m0.util.Long !== Long) {
    _m0.util.Long = Long;
    _m0.configure();
}
function isObject(value) {
    return typeof value === "object" && value !== null;
}
function isSet(value) {
    return value !== null && value !== undefined;
}
export class GrpcWebError extends tsProtoGlobalThis.Error {
    code;
    metadata;
    constructor(message, code, metadata) {
        super(message);
        this.code = code;
        this.metadata = metadata;
    }
}
