/* eslint-disable */
import { grpc } from "@injectivelabs/grpc-web";
import { BrowserHeaders } from "browser-headers";
import Long from "long";
import _m0 from "protobufjs/minimal.js";
export const protobufPackage = "injective_megavault_rpc";
function createBaseGetVaultRequest() {
    return { vaultAddress: "" };
}
export const GetVaultRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.vaultAddress !== "") {
            writer.uint32(10).string(message.vaultAddress);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetVaultRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.vaultAddress = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return { vaultAddress: isSet(object.vaultAddress) ? String(object.vaultAddress) : "" };
    },
    toJSON(message) {
        const obj = {};
        message.vaultAddress !== undefined && (obj.vaultAddress = message.vaultAddress);
        return obj;
    },
    create(base) {
        return GetVaultRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseGetVaultRequest();
        message.vaultAddress = object.vaultAddress ?? "";
        return message;
    },
};
function createBaseGetVaultResponse() {
    return { vault: undefined };
}
export const GetVaultResponse = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.vault !== undefined) {
            Vault.encode(message.vault, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetVaultResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.vault = Vault.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return { vault: isSet(object.vault) ? Vault.fromJSON(object.vault) : undefined };
    },
    toJSON(message) {
        const obj = {};
        message.vault !== undefined && (obj.vault = message.vault ? Vault.toJSON(message.vault) : undefined);
        return obj;
    },
    create(base) {
        return GetVaultResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseGetVaultResponse();
        message.vault = (object.vault !== undefined && object.vault !== null) ? Vault.fromPartial(object.vault) : undefined;
        return message;
    },
};
function createBaseVault() {
    return {
        contractAddress: "",
        contractName: "",
        contractVersion: "",
        admin: "",
        lpDenom: "",
        quoteDenom: "",
        operators: [],
        incentives: undefined,
        targetApr: undefined,
        stats: undefined,
        createdHeight: "0",
        createdAt: "0",
        updatedHeight: "0",
        updatedAt: "0",
    };
}
export const Vault = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.contractAddress !== "") {
            writer.uint32(10).string(message.contractAddress);
        }
        if (message.contractName !== "") {
            writer.uint32(18).string(message.contractName);
        }
        if (message.contractVersion !== "") {
            writer.uint32(26).string(message.contractVersion);
        }
        if (message.admin !== "") {
            writer.uint32(34).string(message.admin);
        }
        if (message.lpDenom !== "") {
            writer.uint32(42).string(message.lpDenom);
        }
        if (message.quoteDenom !== "") {
            writer.uint32(50).string(message.quoteDenom);
        }
        for (const v of message.operators) {
            Operator.encode(v, writer.uint32(58).fork()).ldelim();
        }
        if (message.incentives !== undefined) {
            Incentives.encode(message.incentives, writer.uint32(66).fork()).ldelim();
        }
        if (message.targetApr !== undefined) {
            TargetApr.encode(message.targetApr, writer.uint32(74).fork()).ldelim();
        }
        if (message.stats !== undefined) {
            VaultStats.encode(message.stats, writer.uint32(82).fork()).ldelim();
        }
        if (message.createdHeight !== "0") {
            writer.uint32(88).sint64(message.createdHeight);
        }
        if (message.createdAt !== "0") {
            writer.uint32(96).sint64(message.createdAt);
        }
        if (message.updatedHeight !== "0") {
            writer.uint32(104).sint64(message.updatedHeight);
        }
        if (message.updatedAt !== "0") {
            writer.uint32(112).sint64(message.updatedAt);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseVault();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.contractAddress = reader.string();
                    break;
                case 2:
                    message.contractName = reader.string();
                    break;
                case 3:
                    message.contractVersion = reader.string();
                    break;
                case 4:
                    message.admin = reader.string();
                    break;
                case 5:
                    message.lpDenom = reader.string();
                    break;
                case 6:
                    message.quoteDenom = reader.string();
                    break;
                case 7:
                    message.operators.push(Operator.decode(reader, reader.uint32()));
                    break;
                case 8:
                    message.incentives = Incentives.decode(reader, reader.uint32());
                    break;
                case 9:
                    message.targetApr = TargetApr.decode(reader, reader.uint32());
                    break;
                case 10:
                    message.stats = VaultStats.decode(reader, reader.uint32());
                    break;
                case 11:
                    message.createdHeight = longToString(reader.sint64());
                    break;
                case 12:
                    message.createdAt = longToString(reader.sint64());
                    break;
                case 13:
                    message.updatedHeight = longToString(reader.sint64());
                    break;
                case 14:
                    message.updatedAt = longToString(reader.sint64());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            contractAddress: isSet(object.contractAddress) ? String(object.contractAddress) : "",
            contractName: isSet(object.contractName) ? String(object.contractName) : "",
            contractVersion: isSet(object.contractVersion) ? String(object.contractVersion) : "",
            admin: isSet(object.admin) ? String(object.admin) : "",
            lpDenom: isSet(object.lpDenom) ? String(object.lpDenom) : "",
            quoteDenom: isSet(object.quoteDenom) ? String(object.quoteDenom) : "",
            operators: Array.isArray(object?.operators) ? object.operators.map((e) => Operator.fromJSON(e)) : [],
            incentives: isSet(object.incentives) ? Incentives.fromJSON(object.incentives) : undefined,
            targetApr: isSet(object.targetApr) ? TargetApr.fromJSON(object.targetApr) : undefined,
            stats: isSet(object.stats) ? VaultStats.fromJSON(object.stats) : undefined,
            createdHeight: isSet(object.createdHeight) ? String(object.createdHeight) : "0",
            createdAt: isSet(object.createdAt) ? String(object.createdAt) : "0",
            updatedHeight: isSet(object.updatedHeight) ? String(object.updatedHeight) : "0",
            updatedAt: isSet(object.updatedAt) ? String(object.updatedAt) : "0",
        };
    },
    toJSON(message) {
        const obj = {};
        message.contractAddress !== undefined && (obj.contractAddress = message.contractAddress);
        message.contractName !== undefined && (obj.contractName = message.contractName);
        message.contractVersion !== undefined && (obj.contractVersion = message.contractVersion);
        message.admin !== undefined && (obj.admin = message.admin);
        message.lpDenom !== undefined && (obj.lpDenom = message.lpDenom);
        message.quoteDenom !== undefined && (obj.quoteDenom = message.quoteDenom);
        if (message.operators) {
            obj.operators = message.operators.map((e) => e ? Operator.toJSON(e) : undefined);
        }
        else {
            obj.operators = [];
        }
        message.incentives !== undefined &&
            (obj.incentives = message.incentives ? Incentives.toJSON(message.incentives) : undefined);
        message.targetApr !== undefined &&
            (obj.targetApr = message.targetApr ? TargetApr.toJSON(message.targetApr) : undefined);
        message.stats !== undefined && (obj.stats = message.stats ? VaultStats.toJSON(message.stats) : undefined);
        message.createdHeight !== undefined && (obj.createdHeight = message.createdHeight);
        message.createdAt !== undefined && (obj.createdAt = message.createdAt);
        message.updatedHeight !== undefined && (obj.updatedHeight = message.updatedHeight);
        message.updatedAt !== undefined && (obj.updatedAt = message.updatedAt);
        return obj;
    },
    create(base) {
        return Vault.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseVault();
        message.contractAddress = object.contractAddress ?? "";
        message.contractName = object.contractName ?? "";
        message.contractVersion = object.contractVersion ?? "";
        message.admin = object.admin ?? "";
        message.lpDenom = object.lpDenom ?? "";
        message.quoteDenom = object.quoteDenom ?? "";
        message.operators = object.operators?.map((e) => Operator.fromPartial(e)) || [];
        message.incentives = (object.incentives !== undefined && object.incentives !== null)
            ? Incentives.fromPartial(object.incentives)
            : undefined;
        message.targetApr = (object.targetApr !== undefined && object.targetApr !== null)
            ? TargetApr.fromPartial(object.targetApr)
            : undefined;
        message.stats = (object.stats !== undefined && object.stats !== null)
            ? VaultStats.fromPartial(object.stats)
            : undefined;
        message.createdHeight = object.createdHeight ?? "0";
        message.createdAt = object.createdAt ?? "0";
        message.updatedHeight = object.updatedHeight ?? "0";
        message.updatedAt = object.updatedAt ?? "0";
        return message;
    },
};
function createBaseOperator() {
    return { address: "", totalAmount: "", totalLiquidAmount: "", updatedHeight: "0", updatedAt: "0" };
}
export const Operator = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.address !== "") {
            writer.uint32(10).string(message.address);
        }
        if (message.totalAmount !== "") {
            writer.uint32(18).string(message.totalAmount);
        }
        if (message.totalLiquidAmount !== "") {
            writer.uint32(26).string(message.totalLiquidAmount);
        }
        if (message.updatedHeight !== "0") {
            writer.uint32(32).sint64(message.updatedHeight);
        }
        if (message.updatedAt !== "0") {
            writer.uint32(40).sint64(message.updatedAt);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseOperator();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.address = reader.string();
                    break;
                case 2:
                    message.totalAmount = reader.string();
                    break;
                case 3:
                    message.totalLiquidAmount = reader.string();
                    break;
                case 4:
                    message.updatedHeight = longToString(reader.sint64());
                    break;
                case 5:
                    message.updatedAt = longToString(reader.sint64());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            address: isSet(object.address) ? String(object.address) : "",
            totalAmount: isSet(object.totalAmount) ? String(object.totalAmount) : "",
            totalLiquidAmount: isSet(object.totalLiquidAmount) ? String(object.totalLiquidAmount) : "",
            updatedHeight: isSet(object.updatedHeight) ? String(object.updatedHeight) : "0",
            updatedAt: isSet(object.updatedAt) ? String(object.updatedAt) : "0",
        };
    },
    toJSON(message) {
        const obj = {};
        message.address !== undefined && (obj.address = message.address);
        message.totalAmount !== undefined && (obj.totalAmount = message.totalAmount);
        message.totalLiquidAmount !== undefined && (obj.totalLiquidAmount = message.totalLiquidAmount);
        message.updatedHeight !== undefined && (obj.updatedHeight = message.updatedHeight);
        message.updatedAt !== undefined && (obj.updatedAt = message.updatedAt);
        return obj;
    },
    create(base) {
        return Operator.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseOperator();
        message.address = object.address ?? "";
        message.totalAmount = object.totalAmount ?? "";
        message.totalLiquidAmount = object.totalLiquidAmount ?? "";
        message.updatedHeight = object.updatedHeight ?? "0";
        message.updatedAt = object.updatedAt ?? "0";
        return message;
    },
};
function createBaseIncentives() {
    return { address: "", amount: "", updatedHeight: "0", updatedAt: "0" };
}
export const Incentives = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.address !== "") {
            writer.uint32(10).string(message.address);
        }
        if (message.amount !== "") {
            writer.uint32(18).string(message.amount);
        }
        if (message.updatedHeight !== "0") {
            writer.uint32(24).sint64(message.updatedHeight);
        }
        if (message.updatedAt !== "0") {
            writer.uint32(32).sint64(message.updatedAt);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseIncentives();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.address = reader.string();
                    break;
                case 2:
                    message.amount = reader.string();
                    break;
                case 3:
                    message.updatedHeight = longToString(reader.sint64());
                    break;
                case 4:
                    message.updatedAt = longToString(reader.sint64());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            address: isSet(object.address) ? String(object.address) : "",
            amount: isSet(object.amount) ? String(object.amount) : "",
            updatedHeight: isSet(object.updatedHeight) ? String(object.updatedHeight) : "0",
            updatedAt: isSet(object.updatedAt) ? String(object.updatedAt) : "0",
        };
    },
    toJSON(message) {
        const obj = {};
        message.address !== undefined && (obj.address = message.address);
        message.amount !== undefined && (obj.amount = message.amount);
        message.updatedHeight !== undefined && (obj.updatedHeight = message.updatedHeight);
        message.updatedAt !== undefined && (obj.updatedAt = message.updatedAt);
        return obj;
    },
    create(base) {
        return Incentives.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseIncentives();
        message.address = object.address ?? "";
        message.amount = object.amount ?? "";
        message.updatedHeight = object.updatedHeight ?? "0";
        message.updatedAt = object.updatedAt ?? "0";
        return message;
    },
};
function createBaseTargetApr() {
    return { apr: "", upperThreshold: "", lowerThreshold: "", updatedHeight: "0", updatedAt: "0" };
}
export const TargetApr = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.apr !== "") {
            writer.uint32(10).string(message.apr);
        }
        if (message.upperThreshold !== "") {
            writer.uint32(18).string(message.upperThreshold);
        }
        if (message.lowerThreshold !== "") {
            writer.uint32(26).string(message.lowerThreshold);
        }
        if (message.updatedHeight !== "0") {
            writer.uint32(32).sint64(message.updatedHeight);
        }
        if (message.updatedAt !== "0") {
            writer.uint32(40).sint64(message.updatedAt);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTargetApr();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.apr = reader.string();
                    break;
                case 2:
                    message.upperThreshold = reader.string();
                    break;
                case 3:
                    message.lowerThreshold = reader.string();
                    break;
                case 4:
                    message.updatedHeight = longToString(reader.sint64());
                    break;
                case 5:
                    message.updatedAt = longToString(reader.sint64());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            apr: isSet(object.apr) ? String(object.apr) : "",
            upperThreshold: isSet(object.upperThreshold) ? String(object.upperThreshold) : "",
            lowerThreshold: isSet(object.lowerThreshold) ? String(object.lowerThreshold) : "",
            updatedHeight: isSet(object.updatedHeight) ? String(object.updatedHeight) : "0",
            updatedAt: isSet(object.updatedAt) ? String(object.updatedAt) : "0",
        };
    },
    toJSON(message) {
        const obj = {};
        message.apr !== undefined && (obj.apr = message.apr);
        message.upperThreshold !== undefined && (obj.upperThreshold = message.upperThreshold);
        message.lowerThreshold !== undefined && (obj.lowerThreshold = message.lowerThreshold);
        message.updatedHeight !== undefined && (obj.updatedHeight = message.updatedHeight);
        message.updatedAt !== undefined && (obj.updatedAt = message.updatedAt);
        return obj;
    },
    create(base) {
        return TargetApr.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseTargetApr();
        message.apr = object.apr ?? "";
        message.upperThreshold = object.upperThreshold ?? "";
        message.lowerThreshold = object.lowerThreshold ?? "";
        message.updatedHeight = object.updatedHeight ?? "0";
        message.updatedAt = object.updatedAt ?? "0";
        return message;
    },
};
function createBaseVaultStats() {
    return {
        totalSubscribedAmount: "",
        totalRedeemedAmount: "",
        currentAmount: "",
        currentAmountWithoutIncentives: "",
        currentLpAmount: "",
        currentLpPrice: "",
        pnl: undefined,
        volatility: undefined,
        apr: undefined,
        maxDrawdown: undefined,
    };
}
export const VaultStats = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.totalSubscribedAmount !== "") {
            writer.uint32(10).string(message.totalSubscribedAmount);
        }
        if (message.totalRedeemedAmount !== "") {
            writer.uint32(18).string(message.totalRedeemedAmount);
        }
        if (message.currentAmount !== "") {
            writer.uint32(26).string(message.currentAmount);
        }
        if (message.currentAmountWithoutIncentives !== "") {
            writer.uint32(34).string(message.currentAmountWithoutIncentives);
        }
        if (message.currentLpAmount !== "") {
            writer.uint32(42).string(message.currentLpAmount);
        }
        if (message.currentLpPrice !== "") {
            writer.uint32(50).string(message.currentLpPrice);
        }
        if (message.pnl !== undefined) {
            PnlStats.encode(message.pnl, writer.uint32(58).fork()).ldelim();
        }
        if (message.volatility !== undefined) {
            VolatilityStats.encode(message.volatility, writer.uint32(66).fork()).ldelim();
        }
        if (message.apr !== undefined) {
            AprStats.encode(message.apr, writer.uint32(74).fork()).ldelim();
        }
        if (message.maxDrawdown !== undefined) {
            MaxDrawdown.encode(message.maxDrawdown, writer.uint32(82).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseVaultStats();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.totalSubscribedAmount = reader.string();
                    break;
                case 2:
                    message.totalRedeemedAmount = reader.string();
                    break;
                case 3:
                    message.currentAmount = reader.string();
                    break;
                case 4:
                    message.currentAmountWithoutIncentives = reader.string();
                    break;
                case 5:
                    message.currentLpAmount = reader.string();
                    break;
                case 6:
                    message.currentLpPrice = reader.string();
                    break;
                case 7:
                    message.pnl = PnlStats.decode(reader, reader.uint32());
                    break;
                case 8:
                    message.volatility = VolatilityStats.decode(reader, reader.uint32());
                    break;
                case 9:
                    message.apr = AprStats.decode(reader, reader.uint32());
                    break;
                case 10:
                    message.maxDrawdown = MaxDrawdown.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            totalSubscribedAmount: isSet(object.totalSubscribedAmount) ? String(object.totalSubscribedAmount) : "",
            totalRedeemedAmount: isSet(object.totalRedeemedAmount) ? String(object.totalRedeemedAmount) : "",
            currentAmount: isSet(object.currentAmount) ? String(object.currentAmount) : "",
            currentAmountWithoutIncentives: isSet(object.currentAmountWithoutIncentives)
                ? String(object.currentAmountWithoutIncentives)
                : "",
            currentLpAmount: isSet(object.currentLpAmount) ? String(object.currentLpAmount) : "",
            currentLpPrice: isSet(object.currentLpPrice) ? String(object.currentLpPrice) : "",
            pnl: isSet(object.pnl) ? PnlStats.fromJSON(object.pnl) : undefined,
            volatility: isSet(object.volatility) ? VolatilityStats.fromJSON(object.volatility) : undefined,
            apr: isSet(object.apr) ? AprStats.fromJSON(object.apr) : undefined,
            maxDrawdown: isSet(object.maxDrawdown) ? MaxDrawdown.fromJSON(object.maxDrawdown) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.totalSubscribedAmount !== undefined && (obj.totalSubscribedAmount = message.totalSubscribedAmount);
        message.totalRedeemedAmount !== undefined && (obj.totalRedeemedAmount = message.totalRedeemedAmount);
        message.currentAmount !== undefined && (obj.currentAmount = message.currentAmount);
        message.currentAmountWithoutIncentives !== undefined &&
            (obj.currentAmountWithoutIncentives = message.currentAmountWithoutIncentives);
        message.currentLpAmount !== undefined && (obj.currentLpAmount = message.currentLpAmount);
        message.currentLpPrice !== undefined && (obj.currentLpPrice = message.currentLpPrice);
        message.pnl !== undefined && (obj.pnl = message.pnl ? PnlStats.toJSON(message.pnl) : undefined);
        message.volatility !== undefined &&
            (obj.volatility = message.volatility ? VolatilityStats.toJSON(message.volatility) : undefined);
        message.apr !== undefined && (obj.apr = message.apr ? AprStats.toJSON(message.apr) : undefined);
        message.maxDrawdown !== undefined &&
            (obj.maxDrawdown = message.maxDrawdown ? MaxDrawdown.toJSON(message.maxDrawdown) : undefined);
        return obj;
    },
    create(base) {
        return VaultStats.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseVaultStats();
        message.totalSubscribedAmount = object.totalSubscribedAmount ?? "";
        message.totalRedeemedAmount = object.totalRedeemedAmount ?? "";
        message.currentAmount = object.currentAmount ?? "";
        message.currentAmountWithoutIncentives = object.currentAmountWithoutIncentives ?? "";
        message.currentLpAmount = object.currentLpAmount ?? "";
        message.currentLpPrice = object.currentLpPrice ?? "";
        message.pnl = (object.pnl !== undefined && object.pnl !== null) ? PnlStats.fromPartial(object.pnl) : undefined;
        message.volatility = (object.volatility !== undefined && object.volatility !== null)
            ? VolatilityStats.fromPartial(object.volatility)
            : undefined;
        message.apr = (object.apr !== undefined && object.apr !== null) ? AprStats.fromPartial(object.apr) : undefined;
        message.maxDrawdown = (object.maxDrawdown !== undefined && object.maxDrawdown !== null)
            ? MaxDrawdown.fromPartial(object.maxDrawdown)
            : undefined;
        return message;
    },
};
function createBasePnlStats() {
    return { unrealized: undefined, allTime: undefined };
}
export const PnlStats = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.unrealized !== undefined) {
            UnrealizedPnl.encode(message.unrealized, writer.uint32(10).fork()).ldelim();
        }
        if (message.allTime !== undefined) {
            Pnl.encode(message.allTime, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePnlStats();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.unrealized = UnrealizedPnl.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.allTime = Pnl.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            unrealized: isSet(object.unrealized) ? UnrealizedPnl.fromJSON(object.unrealized) : undefined,
            allTime: isSet(object.allTime) ? Pnl.fromJSON(object.allTime) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.unrealized !== undefined &&
            (obj.unrealized = message.unrealized ? UnrealizedPnl.toJSON(message.unrealized) : undefined);
        message.allTime !== undefined && (obj.allTime = message.allTime ? Pnl.toJSON(message.allTime) : undefined);
        return obj;
    },
    create(base) {
        return PnlStats.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBasePnlStats();
        message.unrealized = (object.unrealized !== undefined && object.unrealized !== null)
            ? UnrealizedPnl.fromPartial(object.unrealized)
            : undefined;
        message.allTime = (object.allTime !== undefined && object.allTime !== null)
            ? Pnl.fromPartial(object.allTime)
            : undefined;
        return message;
    },
};
function createBaseUnrealizedPnl() {
    return { value: "", percentage: "" };
}
export const UnrealizedPnl = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.value !== "") {
            writer.uint32(10).string(message.value);
        }
        if (message.percentage !== "") {
            writer.uint32(18).string(message.percentage);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUnrealizedPnl();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.value = reader.string();
                    break;
                case 2:
                    message.percentage = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            value: isSet(object.value) ? String(object.value) : "",
            percentage: isSet(object.percentage) ? String(object.percentage) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.value !== undefined && (obj.value = message.value);
        message.percentage !== undefined && (obj.percentage = message.percentage);
        return obj;
    },
    create(base) {
        return UnrealizedPnl.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseUnrealizedPnl();
        message.value = object.value ?? "";
        message.percentage = object.percentage ?? "";
        return message;
    },
};
function createBasePnl() {
    return { value: "", percentage: "", totalAmountSubscribed: "", totalAmountRedeemed: "", currentAmount: "" };
}
export const Pnl = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.value !== "") {
            writer.uint32(10).string(message.value);
        }
        if (message.percentage !== "") {
            writer.uint32(18).string(message.percentage);
        }
        if (message.totalAmountSubscribed !== "") {
            writer.uint32(26).string(message.totalAmountSubscribed);
        }
        if (message.totalAmountRedeemed !== "") {
            writer.uint32(34).string(message.totalAmountRedeemed);
        }
        if (message.currentAmount !== "") {
            writer.uint32(42).string(message.currentAmount);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePnl();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.value = reader.string();
                    break;
                case 2:
                    message.percentage = reader.string();
                    break;
                case 3:
                    message.totalAmountSubscribed = reader.string();
                    break;
                case 4:
                    message.totalAmountRedeemed = reader.string();
                    break;
                case 5:
                    message.currentAmount = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            value: isSet(object.value) ? String(object.value) : "",
            percentage: isSet(object.percentage) ? String(object.percentage) : "",
            totalAmountSubscribed: isSet(object.totalAmountSubscribed) ? String(object.totalAmountSubscribed) : "",
            totalAmountRedeemed: isSet(object.totalAmountRedeemed) ? String(object.totalAmountRedeemed) : "",
            currentAmount: isSet(object.currentAmount) ? String(object.currentAmount) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.value !== undefined && (obj.value = message.value);
        message.percentage !== undefined && (obj.percentage = message.percentage);
        message.totalAmountSubscribed !== undefined && (obj.totalAmountSubscribed = message.totalAmountSubscribed);
        message.totalAmountRedeemed !== undefined && (obj.totalAmountRedeemed = message.totalAmountRedeemed);
        message.currentAmount !== undefined && (obj.currentAmount = message.currentAmount);
        return obj;
    },
    create(base) {
        return Pnl.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBasePnl();
        message.value = object.value ?? "";
        message.percentage = object.percentage ?? "";
        message.totalAmountSubscribed = object.totalAmountSubscribed ?? "";
        message.totalAmountRedeemed = object.totalAmountRedeemed ?? "";
        message.currentAmount = object.currentAmount ?? "";
        return message;
    },
};
function createBaseVolatilityStats() {
    return { thirtyDays: undefined };
}
export const VolatilityStats = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.thirtyDays !== undefined) {
            Volatility.encode(message.thirtyDays, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseVolatilityStats();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.thirtyDays = Volatility.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return { thirtyDays: isSet(object.thirtyDays) ? Volatility.fromJSON(object.thirtyDays) : undefined };
    },
    toJSON(message) {
        const obj = {};
        message.thirtyDays !== undefined &&
            (obj.thirtyDays = message.thirtyDays ? Volatility.toJSON(message.thirtyDays) : undefined);
        return obj;
    },
    create(base) {
        return VolatilityStats.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseVolatilityStats();
        message.thirtyDays = (object.thirtyDays !== undefined && object.thirtyDays !== null)
            ? Volatility.fromPartial(object.thirtyDays)
            : undefined;
        return message;
    },
};
function createBaseVolatility() {
    return { value: "" };
}
export const Volatility = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.value !== "") {
            writer.uint32(10).string(message.value);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseVolatility();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.value = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return { value: isSet(object.value) ? String(object.value) : "" };
    },
    toJSON(message) {
        const obj = {};
        message.value !== undefined && (obj.value = message.value);
        return obj;
    },
    create(base) {
        return Volatility.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseVolatility();
        message.value = object.value ?? "";
        return message;
    },
};
function createBaseAprStats() {
    return { thirtyDays: undefined };
}
export const AprStats = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.thirtyDays !== undefined) {
            Apr.encode(message.thirtyDays, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAprStats();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.thirtyDays = Apr.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return { thirtyDays: isSet(object.thirtyDays) ? Apr.fromJSON(object.thirtyDays) : undefined };
    },
    toJSON(message) {
        const obj = {};
        message.thirtyDays !== undefined &&
            (obj.thirtyDays = message.thirtyDays ? Apr.toJSON(message.thirtyDays) : undefined);
        return obj;
    },
    create(base) {
        return AprStats.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseAprStats();
        message.thirtyDays = (object.thirtyDays !== undefined && object.thirtyDays !== null)
            ? Apr.fromPartial(object.thirtyDays)
            : undefined;
        return message;
    },
};
function createBaseApr() {
    return { value: "", originalLpPrice: "", currentLpPrice: "" };
}
export const Apr = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.value !== "") {
            writer.uint32(10).string(message.value);
        }
        if (message.originalLpPrice !== "") {
            writer.uint32(18).string(message.originalLpPrice);
        }
        if (message.currentLpPrice !== "") {
            writer.uint32(26).string(message.currentLpPrice);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseApr();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.value = reader.string();
                    break;
                case 2:
                    message.originalLpPrice = reader.string();
                    break;
                case 3:
                    message.currentLpPrice = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            value: isSet(object.value) ? String(object.value) : "",
            originalLpPrice: isSet(object.originalLpPrice) ? String(object.originalLpPrice) : "",
            currentLpPrice: isSet(object.currentLpPrice) ? String(object.currentLpPrice) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.value !== undefined && (obj.value = message.value);
        message.originalLpPrice !== undefined && (obj.originalLpPrice = message.originalLpPrice);
        message.currentLpPrice !== undefined && (obj.currentLpPrice = message.currentLpPrice);
        return obj;
    },
    create(base) {
        return Apr.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseApr();
        message.value = object.value ?? "";
        message.originalLpPrice = object.originalLpPrice ?? "";
        message.currentLpPrice = object.currentLpPrice ?? "";
        return message;
    },
};
function createBaseMaxDrawdown() {
    return { value: "", latestPnLPeak: "" };
}
export const MaxDrawdown = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.value !== "") {
            writer.uint32(10).string(message.value);
        }
        if (message.latestPnLPeak !== "") {
            writer.uint32(18).string(message.latestPnLPeak);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMaxDrawdown();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.value = reader.string();
                    break;
                case 2:
                    message.latestPnLPeak = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            value: isSet(object.value) ? String(object.value) : "",
            latestPnLPeak: isSet(object.latestPnLPeak) ? String(object.latestPnLPeak) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.value !== undefined && (obj.value = message.value);
        message.latestPnLPeak !== undefined && (obj.latestPnLPeak = message.latestPnLPeak);
        return obj;
    },
    create(base) {
        return MaxDrawdown.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseMaxDrawdown();
        message.value = object.value ?? "";
        message.latestPnLPeak = object.latestPnLPeak ?? "";
        return message;
    },
};
function createBaseGetUserRequest() {
    return { vaultAddress: "", userAddress: "" };
}
export const GetUserRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.vaultAddress !== "") {
            writer.uint32(10).string(message.vaultAddress);
        }
        if (message.userAddress !== "") {
            writer.uint32(18).string(message.userAddress);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetUserRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.vaultAddress = reader.string();
                    break;
                case 2:
                    message.userAddress = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            vaultAddress: isSet(object.vaultAddress) ? String(object.vaultAddress) : "",
            userAddress: isSet(object.userAddress) ? String(object.userAddress) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.vaultAddress !== undefined && (obj.vaultAddress = message.vaultAddress);
        message.userAddress !== undefined && (obj.userAddress = message.userAddress);
        return obj;
    },
    create(base) {
        return GetUserRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseGetUserRequest();
        message.vaultAddress = object.vaultAddress ?? "";
        message.userAddress = object.userAddress ?? "";
        return message;
    },
};
function createBaseGetUserResponse() {
    return { user: undefined };
}
export const GetUserResponse = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.user !== undefined) {
            User.encode(message.user, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetUserResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.user = User.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return { user: isSet(object.user) ? User.fromJSON(object.user) : undefined };
    },
    toJSON(message) {
        const obj = {};
        message.user !== undefined && (obj.user = message.user ? User.toJSON(message.user) : undefined);
        return obj;
    },
    create(base) {
        return GetUserResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseGetUserResponse();
        message.user = (object.user !== undefined && object.user !== null) ? User.fromPartial(object.user) : undefined;
        return message;
    },
};
function createBaseUser() {
    return { address: "", contractAddress: "", stats: undefined, updatedHeight: "0", updatedAt: "0" };
}
export const User = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.address !== "") {
            writer.uint32(10).string(message.address);
        }
        if (message.contractAddress !== "") {
            writer.uint32(18).string(message.contractAddress);
        }
        if (message.stats !== undefined) {
            UserStats.encode(message.stats, writer.uint32(26).fork()).ldelim();
        }
        if (message.updatedHeight !== "0") {
            writer.uint32(32).sint64(message.updatedHeight);
        }
        if (message.updatedAt !== "0") {
            writer.uint32(40).sint64(message.updatedAt);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUser();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.address = reader.string();
                    break;
                case 2:
                    message.contractAddress = reader.string();
                    break;
                case 3:
                    message.stats = UserStats.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.updatedHeight = longToString(reader.sint64());
                    break;
                case 5:
                    message.updatedAt = longToString(reader.sint64());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            address: isSet(object.address) ? String(object.address) : "",
            contractAddress: isSet(object.contractAddress) ? String(object.contractAddress) : "",
            stats: isSet(object.stats) ? UserStats.fromJSON(object.stats) : undefined,
            updatedHeight: isSet(object.updatedHeight) ? String(object.updatedHeight) : "0",
            updatedAt: isSet(object.updatedAt) ? String(object.updatedAt) : "0",
        };
    },
    toJSON(message) {
        const obj = {};
        message.address !== undefined && (obj.address = message.address);
        message.contractAddress !== undefined && (obj.contractAddress = message.contractAddress);
        message.stats !== undefined && (obj.stats = message.stats ? UserStats.toJSON(message.stats) : undefined);
        message.updatedHeight !== undefined && (obj.updatedHeight = message.updatedHeight);
        message.updatedAt !== undefined && (obj.updatedAt = message.updatedAt);
        return obj;
    },
    create(base) {
        return User.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseUser();
        message.address = object.address ?? "";
        message.contractAddress = object.contractAddress ?? "";
        message.stats = (object.stats !== undefined && object.stats !== null)
            ? UserStats.fromPartial(object.stats)
            : undefined;
        message.updatedHeight = object.updatedHeight ?? "0";
        message.updatedAt = object.updatedAt ?? "0";
        return message;
    },
};
function createBaseUserStats() {
    return { currentAmount: "", currentLpAmount: "", pnl: undefined, depositedValue: "" };
}
export const UserStats = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.currentAmount !== "") {
            writer.uint32(10).string(message.currentAmount);
        }
        if (message.currentLpAmount !== "") {
            writer.uint32(18).string(message.currentLpAmount);
        }
        if (message.pnl !== undefined) {
            PnlStats.encode(message.pnl, writer.uint32(26).fork()).ldelim();
        }
        if (message.depositedValue !== "") {
            writer.uint32(34).string(message.depositedValue);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUserStats();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.currentAmount = reader.string();
                    break;
                case 2:
                    message.currentLpAmount = reader.string();
                    break;
                case 3:
                    message.pnl = PnlStats.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.depositedValue = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            currentAmount: isSet(object.currentAmount) ? String(object.currentAmount) : "",
            currentLpAmount: isSet(object.currentLpAmount) ? String(object.currentLpAmount) : "",
            pnl: isSet(object.pnl) ? PnlStats.fromJSON(object.pnl) : undefined,
            depositedValue: isSet(object.depositedValue) ? String(object.depositedValue) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.currentAmount !== undefined && (obj.currentAmount = message.currentAmount);
        message.currentLpAmount !== undefined && (obj.currentLpAmount = message.currentLpAmount);
        message.pnl !== undefined && (obj.pnl = message.pnl ? PnlStats.toJSON(message.pnl) : undefined);
        message.depositedValue !== undefined && (obj.depositedValue = message.depositedValue);
        return obj;
    },
    create(base) {
        return UserStats.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseUserStats();
        message.currentAmount = object.currentAmount ?? "";
        message.currentLpAmount = object.currentLpAmount ?? "";
        message.pnl = (object.pnl !== undefined && object.pnl !== null) ? PnlStats.fromPartial(object.pnl) : undefined;
        message.depositedValue = object.depositedValue ?? "";
        return message;
    },
};
function createBaseListSubscriptionsRequest() {
    return { vaultAddress: "", userAddress: "", status: "", perPage: 0, token: "" };
}
export const ListSubscriptionsRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.vaultAddress !== "") {
            writer.uint32(10).string(message.vaultAddress);
        }
        if (message.userAddress !== "") {
            writer.uint32(18).string(message.userAddress);
        }
        if (message.status !== "") {
            writer.uint32(26).string(message.status);
        }
        if (message.perPage !== 0) {
            writer.uint32(32).sint32(message.perPage);
        }
        if (message.token !== "") {
            writer.uint32(42).string(message.token);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseListSubscriptionsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.vaultAddress = reader.string();
                    break;
                case 2:
                    message.userAddress = reader.string();
                    break;
                case 3:
                    message.status = reader.string();
                    break;
                case 4:
                    message.perPage = reader.sint32();
                    break;
                case 5:
                    message.token = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            vaultAddress: isSet(object.vaultAddress) ? String(object.vaultAddress) : "",
            userAddress: isSet(object.userAddress) ? String(object.userAddress) : "",
            status: isSet(object.status) ? String(object.status) : "",
            perPage: isSet(object.perPage) ? Number(object.perPage) : 0,
            token: isSet(object.token) ? String(object.token) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.vaultAddress !== undefined && (obj.vaultAddress = message.vaultAddress);
        message.userAddress !== undefined && (obj.userAddress = message.userAddress);
        message.status !== undefined && (obj.status = message.status);
        message.perPage !== undefined && (obj.perPage = Math.round(message.perPage));
        message.token !== undefined && (obj.token = message.token);
        return obj;
    },
    create(base) {
        return ListSubscriptionsRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseListSubscriptionsRequest();
        message.vaultAddress = object.vaultAddress ?? "";
        message.userAddress = object.userAddress ?? "";
        message.status = object.status ?? "";
        message.perPage = object.perPage ?? 0;
        message.token = object.token ?? "";
        return message;
    },
};
function createBaseListSubscriptionsResponse() {
    return { subscriptions: [], next: [] };
}
export const ListSubscriptionsResponse = {
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.subscriptions) {
            Subscription.encode(v, writer.uint32(10).fork()).ldelim();
        }
        for (const v of message.next) {
            writer.uint32(18).string(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseListSubscriptionsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.subscriptions.push(Subscription.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.next.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            subscriptions: Array.isArray(object?.subscriptions)
                ? object.subscriptions.map((e) => Subscription.fromJSON(e))
                : [],
            next: Array.isArray(object?.next) ? object.next.map((e) => String(e)) : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.subscriptions) {
            obj.subscriptions = message.subscriptions.map((e) => e ? Subscription.toJSON(e) : undefined);
        }
        else {
            obj.subscriptions = [];
        }
        if (message.next) {
            obj.next = message.next.map((e) => e);
        }
        else {
            obj.next = [];
        }
        return obj;
    },
    create(base) {
        return ListSubscriptionsResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseListSubscriptionsResponse();
        message.subscriptions = object.subscriptions?.map((e) => Subscription.fromPartial(e)) || [];
        message.next = object.next?.map((e) => e) || [];
        return message;
    },
};
function createBaseSubscription() {
    return {
        contractAddress: "",
        user: "",
        index: "0",
        lpAmount: "",
        amount: "",
        status: "",
        createdHeight: "0",
        createdAt: "0",
        executedHeight: "0",
        executedAt: "0",
    };
}
export const Subscription = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.contractAddress !== "") {
            writer.uint32(10).string(message.contractAddress);
        }
        if (message.user !== "") {
            writer.uint32(18).string(message.user);
        }
        if (message.index !== "0") {
            writer.uint32(24).sint64(message.index);
        }
        if (message.lpAmount !== "") {
            writer.uint32(34).string(message.lpAmount);
        }
        if (message.amount !== "") {
            writer.uint32(42).string(message.amount);
        }
        if (message.status !== "") {
            writer.uint32(50).string(message.status);
        }
        if (message.createdHeight !== "0") {
            writer.uint32(56).sint64(message.createdHeight);
        }
        if (message.createdAt !== "0") {
            writer.uint32(64).sint64(message.createdAt);
        }
        if (message.executedHeight !== "0") {
            writer.uint32(72).sint64(message.executedHeight);
        }
        if (message.executedAt !== "0") {
            writer.uint32(80).sint64(message.executedAt);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSubscription();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.contractAddress = reader.string();
                    break;
                case 2:
                    message.user = reader.string();
                    break;
                case 3:
                    message.index = longToString(reader.sint64());
                    break;
                case 4:
                    message.lpAmount = reader.string();
                    break;
                case 5:
                    message.amount = reader.string();
                    break;
                case 6:
                    message.status = reader.string();
                    break;
                case 7:
                    message.createdHeight = longToString(reader.sint64());
                    break;
                case 8:
                    message.createdAt = longToString(reader.sint64());
                    break;
                case 9:
                    message.executedHeight = longToString(reader.sint64());
                    break;
                case 10:
                    message.executedAt = longToString(reader.sint64());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            contractAddress: isSet(object.contractAddress) ? String(object.contractAddress) : "",
            user: isSet(object.user) ? String(object.user) : "",
            index: isSet(object.index) ? String(object.index) : "0",
            lpAmount: isSet(object.lpAmount) ? String(object.lpAmount) : "",
            amount: isSet(object.amount) ? String(object.amount) : "",
            status: isSet(object.status) ? String(object.status) : "",
            createdHeight: isSet(object.createdHeight) ? String(object.createdHeight) : "0",
            createdAt: isSet(object.createdAt) ? String(object.createdAt) : "0",
            executedHeight: isSet(object.executedHeight) ? String(object.executedHeight) : "0",
            executedAt: isSet(object.executedAt) ? String(object.executedAt) : "0",
        };
    },
    toJSON(message) {
        const obj = {};
        message.contractAddress !== undefined && (obj.contractAddress = message.contractAddress);
        message.user !== undefined && (obj.user = message.user);
        message.index !== undefined && (obj.index = message.index);
        message.lpAmount !== undefined && (obj.lpAmount = message.lpAmount);
        message.amount !== undefined && (obj.amount = message.amount);
        message.status !== undefined && (obj.status = message.status);
        message.createdHeight !== undefined && (obj.createdHeight = message.createdHeight);
        message.createdAt !== undefined && (obj.createdAt = message.createdAt);
        message.executedHeight !== undefined && (obj.executedHeight = message.executedHeight);
        message.executedAt !== undefined && (obj.executedAt = message.executedAt);
        return obj;
    },
    create(base) {
        return Subscription.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseSubscription();
        message.contractAddress = object.contractAddress ?? "";
        message.user = object.user ?? "";
        message.index = object.index ?? "0";
        message.lpAmount = object.lpAmount ?? "";
        message.amount = object.amount ?? "";
        message.status = object.status ?? "";
        message.createdHeight = object.createdHeight ?? "0";
        message.createdAt = object.createdAt ?? "0";
        message.executedHeight = object.executedHeight ?? "0";
        message.executedAt = object.executedAt ?? "0";
        return message;
    },
};
function createBaseListRedemptionsRequest() {
    return { vaultAddress: "", userAddress: "", status: "", perPage: 0, token: "" };
}
export const ListRedemptionsRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.vaultAddress !== "") {
            writer.uint32(10).string(message.vaultAddress);
        }
        if (message.userAddress !== "") {
            writer.uint32(18).string(message.userAddress);
        }
        if (message.status !== "") {
            writer.uint32(26).string(message.status);
        }
        if (message.perPage !== 0) {
            writer.uint32(32).sint32(message.perPage);
        }
        if (message.token !== "") {
            writer.uint32(42).string(message.token);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseListRedemptionsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.vaultAddress = reader.string();
                    break;
                case 2:
                    message.userAddress = reader.string();
                    break;
                case 3:
                    message.status = reader.string();
                    break;
                case 4:
                    message.perPage = reader.sint32();
                    break;
                case 5:
                    message.token = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            vaultAddress: isSet(object.vaultAddress) ? String(object.vaultAddress) : "",
            userAddress: isSet(object.userAddress) ? String(object.userAddress) : "",
            status: isSet(object.status) ? String(object.status) : "",
            perPage: isSet(object.perPage) ? Number(object.perPage) : 0,
            token: isSet(object.token) ? String(object.token) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.vaultAddress !== undefined && (obj.vaultAddress = message.vaultAddress);
        message.userAddress !== undefined && (obj.userAddress = message.userAddress);
        message.status !== undefined && (obj.status = message.status);
        message.perPage !== undefined && (obj.perPage = Math.round(message.perPage));
        message.token !== undefined && (obj.token = message.token);
        return obj;
    },
    create(base) {
        return ListRedemptionsRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseListRedemptionsRequest();
        message.vaultAddress = object.vaultAddress ?? "";
        message.userAddress = object.userAddress ?? "";
        message.status = object.status ?? "";
        message.perPage = object.perPage ?? 0;
        message.token = object.token ?? "";
        return message;
    },
};
function createBaseListRedemptionsResponse() {
    return { redemptions: [], next: [] };
}
export const ListRedemptionsResponse = {
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.redemptions) {
            Redemption.encode(v, writer.uint32(10).fork()).ldelim();
        }
        for (const v of message.next) {
            writer.uint32(18).string(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseListRedemptionsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.redemptions.push(Redemption.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.next.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            redemptions: Array.isArray(object?.redemptions) ? object.redemptions.map((e) => Redemption.fromJSON(e)) : [],
            next: Array.isArray(object?.next) ? object.next.map((e) => String(e)) : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.redemptions) {
            obj.redemptions = message.redemptions.map((e) => e ? Redemption.toJSON(e) : undefined);
        }
        else {
            obj.redemptions = [];
        }
        if (message.next) {
            obj.next = message.next.map((e) => e);
        }
        else {
            obj.next = [];
        }
        return obj;
    },
    create(base) {
        return ListRedemptionsResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseListRedemptionsResponse();
        message.redemptions = object.redemptions?.map((e) => Redemption.fromPartial(e)) || [];
        message.next = object.next?.map((e) => e) || [];
        return message;
    },
};
function createBaseRedemption() {
    return {
        contractAddress: "",
        user: "",
        index: "0",
        lpAmount: "",
        amount: "",
        status: "",
        dueAt: "0",
        createdHeight: "0",
        createdAt: "0",
        executedHeight: "0",
        executedAt: "0",
    };
}
export const Redemption = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.contractAddress !== "") {
            writer.uint32(10).string(message.contractAddress);
        }
        if (message.user !== "") {
            writer.uint32(18).string(message.user);
        }
        if (message.index !== "0") {
            writer.uint32(24).sint64(message.index);
        }
        if (message.lpAmount !== "") {
            writer.uint32(34).string(message.lpAmount);
        }
        if (message.amount !== "") {
            writer.uint32(42).string(message.amount);
        }
        if (message.status !== "") {
            writer.uint32(50).string(message.status);
        }
        if (message.dueAt !== "0") {
            writer.uint32(56).sint64(message.dueAt);
        }
        if (message.createdHeight !== "0") {
            writer.uint32(64).sint64(message.createdHeight);
        }
        if (message.createdAt !== "0") {
            writer.uint32(72).sint64(message.createdAt);
        }
        if (message.executedHeight !== "0") {
            writer.uint32(80).sint64(message.executedHeight);
        }
        if (message.executedAt !== "0") {
            writer.uint32(88).sint64(message.executedAt);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRedemption();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.contractAddress = reader.string();
                    break;
                case 2:
                    message.user = reader.string();
                    break;
                case 3:
                    message.index = longToString(reader.sint64());
                    break;
                case 4:
                    message.lpAmount = reader.string();
                    break;
                case 5:
                    message.amount = reader.string();
                    break;
                case 6:
                    message.status = reader.string();
                    break;
                case 7:
                    message.dueAt = longToString(reader.sint64());
                    break;
                case 8:
                    message.createdHeight = longToString(reader.sint64());
                    break;
                case 9:
                    message.createdAt = longToString(reader.sint64());
                    break;
                case 10:
                    message.executedHeight = longToString(reader.sint64());
                    break;
                case 11:
                    message.executedAt = longToString(reader.sint64());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            contractAddress: isSet(object.contractAddress) ? String(object.contractAddress) : "",
            user: isSet(object.user) ? String(object.user) : "",
            index: isSet(object.index) ? String(object.index) : "0",
            lpAmount: isSet(object.lpAmount) ? String(object.lpAmount) : "",
            amount: isSet(object.amount) ? String(object.amount) : "",
            status: isSet(object.status) ? String(object.status) : "",
            dueAt: isSet(object.dueAt) ? String(object.dueAt) : "0",
            createdHeight: isSet(object.createdHeight) ? String(object.createdHeight) : "0",
            createdAt: isSet(object.createdAt) ? String(object.createdAt) : "0",
            executedHeight: isSet(object.executedHeight) ? String(object.executedHeight) : "0",
            executedAt: isSet(object.executedAt) ? String(object.executedAt) : "0",
        };
    },
    toJSON(message) {
        const obj = {};
        message.contractAddress !== undefined && (obj.contractAddress = message.contractAddress);
        message.user !== undefined && (obj.user = message.user);
        message.index !== undefined && (obj.index = message.index);
        message.lpAmount !== undefined && (obj.lpAmount = message.lpAmount);
        message.amount !== undefined && (obj.amount = message.amount);
        message.status !== undefined && (obj.status = message.status);
        message.dueAt !== undefined && (obj.dueAt = message.dueAt);
        message.createdHeight !== undefined && (obj.createdHeight = message.createdHeight);
        message.createdAt !== undefined && (obj.createdAt = message.createdAt);
        message.executedHeight !== undefined && (obj.executedHeight = message.executedHeight);
        message.executedAt !== undefined && (obj.executedAt = message.executedAt);
        return obj;
    },
    create(base) {
        return Redemption.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseRedemption();
        message.contractAddress = object.contractAddress ?? "";
        message.user = object.user ?? "";
        message.index = object.index ?? "0";
        message.lpAmount = object.lpAmount ?? "";
        message.amount = object.amount ?? "";
        message.status = object.status ?? "";
        message.dueAt = object.dueAt ?? "0";
        message.createdHeight = object.createdHeight ?? "0";
        message.createdAt = object.createdAt ?? "0";
        message.executedHeight = object.executedHeight ?? "0";
        message.executedAt = object.executedAt ?? "0";
        return message;
    },
};
function createBaseGetOperatorRedemptionBucketsRequest() {
    return { vaultAddress: "", operatorAddress: "" };
}
export const GetOperatorRedemptionBucketsRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.vaultAddress !== "") {
            writer.uint32(10).string(message.vaultAddress);
        }
        if (message.operatorAddress !== "") {
            writer.uint32(18).string(message.operatorAddress);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetOperatorRedemptionBucketsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.vaultAddress = reader.string();
                    break;
                case 2:
                    message.operatorAddress = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            vaultAddress: isSet(object.vaultAddress) ? String(object.vaultAddress) : "",
            operatorAddress: isSet(object.operatorAddress) ? String(object.operatorAddress) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.vaultAddress !== undefined && (obj.vaultAddress = message.vaultAddress);
        message.operatorAddress !== undefined && (obj.operatorAddress = message.operatorAddress);
        return obj;
    },
    create(base) {
        return GetOperatorRedemptionBucketsRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseGetOperatorRedemptionBucketsRequest();
        message.vaultAddress = object.vaultAddress ?? "";
        message.operatorAddress = object.operatorAddress ?? "";
        return message;
    },
};
function createBaseGetOperatorRedemptionBucketsResponse() {
    return { buckets: [] };
}
export const GetOperatorRedemptionBucketsResponse = {
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.buckets) {
            RedemptionBucket.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetOperatorRedemptionBucketsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.buckets.push(RedemptionBucket.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            buckets: Array.isArray(object?.buckets) ? object.buckets.map((e) => RedemptionBucket.fromJSON(e)) : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.buckets) {
            obj.buckets = message.buckets.map((e) => e ? RedemptionBucket.toJSON(e) : undefined);
        }
        else {
            obj.buckets = [];
        }
        return obj;
    },
    create(base) {
        return GetOperatorRedemptionBucketsResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseGetOperatorRedemptionBucketsResponse();
        message.buckets = object.buckets?.map((e) => RedemptionBucket.fromPartial(e)) || [];
        return message;
    },
};
function createBaseRedemptionBucket() {
    return { bucket: "", lpAmountToRedeem: "", neededAmount: "", missingLiquidity: "" };
}
export const RedemptionBucket = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.bucket !== "") {
            writer.uint32(10).string(message.bucket);
        }
        if (message.lpAmountToRedeem !== "") {
            writer.uint32(18).string(message.lpAmountToRedeem);
        }
        if (message.neededAmount !== "") {
            writer.uint32(26).string(message.neededAmount);
        }
        if (message.missingLiquidity !== "") {
            writer.uint32(34).string(message.missingLiquidity);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRedemptionBucket();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.bucket = reader.string();
                    break;
                case 2:
                    message.lpAmountToRedeem = reader.string();
                    break;
                case 3:
                    message.neededAmount = reader.string();
                    break;
                case 4:
                    message.missingLiquidity = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            bucket: isSet(object.bucket) ? String(object.bucket) : "",
            lpAmountToRedeem: isSet(object.lpAmountToRedeem) ? String(object.lpAmountToRedeem) : "",
            neededAmount: isSet(object.neededAmount) ? String(object.neededAmount) : "",
            missingLiquidity: isSet(object.missingLiquidity) ? String(object.missingLiquidity) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.bucket !== undefined && (obj.bucket = message.bucket);
        message.lpAmountToRedeem !== undefined && (obj.lpAmountToRedeem = message.lpAmountToRedeem);
        message.neededAmount !== undefined && (obj.neededAmount = message.neededAmount);
        message.missingLiquidity !== undefined && (obj.missingLiquidity = message.missingLiquidity);
        return obj;
    },
    create(base) {
        return RedemptionBucket.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseRedemptionBucket();
        message.bucket = object.bucket ?? "";
        message.lpAmountToRedeem = object.lpAmountToRedeem ?? "";
        message.neededAmount = object.neededAmount ?? "";
        message.missingLiquidity = object.missingLiquidity ?? "";
        return message;
    },
};
function createBaseTvlHistoryRequest() {
    return { vaultAddress: "", since: "0", maxDataPoints: 0 };
}
export const TvlHistoryRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.vaultAddress !== "") {
            writer.uint32(10).string(message.vaultAddress);
        }
        if (message.since !== "0") {
            writer.uint32(16).sint64(message.since);
        }
        if (message.maxDataPoints !== 0) {
            writer.uint32(24).sint32(message.maxDataPoints);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTvlHistoryRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.vaultAddress = reader.string();
                    break;
                case 2:
                    message.since = longToString(reader.sint64());
                    break;
                case 3:
                    message.maxDataPoints = reader.sint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            vaultAddress: isSet(object.vaultAddress) ? String(object.vaultAddress) : "",
            since: isSet(object.since) ? String(object.since) : "0",
            maxDataPoints: isSet(object.maxDataPoints) ? Number(object.maxDataPoints) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        message.vaultAddress !== undefined && (obj.vaultAddress = message.vaultAddress);
        message.since !== undefined && (obj.since = message.since);
        message.maxDataPoints !== undefined && (obj.maxDataPoints = Math.round(message.maxDataPoints));
        return obj;
    },
    create(base) {
        return TvlHistoryRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseTvlHistoryRequest();
        message.vaultAddress = object.vaultAddress ?? "";
        message.since = object.since ?? "0";
        message.maxDataPoints = object.maxDataPoints ?? 0;
        return message;
    },
};
function createBaseTvlHistoryResponse() {
    return { history: [] };
}
export const TvlHistoryResponse = {
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.history) {
            HistoricalTVL.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTvlHistoryResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.history.push(HistoricalTVL.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return { history: Array.isArray(object?.history) ? object.history.map((e) => HistoricalTVL.fromJSON(e)) : [] };
    },
    toJSON(message) {
        const obj = {};
        if (message.history) {
            obj.history = message.history.map((e) => e ? HistoricalTVL.toJSON(e) : undefined);
        }
        else {
            obj.history = [];
        }
        return obj;
    },
    create(base) {
        return TvlHistoryResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseTvlHistoryResponse();
        message.history = object.history?.map((e) => HistoricalTVL.fromPartial(e)) || [];
        return message;
    },
};
function createBaseHistoricalTVL() {
    return { t: 0, v: "" };
}
export const HistoricalTVL = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.t !== 0) {
            writer.uint32(8).sint32(message.t);
        }
        if (message.v !== "") {
            writer.uint32(18).string(message.v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseHistoricalTVL();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.t = reader.sint32();
                    break;
                case 2:
                    message.v = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return { t: isSet(object.t) ? Number(object.t) : 0, v: isSet(object.v) ? String(object.v) : "" };
    },
    toJSON(message) {
        const obj = {};
        message.t !== undefined && (obj.t = Math.round(message.t));
        message.v !== undefined && (obj.v = message.v);
        return obj;
    },
    create(base) {
        return HistoricalTVL.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseHistoricalTVL();
        message.t = object.t ?? 0;
        message.v = object.v ?? "";
        return message;
    },
};
function createBasePnlHistoryRequest() {
    return { vaultAddress: "", since: "0", maxDataPoints: 0 };
}
export const PnlHistoryRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.vaultAddress !== "") {
            writer.uint32(10).string(message.vaultAddress);
        }
        if (message.since !== "0") {
            writer.uint32(16).sint64(message.since);
        }
        if (message.maxDataPoints !== 0) {
            writer.uint32(24).sint32(message.maxDataPoints);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePnlHistoryRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.vaultAddress = reader.string();
                    break;
                case 2:
                    message.since = longToString(reader.sint64());
                    break;
                case 3:
                    message.maxDataPoints = reader.sint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            vaultAddress: isSet(object.vaultAddress) ? String(object.vaultAddress) : "",
            since: isSet(object.since) ? String(object.since) : "0",
            maxDataPoints: isSet(object.maxDataPoints) ? Number(object.maxDataPoints) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        message.vaultAddress !== undefined && (obj.vaultAddress = message.vaultAddress);
        message.since !== undefined && (obj.since = message.since);
        message.maxDataPoints !== undefined && (obj.maxDataPoints = Math.round(message.maxDataPoints));
        return obj;
    },
    create(base) {
        return PnlHistoryRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBasePnlHistoryRequest();
        message.vaultAddress = object.vaultAddress ?? "";
        message.since = object.since ?? "0";
        message.maxDataPoints = object.maxDataPoints ?? 0;
        return message;
    },
};
function createBasePnlHistoryResponse() {
    return { history: [] };
}
export const PnlHistoryResponse = {
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.history) {
            HistoricalPnL.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePnlHistoryResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.history.push(HistoricalPnL.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return { history: Array.isArray(object?.history) ? object.history.map((e) => HistoricalPnL.fromJSON(e)) : [] };
    },
    toJSON(message) {
        const obj = {};
        if (message.history) {
            obj.history = message.history.map((e) => e ? HistoricalPnL.toJSON(e) : undefined);
        }
        else {
            obj.history = [];
        }
        return obj;
    },
    create(base) {
        return PnlHistoryResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBasePnlHistoryResponse();
        message.history = object.history?.map((e) => HistoricalPnL.fromPartial(e)) || [];
        return message;
    },
};
function createBaseHistoricalPnL() {
    return { t: 0, v: "" };
}
export const HistoricalPnL = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.t !== 0) {
            writer.uint32(8).sint32(message.t);
        }
        if (message.v !== "") {
            writer.uint32(18).string(message.v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseHistoricalPnL();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.t = reader.sint32();
                    break;
                case 2:
                    message.v = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return { t: isSet(object.t) ? Number(object.t) : 0, v: isSet(object.v) ? String(object.v) : "" };
    },
    toJSON(message) {
        const obj = {};
        message.t !== undefined && (obj.t = Math.round(message.t));
        message.v !== undefined && (obj.v = message.v);
        return obj;
    },
    create(base) {
        return HistoricalPnL.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseHistoricalPnL();
        message.t = object.t ?? 0;
        message.v = object.v ?? "";
        return message;
    },
};
export class InjectiveMegavaultRPCClientImpl {
    rpc;
    constructor(rpc) {
        this.rpc = rpc;
        this.GetVault = this.GetVault.bind(this);
        this.GetUser = this.GetUser.bind(this);
        this.ListSubscriptions = this.ListSubscriptions.bind(this);
        this.ListRedemptions = this.ListRedemptions.bind(this);
        this.GetOperatorRedemptionBuckets = this.GetOperatorRedemptionBuckets.bind(this);
        this.TvlHistory = this.TvlHistory.bind(this);
        this.PnlHistory = this.PnlHistory.bind(this);
    }
    GetVault(request, metadata) {
        return this.rpc.unary(InjectiveMegavaultRPCGetVaultDesc, GetVaultRequest.fromPartial(request), metadata);
    }
    GetUser(request, metadata) {
        return this.rpc.unary(InjectiveMegavaultRPCGetUserDesc, GetUserRequest.fromPartial(request), metadata);
    }
    ListSubscriptions(request, metadata) {
        return this.rpc.unary(InjectiveMegavaultRPCListSubscriptionsDesc, ListSubscriptionsRequest.fromPartial(request), metadata);
    }
    ListRedemptions(request, metadata) {
        return this.rpc.unary(InjectiveMegavaultRPCListRedemptionsDesc, ListRedemptionsRequest.fromPartial(request), metadata);
    }
    GetOperatorRedemptionBuckets(request, metadata) {
        return this.rpc.unary(InjectiveMegavaultRPCGetOperatorRedemptionBucketsDesc, GetOperatorRedemptionBucketsRequest.fromPartial(request), metadata);
    }
    TvlHistory(request, metadata) {
        return this.rpc.unary(InjectiveMegavaultRPCTvlHistoryDesc, TvlHistoryRequest.fromPartial(request), metadata);
    }
    PnlHistory(request, metadata) {
        return this.rpc.unary(InjectiveMegavaultRPCPnlHistoryDesc, PnlHistoryRequest.fromPartial(request), metadata);
    }
}
export const InjectiveMegavaultRPCDesc = { serviceName: "injective_megavault_rpc.InjectiveMegavaultRPC" };
export const InjectiveMegavaultRPCGetVaultDesc = {
    methodName: "GetVault",
    service: InjectiveMegavaultRPCDesc,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return GetVaultRequest.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = GetVaultResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
export const InjectiveMegavaultRPCGetUserDesc = {
    methodName: "GetUser",
    service: InjectiveMegavaultRPCDesc,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return GetUserRequest.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = GetUserResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
export const InjectiveMegavaultRPCListSubscriptionsDesc = {
    methodName: "ListSubscriptions",
    service: InjectiveMegavaultRPCDesc,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return ListSubscriptionsRequest.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = ListSubscriptionsResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
export const InjectiveMegavaultRPCListRedemptionsDesc = {
    methodName: "ListRedemptions",
    service: InjectiveMegavaultRPCDesc,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return ListRedemptionsRequest.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = ListRedemptionsResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
export const InjectiveMegavaultRPCGetOperatorRedemptionBucketsDesc = {
    methodName: "GetOperatorRedemptionBuckets",
    service: InjectiveMegavaultRPCDesc,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return GetOperatorRedemptionBucketsRequest.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = GetOperatorRedemptionBucketsResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
export const InjectiveMegavaultRPCTvlHistoryDesc = {
    methodName: "TvlHistory",
    service: InjectiveMegavaultRPCDesc,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return TvlHistoryRequest.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = TvlHistoryResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
export const InjectiveMegavaultRPCPnlHistoryDesc = {
    methodName: "PnlHistory",
    service: InjectiveMegavaultRPCDesc,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return PnlHistoryRequest.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = PnlHistoryResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
export class GrpcWebImpl {
    host;
    options;
    constructor(host, options) {
        this.host = host;
        this.options = options;
    }
    unary(methodDesc, _request, metadata) {
        const request = { ..._request, ...methodDesc.requestType };
        const maybeCombinedMetadata = metadata && this.options.metadata
            ? new BrowserHeaders({ ...this.options?.metadata.headersMap, ...metadata?.headersMap })
            : metadata || this.options.metadata;
        return new Promise((resolve, reject) => {
            grpc.unary(methodDesc, {
                request,
                host: this.host,
                metadata: maybeCombinedMetadata,
                transport: this.options.transport,
                debug: this.options.debug,
                onEnd: function (response) {
                    if (response.status === grpc.Code.OK) {
                        resolve(response.message.toObject());
                    }
                    else {
                        const err = new GrpcWebError(response.statusMessage, response.status, response.trailers);
                        reject(err);
                    }
                },
            });
        });
    }
}
var tsProtoGlobalThis = (() => {
    if (typeof globalThis !== "undefined") {
        return globalThis;
    }
    if (typeof self !== "undefined") {
        return self;
    }
    if (typeof window !== "undefined") {
        return window;
    }
    if (typeof global !== "undefined") {
        return global;
    }
    throw "Unable to locate global object";
})();
function longToString(long) {
    return long.toString();
}
if (_m0.util.Long !== Long) {
    _m0.util.Long = Long;
    _m0.configure();
}
function isSet(value) {
    return value !== null && value !== undefined;
}
export class GrpcWebError extends tsProtoGlobalThis.Error {
    code;
    metadata;
    constructor(message, code, metadata) {
        super(message);
        this.code = code;
        this.metadata = metadata;
    }
}
