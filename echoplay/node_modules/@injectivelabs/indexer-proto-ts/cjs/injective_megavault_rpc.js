"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GrpcWebError = exports.GrpcWebImpl = exports.InjectiveMegavaultRPCPnlHistoryDesc = exports.InjectiveMegavaultRPCTvlHistoryDesc = exports.InjectiveMegavaultRPCGetOperatorRedemptionBucketsDesc = exports.InjectiveMegavaultRPCListRedemptionsDesc = exports.InjectiveMegavaultRPCListSubscriptionsDesc = exports.InjectiveMegavaultRPCGetUserDesc = exports.InjectiveMegavaultRPCGetVaultDesc = exports.InjectiveMegavaultRPCDesc = exports.InjectiveMegavaultRPCClientImpl = exports.HistoricalPnL = exports.PnlHistoryResponse = exports.PnlHistoryRequest = exports.HistoricalTVL = exports.TvlHistoryResponse = exports.TvlHistoryRequest = exports.RedemptionBucket = exports.GetOperatorRedemptionBucketsResponse = exports.GetOperatorRedemptionBucketsRequest = exports.Redemption = exports.ListRedemptionsResponse = exports.ListRedemptionsRequest = exports.Subscription = exports.ListSubscriptionsResponse = exports.ListSubscriptionsRequest = exports.UserStats = exports.User = exports.GetUserResponse = exports.GetUserRequest = exports.MaxDrawdown = exports.Apr = exports.AprStats = exports.Volatility = exports.VolatilityStats = exports.Pnl = exports.UnrealizedPnl = exports.PnlStats = exports.VaultStats = exports.TargetApr = exports.Incentives = exports.Operator = exports.Vault = exports.GetVaultResponse = exports.GetVaultRequest = exports.protobufPackage = void 0;
/* eslint-disable */
const grpc_web_1 = require("@injectivelabs/grpc-web");
const browser_headers_1 = require("browser-headers");
const long_1 = __importDefault(require("long"));
const minimal_js_1 = __importDefault(require("protobufjs/minimal.js"));
exports.protobufPackage = "injective_megavault_rpc";
function createBaseGetVaultRequest() {
    return { vaultAddress: "" };
}
exports.GetVaultRequest = {
    encode(message, writer = minimal_js_1.default.Writer.create()) {
        if (message.vaultAddress !== "") {
            writer.uint32(10).string(message.vaultAddress);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_js_1.default.Reader ? input : new minimal_js_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetVaultRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.vaultAddress = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return { vaultAddress: isSet(object.vaultAddress) ? String(object.vaultAddress) : "" };
    },
    toJSON(message) {
        const obj = {};
        message.vaultAddress !== undefined && (obj.vaultAddress = message.vaultAddress);
        return obj;
    },
    create(base) {
        return exports.GetVaultRequest.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a;
        const message = createBaseGetVaultRequest();
        message.vaultAddress = (_a = object.vaultAddress) !== null && _a !== void 0 ? _a : "";
        return message;
    },
};
function createBaseGetVaultResponse() {
    return { vault: undefined };
}
exports.GetVaultResponse = {
    encode(message, writer = minimal_js_1.default.Writer.create()) {
        if (message.vault !== undefined) {
            exports.Vault.encode(message.vault, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_js_1.default.Reader ? input : new minimal_js_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetVaultResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.vault = exports.Vault.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return { vault: isSet(object.vault) ? exports.Vault.fromJSON(object.vault) : undefined };
    },
    toJSON(message) {
        const obj = {};
        message.vault !== undefined && (obj.vault = message.vault ? exports.Vault.toJSON(message.vault) : undefined);
        return obj;
    },
    create(base) {
        return exports.GetVaultResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        const message = createBaseGetVaultResponse();
        message.vault = (object.vault !== undefined && object.vault !== null) ? exports.Vault.fromPartial(object.vault) : undefined;
        return message;
    },
};
function createBaseVault() {
    return {
        contractAddress: "",
        contractName: "",
        contractVersion: "",
        admin: "",
        lpDenom: "",
        quoteDenom: "",
        operators: [],
        incentives: undefined,
        targetApr: undefined,
        stats: undefined,
        createdHeight: "0",
        createdAt: "0",
        updatedHeight: "0",
        updatedAt: "0",
    };
}
exports.Vault = {
    encode(message, writer = minimal_js_1.default.Writer.create()) {
        if (message.contractAddress !== "") {
            writer.uint32(10).string(message.contractAddress);
        }
        if (message.contractName !== "") {
            writer.uint32(18).string(message.contractName);
        }
        if (message.contractVersion !== "") {
            writer.uint32(26).string(message.contractVersion);
        }
        if (message.admin !== "") {
            writer.uint32(34).string(message.admin);
        }
        if (message.lpDenom !== "") {
            writer.uint32(42).string(message.lpDenom);
        }
        if (message.quoteDenom !== "") {
            writer.uint32(50).string(message.quoteDenom);
        }
        for (const v of message.operators) {
            exports.Operator.encode(v, writer.uint32(58).fork()).ldelim();
        }
        if (message.incentives !== undefined) {
            exports.Incentives.encode(message.incentives, writer.uint32(66).fork()).ldelim();
        }
        if (message.targetApr !== undefined) {
            exports.TargetApr.encode(message.targetApr, writer.uint32(74).fork()).ldelim();
        }
        if (message.stats !== undefined) {
            exports.VaultStats.encode(message.stats, writer.uint32(82).fork()).ldelim();
        }
        if (message.createdHeight !== "0") {
            writer.uint32(88).sint64(message.createdHeight);
        }
        if (message.createdAt !== "0") {
            writer.uint32(96).sint64(message.createdAt);
        }
        if (message.updatedHeight !== "0") {
            writer.uint32(104).sint64(message.updatedHeight);
        }
        if (message.updatedAt !== "0") {
            writer.uint32(112).sint64(message.updatedAt);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_js_1.default.Reader ? input : new minimal_js_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseVault();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.contractAddress = reader.string();
                    break;
                case 2:
                    message.contractName = reader.string();
                    break;
                case 3:
                    message.contractVersion = reader.string();
                    break;
                case 4:
                    message.admin = reader.string();
                    break;
                case 5:
                    message.lpDenom = reader.string();
                    break;
                case 6:
                    message.quoteDenom = reader.string();
                    break;
                case 7:
                    message.operators.push(exports.Operator.decode(reader, reader.uint32()));
                    break;
                case 8:
                    message.incentives = exports.Incentives.decode(reader, reader.uint32());
                    break;
                case 9:
                    message.targetApr = exports.TargetApr.decode(reader, reader.uint32());
                    break;
                case 10:
                    message.stats = exports.VaultStats.decode(reader, reader.uint32());
                    break;
                case 11:
                    message.createdHeight = longToString(reader.sint64());
                    break;
                case 12:
                    message.createdAt = longToString(reader.sint64());
                    break;
                case 13:
                    message.updatedHeight = longToString(reader.sint64());
                    break;
                case 14:
                    message.updatedAt = longToString(reader.sint64());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            contractAddress: isSet(object.contractAddress) ? String(object.contractAddress) : "",
            contractName: isSet(object.contractName) ? String(object.contractName) : "",
            contractVersion: isSet(object.contractVersion) ? String(object.contractVersion) : "",
            admin: isSet(object.admin) ? String(object.admin) : "",
            lpDenom: isSet(object.lpDenom) ? String(object.lpDenom) : "",
            quoteDenom: isSet(object.quoteDenom) ? String(object.quoteDenom) : "",
            operators: Array.isArray(object === null || object === void 0 ? void 0 : object.operators) ? object.operators.map((e) => exports.Operator.fromJSON(e)) : [],
            incentives: isSet(object.incentives) ? exports.Incentives.fromJSON(object.incentives) : undefined,
            targetApr: isSet(object.targetApr) ? exports.TargetApr.fromJSON(object.targetApr) : undefined,
            stats: isSet(object.stats) ? exports.VaultStats.fromJSON(object.stats) : undefined,
            createdHeight: isSet(object.createdHeight) ? String(object.createdHeight) : "0",
            createdAt: isSet(object.createdAt) ? String(object.createdAt) : "0",
            updatedHeight: isSet(object.updatedHeight) ? String(object.updatedHeight) : "0",
            updatedAt: isSet(object.updatedAt) ? String(object.updatedAt) : "0",
        };
    },
    toJSON(message) {
        const obj = {};
        message.contractAddress !== undefined && (obj.contractAddress = message.contractAddress);
        message.contractName !== undefined && (obj.contractName = message.contractName);
        message.contractVersion !== undefined && (obj.contractVersion = message.contractVersion);
        message.admin !== undefined && (obj.admin = message.admin);
        message.lpDenom !== undefined && (obj.lpDenom = message.lpDenom);
        message.quoteDenom !== undefined && (obj.quoteDenom = message.quoteDenom);
        if (message.operators) {
            obj.operators = message.operators.map((e) => e ? exports.Operator.toJSON(e) : undefined);
        }
        else {
            obj.operators = [];
        }
        message.incentives !== undefined &&
            (obj.incentives = message.incentives ? exports.Incentives.toJSON(message.incentives) : undefined);
        message.targetApr !== undefined &&
            (obj.targetApr = message.targetApr ? exports.TargetApr.toJSON(message.targetApr) : undefined);
        message.stats !== undefined && (obj.stats = message.stats ? exports.VaultStats.toJSON(message.stats) : undefined);
        message.createdHeight !== undefined && (obj.createdHeight = message.createdHeight);
        message.createdAt !== undefined && (obj.createdAt = message.createdAt);
        message.updatedHeight !== undefined && (obj.updatedHeight = message.updatedHeight);
        message.updatedAt !== undefined && (obj.updatedAt = message.updatedAt);
        return obj;
    },
    create(base) {
        return exports.Vault.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
        const message = createBaseVault();
        message.contractAddress = (_a = object.contractAddress) !== null && _a !== void 0 ? _a : "";
        message.contractName = (_b = object.contractName) !== null && _b !== void 0 ? _b : "";
        message.contractVersion = (_c = object.contractVersion) !== null && _c !== void 0 ? _c : "";
        message.admin = (_d = object.admin) !== null && _d !== void 0 ? _d : "";
        message.lpDenom = (_e = object.lpDenom) !== null && _e !== void 0 ? _e : "";
        message.quoteDenom = (_f = object.quoteDenom) !== null && _f !== void 0 ? _f : "";
        message.operators = ((_g = object.operators) === null || _g === void 0 ? void 0 : _g.map((e) => exports.Operator.fromPartial(e))) || [];
        message.incentives = (object.incentives !== undefined && object.incentives !== null)
            ? exports.Incentives.fromPartial(object.incentives)
            : undefined;
        message.targetApr = (object.targetApr !== undefined && object.targetApr !== null)
            ? exports.TargetApr.fromPartial(object.targetApr)
            : undefined;
        message.stats = (object.stats !== undefined && object.stats !== null)
            ? exports.VaultStats.fromPartial(object.stats)
            : undefined;
        message.createdHeight = (_h = object.createdHeight) !== null && _h !== void 0 ? _h : "0";
        message.createdAt = (_j = object.createdAt) !== null && _j !== void 0 ? _j : "0";
        message.updatedHeight = (_k = object.updatedHeight) !== null && _k !== void 0 ? _k : "0";
        message.updatedAt = (_l = object.updatedAt) !== null && _l !== void 0 ? _l : "0";
        return message;
    },
};
function createBaseOperator() {
    return { address: "", totalAmount: "", totalLiquidAmount: "", updatedHeight: "0", updatedAt: "0" };
}
exports.Operator = {
    encode(message, writer = minimal_js_1.default.Writer.create()) {
        if (message.address !== "") {
            writer.uint32(10).string(message.address);
        }
        if (message.totalAmount !== "") {
            writer.uint32(18).string(message.totalAmount);
        }
        if (message.totalLiquidAmount !== "") {
            writer.uint32(26).string(message.totalLiquidAmount);
        }
        if (message.updatedHeight !== "0") {
            writer.uint32(32).sint64(message.updatedHeight);
        }
        if (message.updatedAt !== "0") {
            writer.uint32(40).sint64(message.updatedAt);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_js_1.default.Reader ? input : new minimal_js_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseOperator();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.address = reader.string();
                    break;
                case 2:
                    message.totalAmount = reader.string();
                    break;
                case 3:
                    message.totalLiquidAmount = reader.string();
                    break;
                case 4:
                    message.updatedHeight = longToString(reader.sint64());
                    break;
                case 5:
                    message.updatedAt = longToString(reader.sint64());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            address: isSet(object.address) ? String(object.address) : "",
            totalAmount: isSet(object.totalAmount) ? String(object.totalAmount) : "",
            totalLiquidAmount: isSet(object.totalLiquidAmount) ? String(object.totalLiquidAmount) : "",
            updatedHeight: isSet(object.updatedHeight) ? String(object.updatedHeight) : "0",
            updatedAt: isSet(object.updatedAt) ? String(object.updatedAt) : "0",
        };
    },
    toJSON(message) {
        const obj = {};
        message.address !== undefined && (obj.address = message.address);
        message.totalAmount !== undefined && (obj.totalAmount = message.totalAmount);
        message.totalLiquidAmount !== undefined && (obj.totalLiquidAmount = message.totalLiquidAmount);
        message.updatedHeight !== undefined && (obj.updatedHeight = message.updatedHeight);
        message.updatedAt !== undefined && (obj.updatedAt = message.updatedAt);
        return obj;
    },
    create(base) {
        return exports.Operator.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e;
        const message = createBaseOperator();
        message.address = (_a = object.address) !== null && _a !== void 0 ? _a : "";
        message.totalAmount = (_b = object.totalAmount) !== null && _b !== void 0 ? _b : "";
        message.totalLiquidAmount = (_c = object.totalLiquidAmount) !== null && _c !== void 0 ? _c : "";
        message.updatedHeight = (_d = object.updatedHeight) !== null && _d !== void 0 ? _d : "0";
        message.updatedAt = (_e = object.updatedAt) !== null && _e !== void 0 ? _e : "0";
        return message;
    },
};
function createBaseIncentives() {
    return { address: "", amount: "", updatedHeight: "0", updatedAt: "0" };
}
exports.Incentives = {
    encode(message, writer = minimal_js_1.default.Writer.create()) {
        if (message.address !== "") {
            writer.uint32(10).string(message.address);
        }
        if (message.amount !== "") {
            writer.uint32(18).string(message.amount);
        }
        if (message.updatedHeight !== "0") {
            writer.uint32(24).sint64(message.updatedHeight);
        }
        if (message.updatedAt !== "0") {
            writer.uint32(32).sint64(message.updatedAt);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_js_1.default.Reader ? input : new minimal_js_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseIncentives();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.address = reader.string();
                    break;
                case 2:
                    message.amount = reader.string();
                    break;
                case 3:
                    message.updatedHeight = longToString(reader.sint64());
                    break;
                case 4:
                    message.updatedAt = longToString(reader.sint64());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            address: isSet(object.address) ? String(object.address) : "",
            amount: isSet(object.amount) ? String(object.amount) : "",
            updatedHeight: isSet(object.updatedHeight) ? String(object.updatedHeight) : "0",
            updatedAt: isSet(object.updatedAt) ? String(object.updatedAt) : "0",
        };
    },
    toJSON(message) {
        const obj = {};
        message.address !== undefined && (obj.address = message.address);
        message.amount !== undefined && (obj.amount = message.amount);
        message.updatedHeight !== undefined && (obj.updatedHeight = message.updatedHeight);
        message.updatedAt !== undefined && (obj.updatedAt = message.updatedAt);
        return obj;
    },
    create(base) {
        return exports.Incentives.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c, _d;
        const message = createBaseIncentives();
        message.address = (_a = object.address) !== null && _a !== void 0 ? _a : "";
        message.amount = (_b = object.amount) !== null && _b !== void 0 ? _b : "";
        message.updatedHeight = (_c = object.updatedHeight) !== null && _c !== void 0 ? _c : "0";
        message.updatedAt = (_d = object.updatedAt) !== null && _d !== void 0 ? _d : "0";
        return message;
    },
};
function createBaseTargetApr() {
    return { apr: "", upperThreshold: "", lowerThreshold: "", updatedHeight: "0", updatedAt: "0" };
}
exports.TargetApr = {
    encode(message, writer = minimal_js_1.default.Writer.create()) {
        if (message.apr !== "") {
            writer.uint32(10).string(message.apr);
        }
        if (message.upperThreshold !== "") {
            writer.uint32(18).string(message.upperThreshold);
        }
        if (message.lowerThreshold !== "") {
            writer.uint32(26).string(message.lowerThreshold);
        }
        if (message.updatedHeight !== "0") {
            writer.uint32(32).sint64(message.updatedHeight);
        }
        if (message.updatedAt !== "0") {
            writer.uint32(40).sint64(message.updatedAt);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_js_1.default.Reader ? input : new minimal_js_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTargetApr();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.apr = reader.string();
                    break;
                case 2:
                    message.upperThreshold = reader.string();
                    break;
                case 3:
                    message.lowerThreshold = reader.string();
                    break;
                case 4:
                    message.updatedHeight = longToString(reader.sint64());
                    break;
                case 5:
                    message.updatedAt = longToString(reader.sint64());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            apr: isSet(object.apr) ? String(object.apr) : "",
            upperThreshold: isSet(object.upperThreshold) ? String(object.upperThreshold) : "",
            lowerThreshold: isSet(object.lowerThreshold) ? String(object.lowerThreshold) : "",
            updatedHeight: isSet(object.updatedHeight) ? String(object.updatedHeight) : "0",
            updatedAt: isSet(object.updatedAt) ? String(object.updatedAt) : "0",
        };
    },
    toJSON(message) {
        const obj = {};
        message.apr !== undefined && (obj.apr = message.apr);
        message.upperThreshold !== undefined && (obj.upperThreshold = message.upperThreshold);
        message.lowerThreshold !== undefined && (obj.lowerThreshold = message.lowerThreshold);
        message.updatedHeight !== undefined && (obj.updatedHeight = message.updatedHeight);
        message.updatedAt !== undefined && (obj.updatedAt = message.updatedAt);
        return obj;
    },
    create(base) {
        return exports.TargetApr.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e;
        const message = createBaseTargetApr();
        message.apr = (_a = object.apr) !== null && _a !== void 0 ? _a : "";
        message.upperThreshold = (_b = object.upperThreshold) !== null && _b !== void 0 ? _b : "";
        message.lowerThreshold = (_c = object.lowerThreshold) !== null && _c !== void 0 ? _c : "";
        message.updatedHeight = (_d = object.updatedHeight) !== null && _d !== void 0 ? _d : "0";
        message.updatedAt = (_e = object.updatedAt) !== null && _e !== void 0 ? _e : "0";
        return message;
    },
};
function createBaseVaultStats() {
    return {
        totalSubscribedAmount: "",
        totalRedeemedAmount: "",
        currentAmount: "",
        currentAmountWithoutIncentives: "",
        currentLpAmount: "",
        currentLpPrice: "",
        pnl: undefined,
        volatility: undefined,
        apr: undefined,
        maxDrawdown: undefined,
    };
}
exports.VaultStats = {
    encode(message, writer = minimal_js_1.default.Writer.create()) {
        if (message.totalSubscribedAmount !== "") {
            writer.uint32(10).string(message.totalSubscribedAmount);
        }
        if (message.totalRedeemedAmount !== "") {
            writer.uint32(18).string(message.totalRedeemedAmount);
        }
        if (message.currentAmount !== "") {
            writer.uint32(26).string(message.currentAmount);
        }
        if (message.currentAmountWithoutIncentives !== "") {
            writer.uint32(34).string(message.currentAmountWithoutIncentives);
        }
        if (message.currentLpAmount !== "") {
            writer.uint32(42).string(message.currentLpAmount);
        }
        if (message.currentLpPrice !== "") {
            writer.uint32(50).string(message.currentLpPrice);
        }
        if (message.pnl !== undefined) {
            exports.PnlStats.encode(message.pnl, writer.uint32(58).fork()).ldelim();
        }
        if (message.volatility !== undefined) {
            exports.VolatilityStats.encode(message.volatility, writer.uint32(66).fork()).ldelim();
        }
        if (message.apr !== undefined) {
            exports.AprStats.encode(message.apr, writer.uint32(74).fork()).ldelim();
        }
        if (message.maxDrawdown !== undefined) {
            exports.MaxDrawdown.encode(message.maxDrawdown, writer.uint32(82).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_js_1.default.Reader ? input : new minimal_js_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseVaultStats();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.totalSubscribedAmount = reader.string();
                    break;
                case 2:
                    message.totalRedeemedAmount = reader.string();
                    break;
                case 3:
                    message.currentAmount = reader.string();
                    break;
                case 4:
                    message.currentAmountWithoutIncentives = reader.string();
                    break;
                case 5:
                    message.currentLpAmount = reader.string();
                    break;
                case 6:
                    message.currentLpPrice = reader.string();
                    break;
                case 7:
                    message.pnl = exports.PnlStats.decode(reader, reader.uint32());
                    break;
                case 8:
                    message.volatility = exports.VolatilityStats.decode(reader, reader.uint32());
                    break;
                case 9:
                    message.apr = exports.AprStats.decode(reader, reader.uint32());
                    break;
                case 10:
                    message.maxDrawdown = exports.MaxDrawdown.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            totalSubscribedAmount: isSet(object.totalSubscribedAmount) ? String(object.totalSubscribedAmount) : "",
            totalRedeemedAmount: isSet(object.totalRedeemedAmount) ? String(object.totalRedeemedAmount) : "",
            currentAmount: isSet(object.currentAmount) ? String(object.currentAmount) : "",
            currentAmountWithoutIncentives: isSet(object.currentAmountWithoutIncentives)
                ? String(object.currentAmountWithoutIncentives)
                : "",
            currentLpAmount: isSet(object.currentLpAmount) ? String(object.currentLpAmount) : "",
            currentLpPrice: isSet(object.currentLpPrice) ? String(object.currentLpPrice) : "",
            pnl: isSet(object.pnl) ? exports.PnlStats.fromJSON(object.pnl) : undefined,
            volatility: isSet(object.volatility) ? exports.VolatilityStats.fromJSON(object.volatility) : undefined,
            apr: isSet(object.apr) ? exports.AprStats.fromJSON(object.apr) : undefined,
            maxDrawdown: isSet(object.maxDrawdown) ? exports.MaxDrawdown.fromJSON(object.maxDrawdown) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.totalSubscribedAmount !== undefined && (obj.totalSubscribedAmount = message.totalSubscribedAmount);
        message.totalRedeemedAmount !== undefined && (obj.totalRedeemedAmount = message.totalRedeemedAmount);
        message.currentAmount !== undefined && (obj.currentAmount = message.currentAmount);
        message.currentAmountWithoutIncentives !== undefined &&
            (obj.currentAmountWithoutIncentives = message.currentAmountWithoutIncentives);
        message.currentLpAmount !== undefined && (obj.currentLpAmount = message.currentLpAmount);
        message.currentLpPrice !== undefined && (obj.currentLpPrice = message.currentLpPrice);
        message.pnl !== undefined && (obj.pnl = message.pnl ? exports.PnlStats.toJSON(message.pnl) : undefined);
        message.volatility !== undefined &&
            (obj.volatility = message.volatility ? exports.VolatilityStats.toJSON(message.volatility) : undefined);
        message.apr !== undefined && (obj.apr = message.apr ? exports.AprStats.toJSON(message.apr) : undefined);
        message.maxDrawdown !== undefined &&
            (obj.maxDrawdown = message.maxDrawdown ? exports.MaxDrawdown.toJSON(message.maxDrawdown) : undefined);
        return obj;
    },
    create(base) {
        return exports.VaultStats.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e, _f;
        const message = createBaseVaultStats();
        message.totalSubscribedAmount = (_a = object.totalSubscribedAmount) !== null && _a !== void 0 ? _a : "";
        message.totalRedeemedAmount = (_b = object.totalRedeemedAmount) !== null && _b !== void 0 ? _b : "";
        message.currentAmount = (_c = object.currentAmount) !== null && _c !== void 0 ? _c : "";
        message.currentAmountWithoutIncentives = (_d = object.currentAmountWithoutIncentives) !== null && _d !== void 0 ? _d : "";
        message.currentLpAmount = (_e = object.currentLpAmount) !== null && _e !== void 0 ? _e : "";
        message.currentLpPrice = (_f = object.currentLpPrice) !== null && _f !== void 0 ? _f : "";
        message.pnl = (object.pnl !== undefined && object.pnl !== null) ? exports.PnlStats.fromPartial(object.pnl) : undefined;
        message.volatility = (object.volatility !== undefined && object.volatility !== null)
            ? exports.VolatilityStats.fromPartial(object.volatility)
            : undefined;
        message.apr = (object.apr !== undefined && object.apr !== null) ? exports.AprStats.fromPartial(object.apr) : undefined;
        message.maxDrawdown = (object.maxDrawdown !== undefined && object.maxDrawdown !== null)
            ? exports.MaxDrawdown.fromPartial(object.maxDrawdown)
            : undefined;
        return message;
    },
};
function createBasePnlStats() {
    return { unrealized: undefined, allTime: undefined };
}
exports.PnlStats = {
    encode(message, writer = minimal_js_1.default.Writer.create()) {
        if (message.unrealized !== undefined) {
            exports.UnrealizedPnl.encode(message.unrealized, writer.uint32(10).fork()).ldelim();
        }
        if (message.allTime !== undefined) {
            exports.Pnl.encode(message.allTime, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_js_1.default.Reader ? input : new minimal_js_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePnlStats();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.unrealized = exports.UnrealizedPnl.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.allTime = exports.Pnl.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            unrealized: isSet(object.unrealized) ? exports.UnrealizedPnl.fromJSON(object.unrealized) : undefined,
            allTime: isSet(object.allTime) ? exports.Pnl.fromJSON(object.allTime) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.unrealized !== undefined &&
            (obj.unrealized = message.unrealized ? exports.UnrealizedPnl.toJSON(message.unrealized) : undefined);
        message.allTime !== undefined && (obj.allTime = message.allTime ? exports.Pnl.toJSON(message.allTime) : undefined);
        return obj;
    },
    create(base) {
        return exports.PnlStats.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        const message = createBasePnlStats();
        message.unrealized = (object.unrealized !== undefined && object.unrealized !== null)
            ? exports.UnrealizedPnl.fromPartial(object.unrealized)
            : undefined;
        message.allTime = (object.allTime !== undefined && object.allTime !== null)
            ? exports.Pnl.fromPartial(object.allTime)
            : undefined;
        return message;
    },
};
function createBaseUnrealizedPnl() {
    return { value: "", percentage: "" };
}
exports.UnrealizedPnl = {
    encode(message, writer = minimal_js_1.default.Writer.create()) {
        if (message.value !== "") {
            writer.uint32(10).string(message.value);
        }
        if (message.percentage !== "") {
            writer.uint32(18).string(message.percentage);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_js_1.default.Reader ? input : new minimal_js_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUnrealizedPnl();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.value = reader.string();
                    break;
                case 2:
                    message.percentage = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            value: isSet(object.value) ? String(object.value) : "",
            percentage: isSet(object.percentage) ? String(object.percentage) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.value !== undefined && (obj.value = message.value);
        message.percentage !== undefined && (obj.percentage = message.percentage);
        return obj;
    },
    create(base) {
        return exports.UnrealizedPnl.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseUnrealizedPnl();
        message.value = (_a = object.value) !== null && _a !== void 0 ? _a : "";
        message.percentage = (_b = object.percentage) !== null && _b !== void 0 ? _b : "";
        return message;
    },
};
function createBasePnl() {
    return { value: "", percentage: "", totalAmountSubscribed: "", totalAmountRedeemed: "", currentAmount: "" };
}
exports.Pnl = {
    encode(message, writer = minimal_js_1.default.Writer.create()) {
        if (message.value !== "") {
            writer.uint32(10).string(message.value);
        }
        if (message.percentage !== "") {
            writer.uint32(18).string(message.percentage);
        }
        if (message.totalAmountSubscribed !== "") {
            writer.uint32(26).string(message.totalAmountSubscribed);
        }
        if (message.totalAmountRedeemed !== "") {
            writer.uint32(34).string(message.totalAmountRedeemed);
        }
        if (message.currentAmount !== "") {
            writer.uint32(42).string(message.currentAmount);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_js_1.default.Reader ? input : new minimal_js_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePnl();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.value = reader.string();
                    break;
                case 2:
                    message.percentage = reader.string();
                    break;
                case 3:
                    message.totalAmountSubscribed = reader.string();
                    break;
                case 4:
                    message.totalAmountRedeemed = reader.string();
                    break;
                case 5:
                    message.currentAmount = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            value: isSet(object.value) ? String(object.value) : "",
            percentage: isSet(object.percentage) ? String(object.percentage) : "",
            totalAmountSubscribed: isSet(object.totalAmountSubscribed) ? String(object.totalAmountSubscribed) : "",
            totalAmountRedeemed: isSet(object.totalAmountRedeemed) ? String(object.totalAmountRedeemed) : "",
            currentAmount: isSet(object.currentAmount) ? String(object.currentAmount) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.value !== undefined && (obj.value = message.value);
        message.percentage !== undefined && (obj.percentage = message.percentage);
        message.totalAmountSubscribed !== undefined && (obj.totalAmountSubscribed = message.totalAmountSubscribed);
        message.totalAmountRedeemed !== undefined && (obj.totalAmountRedeemed = message.totalAmountRedeemed);
        message.currentAmount !== undefined && (obj.currentAmount = message.currentAmount);
        return obj;
    },
    create(base) {
        return exports.Pnl.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e;
        const message = createBasePnl();
        message.value = (_a = object.value) !== null && _a !== void 0 ? _a : "";
        message.percentage = (_b = object.percentage) !== null && _b !== void 0 ? _b : "";
        message.totalAmountSubscribed = (_c = object.totalAmountSubscribed) !== null && _c !== void 0 ? _c : "";
        message.totalAmountRedeemed = (_d = object.totalAmountRedeemed) !== null && _d !== void 0 ? _d : "";
        message.currentAmount = (_e = object.currentAmount) !== null && _e !== void 0 ? _e : "";
        return message;
    },
};
function createBaseVolatilityStats() {
    return { thirtyDays: undefined };
}
exports.VolatilityStats = {
    encode(message, writer = minimal_js_1.default.Writer.create()) {
        if (message.thirtyDays !== undefined) {
            exports.Volatility.encode(message.thirtyDays, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_js_1.default.Reader ? input : new minimal_js_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseVolatilityStats();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.thirtyDays = exports.Volatility.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return { thirtyDays: isSet(object.thirtyDays) ? exports.Volatility.fromJSON(object.thirtyDays) : undefined };
    },
    toJSON(message) {
        const obj = {};
        message.thirtyDays !== undefined &&
            (obj.thirtyDays = message.thirtyDays ? exports.Volatility.toJSON(message.thirtyDays) : undefined);
        return obj;
    },
    create(base) {
        return exports.VolatilityStats.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        const message = createBaseVolatilityStats();
        message.thirtyDays = (object.thirtyDays !== undefined && object.thirtyDays !== null)
            ? exports.Volatility.fromPartial(object.thirtyDays)
            : undefined;
        return message;
    },
};
function createBaseVolatility() {
    return { value: "" };
}
exports.Volatility = {
    encode(message, writer = minimal_js_1.default.Writer.create()) {
        if (message.value !== "") {
            writer.uint32(10).string(message.value);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_js_1.default.Reader ? input : new minimal_js_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseVolatility();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.value = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return { value: isSet(object.value) ? String(object.value) : "" };
    },
    toJSON(message) {
        const obj = {};
        message.value !== undefined && (obj.value = message.value);
        return obj;
    },
    create(base) {
        return exports.Volatility.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a;
        const message = createBaseVolatility();
        message.value = (_a = object.value) !== null && _a !== void 0 ? _a : "";
        return message;
    },
};
function createBaseAprStats() {
    return { thirtyDays: undefined };
}
exports.AprStats = {
    encode(message, writer = minimal_js_1.default.Writer.create()) {
        if (message.thirtyDays !== undefined) {
            exports.Apr.encode(message.thirtyDays, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_js_1.default.Reader ? input : new minimal_js_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAprStats();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.thirtyDays = exports.Apr.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return { thirtyDays: isSet(object.thirtyDays) ? exports.Apr.fromJSON(object.thirtyDays) : undefined };
    },
    toJSON(message) {
        const obj = {};
        message.thirtyDays !== undefined &&
            (obj.thirtyDays = message.thirtyDays ? exports.Apr.toJSON(message.thirtyDays) : undefined);
        return obj;
    },
    create(base) {
        return exports.AprStats.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        const message = createBaseAprStats();
        message.thirtyDays = (object.thirtyDays !== undefined && object.thirtyDays !== null)
            ? exports.Apr.fromPartial(object.thirtyDays)
            : undefined;
        return message;
    },
};
function createBaseApr() {
    return { value: "", originalLpPrice: "", currentLpPrice: "" };
}
exports.Apr = {
    encode(message, writer = minimal_js_1.default.Writer.create()) {
        if (message.value !== "") {
            writer.uint32(10).string(message.value);
        }
        if (message.originalLpPrice !== "") {
            writer.uint32(18).string(message.originalLpPrice);
        }
        if (message.currentLpPrice !== "") {
            writer.uint32(26).string(message.currentLpPrice);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_js_1.default.Reader ? input : new minimal_js_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseApr();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.value = reader.string();
                    break;
                case 2:
                    message.originalLpPrice = reader.string();
                    break;
                case 3:
                    message.currentLpPrice = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            value: isSet(object.value) ? String(object.value) : "",
            originalLpPrice: isSet(object.originalLpPrice) ? String(object.originalLpPrice) : "",
            currentLpPrice: isSet(object.currentLpPrice) ? String(object.currentLpPrice) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.value !== undefined && (obj.value = message.value);
        message.originalLpPrice !== undefined && (obj.originalLpPrice = message.originalLpPrice);
        message.currentLpPrice !== undefined && (obj.currentLpPrice = message.currentLpPrice);
        return obj;
    },
    create(base) {
        return exports.Apr.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseApr();
        message.value = (_a = object.value) !== null && _a !== void 0 ? _a : "";
        message.originalLpPrice = (_b = object.originalLpPrice) !== null && _b !== void 0 ? _b : "";
        message.currentLpPrice = (_c = object.currentLpPrice) !== null && _c !== void 0 ? _c : "";
        return message;
    },
};
function createBaseMaxDrawdown() {
    return { value: "", latestPnLPeak: "" };
}
exports.MaxDrawdown = {
    encode(message, writer = minimal_js_1.default.Writer.create()) {
        if (message.value !== "") {
            writer.uint32(10).string(message.value);
        }
        if (message.latestPnLPeak !== "") {
            writer.uint32(18).string(message.latestPnLPeak);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_js_1.default.Reader ? input : new minimal_js_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMaxDrawdown();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.value = reader.string();
                    break;
                case 2:
                    message.latestPnLPeak = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            value: isSet(object.value) ? String(object.value) : "",
            latestPnLPeak: isSet(object.latestPnLPeak) ? String(object.latestPnLPeak) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.value !== undefined && (obj.value = message.value);
        message.latestPnLPeak !== undefined && (obj.latestPnLPeak = message.latestPnLPeak);
        return obj;
    },
    create(base) {
        return exports.MaxDrawdown.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseMaxDrawdown();
        message.value = (_a = object.value) !== null && _a !== void 0 ? _a : "";
        message.latestPnLPeak = (_b = object.latestPnLPeak) !== null && _b !== void 0 ? _b : "";
        return message;
    },
};
function createBaseGetUserRequest() {
    return { vaultAddress: "", userAddress: "" };
}
exports.GetUserRequest = {
    encode(message, writer = minimal_js_1.default.Writer.create()) {
        if (message.vaultAddress !== "") {
            writer.uint32(10).string(message.vaultAddress);
        }
        if (message.userAddress !== "") {
            writer.uint32(18).string(message.userAddress);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_js_1.default.Reader ? input : new minimal_js_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetUserRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.vaultAddress = reader.string();
                    break;
                case 2:
                    message.userAddress = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            vaultAddress: isSet(object.vaultAddress) ? String(object.vaultAddress) : "",
            userAddress: isSet(object.userAddress) ? String(object.userAddress) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.vaultAddress !== undefined && (obj.vaultAddress = message.vaultAddress);
        message.userAddress !== undefined && (obj.userAddress = message.userAddress);
        return obj;
    },
    create(base) {
        return exports.GetUserRequest.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseGetUserRequest();
        message.vaultAddress = (_a = object.vaultAddress) !== null && _a !== void 0 ? _a : "";
        message.userAddress = (_b = object.userAddress) !== null && _b !== void 0 ? _b : "";
        return message;
    },
};
function createBaseGetUserResponse() {
    return { user: undefined };
}
exports.GetUserResponse = {
    encode(message, writer = minimal_js_1.default.Writer.create()) {
        if (message.user !== undefined) {
            exports.User.encode(message.user, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_js_1.default.Reader ? input : new minimal_js_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetUserResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.user = exports.User.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return { user: isSet(object.user) ? exports.User.fromJSON(object.user) : undefined };
    },
    toJSON(message) {
        const obj = {};
        message.user !== undefined && (obj.user = message.user ? exports.User.toJSON(message.user) : undefined);
        return obj;
    },
    create(base) {
        return exports.GetUserResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        const message = createBaseGetUserResponse();
        message.user = (object.user !== undefined && object.user !== null) ? exports.User.fromPartial(object.user) : undefined;
        return message;
    },
};
function createBaseUser() {
    return { address: "", contractAddress: "", stats: undefined, updatedHeight: "0", updatedAt: "0" };
}
exports.User = {
    encode(message, writer = minimal_js_1.default.Writer.create()) {
        if (message.address !== "") {
            writer.uint32(10).string(message.address);
        }
        if (message.contractAddress !== "") {
            writer.uint32(18).string(message.contractAddress);
        }
        if (message.stats !== undefined) {
            exports.UserStats.encode(message.stats, writer.uint32(26).fork()).ldelim();
        }
        if (message.updatedHeight !== "0") {
            writer.uint32(32).sint64(message.updatedHeight);
        }
        if (message.updatedAt !== "0") {
            writer.uint32(40).sint64(message.updatedAt);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_js_1.default.Reader ? input : new minimal_js_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUser();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.address = reader.string();
                    break;
                case 2:
                    message.contractAddress = reader.string();
                    break;
                case 3:
                    message.stats = exports.UserStats.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.updatedHeight = longToString(reader.sint64());
                    break;
                case 5:
                    message.updatedAt = longToString(reader.sint64());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            address: isSet(object.address) ? String(object.address) : "",
            contractAddress: isSet(object.contractAddress) ? String(object.contractAddress) : "",
            stats: isSet(object.stats) ? exports.UserStats.fromJSON(object.stats) : undefined,
            updatedHeight: isSet(object.updatedHeight) ? String(object.updatedHeight) : "0",
            updatedAt: isSet(object.updatedAt) ? String(object.updatedAt) : "0",
        };
    },
    toJSON(message) {
        const obj = {};
        message.address !== undefined && (obj.address = message.address);
        message.contractAddress !== undefined && (obj.contractAddress = message.contractAddress);
        message.stats !== undefined && (obj.stats = message.stats ? exports.UserStats.toJSON(message.stats) : undefined);
        message.updatedHeight !== undefined && (obj.updatedHeight = message.updatedHeight);
        message.updatedAt !== undefined && (obj.updatedAt = message.updatedAt);
        return obj;
    },
    create(base) {
        return exports.User.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c, _d;
        const message = createBaseUser();
        message.address = (_a = object.address) !== null && _a !== void 0 ? _a : "";
        message.contractAddress = (_b = object.contractAddress) !== null && _b !== void 0 ? _b : "";
        message.stats = (object.stats !== undefined && object.stats !== null)
            ? exports.UserStats.fromPartial(object.stats)
            : undefined;
        message.updatedHeight = (_c = object.updatedHeight) !== null && _c !== void 0 ? _c : "0";
        message.updatedAt = (_d = object.updatedAt) !== null && _d !== void 0 ? _d : "0";
        return message;
    },
};
function createBaseUserStats() {
    return { currentAmount: "", currentLpAmount: "", pnl: undefined, depositedValue: "" };
}
exports.UserStats = {
    encode(message, writer = minimal_js_1.default.Writer.create()) {
        if (message.currentAmount !== "") {
            writer.uint32(10).string(message.currentAmount);
        }
        if (message.currentLpAmount !== "") {
            writer.uint32(18).string(message.currentLpAmount);
        }
        if (message.pnl !== undefined) {
            exports.PnlStats.encode(message.pnl, writer.uint32(26).fork()).ldelim();
        }
        if (message.depositedValue !== "") {
            writer.uint32(34).string(message.depositedValue);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_js_1.default.Reader ? input : new minimal_js_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUserStats();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.currentAmount = reader.string();
                    break;
                case 2:
                    message.currentLpAmount = reader.string();
                    break;
                case 3:
                    message.pnl = exports.PnlStats.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.depositedValue = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            currentAmount: isSet(object.currentAmount) ? String(object.currentAmount) : "",
            currentLpAmount: isSet(object.currentLpAmount) ? String(object.currentLpAmount) : "",
            pnl: isSet(object.pnl) ? exports.PnlStats.fromJSON(object.pnl) : undefined,
            depositedValue: isSet(object.depositedValue) ? String(object.depositedValue) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.currentAmount !== undefined && (obj.currentAmount = message.currentAmount);
        message.currentLpAmount !== undefined && (obj.currentLpAmount = message.currentLpAmount);
        message.pnl !== undefined && (obj.pnl = message.pnl ? exports.PnlStats.toJSON(message.pnl) : undefined);
        message.depositedValue !== undefined && (obj.depositedValue = message.depositedValue);
        return obj;
    },
    create(base) {
        return exports.UserStats.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseUserStats();
        message.currentAmount = (_a = object.currentAmount) !== null && _a !== void 0 ? _a : "";
        message.currentLpAmount = (_b = object.currentLpAmount) !== null && _b !== void 0 ? _b : "";
        message.pnl = (object.pnl !== undefined && object.pnl !== null) ? exports.PnlStats.fromPartial(object.pnl) : undefined;
        message.depositedValue = (_c = object.depositedValue) !== null && _c !== void 0 ? _c : "";
        return message;
    },
};
function createBaseListSubscriptionsRequest() {
    return { vaultAddress: "", userAddress: "", status: "", perPage: 0, token: "" };
}
exports.ListSubscriptionsRequest = {
    encode(message, writer = minimal_js_1.default.Writer.create()) {
        if (message.vaultAddress !== "") {
            writer.uint32(10).string(message.vaultAddress);
        }
        if (message.userAddress !== "") {
            writer.uint32(18).string(message.userAddress);
        }
        if (message.status !== "") {
            writer.uint32(26).string(message.status);
        }
        if (message.perPage !== 0) {
            writer.uint32(32).sint32(message.perPage);
        }
        if (message.token !== "") {
            writer.uint32(42).string(message.token);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_js_1.default.Reader ? input : new minimal_js_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseListSubscriptionsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.vaultAddress = reader.string();
                    break;
                case 2:
                    message.userAddress = reader.string();
                    break;
                case 3:
                    message.status = reader.string();
                    break;
                case 4:
                    message.perPage = reader.sint32();
                    break;
                case 5:
                    message.token = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            vaultAddress: isSet(object.vaultAddress) ? String(object.vaultAddress) : "",
            userAddress: isSet(object.userAddress) ? String(object.userAddress) : "",
            status: isSet(object.status) ? String(object.status) : "",
            perPage: isSet(object.perPage) ? Number(object.perPage) : 0,
            token: isSet(object.token) ? String(object.token) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.vaultAddress !== undefined && (obj.vaultAddress = message.vaultAddress);
        message.userAddress !== undefined && (obj.userAddress = message.userAddress);
        message.status !== undefined && (obj.status = message.status);
        message.perPage !== undefined && (obj.perPage = Math.round(message.perPage));
        message.token !== undefined && (obj.token = message.token);
        return obj;
    },
    create(base) {
        return exports.ListSubscriptionsRequest.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e;
        const message = createBaseListSubscriptionsRequest();
        message.vaultAddress = (_a = object.vaultAddress) !== null && _a !== void 0 ? _a : "";
        message.userAddress = (_b = object.userAddress) !== null && _b !== void 0 ? _b : "";
        message.status = (_c = object.status) !== null && _c !== void 0 ? _c : "";
        message.perPage = (_d = object.perPage) !== null && _d !== void 0 ? _d : 0;
        message.token = (_e = object.token) !== null && _e !== void 0 ? _e : "";
        return message;
    },
};
function createBaseListSubscriptionsResponse() {
    return { subscriptions: [], next: [] };
}
exports.ListSubscriptionsResponse = {
    encode(message, writer = minimal_js_1.default.Writer.create()) {
        for (const v of message.subscriptions) {
            exports.Subscription.encode(v, writer.uint32(10).fork()).ldelim();
        }
        for (const v of message.next) {
            writer.uint32(18).string(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_js_1.default.Reader ? input : new minimal_js_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseListSubscriptionsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.subscriptions.push(exports.Subscription.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.next.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            subscriptions: Array.isArray(object === null || object === void 0 ? void 0 : object.subscriptions)
                ? object.subscriptions.map((e) => exports.Subscription.fromJSON(e))
                : [],
            next: Array.isArray(object === null || object === void 0 ? void 0 : object.next) ? object.next.map((e) => String(e)) : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.subscriptions) {
            obj.subscriptions = message.subscriptions.map((e) => e ? exports.Subscription.toJSON(e) : undefined);
        }
        else {
            obj.subscriptions = [];
        }
        if (message.next) {
            obj.next = message.next.map((e) => e);
        }
        else {
            obj.next = [];
        }
        return obj;
    },
    create(base) {
        return exports.ListSubscriptionsResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseListSubscriptionsResponse();
        message.subscriptions = ((_a = object.subscriptions) === null || _a === void 0 ? void 0 : _a.map((e) => exports.Subscription.fromPartial(e))) || [];
        message.next = ((_b = object.next) === null || _b === void 0 ? void 0 : _b.map((e) => e)) || [];
        return message;
    },
};
function createBaseSubscription() {
    return {
        contractAddress: "",
        user: "",
        index: "0",
        lpAmount: "",
        amount: "",
        status: "",
        createdHeight: "0",
        createdAt: "0",
        executedHeight: "0",
        executedAt: "0",
    };
}
exports.Subscription = {
    encode(message, writer = minimal_js_1.default.Writer.create()) {
        if (message.contractAddress !== "") {
            writer.uint32(10).string(message.contractAddress);
        }
        if (message.user !== "") {
            writer.uint32(18).string(message.user);
        }
        if (message.index !== "0") {
            writer.uint32(24).sint64(message.index);
        }
        if (message.lpAmount !== "") {
            writer.uint32(34).string(message.lpAmount);
        }
        if (message.amount !== "") {
            writer.uint32(42).string(message.amount);
        }
        if (message.status !== "") {
            writer.uint32(50).string(message.status);
        }
        if (message.createdHeight !== "0") {
            writer.uint32(56).sint64(message.createdHeight);
        }
        if (message.createdAt !== "0") {
            writer.uint32(64).sint64(message.createdAt);
        }
        if (message.executedHeight !== "0") {
            writer.uint32(72).sint64(message.executedHeight);
        }
        if (message.executedAt !== "0") {
            writer.uint32(80).sint64(message.executedAt);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_js_1.default.Reader ? input : new minimal_js_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSubscription();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.contractAddress = reader.string();
                    break;
                case 2:
                    message.user = reader.string();
                    break;
                case 3:
                    message.index = longToString(reader.sint64());
                    break;
                case 4:
                    message.lpAmount = reader.string();
                    break;
                case 5:
                    message.amount = reader.string();
                    break;
                case 6:
                    message.status = reader.string();
                    break;
                case 7:
                    message.createdHeight = longToString(reader.sint64());
                    break;
                case 8:
                    message.createdAt = longToString(reader.sint64());
                    break;
                case 9:
                    message.executedHeight = longToString(reader.sint64());
                    break;
                case 10:
                    message.executedAt = longToString(reader.sint64());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            contractAddress: isSet(object.contractAddress) ? String(object.contractAddress) : "",
            user: isSet(object.user) ? String(object.user) : "",
            index: isSet(object.index) ? String(object.index) : "0",
            lpAmount: isSet(object.lpAmount) ? String(object.lpAmount) : "",
            amount: isSet(object.amount) ? String(object.amount) : "",
            status: isSet(object.status) ? String(object.status) : "",
            createdHeight: isSet(object.createdHeight) ? String(object.createdHeight) : "0",
            createdAt: isSet(object.createdAt) ? String(object.createdAt) : "0",
            executedHeight: isSet(object.executedHeight) ? String(object.executedHeight) : "0",
            executedAt: isSet(object.executedAt) ? String(object.executedAt) : "0",
        };
    },
    toJSON(message) {
        const obj = {};
        message.contractAddress !== undefined && (obj.contractAddress = message.contractAddress);
        message.user !== undefined && (obj.user = message.user);
        message.index !== undefined && (obj.index = message.index);
        message.lpAmount !== undefined && (obj.lpAmount = message.lpAmount);
        message.amount !== undefined && (obj.amount = message.amount);
        message.status !== undefined && (obj.status = message.status);
        message.createdHeight !== undefined && (obj.createdHeight = message.createdHeight);
        message.createdAt !== undefined && (obj.createdAt = message.createdAt);
        message.executedHeight !== undefined && (obj.executedHeight = message.executedHeight);
        message.executedAt !== undefined && (obj.executedAt = message.executedAt);
        return obj;
    },
    create(base) {
        return exports.Subscription.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        const message = createBaseSubscription();
        message.contractAddress = (_a = object.contractAddress) !== null && _a !== void 0 ? _a : "";
        message.user = (_b = object.user) !== null && _b !== void 0 ? _b : "";
        message.index = (_c = object.index) !== null && _c !== void 0 ? _c : "0";
        message.lpAmount = (_d = object.lpAmount) !== null && _d !== void 0 ? _d : "";
        message.amount = (_e = object.amount) !== null && _e !== void 0 ? _e : "";
        message.status = (_f = object.status) !== null && _f !== void 0 ? _f : "";
        message.createdHeight = (_g = object.createdHeight) !== null && _g !== void 0 ? _g : "0";
        message.createdAt = (_h = object.createdAt) !== null && _h !== void 0 ? _h : "0";
        message.executedHeight = (_j = object.executedHeight) !== null && _j !== void 0 ? _j : "0";
        message.executedAt = (_k = object.executedAt) !== null && _k !== void 0 ? _k : "0";
        return message;
    },
};
function createBaseListRedemptionsRequest() {
    return { vaultAddress: "", userAddress: "", status: "", perPage: 0, token: "" };
}
exports.ListRedemptionsRequest = {
    encode(message, writer = minimal_js_1.default.Writer.create()) {
        if (message.vaultAddress !== "") {
            writer.uint32(10).string(message.vaultAddress);
        }
        if (message.userAddress !== "") {
            writer.uint32(18).string(message.userAddress);
        }
        if (message.status !== "") {
            writer.uint32(26).string(message.status);
        }
        if (message.perPage !== 0) {
            writer.uint32(32).sint32(message.perPage);
        }
        if (message.token !== "") {
            writer.uint32(42).string(message.token);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_js_1.default.Reader ? input : new minimal_js_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseListRedemptionsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.vaultAddress = reader.string();
                    break;
                case 2:
                    message.userAddress = reader.string();
                    break;
                case 3:
                    message.status = reader.string();
                    break;
                case 4:
                    message.perPage = reader.sint32();
                    break;
                case 5:
                    message.token = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            vaultAddress: isSet(object.vaultAddress) ? String(object.vaultAddress) : "",
            userAddress: isSet(object.userAddress) ? String(object.userAddress) : "",
            status: isSet(object.status) ? String(object.status) : "",
            perPage: isSet(object.perPage) ? Number(object.perPage) : 0,
            token: isSet(object.token) ? String(object.token) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.vaultAddress !== undefined && (obj.vaultAddress = message.vaultAddress);
        message.userAddress !== undefined && (obj.userAddress = message.userAddress);
        message.status !== undefined && (obj.status = message.status);
        message.perPage !== undefined && (obj.perPage = Math.round(message.perPage));
        message.token !== undefined && (obj.token = message.token);
        return obj;
    },
    create(base) {
        return exports.ListRedemptionsRequest.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e;
        const message = createBaseListRedemptionsRequest();
        message.vaultAddress = (_a = object.vaultAddress) !== null && _a !== void 0 ? _a : "";
        message.userAddress = (_b = object.userAddress) !== null && _b !== void 0 ? _b : "";
        message.status = (_c = object.status) !== null && _c !== void 0 ? _c : "";
        message.perPage = (_d = object.perPage) !== null && _d !== void 0 ? _d : 0;
        message.token = (_e = object.token) !== null && _e !== void 0 ? _e : "";
        return message;
    },
};
function createBaseListRedemptionsResponse() {
    return { redemptions: [], next: [] };
}
exports.ListRedemptionsResponse = {
    encode(message, writer = minimal_js_1.default.Writer.create()) {
        for (const v of message.redemptions) {
            exports.Redemption.encode(v, writer.uint32(10).fork()).ldelim();
        }
        for (const v of message.next) {
            writer.uint32(18).string(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_js_1.default.Reader ? input : new minimal_js_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseListRedemptionsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.redemptions.push(exports.Redemption.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.next.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            redemptions: Array.isArray(object === null || object === void 0 ? void 0 : object.redemptions) ? object.redemptions.map((e) => exports.Redemption.fromJSON(e)) : [],
            next: Array.isArray(object === null || object === void 0 ? void 0 : object.next) ? object.next.map((e) => String(e)) : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.redemptions) {
            obj.redemptions = message.redemptions.map((e) => e ? exports.Redemption.toJSON(e) : undefined);
        }
        else {
            obj.redemptions = [];
        }
        if (message.next) {
            obj.next = message.next.map((e) => e);
        }
        else {
            obj.next = [];
        }
        return obj;
    },
    create(base) {
        return exports.ListRedemptionsResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseListRedemptionsResponse();
        message.redemptions = ((_a = object.redemptions) === null || _a === void 0 ? void 0 : _a.map((e) => exports.Redemption.fromPartial(e))) || [];
        message.next = ((_b = object.next) === null || _b === void 0 ? void 0 : _b.map((e) => e)) || [];
        return message;
    },
};
function createBaseRedemption() {
    return {
        contractAddress: "",
        user: "",
        index: "0",
        lpAmount: "",
        amount: "",
        status: "",
        dueAt: "0",
        createdHeight: "0",
        createdAt: "0",
        executedHeight: "0",
        executedAt: "0",
    };
}
exports.Redemption = {
    encode(message, writer = minimal_js_1.default.Writer.create()) {
        if (message.contractAddress !== "") {
            writer.uint32(10).string(message.contractAddress);
        }
        if (message.user !== "") {
            writer.uint32(18).string(message.user);
        }
        if (message.index !== "0") {
            writer.uint32(24).sint64(message.index);
        }
        if (message.lpAmount !== "") {
            writer.uint32(34).string(message.lpAmount);
        }
        if (message.amount !== "") {
            writer.uint32(42).string(message.amount);
        }
        if (message.status !== "") {
            writer.uint32(50).string(message.status);
        }
        if (message.dueAt !== "0") {
            writer.uint32(56).sint64(message.dueAt);
        }
        if (message.createdHeight !== "0") {
            writer.uint32(64).sint64(message.createdHeight);
        }
        if (message.createdAt !== "0") {
            writer.uint32(72).sint64(message.createdAt);
        }
        if (message.executedHeight !== "0") {
            writer.uint32(80).sint64(message.executedHeight);
        }
        if (message.executedAt !== "0") {
            writer.uint32(88).sint64(message.executedAt);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_js_1.default.Reader ? input : new minimal_js_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRedemption();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.contractAddress = reader.string();
                    break;
                case 2:
                    message.user = reader.string();
                    break;
                case 3:
                    message.index = longToString(reader.sint64());
                    break;
                case 4:
                    message.lpAmount = reader.string();
                    break;
                case 5:
                    message.amount = reader.string();
                    break;
                case 6:
                    message.status = reader.string();
                    break;
                case 7:
                    message.dueAt = longToString(reader.sint64());
                    break;
                case 8:
                    message.createdHeight = longToString(reader.sint64());
                    break;
                case 9:
                    message.createdAt = longToString(reader.sint64());
                    break;
                case 10:
                    message.executedHeight = longToString(reader.sint64());
                    break;
                case 11:
                    message.executedAt = longToString(reader.sint64());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            contractAddress: isSet(object.contractAddress) ? String(object.contractAddress) : "",
            user: isSet(object.user) ? String(object.user) : "",
            index: isSet(object.index) ? String(object.index) : "0",
            lpAmount: isSet(object.lpAmount) ? String(object.lpAmount) : "",
            amount: isSet(object.amount) ? String(object.amount) : "",
            status: isSet(object.status) ? String(object.status) : "",
            dueAt: isSet(object.dueAt) ? String(object.dueAt) : "0",
            createdHeight: isSet(object.createdHeight) ? String(object.createdHeight) : "0",
            createdAt: isSet(object.createdAt) ? String(object.createdAt) : "0",
            executedHeight: isSet(object.executedHeight) ? String(object.executedHeight) : "0",
            executedAt: isSet(object.executedAt) ? String(object.executedAt) : "0",
        };
    },
    toJSON(message) {
        const obj = {};
        message.contractAddress !== undefined && (obj.contractAddress = message.contractAddress);
        message.user !== undefined && (obj.user = message.user);
        message.index !== undefined && (obj.index = message.index);
        message.lpAmount !== undefined && (obj.lpAmount = message.lpAmount);
        message.amount !== undefined && (obj.amount = message.amount);
        message.status !== undefined && (obj.status = message.status);
        message.dueAt !== undefined && (obj.dueAt = message.dueAt);
        message.createdHeight !== undefined && (obj.createdHeight = message.createdHeight);
        message.createdAt !== undefined && (obj.createdAt = message.createdAt);
        message.executedHeight !== undefined && (obj.executedHeight = message.executedHeight);
        message.executedAt !== undefined && (obj.executedAt = message.executedAt);
        return obj;
    },
    create(base) {
        return exports.Redemption.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
        const message = createBaseRedemption();
        message.contractAddress = (_a = object.contractAddress) !== null && _a !== void 0 ? _a : "";
        message.user = (_b = object.user) !== null && _b !== void 0 ? _b : "";
        message.index = (_c = object.index) !== null && _c !== void 0 ? _c : "0";
        message.lpAmount = (_d = object.lpAmount) !== null && _d !== void 0 ? _d : "";
        message.amount = (_e = object.amount) !== null && _e !== void 0 ? _e : "";
        message.status = (_f = object.status) !== null && _f !== void 0 ? _f : "";
        message.dueAt = (_g = object.dueAt) !== null && _g !== void 0 ? _g : "0";
        message.createdHeight = (_h = object.createdHeight) !== null && _h !== void 0 ? _h : "0";
        message.createdAt = (_j = object.createdAt) !== null && _j !== void 0 ? _j : "0";
        message.executedHeight = (_k = object.executedHeight) !== null && _k !== void 0 ? _k : "0";
        message.executedAt = (_l = object.executedAt) !== null && _l !== void 0 ? _l : "0";
        return message;
    },
};
function createBaseGetOperatorRedemptionBucketsRequest() {
    return { vaultAddress: "", operatorAddress: "" };
}
exports.GetOperatorRedemptionBucketsRequest = {
    encode(message, writer = minimal_js_1.default.Writer.create()) {
        if (message.vaultAddress !== "") {
            writer.uint32(10).string(message.vaultAddress);
        }
        if (message.operatorAddress !== "") {
            writer.uint32(18).string(message.operatorAddress);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_js_1.default.Reader ? input : new minimal_js_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetOperatorRedemptionBucketsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.vaultAddress = reader.string();
                    break;
                case 2:
                    message.operatorAddress = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            vaultAddress: isSet(object.vaultAddress) ? String(object.vaultAddress) : "",
            operatorAddress: isSet(object.operatorAddress) ? String(object.operatorAddress) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.vaultAddress !== undefined && (obj.vaultAddress = message.vaultAddress);
        message.operatorAddress !== undefined && (obj.operatorAddress = message.operatorAddress);
        return obj;
    },
    create(base) {
        return exports.GetOperatorRedemptionBucketsRequest.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseGetOperatorRedemptionBucketsRequest();
        message.vaultAddress = (_a = object.vaultAddress) !== null && _a !== void 0 ? _a : "";
        message.operatorAddress = (_b = object.operatorAddress) !== null && _b !== void 0 ? _b : "";
        return message;
    },
};
function createBaseGetOperatorRedemptionBucketsResponse() {
    return { buckets: [] };
}
exports.GetOperatorRedemptionBucketsResponse = {
    encode(message, writer = minimal_js_1.default.Writer.create()) {
        for (const v of message.buckets) {
            exports.RedemptionBucket.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_js_1.default.Reader ? input : new minimal_js_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetOperatorRedemptionBucketsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.buckets.push(exports.RedemptionBucket.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            buckets: Array.isArray(object === null || object === void 0 ? void 0 : object.buckets) ? object.buckets.map((e) => exports.RedemptionBucket.fromJSON(e)) : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.buckets) {
            obj.buckets = message.buckets.map((e) => e ? exports.RedemptionBucket.toJSON(e) : undefined);
        }
        else {
            obj.buckets = [];
        }
        return obj;
    },
    create(base) {
        return exports.GetOperatorRedemptionBucketsResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a;
        const message = createBaseGetOperatorRedemptionBucketsResponse();
        message.buckets = ((_a = object.buckets) === null || _a === void 0 ? void 0 : _a.map((e) => exports.RedemptionBucket.fromPartial(e))) || [];
        return message;
    },
};
function createBaseRedemptionBucket() {
    return { bucket: "", lpAmountToRedeem: "", neededAmount: "", missingLiquidity: "" };
}
exports.RedemptionBucket = {
    encode(message, writer = minimal_js_1.default.Writer.create()) {
        if (message.bucket !== "") {
            writer.uint32(10).string(message.bucket);
        }
        if (message.lpAmountToRedeem !== "") {
            writer.uint32(18).string(message.lpAmountToRedeem);
        }
        if (message.neededAmount !== "") {
            writer.uint32(26).string(message.neededAmount);
        }
        if (message.missingLiquidity !== "") {
            writer.uint32(34).string(message.missingLiquidity);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_js_1.default.Reader ? input : new minimal_js_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRedemptionBucket();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.bucket = reader.string();
                    break;
                case 2:
                    message.lpAmountToRedeem = reader.string();
                    break;
                case 3:
                    message.neededAmount = reader.string();
                    break;
                case 4:
                    message.missingLiquidity = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            bucket: isSet(object.bucket) ? String(object.bucket) : "",
            lpAmountToRedeem: isSet(object.lpAmountToRedeem) ? String(object.lpAmountToRedeem) : "",
            neededAmount: isSet(object.neededAmount) ? String(object.neededAmount) : "",
            missingLiquidity: isSet(object.missingLiquidity) ? String(object.missingLiquidity) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.bucket !== undefined && (obj.bucket = message.bucket);
        message.lpAmountToRedeem !== undefined && (obj.lpAmountToRedeem = message.lpAmountToRedeem);
        message.neededAmount !== undefined && (obj.neededAmount = message.neededAmount);
        message.missingLiquidity !== undefined && (obj.missingLiquidity = message.missingLiquidity);
        return obj;
    },
    create(base) {
        return exports.RedemptionBucket.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c, _d;
        const message = createBaseRedemptionBucket();
        message.bucket = (_a = object.bucket) !== null && _a !== void 0 ? _a : "";
        message.lpAmountToRedeem = (_b = object.lpAmountToRedeem) !== null && _b !== void 0 ? _b : "";
        message.neededAmount = (_c = object.neededAmount) !== null && _c !== void 0 ? _c : "";
        message.missingLiquidity = (_d = object.missingLiquidity) !== null && _d !== void 0 ? _d : "";
        return message;
    },
};
function createBaseTvlHistoryRequest() {
    return { vaultAddress: "", since: "0", maxDataPoints: 0 };
}
exports.TvlHistoryRequest = {
    encode(message, writer = minimal_js_1.default.Writer.create()) {
        if (message.vaultAddress !== "") {
            writer.uint32(10).string(message.vaultAddress);
        }
        if (message.since !== "0") {
            writer.uint32(16).sint64(message.since);
        }
        if (message.maxDataPoints !== 0) {
            writer.uint32(24).sint32(message.maxDataPoints);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_js_1.default.Reader ? input : new minimal_js_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTvlHistoryRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.vaultAddress = reader.string();
                    break;
                case 2:
                    message.since = longToString(reader.sint64());
                    break;
                case 3:
                    message.maxDataPoints = reader.sint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            vaultAddress: isSet(object.vaultAddress) ? String(object.vaultAddress) : "",
            since: isSet(object.since) ? String(object.since) : "0",
            maxDataPoints: isSet(object.maxDataPoints) ? Number(object.maxDataPoints) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        message.vaultAddress !== undefined && (obj.vaultAddress = message.vaultAddress);
        message.since !== undefined && (obj.since = message.since);
        message.maxDataPoints !== undefined && (obj.maxDataPoints = Math.round(message.maxDataPoints));
        return obj;
    },
    create(base) {
        return exports.TvlHistoryRequest.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseTvlHistoryRequest();
        message.vaultAddress = (_a = object.vaultAddress) !== null && _a !== void 0 ? _a : "";
        message.since = (_b = object.since) !== null && _b !== void 0 ? _b : "0";
        message.maxDataPoints = (_c = object.maxDataPoints) !== null && _c !== void 0 ? _c : 0;
        return message;
    },
};
function createBaseTvlHistoryResponse() {
    return { history: [] };
}
exports.TvlHistoryResponse = {
    encode(message, writer = minimal_js_1.default.Writer.create()) {
        for (const v of message.history) {
            exports.HistoricalTVL.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_js_1.default.Reader ? input : new minimal_js_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTvlHistoryResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.history.push(exports.HistoricalTVL.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return { history: Array.isArray(object === null || object === void 0 ? void 0 : object.history) ? object.history.map((e) => exports.HistoricalTVL.fromJSON(e)) : [] };
    },
    toJSON(message) {
        const obj = {};
        if (message.history) {
            obj.history = message.history.map((e) => e ? exports.HistoricalTVL.toJSON(e) : undefined);
        }
        else {
            obj.history = [];
        }
        return obj;
    },
    create(base) {
        return exports.TvlHistoryResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a;
        const message = createBaseTvlHistoryResponse();
        message.history = ((_a = object.history) === null || _a === void 0 ? void 0 : _a.map((e) => exports.HistoricalTVL.fromPartial(e))) || [];
        return message;
    },
};
function createBaseHistoricalTVL() {
    return { t: 0, v: "" };
}
exports.HistoricalTVL = {
    encode(message, writer = minimal_js_1.default.Writer.create()) {
        if (message.t !== 0) {
            writer.uint32(8).sint32(message.t);
        }
        if (message.v !== "") {
            writer.uint32(18).string(message.v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_js_1.default.Reader ? input : new minimal_js_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseHistoricalTVL();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.t = reader.sint32();
                    break;
                case 2:
                    message.v = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return { t: isSet(object.t) ? Number(object.t) : 0, v: isSet(object.v) ? String(object.v) : "" };
    },
    toJSON(message) {
        const obj = {};
        message.t !== undefined && (obj.t = Math.round(message.t));
        message.v !== undefined && (obj.v = message.v);
        return obj;
    },
    create(base) {
        return exports.HistoricalTVL.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseHistoricalTVL();
        message.t = (_a = object.t) !== null && _a !== void 0 ? _a : 0;
        message.v = (_b = object.v) !== null && _b !== void 0 ? _b : "";
        return message;
    },
};
function createBasePnlHistoryRequest() {
    return { vaultAddress: "", since: "0", maxDataPoints: 0 };
}
exports.PnlHistoryRequest = {
    encode(message, writer = minimal_js_1.default.Writer.create()) {
        if (message.vaultAddress !== "") {
            writer.uint32(10).string(message.vaultAddress);
        }
        if (message.since !== "0") {
            writer.uint32(16).sint64(message.since);
        }
        if (message.maxDataPoints !== 0) {
            writer.uint32(24).sint32(message.maxDataPoints);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_js_1.default.Reader ? input : new minimal_js_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePnlHistoryRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.vaultAddress = reader.string();
                    break;
                case 2:
                    message.since = longToString(reader.sint64());
                    break;
                case 3:
                    message.maxDataPoints = reader.sint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            vaultAddress: isSet(object.vaultAddress) ? String(object.vaultAddress) : "",
            since: isSet(object.since) ? String(object.since) : "0",
            maxDataPoints: isSet(object.maxDataPoints) ? Number(object.maxDataPoints) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        message.vaultAddress !== undefined && (obj.vaultAddress = message.vaultAddress);
        message.since !== undefined && (obj.since = message.since);
        message.maxDataPoints !== undefined && (obj.maxDataPoints = Math.round(message.maxDataPoints));
        return obj;
    },
    create(base) {
        return exports.PnlHistoryRequest.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c;
        const message = createBasePnlHistoryRequest();
        message.vaultAddress = (_a = object.vaultAddress) !== null && _a !== void 0 ? _a : "";
        message.since = (_b = object.since) !== null && _b !== void 0 ? _b : "0";
        message.maxDataPoints = (_c = object.maxDataPoints) !== null && _c !== void 0 ? _c : 0;
        return message;
    },
};
function createBasePnlHistoryResponse() {
    return { history: [] };
}
exports.PnlHistoryResponse = {
    encode(message, writer = minimal_js_1.default.Writer.create()) {
        for (const v of message.history) {
            exports.HistoricalPnL.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_js_1.default.Reader ? input : new minimal_js_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePnlHistoryResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.history.push(exports.HistoricalPnL.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return { history: Array.isArray(object === null || object === void 0 ? void 0 : object.history) ? object.history.map((e) => exports.HistoricalPnL.fromJSON(e)) : [] };
    },
    toJSON(message) {
        const obj = {};
        if (message.history) {
            obj.history = message.history.map((e) => e ? exports.HistoricalPnL.toJSON(e) : undefined);
        }
        else {
            obj.history = [];
        }
        return obj;
    },
    create(base) {
        return exports.PnlHistoryResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a;
        const message = createBasePnlHistoryResponse();
        message.history = ((_a = object.history) === null || _a === void 0 ? void 0 : _a.map((e) => exports.HistoricalPnL.fromPartial(e))) || [];
        return message;
    },
};
function createBaseHistoricalPnL() {
    return { t: 0, v: "" };
}
exports.HistoricalPnL = {
    encode(message, writer = minimal_js_1.default.Writer.create()) {
        if (message.t !== 0) {
            writer.uint32(8).sint32(message.t);
        }
        if (message.v !== "") {
            writer.uint32(18).string(message.v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_js_1.default.Reader ? input : new minimal_js_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseHistoricalPnL();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.t = reader.sint32();
                    break;
                case 2:
                    message.v = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return { t: isSet(object.t) ? Number(object.t) : 0, v: isSet(object.v) ? String(object.v) : "" };
    },
    toJSON(message) {
        const obj = {};
        message.t !== undefined && (obj.t = Math.round(message.t));
        message.v !== undefined && (obj.v = message.v);
        return obj;
    },
    create(base) {
        return exports.HistoricalPnL.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseHistoricalPnL();
        message.t = (_a = object.t) !== null && _a !== void 0 ? _a : 0;
        message.v = (_b = object.v) !== null && _b !== void 0 ? _b : "";
        return message;
    },
};
class InjectiveMegavaultRPCClientImpl {
    constructor(rpc) {
        this.rpc = rpc;
        this.GetVault = this.GetVault.bind(this);
        this.GetUser = this.GetUser.bind(this);
        this.ListSubscriptions = this.ListSubscriptions.bind(this);
        this.ListRedemptions = this.ListRedemptions.bind(this);
        this.GetOperatorRedemptionBuckets = this.GetOperatorRedemptionBuckets.bind(this);
        this.TvlHistory = this.TvlHistory.bind(this);
        this.PnlHistory = this.PnlHistory.bind(this);
    }
    GetVault(request, metadata) {
        return this.rpc.unary(exports.InjectiveMegavaultRPCGetVaultDesc, exports.GetVaultRequest.fromPartial(request), metadata);
    }
    GetUser(request, metadata) {
        return this.rpc.unary(exports.InjectiveMegavaultRPCGetUserDesc, exports.GetUserRequest.fromPartial(request), metadata);
    }
    ListSubscriptions(request, metadata) {
        return this.rpc.unary(exports.InjectiveMegavaultRPCListSubscriptionsDesc, exports.ListSubscriptionsRequest.fromPartial(request), metadata);
    }
    ListRedemptions(request, metadata) {
        return this.rpc.unary(exports.InjectiveMegavaultRPCListRedemptionsDesc, exports.ListRedemptionsRequest.fromPartial(request), metadata);
    }
    GetOperatorRedemptionBuckets(request, metadata) {
        return this.rpc.unary(exports.InjectiveMegavaultRPCGetOperatorRedemptionBucketsDesc, exports.GetOperatorRedemptionBucketsRequest.fromPartial(request), metadata);
    }
    TvlHistory(request, metadata) {
        return this.rpc.unary(exports.InjectiveMegavaultRPCTvlHistoryDesc, exports.TvlHistoryRequest.fromPartial(request), metadata);
    }
    PnlHistory(request, metadata) {
        return this.rpc.unary(exports.InjectiveMegavaultRPCPnlHistoryDesc, exports.PnlHistoryRequest.fromPartial(request), metadata);
    }
}
exports.InjectiveMegavaultRPCClientImpl = InjectiveMegavaultRPCClientImpl;
exports.InjectiveMegavaultRPCDesc = { serviceName: "injective_megavault_rpc.InjectiveMegavaultRPC" };
exports.InjectiveMegavaultRPCGetVaultDesc = {
    methodName: "GetVault",
    service: exports.InjectiveMegavaultRPCDesc,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return exports.GetVaultRequest.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = exports.GetVaultResponse.decode(data);
            return Object.assign(Object.assign({}, value), { toObject() {
                    return value;
                } });
        },
    },
};
exports.InjectiveMegavaultRPCGetUserDesc = {
    methodName: "GetUser",
    service: exports.InjectiveMegavaultRPCDesc,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return exports.GetUserRequest.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = exports.GetUserResponse.decode(data);
            return Object.assign(Object.assign({}, value), { toObject() {
                    return value;
                } });
        },
    },
};
exports.InjectiveMegavaultRPCListSubscriptionsDesc = {
    methodName: "ListSubscriptions",
    service: exports.InjectiveMegavaultRPCDesc,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return exports.ListSubscriptionsRequest.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = exports.ListSubscriptionsResponse.decode(data);
            return Object.assign(Object.assign({}, value), { toObject() {
                    return value;
                } });
        },
    },
};
exports.InjectiveMegavaultRPCListRedemptionsDesc = {
    methodName: "ListRedemptions",
    service: exports.InjectiveMegavaultRPCDesc,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return exports.ListRedemptionsRequest.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = exports.ListRedemptionsResponse.decode(data);
            return Object.assign(Object.assign({}, value), { toObject() {
                    return value;
                } });
        },
    },
};
exports.InjectiveMegavaultRPCGetOperatorRedemptionBucketsDesc = {
    methodName: "GetOperatorRedemptionBuckets",
    service: exports.InjectiveMegavaultRPCDesc,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return exports.GetOperatorRedemptionBucketsRequest.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = exports.GetOperatorRedemptionBucketsResponse.decode(data);
            return Object.assign(Object.assign({}, value), { toObject() {
                    return value;
                } });
        },
    },
};
exports.InjectiveMegavaultRPCTvlHistoryDesc = {
    methodName: "TvlHistory",
    service: exports.InjectiveMegavaultRPCDesc,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return exports.TvlHistoryRequest.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = exports.TvlHistoryResponse.decode(data);
            return Object.assign(Object.assign({}, value), { toObject() {
                    return value;
                } });
        },
    },
};
exports.InjectiveMegavaultRPCPnlHistoryDesc = {
    methodName: "PnlHistory",
    service: exports.InjectiveMegavaultRPCDesc,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return exports.PnlHistoryRequest.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = exports.PnlHistoryResponse.decode(data);
            return Object.assign(Object.assign({}, value), { toObject() {
                    return value;
                } });
        },
    },
};
class GrpcWebImpl {
    constructor(host, options) {
        this.host = host;
        this.options = options;
    }
    unary(methodDesc, _request, metadata) {
        var _a;
        const request = Object.assign(Object.assign({}, _request), methodDesc.requestType);
        const maybeCombinedMetadata = metadata && this.options.metadata
            ? new browser_headers_1.BrowserHeaders(Object.assign(Object.assign({}, (_a = this.options) === null || _a === void 0 ? void 0 : _a.metadata.headersMap), metadata === null || metadata === void 0 ? void 0 : metadata.headersMap))
            : metadata || this.options.metadata;
        return new Promise((resolve, reject) => {
            grpc_web_1.grpc.unary(methodDesc, {
                request,
                host: this.host,
                metadata: maybeCombinedMetadata,
                transport: this.options.transport,
                debug: this.options.debug,
                onEnd: function (response) {
                    if (response.status === grpc_web_1.grpc.Code.OK) {
                        resolve(response.message.toObject());
                    }
                    else {
                        const err = new GrpcWebError(response.statusMessage, response.status, response.trailers);
                        reject(err);
                    }
                },
            });
        });
    }
}
exports.GrpcWebImpl = GrpcWebImpl;
var tsProtoGlobalThis = (() => {
    if (typeof globalThis !== "undefined") {
        return globalThis;
    }
    if (typeof self !== "undefined") {
        return self;
    }
    if (typeof window !== "undefined") {
        return window;
    }
    if (typeof global !== "undefined") {
        return global;
    }
    throw "Unable to locate global object";
})();
function longToString(long) {
    return long.toString();
}
if (minimal_js_1.default.util.Long !== long_1.default) {
    minimal_js_1.default.util.Long = long_1.default;
    minimal_js_1.default.configure();
}
function isSet(value) {
    return value !== null && value !== undefined;
}
class GrpcWebError extends tsProtoGlobalThis.Error {
    constructor(message, code, metadata) {
        super(message);
        this.code = code;
        this.metadata = metadata;
    }
}
exports.GrpcWebError = GrpcWebError;
