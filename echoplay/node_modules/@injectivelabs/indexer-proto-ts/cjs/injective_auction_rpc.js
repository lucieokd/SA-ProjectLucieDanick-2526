"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GrpcWebError = exports.GrpcWebImpl = exports.InjectiveAuctionRPCAuctionsStatsDesc = exports.InjectiveAuctionRPCInjBurntEndpointDesc = exports.InjectiveAuctionRPCStreamBidsDesc = exports.InjectiveAuctionRPCAccountAuctionsV2Desc = exports.InjectiveAuctionRPCAuctionV2Desc = exports.InjectiveAuctionRPCAuctionsHistoryV2Desc = exports.InjectiveAuctionRPCAuctionsDesc = exports.InjectiveAuctionRPCAuctionEndpointDesc = exports.InjectiveAuctionRPCDesc = exports.InjectiveAuctionRPCClientImpl = exports.AuctionsStatsResponse = exports.AuctionsStatsRequest = exports.InjBurntEndpointResponse = exports.InjBurntEndpointRequest = exports.StreamBidsResponse = exports.StreamBidsRequest = exports.AccountAuctionV2 = exports.AccountAuctionsV2Response = exports.AccountAuctionsV2Request = exports.AuctionV2Response = exports.AuctionV2Request = exports.CoinPrices_PricesEntry = exports.CoinPrices = exports.AuctionV2Result = exports.AuctionsHistoryV2Response = exports.AuctionsHistoryV2Request = exports.AuctionsResponse = exports.AuctionsRequest = exports.Bid = exports.AuctionContract = exports.Coin = exports.Auction = exports.AuctionEndpointResponse = exports.AuctionEndpointRequest = exports.protobufPackage = void 0;
/* eslint-disable */
const grpc_web_1 = require("@injectivelabs/grpc-web");
const browser_headers_1 = require("browser-headers");
const long_1 = __importDefault(require("long"));
const minimal_js_1 = __importDefault(require("protobufjs/minimal.js"));
const rxjs_1 = require("rxjs");
const operators_1 = require("rxjs/operators");
exports.protobufPackage = "injective_auction_rpc";
function createBaseAuctionEndpointRequest() {
    return { round: "0" };
}
exports.AuctionEndpointRequest = {
    encode(message, writer = minimal_js_1.default.Writer.create()) {
        if (message.round !== "0") {
            writer.uint32(8).sint64(message.round);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_js_1.default.Reader ? input : new minimal_js_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAuctionEndpointRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.round = longToString(reader.sint64());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return { round: isSet(object.round) ? String(object.round) : "0" };
    },
    toJSON(message) {
        const obj = {};
        message.round !== undefined && (obj.round = message.round);
        return obj;
    },
    create(base) {
        return exports.AuctionEndpointRequest.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a;
        const message = createBaseAuctionEndpointRequest();
        message.round = (_a = object.round) !== null && _a !== void 0 ? _a : "0";
        return message;
    },
};
function createBaseAuctionEndpointResponse() {
    return { auction: undefined, bids: [] };
}
exports.AuctionEndpointResponse = {
    encode(message, writer = minimal_js_1.default.Writer.create()) {
        if (message.auction !== undefined) {
            exports.Auction.encode(message.auction, writer.uint32(10).fork()).ldelim();
        }
        for (const v of message.bids) {
            exports.Bid.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_js_1.default.Reader ? input : new minimal_js_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAuctionEndpointResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.auction = exports.Auction.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.bids.push(exports.Bid.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            auction: isSet(object.auction) ? exports.Auction.fromJSON(object.auction) : undefined,
            bids: Array.isArray(object === null || object === void 0 ? void 0 : object.bids) ? object.bids.map((e) => exports.Bid.fromJSON(e)) : [],
        };
    },
    toJSON(message) {
        const obj = {};
        message.auction !== undefined && (obj.auction = message.auction ? exports.Auction.toJSON(message.auction) : undefined);
        if (message.bids) {
            obj.bids = message.bids.map((e) => e ? exports.Bid.toJSON(e) : undefined);
        }
        else {
            obj.bids = [];
        }
        return obj;
    },
    create(base) {
        return exports.AuctionEndpointResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a;
        const message = createBaseAuctionEndpointResponse();
        message.auction = (object.auction !== undefined && object.auction !== null)
            ? exports.Auction.fromPartial(object.auction)
            : undefined;
        message.bids = ((_a = object.bids) === null || _a === void 0 ? void 0 : _a.map((e) => exports.Bid.fromPartial(e))) || [];
        return message;
    },
};
function createBaseAuction() {
    return {
        winner: "",
        basket: [],
        winningBidAmount: "",
        round: "0",
        endTimestamp: "0",
        updatedAt: "0",
        contract: undefined,
    };
}
exports.Auction = {
    encode(message, writer = minimal_js_1.default.Writer.create()) {
        if (message.winner !== "") {
            writer.uint32(10).string(message.winner);
        }
        for (const v of message.basket) {
            exports.Coin.encode(v, writer.uint32(18).fork()).ldelim();
        }
        if (message.winningBidAmount !== "") {
            writer.uint32(26).string(message.winningBidAmount);
        }
        if (message.round !== "0") {
            writer.uint32(32).uint64(message.round);
        }
        if (message.endTimestamp !== "0") {
            writer.uint32(40).sint64(message.endTimestamp);
        }
        if (message.updatedAt !== "0") {
            writer.uint32(48).sint64(message.updatedAt);
        }
        if (message.contract !== undefined) {
            exports.AuctionContract.encode(message.contract, writer.uint32(58).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_js_1.default.Reader ? input : new minimal_js_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAuction();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.winner = reader.string();
                    break;
                case 2:
                    message.basket.push(exports.Coin.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.winningBidAmount = reader.string();
                    break;
                case 4:
                    message.round = longToString(reader.uint64());
                    break;
                case 5:
                    message.endTimestamp = longToString(reader.sint64());
                    break;
                case 6:
                    message.updatedAt = longToString(reader.sint64());
                    break;
                case 7:
                    message.contract = exports.AuctionContract.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            winner: isSet(object.winner) ? String(object.winner) : "",
            basket: Array.isArray(object === null || object === void 0 ? void 0 : object.basket) ? object.basket.map((e) => exports.Coin.fromJSON(e)) : [],
            winningBidAmount: isSet(object.winningBidAmount) ? String(object.winningBidAmount) : "",
            round: isSet(object.round) ? String(object.round) : "0",
            endTimestamp: isSet(object.endTimestamp) ? String(object.endTimestamp) : "0",
            updatedAt: isSet(object.updatedAt) ? String(object.updatedAt) : "0",
            contract: isSet(object.contract) ? exports.AuctionContract.fromJSON(object.contract) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.winner !== undefined && (obj.winner = message.winner);
        if (message.basket) {
            obj.basket = message.basket.map((e) => e ? exports.Coin.toJSON(e) : undefined);
        }
        else {
            obj.basket = [];
        }
        message.winningBidAmount !== undefined && (obj.winningBidAmount = message.winningBidAmount);
        message.round !== undefined && (obj.round = message.round);
        message.endTimestamp !== undefined && (obj.endTimestamp = message.endTimestamp);
        message.updatedAt !== undefined && (obj.updatedAt = message.updatedAt);
        message.contract !== undefined &&
            (obj.contract = message.contract ? exports.AuctionContract.toJSON(message.contract) : undefined);
        return obj;
    },
    create(base) {
        return exports.Auction.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e, _f;
        const message = createBaseAuction();
        message.winner = (_a = object.winner) !== null && _a !== void 0 ? _a : "";
        message.basket = ((_b = object.basket) === null || _b === void 0 ? void 0 : _b.map((e) => exports.Coin.fromPartial(e))) || [];
        message.winningBidAmount = (_c = object.winningBidAmount) !== null && _c !== void 0 ? _c : "";
        message.round = (_d = object.round) !== null && _d !== void 0 ? _d : "0";
        message.endTimestamp = (_e = object.endTimestamp) !== null && _e !== void 0 ? _e : "0";
        message.updatedAt = (_f = object.updatedAt) !== null && _f !== void 0 ? _f : "0";
        message.contract = (object.contract !== undefined && object.contract !== null)
            ? exports.AuctionContract.fromPartial(object.contract)
            : undefined;
        return message;
    },
};
function createBaseCoin() {
    return { denom: "", amount: "", usdValue: "" };
}
exports.Coin = {
    encode(message, writer = minimal_js_1.default.Writer.create()) {
        if (message.denom !== "") {
            writer.uint32(10).string(message.denom);
        }
        if (message.amount !== "") {
            writer.uint32(18).string(message.amount);
        }
        if (message.usdValue !== "") {
            writer.uint32(26).string(message.usdValue);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_js_1.default.Reader ? input : new minimal_js_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCoin();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.denom = reader.string();
                    break;
                case 2:
                    message.amount = reader.string();
                    break;
                case 3:
                    message.usdValue = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            denom: isSet(object.denom) ? String(object.denom) : "",
            amount: isSet(object.amount) ? String(object.amount) : "",
            usdValue: isSet(object.usdValue) ? String(object.usdValue) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.denom !== undefined && (obj.denom = message.denom);
        message.amount !== undefined && (obj.amount = message.amount);
        message.usdValue !== undefined && (obj.usdValue = message.usdValue);
        return obj;
    },
    create(base) {
        return exports.Coin.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseCoin();
        message.denom = (_a = object.denom) !== null && _a !== void 0 ? _a : "";
        message.amount = (_b = object.amount) !== null && _b !== void 0 ? _b : "";
        message.usdValue = (_c = object.usdValue) !== null && _c !== void 0 ? _c : "";
        return message;
    },
};
function createBaseAuctionContract() {
    return {
        id: "0",
        bidTarget: "",
        currentSlots: "0",
        totalSlots: "0",
        maxUserAllocation: "",
        totalCommitted: "",
        whitelistAddresses: [],
        startTimestamp: "0",
        endTimestamp: "0",
        maxRoundAllocation: "",
    };
}
exports.AuctionContract = {
    encode(message, writer = minimal_js_1.default.Writer.create()) {
        if (message.id !== "0") {
            writer.uint32(8).uint64(message.id);
        }
        if (message.bidTarget !== "") {
            writer.uint32(18).string(message.bidTarget);
        }
        if (message.currentSlots !== "0") {
            writer.uint32(24).uint64(message.currentSlots);
        }
        if (message.totalSlots !== "0") {
            writer.uint32(32).uint64(message.totalSlots);
        }
        if (message.maxUserAllocation !== "") {
            writer.uint32(42).string(message.maxUserAllocation);
        }
        if (message.totalCommitted !== "") {
            writer.uint32(50).string(message.totalCommitted);
        }
        for (const v of message.whitelistAddresses) {
            writer.uint32(58).string(v);
        }
        if (message.startTimestamp !== "0") {
            writer.uint32(64).uint64(message.startTimestamp);
        }
        if (message.endTimestamp !== "0") {
            writer.uint32(72).uint64(message.endTimestamp);
        }
        if (message.maxRoundAllocation !== "") {
            writer.uint32(82).string(message.maxRoundAllocation);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_js_1.default.Reader ? input : new minimal_js_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAuctionContract();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.id = longToString(reader.uint64());
                    break;
                case 2:
                    message.bidTarget = reader.string();
                    break;
                case 3:
                    message.currentSlots = longToString(reader.uint64());
                    break;
                case 4:
                    message.totalSlots = longToString(reader.uint64());
                    break;
                case 5:
                    message.maxUserAllocation = reader.string();
                    break;
                case 6:
                    message.totalCommitted = reader.string();
                    break;
                case 7:
                    message.whitelistAddresses.push(reader.string());
                    break;
                case 8:
                    message.startTimestamp = longToString(reader.uint64());
                    break;
                case 9:
                    message.endTimestamp = longToString(reader.uint64());
                    break;
                case 10:
                    message.maxRoundAllocation = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            id: isSet(object.id) ? String(object.id) : "0",
            bidTarget: isSet(object.bidTarget) ? String(object.bidTarget) : "",
            currentSlots: isSet(object.currentSlots) ? String(object.currentSlots) : "0",
            totalSlots: isSet(object.totalSlots) ? String(object.totalSlots) : "0",
            maxUserAllocation: isSet(object.maxUserAllocation) ? String(object.maxUserAllocation) : "",
            totalCommitted: isSet(object.totalCommitted) ? String(object.totalCommitted) : "",
            whitelistAddresses: Array.isArray(object === null || object === void 0 ? void 0 : object.whitelistAddresses)
                ? object.whitelistAddresses.map((e) => String(e))
                : [],
            startTimestamp: isSet(object.startTimestamp) ? String(object.startTimestamp) : "0",
            endTimestamp: isSet(object.endTimestamp) ? String(object.endTimestamp) : "0",
            maxRoundAllocation: isSet(object.maxRoundAllocation) ? String(object.maxRoundAllocation) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.id !== undefined && (obj.id = message.id);
        message.bidTarget !== undefined && (obj.bidTarget = message.bidTarget);
        message.currentSlots !== undefined && (obj.currentSlots = message.currentSlots);
        message.totalSlots !== undefined && (obj.totalSlots = message.totalSlots);
        message.maxUserAllocation !== undefined && (obj.maxUserAllocation = message.maxUserAllocation);
        message.totalCommitted !== undefined && (obj.totalCommitted = message.totalCommitted);
        if (message.whitelistAddresses) {
            obj.whitelistAddresses = message.whitelistAddresses.map((e) => e);
        }
        else {
            obj.whitelistAddresses = [];
        }
        message.startTimestamp !== undefined && (obj.startTimestamp = message.startTimestamp);
        message.endTimestamp !== undefined && (obj.endTimestamp = message.endTimestamp);
        message.maxRoundAllocation !== undefined && (obj.maxRoundAllocation = message.maxRoundAllocation);
        return obj;
    },
    create(base) {
        return exports.AuctionContract.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        const message = createBaseAuctionContract();
        message.id = (_a = object.id) !== null && _a !== void 0 ? _a : "0";
        message.bidTarget = (_b = object.bidTarget) !== null && _b !== void 0 ? _b : "";
        message.currentSlots = (_c = object.currentSlots) !== null && _c !== void 0 ? _c : "0";
        message.totalSlots = (_d = object.totalSlots) !== null && _d !== void 0 ? _d : "0";
        message.maxUserAllocation = (_e = object.maxUserAllocation) !== null && _e !== void 0 ? _e : "";
        message.totalCommitted = (_f = object.totalCommitted) !== null && _f !== void 0 ? _f : "";
        message.whitelistAddresses = ((_g = object.whitelistAddresses) === null || _g === void 0 ? void 0 : _g.map((e) => e)) || [];
        message.startTimestamp = (_h = object.startTimestamp) !== null && _h !== void 0 ? _h : "0";
        message.endTimestamp = (_j = object.endTimestamp) !== null && _j !== void 0 ? _j : "0";
        message.maxRoundAllocation = (_k = object.maxRoundAllocation) !== null && _k !== void 0 ? _k : "";
        return message;
    },
};
function createBaseBid() {
    return { bidder: "", amount: "", timestamp: "0" };
}
exports.Bid = {
    encode(message, writer = minimal_js_1.default.Writer.create()) {
        if (message.bidder !== "") {
            writer.uint32(10).string(message.bidder);
        }
        if (message.amount !== "") {
            writer.uint32(18).string(message.amount);
        }
        if (message.timestamp !== "0") {
            writer.uint32(24).sint64(message.timestamp);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_js_1.default.Reader ? input : new minimal_js_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBid();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.bidder = reader.string();
                    break;
                case 2:
                    message.amount = reader.string();
                    break;
                case 3:
                    message.timestamp = longToString(reader.sint64());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            bidder: isSet(object.bidder) ? String(object.bidder) : "",
            amount: isSet(object.amount) ? String(object.amount) : "",
            timestamp: isSet(object.timestamp) ? String(object.timestamp) : "0",
        };
    },
    toJSON(message) {
        const obj = {};
        message.bidder !== undefined && (obj.bidder = message.bidder);
        message.amount !== undefined && (obj.amount = message.amount);
        message.timestamp !== undefined && (obj.timestamp = message.timestamp);
        return obj;
    },
    create(base) {
        return exports.Bid.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseBid();
        message.bidder = (_a = object.bidder) !== null && _a !== void 0 ? _a : "";
        message.amount = (_b = object.amount) !== null && _b !== void 0 ? _b : "";
        message.timestamp = (_c = object.timestamp) !== null && _c !== void 0 ? _c : "0";
        return message;
    },
};
function createBaseAuctionsRequest() {
    return {};
}
exports.AuctionsRequest = {
    encode(_, writer = minimal_js_1.default.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_js_1.default.Reader ? input : new minimal_js_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAuctionsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return exports.AuctionsRequest.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(_) {
        const message = createBaseAuctionsRequest();
        return message;
    },
};
function createBaseAuctionsResponse() {
    return { auctions: [] };
}
exports.AuctionsResponse = {
    encode(message, writer = minimal_js_1.default.Writer.create()) {
        for (const v of message.auctions) {
            exports.Auction.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_js_1.default.Reader ? input : new minimal_js_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAuctionsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.auctions.push(exports.Auction.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return { auctions: Array.isArray(object === null || object === void 0 ? void 0 : object.auctions) ? object.auctions.map((e) => exports.Auction.fromJSON(e)) : [] };
    },
    toJSON(message) {
        const obj = {};
        if (message.auctions) {
            obj.auctions = message.auctions.map((e) => e ? exports.Auction.toJSON(e) : undefined);
        }
        else {
            obj.auctions = [];
        }
        return obj;
    },
    create(base) {
        return exports.AuctionsResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a;
        const message = createBaseAuctionsResponse();
        message.auctions = ((_a = object.auctions) === null || _a === void 0 ? void 0 : _a.map((e) => exports.Auction.fromPartial(e))) || [];
        return message;
    },
};
function createBaseAuctionsHistoryV2Request() {
    return { perPage: 0, token: "", endTime: "0" };
}
exports.AuctionsHistoryV2Request = {
    encode(message, writer = minimal_js_1.default.Writer.create()) {
        if (message.perPage !== 0) {
            writer.uint32(8).sint32(message.perPage);
        }
        if (message.token !== "") {
            writer.uint32(18).string(message.token);
        }
        if (message.endTime !== "0") {
            writer.uint32(24).sint64(message.endTime);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_js_1.default.Reader ? input : new minimal_js_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAuctionsHistoryV2Request();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.perPage = reader.sint32();
                    break;
                case 2:
                    message.token = reader.string();
                    break;
                case 3:
                    message.endTime = longToString(reader.sint64());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            perPage: isSet(object.perPage) ? Number(object.perPage) : 0,
            token: isSet(object.token) ? String(object.token) : "",
            endTime: isSet(object.endTime) ? String(object.endTime) : "0",
        };
    },
    toJSON(message) {
        const obj = {};
        message.perPage !== undefined && (obj.perPage = Math.round(message.perPage));
        message.token !== undefined && (obj.token = message.token);
        message.endTime !== undefined && (obj.endTime = message.endTime);
        return obj;
    },
    create(base) {
        return exports.AuctionsHistoryV2Request.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseAuctionsHistoryV2Request();
        message.perPage = (_a = object.perPage) !== null && _a !== void 0 ? _a : 0;
        message.token = (_b = object.token) !== null && _b !== void 0 ? _b : "";
        message.endTime = (_c = object.endTime) !== null && _c !== void 0 ? _c : "0";
        return message;
    },
};
function createBaseAuctionsHistoryV2Response() {
    return { auctions: [], next: [] };
}
exports.AuctionsHistoryV2Response = {
    encode(message, writer = minimal_js_1.default.Writer.create()) {
        for (const v of message.auctions) {
            exports.AuctionV2Result.encode(v, writer.uint32(10).fork()).ldelim();
        }
        for (const v of message.next) {
            writer.uint32(18).string(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_js_1.default.Reader ? input : new minimal_js_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAuctionsHistoryV2Response();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.auctions.push(exports.AuctionV2Result.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.next.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            auctions: Array.isArray(object === null || object === void 0 ? void 0 : object.auctions) ? object.auctions.map((e) => exports.AuctionV2Result.fromJSON(e)) : [],
            next: Array.isArray(object === null || object === void 0 ? void 0 : object.next) ? object.next.map((e) => String(e)) : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.auctions) {
            obj.auctions = message.auctions.map((e) => e ? exports.AuctionV2Result.toJSON(e) : undefined);
        }
        else {
            obj.auctions = [];
        }
        if (message.next) {
            obj.next = message.next.map((e) => e);
        }
        else {
            obj.next = [];
        }
        return obj;
    },
    create(base) {
        return exports.AuctionsHistoryV2Response.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseAuctionsHistoryV2Response();
        message.auctions = ((_a = object.auctions) === null || _a === void 0 ? void 0 : _a.map((e) => exports.AuctionV2Result.fromPartial(e))) || [];
        message.next = ((_b = object.next) === null || _b === void 0 ? void 0 : _b.map((e) => e)) || [];
        return message;
    },
};
function createBaseAuctionV2Result() {
    return {
        winner: "",
        basket: [],
        winningBidAmount: "",
        round: "0",
        endTimestamp: "0",
        updatedAt: "0",
        contract: undefined,
        winningBidAmountUsd: "",
    };
}
exports.AuctionV2Result = {
    encode(message, writer = minimal_js_1.default.Writer.create()) {
        if (message.winner !== "") {
            writer.uint32(10).string(message.winner);
        }
        for (const v of message.basket) {
            exports.CoinPrices.encode(v, writer.uint32(18).fork()).ldelim();
        }
        if (message.winningBidAmount !== "") {
            writer.uint32(26).string(message.winningBidAmount);
        }
        if (message.round !== "0") {
            writer.uint32(32).uint64(message.round);
        }
        if (message.endTimestamp !== "0") {
            writer.uint32(40).sint64(message.endTimestamp);
        }
        if (message.updatedAt !== "0") {
            writer.uint32(48).sint64(message.updatedAt);
        }
        if (message.contract !== undefined) {
            exports.AuctionContract.encode(message.contract, writer.uint32(58).fork()).ldelim();
        }
        if (message.winningBidAmountUsd !== "") {
            writer.uint32(66).string(message.winningBidAmountUsd);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_js_1.default.Reader ? input : new minimal_js_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAuctionV2Result();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.winner = reader.string();
                    break;
                case 2:
                    message.basket.push(exports.CoinPrices.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.winningBidAmount = reader.string();
                    break;
                case 4:
                    message.round = longToString(reader.uint64());
                    break;
                case 5:
                    message.endTimestamp = longToString(reader.sint64());
                    break;
                case 6:
                    message.updatedAt = longToString(reader.sint64());
                    break;
                case 7:
                    message.contract = exports.AuctionContract.decode(reader, reader.uint32());
                    break;
                case 8:
                    message.winningBidAmountUsd = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            winner: isSet(object.winner) ? String(object.winner) : "",
            basket: Array.isArray(object === null || object === void 0 ? void 0 : object.basket) ? object.basket.map((e) => exports.CoinPrices.fromJSON(e)) : [],
            winningBidAmount: isSet(object.winningBidAmount) ? String(object.winningBidAmount) : "",
            round: isSet(object.round) ? String(object.round) : "0",
            endTimestamp: isSet(object.endTimestamp) ? String(object.endTimestamp) : "0",
            updatedAt: isSet(object.updatedAt) ? String(object.updatedAt) : "0",
            contract: isSet(object.contract) ? exports.AuctionContract.fromJSON(object.contract) : undefined,
            winningBidAmountUsd: isSet(object.winningBidAmountUsd) ? String(object.winningBidAmountUsd) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.winner !== undefined && (obj.winner = message.winner);
        if (message.basket) {
            obj.basket = message.basket.map((e) => e ? exports.CoinPrices.toJSON(e) : undefined);
        }
        else {
            obj.basket = [];
        }
        message.winningBidAmount !== undefined && (obj.winningBidAmount = message.winningBidAmount);
        message.round !== undefined && (obj.round = message.round);
        message.endTimestamp !== undefined && (obj.endTimestamp = message.endTimestamp);
        message.updatedAt !== undefined && (obj.updatedAt = message.updatedAt);
        message.contract !== undefined &&
            (obj.contract = message.contract ? exports.AuctionContract.toJSON(message.contract) : undefined);
        message.winningBidAmountUsd !== undefined && (obj.winningBidAmountUsd = message.winningBidAmountUsd);
        return obj;
    },
    create(base) {
        return exports.AuctionV2Result.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e, _f, _g;
        const message = createBaseAuctionV2Result();
        message.winner = (_a = object.winner) !== null && _a !== void 0 ? _a : "";
        message.basket = ((_b = object.basket) === null || _b === void 0 ? void 0 : _b.map((e) => exports.CoinPrices.fromPartial(e))) || [];
        message.winningBidAmount = (_c = object.winningBidAmount) !== null && _c !== void 0 ? _c : "";
        message.round = (_d = object.round) !== null && _d !== void 0 ? _d : "0";
        message.endTimestamp = (_e = object.endTimestamp) !== null && _e !== void 0 ? _e : "0";
        message.updatedAt = (_f = object.updatedAt) !== null && _f !== void 0 ? _f : "0";
        message.contract = (object.contract !== undefined && object.contract !== null)
            ? exports.AuctionContract.fromPartial(object.contract)
            : undefined;
        message.winningBidAmountUsd = (_g = object.winningBidAmountUsd) !== null && _g !== void 0 ? _g : "";
        return message;
    },
};
function createBaseCoinPrices() {
    return { denom: "", amount: "", prices: {} };
}
exports.CoinPrices = {
    encode(message, writer = minimal_js_1.default.Writer.create()) {
        if (message.denom !== "") {
            writer.uint32(10).string(message.denom);
        }
        if (message.amount !== "") {
            writer.uint32(18).string(message.amount);
        }
        Object.entries(message.prices).forEach(([key, value]) => {
            exports.CoinPrices_PricesEntry.encode({ key: key, value }, writer.uint32(26).fork()).ldelim();
        });
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_js_1.default.Reader ? input : new minimal_js_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCoinPrices();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.denom = reader.string();
                    break;
                case 2:
                    message.amount = reader.string();
                    break;
                case 3:
                    const entry3 = exports.CoinPrices_PricesEntry.decode(reader, reader.uint32());
                    if (entry3.value !== undefined) {
                        message.prices[entry3.key] = entry3.value;
                    }
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            denom: isSet(object.denom) ? String(object.denom) : "",
            amount: isSet(object.amount) ? String(object.amount) : "",
            prices: isObject(object.prices)
                ? Object.entries(object.prices).reduce((acc, [key, value]) => {
                    acc[key] = String(value);
                    return acc;
                }, {})
                : {},
        };
    },
    toJSON(message) {
        const obj = {};
        message.denom !== undefined && (obj.denom = message.denom);
        message.amount !== undefined && (obj.amount = message.amount);
        obj.prices = {};
        if (message.prices) {
            Object.entries(message.prices).forEach(([k, v]) => {
                obj.prices[k] = v;
            });
        }
        return obj;
    },
    create(base) {
        return exports.CoinPrices.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseCoinPrices();
        message.denom = (_a = object.denom) !== null && _a !== void 0 ? _a : "";
        message.amount = (_b = object.amount) !== null && _b !== void 0 ? _b : "";
        message.prices = Object.entries((_c = object.prices) !== null && _c !== void 0 ? _c : {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = String(value);
            }
            return acc;
        }, {});
        return message;
    },
};
function createBaseCoinPrices_PricesEntry() {
    return { key: "", value: "" };
}
exports.CoinPrices_PricesEntry = {
    encode(message, writer = minimal_js_1.default.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== "") {
            writer.uint32(18).string(message.value);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_js_1.default.Reader ? input : new minimal_js_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCoinPrices_PricesEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return { key: isSet(object.key) ? String(object.key) : "", value: isSet(object.value) ? String(object.value) : "" };
    },
    toJSON(message) {
        const obj = {};
        message.key !== undefined && (obj.key = message.key);
        message.value !== undefined && (obj.value = message.value);
        return obj;
    },
    create(base) {
        return exports.CoinPrices_PricesEntry.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseCoinPrices_PricesEntry();
        message.key = (_a = object.key) !== null && _a !== void 0 ? _a : "";
        message.value = (_b = object.value) !== null && _b !== void 0 ? _b : "";
        return message;
    },
};
function createBaseAuctionV2Request() {
    return { round: "0" };
}
exports.AuctionV2Request = {
    encode(message, writer = minimal_js_1.default.Writer.create()) {
        if (message.round !== "0") {
            writer.uint32(8).sint64(message.round);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_js_1.default.Reader ? input : new minimal_js_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAuctionV2Request();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.round = longToString(reader.sint64());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return { round: isSet(object.round) ? String(object.round) : "0" };
    },
    toJSON(message) {
        const obj = {};
        message.round !== undefined && (obj.round = message.round);
        return obj;
    },
    create(base) {
        return exports.AuctionV2Request.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a;
        const message = createBaseAuctionV2Request();
        message.round = (_a = object.round) !== null && _a !== void 0 ? _a : "0";
        return message;
    },
};
function createBaseAuctionV2Response() {
    return {
        winner: "",
        basket: [],
        winningBidAmount: "",
        round: "0",
        endTimestamp: "0",
        updatedAt: "0",
        contract: undefined,
        winningBidAmountUsd: "",
    };
}
exports.AuctionV2Response = {
    encode(message, writer = minimal_js_1.default.Writer.create()) {
        if (message.winner !== "") {
            writer.uint32(10).string(message.winner);
        }
        for (const v of message.basket) {
            exports.CoinPrices.encode(v, writer.uint32(18).fork()).ldelim();
        }
        if (message.winningBidAmount !== "") {
            writer.uint32(26).string(message.winningBidAmount);
        }
        if (message.round !== "0") {
            writer.uint32(32).uint64(message.round);
        }
        if (message.endTimestamp !== "0") {
            writer.uint32(40).sint64(message.endTimestamp);
        }
        if (message.updatedAt !== "0") {
            writer.uint32(48).sint64(message.updatedAt);
        }
        if (message.contract !== undefined) {
            exports.AuctionContract.encode(message.contract, writer.uint32(58).fork()).ldelim();
        }
        if (message.winningBidAmountUsd !== "") {
            writer.uint32(66).string(message.winningBidAmountUsd);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_js_1.default.Reader ? input : new minimal_js_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAuctionV2Response();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.winner = reader.string();
                    break;
                case 2:
                    message.basket.push(exports.CoinPrices.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.winningBidAmount = reader.string();
                    break;
                case 4:
                    message.round = longToString(reader.uint64());
                    break;
                case 5:
                    message.endTimestamp = longToString(reader.sint64());
                    break;
                case 6:
                    message.updatedAt = longToString(reader.sint64());
                    break;
                case 7:
                    message.contract = exports.AuctionContract.decode(reader, reader.uint32());
                    break;
                case 8:
                    message.winningBidAmountUsd = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            winner: isSet(object.winner) ? String(object.winner) : "",
            basket: Array.isArray(object === null || object === void 0 ? void 0 : object.basket) ? object.basket.map((e) => exports.CoinPrices.fromJSON(e)) : [],
            winningBidAmount: isSet(object.winningBidAmount) ? String(object.winningBidAmount) : "",
            round: isSet(object.round) ? String(object.round) : "0",
            endTimestamp: isSet(object.endTimestamp) ? String(object.endTimestamp) : "0",
            updatedAt: isSet(object.updatedAt) ? String(object.updatedAt) : "0",
            contract: isSet(object.contract) ? exports.AuctionContract.fromJSON(object.contract) : undefined,
            winningBidAmountUsd: isSet(object.winningBidAmountUsd) ? String(object.winningBidAmountUsd) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.winner !== undefined && (obj.winner = message.winner);
        if (message.basket) {
            obj.basket = message.basket.map((e) => e ? exports.CoinPrices.toJSON(e) : undefined);
        }
        else {
            obj.basket = [];
        }
        message.winningBidAmount !== undefined && (obj.winningBidAmount = message.winningBidAmount);
        message.round !== undefined && (obj.round = message.round);
        message.endTimestamp !== undefined && (obj.endTimestamp = message.endTimestamp);
        message.updatedAt !== undefined && (obj.updatedAt = message.updatedAt);
        message.contract !== undefined &&
            (obj.contract = message.contract ? exports.AuctionContract.toJSON(message.contract) : undefined);
        message.winningBidAmountUsd !== undefined && (obj.winningBidAmountUsd = message.winningBidAmountUsd);
        return obj;
    },
    create(base) {
        return exports.AuctionV2Response.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e, _f, _g;
        const message = createBaseAuctionV2Response();
        message.winner = (_a = object.winner) !== null && _a !== void 0 ? _a : "";
        message.basket = ((_b = object.basket) === null || _b === void 0 ? void 0 : _b.map((e) => exports.CoinPrices.fromPartial(e))) || [];
        message.winningBidAmount = (_c = object.winningBidAmount) !== null && _c !== void 0 ? _c : "";
        message.round = (_d = object.round) !== null && _d !== void 0 ? _d : "0";
        message.endTimestamp = (_e = object.endTimestamp) !== null && _e !== void 0 ? _e : "0";
        message.updatedAt = (_f = object.updatedAt) !== null && _f !== void 0 ? _f : "0";
        message.contract = (object.contract !== undefined && object.contract !== null)
            ? exports.AuctionContract.fromPartial(object.contract)
            : undefined;
        message.winningBidAmountUsd = (_g = object.winningBidAmountUsd) !== null && _g !== void 0 ? _g : "";
        return message;
    },
};
function createBaseAccountAuctionsV2Request() {
    return { address: "", perPage: 0, token: "" };
}
exports.AccountAuctionsV2Request = {
    encode(message, writer = minimal_js_1.default.Writer.create()) {
        if (message.address !== "") {
            writer.uint32(10).string(message.address);
        }
        if (message.perPage !== 0) {
            writer.uint32(16).sint32(message.perPage);
        }
        if (message.token !== "") {
            writer.uint32(26).string(message.token);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_js_1.default.Reader ? input : new minimal_js_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAccountAuctionsV2Request();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.address = reader.string();
                    break;
                case 2:
                    message.perPage = reader.sint32();
                    break;
                case 3:
                    message.token = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            address: isSet(object.address) ? String(object.address) : "",
            perPage: isSet(object.perPage) ? Number(object.perPage) : 0,
            token: isSet(object.token) ? String(object.token) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.address !== undefined && (obj.address = message.address);
        message.perPage !== undefined && (obj.perPage = Math.round(message.perPage));
        message.token !== undefined && (obj.token = message.token);
        return obj;
    },
    create(base) {
        return exports.AccountAuctionsV2Request.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseAccountAuctionsV2Request();
        message.address = (_a = object.address) !== null && _a !== void 0 ? _a : "";
        message.perPage = (_b = object.perPage) !== null && _b !== void 0 ? _b : 0;
        message.token = (_c = object.token) !== null && _c !== void 0 ? _c : "";
        return message;
    },
};
function createBaseAccountAuctionsV2Response() {
    return { auctions: [], next: [], total: "0" };
}
exports.AccountAuctionsV2Response = {
    encode(message, writer = minimal_js_1.default.Writer.create()) {
        for (const v of message.auctions) {
            exports.AccountAuctionV2.encode(v, writer.uint32(10).fork()).ldelim();
        }
        for (const v of message.next) {
            writer.uint32(18).string(v);
        }
        if (message.total !== "0") {
            writer.uint32(24).sint64(message.total);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_js_1.default.Reader ? input : new minimal_js_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAccountAuctionsV2Response();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.auctions.push(exports.AccountAuctionV2.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.next.push(reader.string());
                    break;
                case 3:
                    message.total = longToString(reader.sint64());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            auctions: Array.isArray(object === null || object === void 0 ? void 0 : object.auctions) ? object.auctions.map((e) => exports.AccountAuctionV2.fromJSON(e)) : [],
            next: Array.isArray(object === null || object === void 0 ? void 0 : object.next) ? object.next.map((e) => String(e)) : [],
            total: isSet(object.total) ? String(object.total) : "0",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.auctions) {
            obj.auctions = message.auctions.map((e) => e ? exports.AccountAuctionV2.toJSON(e) : undefined);
        }
        else {
            obj.auctions = [];
        }
        if (message.next) {
            obj.next = message.next.map((e) => e);
        }
        else {
            obj.next = [];
        }
        message.total !== undefined && (obj.total = message.total);
        return obj;
    },
    create(base) {
        return exports.AccountAuctionsV2Response.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseAccountAuctionsV2Response();
        message.auctions = ((_a = object.auctions) === null || _a === void 0 ? void 0 : _a.map((e) => exports.AccountAuctionV2.fromPartial(e))) || [];
        message.next = ((_b = object.next) === null || _b === void 0 ? void 0 : _b.map((e) => e)) || [];
        message.total = (_c = object.total) !== null && _c !== void 0 ? _c : "0";
        return message;
    },
};
function createBaseAccountAuctionV2() {
    return { id: "0", round: "0", amountDeposited: "", isClaimable: false, claimedAssets: [] };
}
exports.AccountAuctionV2 = {
    encode(message, writer = minimal_js_1.default.Writer.create()) {
        if (message.id !== "0") {
            writer.uint32(8).uint64(message.id);
        }
        if (message.round !== "0") {
            writer.uint32(16).uint64(message.round);
        }
        if (message.amountDeposited !== "") {
            writer.uint32(26).string(message.amountDeposited);
        }
        if (message.isClaimable === true) {
            writer.uint32(32).bool(message.isClaimable);
        }
        for (const v of message.claimedAssets) {
            exports.CoinPrices.encode(v, writer.uint32(42).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_js_1.default.Reader ? input : new minimal_js_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAccountAuctionV2();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.id = longToString(reader.uint64());
                    break;
                case 2:
                    message.round = longToString(reader.uint64());
                    break;
                case 3:
                    message.amountDeposited = reader.string();
                    break;
                case 4:
                    message.isClaimable = reader.bool();
                    break;
                case 5:
                    message.claimedAssets.push(exports.CoinPrices.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            id: isSet(object.id) ? String(object.id) : "0",
            round: isSet(object.round) ? String(object.round) : "0",
            amountDeposited: isSet(object.amountDeposited) ? String(object.amountDeposited) : "",
            isClaimable: isSet(object.isClaimable) ? Boolean(object.isClaimable) : false,
            claimedAssets: Array.isArray(object === null || object === void 0 ? void 0 : object.claimedAssets)
                ? object.claimedAssets.map((e) => exports.CoinPrices.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        message.id !== undefined && (obj.id = message.id);
        message.round !== undefined && (obj.round = message.round);
        message.amountDeposited !== undefined && (obj.amountDeposited = message.amountDeposited);
        message.isClaimable !== undefined && (obj.isClaimable = message.isClaimable);
        if (message.claimedAssets) {
            obj.claimedAssets = message.claimedAssets.map((e) => e ? exports.CoinPrices.toJSON(e) : undefined);
        }
        else {
            obj.claimedAssets = [];
        }
        return obj;
    },
    create(base) {
        return exports.AccountAuctionV2.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e;
        const message = createBaseAccountAuctionV2();
        message.id = (_a = object.id) !== null && _a !== void 0 ? _a : "0";
        message.round = (_b = object.round) !== null && _b !== void 0 ? _b : "0";
        message.amountDeposited = (_c = object.amountDeposited) !== null && _c !== void 0 ? _c : "";
        message.isClaimable = (_d = object.isClaimable) !== null && _d !== void 0 ? _d : false;
        message.claimedAssets = ((_e = object.claimedAssets) === null || _e === void 0 ? void 0 : _e.map((e) => exports.CoinPrices.fromPartial(e))) || [];
        return message;
    },
};
function createBaseStreamBidsRequest() {
    return {};
}
exports.StreamBidsRequest = {
    encode(_, writer = minimal_js_1.default.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_js_1.default.Reader ? input : new minimal_js_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseStreamBidsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return exports.StreamBidsRequest.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(_) {
        const message = createBaseStreamBidsRequest();
        return message;
    },
};
function createBaseStreamBidsResponse() {
    return { bidder: "", bidAmount: "", round: "0", timestamp: "0" };
}
exports.StreamBidsResponse = {
    encode(message, writer = minimal_js_1.default.Writer.create()) {
        if (message.bidder !== "") {
            writer.uint32(10).string(message.bidder);
        }
        if (message.bidAmount !== "") {
            writer.uint32(18).string(message.bidAmount);
        }
        if (message.round !== "0") {
            writer.uint32(24).uint64(message.round);
        }
        if (message.timestamp !== "0") {
            writer.uint32(32).sint64(message.timestamp);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_js_1.default.Reader ? input : new minimal_js_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseStreamBidsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.bidder = reader.string();
                    break;
                case 2:
                    message.bidAmount = reader.string();
                    break;
                case 3:
                    message.round = longToString(reader.uint64());
                    break;
                case 4:
                    message.timestamp = longToString(reader.sint64());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            bidder: isSet(object.bidder) ? String(object.bidder) : "",
            bidAmount: isSet(object.bidAmount) ? String(object.bidAmount) : "",
            round: isSet(object.round) ? String(object.round) : "0",
            timestamp: isSet(object.timestamp) ? String(object.timestamp) : "0",
        };
    },
    toJSON(message) {
        const obj = {};
        message.bidder !== undefined && (obj.bidder = message.bidder);
        message.bidAmount !== undefined && (obj.bidAmount = message.bidAmount);
        message.round !== undefined && (obj.round = message.round);
        message.timestamp !== undefined && (obj.timestamp = message.timestamp);
        return obj;
    },
    create(base) {
        return exports.StreamBidsResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c, _d;
        const message = createBaseStreamBidsResponse();
        message.bidder = (_a = object.bidder) !== null && _a !== void 0 ? _a : "";
        message.bidAmount = (_b = object.bidAmount) !== null && _b !== void 0 ? _b : "";
        message.round = (_c = object.round) !== null && _c !== void 0 ? _c : "0";
        message.timestamp = (_d = object.timestamp) !== null && _d !== void 0 ? _d : "0";
        return message;
    },
};
function createBaseInjBurntEndpointRequest() {
    return {};
}
exports.InjBurntEndpointRequest = {
    encode(_, writer = minimal_js_1.default.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_js_1.default.Reader ? input : new minimal_js_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseInjBurntEndpointRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return exports.InjBurntEndpointRequest.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(_) {
        const message = createBaseInjBurntEndpointRequest();
        return message;
    },
};
function createBaseInjBurntEndpointResponse() {
    return { totalInjBurnt: "" };
}
exports.InjBurntEndpointResponse = {
    encode(message, writer = minimal_js_1.default.Writer.create()) {
        if (message.totalInjBurnt !== "") {
            writer.uint32(10).string(message.totalInjBurnt);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_js_1.default.Reader ? input : new minimal_js_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseInjBurntEndpointResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.totalInjBurnt = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return { totalInjBurnt: isSet(object.totalInjBurnt) ? String(object.totalInjBurnt) : "" };
    },
    toJSON(message) {
        const obj = {};
        message.totalInjBurnt !== undefined && (obj.totalInjBurnt = message.totalInjBurnt);
        return obj;
    },
    create(base) {
        return exports.InjBurntEndpointResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a;
        const message = createBaseInjBurntEndpointResponse();
        message.totalInjBurnt = (_a = object.totalInjBurnt) !== null && _a !== void 0 ? _a : "";
        return message;
    },
};
function createBaseAuctionsStatsRequest() {
    return {};
}
exports.AuctionsStatsRequest = {
    encode(_, writer = minimal_js_1.default.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_js_1.default.Reader ? input : new minimal_js_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAuctionsStatsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return exports.AuctionsStatsRequest.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(_) {
        const message = createBaseAuctionsStatsRequest();
        return message;
    },
};
function createBaseAuctionsStatsResponse() {
    return { totalBurnt: "", totalUsdValue: "" };
}
exports.AuctionsStatsResponse = {
    encode(message, writer = minimal_js_1.default.Writer.create()) {
        if (message.totalBurnt !== "") {
            writer.uint32(10).string(message.totalBurnt);
        }
        if (message.totalUsdValue !== "") {
            writer.uint32(18).string(message.totalUsdValue);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_js_1.default.Reader ? input : new minimal_js_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAuctionsStatsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.totalBurnt = reader.string();
                    break;
                case 2:
                    message.totalUsdValue = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            totalBurnt: isSet(object.totalBurnt) ? String(object.totalBurnt) : "",
            totalUsdValue: isSet(object.totalUsdValue) ? String(object.totalUsdValue) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.totalBurnt !== undefined && (obj.totalBurnt = message.totalBurnt);
        message.totalUsdValue !== undefined && (obj.totalUsdValue = message.totalUsdValue);
        return obj;
    },
    create(base) {
        return exports.AuctionsStatsResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseAuctionsStatsResponse();
        message.totalBurnt = (_a = object.totalBurnt) !== null && _a !== void 0 ? _a : "";
        message.totalUsdValue = (_b = object.totalUsdValue) !== null && _b !== void 0 ? _b : "";
        return message;
    },
};
class InjectiveAuctionRPCClientImpl {
    constructor(rpc) {
        this.rpc = rpc;
        this.AuctionEndpoint = this.AuctionEndpoint.bind(this);
        this.Auctions = this.Auctions.bind(this);
        this.AuctionsHistoryV2 = this.AuctionsHistoryV2.bind(this);
        this.AuctionV2 = this.AuctionV2.bind(this);
        this.AccountAuctionsV2 = this.AccountAuctionsV2.bind(this);
        this.StreamBids = this.StreamBids.bind(this);
        this.InjBurntEndpoint = this.InjBurntEndpoint.bind(this);
        this.AuctionsStats = this.AuctionsStats.bind(this);
    }
    AuctionEndpoint(request, metadata) {
        return this.rpc.unary(exports.InjectiveAuctionRPCAuctionEndpointDesc, exports.AuctionEndpointRequest.fromPartial(request), metadata);
    }
    Auctions(request, metadata) {
        return this.rpc.unary(exports.InjectiveAuctionRPCAuctionsDesc, exports.AuctionsRequest.fromPartial(request), metadata);
    }
    AuctionsHistoryV2(request, metadata) {
        return this.rpc.unary(exports.InjectiveAuctionRPCAuctionsHistoryV2Desc, exports.AuctionsHistoryV2Request.fromPartial(request), metadata);
    }
    AuctionV2(request, metadata) {
        return this.rpc.unary(exports.InjectiveAuctionRPCAuctionV2Desc, exports.AuctionV2Request.fromPartial(request), metadata);
    }
    AccountAuctionsV2(request, metadata) {
        return this.rpc.unary(exports.InjectiveAuctionRPCAccountAuctionsV2Desc, exports.AccountAuctionsV2Request.fromPartial(request), metadata);
    }
    StreamBids(request, metadata) {
        return this.rpc.invoke(exports.InjectiveAuctionRPCStreamBidsDesc, exports.StreamBidsRequest.fromPartial(request), metadata);
    }
    InjBurntEndpoint(request, metadata) {
        return this.rpc.unary(exports.InjectiveAuctionRPCInjBurntEndpointDesc, exports.InjBurntEndpointRequest.fromPartial(request), metadata);
    }
    AuctionsStats(request, metadata) {
        return this.rpc.unary(exports.InjectiveAuctionRPCAuctionsStatsDesc, exports.AuctionsStatsRequest.fromPartial(request), metadata);
    }
}
exports.InjectiveAuctionRPCClientImpl = InjectiveAuctionRPCClientImpl;
exports.InjectiveAuctionRPCDesc = { serviceName: "injective_auction_rpc.InjectiveAuctionRPC" };
exports.InjectiveAuctionRPCAuctionEndpointDesc = {
    methodName: "AuctionEndpoint",
    service: exports.InjectiveAuctionRPCDesc,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return exports.AuctionEndpointRequest.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = exports.AuctionEndpointResponse.decode(data);
            return Object.assign(Object.assign({}, value), { toObject() {
                    return value;
                } });
        },
    },
};
exports.InjectiveAuctionRPCAuctionsDesc = {
    methodName: "Auctions",
    service: exports.InjectiveAuctionRPCDesc,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return exports.AuctionsRequest.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = exports.AuctionsResponse.decode(data);
            return Object.assign(Object.assign({}, value), { toObject() {
                    return value;
                } });
        },
    },
};
exports.InjectiveAuctionRPCAuctionsHistoryV2Desc = {
    methodName: "AuctionsHistoryV2",
    service: exports.InjectiveAuctionRPCDesc,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return exports.AuctionsHistoryV2Request.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = exports.AuctionsHistoryV2Response.decode(data);
            return Object.assign(Object.assign({}, value), { toObject() {
                    return value;
                } });
        },
    },
};
exports.InjectiveAuctionRPCAuctionV2Desc = {
    methodName: "AuctionV2",
    service: exports.InjectiveAuctionRPCDesc,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return exports.AuctionV2Request.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = exports.AuctionV2Response.decode(data);
            return Object.assign(Object.assign({}, value), { toObject() {
                    return value;
                } });
        },
    },
};
exports.InjectiveAuctionRPCAccountAuctionsV2Desc = {
    methodName: "AccountAuctionsV2",
    service: exports.InjectiveAuctionRPCDesc,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return exports.AccountAuctionsV2Request.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = exports.AccountAuctionsV2Response.decode(data);
            return Object.assign(Object.assign({}, value), { toObject() {
                    return value;
                } });
        },
    },
};
exports.InjectiveAuctionRPCStreamBidsDesc = {
    methodName: "StreamBids",
    service: exports.InjectiveAuctionRPCDesc,
    requestStream: false,
    responseStream: true,
    requestType: {
        serializeBinary() {
            return exports.StreamBidsRequest.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = exports.StreamBidsResponse.decode(data);
            return Object.assign(Object.assign({}, value), { toObject() {
                    return value;
                } });
        },
    },
};
exports.InjectiveAuctionRPCInjBurntEndpointDesc = {
    methodName: "InjBurntEndpoint",
    service: exports.InjectiveAuctionRPCDesc,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return exports.InjBurntEndpointRequest.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = exports.InjBurntEndpointResponse.decode(data);
            return Object.assign(Object.assign({}, value), { toObject() {
                    return value;
                } });
        },
    },
};
exports.InjectiveAuctionRPCAuctionsStatsDesc = {
    methodName: "AuctionsStats",
    service: exports.InjectiveAuctionRPCDesc,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return exports.AuctionsStatsRequest.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = exports.AuctionsStatsResponse.decode(data);
            return Object.assign(Object.assign({}, value), { toObject() {
                    return value;
                } });
        },
    },
};
class GrpcWebImpl {
    constructor(host, options) {
        this.host = host;
        this.options = options;
    }
    unary(methodDesc, _request, metadata) {
        var _a;
        const request = Object.assign(Object.assign({}, _request), methodDesc.requestType);
        const maybeCombinedMetadata = metadata && this.options.metadata
            ? new browser_headers_1.BrowserHeaders(Object.assign(Object.assign({}, (_a = this.options) === null || _a === void 0 ? void 0 : _a.metadata.headersMap), metadata === null || metadata === void 0 ? void 0 : metadata.headersMap))
            : metadata || this.options.metadata;
        return new Promise((resolve, reject) => {
            grpc_web_1.grpc.unary(methodDesc, {
                request,
                host: this.host,
                metadata: maybeCombinedMetadata,
                transport: this.options.transport,
                debug: this.options.debug,
                onEnd: function (response) {
                    if (response.status === grpc_web_1.grpc.Code.OK) {
                        resolve(response.message.toObject());
                    }
                    else {
                        const err = new GrpcWebError(response.statusMessage, response.status, response.trailers);
                        reject(err);
                    }
                },
            });
        });
    }
    invoke(methodDesc, _request, metadata) {
        var _a;
        const upStreamCodes = this.options.upStreamRetryCodes || [];
        const DEFAULT_TIMEOUT_TIME = 3000;
        const request = Object.assign(Object.assign({}, _request), methodDesc.requestType);
        const maybeCombinedMetadata = metadata && this.options.metadata
            ? new browser_headers_1.BrowserHeaders(Object.assign(Object.assign({}, (_a = this.options) === null || _a === void 0 ? void 0 : _a.metadata.headersMap), metadata === null || metadata === void 0 ? void 0 : metadata.headersMap))
            : metadata || this.options.metadata;
        return new rxjs_1.Observable((observer) => {
            const upStream = (() => {
                const client = grpc_web_1.grpc.invoke(methodDesc, {
                    host: this.host,
                    request,
                    transport: this.options.streamingTransport || this.options.transport,
                    metadata: maybeCombinedMetadata,
                    debug: this.options.debug,
                    onMessage: (next) => observer.next(next),
                    onEnd: (code, message, trailers) => {
                        if (code === 0) {
                            observer.complete();
                        }
                        else if (upStreamCodes.includes(code)) {
                            setTimeout(upStream, DEFAULT_TIMEOUT_TIME);
                        }
                        else {
                            const err = new Error(message);
                            err.code = code;
                            err.metadata = trailers;
                            observer.error(err);
                        }
                    },
                });
                observer.add(() => {
                    if (!observer.closed) {
                        return client.close();
                    }
                });
            });
            upStream();
        }).pipe((0, operators_1.share)());
    }
}
exports.GrpcWebImpl = GrpcWebImpl;
var tsProtoGlobalThis = (() => {
    if (typeof globalThis !== "undefined") {
        return globalThis;
    }
    if (typeof self !== "undefined") {
        return self;
    }
    if (typeof window !== "undefined") {
        return window;
    }
    if (typeof global !== "undefined") {
        return global;
    }
    throw "Unable to locate global object";
})();
function longToString(long) {
    return long.toString();
}
if (minimal_js_1.default.util.Long !== long_1.default) {
    minimal_js_1.default.util.Long = long_1.default;
    minimal_js_1.default.configure();
}
function isObject(value) {
    return typeof value === "object" && value !== null;
}
function isSet(value) {
    return value !== null && value !== undefined;
}
class GrpcWebError extends tsProtoGlobalThis.Error {
    constructor(message, code, metadata) {
        super(message);
        this.code = code;
        this.metadata = metadata;
    }
}
exports.GrpcWebError = GrpcWebError;
