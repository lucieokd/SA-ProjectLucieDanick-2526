import {
  require_buffer,
  require_ieee754,
  require_safe_buffer
} from "./chunk-ZGYAHW6P.js";
import {
  browser_default,
  require_browser_ponyfill,
  z
} from "./chunk-SEWXHYBU.js";
import {
  equalBytes,
  secp256k1
} from "./chunk-WUABNFPV.js";
import {
  AbiDecodingDataSizeTooSmallError,
  AbiDecodingZeroDataError,
  AbiEventNotFoundError,
  AbiEventSignatureEmptyTopicsError,
  AbiEventSignatureNotFoundError,
  AbiFunctionSignatureNotFoundError,
  BaseError,
  BytesSizeMismatchError,
  CallExecutionError,
  ChainDisconnectedError,
  ChainMismatchError,
  ChainNotFoundError,
  ContractFunctionExecutionError,
  ContractFunctionRevertedError,
  ContractFunctionZeroDataError,
  DecodeLogDataMismatch,
  DecodeLogTopicsMismatch,
  Hash,
  HttpRequestError,
  InternalRpcError,
  InvalidAddressError,
  InvalidInputRpcError,
  InvalidParamsRpcError,
  InvalidRequestRpcError,
  InvalidSerializableTransactionError,
  JsonRpcVersionUnsupportedError,
  LimitExceededRpcError,
  LruMap,
  MethodNotFoundRpcError,
  MethodNotSupportedRpcError,
  ParseRpcError,
  PositionOutOfBoundsError,
  ProviderDisconnectedError,
  RawContractError,
  ResourceNotFoundRpcError,
  ResourceUnavailableRpcError,
  RpcRequestError,
  SwitchChainError,
  TimeoutError,
  TransactionExecutionError,
  TransactionNotFoundError,
  TransactionReceiptNotFoundError,
  TransactionRejectedRpcError,
  UnauthorizedProviderError,
  UnknownNodeError,
  UnknownRpcError,
  UnsupportedProviderMethodError,
  UserRejectedRequestError,
  WaitForTransactionReceiptTimeoutError,
  addressResolverAbi,
  assertRequest,
  bytesToHex,
  call,
  checksumAddress,
  concat,
  concatHex,
  createBatchScheduler,
  createCursor,
  createView,
  decodeAbiParameters,
  decodeFunctionResult,
  defineFormatter,
  encodeAbiParameters,
  encodeDeployData,
  encodeFunctionData,
  exists,
  extract,
  formatAbiItem,
  formatEther,
  formatGwei,
  formatTransactionRequest,
  getAbiItem,
  getAddress,
  getChainContractAddress,
  getNodeError,
  hexToBigInt,
  hexToBytes,
  hexToNumber,
  hexToString,
  isAddress,
  isAddressEqual,
  isHex,
  keccak256,
  multicall3Abi,
  numberToHex,
  output,
  panicReasons,
  parseAccount,
  prettyPrint,
  rotl,
  rotr,
  serializeStateOverride,
  size,
  slice,
  sliceHex,
  stringToBytes as stringToBytes2,
  stringToHex,
  stringify,
  textResolverAbi,
  toBytes,
  toBytes2,
  toEventSelector,
  toFunctionSelector,
  toHex,
  trim,
  universalResolverResolveAbi,
  universalResolverReverseAbi,
  universalSignatureValidatorAbi,
  universalSignatureValidatorByteCode,
  wrapConstructor
} from "./chunk-RPXAY6Q7.js";
import {
  __commonJS,
  __esm,
  __export,
  __publicField,
  __toCommonJS,
  __toESM
} from "./chunk-EWTE5DHJ.js";

// node_modules/lodash/lodash.js
var require_lodash = __commonJS({
  "node_modules/lodash/lodash.js"(exports2, module2) {
    (function() {
      var undefined2;
      var VERSION = "4.17.21";
      var LARGE_ARRAY_SIZE2 = 200;
      var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT = "Expected a function", INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
      var HASH_UNDEFINED2 = "__lodash_hash_undefined__";
      var MAX_MEMOIZE_SIZE = 500;
      var PLACEHOLDER = "__lodash_placeholder__";
      var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
      var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
      var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
      var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
      var HOT_COUNT2 = 800, HOT_SPAN2 = 16;
      var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
      var INFINITY = 1 / 0, MAX_SAFE_INTEGER3 = 9007199254740991, MAX_INTEGER = 17976931348623157e292, NAN = 0 / 0;
      var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
      var wrapFlags = [
        ["ary", WRAP_ARY_FLAG],
        ["bind", WRAP_BIND_FLAG],
        ["bindKey", WRAP_BIND_KEY_FLAG],
        ["curry", WRAP_CURRY_FLAG],
        ["curryRight", WRAP_CURRY_RIGHT_FLAG],
        ["flip", WRAP_FLIP_FLAG],
        ["partial", WRAP_PARTIAL_FLAG],
        ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
        ["rearg", WRAP_REARG_FLAG]
      ];
      var argsTag2 = "[object Arguments]", arrayTag2 = "[object Array]", asyncTag2 = "[object AsyncFunction]", boolTag2 = "[object Boolean]", dateTag2 = "[object Date]", domExcTag = "[object DOMException]", errorTag2 = "[object Error]", funcTag2 = "[object Function]", genTag2 = "[object GeneratorFunction]", mapTag2 = "[object Map]", numberTag2 = "[object Number]", nullTag2 = "[object Null]", objectTag2 = "[object Object]", promiseTag = "[object Promise]", proxyTag2 = "[object Proxy]", regexpTag2 = "[object RegExp]", setTag2 = "[object Set]", stringTag2 = "[object String]", symbolTag = "[object Symbol]", undefinedTag2 = "[object Undefined]", weakMapTag2 = "[object WeakMap]", weakSetTag = "[object WeakSet]";
      var arrayBufferTag2 = "[object ArrayBuffer]", dataViewTag2 = "[object DataView]", float32Tag2 = "[object Float32Array]", float64Tag2 = "[object Float64Array]", int8Tag2 = "[object Int8Array]", int16Tag2 = "[object Int16Array]", int32Tag2 = "[object Int32Array]", uint8Tag2 = "[object Uint8Array]", uint8ClampedTag2 = "[object Uint8ClampedArray]", uint16Tag2 = "[object Uint16Array]", uint32Tag2 = "[object Uint32Array]";
      var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
      var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
      var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
      var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
      var reRegExpChar2 = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar2.source);
      var reTrimStart = /^\s+/;
      var reWhitespace = /\s/;
      var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
      var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
      var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
      var reEscapeChar = /\\(\\)?/g;
      var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
      var reFlags = /\w*$/;
      var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
      var reIsBinary = /^0b[01]+$/i;
      var reIsHostCtor2 = /^\[object .+?Constructor\]$/;
      var reIsOctal = /^0o[0-7]+$/i;
      var reIsUint2 = /^(?:0|[1-9]\d*)$/;
      var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
      var reNoMatch = /($^)/;
      var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
      var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
      var rsApos = "['’]", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
      var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
      var reApos = RegExp(rsApos, "g");
      var reComboMark = RegExp(rsCombo, "g");
      var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
      var reUnicodeWord = RegExp([
        rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
        rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
        rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
        rsUpper + "+" + rsOptContrUpper,
        rsOrdUpper,
        rsOrdLower,
        rsDigits,
        rsEmoji
      ].join("|"), "g");
      var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
      var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
      var contextProps = [
        "Array",
        "Buffer",
        "DataView",
        "Date",
        "Error",
        "Float32Array",
        "Float64Array",
        "Function",
        "Int8Array",
        "Int16Array",
        "Int32Array",
        "Map",
        "Math",
        "Object",
        "Promise",
        "RegExp",
        "Set",
        "String",
        "Symbol",
        "TypeError",
        "Uint8Array",
        "Uint8ClampedArray",
        "Uint16Array",
        "Uint32Array",
        "WeakMap",
        "_",
        "clearTimeout",
        "isFinite",
        "parseInt",
        "setTimeout"
      ];
      var templateCounter = -1;
      var typedArrayTags2 = {};
      typedArrayTags2[float32Tag2] = typedArrayTags2[float64Tag2] = typedArrayTags2[int8Tag2] = typedArrayTags2[int16Tag2] = typedArrayTags2[int32Tag2] = typedArrayTags2[uint8Tag2] = typedArrayTags2[uint8ClampedTag2] = typedArrayTags2[uint16Tag2] = typedArrayTags2[uint32Tag2] = true;
      typedArrayTags2[argsTag2] = typedArrayTags2[arrayTag2] = typedArrayTags2[arrayBufferTag2] = typedArrayTags2[boolTag2] = typedArrayTags2[dataViewTag2] = typedArrayTags2[dateTag2] = typedArrayTags2[errorTag2] = typedArrayTags2[funcTag2] = typedArrayTags2[mapTag2] = typedArrayTags2[numberTag2] = typedArrayTags2[objectTag2] = typedArrayTags2[regexpTag2] = typedArrayTags2[setTag2] = typedArrayTags2[stringTag2] = typedArrayTags2[weakMapTag2] = false;
      var cloneableTags = {};
      cloneableTags[argsTag2] = cloneableTags[arrayTag2] = cloneableTags[arrayBufferTag2] = cloneableTags[dataViewTag2] = cloneableTags[boolTag2] = cloneableTags[dateTag2] = cloneableTags[float32Tag2] = cloneableTags[float64Tag2] = cloneableTags[int8Tag2] = cloneableTags[int16Tag2] = cloneableTags[int32Tag2] = cloneableTags[mapTag2] = cloneableTags[numberTag2] = cloneableTags[objectTag2] = cloneableTags[regexpTag2] = cloneableTags[setTag2] = cloneableTags[stringTag2] = cloneableTags[symbolTag] = cloneableTags[uint8Tag2] = cloneableTags[uint8ClampedTag2] = cloneableTags[uint16Tag2] = cloneableTags[uint32Tag2] = true;
      cloneableTags[errorTag2] = cloneableTags[funcTag2] = cloneableTags[weakMapTag2] = false;
      var deburredLetters = {
        // Latin-1 Supplement block.
        "À": "A",
        "Á": "A",
        "Â": "A",
        "Ã": "A",
        "Ä": "A",
        "Å": "A",
        "à": "a",
        "á": "a",
        "â": "a",
        "ã": "a",
        "ä": "a",
        "å": "a",
        "Ç": "C",
        "ç": "c",
        "Ð": "D",
        "ð": "d",
        "È": "E",
        "É": "E",
        "Ê": "E",
        "Ë": "E",
        "è": "e",
        "é": "e",
        "ê": "e",
        "ë": "e",
        "Ì": "I",
        "Í": "I",
        "Î": "I",
        "Ï": "I",
        "ì": "i",
        "í": "i",
        "î": "i",
        "ï": "i",
        "Ñ": "N",
        "ñ": "n",
        "Ò": "O",
        "Ó": "O",
        "Ô": "O",
        "Õ": "O",
        "Ö": "O",
        "Ø": "O",
        "ò": "o",
        "ó": "o",
        "ô": "o",
        "õ": "o",
        "ö": "o",
        "ø": "o",
        "Ù": "U",
        "Ú": "U",
        "Û": "U",
        "Ü": "U",
        "ù": "u",
        "ú": "u",
        "û": "u",
        "ü": "u",
        "Ý": "Y",
        "ý": "y",
        "ÿ": "y",
        "Æ": "Ae",
        "æ": "ae",
        "Þ": "Th",
        "þ": "th",
        "ß": "ss",
        // Latin Extended-A block.
        "Ā": "A",
        "Ă": "A",
        "Ą": "A",
        "ā": "a",
        "ă": "a",
        "ą": "a",
        "Ć": "C",
        "Ĉ": "C",
        "Ċ": "C",
        "Č": "C",
        "ć": "c",
        "ĉ": "c",
        "ċ": "c",
        "č": "c",
        "Ď": "D",
        "Đ": "D",
        "ď": "d",
        "đ": "d",
        "Ē": "E",
        "Ĕ": "E",
        "Ė": "E",
        "Ę": "E",
        "Ě": "E",
        "ē": "e",
        "ĕ": "e",
        "ė": "e",
        "ę": "e",
        "ě": "e",
        "Ĝ": "G",
        "Ğ": "G",
        "Ġ": "G",
        "Ģ": "G",
        "ĝ": "g",
        "ğ": "g",
        "ġ": "g",
        "ģ": "g",
        "Ĥ": "H",
        "Ħ": "H",
        "ĥ": "h",
        "ħ": "h",
        "Ĩ": "I",
        "Ī": "I",
        "Ĭ": "I",
        "Į": "I",
        "İ": "I",
        "ĩ": "i",
        "ī": "i",
        "ĭ": "i",
        "į": "i",
        "ı": "i",
        "Ĵ": "J",
        "ĵ": "j",
        "Ķ": "K",
        "ķ": "k",
        "ĸ": "k",
        "Ĺ": "L",
        "Ļ": "L",
        "Ľ": "L",
        "Ŀ": "L",
        "Ł": "L",
        "ĺ": "l",
        "ļ": "l",
        "ľ": "l",
        "ŀ": "l",
        "ł": "l",
        "Ń": "N",
        "Ņ": "N",
        "Ň": "N",
        "Ŋ": "N",
        "ń": "n",
        "ņ": "n",
        "ň": "n",
        "ŋ": "n",
        "Ō": "O",
        "Ŏ": "O",
        "Ő": "O",
        "ō": "o",
        "ŏ": "o",
        "ő": "o",
        "Ŕ": "R",
        "Ŗ": "R",
        "Ř": "R",
        "ŕ": "r",
        "ŗ": "r",
        "ř": "r",
        "Ś": "S",
        "Ŝ": "S",
        "Ş": "S",
        "Š": "S",
        "ś": "s",
        "ŝ": "s",
        "ş": "s",
        "š": "s",
        "Ţ": "T",
        "Ť": "T",
        "Ŧ": "T",
        "ţ": "t",
        "ť": "t",
        "ŧ": "t",
        "Ũ": "U",
        "Ū": "U",
        "Ŭ": "U",
        "Ů": "U",
        "Ű": "U",
        "Ų": "U",
        "ũ": "u",
        "ū": "u",
        "ŭ": "u",
        "ů": "u",
        "ű": "u",
        "ų": "u",
        "Ŵ": "W",
        "ŵ": "w",
        "Ŷ": "Y",
        "ŷ": "y",
        "Ÿ": "Y",
        "Ź": "Z",
        "Ż": "Z",
        "Ž": "Z",
        "ź": "z",
        "ż": "z",
        "ž": "z",
        "Ĳ": "IJ",
        "ĳ": "ij",
        "Œ": "Oe",
        "œ": "oe",
        "ŉ": "'n",
        "ſ": "s"
      };
      var htmlEscapes = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;"
      };
      var htmlUnescapes = {
        "&amp;": "&",
        "&lt;": "<",
        "&gt;": ">",
        "&quot;": '"',
        "&#39;": "'"
      };
      var stringEscapes = {
        "\\": "\\",
        "'": "'",
        "\n": "n",
        "\r": "r",
        "\u2028": "u2028",
        "\u2029": "u2029"
      };
      var freeParseFloat = parseFloat, freeParseInt = parseInt;
      var freeGlobal2 = typeof global == "object" && global && global.Object === Object && global;
      var freeSelf2 = typeof self == "object" && self && self.Object === Object && self;
      var root2 = freeGlobal2 || freeSelf2 || Function("return this")();
      var freeExports = typeof exports2 == "object" && exports2 && !exports2.nodeType && exports2;
      var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
      var moduleExports = freeModule && freeModule.exports === freeExports;
      var freeProcess = moduleExports && freeGlobal2.process;
      var nodeUtil2 = (function() {
        try {
          var types = freeModule && freeModule.require && freeModule.require("util").types;
          if (types) {
            return types;
          }
          return freeProcess && freeProcess.binding && freeProcess.binding("util");
        } catch (e) {
        }
      })();
      var nodeIsArrayBuffer = nodeUtil2 && nodeUtil2.isArrayBuffer, nodeIsDate = nodeUtil2 && nodeUtil2.isDate, nodeIsMap = nodeUtil2 && nodeUtil2.isMap, nodeIsRegExp = nodeUtil2 && nodeUtil2.isRegExp, nodeIsSet = nodeUtil2 && nodeUtil2.isSet, nodeIsTypedArray2 = nodeUtil2 && nodeUtil2.isTypedArray;
      function apply2(func, thisArg, args) {
        switch (args.length) {
          case 0:
            return func.call(thisArg);
          case 1:
            return func.call(thisArg, args[0]);
          case 2:
            return func.call(thisArg, args[0], args[1]);
          case 3:
            return func.call(thisArg, args[0], args[1], args[2]);
        }
        return func.apply(thisArg, args);
      }
      function arrayAggregator(array4, setter, iteratee, accumulator) {
        var index4 = -1, length2 = array4 == null ? 0 : array4.length;
        while (++index4 < length2) {
          var value = array4[index4];
          setter(accumulator, value, iteratee(value), array4);
        }
        return accumulator;
      }
      function arrayEach(array4, iteratee) {
        var index4 = -1, length2 = array4 == null ? 0 : array4.length;
        while (++index4 < length2) {
          if (iteratee(array4[index4], index4, array4) === false) {
            break;
          }
        }
        return array4;
      }
      function arrayEachRight(array4, iteratee) {
        var length2 = array4 == null ? 0 : array4.length;
        while (length2--) {
          if (iteratee(array4[length2], length2, array4) === false) {
            break;
          }
        }
        return array4;
      }
      function arrayEvery(array4, predicate) {
        var index4 = -1, length2 = array4 == null ? 0 : array4.length;
        while (++index4 < length2) {
          if (!predicate(array4[index4], index4, array4)) {
            return false;
          }
        }
        return true;
      }
      function arrayFilter(array4, predicate) {
        var index4 = -1, length2 = array4 == null ? 0 : array4.length, resIndex = 0, result = [];
        while (++index4 < length2) {
          var value = array4[index4];
          if (predicate(value, index4, array4)) {
            result[resIndex++] = value;
          }
        }
        return result;
      }
      function arrayIncludes(array4, value) {
        var length2 = array4 == null ? 0 : array4.length;
        return !!length2 && baseIndexOf(array4, value, 0) > -1;
      }
      function arrayIncludesWith(array4, value, comparator) {
        var index4 = -1, length2 = array4 == null ? 0 : array4.length;
        while (++index4 < length2) {
          if (comparator(value, array4[index4])) {
            return true;
          }
        }
        return false;
      }
      function arrayMap(array4, iteratee) {
        var index4 = -1, length2 = array4 == null ? 0 : array4.length, result = Array(length2);
        while (++index4 < length2) {
          result[index4] = iteratee(array4[index4], index4, array4);
        }
        return result;
      }
      function arrayPush(array4, values) {
        var index4 = -1, length2 = values.length, offset3 = array4.length;
        while (++index4 < length2) {
          array4[offset3 + index4] = values[index4];
        }
        return array4;
      }
      function arrayReduce(array4, iteratee, accumulator, initAccum) {
        var index4 = -1, length2 = array4 == null ? 0 : array4.length;
        if (initAccum && length2) {
          accumulator = array4[++index4];
        }
        while (++index4 < length2) {
          accumulator = iteratee(accumulator, array4[index4], index4, array4);
        }
        return accumulator;
      }
      function arrayReduceRight(array4, iteratee, accumulator, initAccum) {
        var length2 = array4 == null ? 0 : array4.length;
        if (initAccum && length2) {
          accumulator = array4[--length2];
        }
        while (length2--) {
          accumulator = iteratee(accumulator, array4[length2], length2, array4);
        }
        return accumulator;
      }
      function arraySome(array4, predicate) {
        var index4 = -1, length2 = array4 == null ? 0 : array4.length;
        while (++index4 < length2) {
          if (predicate(array4[index4], index4, array4)) {
            return true;
          }
        }
        return false;
      }
      var asciiSize = baseProperty("length");
      function asciiToArray(string3) {
        return string3.split("");
      }
      function asciiWords(string3) {
        return string3.match(reAsciiWord) || [];
      }
      function baseFindKey(collection, predicate, eachFunc) {
        var result;
        eachFunc(collection, function(value, key, collection2) {
          if (predicate(value, key, collection2)) {
            result = key;
            return false;
          }
        });
        return result;
      }
      function baseFindIndex(array4, predicate, fromIndex, fromRight) {
        var length2 = array4.length, index4 = fromIndex + (fromRight ? 1 : -1);
        while (fromRight ? index4-- : ++index4 < length2) {
          if (predicate(array4[index4], index4, array4)) {
            return index4;
          }
        }
        return -1;
      }
      function baseIndexOf(array4, value, fromIndex) {
        return value === value ? strictIndexOf(array4, value, fromIndex) : baseFindIndex(array4, baseIsNaN, fromIndex);
      }
      function baseIndexOfWith(array4, value, fromIndex, comparator) {
        var index4 = fromIndex - 1, length2 = array4.length;
        while (++index4 < length2) {
          if (comparator(array4[index4], value)) {
            return index4;
          }
        }
        return -1;
      }
      function baseIsNaN(value) {
        return value !== value;
      }
      function baseMean(array4, iteratee) {
        var length2 = array4 == null ? 0 : array4.length;
        return length2 ? baseSum(array4, iteratee) / length2 : NAN;
      }
      function baseProperty(key) {
        return function(object) {
          return object == null ? undefined2 : object[key];
        };
      }
      function basePropertyOf(object) {
        return function(key) {
          return object == null ? undefined2 : object[key];
        };
      }
      function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
        eachFunc(collection, function(value, index4, collection2) {
          accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index4, collection2);
        });
        return accumulator;
      }
      function baseSortBy(array4, comparer) {
        var length2 = array4.length;
        array4.sort(comparer);
        while (length2--) {
          array4[length2] = array4[length2].value;
        }
        return array4;
      }
      function baseSum(array4, iteratee) {
        var result, index4 = -1, length2 = array4.length;
        while (++index4 < length2) {
          var current = iteratee(array4[index4]);
          if (current !== undefined2) {
            result = result === undefined2 ? current : result + current;
          }
        }
        return result;
      }
      function baseTimes2(n, iteratee) {
        var index4 = -1, result = Array(n);
        while (++index4 < n) {
          result[index4] = iteratee(index4);
        }
        return result;
      }
      function baseToPairs(object, props) {
        return arrayMap(props, function(key) {
          return [key, object[key]];
        });
      }
      function baseTrim(string3) {
        return string3 ? string3.slice(0, trimmedEndIndex(string3) + 1).replace(reTrimStart, "") : string3;
      }
      function baseUnary2(func) {
        return function(value) {
          return func(value);
        };
      }
      function baseValues(object, props) {
        return arrayMap(props, function(key) {
          return object[key];
        });
      }
      function cacheHas(cache2, key) {
        return cache2.has(key);
      }
      function charsStartIndex(strSymbols, chrSymbols) {
        var index4 = -1, length2 = strSymbols.length;
        while (++index4 < length2 && baseIndexOf(chrSymbols, strSymbols[index4], 0) > -1) {
        }
        return index4;
      }
      function charsEndIndex(strSymbols, chrSymbols) {
        var index4 = strSymbols.length;
        while (index4-- && baseIndexOf(chrSymbols, strSymbols[index4], 0) > -1) {
        }
        return index4;
      }
      function countHolders(array4, placeholder) {
        var length2 = array4.length, result = 0;
        while (length2--) {
          if (array4[length2] === placeholder) {
            ++result;
          }
        }
        return result;
      }
      var deburrLetter = basePropertyOf(deburredLetters);
      var escapeHtmlChar = basePropertyOf(htmlEscapes);
      function escapeStringChar(chr) {
        return "\\" + stringEscapes[chr];
      }
      function getValue2(object, key) {
        return object == null ? undefined2 : object[key];
      }
      function hasUnicode(string3) {
        return reHasUnicode.test(string3);
      }
      function hasUnicodeWord(string3) {
        return reHasUnicodeWord.test(string3);
      }
      function iteratorToArray(iterator) {
        var data, result = [];
        while (!(data = iterator.next()).done) {
          result.push(data.value);
        }
        return result;
      }
      function mapToArray(map) {
        var index4 = -1, result = Array(map.size);
        map.forEach(function(value, key) {
          result[++index4] = [key, value];
        });
        return result;
      }
      function overArg2(func, transform) {
        return function(arg) {
          return func(transform(arg));
        };
      }
      function replaceHolders(array4, placeholder) {
        var index4 = -1, length2 = array4.length, resIndex = 0, result = [];
        while (++index4 < length2) {
          var value = array4[index4];
          if (value === placeholder || value === PLACEHOLDER) {
            array4[index4] = PLACEHOLDER;
            result[resIndex++] = index4;
          }
        }
        return result;
      }
      function setToArray(set2) {
        var index4 = -1, result = Array(set2.size);
        set2.forEach(function(value) {
          result[++index4] = value;
        });
        return result;
      }
      function setToPairs(set2) {
        var index4 = -1, result = Array(set2.size);
        set2.forEach(function(value) {
          result[++index4] = [value, value];
        });
        return result;
      }
      function strictIndexOf(array4, value, fromIndex) {
        var index4 = fromIndex - 1, length2 = array4.length;
        while (++index4 < length2) {
          if (array4[index4] === value) {
            return index4;
          }
        }
        return -1;
      }
      function strictLastIndexOf(array4, value, fromIndex) {
        var index4 = fromIndex + 1;
        while (index4--) {
          if (array4[index4] === value) {
            return index4;
          }
        }
        return index4;
      }
      function stringSize(string3) {
        return hasUnicode(string3) ? unicodeSize(string3) : asciiSize(string3);
      }
      function stringToArray(string3) {
        return hasUnicode(string3) ? unicodeToArray(string3) : asciiToArray(string3);
      }
      function trimmedEndIndex(string3) {
        var index4 = string3.length;
        while (index4-- && reWhitespace.test(string3.charAt(index4))) {
        }
        return index4;
      }
      var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
      function unicodeSize(string3) {
        var result = reUnicode.lastIndex = 0;
        while (reUnicode.test(string3)) {
          ++result;
        }
        return result;
      }
      function unicodeToArray(string3) {
        return string3.match(reUnicode) || [];
      }
      function unicodeWords(string3) {
        return string3.match(reUnicodeWord) || [];
      }
      var runInContext = (function runInContext2(context) {
        context = context == null ? root2 : _.defaults(root2.Object(), context, _.pick(root2, contextProps));
        var Array2 = context.Array, Date2 = context.Date, Error2 = context.Error, Function2 = context.Function, Math2 = context.Math, Object2 = context.Object, RegExp2 = context.RegExp, String2 = context.String, TypeError2 = context.TypeError;
        var arrayProto2 = Array2.prototype, funcProto2 = Function2.prototype, objectProto2 = Object2.prototype;
        var coreJsData2 = context["__core-js_shared__"];
        var funcToString2 = funcProto2.toString;
        var hasOwnProperty2 = objectProto2.hasOwnProperty;
        var idCounter = 0;
        var maskSrcKey2 = (function() {
          var uid2 = /[^.]+$/.exec(coreJsData2 && coreJsData2.keys && coreJsData2.keys.IE_PROTO || "");
          return uid2 ? "Symbol(src)_1." + uid2 : "";
        })();
        var nativeObjectToString2 = objectProto2.toString;
        var objectCtorString2 = funcToString2.call(Object2);
        var oldDash = root2._;
        var reIsNative2 = RegExp2(
          "^" + funcToString2.call(hasOwnProperty2).replace(reRegExpChar2, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
        );
        var Buffer4 = moduleExports ? context.Buffer : undefined2, Symbol2 = context.Symbol, Uint8Array2 = context.Uint8Array, allocUnsafe = Buffer4 ? Buffer4.allocUnsafe : undefined2, getPrototype2 = overArg2(Object2.getPrototypeOf, Object2), objectCreate2 = Object2.create, propertyIsEnumerable2 = objectProto2.propertyIsEnumerable, splice2 = arrayProto2.splice, spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : undefined2, symIterator = Symbol2 ? Symbol2.iterator : undefined2, symToStringTag2 = Symbol2 ? Symbol2.toStringTag : undefined2;
        var defineProperty2 = (function() {
          try {
            var func = getNative2(Object2, "defineProperty");
            func({}, "", {});
            return func;
          } catch (e) {
          }
        })();
        var ctxClearTimeout = context.clearTimeout !== root2.clearTimeout && context.clearTimeout, ctxNow = Date2 && Date2.now !== root2.Date.now && Date2.now, ctxSetTimeout = context.setTimeout !== root2.setTimeout && context.setTimeout;
        var nativeCeil = Math2.ceil, nativeFloor = Math2.floor, nativeGetSymbols = Object2.getOwnPropertySymbols, nativeIsBuffer = Buffer4 ? Buffer4.isBuffer : undefined2, nativeIsFinite = context.isFinite, nativeJoin = arrayProto2.join, nativeKeys = overArg2(Object2.keys, Object2), nativeMax2 = Math2.max, nativeMin = Math2.min, nativeNow2 = Date2.now, nativeParseInt = context.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto2.reverse;
        var DataView2 = getNative2(context, "DataView"), Map2 = getNative2(context, "Map"), Promise2 = getNative2(context, "Promise"), Set2 = getNative2(context, "Set"), WeakMap2 = getNative2(context, "WeakMap"), nativeCreate2 = getNative2(Object2, "create");
        var metaMap = WeakMap2 && new WeakMap2();
        var realNames = {};
        var dataViewCtorString = toSource2(DataView2), mapCtorString = toSource2(Map2), promiseCtorString = toSource2(Promise2), setCtorString = toSource2(Set2), weakMapCtorString = toSource2(WeakMap2);
        var symbolProto = Symbol2 ? Symbol2.prototype : undefined2, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined2, symbolToString = symbolProto ? symbolProto.toString : undefined2;
        function lodash(value) {
          if (isObjectLike2(value) && !isArray2(value) && !(value instanceof LazyWrapper)) {
            if (value instanceof LodashWrapper) {
              return value;
            }
            if (hasOwnProperty2.call(value, "__wrapped__")) {
              return wrapperClone(value);
            }
          }
          return new LodashWrapper(value);
        }
        var baseCreate2 = /* @__PURE__ */ (function() {
          function object() {
          }
          return function(proto) {
            if (!isObject4(proto)) {
              return {};
            }
            if (objectCreate2) {
              return objectCreate2(proto);
            }
            object.prototype = proto;
            var result2 = new object();
            object.prototype = undefined2;
            return result2;
          };
        })();
        function baseLodash() {
        }
        function LodashWrapper(value, chainAll) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__chain__ = !!chainAll;
          this.__index__ = 0;
          this.__values__ = undefined2;
        }
        lodash.templateSettings = {
          /**
           * Used to detect `data` property values to be HTML-escaped.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          "escape": reEscape,
          /**
           * Used to detect code to be evaluated.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          "evaluate": reEvaluate,
          /**
           * Used to detect `data` property values to inject.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          "interpolate": reInterpolate,
          /**
           * Used to reference the data object in the template text.
           *
           * @memberOf _.templateSettings
           * @type {string}
           */
          "variable": "",
          /**
           * Used to import variables into the compiled template.
           *
           * @memberOf _.templateSettings
           * @type {Object}
           */
          "imports": {
            /**
             * A reference to the `lodash` function.
             *
             * @memberOf _.templateSettings.imports
             * @type {Function}
             */
            "_": lodash
          }
        };
        lodash.prototype = baseLodash.prototype;
        lodash.prototype.constructor = lodash;
        LodashWrapper.prototype = baseCreate2(baseLodash.prototype);
        LodashWrapper.prototype.constructor = LodashWrapper;
        function LazyWrapper(value) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__dir__ = 1;
          this.__filtered__ = false;
          this.__iteratees__ = [];
          this.__takeCount__ = MAX_ARRAY_LENGTH;
          this.__views__ = [];
        }
        function lazyClone() {
          var result2 = new LazyWrapper(this.__wrapped__);
          result2.__actions__ = copyArray2(this.__actions__);
          result2.__dir__ = this.__dir__;
          result2.__filtered__ = this.__filtered__;
          result2.__iteratees__ = copyArray2(this.__iteratees__);
          result2.__takeCount__ = this.__takeCount__;
          result2.__views__ = copyArray2(this.__views__);
          return result2;
        }
        function lazyReverse() {
          if (this.__filtered__) {
            var result2 = new LazyWrapper(this);
            result2.__dir__ = -1;
            result2.__filtered__ = true;
          } else {
            result2 = this.clone();
            result2.__dir__ *= -1;
          }
          return result2;
        }
        function lazyValue() {
          var array4 = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray2(array4), isRight = dir < 0, arrLength = isArr ? array4.length : 0, view = getView(0, arrLength, this.__views__), start = view.start, end = view.end, length2 = end - start, index4 = isRight ? end : start - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length2, this.__takeCount__);
          if (!isArr || !isRight && arrLength == length2 && takeCount == length2) {
            return baseWrapperValue(array4, this.__actions__);
          }
          var result2 = [];
          outer:
            while (length2-- && resIndex < takeCount) {
              index4 += dir;
              var iterIndex = -1, value = array4[index4];
              while (++iterIndex < iterLength) {
                var data = iteratees[iterIndex], iteratee2 = data.iteratee, type3 = data.type, computed = iteratee2(value);
                if (type3 == LAZY_MAP_FLAG) {
                  value = computed;
                } else if (!computed) {
                  if (type3 == LAZY_FILTER_FLAG) {
                    continue outer;
                  } else {
                    break outer;
                  }
                }
              }
              result2[resIndex++] = value;
            }
          return result2;
        }
        LazyWrapper.prototype = baseCreate2(baseLodash.prototype);
        LazyWrapper.prototype.constructor = LazyWrapper;
        function Hash7(entries) {
          var index4 = -1, length2 = entries == null ? 0 : entries.length;
          this.clear();
          while (++index4 < length2) {
            var entry = entries[index4];
            this.set(entry[0], entry[1]);
          }
        }
        function hashClear2() {
          this.__data__ = nativeCreate2 ? nativeCreate2(null) : {};
          this.size = 0;
        }
        function hashDelete2(key) {
          var result2 = this.has(key) && delete this.__data__[key];
          this.size -= result2 ? 1 : 0;
          return result2;
        }
        function hashGet2(key) {
          var data = this.__data__;
          if (nativeCreate2) {
            var result2 = data[key];
            return result2 === HASH_UNDEFINED2 ? undefined2 : result2;
          }
          return hasOwnProperty2.call(data, key) ? data[key] : undefined2;
        }
        function hashHas2(key) {
          var data = this.__data__;
          return nativeCreate2 ? data[key] !== undefined2 : hasOwnProperty2.call(data, key);
        }
        function hashSet2(key, value) {
          var data = this.__data__;
          this.size += this.has(key) ? 0 : 1;
          data[key] = nativeCreate2 && value === undefined2 ? HASH_UNDEFINED2 : value;
          return this;
        }
        Hash7.prototype.clear = hashClear2;
        Hash7.prototype["delete"] = hashDelete2;
        Hash7.prototype.get = hashGet2;
        Hash7.prototype.has = hashHas2;
        Hash7.prototype.set = hashSet2;
        function ListCache2(entries) {
          var index4 = -1, length2 = entries == null ? 0 : entries.length;
          this.clear();
          while (++index4 < length2) {
            var entry = entries[index4];
            this.set(entry[0], entry[1]);
          }
        }
        function listCacheClear2() {
          this.__data__ = [];
          this.size = 0;
        }
        function listCacheDelete2(key) {
          var data = this.__data__, index4 = assocIndexOf2(data, key);
          if (index4 < 0) {
            return false;
          }
          var lastIndex = data.length - 1;
          if (index4 == lastIndex) {
            data.pop();
          } else {
            splice2.call(data, index4, 1);
          }
          --this.size;
          return true;
        }
        function listCacheGet2(key) {
          var data = this.__data__, index4 = assocIndexOf2(data, key);
          return index4 < 0 ? undefined2 : data[index4][1];
        }
        function listCacheHas2(key) {
          return assocIndexOf2(this.__data__, key) > -1;
        }
        function listCacheSet2(key, value) {
          var data = this.__data__, index4 = assocIndexOf2(data, key);
          if (index4 < 0) {
            ++this.size;
            data.push([key, value]);
          } else {
            data[index4][1] = value;
          }
          return this;
        }
        ListCache2.prototype.clear = listCacheClear2;
        ListCache2.prototype["delete"] = listCacheDelete2;
        ListCache2.prototype.get = listCacheGet2;
        ListCache2.prototype.has = listCacheHas2;
        ListCache2.prototype.set = listCacheSet2;
        function MapCache2(entries) {
          var index4 = -1, length2 = entries == null ? 0 : entries.length;
          this.clear();
          while (++index4 < length2) {
            var entry = entries[index4];
            this.set(entry[0], entry[1]);
          }
        }
        function mapCacheClear2() {
          this.size = 0;
          this.__data__ = {
            "hash": new Hash7(),
            "map": new (Map2 || ListCache2)(),
            "string": new Hash7()
          };
        }
        function mapCacheDelete2(key) {
          var result2 = getMapData2(this, key)["delete"](key);
          this.size -= result2 ? 1 : 0;
          return result2;
        }
        function mapCacheGet2(key) {
          return getMapData2(this, key).get(key);
        }
        function mapCacheHas2(key) {
          return getMapData2(this, key).has(key);
        }
        function mapCacheSet2(key, value) {
          var data = getMapData2(this, key), size5 = data.size;
          data.set(key, value);
          this.size += data.size == size5 ? 0 : 1;
          return this;
        }
        MapCache2.prototype.clear = mapCacheClear2;
        MapCache2.prototype["delete"] = mapCacheDelete2;
        MapCache2.prototype.get = mapCacheGet2;
        MapCache2.prototype.has = mapCacheHas2;
        MapCache2.prototype.set = mapCacheSet2;
        function SetCache(values2) {
          var index4 = -1, length2 = values2 == null ? 0 : values2.length;
          this.__data__ = new MapCache2();
          while (++index4 < length2) {
            this.add(values2[index4]);
          }
        }
        function setCacheAdd(value) {
          this.__data__.set(value, HASH_UNDEFINED2);
          return this;
        }
        function setCacheHas(value) {
          return this.__data__.has(value);
        }
        SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
        SetCache.prototype.has = setCacheHas;
        function Stack2(entries) {
          var data = this.__data__ = new ListCache2(entries);
          this.size = data.size;
        }
        function stackClear2() {
          this.__data__ = new ListCache2();
          this.size = 0;
        }
        function stackDelete2(key) {
          var data = this.__data__, result2 = data["delete"](key);
          this.size = data.size;
          return result2;
        }
        function stackGet2(key) {
          return this.__data__.get(key);
        }
        function stackHas2(key) {
          return this.__data__.has(key);
        }
        function stackSet2(key, value) {
          var data = this.__data__;
          if (data instanceof ListCache2) {
            var pairs = data.__data__;
            if (!Map2 || pairs.length < LARGE_ARRAY_SIZE2 - 1) {
              pairs.push([key, value]);
              this.size = ++data.size;
              return this;
            }
            data = this.__data__ = new MapCache2(pairs);
          }
          data.set(key, value);
          this.size = data.size;
          return this;
        }
        Stack2.prototype.clear = stackClear2;
        Stack2.prototype["delete"] = stackDelete2;
        Stack2.prototype.get = stackGet2;
        Stack2.prototype.has = stackHas2;
        Stack2.prototype.set = stackSet2;
        function arrayLikeKeys2(value, inherited) {
          var isArr = isArray2(value), isArg = !isArr && isArguments2(value), isBuff = !isArr && !isArg && isBuffer2(value), isType = !isArr && !isArg && !isBuff && isTypedArray2(value), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes2(value.length, String2) : [], length2 = result2.length;
          for (var key in value) {
            if ((inherited || hasOwnProperty2.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
            (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
            isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
            isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
            isIndex2(key, length2)))) {
              result2.push(key);
            }
          }
          return result2;
        }
        function arraySample(array4) {
          var length2 = array4.length;
          return length2 ? array4[baseRandom(0, length2 - 1)] : undefined2;
        }
        function arraySampleSize(array4, n) {
          return shuffleSelf(copyArray2(array4), baseClamp(n, 0, array4.length));
        }
        function arrayShuffle(array4) {
          return shuffleSelf(copyArray2(array4));
        }
        function assignMergeValue2(object, key, value) {
          if (value !== undefined2 && !eq2(object[key], value) || value === undefined2 && !(key in object)) {
            baseAssignValue2(object, key, value);
          }
        }
        function assignValue2(object, key, value) {
          var objValue = object[key];
          if (!(hasOwnProperty2.call(object, key) && eq2(objValue, value)) || value === undefined2 && !(key in object)) {
            baseAssignValue2(object, key, value);
          }
        }
        function assocIndexOf2(array4, key) {
          var length2 = array4.length;
          while (length2--) {
            if (eq2(array4[length2][0], key)) {
              return length2;
            }
          }
          return -1;
        }
        function baseAggregator(collection, setter, iteratee2, accumulator) {
          baseEach(collection, function(value, key, collection2) {
            setter(accumulator, value, iteratee2(value), collection2);
          });
          return accumulator;
        }
        function baseAssign(object, source) {
          return object && copyObject2(source, keys(source), object);
        }
        function baseAssignIn(object, source) {
          return object && copyObject2(source, keysIn2(source), object);
        }
        function baseAssignValue2(object, key, value) {
          if (key == "__proto__" && defineProperty2) {
            defineProperty2(object, key, {
              "configurable": true,
              "enumerable": true,
              "value": value,
              "writable": true
            });
          } else {
            object[key] = value;
          }
        }
        function baseAt(object, paths) {
          var index4 = -1, length2 = paths.length, result2 = Array2(length2), skip = object == null;
          while (++index4 < length2) {
            result2[index4] = skip ? undefined2 : get(object, paths[index4]);
          }
          return result2;
        }
        function baseClamp(number5, lower, upper) {
          if (number5 === number5) {
            if (upper !== undefined2) {
              number5 = number5 <= upper ? number5 : upper;
            }
            if (lower !== undefined2) {
              number5 = number5 >= lower ? number5 : lower;
            }
          }
          return number5;
        }
        function baseClone(value, bitmask, customizer, key, object, stack) {
          var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
          if (customizer) {
            result2 = object ? customizer(value, key, object, stack) : customizer(value);
          }
          if (result2 !== undefined2) {
            return result2;
          }
          if (!isObject4(value)) {
            return value;
          }
          var isArr = isArray2(value);
          if (isArr) {
            result2 = initCloneArray(value);
            if (!isDeep) {
              return copyArray2(value, result2);
            }
          } else {
            var tag = getTag(value), isFunc = tag == funcTag2 || tag == genTag2;
            if (isBuffer2(value)) {
              return cloneBuffer2(value, isDeep);
            }
            if (tag == objectTag2 || tag == argsTag2 || isFunc && !object) {
              result2 = isFlat || isFunc ? {} : initCloneObject2(value);
              if (!isDeep) {
                return isFlat ? copySymbolsIn(value, baseAssignIn(result2, value)) : copySymbols(value, baseAssign(result2, value));
              }
            } else {
              if (!cloneableTags[tag]) {
                return object ? value : {};
              }
              result2 = initCloneByTag(value, tag, isDeep);
            }
          }
          stack || (stack = new Stack2());
          var stacked = stack.get(value);
          if (stacked) {
            return stacked;
          }
          stack.set(value, result2);
          if (isSet2(value)) {
            value.forEach(function(subValue) {
              result2.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
            });
          } else if (isMap(value)) {
            value.forEach(function(subValue, key2) {
              result2.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
            });
          }
          var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn2 : keys;
          var props = isArr ? undefined2 : keysFunc(value);
          arrayEach(props || value, function(subValue, key2) {
            if (props) {
              key2 = subValue;
              subValue = value[key2];
            }
            assignValue2(result2, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
          });
          return result2;
        }
        function baseConforms(source) {
          var props = keys(source);
          return function(object) {
            return baseConformsTo(object, source, props);
          };
        }
        function baseConformsTo(object, source, props) {
          var length2 = props.length;
          if (object == null) {
            return !length2;
          }
          object = Object2(object);
          while (length2--) {
            var key = props[length2], predicate = source[key], value = object[key];
            if (value === undefined2 && !(key in object) || !predicate(value)) {
              return false;
            }
          }
          return true;
        }
        function baseDelay(func, wait3, args) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return setTimeout2(function() {
            func.apply(undefined2, args);
          }, wait3);
        }
        function baseDifference(array4, values2, iteratee2, comparator) {
          var index4 = -1, includes2 = arrayIncludes, isCommon = true, length2 = array4.length, result2 = [], valuesLength = values2.length;
          if (!length2) {
            return result2;
          }
          if (iteratee2) {
            values2 = arrayMap(values2, baseUnary2(iteratee2));
          }
          if (comparator) {
            includes2 = arrayIncludesWith;
            isCommon = false;
          } else if (values2.length >= LARGE_ARRAY_SIZE2) {
            includes2 = cacheHas;
            isCommon = false;
            values2 = new SetCache(values2);
          }
          outer:
            while (++index4 < length2) {
              var value = array4[index4], computed = iteratee2 == null ? value : iteratee2(value);
              value = comparator || value !== 0 ? value : 0;
              if (isCommon && computed === computed) {
                var valuesIndex = valuesLength;
                while (valuesIndex--) {
                  if (values2[valuesIndex] === computed) {
                    continue outer;
                  }
                }
                result2.push(value);
              } else if (!includes2(values2, computed, comparator)) {
                result2.push(value);
              }
            }
          return result2;
        }
        var baseEach = createBaseEach(baseForOwn);
        var baseEachRight = createBaseEach(baseForOwnRight, true);
        function baseEvery(collection, predicate) {
          var result2 = true;
          baseEach(collection, function(value, index4, collection2) {
            result2 = !!predicate(value, index4, collection2);
            return result2;
          });
          return result2;
        }
        function baseExtremum(array4, iteratee2, comparator) {
          var index4 = -1, length2 = array4.length;
          while (++index4 < length2) {
            var value = array4[index4], current = iteratee2(value);
            if (current != null && (computed === undefined2 ? current === current && !isSymbol(current) : comparator(current, computed))) {
              var computed = current, result2 = value;
            }
          }
          return result2;
        }
        function baseFill(array4, value, start, end) {
          var length2 = array4.length;
          start = toInteger(start);
          if (start < 0) {
            start = -start > length2 ? 0 : length2 + start;
          }
          end = end === undefined2 || end > length2 ? length2 : toInteger(end);
          if (end < 0) {
            end += length2;
          }
          end = start > end ? 0 : toLength(end);
          while (start < end) {
            array4[start++] = value;
          }
          return array4;
        }
        function baseFilter(collection, predicate) {
          var result2 = [];
          baseEach(collection, function(value, index4, collection2) {
            if (predicate(value, index4, collection2)) {
              result2.push(value);
            }
          });
          return result2;
        }
        function baseFlatten(array4, depth, predicate, isStrict, result2) {
          var index4 = -1, length2 = array4.length;
          predicate || (predicate = isFlattenable);
          result2 || (result2 = []);
          while (++index4 < length2) {
            var value = array4[index4];
            if (depth > 0 && predicate(value)) {
              if (depth > 1) {
                baseFlatten(value, depth - 1, predicate, isStrict, result2);
              } else {
                arrayPush(result2, value);
              }
            } else if (!isStrict) {
              result2[result2.length] = value;
            }
          }
          return result2;
        }
        var baseFor2 = createBaseFor2();
        var baseForRight = createBaseFor2(true);
        function baseForOwn(object, iteratee2) {
          return object && baseFor2(object, iteratee2, keys);
        }
        function baseForOwnRight(object, iteratee2) {
          return object && baseForRight(object, iteratee2, keys);
        }
        function baseFunctions(object, props) {
          return arrayFilter(props, function(key) {
            return isFunction2(object[key]);
          });
        }
        function baseGet(object, path) {
          path = castPath(path, object);
          var index4 = 0, length2 = path.length;
          while (object != null && index4 < length2) {
            object = object[toKey(path[index4++])];
          }
          return index4 && index4 == length2 ? object : undefined2;
        }
        function baseGetAllKeys(object, keysFunc, symbolsFunc) {
          var result2 = keysFunc(object);
          return isArray2(object) ? result2 : arrayPush(result2, symbolsFunc(object));
        }
        function baseGetTag2(value) {
          if (value == null) {
            return value === undefined2 ? undefinedTag2 : nullTag2;
          }
          return symToStringTag2 && symToStringTag2 in Object2(value) ? getRawTag2(value) : objectToString2(value);
        }
        function baseGt(value, other) {
          return value > other;
        }
        function baseHas(object, key) {
          return object != null && hasOwnProperty2.call(object, key);
        }
        function baseHasIn(object, key) {
          return object != null && key in Object2(object);
        }
        function baseInRange(number5, start, end) {
          return number5 >= nativeMin(start, end) && number5 < nativeMax2(start, end);
        }
        function baseIntersection(arrays, iteratee2, comparator) {
          var includes2 = comparator ? arrayIncludesWith : arrayIncludes, length2 = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array2(othLength), maxLength = Infinity, result2 = [];
          while (othIndex--) {
            var array4 = arrays[othIndex];
            if (othIndex && iteratee2) {
              array4 = arrayMap(array4, baseUnary2(iteratee2));
            }
            maxLength = nativeMin(array4.length, maxLength);
            caches[othIndex] = !comparator && (iteratee2 || length2 >= 120 && array4.length >= 120) ? new SetCache(othIndex && array4) : undefined2;
          }
          array4 = arrays[0];
          var index4 = -1, seen = caches[0];
          outer:
            while (++index4 < length2 && result2.length < maxLength) {
              var value = array4[index4], computed = iteratee2 ? iteratee2(value) : value;
              value = comparator || value !== 0 ? value : 0;
              if (!(seen ? cacheHas(seen, computed) : includes2(result2, computed, comparator))) {
                othIndex = othLength;
                while (--othIndex) {
                  var cache2 = caches[othIndex];
                  if (!(cache2 ? cacheHas(cache2, computed) : includes2(arrays[othIndex], computed, comparator))) {
                    continue outer;
                  }
                }
                if (seen) {
                  seen.push(computed);
                }
                result2.push(value);
              }
            }
          return result2;
        }
        function baseInverter(object, setter, iteratee2, accumulator) {
          baseForOwn(object, function(value, key, object2) {
            setter(accumulator, iteratee2(value), key, object2);
          });
          return accumulator;
        }
        function baseInvoke(object, path, args) {
          path = castPath(path, object);
          object = parent(object, path);
          var func = object == null ? object : object[toKey(last(path))];
          return func == null ? undefined2 : apply2(func, object, args);
        }
        function baseIsArguments2(value) {
          return isObjectLike2(value) && baseGetTag2(value) == argsTag2;
        }
        function baseIsArrayBuffer(value) {
          return isObjectLike2(value) && baseGetTag2(value) == arrayBufferTag2;
        }
        function baseIsDate(value) {
          return isObjectLike2(value) && baseGetTag2(value) == dateTag2;
        }
        function baseIsEqual(value, other, bitmask, customizer, stack) {
          if (value === other) {
            return true;
          }
          if (value == null || other == null || !isObjectLike2(value) && !isObjectLike2(other)) {
            return value !== value && other !== other;
          }
          return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
        }
        function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
          var objIsArr = isArray2(object), othIsArr = isArray2(other), objTag = objIsArr ? arrayTag2 : getTag(object), othTag = othIsArr ? arrayTag2 : getTag(other);
          objTag = objTag == argsTag2 ? objectTag2 : objTag;
          othTag = othTag == argsTag2 ? objectTag2 : othTag;
          var objIsObj = objTag == objectTag2, othIsObj = othTag == objectTag2, isSameTag = objTag == othTag;
          if (isSameTag && isBuffer2(object)) {
            if (!isBuffer2(other)) {
              return false;
            }
            objIsArr = true;
            objIsObj = false;
          }
          if (isSameTag && !objIsObj) {
            stack || (stack = new Stack2());
            return objIsArr || isTypedArray2(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
          }
          if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
            var objIsWrapped = objIsObj && hasOwnProperty2.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty2.call(other, "__wrapped__");
            if (objIsWrapped || othIsWrapped) {
              var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
              stack || (stack = new Stack2());
              return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
            }
          }
          if (!isSameTag) {
            return false;
          }
          stack || (stack = new Stack2());
          return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
        }
        function baseIsMap(value) {
          return isObjectLike2(value) && getTag(value) == mapTag2;
        }
        function baseIsMatch(object, source, matchData, customizer) {
          var index4 = matchData.length, length2 = index4, noCustomizer = !customizer;
          if (object == null) {
            return !length2;
          }
          object = Object2(object);
          while (index4--) {
            var data = matchData[index4];
            if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
              return false;
            }
          }
          while (++index4 < length2) {
            data = matchData[index4];
            var key = data[0], objValue = object[key], srcValue = data[1];
            if (noCustomizer && data[2]) {
              if (objValue === undefined2 && !(key in object)) {
                return false;
              }
            } else {
              var stack = new Stack2();
              if (customizer) {
                var result2 = customizer(objValue, srcValue, key, object, source, stack);
              }
              if (!(result2 === undefined2 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result2)) {
                return false;
              }
            }
          }
          return true;
        }
        function baseIsNative2(value) {
          if (!isObject4(value) || isMasked2(value)) {
            return false;
          }
          var pattern = isFunction2(value) ? reIsNative2 : reIsHostCtor2;
          return pattern.test(toSource2(value));
        }
        function baseIsRegExp(value) {
          return isObjectLike2(value) && baseGetTag2(value) == regexpTag2;
        }
        function baseIsSet(value) {
          return isObjectLike2(value) && getTag(value) == setTag2;
        }
        function baseIsTypedArray2(value) {
          return isObjectLike2(value) && isLength2(value.length) && !!typedArrayTags2[baseGetTag2(value)];
        }
        function baseIteratee(value) {
          if (typeof value == "function") {
            return value;
          }
          if (value == null) {
            return identity2;
          }
          if (typeof value == "object") {
            return isArray2(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
          }
          return property(value);
        }
        function baseKeys(object) {
          if (!isPrototype2(object)) {
            return nativeKeys(object);
          }
          var result2 = [];
          for (var key in Object2(object)) {
            if (hasOwnProperty2.call(object, key) && key != "constructor") {
              result2.push(key);
            }
          }
          return result2;
        }
        function baseKeysIn2(object) {
          if (!isObject4(object)) {
            return nativeKeysIn2(object);
          }
          var isProto = isPrototype2(object), result2 = [];
          for (var key in object) {
            if (!(key == "constructor" && (isProto || !hasOwnProperty2.call(object, key)))) {
              result2.push(key);
            }
          }
          return result2;
        }
        function baseLt(value, other) {
          return value < other;
        }
        function baseMap(collection, iteratee2) {
          var index4 = -1, result2 = isArrayLike2(collection) ? Array2(collection.length) : [];
          baseEach(collection, function(value, key, collection2) {
            result2[++index4] = iteratee2(value, key, collection2);
          });
          return result2;
        }
        function baseMatches(source) {
          var matchData = getMatchData(source);
          if (matchData.length == 1 && matchData[0][2]) {
            return matchesStrictComparable(matchData[0][0], matchData[0][1]);
          }
          return function(object) {
            return object === source || baseIsMatch(object, source, matchData);
          };
        }
        function baseMatchesProperty(path, srcValue) {
          if (isKey(path) && isStrictComparable(srcValue)) {
            return matchesStrictComparable(toKey(path), srcValue);
          }
          return function(object) {
            var objValue = get(object, path);
            return objValue === undefined2 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
          };
        }
        function baseMerge2(object, source, srcIndex, customizer, stack) {
          if (object === source) {
            return;
          }
          baseFor2(source, function(srcValue, key) {
            stack || (stack = new Stack2());
            if (isObject4(srcValue)) {
              baseMergeDeep2(object, source, key, srcIndex, baseMerge2, customizer, stack);
            } else {
              var newValue = customizer ? customizer(safeGet2(object, key), srcValue, key + "", object, source, stack) : undefined2;
              if (newValue === undefined2) {
                newValue = srcValue;
              }
              assignMergeValue2(object, key, newValue);
            }
          }, keysIn2);
        }
        function baseMergeDeep2(object, source, key, srcIndex, mergeFunc, customizer, stack) {
          var objValue = safeGet2(object, key), srcValue = safeGet2(source, key), stacked = stack.get(srcValue);
          if (stacked) {
            assignMergeValue2(object, key, stacked);
            return;
          }
          var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : undefined2;
          var isCommon = newValue === undefined2;
          if (isCommon) {
            var isArr = isArray2(srcValue), isBuff = !isArr && isBuffer2(srcValue), isTyped = !isArr && !isBuff && isTypedArray2(srcValue);
            newValue = srcValue;
            if (isArr || isBuff || isTyped) {
              if (isArray2(objValue)) {
                newValue = objValue;
              } else if (isArrayLikeObject2(objValue)) {
                newValue = copyArray2(objValue);
              } else if (isBuff) {
                isCommon = false;
                newValue = cloneBuffer2(srcValue, true);
              } else if (isTyped) {
                isCommon = false;
                newValue = cloneTypedArray2(srcValue, true);
              } else {
                newValue = [];
              }
            } else if (isPlainObject2(srcValue) || isArguments2(srcValue)) {
              newValue = objValue;
              if (isArguments2(objValue)) {
                newValue = toPlainObject2(objValue);
              } else if (!isObject4(objValue) || isFunction2(objValue)) {
                newValue = initCloneObject2(srcValue);
              }
            } else {
              isCommon = false;
            }
          }
          if (isCommon) {
            stack.set(srcValue, newValue);
            mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
            stack["delete"](srcValue);
          }
          assignMergeValue2(object, key, newValue);
        }
        function baseNth(array4, n) {
          var length2 = array4.length;
          if (!length2) {
            return;
          }
          n += n < 0 ? length2 : 0;
          return isIndex2(n, length2) ? array4[n] : undefined2;
        }
        function baseOrderBy(collection, iteratees, orders) {
          if (iteratees.length) {
            iteratees = arrayMap(iteratees, function(iteratee2) {
              if (isArray2(iteratee2)) {
                return function(value) {
                  return baseGet(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
                };
              }
              return iteratee2;
            });
          } else {
            iteratees = [identity2];
          }
          var index4 = -1;
          iteratees = arrayMap(iteratees, baseUnary2(getIteratee()));
          var result2 = baseMap(collection, function(value, key, collection2) {
            var criteria = arrayMap(iteratees, function(iteratee2) {
              return iteratee2(value);
            });
            return { "criteria": criteria, "index": ++index4, "value": value };
          });
          return baseSortBy(result2, function(object, other) {
            return compareMultiple(object, other, orders);
          });
        }
        function basePick(object, paths) {
          return basePickBy(object, paths, function(value, path) {
            return hasIn(object, path);
          });
        }
        function basePickBy(object, paths, predicate) {
          var index4 = -1, length2 = paths.length, result2 = {};
          while (++index4 < length2) {
            var path = paths[index4], value = baseGet(object, path);
            if (predicate(value, path)) {
              baseSet(result2, castPath(path, object), value);
            }
          }
          return result2;
        }
        function basePropertyDeep(path) {
          return function(object) {
            return baseGet(object, path);
          };
        }
        function basePullAll(array4, values2, iteratee2, comparator) {
          var indexOf2 = comparator ? baseIndexOfWith : baseIndexOf, index4 = -1, length2 = values2.length, seen = array4;
          if (array4 === values2) {
            values2 = copyArray2(values2);
          }
          if (iteratee2) {
            seen = arrayMap(array4, baseUnary2(iteratee2));
          }
          while (++index4 < length2) {
            var fromIndex = 0, value = values2[index4], computed = iteratee2 ? iteratee2(value) : value;
            while ((fromIndex = indexOf2(seen, computed, fromIndex, comparator)) > -1) {
              if (seen !== array4) {
                splice2.call(seen, fromIndex, 1);
              }
              splice2.call(array4, fromIndex, 1);
            }
          }
          return array4;
        }
        function basePullAt(array4, indexes) {
          var length2 = array4 ? indexes.length : 0, lastIndex = length2 - 1;
          while (length2--) {
            var index4 = indexes[length2];
            if (length2 == lastIndex || index4 !== previous) {
              var previous = index4;
              if (isIndex2(index4)) {
                splice2.call(array4, index4, 1);
              } else {
                baseUnset(array4, index4);
              }
            }
          }
          return array4;
        }
        function baseRandom(lower, upper) {
          return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
        }
        function baseRange(start, end, step, fromRight) {
          var index4 = -1, length2 = nativeMax2(nativeCeil((end - start) / (step || 1)), 0), result2 = Array2(length2);
          while (length2--) {
            result2[fromRight ? length2 : ++index4] = start;
            start += step;
          }
          return result2;
        }
        function baseRepeat(string3, n) {
          var result2 = "";
          if (!string3 || n < 1 || n > MAX_SAFE_INTEGER3) {
            return result2;
          }
          do {
            if (n % 2) {
              result2 += string3;
            }
            n = nativeFloor(n / 2);
            if (n) {
              string3 += string3;
            }
          } while (n);
          return result2;
        }
        function baseRest2(func, start) {
          return setToString2(overRest2(func, start, identity2), func + "");
        }
        function baseSample(collection) {
          return arraySample(values(collection));
        }
        function baseSampleSize(collection, n) {
          var array4 = values(collection);
          return shuffleSelf(array4, baseClamp(n, 0, array4.length));
        }
        function baseSet(object, path, value, customizer) {
          if (!isObject4(object)) {
            return object;
          }
          path = castPath(path, object);
          var index4 = -1, length2 = path.length, lastIndex = length2 - 1, nested = object;
          while (nested != null && ++index4 < length2) {
            var key = toKey(path[index4]), newValue = value;
            if (key === "__proto__" || key === "constructor" || key === "prototype") {
              return object;
            }
            if (index4 != lastIndex) {
              var objValue = nested[key];
              newValue = customizer ? customizer(objValue, key, nested) : undefined2;
              if (newValue === undefined2) {
                newValue = isObject4(objValue) ? objValue : isIndex2(path[index4 + 1]) ? [] : {};
              }
            }
            assignValue2(nested, key, newValue);
            nested = nested[key];
          }
          return object;
        }
        var baseSetData = !metaMap ? identity2 : function(func, data) {
          metaMap.set(func, data);
          return func;
        };
        var baseSetToString2 = !defineProperty2 ? identity2 : function(func, string3) {
          return defineProperty2(func, "toString", {
            "configurable": true,
            "enumerable": false,
            "value": constant2(string3),
            "writable": true
          });
        };
        function baseShuffle(collection) {
          return shuffleSelf(values(collection));
        }
        function baseSlice(array4, start, end) {
          var index4 = -1, length2 = array4.length;
          if (start < 0) {
            start = -start > length2 ? 0 : length2 + start;
          }
          end = end > length2 ? length2 : end;
          if (end < 0) {
            end += length2;
          }
          length2 = start > end ? 0 : end - start >>> 0;
          start >>>= 0;
          var result2 = Array2(length2);
          while (++index4 < length2) {
            result2[index4] = array4[index4 + start];
          }
          return result2;
        }
        function baseSome(collection, predicate) {
          var result2;
          baseEach(collection, function(value, index4, collection2) {
            result2 = predicate(value, index4, collection2);
            return !result2;
          });
          return !!result2;
        }
        function baseSortedIndex(array4, value, retHighest) {
          var low = 0, high = array4 == null ? low : array4.length;
          if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
            while (low < high) {
              var mid = low + high >>> 1, computed = array4[mid];
              if (computed !== null && !isSymbol(computed) && (retHighest ? computed <= value : computed < value)) {
                low = mid + 1;
              } else {
                high = mid;
              }
            }
            return high;
          }
          return baseSortedIndexBy(array4, value, identity2, retHighest);
        }
        function baseSortedIndexBy(array4, value, iteratee2, retHighest) {
          var low = 0, high = array4 == null ? 0 : array4.length;
          if (high === 0) {
            return 0;
          }
          value = iteratee2(value);
          var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol(value), valIsUndefined = value === undefined2;
          while (low < high) {
            var mid = nativeFloor((low + high) / 2), computed = iteratee2(array4[mid]), othIsDefined = computed !== undefined2, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol(computed);
            if (valIsNaN) {
              var setLow = retHighest || othIsReflexive;
            } else if (valIsUndefined) {
              setLow = othIsReflexive && (retHighest || othIsDefined);
            } else if (valIsNull) {
              setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
            } else if (valIsSymbol) {
              setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
            } else if (othIsNull || othIsSymbol) {
              setLow = false;
            } else {
              setLow = retHighest ? computed <= value : computed < value;
            }
            if (setLow) {
              low = mid + 1;
            } else {
              high = mid;
            }
          }
          return nativeMin(high, MAX_ARRAY_INDEX);
        }
        function baseSortedUniq(array4, iteratee2) {
          var index4 = -1, length2 = array4.length, resIndex = 0, result2 = [];
          while (++index4 < length2) {
            var value = array4[index4], computed = iteratee2 ? iteratee2(value) : value;
            if (!index4 || !eq2(computed, seen)) {
              var seen = computed;
              result2[resIndex++] = value === 0 ? 0 : value;
            }
          }
          return result2;
        }
        function baseToNumber(value) {
          if (typeof value == "number") {
            return value;
          }
          if (isSymbol(value)) {
            return NAN;
          }
          return +value;
        }
        function baseToString(value) {
          if (typeof value == "string") {
            return value;
          }
          if (isArray2(value)) {
            return arrayMap(value, baseToString) + "";
          }
          if (isSymbol(value)) {
            return symbolToString ? symbolToString.call(value) : "";
          }
          var result2 = value + "";
          return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
        }
        function baseUniq(array4, iteratee2, comparator) {
          var index4 = -1, includes2 = arrayIncludes, length2 = array4.length, isCommon = true, result2 = [], seen = result2;
          if (comparator) {
            isCommon = false;
            includes2 = arrayIncludesWith;
          } else if (length2 >= LARGE_ARRAY_SIZE2) {
            var set3 = iteratee2 ? null : createSet(array4);
            if (set3) {
              return setToArray(set3);
            }
            isCommon = false;
            includes2 = cacheHas;
            seen = new SetCache();
          } else {
            seen = iteratee2 ? [] : result2;
          }
          outer:
            while (++index4 < length2) {
              var value = array4[index4], computed = iteratee2 ? iteratee2(value) : value;
              value = comparator || value !== 0 ? value : 0;
              if (isCommon && computed === computed) {
                var seenIndex = seen.length;
                while (seenIndex--) {
                  if (seen[seenIndex] === computed) {
                    continue outer;
                  }
                }
                if (iteratee2) {
                  seen.push(computed);
                }
                result2.push(value);
              } else if (!includes2(seen, computed, comparator)) {
                if (seen !== result2) {
                  seen.push(computed);
                }
                result2.push(value);
              }
            }
          return result2;
        }
        function baseUnset(object, path) {
          path = castPath(path, object);
          object = parent(object, path);
          return object == null || delete object[toKey(last(path))];
        }
        function baseUpdate(object, path, updater, customizer) {
          return baseSet(object, path, updater(baseGet(object, path)), customizer);
        }
        function baseWhile(array4, predicate, isDrop, fromRight) {
          var length2 = array4.length, index4 = fromRight ? length2 : -1;
          while ((fromRight ? index4-- : ++index4 < length2) && predicate(array4[index4], index4, array4)) {
          }
          return isDrop ? baseSlice(array4, fromRight ? 0 : index4, fromRight ? index4 + 1 : length2) : baseSlice(array4, fromRight ? index4 + 1 : 0, fromRight ? length2 : index4);
        }
        function baseWrapperValue(value, actions) {
          var result2 = value;
          if (result2 instanceof LazyWrapper) {
            result2 = result2.value();
          }
          return arrayReduce(actions, function(result3, action) {
            return action.func.apply(action.thisArg, arrayPush([result3], action.args));
          }, result2);
        }
        function baseXor(arrays, iteratee2, comparator) {
          var length2 = arrays.length;
          if (length2 < 2) {
            return length2 ? baseUniq(arrays[0]) : [];
          }
          var index4 = -1, result2 = Array2(length2);
          while (++index4 < length2) {
            var array4 = arrays[index4], othIndex = -1;
            while (++othIndex < length2) {
              if (othIndex != index4) {
                result2[index4] = baseDifference(result2[index4] || array4, arrays[othIndex], iteratee2, comparator);
              }
            }
          }
          return baseUniq(baseFlatten(result2, 1), iteratee2, comparator);
        }
        function baseZipObject(props, values2, assignFunc) {
          var index4 = -1, length2 = props.length, valsLength = values2.length, result2 = {};
          while (++index4 < length2) {
            var value = index4 < valsLength ? values2[index4] : undefined2;
            assignFunc(result2, props[index4], value);
          }
          return result2;
        }
        function castArrayLikeObject(value) {
          return isArrayLikeObject2(value) ? value : [];
        }
        function castFunction(value) {
          return typeof value == "function" ? value : identity2;
        }
        function castPath(value, object) {
          if (isArray2(value)) {
            return value;
          }
          return isKey(value, object) ? [value] : stringToPath(toString2(value));
        }
        var castRest = baseRest2;
        function castSlice(array4, start, end) {
          var length2 = array4.length;
          end = end === undefined2 ? length2 : end;
          return !start && end >= length2 ? array4 : baseSlice(array4, start, end);
        }
        var clearTimeout2 = ctxClearTimeout || function(id) {
          return root2.clearTimeout(id);
        };
        function cloneBuffer2(buffer3, isDeep) {
          if (isDeep) {
            return buffer3.slice();
          }
          var length2 = buffer3.length, result2 = allocUnsafe ? allocUnsafe(length2) : new buffer3.constructor(length2);
          buffer3.copy(result2);
          return result2;
        }
        function cloneArrayBuffer2(arrayBuffer) {
          var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
          new Uint8Array2(result2).set(new Uint8Array2(arrayBuffer));
          return result2;
        }
        function cloneDataView(dataView, isDeep) {
          var buffer3 = isDeep ? cloneArrayBuffer2(dataView.buffer) : dataView.buffer;
          return new dataView.constructor(buffer3, dataView.byteOffset, dataView.byteLength);
        }
        function cloneRegExp(regexp) {
          var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
          result2.lastIndex = regexp.lastIndex;
          return result2;
        }
        function cloneSymbol(symbol) {
          return symbolValueOf ? Object2(symbolValueOf.call(symbol)) : {};
        }
        function cloneTypedArray2(typedArray, isDeep) {
          var buffer3 = isDeep ? cloneArrayBuffer2(typedArray.buffer) : typedArray.buffer;
          return new typedArray.constructor(buffer3, typedArray.byteOffset, typedArray.length);
        }
        function compareAscending(value, other) {
          if (value !== other) {
            var valIsDefined = value !== undefined2, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
            var othIsDefined = other !== undefined2, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
            if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
              return 1;
            }
            if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
              return -1;
            }
          }
          return 0;
        }
        function compareMultiple(object, other, orders) {
          var index4 = -1, objCriteria = object.criteria, othCriteria = other.criteria, length2 = objCriteria.length, ordersLength = orders.length;
          while (++index4 < length2) {
            var result2 = compareAscending(objCriteria[index4], othCriteria[index4]);
            if (result2) {
              if (index4 >= ordersLength) {
                return result2;
              }
              var order = orders[index4];
              return result2 * (order == "desc" ? -1 : 1);
            }
          }
          return object.index - other.index;
        }
        function composeArgs(args, partials, holders, isCurried) {
          var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax2(argsLength - holdersLength, 0), result2 = Array2(leftLength + rangeLength), isUncurried = !isCurried;
          while (++leftIndex < leftLength) {
            result2[leftIndex] = partials[leftIndex];
          }
          while (++argsIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result2[holders[argsIndex]] = args[argsIndex];
            }
          }
          while (rangeLength--) {
            result2[leftIndex++] = args[argsIndex++];
          }
          return result2;
        }
        function composeArgsRight(args, partials, holders, isCurried) {
          var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax2(argsLength - holdersLength, 0), result2 = Array2(rangeLength + rightLength), isUncurried = !isCurried;
          while (++argsIndex < rangeLength) {
            result2[argsIndex] = args[argsIndex];
          }
          var offset3 = argsIndex;
          while (++rightIndex < rightLength) {
            result2[offset3 + rightIndex] = partials[rightIndex];
          }
          while (++holdersIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result2[offset3 + holders[holdersIndex]] = args[argsIndex++];
            }
          }
          return result2;
        }
        function copyArray2(source, array4) {
          var index4 = -1, length2 = source.length;
          array4 || (array4 = Array2(length2));
          while (++index4 < length2) {
            array4[index4] = source[index4];
          }
          return array4;
        }
        function copyObject2(source, props, object, customizer) {
          var isNew = !object;
          object || (object = {});
          var index4 = -1, length2 = props.length;
          while (++index4 < length2) {
            var key = props[index4];
            var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined2;
            if (newValue === undefined2) {
              newValue = source[key];
            }
            if (isNew) {
              baseAssignValue2(object, key, newValue);
            } else {
              assignValue2(object, key, newValue);
            }
          }
          return object;
        }
        function copySymbols(source, object) {
          return copyObject2(source, getSymbols(source), object);
        }
        function copySymbolsIn(source, object) {
          return copyObject2(source, getSymbolsIn(source), object);
        }
        function createAggregator(setter, initializer) {
          return function(collection, iteratee2) {
            var func = isArray2(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
            return func(collection, setter, getIteratee(iteratee2, 2), accumulator);
          };
        }
        function createAssigner2(assigner) {
          return baseRest2(function(object, sources) {
            var index4 = -1, length2 = sources.length, customizer = length2 > 1 ? sources[length2 - 1] : undefined2, guard = length2 > 2 ? sources[2] : undefined2;
            customizer = assigner.length > 3 && typeof customizer == "function" ? (length2--, customizer) : undefined2;
            if (guard && isIterateeCall2(sources[0], sources[1], guard)) {
              customizer = length2 < 3 ? undefined2 : customizer;
              length2 = 1;
            }
            object = Object2(object);
            while (++index4 < length2) {
              var source = sources[index4];
              if (source) {
                assigner(object, source, index4, customizer);
              }
            }
            return object;
          });
        }
        function createBaseEach(eachFunc, fromRight) {
          return function(collection, iteratee2) {
            if (collection == null) {
              return collection;
            }
            if (!isArrayLike2(collection)) {
              return eachFunc(collection, iteratee2);
            }
            var length2 = collection.length, index4 = fromRight ? length2 : -1, iterable = Object2(collection);
            while (fromRight ? index4-- : ++index4 < length2) {
              if (iteratee2(iterable[index4], index4, iterable) === false) {
                break;
              }
            }
            return collection;
          };
        }
        function createBaseFor2(fromRight) {
          return function(object, iteratee2, keysFunc) {
            var index4 = -1, iterable = Object2(object), props = keysFunc(object), length2 = props.length;
            while (length2--) {
              var key = props[fromRight ? length2 : ++index4];
              if (iteratee2(iterable[key], key, iterable) === false) {
                break;
              }
            }
            return object;
          };
        }
        function createBind(func, bitmask, thisArg) {
          var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
          function wrapper() {
            var fn = this && this !== root2 && this instanceof wrapper ? Ctor : func;
            return fn.apply(isBind ? thisArg : this, arguments);
          }
          return wrapper;
        }
        function createCaseFirst(methodName) {
          return function(string3) {
            string3 = toString2(string3);
            var strSymbols = hasUnicode(string3) ? stringToArray(string3) : undefined2;
            var chr = strSymbols ? strSymbols[0] : string3.charAt(0);
            var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string3.slice(1);
            return chr[methodName]() + trailing;
          };
        }
        function createCompounder(callback) {
          return function(string3) {
            return arrayReduce(words(deburr(string3).replace(reApos, "")), callback, "");
          };
        }
        function createCtor(Ctor) {
          return function() {
            var args = arguments;
            switch (args.length) {
              case 0:
                return new Ctor();
              case 1:
                return new Ctor(args[0]);
              case 2:
                return new Ctor(args[0], args[1]);
              case 3:
                return new Ctor(args[0], args[1], args[2]);
              case 4:
                return new Ctor(args[0], args[1], args[2], args[3]);
              case 5:
                return new Ctor(args[0], args[1], args[2], args[3], args[4]);
              case 6:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
              case 7:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
            }
            var thisBinding = baseCreate2(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
            return isObject4(result2) ? result2 : thisBinding;
          };
        }
        function createCurry(func, bitmask, arity) {
          var Ctor = createCtor(func);
          function wrapper() {
            var length2 = arguments.length, args = Array2(length2), index4 = length2, placeholder = getHolder(wrapper);
            while (index4--) {
              args[index4] = arguments[index4];
            }
            var holders = length2 < 3 && args[0] !== placeholder && args[length2 - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
            length2 -= holders.length;
            if (length2 < arity) {
              return createRecurry(
                func,
                bitmask,
                createHybrid,
                wrapper.placeholder,
                undefined2,
                args,
                holders,
                undefined2,
                undefined2,
                arity - length2
              );
            }
            var fn = this && this !== root2 && this instanceof wrapper ? Ctor : func;
            return apply2(fn, this, args);
          }
          return wrapper;
        }
        function createFind(findIndexFunc) {
          return function(collection, predicate, fromIndex) {
            var iterable = Object2(collection);
            if (!isArrayLike2(collection)) {
              var iteratee2 = getIteratee(predicate, 3);
              collection = keys(collection);
              predicate = function(key) {
                return iteratee2(iterable[key], key, iterable);
              };
            }
            var index4 = findIndexFunc(collection, predicate, fromIndex);
            return index4 > -1 ? iterable[iteratee2 ? collection[index4] : index4] : undefined2;
          };
        }
        function createFlow(fromRight) {
          return flatRest(function(funcs) {
            var length2 = funcs.length, index4 = length2, prereq = LodashWrapper.prototype.thru;
            if (fromRight) {
              funcs.reverse();
            }
            while (index4--) {
              var func = funcs[index4];
              if (typeof func != "function") {
                throw new TypeError2(FUNC_ERROR_TEXT);
              }
              if (prereq && !wrapper && getFuncName(func) == "wrapper") {
                var wrapper = new LodashWrapper([], true);
              }
            }
            index4 = wrapper ? index4 : length2;
            while (++index4 < length2) {
              func = funcs[index4];
              var funcName = getFuncName(func), data = funcName == "wrapper" ? getData(func) : undefined2;
              if (data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && data[9] == 1) {
                wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
              } else {
                wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
              }
            }
            return function() {
              var args = arguments, value = args[0];
              if (wrapper && args.length == 1 && isArray2(value)) {
                return wrapper.plant(value).value();
              }
              var index5 = 0, result2 = length2 ? funcs[index5].apply(this, args) : value;
              while (++index5 < length2) {
                result2 = funcs[index5].call(this, result2);
              }
              return result2;
            };
          });
        }
        function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
          var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined2 : createCtor(func);
          function wrapper() {
            var length2 = arguments.length, args = Array2(length2), index4 = length2;
            while (index4--) {
              args[index4] = arguments[index4];
            }
            if (isCurried) {
              var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
            }
            if (partials) {
              args = composeArgs(args, partials, holders, isCurried);
            }
            if (partialsRight) {
              args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
            }
            length2 -= holdersCount;
            if (isCurried && length2 < arity) {
              var newHolders = replaceHolders(args, placeholder);
              return createRecurry(
                func,
                bitmask,
                createHybrid,
                wrapper.placeholder,
                thisArg,
                args,
                newHolders,
                argPos,
                ary2,
                arity - length2
              );
            }
            var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
            length2 = args.length;
            if (argPos) {
              args = reorder(args, argPos);
            } else if (isFlip && length2 > 1) {
              args.reverse();
            }
            if (isAry && ary2 < length2) {
              args.length = ary2;
            }
            if (this && this !== root2 && this instanceof wrapper) {
              fn = Ctor || createCtor(fn);
            }
            return fn.apply(thisBinding, args);
          }
          return wrapper;
        }
        function createInverter(setter, toIteratee) {
          return function(object, iteratee2) {
            return baseInverter(object, setter, toIteratee(iteratee2), {});
          };
        }
        function createMathOperation(operator, defaultValue) {
          return function(value, other) {
            var result2;
            if (value === undefined2 && other === undefined2) {
              return defaultValue;
            }
            if (value !== undefined2) {
              result2 = value;
            }
            if (other !== undefined2) {
              if (result2 === undefined2) {
                return other;
              }
              if (typeof value == "string" || typeof other == "string") {
                value = baseToString(value);
                other = baseToString(other);
              } else {
                value = baseToNumber(value);
                other = baseToNumber(other);
              }
              result2 = operator(value, other);
            }
            return result2;
          };
        }
        function createOver(arrayFunc) {
          return flatRest(function(iteratees) {
            iteratees = arrayMap(iteratees, baseUnary2(getIteratee()));
            return baseRest2(function(args) {
              var thisArg = this;
              return arrayFunc(iteratees, function(iteratee2) {
                return apply2(iteratee2, thisArg, args);
              });
            });
          });
        }
        function createPadding(length2, chars) {
          chars = chars === undefined2 ? " " : baseToString(chars);
          var charsLength = chars.length;
          if (charsLength < 2) {
            return charsLength ? baseRepeat(chars, length2) : chars;
          }
          var result2 = baseRepeat(chars, nativeCeil(length2 / stringSize(chars)));
          return hasUnicode(chars) ? castSlice(stringToArray(result2), 0, length2).join("") : result2.slice(0, length2);
        }
        function createPartial(func, bitmask, thisArg, partials) {
          var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
          function wrapper() {
            var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array2(leftLength + argsLength), fn = this && this !== root2 && this instanceof wrapper ? Ctor : func;
            while (++leftIndex < leftLength) {
              args[leftIndex] = partials[leftIndex];
            }
            while (argsLength--) {
              args[leftIndex++] = arguments[++argsIndex];
            }
            return apply2(fn, isBind ? thisArg : this, args);
          }
          return wrapper;
        }
        function createRange(fromRight) {
          return function(start, end, step) {
            if (step && typeof step != "number" && isIterateeCall2(start, end, step)) {
              end = step = undefined2;
            }
            start = toFinite(start);
            if (end === undefined2) {
              end = start;
              start = 0;
            } else {
              end = toFinite(end);
            }
            step = step === undefined2 ? start < end ? 1 : -1 : toFinite(step);
            return baseRange(start, end, step, fromRight);
          };
        }
        function createRelationalOperation(operator) {
          return function(value, other) {
            if (!(typeof value == "string" && typeof other == "string")) {
              value = toNumber(value);
              other = toNumber(other);
            }
            return operator(value, other);
          };
        }
        function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
          var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined2, newHoldersRight = isCurry ? undefined2 : holders, newPartials = isCurry ? partials : undefined2, newPartialsRight = isCurry ? undefined2 : partials;
          bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
          bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
          if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
            bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
          }
          var newData = [
            func,
            bitmask,
            thisArg,
            newPartials,
            newHolders,
            newPartialsRight,
            newHoldersRight,
            argPos,
            ary2,
            arity
          ];
          var result2 = wrapFunc.apply(undefined2, newData);
          if (isLaziable(func)) {
            setData(result2, newData);
          }
          result2.placeholder = placeholder;
          return setWrapToString(result2, func, bitmask);
        }
        function createRound(methodName) {
          var func = Math2[methodName];
          return function(number5, precision) {
            number5 = toNumber(number5);
            precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
            if (precision && nativeIsFinite(number5)) {
              var pair = (toString2(number5) + "e").split("e"), value = func(pair[0] + "e" + (+pair[1] + precision));
              pair = (toString2(value) + "e").split("e");
              return +(pair[0] + "e" + (+pair[1] - precision));
            }
            return func(number5);
          };
        }
        var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop : function(values2) {
          return new Set2(values2);
        };
        function createToPairs(keysFunc) {
          return function(object) {
            var tag = getTag(object);
            if (tag == mapTag2) {
              return mapToArray(object);
            }
            if (tag == setTag2) {
              return setToPairs(object);
            }
            return baseToPairs(object, keysFunc(object));
          };
        }
        function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
          var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
          if (!isBindKey && typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          var length2 = partials ? partials.length : 0;
          if (!length2) {
            bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
            partials = holders = undefined2;
          }
          ary2 = ary2 === undefined2 ? ary2 : nativeMax2(toInteger(ary2), 0);
          arity = arity === undefined2 ? arity : toInteger(arity);
          length2 -= holders ? holders.length : 0;
          if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
            var partialsRight = partials, holdersRight = holders;
            partials = holders = undefined2;
          }
          var data = isBindKey ? undefined2 : getData(func);
          var newData = [
            func,
            bitmask,
            thisArg,
            partials,
            holders,
            partialsRight,
            holdersRight,
            argPos,
            ary2,
            arity
          ];
          if (data) {
            mergeData(newData, data);
          }
          func = newData[0];
          bitmask = newData[1];
          thisArg = newData[2];
          partials = newData[3];
          holders = newData[4];
          arity = newData[9] = newData[9] === undefined2 ? isBindKey ? 0 : func.length : nativeMax2(newData[9] - length2, 0);
          if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
            bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
          }
          if (!bitmask || bitmask == WRAP_BIND_FLAG) {
            var result2 = createBind(func, bitmask, thisArg);
          } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
            result2 = createCurry(func, bitmask, arity);
          } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
            result2 = createPartial(func, bitmask, thisArg, partials);
          } else {
            result2 = createHybrid.apply(undefined2, newData);
          }
          var setter = data ? baseSetData : setData;
          return setWrapToString(setter(result2, newData), func, bitmask);
        }
        function customDefaultsAssignIn(objValue, srcValue, key, object) {
          if (objValue === undefined2 || eq2(objValue, objectProto2[key]) && !hasOwnProperty2.call(object, key)) {
            return srcValue;
          }
          return objValue;
        }
        function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
          if (isObject4(objValue) && isObject4(srcValue)) {
            stack.set(srcValue, objValue);
            baseMerge2(objValue, srcValue, undefined2, customDefaultsMerge, stack);
            stack["delete"](srcValue);
          }
          return objValue;
        }
        function customOmitClone(value) {
          return isPlainObject2(value) ? undefined2 : value;
        }
        function equalArrays(array4, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array4.length, othLength = other.length;
          if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
            return false;
          }
          var arrStacked = stack.get(array4);
          var othStacked = stack.get(other);
          if (arrStacked && othStacked) {
            return arrStacked == other && othStacked == array4;
          }
          var index4 = -1, result2 = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined2;
          stack.set(array4, other);
          stack.set(other, array4);
          while (++index4 < arrLength) {
            var arrValue = array4[index4], othValue = other[index4];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, arrValue, index4, other, array4, stack) : customizer(arrValue, othValue, index4, array4, other, stack);
            }
            if (compared !== undefined2) {
              if (compared) {
                continue;
              }
              result2 = false;
              break;
            }
            if (seen) {
              if (!arraySome(other, function(othValue2, othIndex) {
                if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                  return seen.push(othIndex);
                }
              })) {
                result2 = false;
                break;
              }
            } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
              result2 = false;
              break;
            }
          }
          stack["delete"](array4);
          stack["delete"](other);
          return result2;
        }
        function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
          switch (tag) {
            case dataViewTag2:
              if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
                return false;
              }
              object = object.buffer;
              other = other.buffer;
            case arrayBufferTag2:
              if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
                return false;
              }
              return true;
            case boolTag2:
            case dateTag2:
            case numberTag2:
              return eq2(+object, +other);
            case errorTag2:
              return object.name == other.name && object.message == other.message;
            case regexpTag2:
            case stringTag2:
              return object == other + "";
            case mapTag2:
              var convert = mapToArray;
            case setTag2:
              var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
              convert || (convert = setToArray);
              if (object.size != other.size && !isPartial) {
                return false;
              }
              var stacked = stack.get(object);
              if (stacked) {
                return stacked == other;
              }
              bitmask |= COMPARE_UNORDERED_FLAG;
              stack.set(object, other);
              var result2 = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
              stack["delete"](object);
              return result2;
            case symbolTag:
              if (symbolValueOf) {
                return symbolValueOf.call(object) == symbolValueOf.call(other);
              }
          }
          return false;
        }
        function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
          if (objLength != othLength && !isPartial) {
            return false;
          }
          var index4 = objLength;
          while (index4--) {
            var key = objProps[index4];
            if (!(isPartial ? key in other : hasOwnProperty2.call(other, key))) {
              return false;
            }
          }
          var objStacked = stack.get(object);
          var othStacked = stack.get(other);
          if (objStacked && othStacked) {
            return objStacked == other && othStacked == object;
          }
          var result2 = true;
          stack.set(object, other);
          stack.set(other, object);
          var skipCtor = isPartial;
          while (++index4 < objLength) {
            key = objProps[index4];
            var objValue = object[key], othValue = other[key];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
            }
            if (!(compared === undefined2 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
              result2 = false;
              break;
            }
            skipCtor || (skipCtor = key == "constructor");
          }
          if (result2 && !skipCtor) {
            var objCtor = object.constructor, othCtor = other.constructor;
            if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
              result2 = false;
            }
          }
          stack["delete"](object);
          stack["delete"](other);
          return result2;
        }
        function flatRest(func) {
          return setToString2(overRest2(func, undefined2, flatten), func + "");
        }
        function getAllKeys(object) {
          return baseGetAllKeys(object, keys, getSymbols);
        }
        function getAllKeysIn(object) {
          return baseGetAllKeys(object, keysIn2, getSymbolsIn);
        }
        var getData = !metaMap ? noop : function(func) {
          return metaMap.get(func);
        };
        function getFuncName(func) {
          var result2 = func.name + "", array4 = realNames[result2], length2 = hasOwnProperty2.call(realNames, result2) ? array4.length : 0;
          while (length2--) {
            var data = array4[length2], otherFunc = data.func;
            if (otherFunc == null || otherFunc == func) {
              return data.name;
            }
          }
          return result2;
        }
        function getHolder(func) {
          var object = hasOwnProperty2.call(lodash, "placeholder") ? lodash : func;
          return object.placeholder;
        }
        function getIteratee() {
          var result2 = lodash.iteratee || iteratee;
          result2 = result2 === iteratee ? baseIteratee : result2;
          return arguments.length ? result2(arguments[0], arguments[1]) : result2;
        }
        function getMapData2(map2, key) {
          var data = map2.__data__;
          return isKeyable2(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
        }
        function getMatchData(object) {
          var result2 = keys(object), length2 = result2.length;
          while (length2--) {
            var key = result2[length2], value = object[key];
            result2[length2] = [key, value, isStrictComparable(value)];
          }
          return result2;
        }
        function getNative2(object, key) {
          var value = getValue2(object, key);
          return baseIsNative2(value) ? value : undefined2;
        }
        function getRawTag2(value) {
          var isOwn = hasOwnProperty2.call(value, symToStringTag2), tag = value[symToStringTag2];
          try {
            value[symToStringTag2] = undefined2;
            var unmasked = true;
          } catch (e) {
          }
          var result2 = nativeObjectToString2.call(value);
          if (unmasked) {
            if (isOwn) {
              value[symToStringTag2] = tag;
            } else {
              delete value[symToStringTag2];
            }
          }
          return result2;
        }
        var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
          if (object == null) {
            return [];
          }
          object = Object2(object);
          return arrayFilter(nativeGetSymbols(object), function(symbol) {
            return propertyIsEnumerable2.call(object, symbol);
          });
        };
        var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
          var result2 = [];
          while (object) {
            arrayPush(result2, getSymbols(object));
            object = getPrototype2(object);
          }
          return result2;
        };
        var getTag = baseGetTag2;
        if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag2 || Map2 && getTag(new Map2()) != mapTag2 || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag2 || WeakMap2 && getTag(new WeakMap2()) != weakMapTag2) {
          getTag = function(value) {
            var result2 = baseGetTag2(value), Ctor = result2 == objectTag2 ? value.constructor : undefined2, ctorString = Ctor ? toSource2(Ctor) : "";
            if (ctorString) {
              switch (ctorString) {
                case dataViewCtorString:
                  return dataViewTag2;
                case mapCtorString:
                  return mapTag2;
                case promiseCtorString:
                  return promiseTag;
                case setCtorString:
                  return setTag2;
                case weakMapCtorString:
                  return weakMapTag2;
              }
            }
            return result2;
          };
        }
        function getView(start, end, transforms) {
          var index4 = -1, length2 = transforms.length;
          while (++index4 < length2) {
            var data = transforms[index4], size5 = data.size;
            switch (data.type) {
              case "drop":
                start += size5;
                break;
              case "dropRight":
                end -= size5;
                break;
              case "take":
                end = nativeMin(end, start + size5);
                break;
              case "takeRight":
                start = nativeMax2(start, end - size5);
                break;
            }
          }
          return { "start": start, "end": end };
        }
        function getWrapDetails(source) {
          var match = source.match(reWrapDetails);
          return match ? match[1].split(reSplitDetails) : [];
        }
        function hasPath(object, path, hasFunc) {
          path = castPath(path, object);
          var index4 = -1, length2 = path.length, result2 = false;
          while (++index4 < length2) {
            var key = toKey(path[index4]);
            if (!(result2 = object != null && hasFunc(object, key))) {
              break;
            }
            object = object[key];
          }
          if (result2 || ++index4 != length2) {
            return result2;
          }
          length2 = object == null ? 0 : object.length;
          return !!length2 && isLength2(length2) && isIndex2(key, length2) && (isArray2(object) || isArguments2(object));
        }
        function initCloneArray(array4) {
          var length2 = array4.length, result2 = new array4.constructor(length2);
          if (length2 && typeof array4[0] == "string" && hasOwnProperty2.call(array4, "index")) {
            result2.index = array4.index;
            result2.input = array4.input;
          }
          return result2;
        }
        function initCloneObject2(object) {
          return typeof object.constructor == "function" && !isPrototype2(object) ? baseCreate2(getPrototype2(object)) : {};
        }
        function initCloneByTag(object, tag, isDeep) {
          var Ctor = object.constructor;
          switch (tag) {
            case arrayBufferTag2:
              return cloneArrayBuffer2(object);
            case boolTag2:
            case dateTag2:
              return new Ctor(+object);
            case dataViewTag2:
              return cloneDataView(object, isDeep);
            case float32Tag2:
            case float64Tag2:
            case int8Tag2:
            case int16Tag2:
            case int32Tag2:
            case uint8Tag2:
            case uint8ClampedTag2:
            case uint16Tag2:
            case uint32Tag2:
              return cloneTypedArray2(object, isDeep);
            case mapTag2:
              return new Ctor();
            case numberTag2:
            case stringTag2:
              return new Ctor(object);
            case regexpTag2:
              return cloneRegExp(object);
            case setTag2:
              return new Ctor();
            case symbolTag:
              return cloneSymbol(object);
          }
        }
        function insertWrapDetails(source, details) {
          var length2 = details.length;
          if (!length2) {
            return source;
          }
          var lastIndex = length2 - 1;
          details[lastIndex] = (length2 > 1 ? "& " : "") + details[lastIndex];
          details = details.join(length2 > 2 ? ", " : " ");
          return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
        }
        function isFlattenable(value) {
          return isArray2(value) || isArguments2(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
        }
        function isIndex2(value, length2) {
          var type3 = typeof value;
          length2 = length2 == null ? MAX_SAFE_INTEGER3 : length2;
          return !!length2 && (type3 == "number" || type3 != "symbol" && reIsUint2.test(value)) && (value > -1 && value % 1 == 0 && value < length2);
        }
        function isIterateeCall2(value, index4, object) {
          if (!isObject4(object)) {
            return false;
          }
          var type3 = typeof index4;
          if (type3 == "number" ? isArrayLike2(object) && isIndex2(index4, object.length) : type3 == "string" && index4 in object) {
            return eq2(object[index4], value);
          }
          return false;
        }
        function isKey(value, object) {
          if (isArray2(value)) {
            return false;
          }
          var type3 = typeof value;
          if (type3 == "number" || type3 == "symbol" || type3 == "boolean" || value == null || isSymbol(value)) {
            return true;
          }
          return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object2(object);
        }
        function isKeyable2(value) {
          var type3 = typeof value;
          return type3 == "string" || type3 == "number" || type3 == "symbol" || type3 == "boolean" ? value !== "__proto__" : value === null;
        }
        function isLaziable(func) {
          var funcName = getFuncName(func), other = lodash[funcName];
          if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
            return false;
          }
          if (func === other) {
            return true;
          }
          var data = getData(other);
          return !!data && func === data[0];
        }
        function isMasked2(func) {
          return !!maskSrcKey2 && maskSrcKey2 in func;
        }
        var isMaskable = coreJsData2 ? isFunction2 : stubFalse2;
        function isPrototype2(value) {
          var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto2;
          return value === proto;
        }
        function isStrictComparable(value) {
          return value === value && !isObject4(value);
        }
        function matchesStrictComparable(key, srcValue) {
          return function(object) {
            if (object == null) {
              return false;
            }
            return object[key] === srcValue && (srcValue !== undefined2 || key in Object2(object));
          };
        }
        function memoizeCapped(func) {
          var result2 = memoize(func, function(key) {
            if (cache2.size === MAX_MEMOIZE_SIZE) {
              cache2.clear();
            }
            return key;
          });
          var cache2 = result2.cache;
          return result2;
        }
        function mergeData(data, source) {
          var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
          var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
          if (!(isCommon || isCombo)) {
            return data;
          }
          if (srcBitmask & WRAP_BIND_FLAG) {
            data[2] = source[2];
            newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
          }
          var value = source[3];
          if (value) {
            var partials = data[3];
            data[3] = partials ? composeArgs(partials, value, source[4]) : value;
            data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
          }
          value = source[5];
          if (value) {
            partials = data[5];
            data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
            data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
          }
          value = source[7];
          if (value) {
            data[7] = value;
          }
          if (srcBitmask & WRAP_ARY_FLAG) {
            data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
          }
          if (data[9] == null) {
            data[9] = source[9];
          }
          data[0] = source[0];
          data[1] = newBitmask;
          return data;
        }
        function nativeKeysIn2(object) {
          var result2 = [];
          if (object != null) {
            for (var key in Object2(object)) {
              result2.push(key);
            }
          }
          return result2;
        }
        function objectToString2(value) {
          return nativeObjectToString2.call(value);
        }
        function overRest2(func, start, transform2) {
          start = nativeMax2(start === undefined2 ? func.length - 1 : start, 0);
          return function() {
            var args = arguments, index4 = -1, length2 = nativeMax2(args.length - start, 0), array4 = Array2(length2);
            while (++index4 < length2) {
              array4[index4] = args[start + index4];
            }
            index4 = -1;
            var otherArgs = Array2(start + 1);
            while (++index4 < start) {
              otherArgs[index4] = args[index4];
            }
            otherArgs[start] = transform2(array4);
            return apply2(func, this, otherArgs);
          };
        }
        function parent(object, path) {
          return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
        }
        function reorder(array4, indexes) {
          var arrLength = array4.length, length2 = nativeMin(indexes.length, arrLength), oldArray = copyArray2(array4);
          while (length2--) {
            var index4 = indexes[length2];
            array4[length2] = isIndex2(index4, arrLength) ? oldArray[index4] : undefined2;
          }
          return array4;
        }
        function safeGet2(object, key) {
          if (key === "constructor" && typeof object[key] === "function") {
            return;
          }
          if (key == "__proto__") {
            return;
          }
          return object[key];
        }
        var setData = shortOut2(baseSetData);
        var setTimeout2 = ctxSetTimeout || function(func, wait3) {
          return root2.setTimeout(func, wait3);
        };
        var setToString2 = shortOut2(baseSetToString2);
        function setWrapToString(wrapper, reference, bitmask) {
          var source = reference + "";
          return setToString2(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
        }
        function shortOut2(func) {
          var count = 0, lastCalled = 0;
          return function() {
            var stamp = nativeNow2(), remaining = HOT_SPAN2 - (stamp - lastCalled);
            lastCalled = stamp;
            if (remaining > 0) {
              if (++count >= HOT_COUNT2) {
                return arguments[0];
              }
            } else {
              count = 0;
            }
            return func.apply(undefined2, arguments);
          };
        }
        function shuffleSelf(array4, size5) {
          var index4 = -1, length2 = array4.length, lastIndex = length2 - 1;
          size5 = size5 === undefined2 ? length2 : size5;
          while (++index4 < size5) {
            var rand = baseRandom(index4, lastIndex), value = array4[rand];
            array4[rand] = array4[index4];
            array4[index4] = value;
          }
          array4.length = size5;
          return array4;
        }
        var stringToPath = memoizeCapped(function(string3) {
          var result2 = [];
          if (string3.charCodeAt(0) === 46) {
            result2.push("");
          }
          string3.replace(rePropName, function(match, number5, quote, subString) {
            result2.push(quote ? subString.replace(reEscapeChar, "$1") : number5 || match);
          });
          return result2;
        });
        function toKey(value) {
          if (typeof value == "string" || isSymbol(value)) {
            return value;
          }
          var result2 = value + "";
          return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
        }
        function toSource2(func) {
          if (func != null) {
            try {
              return funcToString2.call(func);
            } catch (e) {
            }
            try {
              return func + "";
            } catch (e) {
            }
          }
          return "";
        }
        function updateWrapDetails(details, bitmask) {
          arrayEach(wrapFlags, function(pair) {
            var value = "_." + pair[0];
            if (bitmask & pair[1] && !arrayIncludes(details, value)) {
              details.push(value);
            }
          });
          return details.sort();
        }
        function wrapperClone(wrapper) {
          if (wrapper instanceof LazyWrapper) {
            return wrapper.clone();
          }
          var result2 = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
          result2.__actions__ = copyArray2(wrapper.__actions__);
          result2.__index__ = wrapper.__index__;
          result2.__values__ = wrapper.__values__;
          return result2;
        }
        function chunk(array4, size5, guard) {
          if (guard ? isIterateeCall2(array4, size5, guard) : size5 === undefined2) {
            size5 = 1;
          } else {
            size5 = nativeMax2(toInteger(size5), 0);
          }
          var length2 = array4 == null ? 0 : array4.length;
          if (!length2 || size5 < 1) {
            return [];
          }
          var index4 = 0, resIndex = 0, result2 = Array2(nativeCeil(length2 / size5));
          while (index4 < length2) {
            result2[resIndex++] = baseSlice(array4, index4, index4 += size5);
          }
          return result2;
        }
        function compact(array4) {
          var index4 = -1, length2 = array4 == null ? 0 : array4.length, resIndex = 0, result2 = [];
          while (++index4 < length2) {
            var value = array4[index4];
            if (value) {
              result2[resIndex++] = value;
            }
          }
          return result2;
        }
        function concat3() {
          var length2 = arguments.length;
          if (!length2) {
            return [];
          }
          var args = Array2(length2 - 1), array4 = arguments[0], index4 = length2;
          while (index4--) {
            args[index4 - 1] = arguments[index4];
          }
          return arrayPush(isArray2(array4) ? copyArray2(array4) : [array4], baseFlatten(args, 1));
        }
        var difference = baseRest2(function(array4, values2) {
          return isArrayLikeObject2(array4) ? baseDifference(array4, baseFlatten(values2, 1, isArrayLikeObject2, true)) : [];
        });
        var differenceBy = baseRest2(function(array4, values2) {
          var iteratee2 = last(values2);
          if (isArrayLikeObject2(iteratee2)) {
            iteratee2 = undefined2;
          }
          return isArrayLikeObject2(array4) ? baseDifference(array4, baseFlatten(values2, 1, isArrayLikeObject2, true), getIteratee(iteratee2, 2)) : [];
        });
        var differenceWith = baseRest2(function(array4, values2) {
          var comparator = last(values2);
          if (isArrayLikeObject2(comparator)) {
            comparator = undefined2;
          }
          return isArrayLikeObject2(array4) ? baseDifference(array4, baseFlatten(values2, 1, isArrayLikeObject2, true), undefined2, comparator) : [];
        });
        function drop(array4, n, guard) {
          var length2 = array4 == null ? 0 : array4.length;
          if (!length2) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger(n);
          return baseSlice(array4, n < 0 ? 0 : n, length2);
        }
        function dropRight(array4, n, guard) {
          var length2 = array4 == null ? 0 : array4.length;
          if (!length2) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger(n);
          n = length2 - n;
          return baseSlice(array4, 0, n < 0 ? 0 : n);
        }
        function dropRightWhile(array4, predicate) {
          return array4 && array4.length ? baseWhile(array4, getIteratee(predicate, 3), true, true) : [];
        }
        function dropWhile(array4, predicate) {
          return array4 && array4.length ? baseWhile(array4, getIteratee(predicate, 3), true) : [];
        }
        function fill(array4, value, start, end) {
          var length2 = array4 == null ? 0 : array4.length;
          if (!length2) {
            return [];
          }
          if (start && typeof start != "number" && isIterateeCall2(array4, value, start)) {
            start = 0;
            end = length2;
          }
          return baseFill(array4, value, start, end);
        }
        function findIndex(array4, predicate, fromIndex) {
          var length2 = array4 == null ? 0 : array4.length;
          if (!length2) {
            return -1;
          }
          var index4 = fromIndex == null ? 0 : toInteger(fromIndex);
          if (index4 < 0) {
            index4 = nativeMax2(length2 + index4, 0);
          }
          return baseFindIndex(array4, getIteratee(predicate, 3), index4);
        }
        function findLastIndex(array4, predicate, fromIndex) {
          var length2 = array4 == null ? 0 : array4.length;
          if (!length2) {
            return -1;
          }
          var index4 = length2 - 1;
          if (fromIndex !== undefined2) {
            index4 = toInteger(fromIndex);
            index4 = fromIndex < 0 ? nativeMax2(length2 + index4, 0) : nativeMin(index4, length2 - 1);
          }
          return baseFindIndex(array4, getIteratee(predicate, 3), index4, true);
        }
        function flatten(array4) {
          var length2 = array4 == null ? 0 : array4.length;
          return length2 ? baseFlatten(array4, 1) : [];
        }
        function flattenDeep(array4) {
          var length2 = array4 == null ? 0 : array4.length;
          return length2 ? baseFlatten(array4, INFINITY) : [];
        }
        function flattenDepth(array4, depth) {
          var length2 = array4 == null ? 0 : array4.length;
          if (!length2) {
            return [];
          }
          depth = depth === undefined2 ? 1 : toInteger(depth);
          return baseFlatten(array4, depth);
        }
        function fromPairs(pairs) {
          var index4 = -1, length2 = pairs == null ? 0 : pairs.length, result2 = {};
          while (++index4 < length2) {
            var pair = pairs[index4];
            result2[pair[0]] = pair[1];
          }
          return result2;
        }
        function head(array4) {
          return array4 && array4.length ? array4[0] : undefined2;
        }
        function indexOf(array4, value, fromIndex) {
          var length2 = array4 == null ? 0 : array4.length;
          if (!length2) {
            return -1;
          }
          var index4 = fromIndex == null ? 0 : toInteger(fromIndex);
          if (index4 < 0) {
            index4 = nativeMax2(length2 + index4, 0);
          }
          return baseIndexOf(array4, value, index4);
        }
        function initial(array4) {
          var length2 = array4 == null ? 0 : array4.length;
          return length2 ? baseSlice(array4, 0, -1) : [];
        }
        var intersection = baseRest2(function(arrays) {
          var mapped = arrayMap(arrays, castArrayLikeObject);
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
        });
        var intersectionBy = baseRest2(function(arrays) {
          var iteratee2 = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
          if (iteratee2 === last(mapped)) {
            iteratee2 = undefined2;
          } else {
            mapped.pop();
          }
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];
        });
        var intersectionWith = baseRest2(function(arrays) {
          var comparator = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          if (comparator) {
            mapped.pop();
          }
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined2, comparator) : [];
        });
        function join2(array4, separator) {
          return array4 == null ? "" : nativeJoin.call(array4, separator);
        }
        function last(array4) {
          var length2 = array4 == null ? 0 : array4.length;
          return length2 ? array4[length2 - 1] : undefined2;
        }
        function lastIndexOf(array4, value, fromIndex) {
          var length2 = array4 == null ? 0 : array4.length;
          if (!length2) {
            return -1;
          }
          var index4 = length2;
          if (fromIndex !== undefined2) {
            index4 = toInteger(fromIndex);
            index4 = index4 < 0 ? nativeMax2(length2 + index4, 0) : nativeMin(index4, length2 - 1);
          }
          return value === value ? strictLastIndexOf(array4, value, index4) : baseFindIndex(array4, baseIsNaN, index4, true);
        }
        function nth(array4, n) {
          return array4 && array4.length ? baseNth(array4, toInteger(n)) : undefined2;
        }
        var pull = baseRest2(pullAll);
        function pullAll(array4, values2) {
          return array4 && array4.length && values2 && values2.length ? basePullAll(array4, values2) : array4;
        }
        function pullAllBy(array4, values2, iteratee2) {
          return array4 && array4.length && values2 && values2.length ? basePullAll(array4, values2, getIteratee(iteratee2, 2)) : array4;
        }
        function pullAllWith(array4, values2, comparator) {
          return array4 && array4.length && values2 && values2.length ? basePullAll(array4, values2, undefined2, comparator) : array4;
        }
        var pullAt = flatRest(function(array4, indexes) {
          var length2 = array4 == null ? 0 : array4.length, result2 = baseAt(array4, indexes);
          basePullAt(array4, arrayMap(indexes, function(index4) {
            return isIndex2(index4, length2) ? +index4 : index4;
          }).sort(compareAscending));
          return result2;
        });
        function remove(array4, predicate) {
          var result2 = [];
          if (!(array4 && array4.length)) {
            return result2;
          }
          var index4 = -1, indexes = [], length2 = array4.length;
          predicate = getIteratee(predicate, 3);
          while (++index4 < length2) {
            var value = array4[index4];
            if (predicate(value, index4, array4)) {
              result2.push(value);
              indexes.push(index4);
            }
          }
          basePullAt(array4, indexes);
          return result2;
        }
        function reverse(array4) {
          return array4 == null ? array4 : nativeReverse.call(array4);
        }
        function slice3(array4, start, end) {
          var length2 = array4 == null ? 0 : array4.length;
          if (!length2) {
            return [];
          }
          if (end && typeof end != "number" && isIterateeCall2(array4, start, end)) {
            start = 0;
            end = length2;
          } else {
            start = start == null ? 0 : toInteger(start);
            end = end === undefined2 ? length2 : toInteger(end);
          }
          return baseSlice(array4, start, end);
        }
        function sortedIndex(array4, value) {
          return baseSortedIndex(array4, value);
        }
        function sortedIndexBy(array4, value, iteratee2) {
          return baseSortedIndexBy(array4, value, getIteratee(iteratee2, 2));
        }
        function sortedIndexOf(array4, value) {
          var length2 = array4 == null ? 0 : array4.length;
          if (length2) {
            var index4 = baseSortedIndex(array4, value);
            if (index4 < length2 && eq2(array4[index4], value)) {
              return index4;
            }
          }
          return -1;
        }
        function sortedLastIndex(array4, value) {
          return baseSortedIndex(array4, value, true);
        }
        function sortedLastIndexBy(array4, value, iteratee2) {
          return baseSortedIndexBy(array4, value, getIteratee(iteratee2, 2), true);
        }
        function sortedLastIndexOf(array4, value) {
          var length2 = array4 == null ? 0 : array4.length;
          if (length2) {
            var index4 = baseSortedIndex(array4, value, true) - 1;
            if (eq2(array4[index4], value)) {
              return index4;
            }
          }
          return -1;
        }
        function sortedUniq(array4) {
          return array4 && array4.length ? baseSortedUniq(array4) : [];
        }
        function sortedUniqBy(array4, iteratee2) {
          return array4 && array4.length ? baseSortedUniq(array4, getIteratee(iteratee2, 2)) : [];
        }
        function tail(array4) {
          var length2 = array4 == null ? 0 : array4.length;
          return length2 ? baseSlice(array4, 1, length2) : [];
        }
        function take(array4, n, guard) {
          if (!(array4 && array4.length)) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger(n);
          return baseSlice(array4, 0, n < 0 ? 0 : n);
        }
        function takeRight(array4, n, guard) {
          var length2 = array4 == null ? 0 : array4.length;
          if (!length2) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger(n);
          n = length2 - n;
          return baseSlice(array4, n < 0 ? 0 : n, length2);
        }
        function takeRightWhile(array4, predicate) {
          return array4 && array4.length ? baseWhile(array4, getIteratee(predicate, 3), false, true) : [];
        }
        function takeWhile(array4, predicate) {
          return array4 && array4.length ? baseWhile(array4, getIteratee(predicate, 3)) : [];
        }
        var union3 = baseRest2(function(arrays) {
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject2, true));
        });
        var unionBy = baseRest2(function(arrays) {
          var iteratee2 = last(arrays);
          if (isArrayLikeObject2(iteratee2)) {
            iteratee2 = undefined2;
          }
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject2, true), getIteratee(iteratee2, 2));
        });
        var unionWith = baseRest2(function(arrays) {
          var comparator = last(arrays);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject2, true), undefined2, comparator);
        });
        function uniq(array4) {
          return array4 && array4.length ? baseUniq(array4) : [];
        }
        function uniqBy2(array4, iteratee2) {
          return array4 && array4.length ? baseUniq(array4, getIteratee(iteratee2, 2)) : [];
        }
        function uniqWith(array4, comparator) {
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return array4 && array4.length ? baseUniq(array4, undefined2, comparator) : [];
        }
        function unzip(array4) {
          if (!(array4 && array4.length)) {
            return [];
          }
          var length2 = 0;
          array4 = arrayFilter(array4, function(group) {
            if (isArrayLikeObject2(group)) {
              length2 = nativeMax2(group.length, length2);
              return true;
            }
          });
          return baseTimes2(length2, function(index4) {
            return arrayMap(array4, baseProperty(index4));
          });
        }
        function unzipWith(array4, iteratee2) {
          if (!(array4 && array4.length)) {
            return [];
          }
          var result2 = unzip(array4);
          if (iteratee2 == null) {
            return result2;
          }
          return arrayMap(result2, function(group) {
            return apply2(iteratee2, undefined2, group);
          });
        }
        var without = baseRest2(function(array4, values2) {
          return isArrayLikeObject2(array4) ? baseDifference(array4, values2) : [];
        });
        var xor = baseRest2(function(arrays) {
          return baseXor(arrayFilter(arrays, isArrayLikeObject2));
        });
        var xorBy = baseRest2(function(arrays) {
          var iteratee2 = last(arrays);
          if (isArrayLikeObject2(iteratee2)) {
            iteratee2 = undefined2;
          }
          return baseXor(arrayFilter(arrays, isArrayLikeObject2), getIteratee(iteratee2, 2));
        });
        var xorWith = baseRest2(function(arrays) {
          var comparator = last(arrays);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return baseXor(arrayFilter(arrays, isArrayLikeObject2), undefined2, comparator);
        });
        var zip2 = baseRest2(unzip);
        function zipObject(props, values2) {
          return baseZipObject(props || [], values2 || [], assignValue2);
        }
        function zipObjectDeep(props, values2) {
          return baseZipObject(props || [], values2 || [], baseSet);
        }
        var zipWith = baseRest2(function(arrays) {
          var length2 = arrays.length, iteratee2 = length2 > 1 ? arrays[length2 - 1] : undefined2;
          iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined2;
          return unzipWith(arrays, iteratee2);
        });
        function chain2(value) {
          var result2 = lodash(value);
          result2.__chain__ = true;
          return result2;
        }
        function tap(value, interceptor) {
          interceptor(value);
          return value;
        }
        function thru(value, interceptor) {
          return interceptor(value);
        }
        var wrapperAt = flatRest(function(paths) {
          var length2 = paths.length, start = length2 ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object) {
            return baseAt(object, paths);
          };
          if (length2 > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex2(start)) {
            return this.thru(interceptor);
          }
          value = value.slice(start, +start + (length2 ? 1 : 0));
          value.__actions__.push({
            "func": thru,
            "args": [interceptor],
            "thisArg": undefined2
          });
          return new LodashWrapper(value, this.__chain__).thru(function(array4) {
            if (length2 && !array4.length) {
              array4.push(undefined2);
            }
            return array4;
          });
        });
        function wrapperChain() {
          return chain2(this);
        }
        function wrapperCommit() {
          return new LodashWrapper(this.value(), this.__chain__);
        }
        function wrapperNext() {
          if (this.__values__ === undefined2) {
            this.__values__ = toArray(this.value());
          }
          var done = this.__index__ >= this.__values__.length, value = done ? undefined2 : this.__values__[this.__index__++];
          return { "done": done, "value": value };
        }
        function wrapperToIterator() {
          return this;
        }
        function wrapperPlant(value) {
          var result2, parent2 = this;
          while (parent2 instanceof baseLodash) {
            var clone3 = wrapperClone(parent2);
            clone3.__index__ = 0;
            clone3.__values__ = undefined2;
            if (result2) {
              previous.__wrapped__ = clone3;
            } else {
              result2 = clone3;
            }
            var previous = clone3;
            parent2 = parent2.__wrapped__;
          }
          previous.__wrapped__ = value;
          return result2;
        }
        function wrapperReverse() {
          var value = this.__wrapped__;
          if (value instanceof LazyWrapper) {
            var wrapped = value;
            if (this.__actions__.length) {
              wrapped = new LazyWrapper(this);
            }
            wrapped = wrapped.reverse();
            wrapped.__actions__.push({
              "func": thru,
              "args": [reverse],
              "thisArg": undefined2
            });
            return new LodashWrapper(wrapped, this.__chain__);
          }
          return this.thru(reverse);
        }
        function wrapperValue() {
          return baseWrapperValue(this.__wrapped__, this.__actions__);
        }
        var countBy = createAggregator(function(result2, value, key) {
          if (hasOwnProperty2.call(result2, key)) {
            ++result2[key];
          } else {
            baseAssignValue2(result2, key, 1);
          }
        });
        function every(collection, predicate, guard) {
          var func = isArray2(collection) ? arrayEvery : baseEvery;
          if (guard && isIterateeCall2(collection, predicate, guard)) {
            predicate = undefined2;
          }
          return func(collection, getIteratee(predicate, 3));
        }
        function filter(collection, predicate) {
          var func = isArray2(collection) ? arrayFilter : baseFilter;
          return func(collection, getIteratee(predicate, 3));
        }
        var find = createFind(findIndex);
        var findLast = createFind(findLastIndex);
        function flatMap(collection, iteratee2) {
          return baseFlatten(map(collection, iteratee2), 1);
        }
        function flatMapDeep(collection, iteratee2) {
          return baseFlatten(map(collection, iteratee2), INFINITY);
        }
        function flatMapDepth(collection, iteratee2, depth) {
          depth = depth === undefined2 ? 1 : toInteger(depth);
          return baseFlatten(map(collection, iteratee2), depth);
        }
        function forEach(collection, iteratee2) {
          var func = isArray2(collection) ? arrayEach : baseEach;
          return func(collection, getIteratee(iteratee2, 3));
        }
        function forEachRight(collection, iteratee2) {
          var func = isArray2(collection) ? arrayEachRight : baseEachRight;
          return func(collection, getIteratee(iteratee2, 3));
        }
        var groupBy = createAggregator(function(result2, value, key) {
          if (hasOwnProperty2.call(result2, key)) {
            result2[key].push(value);
          } else {
            baseAssignValue2(result2, key, [value]);
          }
        });
        function includes(collection, value, fromIndex, guard) {
          collection = isArrayLike2(collection) ? collection : values(collection);
          fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
          var length2 = collection.length;
          if (fromIndex < 0) {
            fromIndex = nativeMax2(length2 + fromIndex, 0);
          }
          return isString2(collection) ? fromIndex <= length2 && collection.indexOf(value, fromIndex) > -1 : !!length2 && baseIndexOf(collection, value, fromIndex) > -1;
        }
        var invokeMap = baseRest2(function(collection, path, args) {
          var index4 = -1, isFunc = typeof path == "function", result2 = isArrayLike2(collection) ? Array2(collection.length) : [];
          baseEach(collection, function(value) {
            result2[++index4] = isFunc ? apply2(path, value, args) : baseInvoke(value, path, args);
          });
          return result2;
        });
        var keyBy = createAggregator(function(result2, value, key) {
          baseAssignValue2(result2, key, value);
        });
        function map(collection, iteratee2) {
          var func = isArray2(collection) ? arrayMap : baseMap;
          return func(collection, getIteratee(iteratee2, 3));
        }
        function orderBy(collection, iteratees, orders, guard) {
          if (collection == null) {
            return [];
          }
          if (!isArray2(iteratees)) {
            iteratees = iteratees == null ? [] : [iteratees];
          }
          orders = guard ? undefined2 : orders;
          if (!isArray2(orders)) {
            orders = orders == null ? [] : [orders];
          }
          return baseOrderBy(collection, iteratees, orders);
        }
        var partition = createAggregator(function(result2, value, key) {
          result2[key ? 0 : 1].push(value);
        }, function() {
          return [[], []];
        });
        function reduce(collection, iteratee2, accumulator) {
          var func = isArray2(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
          return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach);
        }
        function reduceRight(collection, iteratee2, accumulator) {
          var func = isArray2(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
          return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
        }
        function reject2(collection, predicate) {
          var func = isArray2(collection) ? arrayFilter : baseFilter;
          return func(collection, negate(getIteratee(predicate, 3)));
        }
        function sample(collection) {
          var func = isArray2(collection) ? arraySample : baseSample;
          return func(collection);
        }
        function sampleSize(collection, n, guard) {
          if (guard ? isIterateeCall2(collection, n, guard) : n === undefined2) {
            n = 1;
          } else {
            n = toInteger(n);
          }
          var func = isArray2(collection) ? arraySampleSize : baseSampleSize;
          return func(collection, n);
        }
        function shuffle2(collection) {
          var func = isArray2(collection) ? arrayShuffle : baseShuffle;
          return func(collection);
        }
        function size4(collection) {
          if (collection == null) {
            return 0;
          }
          if (isArrayLike2(collection)) {
            return isString2(collection) ? stringSize(collection) : collection.length;
          }
          var tag = getTag(collection);
          if (tag == mapTag2 || tag == setTag2) {
            return collection.size;
          }
          return baseKeys(collection).length;
        }
        function some(collection, predicate, guard) {
          var func = isArray2(collection) ? arraySome : baseSome;
          if (guard && isIterateeCall2(collection, predicate, guard)) {
            predicate = undefined2;
          }
          return func(collection, getIteratee(predicate, 3));
        }
        var sortBy = baseRest2(function(collection, iteratees) {
          if (collection == null) {
            return [];
          }
          var length2 = iteratees.length;
          if (length2 > 1 && isIterateeCall2(collection, iteratees[0], iteratees[1])) {
            iteratees = [];
          } else if (length2 > 2 && isIterateeCall2(iteratees[0], iteratees[1], iteratees[2])) {
            iteratees = [iteratees[0]];
          }
          return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
        });
        var now = ctxNow || function() {
          return root2.Date.now();
        };
        function after(n, func) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          n = toInteger(n);
          return function() {
            if (--n < 1) {
              return func.apply(this, arguments);
            }
          };
        }
        function ary(func, n, guard) {
          n = guard ? undefined2 : n;
          n = func && n == null ? func.length : n;
          return createWrap(func, WRAP_ARY_FLAG, undefined2, undefined2, undefined2, undefined2, n);
        }
        function before(n, func) {
          var result2;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          n = toInteger(n);
          return function() {
            if (--n > 0) {
              result2 = func.apply(this, arguments);
            }
            if (n <= 1) {
              func = undefined2;
            }
            return result2;
          };
        }
        var bind = baseRest2(function(func, thisArg, partials) {
          var bitmask = WRAP_BIND_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bind));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(func, bitmask, thisArg, partials, holders);
        });
        var bindKey = baseRest2(function(object, key, partials) {
          var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bindKey));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(key, bitmask, object, partials, holders);
        });
        function curry(func, arity, guard) {
          arity = guard ? undefined2 : arity;
          var result2 = createWrap(func, WRAP_CURRY_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
          result2.placeholder = curry.placeholder;
          return result2;
        }
        function curryRight(func, arity, guard) {
          arity = guard ? undefined2 : arity;
          var result2 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
          result2.placeholder = curryRight.placeholder;
          return result2;
        }
        function debounce(func, wait3, options) {
          var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          wait3 = toNumber(wait3) || 0;
          if (isObject4(options)) {
            leading = !!options.leading;
            maxing = "maxWait" in options;
            maxWait = maxing ? nativeMax2(toNumber(options.maxWait) || 0, wait3) : maxWait;
            trailing = "trailing" in options ? !!options.trailing : trailing;
          }
          function invokeFunc(time) {
            var args = lastArgs, thisArg = lastThis;
            lastArgs = lastThis = undefined2;
            lastInvokeTime = time;
            result2 = func.apply(thisArg, args);
            return result2;
          }
          function leadingEdge(time) {
            lastInvokeTime = time;
            timerId = setTimeout2(timerExpired, wait3);
            return leading ? invokeFunc(time) : result2;
          }
          function remainingWait(time) {
            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait3 - timeSinceLastCall;
            return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
          }
          function shouldInvoke(time) {
            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
            return lastCallTime === undefined2 || timeSinceLastCall >= wait3 || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
          }
          function timerExpired() {
            var time = now();
            if (shouldInvoke(time)) {
              return trailingEdge(time);
            }
            timerId = setTimeout2(timerExpired, remainingWait(time));
          }
          function trailingEdge(time) {
            timerId = undefined2;
            if (trailing && lastArgs) {
              return invokeFunc(time);
            }
            lastArgs = lastThis = undefined2;
            return result2;
          }
          function cancel() {
            if (timerId !== undefined2) {
              clearTimeout2(timerId);
            }
            lastInvokeTime = 0;
            lastArgs = lastCallTime = lastThis = timerId = undefined2;
          }
          function flush() {
            return timerId === undefined2 ? result2 : trailingEdge(now());
          }
          function debounced() {
            var time = now(), isInvoking = shouldInvoke(time);
            lastArgs = arguments;
            lastThis = this;
            lastCallTime = time;
            if (isInvoking) {
              if (timerId === undefined2) {
                return leadingEdge(lastCallTime);
              }
              if (maxing) {
                clearTimeout2(timerId);
                timerId = setTimeout2(timerExpired, wait3);
                return invokeFunc(lastCallTime);
              }
            }
            if (timerId === undefined2) {
              timerId = setTimeout2(timerExpired, wait3);
            }
            return result2;
          }
          debounced.cancel = cancel;
          debounced.flush = flush;
          return debounced;
        }
        var defer = baseRest2(function(func, args) {
          return baseDelay(func, 1, args);
        });
        var delay = baseRest2(function(func, wait3, args) {
          return baseDelay(func, toNumber(wait3) || 0, args);
        });
        function flip(func) {
          return createWrap(func, WRAP_FLIP_FLAG);
        }
        function memoize(func, resolver) {
          if (typeof func != "function" || resolver != null && typeof resolver != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          var memoized3 = function() {
            var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache2 = memoized3.cache;
            if (cache2.has(key)) {
              return cache2.get(key);
            }
            var result2 = func.apply(this, args);
            memoized3.cache = cache2.set(key, result2) || cache2;
            return result2;
          };
          memoized3.cache = new (memoize.Cache || MapCache2)();
          return memoized3;
        }
        memoize.Cache = MapCache2;
        function negate(predicate) {
          if (typeof predicate != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return function() {
            var args = arguments;
            switch (args.length) {
              case 0:
                return !predicate.call(this);
              case 1:
                return !predicate.call(this, args[0]);
              case 2:
                return !predicate.call(this, args[0], args[1]);
              case 3:
                return !predicate.call(this, args[0], args[1], args[2]);
            }
            return !predicate.apply(this, args);
          };
        }
        function once(func) {
          return before(2, func);
        }
        var overArgs = castRest(function(func, transforms) {
          transforms = transforms.length == 1 && isArray2(transforms[0]) ? arrayMap(transforms[0], baseUnary2(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary2(getIteratee()));
          var funcsLength = transforms.length;
          return baseRest2(function(args) {
            var index4 = -1, length2 = nativeMin(args.length, funcsLength);
            while (++index4 < length2) {
              args[index4] = transforms[index4].call(this, args[index4]);
            }
            return apply2(func, this, args);
          });
        });
        var partial = baseRest2(function(func, partials) {
          var holders = replaceHolders(partials, getHolder(partial));
          return createWrap(func, WRAP_PARTIAL_FLAG, undefined2, partials, holders);
        });
        var partialRight = baseRest2(function(func, partials) {
          var holders = replaceHolders(partials, getHolder(partialRight));
          return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined2, partials, holders);
        });
        var rearg = flatRest(function(func, indexes) {
          return createWrap(func, WRAP_REARG_FLAG, undefined2, undefined2, undefined2, indexes);
        });
        function rest(func, start) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          start = start === undefined2 ? start : toInteger(start);
          return baseRest2(func, start);
        }
        function spread(func, start) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          start = start == null ? 0 : nativeMax2(toInteger(start), 0);
          return baseRest2(function(args) {
            var array4 = args[start], otherArgs = castSlice(args, 0, start);
            if (array4) {
              arrayPush(otherArgs, array4);
            }
            return apply2(func, this, otherArgs);
          });
        }
        function throttle(func, wait3, options) {
          var leading = true, trailing = true;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          if (isObject4(options)) {
            leading = "leading" in options ? !!options.leading : leading;
            trailing = "trailing" in options ? !!options.trailing : trailing;
          }
          return debounce(func, wait3, {
            "leading": leading,
            "maxWait": wait3,
            "trailing": trailing
          });
        }
        function unary(func) {
          return ary(func, 1);
        }
        function wrap(value, wrapper) {
          return partial(castFunction(wrapper), value);
        }
        function castArray() {
          if (!arguments.length) {
            return [];
          }
          var value = arguments[0];
          return isArray2(value) ? value : [value];
        }
        function clone2(value) {
          return baseClone(value, CLONE_SYMBOLS_FLAG);
        }
        function cloneWith(value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
        }
        function cloneDeep(value) {
          return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
        }
        function cloneDeepWith(value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
        }
        function conformsTo(object, source) {
          return source == null || baseConformsTo(object, source, keys(source));
        }
        function eq2(value, other) {
          return value === other || value !== value && other !== other;
        }
        var gt = createRelationalOperation(baseGt);
        var gte = createRelationalOperation(function(value, other) {
          return value >= other;
        });
        var isArguments2 = baseIsArguments2(/* @__PURE__ */ (function() {
          return arguments;
        })()) ? baseIsArguments2 : function(value) {
          return isObjectLike2(value) && hasOwnProperty2.call(value, "callee") && !propertyIsEnumerable2.call(value, "callee");
        };
        var isArray2 = Array2.isArray;
        var isArrayBuffer = nodeIsArrayBuffer ? baseUnary2(nodeIsArrayBuffer) : baseIsArrayBuffer;
        function isArrayLike2(value) {
          return value != null && isLength2(value.length) && !isFunction2(value);
        }
        function isArrayLikeObject2(value) {
          return isObjectLike2(value) && isArrayLike2(value);
        }
        function isBoolean(value) {
          return value === true || value === false || isObjectLike2(value) && baseGetTag2(value) == boolTag2;
        }
        var isBuffer2 = nativeIsBuffer || stubFalse2;
        var isDate = nodeIsDate ? baseUnary2(nodeIsDate) : baseIsDate;
        function isElement(value) {
          return isObjectLike2(value) && value.nodeType === 1 && !isPlainObject2(value);
        }
        function isEmpty(value) {
          if (value == null) {
            return true;
          }
          if (isArrayLike2(value) && (isArray2(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer2(value) || isTypedArray2(value) || isArguments2(value))) {
            return !value.length;
          }
          var tag = getTag(value);
          if (tag == mapTag2 || tag == setTag2) {
            return !value.size;
          }
          if (isPrototype2(value)) {
            return !baseKeys(value).length;
          }
          for (var key in value) {
            if (hasOwnProperty2.call(value, key)) {
              return false;
            }
          }
          return true;
        }
        function isEqual(value, other) {
          return baseIsEqual(value, other);
        }
        function isEqualWith(value, other, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          var result2 = customizer ? customizer(value, other) : undefined2;
          return result2 === undefined2 ? baseIsEqual(value, other, undefined2, customizer) : !!result2;
        }
        function isError(value) {
          if (!isObjectLike2(value)) {
            return false;
          }
          var tag = baseGetTag2(value);
          return tag == errorTag2 || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject2(value);
        }
        function isFinite2(value) {
          return typeof value == "number" && nativeIsFinite(value);
        }
        function isFunction2(value) {
          if (!isObject4(value)) {
            return false;
          }
          var tag = baseGetTag2(value);
          return tag == funcTag2 || tag == genTag2 || tag == asyncTag2 || tag == proxyTag2;
        }
        function isInteger(value) {
          return typeof value == "number" && value == toInteger(value);
        }
        function isLength2(value) {
          return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER3;
        }
        function isObject4(value) {
          var type3 = typeof value;
          return value != null && (type3 == "object" || type3 == "function");
        }
        function isObjectLike2(value) {
          return value != null && typeof value == "object";
        }
        var isMap = nodeIsMap ? baseUnary2(nodeIsMap) : baseIsMap;
        function isMatch(object, source) {
          return object === source || baseIsMatch(object, source, getMatchData(source));
        }
        function isMatchWith(object, source, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseIsMatch(object, source, getMatchData(source), customizer);
        }
        function isNaN2(value) {
          return isNumber2(value) && value != +value;
        }
        function isNative(value) {
          if (isMaskable(value)) {
            throw new Error2(CORE_ERROR_TEXT);
          }
          return baseIsNative2(value);
        }
        function isNull(value) {
          return value === null;
        }
        function isNil(value) {
          return value == null;
        }
        function isNumber2(value) {
          return typeof value == "number" || isObjectLike2(value) && baseGetTag2(value) == numberTag2;
        }
        function isPlainObject2(value) {
          if (!isObjectLike2(value) || baseGetTag2(value) != objectTag2) {
            return false;
          }
          var proto = getPrototype2(value);
          if (proto === null) {
            return true;
          }
          var Ctor = hasOwnProperty2.call(proto, "constructor") && proto.constructor;
          return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString2.call(Ctor) == objectCtorString2;
        }
        var isRegExp = nodeIsRegExp ? baseUnary2(nodeIsRegExp) : baseIsRegExp;
        function isSafeInteger(value) {
          return isInteger(value) && value >= -MAX_SAFE_INTEGER3 && value <= MAX_SAFE_INTEGER3;
        }
        var isSet2 = nodeIsSet ? baseUnary2(nodeIsSet) : baseIsSet;
        function isString2(value) {
          return typeof value == "string" || !isArray2(value) && isObjectLike2(value) && baseGetTag2(value) == stringTag2;
        }
        function isSymbol(value) {
          return typeof value == "symbol" || isObjectLike2(value) && baseGetTag2(value) == symbolTag;
        }
        var isTypedArray2 = nodeIsTypedArray2 ? baseUnary2(nodeIsTypedArray2) : baseIsTypedArray2;
        function isUndefined2(value) {
          return value === undefined2;
        }
        function isWeakMap(value) {
          return isObjectLike2(value) && getTag(value) == weakMapTag2;
        }
        function isWeakSet(value) {
          return isObjectLike2(value) && baseGetTag2(value) == weakSetTag;
        }
        var lt = createRelationalOperation(baseLt);
        var lte = createRelationalOperation(function(value, other) {
          return value <= other;
        });
        function toArray(value) {
          if (!value) {
            return [];
          }
          if (isArrayLike2(value)) {
            return isString2(value) ? stringToArray(value) : copyArray2(value);
          }
          if (symIterator && value[symIterator]) {
            return iteratorToArray(value[symIterator]());
          }
          var tag = getTag(value), func = tag == mapTag2 ? mapToArray : tag == setTag2 ? setToArray : values;
          return func(value);
        }
        function toFinite(value) {
          if (!value) {
            return value === 0 ? value : 0;
          }
          value = toNumber(value);
          if (value === INFINITY || value === -INFINITY) {
            var sign4 = value < 0 ? -1 : 1;
            return sign4 * MAX_INTEGER;
          }
          return value === value ? value : 0;
        }
        function toInteger(value) {
          var result2 = toFinite(value), remainder = result2 % 1;
          return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
        }
        function toLength(value) {
          return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
        }
        function toNumber(value) {
          if (typeof value == "number") {
            return value;
          }
          if (isSymbol(value)) {
            return NAN;
          }
          if (isObject4(value)) {
            var other = typeof value.valueOf == "function" ? value.valueOf() : value;
            value = isObject4(other) ? other + "" : other;
          }
          if (typeof value != "string") {
            return value === 0 ? value : +value;
          }
          value = baseTrim(value);
          var isBinary = reIsBinary.test(value);
          return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
        }
        function toPlainObject2(value) {
          return copyObject2(value, keysIn2(value));
        }
        function toSafeInteger(value) {
          return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER3, MAX_SAFE_INTEGER3) : value === 0 ? value : 0;
        }
        function toString2(value) {
          return value == null ? "" : baseToString(value);
        }
        var assign2 = createAssigner2(function(object, source) {
          if (isPrototype2(source) || isArrayLike2(source)) {
            copyObject2(source, keys(source), object);
            return;
          }
          for (var key in source) {
            if (hasOwnProperty2.call(source, key)) {
              assignValue2(object, key, source[key]);
            }
          }
        });
        var assignIn = createAssigner2(function(object, source) {
          copyObject2(source, keysIn2(source), object);
        });
        var assignInWith = createAssigner2(function(object, source, srcIndex, customizer) {
          copyObject2(source, keysIn2(source), object, customizer);
        });
        var assignWith = createAssigner2(function(object, source, srcIndex, customizer) {
          copyObject2(source, keys(source), object, customizer);
        });
        var at = flatRest(baseAt);
        function create4(prototype, properties) {
          var result2 = baseCreate2(prototype);
          return properties == null ? result2 : baseAssign(result2, properties);
        }
        var defaults = baseRest2(function(object, sources) {
          object = Object2(object);
          var index4 = -1;
          var length2 = sources.length;
          var guard = length2 > 2 ? sources[2] : undefined2;
          if (guard && isIterateeCall2(sources[0], sources[1], guard)) {
            length2 = 1;
          }
          while (++index4 < length2) {
            var source = sources[index4];
            var props = keysIn2(source);
            var propsIndex = -1;
            var propsLength = props.length;
            while (++propsIndex < propsLength) {
              var key = props[propsIndex];
              var value = object[key];
              if (value === undefined2 || eq2(value, objectProto2[key]) && !hasOwnProperty2.call(object, key)) {
                object[key] = source[key];
              }
            }
          }
          return object;
        });
        var defaultsDeep = baseRest2(function(args) {
          args.push(undefined2, customDefaultsMerge);
          return apply2(mergeWith2, undefined2, args);
        });
        function findKey(object, predicate) {
          return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
        }
        function findLastKey(object, predicate) {
          return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
        }
        function forIn(object, iteratee2) {
          return object == null ? object : baseFor2(object, getIteratee(iteratee2, 3), keysIn2);
        }
        function forInRight(object, iteratee2) {
          return object == null ? object : baseForRight(object, getIteratee(iteratee2, 3), keysIn2);
        }
        function forOwn(object, iteratee2) {
          return object && baseForOwn(object, getIteratee(iteratee2, 3));
        }
        function forOwnRight(object, iteratee2) {
          return object && baseForOwnRight(object, getIteratee(iteratee2, 3));
        }
        function functions(object) {
          return object == null ? [] : baseFunctions(object, keys(object));
        }
        function functionsIn(object) {
          return object == null ? [] : baseFunctions(object, keysIn2(object));
        }
        function get(object, path, defaultValue) {
          var result2 = object == null ? undefined2 : baseGet(object, path);
          return result2 === undefined2 ? defaultValue : result2;
        }
        function has(object, path) {
          return object != null && hasPath(object, path, baseHas);
        }
        function hasIn(object, path) {
          return object != null && hasPath(object, path, baseHasIn);
        }
        var invert4 = createInverter(function(result2, value, key) {
          if (value != null && typeof value.toString != "function") {
            value = nativeObjectToString2.call(value);
          }
          result2[value] = key;
        }, constant2(identity2));
        var invertBy = createInverter(function(result2, value, key) {
          if (value != null && typeof value.toString != "function") {
            value = nativeObjectToString2.call(value);
          }
          if (hasOwnProperty2.call(result2, value)) {
            result2[value].push(key);
          } else {
            result2[value] = [key];
          }
        }, getIteratee);
        var invoke2 = baseRest2(baseInvoke);
        function keys(object) {
          return isArrayLike2(object) ? arrayLikeKeys2(object) : baseKeys(object);
        }
        function keysIn2(object) {
          return isArrayLike2(object) ? arrayLikeKeys2(object, true) : baseKeysIn2(object);
        }
        function mapKeys(object, iteratee2) {
          var result2 = {};
          iteratee2 = getIteratee(iteratee2, 3);
          baseForOwn(object, function(value, key, object2) {
            baseAssignValue2(result2, iteratee2(value, key, object2), value);
          });
          return result2;
        }
        function mapValues2(object, iteratee2) {
          var result2 = {};
          iteratee2 = getIteratee(iteratee2, 3);
          baseForOwn(object, function(value, key, object2) {
            baseAssignValue2(result2, key, iteratee2(value, key, object2));
          });
          return result2;
        }
        var merge = createAssigner2(function(object, source, srcIndex) {
          baseMerge2(object, source, srcIndex);
        });
        var mergeWith2 = createAssigner2(function(object, source, srcIndex, customizer) {
          baseMerge2(object, source, srcIndex, customizer);
        });
        var omit = flatRest(function(object, paths) {
          var result2 = {};
          if (object == null) {
            return result2;
          }
          var isDeep = false;
          paths = arrayMap(paths, function(path) {
            path = castPath(path, object);
            isDeep || (isDeep = path.length > 1);
            return path;
          });
          copyObject2(object, getAllKeysIn(object), result2);
          if (isDeep) {
            result2 = baseClone(result2, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
          }
          var length2 = paths.length;
          while (length2--) {
            baseUnset(result2, paths[length2]);
          }
          return result2;
        });
        function omitBy(object, predicate) {
          return pickBy(object, negate(getIteratee(predicate)));
        }
        var pick2 = flatRest(function(object, paths) {
          return object == null ? {} : basePick(object, paths);
        });
        function pickBy(object, predicate) {
          if (object == null) {
            return {};
          }
          var props = arrayMap(getAllKeysIn(object), function(prop) {
            return [prop];
          });
          predicate = getIteratee(predicate);
          return basePickBy(object, props, function(value, path) {
            return predicate(value, path[0]);
          });
        }
        function result(object, path, defaultValue) {
          path = castPath(path, object);
          var index4 = -1, length2 = path.length;
          if (!length2) {
            length2 = 1;
            object = undefined2;
          }
          while (++index4 < length2) {
            var value = object == null ? undefined2 : object[toKey(path[index4])];
            if (value === undefined2) {
              index4 = length2;
              value = defaultValue;
            }
            object = isFunction2(value) ? value.call(object) : value;
          }
          return object;
        }
        function set2(object, path, value) {
          return object == null ? object : baseSet(object, path, value);
        }
        function setWith(object, path, value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return object == null ? object : baseSet(object, path, value, customizer);
        }
        var toPairs = createToPairs(keys);
        var toPairsIn = createToPairs(keysIn2);
        function transform(object, iteratee2, accumulator) {
          var isArr = isArray2(object), isArrLike = isArr || isBuffer2(object) || isTypedArray2(object);
          iteratee2 = getIteratee(iteratee2, 4);
          if (accumulator == null) {
            var Ctor = object && object.constructor;
            if (isArrLike) {
              accumulator = isArr ? new Ctor() : [];
            } else if (isObject4(object)) {
              accumulator = isFunction2(Ctor) ? baseCreate2(getPrototype2(object)) : {};
            } else {
              accumulator = {};
            }
          }
          (isArrLike ? arrayEach : baseForOwn)(object, function(value, index4, object2) {
            return iteratee2(accumulator, value, index4, object2);
          });
          return accumulator;
        }
        function unset(object, path) {
          return object == null ? true : baseUnset(object, path);
        }
        function update(object, path, updater) {
          return object == null ? object : baseUpdate(object, path, castFunction(updater));
        }
        function updateWith(object, path, updater, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
        }
        function values(object) {
          return object == null ? [] : baseValues(object, keys(object));
        }
        function valuesIn(object) {
          return object == null ? [] : baseValues(object, keysIn2(object));
        }
        function clamp(number5, lower, upper) {
          if (upper === undefined2) {
            upper = lower;
            lower = undefined2;
          }
          if (upper !== undefined2) {
            upper = toNumber(upper);
            upper = upper === upper ? upper : 0;
          }
          if (lower !== undefined2) {
            lower = toNumber(lower);
            lower = lower === lower ? lower : 0;
          }
          return baseClamp(toNumber(number5), lower, upper);
        }
        function inRange4(number5, start, end) {
          start = toFinite(start);
          if (end === undefined2) {
            end = start;
            start = 0;
          } else {
            end = toFinite(end);
          }
          number5 = toNumber(number5);
          return baseInRange(number5, start, end);
        }
        function random(lower, upper, floating) {
          if (floating && typeof floating != "boolean" && isIterateeCall2(lower, upper, floating)) {
            upper = floating = undefined2;
          }
          if (floating === undefined2) {
            if (typeof upper == "boolean") {
              floating = upper;
              upper = undefined2;
            } else if (typeof lower == "boolean") {
              floating = lower;
              lower = undefined2;
            }
          }
          if (lower === undefined2 && upper === undefined2) {
            lower = 0;
            upper = 1;
          } else {
            lower = toFinite(lower);
            if (upper === undefined2) {
              upper = lower;
              lower = 0;
            } else {
              upper = toFinite(upper);
            }
          }
          if (lower > upper) {
            var temp = lower;
            lower = upper;
            upper = temp;
          }
          if (floating || lower % 1 || upper % 1) {
            var rand = nativeRandom();
            return nativeMin(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
          }
          return baseRandom(lower, upper);
        }
        var camelCase2 = createCompounder(function(result2, word, index4) {
          word = word.toLowerCase();
          return result2 + (index4 ? capitalize(word) : word);
        });
        function capitalize(string3) {
          return upperFirst(toString2(string3).toLowerCase());
        }
        function deburr(string3) {
          string3 = toString2(string3);
          return string3 && string3.replace(reLatin, deburrLetter).replace(reComboMark, "");
        }
        function endsWith(string3, target, position) {
          string3 = toString2(string3);
          target = baseToString(target);
          var length2 = string3.length;
          position = position === undefined2 ? length2 : baseClamp(toInteger(position), 0, length2);
          var end = position;
          position -= target.length;
          return position >= 0 && string3.slice(position, end) == target;
        }
        function escape(string3) {
          string3 = toString2(string3);
          return string3 && reHasUnescapedHtml.test(string3) ? string3.replace(reUnescapedHtml, escapeHtmlChar) : string3;
        }
        function escapeRegExp2(string3) {
          string3 = toString2(string3);
          return string3 && reHasRegExpChar.test(string3) ? string3.replace(reRegExpChar2, "\\$&") : string3;
        }
        var kebabCase = createCompounder(function(result2, word, index4) {
          return result2 + (index4 ? "-" : "") + word.toLowerCase();
        });
        var lowerCase3 = createCompounder(function(result2, word, index4) {
          return result2 + (index4 ? " " : "") + word.toLowerCase();
        });
        var lowerFirst = createCaseFirst("toLowerCase");
        function pad3(string3, length2, chars) {
          string3 = toString2(string3);
          length2 = toInteger(length2);
          var strLength = length2 ? stringSize(string3) : 0;
          if (!length2 || strLength >= length2) {
            return string3;
          }
          var mid = (length2 - strLength) / 2;
          return createPadding(nativeFloor(mid), chars) + string3 + createPadding(nativeCeil(mid), chars);
        }
        function padEnd(string3, length2, chars) {
          string3 = toString2(string3);
          length2 = toInteger(length2);
          var strLength = length2 ? stringSize(string3) : 0;
          return length2 && strLength < length2 ? string3 + createPadding(length2 - strLength, chars) : string3;
        }
        function padStart(string3, length2, chars) {
          string3 = toString2(string3);
          length2 = toInteger(length2);
          var strLength = length2 ? stringSize(string3) : 0;
          return length2 && strLength < length2 ? createPadding(length2 - strLength, chars) + string3 : string3;
        }
        function parseInt2(string3, radix3, guard) {
          if (guard || radix3 == null) {
            radix3 = 0;
          } else if (radix3) {
            radix3 = +radix3;
          }
          return nativeParseInt(toString2(string3).replace(reTrimStart, ""), radix3 || 0);
        }
        function repeat(string3, n, guard) {
          if (guard ? isIterateeCall2(string3, n, guard) : n === undefined2) {
            n = 1;
          } else {
            n = toInteger(n);
          }
          return baseRepeat(toString2(string3), n);
        }
        function replace3() {
          var args = arguments, string3 = toString2(args[0]);
          return args.length < 3 ? string3 : string3.replace(args[1], args[2]);
        }
        var snakeCase3 = createCompounder(function(result2, word, index4) {
          return result2 + (index4 ? "_" : "") + word.toLowerCase();
        });
        function split6(string3, separator, limit) {
          if (limit && typeof limit != "number" && isIterateeCall2(string3, separator, limit)) {
            separator = limit = undefined2;
          }
          limit = limit === undefined2 ? MAX_ARRAY_LENGTH : limit >>> 0;
          if (!limit) {
            return [];
          }
          string3 = toString2(string3);
          if (string3 && (typeof separator == "string" || separator != null && !isRegExp(separator))) {
            separator = baseToString(separator);
            if (!separator && hasUnicode(string3)) {
              return castSlice(stringToArray(string3), 0, limit);
            }
          }
          return string3.split(separator, limit);
        }
        var startCase = createCompounder(function(result2, word, index4) {
          return result2 + (index4 ? " " : "") + upperFirst(word);
        });
        function startsWith(string3, target, position) {
          string3 = toString2(string3);
          position = position == null ? 0 : baseClamp(toInteger(position), 0, string3.length);
          target = baseToString(target);
          return string3.slice(position, position + target.length) == target;
        }
        function template(string3, options, guard) {
          var settings = lodash.templateSettings;
          if (guard && isIterateeCall2(string3, options, guard)) {
            options = undefined2;
          }
          string3 = toString2(string3);
          options = assignInWith({}, options, settings, customDefaultsAssignIn);
          var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys);
          var isEscaping, isEvaluating, index4 = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
          var reDelimiters = RegExp2(
            (options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$",
            "g"
          );
          var sourceURL = "//# sourceURL=" + (hasOwnProperty2.call(options, "sourceURL") ? (options.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
          string3.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset3) {
            interpolateValue || (interpolateValue = esTemplateValue);
            source += string3.slice(index4, offset3).replace(reUnescapedString, escapeStringChar);
            if (escapeValue) {
              isEscaping = true;
              source += "' +\n__e(" + escapeValue + ") +\n'";
            }
            if (evaluateValue) {
              isEvaluating = true;
              source += "';\n" + evaluateValue + ";\n__p += '";
            }
            if (interpolateValue) {
              source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
            }
            index4 = offset3 + match.length;
            return match;
          });
          source += "';\n";
          var variable = hasOwnProperty2.call(options, "variable") && options.variable;
          if (!variable) {
            source = "with (obj) {\n" + source + "\n}\n";
          } else if (reForbiddenIdentifierChars.test(variable)) {
            throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);
          }
          source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
          source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
          var result2 = attempt(function() {
            return Function2(importsKeys, sourceURL + "return " + source).apply(undefined2, importsValues);
          });
          result2.source = source;
          if (isError(result2)) {
            throw result2;
          }
          return result2;
        }
        function toLower(value) {
          return toString2(value).toLowerCase();
        }
        function toUpper(value) {
          return toString2(value).toUpperCase();
        }
        function trim3(string3, chars, guard) {
          string3 = toString2(string3);
          if (string3 && (guard || chars === undefined2)) {
            return baseTrim(string3);
          }
          if (!string3 || !(chars = baseToString(chars))) {
            return string3;
          }
          var strSymbols = stringToArray(string3), chrSymbols = stringToArray(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
          return castSlice(strSymbols, start, end).join("");
        }
        function trimEnd(string3, chars, guard) {
          string3 = toString2(string3);
          if (string3 && (guard || chars === undefined2)) {
            return string3.slice(0, trimmedEndIndex(string3) + 1);
          }
          if (!string3 || !(chars = baseToString(chars))) {
            return string3;
          }
          var strSymbols = stringToArray(string3), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
          return castSlice(strSymbols, 0, end).join("");
        }
        function trimStart(string3, chars, guard) {
          string3 = toString2(string3);
          if (string3 && (guard || chars === undefined2)) {
            return string3.replace(reTrimStart, "");
          }
          if (!string3 || !(chars = baseToString(chars))) {
            return string3;
          }
          var strSymbols = stringToArray(string3), start = charsStartIndex(strSymbols, stringToArray(chars));
          return castSlice(strSymbols, start).join("");
        }
        function truncate(string3, options) {
          var length2 = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
          if (isObject4(options)) {
            var separator = "separator" in options ? options.separator : separator;
            length2 = "length" in options ? toInteger(options.length) : length2;
            omission = "omission" in options ? baseToString(options.omission) : omission;
          }
          string3 = toString2(string3);
          var strLength = string3.length;
          if (hasUnicode(string3)) {
            var strSymbols = stringToArray(string3);
            strLength = strSymbols.length;
          }
          if (length2 >= strLength) {
            return string3;
          }
          var end = length2 - stringSize(omission);
          if (end < 1) {
            return omission;
          }
          var result2 = strSymbols ? castSlice(strSymbols, 0, end).join("") : string3.slice(0, end);
          if (separator === undefined2) {
            return result2 + omission;
          }
          if (strSymbols) {
            end += result2.length - end;
          }
          if (isRegExp(separator)) {
            if (string3.slice(end).search(separator)) {
              var match, substring = result2;
              if (!separator.global) {
                separator = RegExp2(separator.source, toString2(reFlags.exec(separator)) + "g");
              }
              separator.lastIndex = 0;
              while (match = separator.exec(substring)) {
                var newEnd = match.index;
              }
              result2 = result2.slice(0, newEnd === undefined2 ? end : newEnd);
            }
          } else if (string3.indexOf(baseToString(separator), end) != end) {
            var index4 = result2.lastIndexOf(separator);
            if (index4 > -1) {
              result2 = result2.slice(0, index4);
            }
          }
          return result2 + omission;
        }
        function unescape2(string3) {
          string3 = toString2(string3);
          return string3 && reHasEscapedHtml.test(string3) ? string3.replace(reEscapedHtml, unescapeHtmlChar) : string3;
        }
        var upperCase = createCompounder(function(result2, word, index4) {
          return result2 + (index4 ? " " : "") + word.toUpperCase();
        });
        var upperFirst = createCaseFirst("toUpperCase");
        function words(string3, pattern, guard) {
          string3 = toString2(string3);
          pattern = guard ? undefined2 : pattern;
          if (pattern === undefined2) {
            return hasUnicodeWord(string3) ? unicodeWords(string3) : asciiWords(string3);
          }
          return string3.match(pattern) || [];
        }
        var attempt = baseRest2(function(func, args) {
          try {
            return apply2(func, undefined2, args);
          } catch (e) {
            return isError(e) ? e : new Error2(e);
          }
        });
        var bindAll = flatRest(function(object, methodNames) {
          arrayEach(methodNames, function(key) {
            key = toKey(key);
            baseAssignValue2(object, key, bind(object[key], object));
          });
          return object;
        });
        function cond(pairs) {
          var length2 = pairs == null ? 0 : pairs.length, toIteratee = getIteratee();
          pairs = !length2 ? [] : arrayMap(pairs, function(pair) {
            if (typeof pair[1] != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            return [toIteratee(pair[0]), pair[1]];
          });
          return baseRest2(function(args) {
            var index4 = -1;
            while (++index4 < length2) {
              var pair = pairs[index4];
              if (apply2(pair[0], this, args)) {
                return apply2(pair[1], this, args);
              }
            }
          });
        }
        function conforms(source) {
          return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
        }
        function constant2(value) {
          return function() {
            return value;
          };
        }
        function defaultTo(value, defaultValue) {
          return value == null || value !== value ? defaultValue : value;
        }
        var flow = createFlow();
        var flowRight = createFlow(true);
        function identity2(value) {
          return value;
        }
        function iteratee(func) {
          return baseIteratee(typeof func == "function" ? func : baseClone(func, CLONE_DEEP_FLAG));
        }
        function matches(source) {
          return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
        }
        function matchesProperty(path, srcValue) {
          return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
        }
        var method = baseRest2(function(path, args) {
          return function(object) {
            return baseInvoke(object, path, args);
          };
        });
        var methodOf = baseRest2(function(object, args) {
          return function(path) {
            return baseInvoke(object, path, args);
          };
        });
        function mixin(object, source, options) {
          var props = keys(source), methodNames = baseFunctions(source, props);
          if (options == null && !(isObject4(source) && (methodNames.length || !props.length))) {
            options = source;
            source = object;
            object = this;
            methodNames = baseFunctions(source, keys(source));
          }
          var chain3 = !(isObject4(options) && "chain" in options) || !!options.chain, isFunc = isFunction2(object);
          arrayEach(methodNames, function(methodName) {
            var func = source[methodName];
            object[methodName] = func;
            if (isFunc) {
              object.prototype[methodName] = function() {
                var chainAll = this.__chain__;
                if (chain3 || chainAll) {
                  var result2 = object(this.__wrapped__), actions = result2.__actions__ = copyArray2(this.__actions__);
                  actions.push({ "func": func, "args": arguments, "thisArg": object });
                  result2.__chain__ = chainAll;
                  return result2;
                }
                return func.apply(object, arrayPush([this.value()], arguments));
              };
            }
          });
          return object;
        }
        function noConflict() {
          if (root2._ === this) {
            root2._ = oldDash;
          }
          return this;
        }
        function noop() {
        }
        function nthArg(n) {
          n = toInteger(n);
          return baseRest2(function(args) {
            return baseNth(args, n);
          });
        }
        var over = createOver(arrayMap);
        var overEvery = createOver(arrayEvery);
        var overSome = createOver(arraySome);
        function property(path) {
          return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
        }
        function propertyOf(object) {
          return function(path) {
            return object == null ? undefined2 : baseGet(object, path);
          };
        }
        var range2 = createRange();
        var rangeRight = createRange(true);
        function stubArray() {
          return [];
        }
        function stubFalse2() {
          return false;
        }
        function stubObject() {
          return {};
        }
        function stubString() {
          return "";
        }
        function stubTrue() {
          return true;
        }
        function times(n, iteratee2) {
          n = toInteger(n);
          if (n < 1 || n > MAX_SAFE_INTEGER3) {
            return [];
          }
          var index4 = MAX_ARRAY_LENGTH, length2 = nativeMin(n, MAX_ARRAY_LENGTH);
          iteratee2 = getIteratee(iteratee2);
          n -= MAX_ARRAY_LENGTH;
          var result2 = baseTimes2(length2, iteratee2);
          while (++index4 < n) {
            iteratee2(index4);
          }
          return result2;
        }
        function toPath(value) {
          if (isArray2(value)) {
            return arrayMap(value, toKey);
          }
          return isSymbol(value) ? [value] : copyArray2(stringToPath(toString2(value)));
        }
        function uniqueId(prefix) {
          var id = ++idCounter;
          return toString2(prefix) + id;
        }
        var add5 = createMathOperation(function(augend, addend) {
          return augend + addend;
        }, 0);
        var ceil = createRound("ceil");
        var divide = createMathOperation(function(dividend, divisor) {
          return dividend / divisor;
        }, 1);
        var floor = createRound("floor");
        function max(array4) {
          return array4 && array4.length ? baseExtremum(array4, identity2, baseGt) : undefined2;
        }
        function maxBy(array4, iteratee2) {
          return array4 && array4.length ? baseExtremum(array4, getIteratee(iteratee2, 2), baseGt) : undefined2;
        }
        function mean(array4) {
          return baseMean(array4, identity2);
        }
        function meanBy(array4, iteratee2) {
          return baseMean(array4, getIteratee(iteratee2, 2));
        }
        function min(array4) {
          return array4 && array4.length ? baseExtremum(array4, identity2, baseLt) : undefined2;
        }
        function minBy(array4, iteratee2) {
          return array4 && array4.length ? baseExtremum(array4, getIteratee(iteratee2, 2), baseLt) : undefined2;
        }
        var multiply = createMathOperation(function(multiplier, multiplicand) {
          return multiplier * multiplicand;
        }, 1);
        var round = createRound("round");
        var subtract = createMathOperation(function(minuend, subtrahend) {
          return minuend - subtrahend;
        }, 0);
        function sum(array4) {
          return array4 && array4.length ? baseSum(array4, identity2) : 0;
        }
        function sumBy(array4, iteratee2) {
          return array4 && array4.length ? baseSum(array4, getIteratee(iteratee2, 2)) : 0;
        }
        lodash.after = after;
        lodash.ary = ary;
        lodash.assign = assign2;
        lodash.assignIn = assignIn;
        lodash.assignInWith = assignInWith;
        lodash.assignWith = assignWith;
        lodash.at = at;
        lodash.before = before;
        lodash.bind = bind;
        lodash.bindAll = bindAll;
        lodash.bindKey = bindKey;
        lodash.castArray = castArray;
        lodash.chain = chain2;
        lodash.chunk = chunk;
        lodash.compact = compact;
        lodash.concat = concat3;
        lodash.cond = cond;
        lodash.conforms = conforms;
        lodash.constant = constant2;
        lodash.countBy = countBy;
        lodash.create = create4;
        lodash.curry = curry;
        lodash.curryRight = curryRight;
        lodash.debounce = debounce;
        lodash.defaults = defaults;
        lodash.defaultsDeep = defaultsDeep;
        lodash.defer = defer;
        lodash.delay = delay;
        lodash.difference = difference;
        lodash.differenceBy = differenceBy;
        lodash.differenceWith = differenceWith;
        lodash.drop = drop;
        lodash.dropRight = dropRight;
        lodash.dropRightWhile = dropRightWhile;
        lodash.dropWhile = dropWhile;
        lodash.fill = fill;
        lodash.filter = filter;
        lodash.flatMap = flatMap;
        lodash.flatMapDeep = flatMapDeep;
        lodash.flatMapDepth = flatMapDepth;
        lodash.flatten = flatten;
        lodash.flattenDeep = flattenDeep;
        lodash.flattenDepth = flattenDepth;
        lodash.flip = flip;
        lodash.flow = flow;
        lodash.flowRight = flowRight;
        lodash.fromPairs = fromPairs;
        lodash.functions = functions;
        lodash.functionsIn = functionsIn;
        lodash.groupBy = groupBy;
        lodash.initial = initial;
        lodash.intersection = intersection;
        lodash.intersectionBy = intersectionBy;
        lodash.intersectionWith = intersectionWith;
        lodash.invert = invert4;
        lodash.invertBy = invertBy;
        lodash.invokeMap = invokeMap;
        lodash.iteratee = iteratee;
        lodash.keyBy = keyBy;
        lodash.keys = keys;
        lodash.keysIn = keysIn2;
        lodash.map = map;
        lodash.mapKeys = mapKeys;
        lodash.mapValues = mapValues2;
        lodash.matches = matches;
        lodash.matchesProperty = matchesProperty;
        lodash.memoize = memoize;
        lodash.merge = merge;
        lodash.mergeWith = mergeWith2;
        lodash.method = method;
        lodash.methodOf = methodOf;
        lodash.mixin = mixin;
        lodash.negate = negate;
        lodash.nthArg = nthArg;
        lodash.omit = omit;
        lodash.omitBy = omitBy;
        lodash.once = once;
        lodash.orderBy = orderBy;
        lodash.over = over;
        lodash.overArgs = overArgs;
        lodash.overEvery = overEvery;
        lodash.overSome = overSome;
        lodash.partial = partial;
        lodash.partialRight = partialRight;
        lodash.partition = partition;
        lodash.pick = pick2;
        lodash.pickBy = pickBy;
        lodash.property = property;
        lodash.propertyOf = propertyOf;
        lodash.pull = pull;
        lodash.pullAll = pullAll;
        lodash.pullAllBy = pullAllBy;
        lodash.pullAllWith = pullAllWith;
        lodash.pullAt = pullAt;
        lodash.range = range2;
        lodash.rangeRight = rangeRight;
        lodash.rearg = rearg;
        lodash.reject = reject2;
        lodash.remove = remove;
        lodash.rest = rest;
        lodash.reverse = reverse;
        lodash.sampleSize = sampleSize;
        lodash.set = set2;
        lodash.setWith = setWith;
        lodash.shuffle = shuffle2;
        lodash.slice = slice3;
        lodash.sortBy = sortBy;
        lodash.sortedUniq = sortedUniq;
        lodash.sortedUniqBy = sortedUniqBy;
        lodash.split = split6;
        lodash.spread = spread;
        lodash.tail = tail;
        lodash.take = take;
        lodash.takeRight = takeRight;
        lodash.takeRightWhile = takeRightWhile;
        lodash.takeWhile = takeWhile;
        lodash.tap = tap;
        lodash.throttle = throttle;
        lodash.thru = thru;
        lodash.toArray = toArray;
        lodash.toPairs = toPairs;
        lodash.toPairsIn = toPairsIn;
        lodash.toPath = toPath;
        lodash.toPlainObject = toPlainObject2;
        lodash.transform = transform;
        lodash.unary = unary;
        lodash.union = union3;
        lodash.unionBy = unionBy;
        lodash.unionWith = unionWith;
        lodash.uniq = uniq;
        lodash.uniqBy = uniqBy2;
        lodash.uniqWith = uniqWith;
        lodash.unset = unset;
        lodash.unzip = unzip;
        lodash.unzipWith = unzipWith;
        lodash.update = update;
        lodash.updateWith = updateWith;
        lodash.values = values;
        lodash.valuesIn = valuesIn;
        lodash.without = without;
        lodash.words = words;
        lodash.wrap = wrap;
        lodash.xor = xor;
        lodash.xorBy = xorBy;
        lodash.xorWith = xorWith;
        lodash.zip = zip2;
        lodash.zipObject = zipObject;
        lodash.zipObjectDeep = zipObjectDeep;
        lodash.zipWith = zipWith;
        lodash.entries = toPairs;
        lodash.entriesIn = toPairsIn;
        lodash.extend = assignIn;
        lodash.extendWith = assignInWith;
        mixin(lodash, lodash);
        lodash.add = add5;
        lodash.attempt = attempt;
        lodash.camelCase = camelCase2;
        lodash.capitalize = capitalize;
        lodash.ceil = ceil;
        lodash.clamp = clamp;
        lodash.clone = clone2;
        lodash.cloneDeep = cloneDeep;
        lodash.cloneDeepWith = cloneDeepWith;
        lodash.cloneWith = cloneWith;
        lodash.conformsTo = conformsTo;
        lodash.deburr = deburr;
        lodash.defaultTo = defaultTo;
        lodash.divide = divide;
        lodash.endsWith = endsWith;
        lodash.eq = eq2;
        lodash.escape = escape;
        lodash.escapeRegExp = escapeRegExp2;
        lodash.every = every;
        lodash.find = find;
        lodash.findIndex = findIndex;
        lodash.findKey = findKey;
        lodash.findLast = findLast;
        lodash.findLastIndex = findLastIndex;
        lodash.findLastKey = findLastKey;
        lodash.floor = floor;
        lodash.forEach = forEach;
        lodash.forEachRight = forEachRight;
        lodash.forIn = forIn;
        lodash.forInRight = forInRight;
        lodash.forOwn = forOwn;
        lodash.forOwnRight = forOwnRight;
        lodash.get = get;
        lodash.gt = gt;
        lodash.gte = gte;
        lodash.has = has;
        lodash.hasIn = hasIn;
        lodash.head = head;
        lodash.identity = identity2;
        lodash.includes = includes;
        lodash.indexOf = indexOf;
        lodash.inRange = inRange4;
        lodash.invoke = invoke2;
        lodash.isArguments = isArguments2;
        lodash.isArray = isArray2;
        lodash.isArrayBuffer = isArrayBuffer;
        lodash.isArrayLike = isArrayLike2;
        lodash.isArrayLikeObject = isArrayLikeObject2;
        lodash.isBoolean = isBoolean;
        lodash.isBuffer = isBuffer2;
        lodash.isDate = isDate;
        lodash.isElement = isElement;
        lodash.isEmpty = isEmpty;
        lodash.isEqual = isEqual;
        lodash.isEqualWith = isEqualWith;
        lodash.isError = isError;
        lodash.isFinite = isFinite2;
        lodash.isFunction = isFunction2;
        lodash.isInteger = isInteger;
        lodash.isLength = isLength2;
        lodash.isMap = isMap;
        lodash.isMatch = isMatch;
        lodash.isMatchWith = isMatchWith;
        lodash.isNaN = isNaN2;
        lodash.isNative = isNative;
        lodash.isNil = isNil;
        lodash.isNull = isNull;
        lodash.isNumber = isNumber2;
        lodash.isObject = isObject4;
        lodash.isObjectLike = isObjectLike2;
        lodash.isPlainObject = isPlainObject2;
        lodash.isRegExp = isRegExp;
        lodash.isSafeInteger = isSafeInteger;
        lodash.isSet = isSet2;
        lodash.isString = isString2;
        lodash.isSymbol = isSymbol;
        lodash.isTypedArray = isTypedArray2;
        lodash.isUndefined = isUndefined2;
        lodash.isWeakMap = isWeakMap;
        lodash.isWeakSet = isWeakSet;
        lodash.join = join2;
        lodash.kebabCase = kebabCase;
        lodash.last = last;
        lodash.lastIndexOf = lastIndexOf;
        lodash.lowerCase = lowerCase3;
        lodash.lowerFirst = lowerFirst;
        lodash.lt = lt;
        lodash.lte = lte;
        lodash.max = max;
        lodash.maxBy = maxBy;
        lodash.mean = mean;
        lodash.meanBy = meanBy;
        lodash.min = min;
        lodash.minBy = minBy;
        lodash.stubArray = stubArray;
        lodash.stubFalse = stubFalse2;
        lodash.stubObject = stubObject;
        lodash.stubString = stubString;
        lodash.stubTrue = stubTrue;
        lodash.multiply = multiply;
        lodash.nth = nth;
        lodash.noConflict = noConflict;
        lodash.noop = noop;
        lodash.now = now;
        lodash.pad = pad3;
        lodash.padEnd = padEnd;
        lodash.padStart = padStart;
        lodash.parseInt = parseInt2;
        lodash.random = random;
        lodash.reduce = reduce;
        lodash.reduceRight = reduceRight;
        lodash.repeat = repeat;
        lodash.replace = replace3;
        lodash.result = result;
        lodash.round = round;
        lodash.runInContext = runInContext2;
        lodash.sample = sample;
        lodash.size = size4;
        lodash.snakeCase = snakeCase3;
        lodash.some = some;
        lodash.sortedIndex = sortedIndex;
        lodash.sortedIndexBy = sortedIndexBy;
        lodash.sortedIndexOf = sortedIndexOf;
        lodash.sortedLastIndex = sortedLastIndex;
        lodash.sortedLastIndexBy = sortedLastIndexBy;
        lodash.sortedLastIndexOf = sortedLastIndexOf;
        lodash.startCase = startCase;
        lodash.startsWith = startsWith;
        lodash.subtract = subtract;
        lodash.sum = sum;
        lodash.sumBy = sumBy;
        lodash.template = template;
        lodash.times = times;
        lodash.toFinite = toFinite;
        lodash.toInteger = toInteger;
        lodash.toLength = toLength;
        lodash.toLower = toLower;
        lodash.toNumber = toNumber;
        lodash.toSafeInteger = toSafeInteger;
        lodash.toString = toString2;
        lodash.toUpper = toUpper;
        lodash.trim = trim3;
        lodash.trimEnd = trimEnd;
        lodash.trimStart = trimStart;
        lodash.truncate = truncate;
        lodash.unescape = unescape2;
        lodash.uniqueId = uniqueId;
        lodash.upperCase = upperCase;
        lodash.upperFirst = upperFirst;
        lodash.each = forEach;
        lodash.eachRight = forEachRight;
        lodash.first = head;
        mixin(lodash, (function() {
          var source = {};
          baseForOwn(lodash, function(func, methodName) {
            if (!hasOwnProperty2.call(lodash.prototype, methodName)) {
              source[methodName] = func;
            }
          });
          return source;
        })(), { "chain": false });
        lodash.VERSION = VERSION;
        arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
          lodash[methodName].placeholder = lodash;
        });
        arrayEach(["drop", "take"], function(methodName, index4) {
          LazyWrapper.prototype[methodName] = function(n) {
            n = n === undefined2 ? 1 : nativeMax2(toInteger(n), 0);
            var result2 = this.__filtered__ && !index4 ? new LazyWrapper(this) : this.clone();
            if (result2.__filtered__) {
              result2.__takeCount__ = nativeMin(n, result2.__takeCount__);
            } else {
              result2.__views__.push({
                "size": nativeMin(n, MAX_ARRAY_LENGTH),
                "type": methodName + (result2.__dir__ < 0 ? "Right" : "")
              });
            }
            return result2;
          };
          LazyWrapper.prototype[methodName + "Right"] = function(n) {
            return this.reverse()[methodName](n).reverse();
          };
        });
        arrayEach(["filter", "map", "takeWhile"], function(methodName, index4) {
          var type3 = index4 + 1, isFilter = type3 == LAZY_FILTER_FLAG || type3 == LAZY_WHILE_FLAG;
          LazyWrapper.prototype[methodName] = function(iteratee2) {
            var result2 = this.clone();
            result2.__iteratees__.push({
              "iteratee": getIteratee(iteratee2, 3),
              "type": type3
            });
            result2.__filtered__ = result2.__filtered__ || isFilter;
            return result2;
          };
        });
        arrayEach(["head", "last"], function(methodName, index4) {
          var takeName = "take" + (index4 ? "Right" : "");
          LazyWrapper.prototype[methodName] = function() {
            return this[takeName](1).value()[0];
          };
        });
        arrayEach(["initial", "tail"], function(methodName, index4) {
          var dropName = "drop" + (index4 ? "" : "Right");
          LazyWrapper.prototype[methodName] = function() {
            return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
          };
        });
        LazyWrapper.prototype.compact = function() {
          return this.filter(identity2);
        };
        LazyWrapper.prototype.find = function(predicate) {
          return this.filter(predicate).head();
        };
        LazyWrapper.prototype.findLast = function(predicate) {
          return this.reverse().find(predicate);
        };
        LazyWrapper.prototype.invokeMap = baseRest2(function(path, args) {
          if (typeof path == "function") {
            return new LazyWrapper(this);
          }
          return this.map(function(value) {
            return baseInvoke(value, path, args);
          });
        });
        LazyWrapper.prototype.reject = function(predicate) {
          return this.filter(negate(getIteratee(predicate)));
        };
        LazyWrapper.prototype.slice = function(start, end) {
          start = toInteger(start);
          var result2 = this;
          if (result2.__filtered__ && (start > 0 || end < 0)) {
            return new LazyWrapper(result2);
          }
          if (start < 0) {
            result2 = result2.takeRight(-start);
          } else if (start) {
            result2 = result2.drop(start);
          }
          if (end !== undefined2) {
            end = toInteger(end);
            result2 = end < 0 ? result2.dropRight(-end) : result2.take(end - start);
          }
          return result2;
        };
        LazyWrapper.prototype.takeRightWhile = function(predicate) {
          return this.reverse().takeWhile(predicate).reverse();
        };
        LazyWrapper.prototype.toArray = function() {
          return this.take(MAX_ARRAY_LENGTH);
        };
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
          if (!lodashFunc) {
            return;
          }
          lodash.prototype[methodName] = function() {
            var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray2(value);
            var interceptor = function(value2) {
              var result3 = lodashFunc.apply(lodash, arrayPush([value2], args));
              return isTaker && chainAll ? result3[0] : result3;
            };
            if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
              isLazy = useLazy = false;
            }
            var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
            if (!retUnwrapped && useLazy) {
              value = onlyLazy ? value : new LazyWrapper(this);
              var result2 = func.apply(value, args);
              result2.__actions__.push({ "func": thru, "args": [interceptor], "thisArg": undefined2 });
              return new LodashWrapper(result2, chainAll);
            }
            if (isUnwrapped && onlyLazy) {
              return func.apply(this, args);
            }
            result2 = this.thru(interceptor);
            return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
          };
        });
        arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
          var func = arrayProto2[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
          lodash.prototype[methodName] = function() {
            var args = arguments;
            if (retUnwrapped && !this.__chain__) {
              var value = this.value();
              return func.apply(isArray2(value) ? value : [], args);
            }
            return this[chainName](function(value2) {
              return func.apply(isArray2(value2) ? value2 : [], args);
            });
          };
        });
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var lodashFunc = lodash[methodName];
          if (lodashFunc) {
            var key = lodashFunc.name + "";
            if (!hasOwnProperty2.call(realNames, key)) {
              realNames[key] = [];
            }
            realNames[key].push({ "name": methodName, "func": lodashFunc });
          }
        });
        realNames[createHybrid(undefined2, WRAP_BIND_KEY_FLAG).name] = [{
          "name": "wrapper",
          "func": undefined2
        }];
        LazyWrapper.prototype.clone = lazyClone;
        LazyWrapper.prototype.reverse = lazyReverse;
        LazyWrapper.prototype.value = lazyValue;
        lodash.prototype.at = wrapperAt;
        lodash.prototype.chain = wrapperChain;
        lodash.prototype.commit = wrapperCommit;
        lodash.prototype.next = wrapperNext;
        lodash.prototype.plant = wrapperPlant;
        lodash.prototype.reverse = wrapperReverse;
        lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;
        lodash.prototype.first = lodash.prototype.head;
        if (symIterator) {
          lodash.prototype[symIterator] = wrapperToIterator;
        }
        return lodash;
      });
      var _ = runInContext();
      if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
        root2._ = _;
        define(function() {
          return _;
        });
      } else if (freeModule) {
        (freeModule.exports = _)._ = _;
        freeExports._ = _;
      } else {
        root2._ = _;
      }
    }).call(exports2);
  }
});

// node_modules/map-obj/index.js
var require_map_obj = __commonJS({
  "node_modules/map-obj/index.js"(exports2, module2) {
    "use strict";
    var isObject4 = (value) => typeof value === "object" && value !== null;
    var mapObjectSkip = Symbol("skip");
    var isObjectCustom = (value) => isObject4(value) && !(value instanceof RegExp) && !(value instanceof Error) && !(value instanceof Date);
    var mapObject = (object, mapper, options, isSeen = /* @__PURE__ */ new WeakMap()) => {
      options = {
        deep: false,
        target: {},
        ...options
      };
      if (isSeen.has(object)) {
        return isSeen.get(object);
      }
      isSeen.set(object, options.target);
      const { target } = options;
      delete options.target;
      const mapArray = (array4) => array4.map((element) => isObjectCustom(element) ? mapObject(element, mapper, options, isSeen) : element);
      if (Array.isArray(object)) {
        return mapArray(object);
      }
      for (const [key, value] of Object.entries(object)) {
        const mapResult = mapper(key, value, object);
        if (mapResult === mapObjectSkip) {
          continue;
        }
        let [newKey, newValue, { shouldRecurse = true } = {}] = mapResult;
        if (newKey === "__proto__") {
          continue;
        }
        if (options.deep && shouldRecurse && isObjectCustom(newValue)) {
          newValue = Array.isArray(newValue) ? mapArray(newValue) : mapObject(newValue, mapper, options, isSeen);
        }
        target[newKey] = newValue;
      }
      return target;
    };
    module2.exports = (object, mapper, options) => {
      if (!isObject4(object)) {
        throw new TypeError(`Expected an object, got \`${object}\` (${typeof object})`);
      }
      return mapObject(object, mapper, options);
    };
    module2.exports.mapObjectSkip = mapObjectSkip;
  }
});

// node_modules/tslib/tslib.es6.mjs
var __assign;
var init_tslib_es6 = __esm({
  "node_modules/tslib/tslib.es6.mjs"() {
    __assign = function() {
      __assign = Object.assign || function __assign3(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
  }
});

// node_modules/lower-case/dist.es2015/index.js
function lowerCase(str2) {
  return str2.toLowerCase();
}
var init_dist = __esm({
  "node_modules/lower-case/dist.es2015/index.js"() {
  }
});

// node_modules/no-case/dist.es2015/index.js
function noCase(input, options) {
  if (options === void 0) {
    options = {};
  }
  var _a2 = options.splitRegexp, splitRegexp = _a2 === void 0 ? DEFAULT_SPLIT_REGEXP : _a2, _b = options.stripRegexp, stripRegexp = _b === void 0 ? DEFAULT_STRIP_REGEXP : _b, _c = options.transform, transform = _c === void 0 ? lowerCase : _c, _d = options.delimiter, delimiter = _d === void 0 ? " " : _d;
  var result = replace(replace(input, splitRegexp, "$1\0$2"), stripRegexp, "\0");
  var start = 0;
  var end = result.length;
  while (result.charAt(start) === "\0")
    start++;
  while (result.charAt(end - 1) === "\0")
    end--;
  return result.slice(start, end).split("\0").map(transform).join(delimiter);
}
function replace(input, re, value) {
  if (re instanceof RegExp)
    return input.replace(re, value);
  return re.reduce(function(input2, re2) {
    return input2.replace(re2, value);
  }, input);
}
var DEFAULT_SPLIT_REGEXP, DEFAULT_STRIP_REGEXP;
var init_dist2 = __esm({
  "node_modules/no-case/dist.es2015/index.js"() {
    init_dist();
    DEFAULT_SPLIT_REGEXP = [/([a-z0-9])([A-Z])/g, /([A-Z])([A-Z][a-z])/g];
    DEFAULT_STRIP_REGEXP = /[^A-Z0-9]+/gi;
  }
});

// node_modules/dot-case/dist.es2015/index.js
function dotCase(input, options) {
  if (options === void 0) {
    options = {};
  }
  return noCase(input, __assign({ delimiter: "." }, options));
}
var init_dist3 = __esm({
  "node_modules/dot-case/dist.es2015/index.js"() {
    init_tslib_es6();
    init_dist2();
  }
});

// node_modules/snake-case/dist.es2015/index.js
var dist_exports = {};
__export(dist_exports, {
  snakeCase: () => snakeCase
});
function snakeCase(input, options) {
  if (options === void 0) {
    options = {};
  }
  return dotCase(input, __assign({ delimiter: "_" }, options));
}
var init_dist4 = __esm({
  "node_modules/snake-case/dist.es2015/index.js"() {
    init_tslib_es6();
    init_dist3();
  }
});

// node_modules/snakecase-keys/index.js
var require_snakecase_keys = __commonJS({
  "node_modules/snakecase-keys/index.js"(exports2, module2) {
    "use strict";
    var map = require_map_obj();
    var { snakeCase: snakeCase3 } = (init_dist4(), __toCommonJS(dist_exports));
    module2.exports = function(obj, options) {
      options = Object.assign({ deep: true, exclude: [], parsingOptions: {} }, options);
      return map(obj, function(key, val) {
        return [
          matches(options.exclude, key) ? key : snakeCase3(key, options.parsingOptions),
          val
        ];
      }, options);
    };
    function matches(patterns, value) {
      return patterns.some(function(pattern) {
        return typeof pattern === "string" ? pattern === value : pattern.test(value);
      });
    }
  }
});

// node_modules/retry/lib/retry_operation.js
var require_retry_operation = __commonJS({
  "node_modules/retry/lib/retry_operation.js"(exports2, module2) {
    function RetryOperation(timeouts, options) {
      if (typeof options === "boolean") {
        options = { forever: options };
      }
      this._originalTimeouts = JSON.parse(JSON.stringify(timeouts));
      this._timeouts = timeouts;
      this._options = options || {};
      this._maxRetryTime = options && options.maxRetryTime || Infinity;
      this._fn = null;
      this._errors = [];
      this._attempts = 1;
      this._operationTimeout = null;
      this._operationTimeoutCb = null;
      this._timeout = null;
      this._operationStart = null;
      if (this._options.forever) {
        this._cachedTimeouts = this._timeouts.slice(0);
      }
    }
    module2.exports = RetryOperation;
    RetryOperation.prototype.reset = function() {
      this._attempts = 1;
      this._timeouts = this._originalTimeouts;
    };
    RetryOperation.prototype.stop = function() {
      if (this._timeout) {
        clearTimeout(this._timeout);
      }
      this._timeouts = [];
      this._cachedTimeouts = null;
    };
    RetryOperation.prototype.retry = function(err2) {
      if (this._timeout) {
        clearTimeout(this._timeout);
      }
      if (!err2) {
        return false;
      }
      var currentTime = (/* @__PURE__ */ new Date()).getTime();
      if (err2 && currentTime - this._operationStart >= this._maxRetryTime) {
        this._errors.unshift(new Error("RetryOperation timeout occurred"));
        return false;
      }
      this._errors.push(err2);
      var timeout = this._timeouts.shift();
      if (timeout === void 0) {
        if (this._cachedTimeouts) {
          this._errors.splice(this._errors.length - 1, this._errors.length);
          this._timeouts = this._cachedTimeouts.slice(0);
          timeout = this._timeouts.shift();
        } else {
          return false;
        }
      }
      var self2 = this;
      var timer = setTimeout(function() {
        self2._attempts++;
        if (self2._operationTimeoutCb) {
          self2._timeout = setTimeout(function() {
            self2._operationTimeoutCb(self2._attempts);
          }, self2._operationTimeout);
          if (self2._options.unref) {
            self2._timeout.unref();
          }
        }
        self2._fn(self2._attempts);
      }, timeout);
      if (this._options.unref) {
        timer.unref();
      }
      return true;
    };
    RetryOperation.prototype.attempt = function(fn, timeoutOps) {
      this._fn = fn;
      if (timeoutOps) {
        if (timeoutOps.timeout) {
          this._operationTimeout = timeoutOps.timeout;
        }
        if (timeoutOps.cb) {
          this._operationTimeoutCb = timeoutOps.cb;
        }
      }
      var self2 = this;
      if (this._operationTimeoutCb) {
        this._timeout = setTimeout(function() {
          self2._operationTimeoutCb();
        }, self2._operationTimeout);
      }
      this._operationStart = (/* @__PURE__ */ new Date()).getTime();
      this._fn(this._attempts);
    };
    RetryOperation.prototype.try = function(fn) {
      console.log("Using RetryOperation.try() is deprecated");
      this.attempt(fn);
    };
    RetryOperation.prototype.start = function(fn) {
      console.log("Using RetryOperation.start() is deprecated");
      this.attempt(fn);
    };
    RetryOperation.prototype.start = RetryOperation.prototype.try;
    RetryOperation.prototype.errors = function() {
      return this._errors;
    };
    RetryOperation.prototype.attempts = function() {
      return this._attempts;
    };
    RetryOperation.prototype.mainError = function() {
      if (this._errors.length === 0) {
        return null;
      }
      var counts = {};
      var mainError = null;
      var mainErrorCount = 0;
      for (var i = 0; i < this._errors.length; i++) {
        var error = this._errors[i];
        var message = error.message;
        var count = (counts[message] || 0) + 1;
        counts[message] = count;
        if (count >= mainErrorCount) {
          mainError = error;
          mainErrorCount = count;
        }
      }
      return mainError;
    };
  }
});

// node_modules/retry/lib/retry.js
var require_retry = __commonJS({
  "node_modules/retry/lib/retry.js"(exports2) {
    var RetryOperation = require_retry_operation();
    exports2.operation = function(options) {
      var timeouts = exports2.timeouts(options);
      return new RetryOperation(timeouts, {
        forever: options && options.forever,
        unref: options && options.unref,
        maxRetryTime: options && options.maxRetryTime
      });
    };
    exports2.timeouts = function(options) {
      if (options instanceof Array) {
        return [].concat(options);
      }
      var opts = {
        retries: 10,
        factor: 2,
        minTimeout: 1 * 1e3,
        maxTimeout: Infinity,
        randomize: false
      };
      for (var key in options) {
        opts[key] = options[key];
      }
      if (opts.minTimeout > opts.maxTimeout) {
        throw new Error("minTimeout is greater than maxTimeout");
      }
      var timeouts = [];
      for (var i = 0; i < opts.retries; i++) {
        timeouts.push(this.createTimeout(i, opts));
      }
      if (options && options.forever && !timeouts.length) {
        timeouts.push(this.createTimeout(i, opts));
      }
      timeouts.sort(function(a, b) {
        return a - b;
      });
      return timeouts;
    };
    exports2.createTimeout = function(attempt, opts) {
      var random = opts.randomize ? Math.random() + 1 : 1;
      var timeout = Math.round(random * opts.minTimeout * Math.pow(opts.factor, attempt));
      timeout = Math.min(timeout, opts.maxTimeout);
      return timeout;
    };
    exports2.wrap = function(obj, options, methods) {
      if (options instanceof Array) {
        methods = options;
        options = null;
      }
      if (!methods) {
        methods = [];
        for (var key in obj) {
          if (typeof obj[key] === "function") {
            methods.push(key);
          }
        }
      }
      for (var i = 0; i < methods.length; i++) {
        var method = methods[i];
        var original = obj[method];
        obj[method] = (function retryWrapper(original2) {
          var op = exports2.operation(options);
          var args = Array.prototype.slice.call(arguments, 1);
          var callback = args.pop();
          args.push(function(err2) {
            if (op.retry(err2)) {
              return;
            }
            if (err2) {
              arguments[0] = op.mainError();
            }
            callback.apply(this, arguments);
          });
          op.attempt(function() {
            original2.apply(obj, args);
          });
        }).bind(obj, original);
        obj[method].options = options;
      }
    };
  }
});

// node_modules/retry/index.js
var require_retry2 = __commonJS({
  "node_modules/retry/index.js"(exports2, module2) {
    module2.exports = require_retry();
  }
});

// node_modules/async-retry/lib/index.js
var require_lib = __commonJS({
  "node_modules/async-retry/lib/index.js"(exports2, module2) {
    var retrier = require_retry2();
    function retry2(fn, opts) {
      function run3(resolve2, reject2) {
        var options = opts || {};
        if (!("randomize" in options)) {
          options.randomize = true;
        }
        var op = retrier.operation(options);
        function bail(err2) {
          reject2(err2 || new Error("Aborted"));
        }
        function onError(err2, num2) {
          if (err2.bail) {
            bail(err2);
            return;
          }
          if (!op.retry(err2)) {
            reject2(op.mainError());
          } else if (options.onRetry) {
            options.onRetry(err2, num2);
          }
        }
        function runAttempt(num2) {
          var val;
          try {
            val = fn(bail, num2);
          } catch (err2) {
            onError(err2, num2);
            return;
          }
          Promise.resolve(val).then(resolve2).catch(function catchIt(err2) {
            onError(err2, num2);
          });
        }
        op.attempt(runAttempt);
      }
      return new Promise(run3);
    }
    module2.exports = retry2;
  }
});

// browser-external:fs
var require_fs = __commonJS({
  "browser-external:fs"(exports2, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "fs" has been externalized for browser compatibility. Cannot access "fs.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/strtok3/lib/FsPromise.js
var require_FsPromise = __commonJS({
  "node_modules/strtok3/lib/FsPromise.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.readFile = exports2.writeFileSync = exports2.writeFile = exports2.read = exports2.open = exports2.close = exports2.stat = exports2.createReadStream = exports2.pathExists = void 0;
    var fs = require_fs();
    exports2.pathExists = fs.existsSync;
    exports2.createReadStream = fs.createReadStream;
    async function stat(path) {
      return new Promise((resolve2, reject2) => {
        fs.stat(path, (err2, stats) => {
          if (err2)
            reject2(err2);
          else
            resolve2(stats);
        });
      });
    }
    exports2.stat = stat;
    async function close(fd) {
      return new Promise((resolve2, reject2) => {
        fs.close(fd, (err2) => {
          if (err2)
            reject2(err2);
          else
            resolve2();
        });
      });
    }
    exports2.close = close;
    async function open(path, mode) {
      return new Promise((resolve2, reject2) => {
        fs.open(path, mode, (err2, fd) => {
          if (err2)
            reject2(err2);
          else
            resolve2(fd);
        });
      });
    }
    exports2.open = open;
    async function read2(fd, buffer3, offset3, length2, position) {
      return new Promise((resolve2, reject2) => {
        fs.read(fd, buffer3, offset3, length2, position, (err2, bytesRead, _buffer) => {
          if (err2)
            reject2(err2);
          else
            resolve2({ bytesRead, buffer: _buffer });
        });
      });
    }
    exports2.read = read2;
    async function writeFile(path, data) {
      return new Promise((resolve2, reject2) => {
        fs.writeFile(path, data, (err2) => {
          if (err2)
            reject2(err2);
          else
            resolve2();
        });
      });
    }
    exports2.writeFile = writeFile;
    function writeFileSync(path, data) {
      fs.writeFileSync(path, data);
    }
    exports2.writeFileSync = writeFileSync;
    async function readFile(path) {
      return new Promise((resolve2, reject2) => {
        fs.readFile(path, (err2, buffer3) => {
          if (err2)
            reject2(err2);
          else
            resolve2(buffer3);
        });
      });
    }
    exports2.readFile = readFile;
  }
});

// node_modules/peek-readable/lib/EndOfFileStream.js
var require_EndOfFileStream = __commonJS({
  "node_modules/peek-readable/lib/EndOfFileStream.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.EndOfStreamError = exports2.defaultMessages = void 0;
    exports2.defaultMessages = "End-Of-Stream";
    var EndOfStreamError = class extends Error {
      constructor() {
        super(exports2.defaultMessages);
      }
    };
    exports2.EndOfStreamError = EndOfStreamError;
  }
});

// node_modules/peek-readable/lib/Deferred.js
var require_Deferred = __commonJS({
  "node_modules/peek-readable/lib/Deferred.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Deferred = void 0;
    var Deferred = class {
      constructor() {
        this.resolve = () => null;
        this.reject = () => null;
        this.promise = new Promise((resolve2, reject2) => {
          this.reject = reject2;
          this.resolve = resolve2;
        });
      }
    };
    exports2.Deferred = Deferred;
  }
});

// node_modules/peek-readable/lib/StreamReader.js
var require_StreamReader = __commonJS({
  "node_modules/peek-readable/lib/StreamReader.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.StreamReader = exports2.EndOfStreamError = void 0;
    var EndOfFileStream_1 = require_EndOfFileStream();
    var Deferred_1 = require_Deferred();
    var EndOfFileStream_2 = require_EndOfFileStream();
    Object.defineProperty(exports2, "EndOfStreamError", { enumerable: true, get: function() {
      return EndOfFileStream_2.EndOfStreamError;
    } });
    var maxStreamReadSize = 1 * 1024 * 1024;
    var StreamReader = class {
      constructor(s) {
        this.s = s;
        this.deferred = null;
        this.endOfStream = false;
        this.peekQueue = [];
        if (!s.read || !s.once) {
          throw new Error("Expected an instance of stream.Readable");
        }
        this.s.once("end", () => this.reject(new EndOfFileStream_1.EndOfStreamError()));
        this.s.once("error", (err2) => this.reject(err2));
        this.s.once("close", () => this.reject(new Error("Stream closed")));
      }
      /**
       * Read ahead (peek) from stream. Subsequent read or peeks will return the same data
       * @param uint8Array - Uint8Array (or Buffer) to store data read from stream in
       * @param offset - Offset target
       * @param length - Number of bytes to read
       * @returns Number of bytes peeked
       */
      async peek(uint8Array, offset3, length2) {
        const bytesRead = await this.read(uint8Array, offset3, length2);
        this.peekQueue.push(uint8Array.subarray(offset3, offset3 + bytesRead));
        return bytesRead;
      }
      /**
       * Read chunk from stream
       * @param buffer - Target Uint8Array (or Buffer) to store data read from stream in
       * @param offset - Offset target
       * @param length - Number of bytes to read
       * @returns Number of bytes read
       */
      async read(buffer3, offset3, length2) {
        if (length2 === 0) {
          return 0;
        }
        if (this.peekQueue.length === 0 && this.endOfStream) {
          throw new EndOfFileStream_1.EndOfStreamError();
        }
        let remaining = length2;
        let bytesRead = 0;
        while (this.peekQueue.length > 0 && remaining > 0) {
          const peekData = this.peekQueue.pop();
          if (!peekData)
            throw new Error("peekData should be defined");
          const lenCopy = Math.min(peekData.length, remaining);
          buffer3.set(peekData.subarray(0, lenCopy), offset3 + bytesRead);
          bytesRead += lenCopy;
          remaining -= lenCopy;
          if (lenCopy < peekData.length) {
            this.peekQueue.push(peekData.subarray(lenCopy));
          }
        }
        while (remaining > 0 && !this.endOfStream) {
          const reqLen = Math.min(remaining, maxStreamReadSize);
          const chunkLen = await this.readFromStream(buffer3, offset3 + bytesRead, reqLen);
          bytesRead += chunkLen;
          if (chunkLen < reqLen)
            break;
          remaining -= chunkLen;
        }
        return bytesRead;
      }
      /**
       * Read chunk from stream
       * @param buffer Target Uint8Array (or Buffer) to store data read from stream in
       * @param offset Offset target
       * @param length Number of bytes to read
       * @returns Number of bytes read
       */
      async readFromStream(buffer3, offset3, length2) {
        const readBuffer = this.s.read(length2);
        if (readBuffer) {
          buffer3.set(readBuffer, offset3);
          return readBuffer.length;
        } else {
          const request = {
            buffer: buffer3,
            offset: offset3,
            length: length2,
            deferred: new Deferred_1.Deferred()
          };
          this.deferred = request.deferred;
          this.s.once("readable", () => {
            this.readDeferred(request);
          });
          return request.deferred.promise;
        }
      }
      /**
       * Process deferred read request
       * @param request Deferred read request
       */
      readDeferred(request) {
        const readBuffer = this.s.read(request.length);
        if (readBuffer) {
          request.buffer.set(readBuffer, request.offset);
          request.deferred.resolve(readBuffer.length);
          this.deferred = null;
        } else {
          this.s.once("readable", () => {
            this.readDeferred(request);
          });
        }
      }
      reject(err2) {
        this.endOfStream = true;
        if (this.deferred) {
          this.deferred.reject(err2);
          this.deferred = null;
        }
      }
    };
    exports2.StreamReader = StreamReader;
  }
});

// node_modules/peek-readable/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/peek-readable/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.StreamReader = exports2.EndOfStreamError = void 0;
    var EndOfFileStream_1 = require_EndOfFileStream();
    Object.defineProperty(exports2, "EndOfStreamError", { enumerable: true, get: function() {
      return EndOfFileStream_1.EndOfStreamError;
    } });
    var StreamReader_1 = require_StreamReader();
    Object.defineProperty(exports2, "StreamReader", { enumerable: true, get: function() {
      return StreamReader_1.StreamReader;
    } });
  }
});

// node_modules/strtok3/lib/AbstractTokenizer.js
var require_AbstractTokenizer = __commonJS({
  "node_modules/strtok3/lib/AbstractTokenizer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AbstractTokenizer = void 0;
    var peek_readable_1 = require_lib2();
    var AbstractTokenizer = class {
      constructor(fileInfo) {
        this.position = 0;
        this.numBuffer = new Uint8Array(8);
        this.fileInfo = fileInfo ? fileInfo : {};
      }
      /**
       * Read a token from the tokenizer-stream
       * @param token - The token to read
       * @param position - If provided, the desired position in the tokenizer-stream
       * @returns Promise with token data
       */
      async readToken(token2, position = this.position) {
        const uint8Array = Buffer.alloc(token2.len);
        const len = await this.readBuffer(uint8Array, { position });
        if (len < token2.len)
          throw new peek_readable_1.EndOfStreamError();
        return token2.get(uint8Array, 0);
      }
      /**
       * Peek a token from the tokenizer-stream.
       * @param token - Token to peek from the tokenizer-stream.
       * @param position - Offset where to begin reading within the file. If position is null, data will be read from the current file position.
       * @returns Promise with token data
       */
      async peekToken(token2, position = this.position) {
        const uint8Array = Buffer.alloc(token2.len);
        const len = await this.peekBuffer(uint8Array, { position });
        if (len < token2.len)
          throw new peek_readable_1.EndOfStreamError();
        return token2.get(uint8Array, 0);
      }
      /**
       * Read a numeric token from the stream
       * @param token - Numeric token
       * @returns Promise with number
       */
      async readNumber(token2) {
        const len = await this.readBuffer(this.numBuffer, { length: token2.len });
        if (len < token2.len)
          throw new peek_readable_1.EndOfStreamError();
        return token2.get(this.numBuffer, 0);
      }
      /**
       * Read a numeric token from the stream
       * @param token - Numeric token
       * @returns Promise with number
       */
      async peekNumber(token2) {
        const len = await this.peekBuffer(this.numBuffer, { length: token2.len });
        if (len < token2.len)
          throw new peek_readable_1.EndOfStreamError();
        return token2.get(this.numBuffer, 0);
      }
      /**
       * Ignore number of bytes, advances the pointer in under tokenizer-stream.
       * @param length - Number of bytes to ignore
       * @return resolves the number of bytes ignored, equals length if this available, otherwise the number of bytes available
       */
      async ignore(length2) {
        if (this.fileInfo.size !== void 0) {
          const bytesLeft = this.fileInfo.size - this.position;
          if (length2 > bytesLeft) {
            this.position += bytesLeft;
            return bytesLeft;
          }
        }
        this.position += length2;
        return length2;
      }
      async close() {
      }
      normalizeOptions(uint8Array, options) {
        if (options && options.position !== void 0 && options.position < this.position) {
          throw new Error("`options.position` must be equal or greater than `tokenizer.position`");
        }
        if (options) {
          return {
            mayBeLess: options.mayBeLess === true,
            offset: options.offset ? options.offset : 0,
            length: options.length ? options.length : uint8Array.length - (options.offset ? options.offset : 0),
            position: options.position ? options.position : this.position
          };
        }
        return {
          mayBeLess: false,
          offset: 0,
          length: uint8Array.length,
          position: this.position
        };
      }
    };
    exports2.AbstractTokenizer = AbstractTokenizer;
  }
});

// node_modules/strtok3/lib/ReadStreamTokenizer.js
var require_ReadStreamTokenizer = __commonJS({
  "node_modules/strtok3/lib/ReadStreamTokenizer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ReadStreamTokenizer = void 0;
    var AbstractTokenizer_1 = require_AbstractTokenizer();
    var peek_readable_1 = require_lib2();
    var maxBufferSize = 256e3;
    var ReadStreamTokenizer = class extends AbstractTokenizer_1.AbstractTokenizer {
      constructor(stream2, fileInfo) {
        super(fileInfo);
        this.streamReader = new peek_readable_1.StreamReader(stream2);
      }
      /**
       * Get file information, an HTTP-client may implement this doing a HEAD request
       * @return Promise with file information
       */
      async getFileInfo() {
        return this.fileInfo;
      }
      /**
       * Read buffer from tokenizer
       * @param uint8Array - Target Uint8Array to fill with data read from the tokenizer-stream
       * @param options - Read behaviour options
       * @returns Promise with number of bytes read
       */
      async readBuffer(uint8Array, options) {
        const normOptions = this.normalizeOptions(uint8Array, options);
        const skipBytes = normOptions.position - this.position;
        if (skipBytes > 0) {
          await this.ignore(skipBytes);
          return this.readBuffer(uint8Array, options);
        } else if (skipBytes < 0) {
          throw new Error("`options.position` must be equal or greater than `tokenizer.position`");
        }
        if (normOptions.length === 0) {
          return 0;
        }
        const bytesRead = await this.streamReader.read(uint8Array, normOptions.offset, normOptions.length);
        this.position += bytesRead;
        if ((!options || !options.mayBeLess) && bytesRead < normOptions.length) {
          throw new peek_readable_1.EndOfStreamError();
        }
        return bytesRead;
      }
      /**
       * Peek (read ahead) buffer from tokenizer
       * @param uint8Array - Uint8Array (or Buffer) to write data to
       * @param options - Read behaviour options
       * @returns Promise with number of bytes peeked
       */
      async peekBuffer(uint8Array, options) {
        const normOptions = this.normalizeOptions(uint8Array, options);
        let bytesRead = 0;
        if (normOptions.position) {
          const skipBytes = normOptions.position - this.position;
          if (skipBytes > 0) {
            const skipBuffer = new Uint8Array(normOptions.length + skipBytes);
            bytesRead = await this.peekBuffer(skipBuffer, { mayBeLess: normOptions.mayBeLess });
            uint8Array.set(skipBuffer.subarray(skipBytes), normOptions.offset);
            return bytesRead - skipBytes;
          } else if (skipBytes < 0) {
            throw new Error("Cannot peek from a negative offset in a stream");
          }
        }
        if (normOptions.length > 0) {
          try {
            bytesRead = await this.streamReader.peek(uint8Array, normOptions.offset, normOptions.length);
          } catch (err2) {
            if (options && options.mayBeLess && err2 instanceof peek_readable_1.EndOfStreamError) {
              return 0;
            }
            throw err2;
          }
          if (!normOptions.mayBeLess && bytesRead < normOptions.length) {
            throw new peek_readable_1.EndOfStreamError();
          }
        }
        return bytesRead;
      }
      async ignore(length2) {
        const bufSize = Math.min(maxBufferSize, length2);
        const buf = new Uint8Array(bufSize);
        let totBytesRead = 0;
        while (totBytesRead < length2) {
          const remaining = length2 - totBytesRead;
          const bytesRead = await this.readBuffer(buf, { length: Math.min(bufSize, remaining) });
          if (bytesRead < 0) {
            return bytesRead;
          }
          totBytesRead += bytesRead;
        }
        return totBytesRead;
      }
    };
    exports2.ReadStreamTokenizer = ReadStreamTokenizer;
  }
});

// node_modules/strtok3/lib/BufferTokenizer.js
var require_BufferTokenizer = __commonJS({
  "node_modules/strtok3/lib/BufferTokenizer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BufferTokenizer = void 0;
    var peek_readable_1 = require_lib2();
    var AbstractTokenizer_1 = require_AbstractTokenizer();
    var BufferTokenizer = class extends AbstractTokenizer_1.AbstractTokenizer {
      /**
       * Construct BufferTokenizer
       * @param uint8Array - Uint8Array to tokenize
       * @param fileInfo - Pass additional file information to the tokenizer
       */
      constructor(uint8Array, fileInfo) {
        super(fileInfo);
        this.uint8Array = uint8Array;
        this.fileInfo.size = this.fileInfo.size ? this.fileInfo.size : uint8Array.length;
      }
      /**
       * Read buffer from tokenizer
       * @param uint8Array - Uint8Array to tokenize
       * @param options - Read behaviour options
       * @returns {Promise<number>}
       */
      async readBuffer(uint8Array, options) {
        if (options && options.position) {
          if (options.position < this.position) {
            throw new Error("`options.position` must be equal or greater than `tokenizer.position`");
          }
          this.position = options.position;
        }
        const bytesRead = await this.peekBuffer(uint8Array, options);
        this.position += bytesRead;
        return bytesRead;
      }
      /**
       * Peek (read ahead) buffer from tokenizer
       * @param uint8Array
       * @param options - Read behaviour options
       * @returns {Promise<number>}
       */
      async peekBuffer(uint8Array, options) {
        const normOptions = this.normalizeOptions(uint8Array, options);
        const bytes2read = Math.min(this.uint8Array.length - normOptions.position, normOptions.length);
        if (!normOptions.mayBeLess && bytes2read < normOptions.length) {
          throw new peek_readable_1.EndOfStreamError();
        } else {
          uint8Array.set(this.uint8Array.subarray(normOptions.position, normOptions.position + bytes2read), normOptions.offset);
          return bytes2read;
        }
      }
      async close() {
      }
    };
    exports2.BufferTokenizer = BufferTokenizer;
  }
});

// node_modules/strtok3/lib/core.js
var require_core = __commonJS({
  "node_modules/strtok3/lib/core.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.fromBuffer = exports2.fromStream = exports2.EndOfStreamError = void 0;
    var ReadStreamTokenizer_1 = require_ReadStreamTokenizer();
    var BufferTokenizer_1 = require_BufferTokenizer();
    var peek_readable_1 = require_lib2();
    Object.defineProperty(exports2, "EndOfStreamError", { enumerable: true, get: function() {
      return peek_readable_1.EndOfStreamError;
    } });
    function fromStream2(stream2, fileInfo) {
      fileInfo = fileInfo ? fileInfo : {};
      return new ReadStreamTokenizer_1.ReadStreamTokenizer(stream2, fileInfo);
    }
    exports2.fromStream = fromStream2;
    function fromBuffer3(uint8Array, fileInfo) {
      return new BufferTokenizer_1.BufferTokenizer(uint8Array, fileInfo);
    }
    exports2.fromBuffer = fromBuffer3;
  }
});

// node_modules/strtok3/lib/FileTokenizer.js
var require_FileTokenizer = __commonJS({
  "node_modules/strtok3/lib/FileTokenizer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.fromFile = exports2.FileTokenizer = void 0;
    var AbstractTokenizer_1 = require_AbstractTokenizer();
    var peek_readable_1 = require_lib2();
    var fs = require_FsPromise();
    var FileTokenizer = class extends AbstractTokenizer_1.AbstractTokenizer {
      constructor(fd, fileInfo) {
        super(fileInfo);
        this.fd = fd;
      }
      /**
       * Read buffer from file
       * @param uint8Array - Uint8Array to write result to
       * @param options - Read behaviour options
       * @returns Promise number of bytes read
       */
      async readBuffer(uint8Array, options) {
        const normOptions = this.normalizeOptions(uint8Array, options);
        this.position = normOptions.position;
        const res = await fs.read(this.fd, uint8Array, normOptions.offset, normOptions.length, normOptions.position);
        this.position += res.bytesRead;
        if (res.bytesRead < normOptions.length && (!options || !options.mayBeLess)) {
          throw new peek_readable_1.EndOfStreamError();
        }
        return res.bytesRead;
      }
      /**
       * Peek buffer from file
       * @param uint8Array - Uint8Array (or Buffer) to write data to
       * @param options - Read behaviour options
       * @returns Promise number of bytes read
       */
      async peekBuffer(uint8Array, options) {
        const normOptions = this.normalizeOptions(uint8Array, options);
        const res = await fs.read(this.fd, uint8Array, normOptions.offset, normOptions.length, normOptions.position);
        if (!normOptions.mayBeLess && res.bytesRead < normOptions.length) {
          throw new peek_readable_1.EndOfStreamError();
        }
        return res.bytesRead;
      }
      async close() {
        return fs.close(this.fd);
      }
    };
    exports2.FileTokenizer = FileTokenizer;
    async function fromFile(sourceFilePath) {
      const stat = await fs.stat(sourceFilePath);
      if (!stat.isFile) {
        throw new Error(`File not a file: ${sourceFilePath}`);
      }
      const fd = await fs.open(sourceFilePath, "r");
      return new FileTokenizer(fd, { path: sourceFilePath, size: stat.size });
    }
    exports2.fromFile = fromFile;
  }
});

// node_modules/strtok3/lib/index.js
var require_lib3 = __commonJS({
  "node_modules/strtok3/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.fromStream = exports2.fromBuffer = exports2.EndOfStreamError = exports2.fromFile = void 0;
    var fs = require_FsPromise();
    var core = require_core();
    var FileTokenizer_1 = require_FileTokenizer();
    Object.defineProperty(exports2, "fromFile", { enumerable: true, get: function() {
      return FileTokenizer_1.fromFile;
    } });
    var core_1 = require_core();
    Object.defineProperty(exports2, "EndOfStreamError", { enumerable: true, get: function() {
      return core_1.EndOfStreamError;
    } });
    Object.defineProperty(exports2, "fromBuffer", { enumerable: true, get: function() {
      return core_1.fromBuffer;
    } });
    async function fromStream2(stream2, fileInfo) {
      fileInfo = fileInfo ? fileInfo : {};
      if (stream2.path) {
        const stat = await fs.stat(stream2.path);
        fileInfo.path = stream2.path;
        fileInfo.size = stat.size;
      }
      return core.fromStream(stream2, fileInfo);
    }
    exports2.fromStream = fromStream2;
  }
});

// node_modules/token-types/lib/index.js
var require_lib4 = __commonJS({
  "node_modules/token-types/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AnsiStringType = exports2.StringType = exports2.BufferType = exports2.Uint8ArrayType = exports2.IgnoreType = exports2.Float80_LE = exports2.Float80_BE = exports2.Float64_LE = exports2.Float64_BE = exports2.Float32_LE = exports2.Float32_BE = exports2.Float16_LE = exports2.Float16_BE = exports2.INT64_BE = exports2.UINT64_BE = exports2.INT64_LE = exports2.UINT64_LE = exports2.INT32_LE = exports2.INT32_BE = exports2.INT24_BE = exports2.INT24_LE = exports2.INT16_LE = exports2.INT16_BE = exports2.INT8 = exports2.UINT32_BE = exports2.UINT32_LE = exports2.UINT24_BE = exports2.UINT24_LE = exports2.UINT16_BE = exports2.UINT16_LE = exports2.UINT8 = void 0;
    var ieee7542 = require_ieee754();
    function dv(array4) {
      return new DataView(array4.buffer, array4.byteOffset);
    }
    exports2.UINT8 = {
      len: 1,
      get(array4, offset3) {
        return dv(array4).getUint8(offset3);
      },
      put(array4, offset3, value) {
        dv(array4).setUint8(offset3, value);
        return offset3 + 1;
      }
    };
    exports2.UINT16_LE = {
      len: 2,
      get(array4, offset3) {
        return dv(array4).getUint16(offset3, true);
      },
      put(array4, offset3, value) {
        dv(array4).setUint16(offset3, value, true);
        return offset3 + 2;
      }
    };
    exports2.UINT16_BE = {
      len: 2,
      get(array4, offset3) {
        return dv(array4).getUint16(offset3);
      },
      put(array4, offset3, value) {
        dv(array4).setUint16(offset3, value);
        return offset3 + 2;
      }
    };
    exports2.UINT24_LE = {
      len: 3,
      get(array4, offset3) {
        const dataView = dv(array4);
        return dataView.getUint8(offset3) + (dataView.getUint16(offset3 + 1, true) << 8);
      },
      put(array4, offset3, value) {
        const dataView = dv(array4);
        dataView.setUint8(offset3, value & 255);
        dataView.setUint16(offset3 + 1, value >> 8, true);
        return offset3 + 3;
      }
    };
    exports2.UINT24_BE = {
      len: 3,
      get(array4, offset3) {
        const dataView = dv(array4);
        return (dataView.getUint16(offset3) << 8) + dataView.getUint8(offset3 + 2);
      },
      put(array4, offset3, value) {
        const dataView = dv(array4);
        dataView.setUint16(offset3, value >> 8);
        dataView.setUint8(offset3 + 2, value & 255);
        return offset3 + 3;
      }
    };
    exports2.UINT32_LE = {
      len: 4,
      get(array4, offset3) {
        return dv(array4).getUint32(offset3, true);
      },
      put(array4, offset3, value) {
        dv(array4).setUint32(offset3, value, true);
        return offset3 + 4;
      }
    };
    exports2.UINT32_BE = {
      len: 4,
      get(array4, offset3) {
        return dv(array4).getUint32(offset3);
      },
      put(array4, offset3, value) {
        dv(array4).setUint32(offset3, value);
        return offset3 + 4;
      }
    };
    exports2.INT8 = {
      len: 1,
      get(array4, offset3) {
        return dv(array4).getInt8(offset3);
      },
      put(array4, offset3, value) {
        dv(array4).setInt8(offset3, value);
        return offset3 + 1;
      }
    };
    exports2.INT16_BE = {
      len: 2,
      get(array4, offset3) {
        return dv(array4).getInt16(offset3);
      },
      put(array4, offset3, value) {
        dv(array4).setInt16(offset3, value);
        return offset3 + 2;
      }
    };
    exports2.INT16_LE = {
      len: 2,
      get(array4, offset3) {
        return dv(array4).getInt16(offset3, true);
      },
      put(array4, offset3, value) {
        dv(array4).setInt16(offset3, value, true);
        return offset3 + 2;
      }
    };
    exports2.INT24_LE = {
      len: 3,
      get(array4, offset3) {
        const unsigned = exports2.UINT24_LE.get(array4, offset3);
        return unsigned > 8388607 ? unsigned - 16777216 : unsigned;
      },
      put(array4, offset3, value) {
        const dataView = dv(array4);
        dataView.setUint8(offset3, value & 255);
        dataView.setUint16(offset3 + 1, value >> 8, true);
        return offset3 + 3;
      }
    };
    exports2.INT24_BE = {
      len: 3,
      get(array4, offset3) {
        const unsigned = exports2.UINT24_BE.get(array4, offset3);
        return unsigned > 8388607 ? unsigned - 16777216 : unsigned;
      },
      put(array4, offset3, value) {
        const dataView = dv(array4);
        dataView.setUint16(offset3, value >> 8);
        dataView.setUint8(offset3 + 2, value & 255);
        return offset3 + 3;
      }
    };
    exports2.INT32_BE = {
      len: 4,
      get(array4, offset3) {
        return dv(array4).getInt32(offset3);
      },
      put(array4, offset3, value) {
        dv(array4).setInt32(offset3, value);
        return offset3 + 4;
      }
    };
    exports2.INT32_LE = {
      len: 4,
      get(array4, offset3) {
        return dv(array4).getInt32(offset3, true);
      },
      put(array4, offset3, value) {
        dv(array4).setInt32(offset3, value, true);
        return offset3 + 4;
      }
    };
    exports2.UINT64_LE = {
      len: 8,
      get(array4, offset3) {
        return dv(array4).getBigUint64(offset3, true);
      },
      put(array4, offset3, value) {
        dv(array4).setBigUint64(offset3, value, true);
        return offset3 + 8;
      }
    };
    exports2.INT64_LE = {
      len: 8,
      get(array4, offset3) {
        return dv(array4).getBigInt64(offset3, true);
      },
      put(array4, offset3, value) {
        dv(array4).setBigInt64(offset3, value, true);
        return offset3 + 8;
      }
    };
    exports2.UINT64_BE = {
      len: 8,
      get(array4, offset3) {
        return dv(array4).getBigUint64(offset3);
      },
      put(array4, offset3, value) {
        dv(array4).setBigUint64(offset3, value);
        return offset3 + 8;
      }
    };
    exports2.INT64_BE = {
      len: 8,
      get(array4, offset3) {
        return dv(array4).getBigInt64(offset3);
      },
      put(array4, offset3, value) {
        dv(array4).setBigInt64(offset3, value);
        return offset3 + 8;
      }
    };
    exports2.Float16_BE = {
      len: 2,
      get(dataView, offset3) {
        return ieee7542.read(dataView, offset3, false, 10, this.len);
      },
      put(dataView, offset3, value) {
        ieee7542.write(dataView, value, offset3, false, 10, this.len);
        return offset3 + this.len;
      }
    };
    exports2.Float16_LE = {
      len: 2,
      get(array4, offset3) {
        return ieee7542.read(array4, offset3, true, 10, this.len);
      },
      put(array4, offset3, value) {
        ieee7542.write(array4, value, offset3, true, 10, this.len);
        return offset3 + this.len;
      }
    };
    exports2.Float32_BE = {
      len: 4,
      get(array4, offset3) {
        return dv(array4).getFloat32(offset3);
      },
      put(array4, offset3, value) {
        dv(array4).setFloat32(offset3, value);
        return offset3 + 4;
      }
    };
    exports2.Float32_LE = {
      len: 4,
      get(array4, offset3) {
        return dv(array4).getFloat32(offset3, true);
      },
      put(array4, offset3, value) {
        dv(array4).setFloat32(offset3, value, true);
        return offset3 + 4;
      }
    };
    exports2.Float64_BE = {
      len: 8,
      get(array4, offset3) {
        return dv(array4).getFloat64(offset3);
      },
      put(array4, offset3, value) {
        dv(array4).setFloat64(offset3, value);
        return offset3 + 8;
      }
    };
    exports2.Float64_LE = {
      len: 8,
      get(array4, offset3) {
        return dv(array4).getFloat64(offset3, true);
      },
      put(array4, offset3, value) {
        dv(array4).setFloat64(offset3, value, true);
        return offset3 + 8;
      }
    };
    exports2.Float80_BE = {
      len: 10,
      get(array4, offset3) {
        return ieee7542.read(array4, offset3, false, 63, this.len);
      },
      put(array4, offset3, value) {
        ieee7542.write(array4, value, offset3, false, 63, this.len);
        return offset3 + this.len;
      }
    };
    exports2.Float80_LE = {
      len: 10,
      get(array4, offset3) {
        return ieee7542.read(array4, offset3, true, 63, this.len);
      },
      put(array4, offset3, value) {
        ieee7542.write(array4, value, offset3, true, 63, this.len);
        return offset3 + this.len;
      }
    };
    var IgnoreType = class {
      /**
       * @param len number of bytes to ignore
       */
      constructor(len) {
        this.len = len;
      }
      // ToDo: don't read, but skip data
      get(array4, off) {
      }
    };
    exports2.IgnoreType = IgnoreType;
    var Uint8ArrayType = class {
      constructor(len) {
        this.len = len;
      }
      get(array4, offset3) {
        return array4.subarray(offset3, offset3 + this.len);
      }
    };
    exports2.Uint8ArrayType = Uint8ArrayType;
    var BufferType = class {
      constructor(len) {
        this.len = len;
      }
      get(uint8Array, off) {
        return Buffer.from(uint8Array.subarray(off, off + this.len));
      }
    };
    exports2.BufferType = BufferType;
    var StringType = class {
      constructor(len, encoding) {
        this.len = len;
        this.encoding = encoding;
      }
      get(uint8Array, offset3) {
        return Buffer.from(uint8Array).toString(this.encoding, offset3, offset3 + this.len);
      }
    };
    exports2.StringType = StringType;
    var AnsiStringType = class _AnsiStringType {
      constructor(len) {
        this.len = len;
      }
      static decode(buffer3, offset3, until) {
        let str2 = "";
        for (let i = offset3; i < until; ++i) {
          str2 += _AnsiStringType.codePointToString(_AnsiStringType.singleByteDecoder(buffer3[i]));
        }
        return str2;
      }
      static inRange(a, min, max) {
        return min <= a && a <= max;
      }
      static codePointToString(cp) {
        if (cp <= 65535) {
          return String.fromCharCode(cp);
        } else {
          cp -= 65536;
          return String.fromCharCode((cp >> 10) + 55296, (cp & 1023) + 56320);
        }
      }
      static singleByteDecoder(bite) {
        if (_AnsiStringType.inRange(bite, 0, 127)) {
          return bite;
        }
        const codePoint = _AnsiStringType.windows1252[bite - 128];
        if (codePoint === null) {
          throw Error("invaliding encoding");
        }
        return codePoint;
      }
      get(buffer3, offset3 = 0) {
        return _AnsiStringType.decode(buffer3, offset3, offset3 + this.len);
      }
    };
    exports2.AnsiStringType = AnsiStringType;
    AnsiStringType.windows1252 = [
      8364,
      129,
      8218,
      402,
      8222,
      8230,
      8224,
      8225,
      710,
      8240,
      352,
      8249,
      338,
      141,
      381,
      143,
      144,
      8216,
      8217,
      8220,
      8221,
      8226,
      8211,
      8212,
      732,
      8482,
      353,
      8250,
      339,
      157,
      382,
      376,
      160,
      161,
      162,
      163,
      164,
      165,
      166,
      167,
      168,
      169,
      170,
      171,
      172,
      173,
      174,
      175,
      176,
      177,
      178,
      179,
      180,
      181,
      182,
      183,
      184,
      185,
      186,
      187,
      188,
      189,
      190,
      191,
      192,
      193,
      194,
      195,
      196,
      197,
      198,
      199,
      200,
      201,
      202,
      203,
      204,
      205,
      206,
      207,
      208,
      209,
      210,
      211,
      212,
      213,
      214,
      215,
      216,
      217,
      218,
      219,
      220,
      221,
      222,
      223,
      224,
      225,
      226,
      227,
      228,
      229,
      230,
      231,
      232,
      233,
      234,
      235,
      236,
      237,
      238,
      239,
      240,
      241,
      242,
      243,
      244,
      245,
      246,
      247,
      248,
      249,
      250,
      251,
      252,
      253,
      254,
      255
    ];
  }
});

// node_modules/file-type/util.js
var require_util = __commonJS({
  "node_modules/file-type/util.js"(exports2) {
    "use strict";
    exports2.stringToBytes = (string3) => [...string3].map((character) => character.charCodeAt(0));
    exports2.tarHeaderChecksumMatches = (buffer3, offset3 = 0) => {
      const readSum = parseInt(buffer3.toString("utf8", 148, 154).replace(/\0.*$/, "").trim(), 8);
      if (isNaN(readSum)) {
        return false;
      }
      let sum = 8 * 32;
      for (let i = offset3; i < offset3 + 148; i++) {
        sum += buffer3[i];
      }
      for (let i = offset3 + 156; i < offset3 + 512; i++) {
        sum += buffer3[i];
      }
      return readSum === sum;
    };
    exports2.uint32SyncSafeToken = {
      get: (buffer3, offset3) => {
        return buffer3[offset3 + 3] & 127 | buffer3[offset3 + 2] << 7 | buffer3[offset3 + 1] << 14 | buffer3[offset3] << 21;
      },
      len: 4
    };
  }
});

// node_modules/file-type/supported.js
var require_supported = __commonJS({
  "node_modules/file-type/supported.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      extensions: [
        "jpg",
        "png",
        "apng",
        "gif",
        "webp",
        "flif",
        "xcf",
        "cr2",
        "cr3",
        "orf",
        "arw",
        "dng",
        "nef",
        "rw2",
        "raf",
        "tif",
        "bmp",
        "icns",
        "jxr",
        "psd",
        "indd",
        "zip",
        "tar",
        "rar",
        "gz",
        "bz2",
        "7z",
        "dmg",
        "mp4",
        "mid",
        "mkv",
        "webm",
        "mov",
        "avi",
        "mpg",
        "mp2",
        "mp3",
        "m4a",
        "oga",
        "ogg",
        "ogv",
        "opus",
        "flac",
        "wav",
        "spx",
        "amr",
        "pdf",
        "epub",
        "exe",
        "swf",
        "rtf",
        "wasm",
        "woff",
        "woff2",
        "eot",
        "ttf",
        "otf",
        "ico",
        "flv",
        "ps",
        "xz",
        "sqlite",
        "nes",
        "crx",
        "xpi",
        "cab",
        "deb",
        "ar",
        "rpm",
        "Z",
        "lz",
        "cfb",
        "mxf",
        "mts",
        "blend",
        "bpg",
        "docx",
        "pptx",
        "xlsx",
        "3gp",
        "3g2",
        "jp2",
        "jpm",
        "jpx",
        "mj2",
        "aif",
        "qcp",
        "odt",
        "ods",
        "odp",
        "xml",
        "mobi",
        "heic",
        "cur",
        "ktx",
        "ape",
        "wv",
        "dcm",
        "ics",
        "glb",
        "pcap",
        "dsf",
        "lnk",
        "alias",
        "voc",
        "ac3",
        "m4v",
        "m4p",
        "m4b",
        "f4v",
        "f4p",
        "f4b",
        "f4a",
        "mie",
        "asf",
        "ogm",
        "ogx",
        "mpc",
        "arrow",
        "shp",
        "aac",
        "mp1",
        "it",
        "s3m",
        "xm",
        "ai",
        "skp",
        "avif",
        "eps",
        "lzh",
        "pgp",
        "asar",
        "stl",
        "chm",
        "3mf",
        "zst",
        "jxl",
        "vcf"
      ],
      mimeTypes: [
        "image/jpeg",
        "image/png",
        "image/gif",
        "image/webp",
        "image/flif",
        "image/x-xcf",
        "image/x-canon-cr2",
        "image/x-canon-cr3",
        "image/tiff",
        "image/bmp",
        "image/vnd.ms-photo",
        "image/vnd.adobe.photoshop",
        "application/x-indesign",
        "application/epub+zip",
        "application/x-xpinstall",
        "application/vnd.oasis.opendocument.text",
        "application/vnd.oasis.opendocument.spreadsheet",
        "application/vnd.oasis.opendocument.presentation",
        "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
        "application/vnd.openxmlformats-officedocument.presentationml.presentation",
        "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
        "application/zip",
        "application/x-tar",
        "application/x-rar-compressed",
        "application/gzip",
        "application/x-bzip2",
        "application/x-7z-compressed",
        "application/x-apple-diskimage",
        "application/x-apache-arrow",
        "video/mp4",
        "audio/midi",
        "video/x-matroska",
        "video/webm",
        "video/quicktime",
        "video/vnd.avi",
        "audio/vnd.wave",
        "audio/qcelp",
        "audio/x-ms-asf",
        "video/x-ms-asf",
        "application/vnd.ms-asf",
        "video/mpeg",
        "video/3gpp",
        "audio/mpeg",
        "audio/mp4",
        // RFC 4337
        "audio/opus",
        "video/ogg",
        "audio/ogg",
        "application/ogg",
        "audio/x-flac",
        "audio/ape",
        "audio/wavpack",
        "audio/amr",
        "application/pdf",
        "application/x-msdownload",
        "application/x-shockwave-flash",
        "application/rtf",
        "application/wasm",
        "font/woff",
        "font/woff2",
        "application/vnd.ms-fontobject",
        "font/ttf",
        "font/otf",
        "image/x-icon",
        "video/x-flv",
        "application/postscript",
        "application/eps",
        "application/x-xz",
        "application/x-sqlite3",
        "application/x-nintendo-nes-rom",
        "application/x-google-chrome-extension",
        "application/vnd.ms-cab-compressed",
        "application/x-deb",
        "application/x-unix-archive",
        "application/x-rpm",
        "application/x-compress",
        "application/x-lzip",
        "application/x-cfb",
        "application/x-mie",
        "application/mxf",
        "video/mp2t",
        "application/x-blender",
        "image/bpg",
        "image/jp2",
        "image/jpx",
        "image/jpm",
        "image/mj2",
        "audio/aiff",
        "application/xml",
        "application/x-mobipocket-ebook",
        "image/heif",
        "image/heif-sequence",
        "image/heic",
        "image/heic-sequence",
        "image/icns",
        "image/ktx",
        "application/dicom",
        "audio/x-musepack",
        "text/calendar",
        "text/vcard",
        "model/gltf-binary",
        "application/vnd.tcpdump.pcap",
        "audio/x-dsf",
        // Non-standard
        "application/x.ms.shortcut",
        // Invented by us
        "application/x.apple.alias",
        // Invented by us
        "audio/x-voc",
        "audio/vnd.dolby.dd-raw",
        "audio/x-m4a",
        "image/apng",
        "image/x-olympus-orf",
        "image/x-sony-arw",
        "image/x-adobe-dng",
        "image/x-nikon-nef",
        "image/x-panasonic-rw2",
        "image/x-fujifilm-raf",
        "video/x-m4v",
        "video/3gpp2",
        "application/x-esri-shape",
        "audio/aac",
        "audio/x-it",
        "audio/x-s3m",
        "audio/x-xm",
        "video/MP1S",
        "video/MP2P",
        "application/vnd.sketchup.skp",
        "image/avif",
        "application/x-lzh-compressed",
        "application/pgp-encrypted",
        "application/x-asar",
        "model/stl",
        "application/vnd.ms-htmlhelp",
        "model/3mf",
        "image/jxl",
        "application/zstd"
      ]
    };
  }
});

// node_modules/file-type/core.js
var require_core2 = __commonJS({
  "node_modules/file-type/core.js"(exports, module) {
    "use strict";
    var Token = require_lib4();
    var strtok3 = require_core();
    var {
      stringToBytes,
      tarHeaderChecksumMatches,
      uint32SyncSafeToken
    } = require_util();
    var supported = require_supported();
    var minimumBytes = 4100;
    async function fromStream(stream2) {
      const tokenizer = await strtok3.fromStream(stream2);
      try {
        return await fromTokenizer(tokenizer);
      } finally {
        await tokenizer.close();
      }
    }
    async function fromBuffer(input) {
      if (!(input instanceof Uint8Array || input instanceof ArrayBuffer || Buffer.isBuffer(input))) {
        throw new TypeError(`Expected the \`input\` argument to be of type \`Uint8Array\` or \`Buffer\` or \`ArrayBuffer\`, got \`${typeof input}\``);
      }
      const buffer3 = input instanceof Buffer ? input : Buffer.from(input);
      if (!(buffer3 && buffer3.length > 1)) {
        return;
      }
      const tokenizer = strtok3.fromBuffer(buffer3);
      return fromTokenizer(tokenizer);
    }
    function _check(buffer3, headers, options) {
      options = {
        offset: 0,
        ...options
      };
      for (const [index4, header] of headers.entries()) {
        if (options.mask) {
          if (header !== (options.mask[index4] & buffer3[index4 + options.offset])) {
            return false;
          }
        } else if (header !== buffer3[index4 + options.offset]) {
          return false;
        }
      }
      return true;
    }
    async function fromTokenizer(tokenizer) {
      try {
        return _fromTokenizer(tokenizer);
      } catch (error) {
        if (!(error instanceof strtok3.EndOfStreamError)) {
          throw error;
        }
      }
    }
    async function _fromTokenizer(tokenizer) {
      let buffer3 = Buffer.alloc(minimumBytes);
      const bytesRead = 12;
      const check = (header, options) => _check(buffer3, header, options);
      const checkString = (header, options) => check(stringToBytes(header), options);
      if (!tokenizer.fileInfo.size) {
        tokenizer.fileInfo.size = Number.MAX_SAFE_INTEGER;
      }
      await tokenizer.peekBuffer(buffer3, { length: bytesRead, mayBeLess: true });
      if (check([66, 77])) {
        return {
          ext: "bmp",
          mime: "image/bmp"
        };
      }
      if (check([11, 119])) {
        return {
          ext: "ac3",
          mime: "audio/vnd.dolby.dd-raw"
        };
      }
      if (check([120, 1])) {
        return {
          ext: "dmg",
          mime: "application/x-apple-diskimage"
        };
      }
      if (check([77, 90])) {
        return {
          ext: "exe",
          mime: "application/x-msdownload"
        };
      }
      if (check([37, 33])) {
        await tokenizer.peekBuffer(buffer3, { length: 24, mayBeLess: true });
        if (checkString("PS-Adobe-", { offset: 2 }) && checkString(" EPSF-", { offset: 14 })) {
          return {
            ext: "eps",
            mime: "application/eps"
          };
        }
        return {
          ext: "ps",
          mime: "application/postscript"
        };
      }
      if (check([31, 160]) || check([31, 157])) {
        return {
          ext: "Z",
          mime: "application/x-compress"
        };
      }
      if (check([255, 216, 255])) {
        return {
          ext: "jpg",
          mime: "image/jpeg"
        };
      }
      if (check([73, 73, 188])) {
        return {
          ext: "jxr",
          mime: "image/vnd.ms-photo"
        };
      }
      if (check([31, 139, 8])) {
        return {
          ext: "gz",
          mime: "application/gzip"
        };
      }
      if (check([66, 90, 104])) {
        return {
          ext: "bz2",
          mime: "application/x-bzip2"
        };
      }
      if (checkString("ID3")) {
        await tokenizer.ignore(6);
        const id3HeaderLen = await tokenizer.readToken(uint32SyncSafeToken);
        if (tokenizer.position + id3HeaderLen > tokenizer.fileInfo.size) {
          return {
            ext: "mp3",
            mime: "audio/mpeg"
          };
        }
        await tokenizer.ignore(id3HeaderLen);
        return fromTokenizer(tokenizer);
      }
      if (checkString("MP+")) {
        return {
          ext: "mpc",
          mime: "audio/x-musepack"
        };
      }
      if ((buffer3[0] === 67 || buffer3[0] === 70) && check([87, 83], { offset: 1 })) {
        return {
          ext: "swf",
          mime: "application/x-shockwave-flash"
        };
      }
      if (check([71, 73, 70])) {
        return {
          ext: "gif",
          mime: "image/gif"
        };
      }
      if (checkString("FLIF")) {
        return {
          ext: "flif",
          mime: "image/flif"
        };
      }
      if (checkString("8BPS")) {
        return {
          ext: "psd",
          mime: "image/vnd.adobe.photoshop"
        };
      }
      if (checkString("WEBP", { offset: 8 })) {
        return {
          ext: "webp",
          mime: "image/webp"
        };
      }
      if (checkString("MPCK")) {
        return {
          ext: "mpc",
          mime: "audio/x-musepack"
        };
      }
      if (checkString("FORM")) {
        return {
          ext: "aif",
          mime: "audio/aiff"
        };
      }
      if (checkString("icns", { offset: 0 })) {
        return {
          ext: "icns",
          mime: "image/icns"
        };
      }
      if (check([80, 75, 3, 4])) {
        try {
          while (tokenizer.position + 30 < tokenizer.fileInfo.size) {
            await tokenizer.readBuffer(buffer3, { length: 30 });
            const zipHeader = {
              compressedSize: buffer3.readUInt32LE(18),
              uncompressedSize: buffer3.readUInt32LE(22),
              filenameLength: buffer3.readUInt16LE(26),
              extraFieldLength: buffer3.readUInt16LE(28)
            };
            zipHeader.filename = await tokenizer.readToken(new Token.StringType(zipHeader.filenameLength, "utf-8"));
            await tokenizer.ignore(zipHeader.extraFieldLength);
            if (zipHeader.filename === "META-INF/mozilla.rsa") {
              return {
                ext: "xpi",
                mime: "application/x-xpinstall"
              };
            }
            if (zipHeader.filename.endsWith(".rels") || zipHeader.filename.endsWith(".xml")) {
              const type3 = zipHeader.filename.split("/")[0];
              switch (type3) {
                case "_rels":
                  break;
                case "word":
                  return {
                    ext: "docx",
                    mime: "application/vnd.openxmlformats-officedocument.wordprocessingml.document"
                  };
                case "ppt":
                  return {
                    ext: "pptx",
                    mime: "application/vnd.openxmlformats-officedocument.presentationml.presentation"
                  };
                case "xl":
                  return {
                    ext: "xlsx",
                    mime: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
                  };
                default:
                  break;
              }
            }
            if (zipHeader.filename.startsWith("xl/")) {
              return {
                ext: "xlsx",
                mime: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
              };
            }
            if (zipHeader.filename.startsWith("3D/") && zipHeader.filename.endsWith(".model")) {
              return {
                ext: "3mf",
                mime: "model/3mf"
              };
            }
            if (zipHeader.filename === "mimetype" && zipHeader.compressedSize === zipHeader.uncompressedSize) {
              const mimeType = await tokenizer.readToken(new Token.StringType(zipHeader.compressedSize, "utf-8"));
              switch (mimeType) {
                case "application/epub+zip":
                  return {
                    ext: "epub",
                    mime: "application/epub+zip"
                  };
                case "application/vnd.oasis.opendocument.text":
                  return {
                    ext: "odt",
                    mime: "application/vnd.oasis.opendocument.text"
                  };
                case "application/vnd.oasis.opendocument.spreadsheet":
                  return {
                    ext: "ods",
                    mime: "application/vnd.oasis.opendocument.spreadsheet"
                  };
                case "application/vnd.oasis.opendocument.presentation":
                  return {
                    ext: "odp",
                    mime: "application/vnd.oasis.opendocument.presentation"
                  };
                default:
              }
            }
            if (zipHeader.compressedSize === 0) {
              let nextHeaderIndex = -1;
              while (nextHeaderIndex < 0 && tokenizer.position < tokenizer.fileInfo.size) {
                await tokenizer.peekBuffer(buffer3, { mayBeLess: true });
                nextHeaderIndex = buffer3.indexOf("504B0304", 0, "hex");
                await tokenizer.ignore(nextHeaderIndex >= 0 ? nextHeaderIndex : buffer3.length);
              }
            } else {
              await tokenizer.ignore(zipHeader.compressedSize);
            }
          }
        } catch (error) {
          if (!(error instanceof strtok3.EndOfStreamError)) {
            throw error;
          }
        }
        return {
          ext: "zip",
          mime: "application/zip"
        };
      }
      if (checkString("OggS")) {
        await tokenizer.ignore(28);
        const type3 = Buffer.alloc(8);
        await tokenizer.readBuffer(type3);
        if (_check(type3, [79, 112, 117, 115, 72, 101, 97, 100])) {
          return {
            ext: "opus",
            mime: "audio/opus"
          };
        }
        if (_check(type3, [128, 116, 104, 101, 111, 114, 97])) {
          return {
            ext: "ogv",
            mime: "video/ogg"
          };
        }
        if (_check(type3, [1, 118, 105, 100, 101, 111, 0])) {
          return {
            ext: "ogm",
            mime: "video/ogg"
          };
        }
        if (_check(type3, [127, 70, 76, 65, 67])) {
          return {
            ext: "oga",
            mime: "audio/ogg"
          };
        }
        if (_check(type3, [83, 112, 101, 101, 120, 32, 32])) {
          return {
            ext: "spx",
            mime: "audio/ogg"
          };
        }
        if (_check(type3, [1, 118, 111, 114, 98, 105, 115])) {
          return {
            ext: "ogg",
            mime: "audio/ogg"
          };
        }
        return {
          ext: "ogx",
          mime: "application/ogg"
        };
      }
      if (check([80, 75]) && (buffer3[2] === 3 || buffer3[2] === 5 || buffer3[2] === 7) && (buffer3[3] === 4 || buffer3[3] === 6 || buffer3[3] === 8)) {
        return {
          ext: "zip",
          mime: "application/zip"
        };
      }
      if (checkString("ftyp", { offset: 4 }) && (buffer3[8] & 96) !== 0) {
        const brandMajor = buffer3.toString("binary", 8, 12).replace("\0", " ").trim();
        switch (brandMajor) {
          case "avif":
            return { ext: "avif", mime: "image/avif" };
          case "mif1":
            return { ext: "heic", mime: "image/heif" };
          case "msf1":
            return { ext: "heic", mime: "image/heif-sequence" };
          case "heic":
          case "heix":
            return { ext: "heic", mime: "image/heic" };
          case "hevc":
          case "hevx":
            return { ext: "heic", mime: "image/heic-sequence" };
          case "qt":
            return { ext: "mov", mime: "video/quicktime" };
          case "M4V":
          case "M4VH":
          case "M4VP":
            return { ext: "m4v", mime: "video/x-m4v" };
          case "M4P":
            return { ext: "m4p", mime: "video/mp4" };
          case "M4B":
            return { ext: "m4b", mime: "audio/mp4" };
          case "M4A":
            return { ext: "m4a", mime: "audio/x-m4a" };
          case "F4V":
            return { ext: "f4v", mime: "video/mp4" };
          case "F4P":
            return { ext: "f4p", mime: "video/mp4" };
          case "F4A":
            return { ext: "f4a", mime: "audio/mp4" };
          case "F4B":
            return { ext: "f4b", mime: "audio/mp4" };
          case "crx":
            return { ext: "cr3", mime: "image/x-canon-cr3" };
          default:
            if (brandMajor.startsWith("3g")) {
              if (brandMajor.startsWith("3g2")) {
                return { ext: "3g2", mime: "video/3gpp2" };
              }
              return { ext: "3gp", mime: "video/3gpp" };
            }
            return { ext: "mp4", mime: "video/mp4" };
        }
      }
      if (checkString("MThd")) {
        return {
          ext: "mid",
          mime: "audio/midi"
        };
      }
      if (checkString("wOFF") && (check([0, 1, 0, 0], { offset: 4 }) || checkString("OTTO", { offset: 4 }))) {
        return {
          ext: "woff",
          mime: "font/woff"
        };
      }
      if (checkString("wOF2") && (check([0, 1, 0, 0], { offset: 4 }) || checkString("OTTO", { offset: 4 }))) {
        return {
          ext: "woff2",
          mime: "font/woff2"
        };
      }
      if (check([212, 195, 178, 161]) || check([161, 178, 195, 212])) {
        return {
          ext: "pcap",
          mime: "application/vnd.tcpdump.pcap"
        };
      }
      if (checkString("DSD ")) {
        return {
          ext: "dsf",
          mime: "audio/x-dsf"
          // Non-standard
        };
      }
      if (checkString("LZIP")) {
        return {
          ext: "lz",
          mime: "application/x-lzip"
        };
      }
      if (checkString("fLaC")) {
        return {
          ext: "flac",
          mime: "audio/x-flac"
        };
      }
      if (check([66, 80, 71, 251])) {
        return {
          ext: "bpg",
          mime: "image/bpg"
        };
      }
      if (checkString("wvpk")) {
        return {
          ext: "wv",
          mime: "audio/wavpack"
        };
      }
      if (checkString("%PDF")) {
        await tokenizer.ignore(1350);
        const maxBufferSize = 10 * 1024 * 1024;
        const buffer4 = Buffer.alloc(Math.min(maxBufferSize, tokenizer.fileInfo.size));
        await tokenizer.readBuffer(buffer4, { mayBeLess: true });
        if (buffer4.includes(Buffer.from("AIPrivateData"))) {
          return {
            ext: "ai",
            mime: "application/postscript"
          };
        }
        return {
          ext: "pdf",
          mime: "application/pdf"
        };
      }
      if (check([0, 97, 115, 109])) {
        return {
          ext: "wasm",
          mime: "application/wasm"
        };
      }
      if (check([73, 73, 42, 0])) {
        if (checkString("CR", { offset: 8 })) {
          return {
            ext: "cr2",
            mime: "image/x-canon-cr2"
          };
        }
        if (check([28, 0, 254, 0], { offset: 8 }) || check([31, 0, 11, 0], { offset: 8 })) {
          return {
            ext: "nef",
            mime: "image/x-nikon-nef"
          };
        }
        if (check([8, 0, 0, 0], { offset: 4 }) && (check([45, 0, 254, 0], { offset: 8 }) || check([39, 0, 254, 0], { offset: 8 }))) {
          return {
            ext: "dng",
            mime: "image/x-adobe-dng"
          };
        }
        buffer3 = Buffer.alloc(24);
        await tokenizer.peekBuffer(buffer3);
        if ((check([16, 251, 134, 1], { offset: 4 }) || check([8, 0, 0, 0], { offset: 4 })) && // This pattern differentiates ARW from other TIFF-ish file types:
        check([0, 254, 0, 4, 0, 1, 0, 0, 0, 1, 0, 0, 0, 3, 1], { offset: 9 })) {
          return {
            ext: "arw",
            mime: "image/x-sony-arw"
          };
        }
        return {
          ext: "tif",
          mime: "image/tiff"
        };
      }
      if (check([77, 77, 0, 42])) {
        return {
          ext: "tif",
          mime: "image/tiff"
        };
      }
      if (checkString("MAC ")) {
        return {
          ext: "ape",
          mime: "audio/ape"
        };
      }
      if (check([26, 69, 223, 163])) {
        async function readField() {
          const msb = await tokenizer.peekNumber(Token.UINT8);
          let mask3 = 128;
          let ic = 0;
          while ((msb & mask3) === 0) {
            ++ic;
            mask3 >>= 1;
          }
          const id = Buffer.alloc(ic + 1);
          await tokenizer.readBuffer(id);
          return id;
        }
        async function readElement() {
          const id = await readField();
          const lenField = await readField();
          lenField[0] ^= 128 >> lenField.length - 1;
          const nrLen = Math.min(6, lenField.length);
          return {
            id: id.readUIntBE(0, id.length),
            len: lenField.readUIntBE(lenField.length - nrLen, nrLen)
          };
        }
        async function readChildren(level, children) {
          while (children > 0) {
            const e = await readElement();
            if (e.id === 17026) {
              return tokenizer.readToken(new Token.StringType(e.len, "utf-8"));
            }
            await tokenizer.ignore(e.len);
            --children;
          }
        }
        const re = await readElement();
        const docType = await readChildren(1, re.len);
        switch (docType) {
          case "webm":
            return {
              ext: "webm",
              mime: "video/webm"
            };
          case "matroska":
            return {
              ext: "mkv",
              mime: "video/x-matroska"
            };
          default:
            return;
        }
      }
      if (check([82, 73, 70, 70])) {
        if (check([65, 86, 73], { offset: 8 })) {
          return {
            ext: "avi",
            mime: "video/vnd.avi"
          };
        }
        if (check([87, 65, 86, 69], { offset: 8 })) {
          return {
            ext: "wav",
            mime: "audio/vnd.wave"
          };
        }
        if (check([81, 76, 67, 77], { offset: 8 })) {
          return {
            ext: "qcp",
            mime: "audio/qcelp"
          };
        }
      }
      if (checkString("SQLi")) {
        return {
          ext: "sqlite",
          mime: "application/x-sqlite3"
        };
      }
      if (check([78, 69, 83, 26])) {
        return {
          ext: "nes",
          mime: "application/x-nintendo-nes-rom"
        };
      }
      if (checkString("Cr24")) {
        return {
          ext: "crx",
          mime: "application/x-google-chrome-extension"
        };
      }
      if (checkString("MSCF") || checkString("ISc(")) {
        return {
          ext: "cab",
          mime: "application/vnd.ms-cab-compressed"
        };
      }
      if (check([237, 171, 238, 219])) {
        return {
          ext: "rpm",
          mime: "application/x-rpm"
        };
      }
      if (check([197, 208, 211, 198])) {
        return {
          ext: "eps",
          mime: "application/eps"
        };
      }
      if (check([40, 181, 47, 253])) {
        return {
          ext: "zst",
          mime: "application/zstd"
        };
      }
      if (check([79, 84, 84, 79, 0])) {
        return {
          ext: "otf",
          mime: "font/otf"
        };
      }
      if (checkString("#!AMR")) {
        return {
          ext: "amr",
          mime: "audio/amr"
        };
      }
      if (checkString("{\\rtf")) {
        return {
          ext: "rtf",
          mime: "application/rtf"
        };
      }
      if (check([70, 76, 86, 1])) {
        return {
          ext: "flv",
          mime: "video/x-flv"
        };
      }
      if (checkString("IMPM")) {
        return {
          ext: "it",
          mime: "audio/x-it"
        };
      }
      if (checkString("-lh0-", { offset: 2 }) || checkString("-lh1-", { offset: 2 }) || checkString("-lh2-", { offset: 2 }) || checkString("-lh3-", { offset: 2 }) || checkString("-lh4-", { offset: 2 }) || checkString("-lh5-", { offset: 2 }) || checkString("-lh6-", { offset: 2 }) || checkString("-lh7-", { offset: 2 }) || checkString("-lzs-", { offset: 2 }) || checkString("-lz4-", { offset: 2 }) || checkString("-lz5-", { offset: 2 }) || checkString("-lhd-", { offset: 2 })) {
        return {
          ext: "lzh",
          mime: "application/x-lzh-compressed"
        };
      }
      if (check([0, 0, 1, 186])) {
        if (check([33], { offset: 4, mask: [241] })) {
          return {
            ext: "mpg",
            // May also be .ps, .mpeg
            mime: "video/MP1S"
          };
        }
        if (check([68], { offset: 4, mask: [196] })) {
          return {
            ext: "mpg",
            // May also be .mpg, .m2p, .vob or .sub
            mime: "video/MP2P"
          };
        }
      }
      if (checkString("ITSF")) {
        return {
          ext: "chm",
          mime: "application/vnd.ms-htmlhelp"
        };
      }
      if (check([253, 55, 122, 88, 90, 0])) {
        return {
          ext: "xz",
          mime: "application/x-xz"
        };
      }
      if (checkString("<?xml ")) {
        return {
          ext: "xml",
          mime: "application/xml"
        };
      }
      if (check([55, 122, 188, 175, 39, 28])) {
        return {
          ext: "7z",
          mime: "application/x-7z-compressed"
        };
      }
      if (check([82, 97, 114, 33, 26, 7]) && (buffer3[6] === 0 || buffer3[6] === 1)) {
        return {
          ext: "rar",
          mime: "application/x-rar-compressed"
        };
      }
      if (checkString("solid ")) {
        return {
          ext: "stl",
          mime: "model/stl"
        };
      }
      if (checkString("BLENDER")) {
        return {
          ext: "blend",
          mime: "application/x-blender"
        };
      }
      if (checkString("!<arch>")) {
        await tokenizer.ignore(8);
        const str2 = await tokenizer.readToken(new Token.StringType(13, "ascii"));
        if (str2 === "debian-binary") {
          return {
            ext: "deb",
            mime: "application/x-deb"
          };
        }
        return {
          ext: "ar",
          mime: "application/x-unix-archive"
        };
      }
      if (check([137, 80, 78, 71, 13, 10, 26, 10])) {
        await tokenizer.ignore(8);
        async function readChunkHeader() {
          return {
            length: await tokenizer.readToken(Token.INT32_BE),
            type: await tokenizer.readToken(new Token.StringType(4, "binary"))
          };
        }
        do {
          const chunk = await readChunkHeader();
          if (chunk.length < 0) {
            return;
          }
          switch (chunk.type) {
            case "IDAT":
              return {
                ext: "png",
                mime: "image/png"
              };
            case "acTL":
              return {
                ext: "apng",
                mime: "image/apng"
              };
            default:
              await tokenizer.ignore(chunk.length + 4);
          }
        } while (tokenizer.position + 8 < tokenizer.fileInfo.size);
        return {
          ext: "png",
          mime: "image/png"
        };
      }
      if (check([65, 82, 82, 79, 87, 49, 0, 0])) {
        return {
          ext: "arrow",
          mime: "application/x-apache-arrow"
        };
      }
      if (check([103, 108, 84, 70, 2, 0, 0, 0])) {
        return {
          ext: "glb",
          mime: "model/gltf-binary"
        };
      }
      if (check([102, 114, 101, 101], { offset: 4 }) || // `free`
      check([109, 100, 97, 116], { offset: 4 }) || // `mdat` MJPEG
      check([109, 111, 111, 118], { offset: 4 }) || // `moov`
      check([119, 105, 100, 101], { offset: 4 })) {
        return {
          ext: "mov",
          mime: "video/quicktime"
        };
      }
      if (check([73, 73, 82, 79, 8, 0, 0, 0, 24])) {
        return {
          ext: "orf",
          mime: "image/x-olympus-orf"
        };
      }
      if (checkString("gimp xcf ")) {
        return {
          ext: "xcf",
          mime: "image/x-xcf"
        };
      }
      if (check([73, 73, 85, 0, 24, 0, 0, 0, 136, 231, 116, 216])) {
        return {
          ext: "rw2",
          mime: "image/x-panasonic-rw2"
        };
      }
      if (check([48, 38, 178, 117, 142, 102, 207, 17, 166, 217])) {
        async function readHeader() {
          const guid = Buffer.alloc(16);
          await tokenizer.readBuffer(guid);
          return {
            id: guid,
            size: Number(await tokenizer.readToken(Token.UINT64_LE))
          };
        }
        await tokenizer.ignore(30);
        while (tokenizer.position + 24 < tokenizer.fileInfo.size) {
          const header = await readHeader();
          let payload = header.size - 24;
          if (_check(header.id, [145, 7, 220, 183, 183, 169, 207, 17, 142, 230, 0, 192, 12, 32, 83, 101])) {
            const typeId = Buffer.alloc(16);
            payload -= await tokenizer.readBuffer(typeId);
            if (_check(typeId, [64, 158, 105, 248, 77, 91, 207, 17, 168, 253, 0, 128, 95, 92, 68, 43])) {
              return {
                ext: "asf",
                mime: "audio/x-ms-asf"
              };
            }
            if (_check(typeId, [192, 239, 25, 188, 77, 91, 207, 17, 168, 253, 0, 128, 95, 92, 68, 43])) {
              return {
                ext: "asf",
                mime: "video/x-ms-asf"
              };
            }
            break;
          }
          await tokenizer.ignore(payload);
        }
        return {
          ext: "asf",
          mime: "application/vnd.ms-asf"
        };
      }
      if (check([171, 75, 84, 88, 32, 49, 49, 187, 13, 10, 26, 10])) {
        return {
          ext: "ktx",
          mime: "image/ktx"
        };
      }
      if ((check([126, 16, 4]) || check([126, 24, 4])) && check([48, 77, 73, 69], { offset: 4 })) {
        return {
          ext: "mie",
          mime: "application/x-mie"
        };
      }
      if (check([39, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], { offset: 2 })) {
        return {
          ext: "shp",
          mime: "application/x-esri-shape"
        };
      }
      if (check([0, 0, 0, 12, 106, 80, 32, 32, 13, 10, 135, 10])) {
        await tokenizer.ignore(20);
        const type3 = await tokenizer.readToken(new Token.StringType(4, "ascii"));
        switch (type3) {
          case "jp2 ":
            return {
              ext: "jp2",
              mime: "image/jp2"
            };
          case "jpx ":
            return {
              ext: "jpx",
              mime: "image/jpx"
            };
          case "jpm ":
            return {
              ext: "jpm",
              mime: "image/jpm"
            };
          case "mjp2":
            return {
              ext: "mj2",
              mime: "image/mj2"
            };
          default:
            return;
        }
      }
      if (check([255, 10]) || check([0, 0, 0, 12, 74, 88, 76, 32, 13, 10, 135, 10])) {
        return {
          ext: "jxl",
          mime: "image/jxl"
        };
      }
      if (check([0, 0, 1, 186]) || check([0, 0, 1, 179])) {
        return {
          ext: "mpg",
          mime: "video/mpeg"
        };
      }
      if (check([0, 1, 0, 0, 0])) {
        return {
          ext: "ttf",
          mime: "font/ttf"
        };
      }
      if (check([0, 0, 1, 0])) {
        return {
          ext: "ico",
          mime: "image/x-icon"
        };
      }
      if (check([0, 0, 2, 0])) {
        return {
          ext: "cur",
          mime: "image/x-icon"
        };
      }
      if (check([208, 207, 17, 224, 161, 177, 26, 225])) {
        return {
          ext: "cfb",
          mime: "application/x-cfb"
        };
      }
      await tokenizer.peekBuffer(buffer3, { length: Math.min(256, tokenizer.fileInfo.size), mayBeLess: true });
      if (checkString("BEGIN:")) {
        if (checkString("VCARD", { offset: 6 })) {
          return {
            ext: "vcf",
            mime: "text/vcard"
          };
        }
        if (checkString("VCALENDAR", { offset: 6 })) {
          return {
            ext: "ics",
            mime: "text/calendar"
          };
        }
      }
      if (checkString("FUJIFILMCCD-RAW")) {
        return {
          ext: "raf",
          mime: "image/x-fujifilm-raf"
        };
      }
      if (checkString("Extended Module:")) {
        return {
          ext: "xm",
          mime: "audio/x-xm"
        };
      }
      if (checkString("Creative Voice File")) {
        return {
          ext: "voc",
          mime: "audio/x-voc"
        };
      }
      if (check([4, 0, 0, 0]) && buffer3.length >= 16) {
        const jsonSize = buffer3.readUInt32LE(12);
        if (jsonSize > 12 && buffer3.length >= jsonSize + 16) {
          try {
            const header = buffer3.slice(16, jsonSize + 16).toString();
            const json = JSON.parse(header);
            if (json.files) {
              return {
                ext: "asar",
                mime: "application/x-asar"
              };
            }
          } catch (_) {
          }
        }
      }
      if (check([6, 14, 43, 52, 2, 5, 1, 1, 13, 1, 2, 1, 1, 2])) {
        return {
          ext: "mxf",
          mime: "application/mxf"
        };
      }
      if (checkString("SCRM", { offset: 44 })) {
        return {
          ext: "s3m",
          mime: "audio/x-s3m"
        };
      }
      if (check([71], { offset: 4 }) && (check([71], { offset: 192 }) || check([71], { offset: 196 }))) {
        return {
          ext: "mts",
          mime: "video/mp2t"
        };
      }
      if (check([66, 79, 79, 75, 77, 79, 66, 73], { offset: 60 })) {
        return {
          ext: "mobi",
          mime: "application/x-mobipocket-ebook"
        };
      }
      if (check([68, 73, 67, 77], { offset: 128 })) {
        return {
          ext: "dcm",
          mime: "application/dicom"
        };
      }
      if (check([76, 0, 0, 0, 1, 20, 2, 0, 0, 0, 0, 0, 192, 0, 0, 0, 0, 0, 0, 70])) {
        return {
          ext: "lnk",
          mime: "application/x.ms.shortcut"
          // Invented by us
        };
      }
      if (check([98, 111, 111, 107, 0, 0, 0, 0, 109, 97, 114, 107, 0, 0, 0, 0])) {
        return {
          ext: "alias",
          mime: "application/x.apple.alias"
          // Invented by us
        };
      }
      if (check([76, 80], { offset: 34 }) && (check([0, 0, 1], { offset: 8 }) || check([1, 0, 2], { offset: 8 }) || check([2, 0, 2], { offset: 8 }))) {
        return {
          ext: "eot",
          mime: "application/vnd.ms-fontobject"
        };
      }
      if (check([6, 6, 237, 245, 216, 29, 70, 229, 189, 49, 239, 231, 254, 116, 183, 29])) {
        return {
          ext: "indd",
          mime: "application/x-indesign"
        };
      }
      await tokenizer.peekBuffer(buffer3, { length: Math.min(512, tokenizer.fileInfo.size), mayBeLess: true });
      if (tarHeaderChecksumMatches(buffer3)) {
        return {
          ext: "tar",
          mime: "application/x-tar"
        };
      }
      if (check([255, 254, 255, 14, 83, 0, 107, 0, 101, 0, 116, 0, 99, 0, 104, 0, 85, 0, 112, 0, 32, 0, 77, 0, 111, 0, 100, 0, 101, 0, 108, 0])) {
        return {
          ext: "skp",
          mime: "application/vnd.sketchup.skp"
        };
      }
      if (checkString("-----BEGIN PGP MESSAGE-----")) {
        return {
          ext: "pgp",
          mime: "application/pgp-encrypted"
        };
      }
      if (buffer3.length >= 2 && check([255, 224], { offset: 0, mask: [255, 224] })) {
        if (check([16], { offset: 1, mask: [22] })) {
          if (check([8], { offset: 1, mask: [8] })) {
            return {
              ext: "aac",
              mime: "audio/aac"
            };
          }
          return {
            ext: "aac",
            mime: "audio/aac"
          };
        }
        if (check([2], { offset: 1, mask: [6] })) {
          return {
            ext: "mp3",
            mime: "audio/mpeg"
          };
        }
        if (check([4], { offset: 1, mask: [6] })) {
          return {
            ext: "mp2",
            mime: "audio/mpeg"
          };
        }
        if (check([6], { offset: 1, mask: [6] })) {
          return {
            ext: "mp1",
            mime: "audio/mpeg"
          };
        }
      }
    }
    var stream = (readableStream) => new Promise((resolve, reject) => {
      const stream = eval("require")("stream");
      readableStream.on("error", reject);
      readableStream.once("readable", async () => {
        const pass = new stream.PassThrough();
        let outputStream;
        if (stream.pipeline) {
          outputStream = stream.pipeline(readableStream, pass, () => {
          });
        } else {
          outputStream = readableStream.pipe(pass);
        }
        const chunk = readableStream.read(minimumBytes) || readableStream.read() || Buffer.alloc(0);
        try {
          const fileType3 = await fromBuffer(chunk);
          pass.fileType = fileType3;
        } catch (error) {
          reject(error);
        }
        resolve(outputStream);
      });
    });
    var fileType = {
      fromStream,
      fromTokenizer,
      fromBuffer,
      stream
    };
    Object.defineProperty(fileType, "extensions", {
      get() {
        return new Set(supported.extensions);
      }
    });
    Object.defineProperty(fileType, "mimeTypes", {
      get() {
        return new Set(supported.mimeTypes);
      }
    });
    module.exports = fileType;
  }
});

// node_modules/file-type/index.js
var require_file_type = __commonJS({
  "node_modules/file-type/index.js"(exports2, module2) {
    "use strict";
    var strtok32 = require_lib3();
    var core = require_core2();
    async function fromFile(path) {
      const tokenizer = await strtok32.fromFile(path);
      try {
        return await core.fromTokenizer(tokenizer);
      } finally {
        await tokenizer.close();
      }
    }
    var fileType3 = {
      fromFile
    };
    Object.assign(fileType3, core);
    Object.defineProperty(fileType3, "extensions", {
      get() {
        return core.extensions;
      }
    });
    Object.defineProperty(fileType3, "mimeTypes", {
      get() {
        return core.mimeTypes;
      }
    });
    module2.exports = fileType3;
  }
});

// node_modules/@noble/curves/node_modules/@noble/hashes/esm/crypto.js
var crypto2;
var init_crypto = __esm({
  "node_modules/@noble/curves/node_modules/@noble/hashes/esm/crypto.js"() {
    crypto2 = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
  }
});

// node_modules/@noble/curves/node_modules/@noble/hashes/esm/utils.js
function isBytes2(a) {
  return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
}
function anumber(n) {
  if (!Number.isSafeInteger(n) || n < 0)
    throw new Error("positive integer expected, got " + n);
}
function abytes(b, ...lengths) {
  if (!isBytes2(b))
    throw new Error("Uint8Array expected");
  if (lengths.length > 0 && !lengths.includes(b.length))
    throw new Error("Uint8Array expected of length " + lengths + ", got length=" + b.length);
}
function ahash(h) {
  if (typeof h !== "function" || typeof h.create !== "function")
    throw new Error("Hash should be wrapped by utils.createHasher");
  anumber(h.outputLen);
  anumber(h.blockLen);
}
function aexists(instance2, checkFinished = true) {
  if (instance2.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance2.finished)
    throw new Error("Hash#digest() has already been called");
}
function aoutput(out, instance2) {
  abytes(out);
  const min = instance2.outputLen;
  if (out.length < min) {
    throw new Error("digestInto() expects output buffer of length at least " + min);
  }
}
function clean(...arrays) {
  for (let i = 0; i < arrays.length; i++) {
    arrays[i].fill(0);
  }
}
function createView2(arr) {
  return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
}
function rotr2(word, shift) {
  return word << 32 - shift | word >>> shift;
}
function bytesToHex2(bytes3) {
  abytes(bytes3);
  if (hasHexBuiltin)
    return bytes3.toHex();
  let hex3 = "";
  for (let i = 0; i < bytes3.length; i++) {
    hex3 += hexes[bytes3[i]];
  }
  return hex3;
}
function asciiToBase16(ch) {
  if (ch >= asciis._0 && ch <= asciis._9)
    return ch - asciis._0;
  if (ch >= asciis.A && ch <= asciis.F)
    return ch - (asciis.A - 10);
  if (ch >= asciis.a && ch <= asciis.f)
    return ch - (asciis.a - 10);
  return;
}
function hexToBytes2(hex3) {
  if (typeof hex3 !== "string")
    throw new Error("hex string expected, got " + typeof hex3);
  if (hasHexBuiltin)
    return Uint8Array.fromHex(hex3);
  const hl = hex3.length;
  const al = hl / 2;
  if (hl % 2)
    throw new Error("hex string expected, got unpadded hex of length " + hl);
  const array4 = new Uint8Array(al);
  for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
    const n1 = asciiToBase16(hex3.charCodeAt(hi));
    const n2 = asciiToBase16(hex3.charCodeAt(hi + 1));
    if (n1 === void 0 || n2 === void 0) {
      const char = hex3[hi] + hex3[hi + 1];
      throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
    }
    array4[ai] = n1 * 16 + n2;
  }
  return array4;
}
function utf8ToBytes(str2) {
  if (typeof str2 !== "string")
    throw new Error("string expected");
  return new Uint8Array(new TextEncoder().encode(str2));
}
function toBytes3(data) {
  if (typeof data === "string")
    data = utf8ToBytes(data);
  abytes(data);
  return data;
}
function concatBytes2(...arrays) {
  let sum = 0;
  for (let i = 0; i < arrays.length; i++) {
    const a = arrays[i];
    abytes(a);
    sum += a.length;
  }
  const res = new Uint8Array(sum);
  for (let i = 0, pad3 = 0; i < arrays.length; i++) {
    const a = arrays[i];
    res.set(a, pad3);
    pad3 += a.length;
  }
  return res;
}
function createHasher(hashCons) {
  const hashC = (msg) => hashCons().update(toBytes3(msg)).digest();
  const tmp = hashCons();
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = () => hashCons();
  return hashC;
}
function randomBytes(bytesLength = 32) {
  if (crypto2 && typeof crypto2.getRandomValues === "function") {
    return crypto2.getRandomValues(new Uint8Array(bytesLength));
  }
  if (crypto2 && typeof crypto2.randomBytes === "function") {
    return Uint8Array.from(crypto2.randomBytes(bytesLength));
  }
  throw new Error("crypto.getRandomValues must be defined");
}
var isLE, hasHexBuiltin, hexes, asciis, Hash2;
var init_utils = __esm({
  "node_modules/@noble/curves/node_modules/@noble/hashes/esm/utils.js"() {
    init_crypto();
    isLE = (() => new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68)();
    hasHexBuiltin = (() => (
      // @ts-ignore
      typeof Uint8Array.from([]).toHex === "function" && typeof Uint8Array.fromHex === "function"
    ))();
    hexes = Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
    asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
    Hash2 = class {
    };
  }
});

// node_modules/@noble/curves/node_modules/@noble/hashes/esm/_md.js
function setBigUint642(view, byteOffset, value, isLE6) {
  if (typeof view.setBigUint64 === "function")
    return view.setBigUint64(byteOffset, value, isLE6);
  const _32n6 = BigInt(32);
  const _u32_max = BigInt(4294967295);
  const wh = Number(value >> _32n6 & _u32_max);
  const wl = Number(value & _u32_max);
  const h = isLE6 ? 4 : 0;
  const l = isLE6 ? 0 : 4;
  view.setUint32(byteOffset + h, wh, isLE6);
  view.setUint32(byteOffset + l, wl, isLE6);
}
function Chi2(a, b, c) {
  return a & b ^ ~a & c;
}
function Maj2(a, b, c) {
  return a & b ^ a & c ^ b & c;
}
var HashMD2, SHA256_IV2, SHA224_IV, SHA384_IV, SHA512_IV;
var init_md = __esm({
  "node_modules/@noble/curves/node_modules/@noble/hashes/esm/_md.js"() {
    init_utils();
    HashMD2 = class extends Hash2 {
      constructor(blockLen, outputLen, padOffset, isLE6) {
        super();
        this.finished = false;
        this.length = 0;
        this.pos = 0;
        this.destroyed = false;
        this.blockLen = blockLen;
        this.outputLen = outputLen;
        this.padOffset = padOffset;
        this.isLE = isLE6;
        this.buffer = new Uint8Array(blockLen);
        this.view = createView2(this.buffer);
      }
      update(data) {
        aexists(this);
        data = toBytes3(data);
        abytes(data);
        const { view, buffer: buffer3, blockLen } = this;
        const len = data.length;
        for (let pos = 0; pos < len; ) {
          const take = Math.min(blockLen - this.pos, len - pos);
          if (take === blockLen) {
            const dataView = createView2(data);
            for (; blockLen <= len - pos; pos += blockLen)
              this.process(dataView, pos);
            continue;
          }
          buffer3.set(data.subarray(pos, pos + take), this.pos);
          this.pos += take;
          pos += take;
          if (this.pos === blockLen) {
            this.process(view, 0);
            this.pos = 0;
          }
        }
        this.length += data.length;
        this.roundClean();
        return this;
      }
      digestInto(out) {
        aexists(this);
        aoutput(out, this);
        this.finished = true;
        const { buffer: buffer3, view, blockLen, isLE: isLE6 } = this;
        let { pos } = this;
        buffer3[pos++] = 128;
        clean(this.buffer.subarray(pos));
        if (this.padOffset > blockLen - pos) {
          this.process(view, 0);
          pos = 0;
        }
        for (let i = pos; i < blockLen; i++)
          buffer3[i] = 0;
        setBigUint642(view, blockLen - 8, BigInt(this.length * 8), isLE6);
        this.process(view, 0);
        const oview = createView2(out);
        const len = this.outputLen;
        if (len % 4)
          throw new Error("_sha2: outputLen should be aligned to 32bit");
        const outLen = len / 4;
        const state = this.get();
        if (outLen > state.length)
          throw new Error("_sha2: outputLen bigger than state");
        for (let i = 0; i < outLen; i++)
          oview.setUint32(4 * i, state[i], isLE6);
      }
      digest() {
        const { buffer: buffer3, outputLen } = this;
        this.digestInto(buffer3);
        const res = buffer3.slice(0, outputLen);
        this.destroy();
        return res;
      }
      _cloneInto(to) {
        to || (to = new this.constructor());
        to.set(...this.get());
        const { blockLen, buffer: buffer3, length: length2, finished: finished2, destroyed, pos } = this;
        to.destroyed = destroyed;
        to.finished = finished2;
        to.length = length2;
        to.pos = pos;
        if (length2 % blockLen)
          to.buffer.set(buffer3);
        return to;
      }
      clone() {
        return this._cloneInto();
      }
    };
    SHA256_IV2 = Uint32Array.from([
      1779033703,
      3144134277,
      1013904242,
      2773480762,
      1359893119,
      2600822924,
      528734635,
      1541459225
    ]);
    SHA224_IV = Uint32Array.from([
      3238371032,
      914150663,
      812702999,
      4144912697,
      4290775857,
      1750603025,
      1694076839,
      3204075428
    ]);
    SHA384_IV = Uint32Array.from([
      3418070365,
      3238371032,
      1654270250,
      914150663,
      2438529370,
      812702999,
      355462360,
      4144912697,
      1731405415,
      4290775857,
      2394180231,
      1750603025,
      3675008525,
      1694076839,
      1203062813,
      3204075428
    ]);
    SHA512_IV = Uint32Array.from([
      1779033703,
      4089235720,
      3144134277,
      2227873595,
      1013904242,
      4271175723,
      2773480762,
      1595750129,
      1359893119,
      2917565137,
      2600822924,
      725511199,
      528734635,
      4215389547,
      1541459225,
      327033209
    ]);
  }
});

// node_modules/@noble/curves/node_modules/@noble/hashes/esm/_u64.js
function fromBig(n, le = false) {
  if (le)
    return { h: Number(n & U32_MASK64), l: Number(n >> _32n & U32_MASK64) };
  return { h: Number(n >> _32n & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
}
function split(lst, le = false) {
  const len = lst.length;
  let Ah = new Uint32Array(len);
  let Al = new Uint32Array(len);
  for (let i = 0; i < len; i++) {
    const { h, l } = fromBig(lst[i], le);
    [Ah[i], Al[i]] = [h, l];
  }
  return [Ah, Al];
}
function add(Ah, Al, Bh, Bl) {
  const l = (Al >>> 0) + (Bl >>> 0);
  return { h: Ah + Bh + (l / 2 ** 32 | 0) | 0, l: l | 0 };
}
var U32_MASK64, _32n, shrSH, shrSL, rotrSH, rotrSL, rotrBH, rotrBL, add3L, add3H, add4L, add4H, add5L, add5H;
var init_u64 = __esm({
  "node_modules/@noble/curves/node_modules/@noble/hashes/esm/_u64.js"() {
    U32_MASK64 = BigInt(2 ** 32 - 1);
    _32n = BigInt(32);
    shrSH = (h, _l, s) => h >>> s;
    shrSL = (h, l, s) => h << 32 - s | l >>> s;
    rotrSH = (h, l, s) => h >>> s | l << 32 - s;
    rotrSL = (h, l, s) => h << 32 - s | l >>> s;
    rotrBH = (h, l, s) => h << 64 - s | l >>> s - 32;
    rotrBL = (h, l, s) => h >>> s - 32 | l << 64 - s;
    add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
    add3H = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
    add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
    add4H = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
    add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
    add5H = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
  }
});

// node_modules/@noble/curves/node_modules/@noble/hashes/esm/sha2.js
var SHA256_K2, SHA256_W2, SHA2562, SHA2242, K512, SHA512_Kh, SHA512_Kl, SHA512_W_H, SHA512_W_L, SHA512, SHA384, T224_IV, T256_IV, SHA512_224, SHA512_256, sha2563, sha2242, sha512, sha384, sha512_256, sha512_224;
var init_sha2 = __esm({
  "node_modules/@noble/curves/node_modules/@noble/hashes/esm/sha2.js"() {
    init_md();
    init_u64();
    init_utils();
    SHA256_K2 = Uint32Array.from([
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ]);
    SHA256_W2 = new Uint32Array(64);
    SHA2562 = class extends HashMD2 {
      constructor(outputLen = 32) {
        super(64, outputLen, 8, false);
        this.A = SHA256_IV2[0] | 0;
        this.B = SHA256_IV2[1] | 0;
        this.C = SHA256_IV2[2] | 0;
        this.D = SHA256_IV2[3] | 0;
        this.E = SHA256_IV2[4] | 0;
        this.F = SHA256_IV2[5] | 0;
        this.G = SHA256_IV2[6] | 0;
        this.H = SHA256_IV2[7] | 0;
      }
      get() {
        const { A, B, C, D, E, F, G, H } = this;
        return [A, B, C, D, E, F, G, H];
      }
      // prettier-ignore
      set(A, B, C, D, E, F, G, H) {
        this.A = A | 0;
        this.B = B | 0;
        this.C = C | 0;
        this.D = D | 0;
        this.E = E | 0;
        this.F = F | 0;
        this.G = G | 0;
        this.H = H | 0;
      }
      process(view, offset3) {
        for (let i = 0; i < 16; i++, offset3 += 4)
          SHA256_W2[i] = view.getUint32(offset3, false);
        for (let i = 16; i < 64; i++) {
          const W15 = SHA256_W2[i - 15];
          const W2 = SHA256_W2[i - 2];
          const s0 = rotr2(W15, 7) ^ rotr2(W15, 18) ^ W15 >>> 3;
          const s1 = rotr2(W2, 17) ^ rotr2(W2, 19) ^ W2 >>> 10;
          SHA256_W2[i] = s1 + SHA256_W2[i - 7] + s0 + SHA256_W2[i - 16] | 0;
        }
        let { A, B, C, D, E, F, G, H } = this;
        for (let i = 0; i < 64; i++) {
          const sigma1 = rotr2(E, 6) ^ rotr2(E, 11) ^ rotr2(E, 25);
          const T1 = H + sigma1 + Chi2(E, F, G) + SHA256_K2[i] + SHA256_W2[i] | 0;
          const sigma0 = rotr2(A, 2) ^ rotr2(A, 13) ^ rotr2(A, 22);
          const T2 = sigma0 + Maj2(A, B, C) | 0;
          H = G;
          G = F;
          F = E;
          E = D + T1 | 0;
          D = C;
          C = B;
          B = A;
          A = T1 + T2 | 0;
        }
        A = A + this.A | 0;
        B = B + this.B | 0;
        C = C + this.C | 0;
        D = D + this.D | 0;
        E = E + this.E | 0;
        F = F + this.F | 0;
        G = G + this.G | 0;
        H = H + this.H | 0;
        this.set(A, B, C, D, E, F, G, H);
      }
      roundClean() {
        clean(SHA256_W2);
      }
      destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0);
        clean(this.buffer);
      }
    };
    SHA2242 = class extends SHA2562 {
      constructor() {
        super(28);
        this.A = SHA224_IV[0] | 0;
        this.B = SHA224_IV[1] | 0;
        this.C = SHA224_IV[2] | 0;
        this.D = SHA224_IV[3] | 0;
        this.E = SHA224_IV[4] | 0;
        this.F = SHA224_IV[5] | 0;
        this.G = SHA224_IV[6] | 0;
        this.H = SHA224_IV[7] | 0;
      }
    };
    K512 = (() => split([
      "0x428a2f98d728ae22",
      "0x7137449123ef65cd",
      "0xb5c0fbcfec4d3b2f",
      "0xe9b5dba58189dbbc",
      "0x3956c25bf348b538",
      "0x59f111f1b605d019",
      "0x923f82a4af194f9b",
      "0xab1c5ed5da6d8118",
      "0xd807aa98a3030242",
      "0x12835b0145706fbe",
      "0x243185be4ee4b28c",
      "0x550c7dc3d5ffb4e2",
      "0x72be5d74f27b896f",
      "0x80deb1fe3b1696b1",
      "0x9bdc06a725c71235",
      "0xc19bf174cf692694",
      "0xe49b69c19ef14ad2",
      "0xefbe4786384f25e3",
      "0x0fc19dc68b8cd5b5",
      "0x240ca1cc77ac9c65",
      "0x2de92c6f592b0275",
      "0x4a7484aa6ea6e483",
      "0x5cb0a9dcbd41fbd4",
      "0x76f988da831153b5",
      "0x983e5152ee66dfab",
      "0xa831c66d2db43210",
      "0xb00327c898fb213f",
      "0xbf597fc7beef0ee4",
      "0xc6e00bf33da88fc2",
      "0xd5a79147930aa725",
      "0x06ca6351e003826f",
      "0x142929670a0e6e70",
      "0x27b70a8546d22ffc",
      "0x2e1b21385c26c926",
      "0x4d2c6dfc5ac42aed",
      "0x53380d139d95b3df",
      "0x650a73548baf63de",
      "0x766a0abb3c77b2a8",
      "0x81c2c92e47edaee6",
      "0x92722c851482353b",
      "0xa2bfe8a14cf10364",
      "0xa81a664bbc423001",
      "0xc24b8b70d0f89791",
      "0xc76c51a30654be30",
      "0xd192e819d6ef5218",
      "0xd69906245565a910",
      "0xf40e35855771202a",
      "0x106aa07032bbd1b8",
      "0x19a4c116b8d2d0c8",
      "0x1e376c085141ab53",
      "0x2748774cdf8eeb99",
      "0x34b0bcb5e19b48a8",
      "0x391c0cb3c5c95a63",
      "0x4ed8aa4ae3418acb",
      "0x5b9cca4f7763e373",
      "0x682e6ff3d6b2b8a3",
      "0x748f82ee5defb2fc",
      "0x78a5636f43172f60",
      "0x84c87814a1f0ab72",
      "0x8cc702081a6439ec",
      "0x90befffa23631e28",
      "0xa4506cebde82bde9",
      "0xbef9a3f7b2c67915",
      "0xc67178f2e372532b",
      "0xca273eceea26619c",
      "0xd186b8c721c0c207",
      "0xeada7dd6cde0eb1e",
      "0xf57d4f7fee6ed178",
      "0x06f067aa72176fba",
      "0x0a637dc5a2c898a6",
      "0x113f9804bef90dae",
      "0x1b710b35131c471b",
      "0x28db77f523047d84",
      "0x32caab7b40c72493",
      "0x3c9ebe0a15c9bebc",
      "0x431d67c49c100d4c",
      "0x4cc5d4becb3e42b6",
      "0x597f299cfc657e2a",
      "0x5fcb6fab3ad6faec",
      "0x6c44198c4a475817"
    ].map((n) => BigInt(n))))();
    SHA512_Kh = (() => K512[0])();
    SHA512_Kl = (() => K512[1])();
    SHA512_W_H = new Uint32Array(80);
    SHA512_W_L = new Uint32Array(80);
    SHA512 = class extends HashMD2 {
      constructor(outputLen = 64) {
        super(128, outputLen, 16, false);
        this.Ah = SHA512_IV[0] | 0;
        this.Al = SHA512_IV[1] | 0;
        this.Bh = SHA512_IV[2] | 0;
        this.Bl = SHA512_IV[3] | 0;
        this.Ch = SHA512_IV[4] | 0;
        this.Cl = SHA512_IV[5] | 0;
        this.Dh = SHA512_IV[6] | 0;
        this.Dl = SHA512_IV[7] | 0;
        this.Eh = SHA512_IV[8] | 0;
        this.El = SHA512_IV[9] | 0;
        this.Fh = SHA512_IV[10] | 0;
        this.Fl = SHA512_IV[11] | 0;
        this.Gh = SHA512_IV[12] | 0;
        this.Gl = SHA512_IV[13] | 0;
        this.Hh = SHA512_IV[14] | 0;
        this.Hl = SHA512_IV[15] | 0;
      }
      // prettier-ignore
      get() {
        const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
        return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
      }
      // prettier-ignore
      set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
        this.Ah = Ah | 0;
        this.Al = Al | 0;
        this.Bh = Bh | 0;
        this.Bl = Bl | 0;
        this.Ch = Ch | 0;
        this.Cl = Cl | 0;
        this.Dh = Dh | 0;
        this.Dl = Dl | 0;
        this.Eh = Eh | 0;
        this.El = El | 0;
        this.Fh = Fh | 0;
        this.Fl = Fl | 0;
        this.Gh = Gh | 0;
        this.Gl = Gl | 0;
        this.Hh = Hh | 0;
        this.Hl = Hl | 0;
      }
      process(view, offset3) {
        for (let i = 0; i < 16; i++, offset3 += 4) {
          SHA512_W_H[i] = view.getUint32(offset3);
          SHA512_W_L[i] = view.getUint32(offset3 += 4);
        }
        for (let i = 16; i < 80; i++) {
          const W15h = SHA512_W_H[i - 15] | 0;
          const W15l = SHA512_W_L[i - 15] | 0;
          const s0h = rotrSH(W15h, W15l, 1) ^ rotrSH(W15h, W15l, 8) ^ shrSH(W15h, W15l, 7);
          const s0l = rotrSL(W15h, W15l, 1) ^ rotrSL(W15h, W15l, 8) ^ shrSL(W15h, W15l, 7);
          const W2h = SHA512_W_H[i - 2] | 0;
          const W2l = SHA512_W_L[i - 2] | 0;
          const s1h = rotrSH(W2h, W2l, 19) ^ rotrBH(W2h, W2l, 61) ^ shrSH(W2h, W2l, 6);
          const s1l = rotrSL(W2h, W2l, 19) ^ rotrBL(W2h, W2l, 61) ^ shrSL(W2h, W2l, 6);
          const SUMl = add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);
          const SUMh = add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);
          SHA512_W_H[i] = SUMh | 0;
          SHA512_W_L[i] = SUMl | 0;
        }
        let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
        for (let i = 0; i < 80; i++) {
          const sigma1h = rotrSH(Eh, El, 14) ^ rotrSH(Eh, El, 18) ^ rotrBH(Eh, El, 41);
          const sigma1l = rotrSL(Eh, El, 14) ^ rotrSL(Eh, El, 18) ^ rotrBL(Eh, El, 41);
          const CHIh = Eh & Fh ^ ~Eh & Gh;
          const CHIl = El & Fl ^ ~El & Gl;
          const T1ll = add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);
          const T1h = add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);
          const T1l = T1ll | 0;
          const sigma0h = rotrSH(Ah, Al, 28) ^ rotrBH(Ah, Al, 34) ^ rotrBH(Ah, Al, 39);
          const sigma0l = rotrSL(Ah, Al, 28) ^ rotrBL(Ah, Al, 34) ^ rotrBL(Ah, Al, 39);
          const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
          const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;
          Hh = Gh | 0;
          Hl = Gl | 0;
          Gh = Fh | 0;
          Gl = Fl | 0;
          Fh = Eh | 0;
          Fl = El | 0;
          ({ h: Eh, l: El } = add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
          Dh = Ch | 0;
          Dl = Cl | 0;
          Ch = Bh | 0;
          Cl = Bl | 0;
          Bh = Ah | 0;
          Bl = Al | 0;
          const All = add3L(T1l, sigma0l, MAJl);
          Ah = add3H(All, T1h, sigma0h, MAJh);
          Al = All | 0;
        }
        ({ h: Ah, l: Al } = add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
        ({ h: Bh, l: Bl } = add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
        ({ h: Ch, l: Cl } = add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
        ({ h: Dh, l: Dl } = add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
        ({ h: Eh, l: El } = add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
        ({ h: Fh, l: Fl } = add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
        ({ h: Gh, l: Gl } = add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
        ({ h: Hh, l: Hl } = add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
        this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
      }
      roundClean() {
        clean(SHA512_W_H, SHA512_W_L);
      }
      destroy() {
        clean(this.buffer);
        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
      }
    };
    SHA384 = class extends SHA512 {
      constructor() {
        super(48);
        this.Ah = SHA384_IV[0] | 0;
        this.Al = SHA384_IV[1] | 0;
        this.Bh = SHA384_IV[2] | 0;
        this.Bl = SHA384_IV[3] | 0;
        this.Ch = SHA384_IV[4] | 0;
        this.Cl = SHA384_IV[5] | 0;
        this.Dh = SHA384_IV[6] | 0;
        this.Dl = SHA384_IV[7] | 0;
        this.Eh = SHA384_IV[8] | 0;
        this.El = SHA384_IV[9] | 0;
        this.Fh = SHA384_IV[10] | 0;
        this.Fl = SHA384_IV[11] | 0;
        this.Gh = SHA384_IV[12] | 0;
        this.Gl = SHA384_IV[13] | 0;
        this.Hh = SHA384_IV[14] | 0;
        this.Hl = SHA384_IV[15] | 0;
      }
    };
    T224_IV = Uint32Array.from([
      2352822216,
      424955298,
      1944164710,
      2312950998,
      502970286,
      855612546,
      1738396948,
      1479516111,
      258812777,
      2077511080,
      2011393907,
      79989058,
      1067287976,
      1780299464,
      286451373,
      2446758561
    ]);
    T256_IV = Uint32Array.from([
      573645204,
      4230739756,
      2673172387,
      3360449730,
      596883563,
      1867755857,
      2520282905,
      1497426621,
      2519219938,
      2827943907,
      3193839141,
      1401305490,
      721525244,
      746961066,
      246885852,
      2177182882
    ]);
    SHA512_224 = class extends SHA512 {
      constructor() {
        super(28);
        this.Ah = T224_IV[0] | 0;
        this.Al = T224_IV[1] | 0;
        this.Bh = T224_IV[2] | 0;
        this.Bl = T224_IV[3] | 0;
        this.Ch = T224_IV[4] | 0;
        this.Cl = T224_IV[5] | 0;
        this.Dh = T224_IV[6] | 0;
        this.Dl = T224_IV[7] | 0;
        this.Eh = T224_IV[8] | 0;
        this.El = T224_IV[9] | 0;
        this.Fh = T224_IV[10] | 0;
        this.Fl = T224_IV[11] | 0;
        this.Gh = T224_IV[12] | 0;
        this.Gl = T224_IV[13] | 0;
        this.Hh = T224_IV[14] | 0;
        this.Hl = T224_IV[15] | 0;
      }
    };
    SHA512_256 = class extends SHA512 {
      constructor() {
        super(32);
        this.Ah = T256_IV[0] | 0;
        this.Al = T256_IV[1] | 0;
        this.Bh = T256_IV[2] | 0;
        this.Bl = T256_IV[3] | 0;
        this.Ch = T256_IV[4] | 0;
        this.Cl = T256_IV[5] | 0;
        this.Dh = T256_IV[6] | 0;
        this.Dl = T256_IV[7] | 0;
        this.Eh = T256_IV[8] | 0;
        this.El = T256_IV[9] | 0;
        this.Fh = T256_IV[10] | 0;
        this.Fl = T256_IV[11] | 0;
        this.Gh = T256_IV[12] | 0;
        this.Gl = T256_IV[13] | 0;
        this.Hh = T256_IV[14] | 0;
        this.Hl = T256_IV[15] | 0;
      }
    };
    sha2563 = createHasher(() => new SHA2562());
    sha2242 = createHasher(() => new SHA2242());
    sha512 = createHasher(() => new SHA512());
    sha384 = createHasher(() => new SHA384());
    sha512_256 = createHasher(() => new SHA512_256());
    sha512_224 = createHasher(() => new SHA512_224());
  }
});

// node_modules/@noble/curves/esm/utils.js
function _abool2(value, title = "") {
  if (typeof value !== "boolean") {
    const prefix = title && `"${title}"`;
    throw new Error(prefix + "expected boolean, got type=" + typeof value);
  }
  return value;
}
function _abytes2(value, length2, title = "") {
  const bytes3 = isBytes2(value);
  const len = value == null ? void 0 : value.length;
  const needsLen = length2 !== void 0;
  if (!bytes3 || needsLen && len !== length2) {
    const prefix = title && `"${title}" `;
    const ofLen = needsLen ? ` of length ${length2}` : "";
    const got = bytes3 ? `length=${len}` : `type=${typeof value}`;
    throw new Error(prefix + "expected Uint8Array" + ofLen + ", got " + got);
  }
  return value;
}
function numberToHexUnpadded(num2) {
  const hex3 = num2.toString(16);
  return hex3.length & 1 ? "0" + hex3 : hex3;
}
function hexToNumber2(hex3) {
  if (typeof hex3 !== "string")
    throw new Error("hex string expected, got " + typeof hex3);
  return hex3 === "" ? _0n : BigInt("0x" + hex3);
}
function bytesToNumberBE(bytes3) {
  return hexToNumber2(bytesToHex2(bytes3));
}
function bytesToNumberLE(bytes3) {
  abytes(bytes3);
  return hexToNumber2(bytesToHex2(Uint8Array.from(bytes3).reverse()));
}
function numberToBytesBE(n, len) {
  return hexToBytes2(n.toString(16).padStart(len * 2, "0"));
}
function numberToBytesLE(n, len) {
  return numberToBytesBE(n, len).reverse();
}
function ensureBytes(title, hex3, expectedLength) {
  let res;
  if (typeof hex3 === "string") {
    try {
      res = hexToBytes2(hex3);
    } catch (e) {
      throw new Error(title + " must be hex string or Uint8Array, cause: " + e);
    }
  } else if (isBytes2(hex3)) {
    res = Uint8Array.from(hex3);
  } else {
    throw new Error(title + " must be hex string or Uint8Array");
  }
  const len = res.length;
  if (typeof expectedLength === "number" && len !== expectedLength)
    throw new Error(title + " of length " + expectedLength + " expected, got " + len);
  return res;
}
function equalBytes2(a, b) {
  if (a.length !== b.length)
    return false;
  let diff = 0;
  for (let i = 0; i < a.length; i++)
    diff |= a[i] ^ b[i];
  return diff === 0;
}
function copyBytes(bytes3) {
  return Uint8Array.from(bytes3);
}
function inRange(n, min, max) {
  return isPosBig(n) && isPosBig(min) && isPosBig(max) && min <= n && n < max;
}
function aInRange(title, n, min, max) {
  if (!inRange(n, min, max))
    throw new Error("expected valid " + title + ": " + min + " <= n < " + max + ", got " + n);
}
function bitLen(n) {
  let len;
  for (len = 0; n > _0n; n >>= _1n, len += 1)
    ;
  return len;
}
function createHmacDrbg(hashLen, qByteLen, hmacFn) {
  if (typeof hashLen !== "number" || hashLen < 2)
    throw new Error("hashLen must be a number");
  if (typeof qByteLen !== "number" || qByteLen < 2)
    throw new Error("qByteLen must be a number");
  if (typeof hmacFn !== "function")
    throw new Error("hmacFn must be a function");
  const u8n2 = (len) => new Uint8Array(len);
  const u8of = (byte) => Uint8Array.of(byte);
  let v = u8n2(hashLen);
  let k = u8n2(hashLen);
  let i = 0;
  const reset2 = () => {
    v.fill(1);
    k.fill(0);
    i = 0;
  };
  const h = (...b) => hmacFn(k, v, ...b);
  const reseed = (seed2 = u8n2(0)) => {
    k = h(u8of(0), seed2);
    v = h();
    if (seed2.length === 0)
      return;
    k = h(u8of(1), seed2);
    v = h();
  };
  const gen4 = () => {
    if (i++ >= 1e3)
      throw new Error("drbg: tried 1000 values");
    let len = 0;
    const out = [];
    while (len < qByteLen) {
      v = h();
      const sl = v.slice();
      out.push(sl);
      len += v.length;
    }
    return concatBytes2(...out);
  };
  const genUntil = (seed2, pred) => {
    reset2();
    reseed(seed2);
    let res = void 0;
    while (!(res = pred(gen4())))
      reseed();
    reset2();
    return res;
  };
  return genUntil;
}
function isHash2(val) {
  return typeof val === "function" && Number.isSafeInteger(val.outputLen);
}
function _validateObject(object, fields, optFields = {}) {
  if (!object || typeof object !== "object")
    throw new Error("expected valid options object");
  function checkField(fieldName, expectedType, isOpt) {
    const val = object[fieldName];
    if (isOpt && val === void 0)
      return;
    const current = typeof val;
    if (current !== expectedType || val === null)
      throw new Error(`param "${fieldName}" is invalid: expected ${expectedType}, got ${current}`);
  }
  Object.entries(fields).forEach(([k, v]) => checkField(k, v, false));
  Object.entries(optFields).forEach(([k, v]) => checkField(k, v, true));
}
function memoized(fn) {
  const map = /* @__PURE__ */ new WeakMap();
  return (arg, ...args) => {
    const val = map.get(arg);
    if (val !== void 0)
      return val;
    const computed = fn(arg, ...args);
    map.set(arg, computed);
    return computed;
  };
}
var _0n, _1n, isPosBig, bitMask, notImplemented;
var init_utils2 = __esm({
  "node_modules/@noble/curves/esm/utils.js"() {
    init_utils();
    init_utils();
    _0n = BigInt(0);
    _1n = BigInt(1);
    isPosBig = (n) => typeof n === "bigint" && _0n <= n;
    bitMask = (n) => (_1n << BigInt(n)) - _1n;
    notImplemented = () => {
      throw new Error("not implemented");
    };
  }
});

// node_modules/@noble/curves/esm/abstract/modular.js
function mod(a, b) {
  const result = a % b;
  return result >= _0n2 ? result : b + result;
}
function pow2(x, power, modulo) {
  let res = x;
  while (power-- > _0n2) {
    res *= res;
    res %= modulo;
  }
  return res;
}
function invert(number5, modulo) {
  if (number5 === _0n2)
    throw new Error("invert: expected non-zero number");
  if (modulo <= _0n2)
    throw new Error("invert: expected positive modulus, got " + modulo);
  let a = mod(number5, modulo);
  let b = modulo;
  let x = _0n2, y = _1n2, u = _1n2, v = _0n2;
  while (a !== _0n2) {
    const q = b / a;
    const r = b % a;
    const m = x - u * q;
    const n = y - v * q;
    b = a, a = r, x = u, y = v, u = m, v = n;
  }
  const gcd2 = b;
  if (gcd2 !== _1n2)
    throw new Error("invert: does not exist");
  return mod(x, modulo);
}
function assertIsSquare(Fp3, root2, n) {
  if (!Fp3.eql(Fp3.sqr(root2), n))
    throw new Error("Cannot find square root");
}
function sqrt3mod4(Fp3, n) {
  const p1div4 = (Fp3.ORDER + _1n2) / _4n;
  const root2 = Fp3.pow(n, p1div4);
  assertIsSquare(Fp3, root2, n);
  return root2;
}
function sqrt5mod8(Fp3, n) {
  const p5div8 = (Fp3.ORDER - _5n) / _8n;
  const n2 = Fp3.mul(n, _2n);
  const v = Fp3.pow(n2, p5div8);
  const nv = Fp3.mul(n, v);
  const i = Fp3.mul(Fp3.mul(nv, _2n), v);
  const root2 = Fp3.mul(nv, Fp3.sub(i, Fp3.ONE));
  assertIsSquare(Fp3, root2, n);
  return root2;
}
function sqrt9mod16(P) {
  const Fp_ = Field(P);
  const tn = tonelliShanks(P);
  const c1 = tn(Fp_, Fp_.neg(Fp_.ONE));
  const c2 = tn(Fp_, c1);
  const c3 = tn(Fp_, Fp_.neg(c1));
  const c4 = (P + _7n) / _16n;
  return (Fp3, n) => {
    let tv1 = Fp3.pow(n, c4);
    let tv2 = Fp3.mul(tv1, c1);
    const tv3 = Fp3.mul(tv1, c2);
    const tv4 = Fp3.mul(tv1, c3);
    const e1 = Fp3.eql(Fp3.sqr(tv2), n);
    const e2 = Fp3.eql(Fp3.sqr(tv3), n);
    tv1 = Fp3.cmov(tv1, tv2, e1);
    tv2 = Fp3.cmov(tv4, tv3, e2);
    const e3 = Fp3.eql(Fp3.sqr(tv2), n);
    const root2 = Fp3.cmov(tv1, tv2, e3);
    assertIsSquare(Fp3, root2, n);
    return root2;
  };
}
function tonelliShanks(P) {
  if (P < _3n)
    throw new Error("sqrt is not defined for small field");
  let Q = P - _1n2;
  let S = 0;
  while (Q % _2n === _0n2) {
    Q /= _2n;
    S++;
  }
  let Z = _2n;
  const _Fp = Field(P);
  while (FpLegendre(_Fp, Z) === 1) {
    if (Z++ > 1e3)
      throw new Error("Cannot find square root: probably non-prime P");
  }
  if (S === 1)
    return sqrt3mod4;
  let cc = _Fp.pow(Z, Q);
  const Q1div2 = (Q + _1n2) / _2n;
  return function tonelliSlow(Fp3, n) {
    if (Fp3.is0(n))
      return n;
    if (FpLegendre(Fp3, n) !== 1)
      throw new Error("Cannot find square root");
    let M = S;
    let c = Fp3.mul(Fp3.ONE, cc);
    let t = Fp3.pow(n, Q);
    let R = Fp3.pow(n, Q1div2);
    while (!Fp3.eql(t, Fp3.ONE)) {
      if (Fp3.is0(t))
        return Fp3.ZERO;
      let i = 1;
      let t_tmp = Fp3.sqr(t);
      while (!Fp3.eql(t_tmp, Fp3.ONE)) {
        i++;
        t_tmp = Fp3.sqr(t_tmp);
        if (i === M)
          throw new Error("Cannot find square root");
      }
      const exponent = _1n2 << BigInt(M - i - 1);
      const b = Fp3.pow(c, exponent);
      M = i;
      c = Fp3.sqr(b);
      t = Fp3.mul(t, c);
      R = Fp3.mul(R, b);
    }
    return R;
  };
}
function FpSqrt(P) {
  if (P % _4n === _3n)
    return sqrt3mod4;
  if (P % _8n === _5n)
    return sqrt5mod8;
  if (P % _16n === _9n)
    return sqrt9mod16(P);
  return tonelliShanks(P);
}
function validateField(field) {
  const initial = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "number",
    BITS: "number"
  };
  const opts = FIELD_FIELDS.reduce((map, val) => {
    map[val] = "function";
    return map;
  }, initial);
  _validateObject(field, opts);
  return field;
}
function FpPow(Fp3, num2, power) {
  if (power < _0n2)
    throw new Error("invalid exponent, negatives unsupported");
  if (power === _0n2)
    return Fp3.ONE;
  if (power === _1n2)
    return num2;
  let p = Fp3.ONE;
  let d = num2;
  while (power > _0n2) {
    if (power & _1n2)
      p = Fp3.mul(p, d);
    d = Fp3.sqr(d);
    power >>= _1n2;
  }
  return p;
}
function FpInvertBatch(Fp3, nums, passZero = false) {
  const inverted = new Array(nums.length).fill(passZero ? Fp3.ZERO : void 0);
  const multipliedAcc = nums.reduce((acc, num2, i) => {
    if (Fp3.is0(num2))
      return acc;
    inverted[i] = acc;
    return Fp3.mul(acc, num2);
  }, Fp3.ONE);
  const invertedAcc = Fp3.inv(multipliedAcc);
  nums.reduceRight((acc, num2, i) => {
    if (Fp3.is0(num2))
      return acc;
    inverted[i] = Fp3.mul(acc, inverted[i]);
    return Fp3.mul(acc, num2);
  }, invertedAcc);
  return inverted;
}
function FpLegendre(Fp3, n) {
  const p1mod2 = (Fp3.ORDER - _1n2) / _2n;
  const powered = Fp3.pow(n, p1mod2);
  const yes = Fp3.eql(powered, Fp3.ONE);
  const zero2 = Fp3.eql(powered, Fp3.ZERO);
  const no = Fp3.eql(powered, Fp3.neg(Fp3.ONE));
  if (!yes && !zero2 && !no)
    throw new Error("invalid Legendre symbol result");
  return yes ? 1 : zero2 ? 0 : -1;
}
function nLength(n, nBitLength) {
  if (nBitLength !== void 0)
    anumber(nBitLength);
  const _nBitLength = nBitLength !== void 0 ? nBitLength : n.toString(2).length;
  const nByteLength = Math.ceil(_nBitLength / 8);
  return { nBitLength: _nBitLength, nByteLength };
}
function Field(ORDER, bitLenOrOpts, isLE6 = false, opts = {}) {
  if (ORDER <= _0n2)
    throw new Error("invalid field: expected ORDER > 0, got " + ORDER);
  let _nbitLength = void 0;
  let _sqrt = void 0;
  let modFromBytes = false;
  let allowedLengths = void 0;
  if (typeof bitLenOrOpts === "object" && bitLenOrOpts != null) {
    if (opts.sqrt || isLE6)
      throw new Error("cannot specify opts in two arguments");
    const _opts = bitLenOrOpts;
    if (_opts.BITS)
      _nbitLength = _opts.BITS;
    if (_opts.sqrt)
      _sqrt = _opts.sqrt;
    if (typeof _opts.isLE === "boolean")
      isLE6 = _opts.isLE;
    if (typeof _opts.modFromBytes === "boolean")
      modFromBytes = _opts.modFromBytes;
    allowedLengths = _opts.allowedLengths;
  } else {
    if (typeof bitLenOrOpts === "number")
      _nbitLength = bitLenOrOpts;
    if (opts.sqrt)
      _sqrt = opts.sqrt;
  }
  const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, _nbitLength);
  if (BYTES > 2048)
    throw new Error("invalid field: expected ORDER of <= 2048 bytes");
  let sqrtP;
  const f3 = Object.freeze({
    ORDER,
    isLE: isLE6,
    BITS,
    BYTES,
    MASK: bitMask(BITS),
    ZERO: _0n2,
    ONE: _1n2,
    allowedLengths,
    create: (num2) => mod(num2, ORDER),
    isValid: (num2) => {
      if (typeof num2 !== "bigint")
        throw new Error("invalid field element: expected bigint, got " + typeof num2);
      return _0n2 <= num2 && num2 < ORDER;
    },
    is0: (num2) => num2 === _0n2,
    // is valid and invertible
    isValidNot0: (num2) => !f3.is0(num2) && f3.isValid(num2),
    isOdd: (num2) => (num2 & _1n2) === _1n2,
    neg: (num2) => mod(-num2, ORDER),
    eql: (lhs, rhs) => lhs === rhs,
    sqr: (num2) => mod(num2 * num2, ORDER),
    add: (lhs, rhs) => mod(lhs + rhs, ORDER),
    sub: (lhs, rhs) => mod(lhs - rhs, ORDER),
    mul: (lhs, rhs) => mod(lhs * rhs, ORDER),
    pow: (num2, power) => FpPow(f3, num2, power),
    div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),
    // Same as above, but doesn't normalize
    sqrN: (num2) => num2 * num2,
    addN: (lhs, rhs) => lhs + rhs,
    subN: (lhs, rhs) => lhs - rhs,
    mulN: (lhs, rhs) => lhs * rhs,
    inv: (num2) => invert(num2, ORDER),
    sqrt: _sqrt || ((n) => {
      if (!sqrtP)
        sqrtP = FpSqrt(ORDER);
      return sqrtP(f3, n);
    }),
    toBytes: (num2) => isLE6 ? numberToBytesLE(num2, BYTES) : numberToBytesBE(num2, BYTES),
    fromBytes: (bytes3, skipValidation = true) => {
      if (allowedLengths) {
        if (!allowedLengths.includes(bytes3.length) || bytes3.length > BYTES) {
          throw new Error("Field.fromBytes: expected " + allowedLengths + " bytes, got " + bytes3.length);
        }
        const padded = new Uint8Array(BYTES);
        padded.set(bytes3, isLE6 ? 0 : padded.length - bytes3.length);
        bytes3 = padded;
      }
      if (bytes3.length !== BYTES)
        throw new Error("Field.fromBytes: expected " + BYTES + " bytes, got " + bytes3.length);
      let scalar = isLE6 ? bytesToNumberLE(bytes3) : bytesToNumberBE(bytes3);
      if (modFromBytes)
        scalar = mod(scalar, ORDER);
      if (!skipValidation) {
        if (!f3.isValid(scalar))
          throw new Error("invalid field element: outside of range 0..ORDER");
      }
      return scalar;
    },
    // TODO: we don't need it here, move out to separate fn
    invertBatch: (lst) => FpInvertBatch(f3, lst),
    // We can't move this out because Fp6, Fp12 implement it
    // and it's unclear what to return in there.
    cmov: (a, b, c) => c ? b : a
  });
  return Object.freeze(f3);
}
function FpSqrtEven(Fp3, elm) {
  if (!Fp3.isOdd)
    throw new Error("Field doesn't have isOdd");
  const root2 = Fp3.sqrt(elm);
  return Fp3.isOdd(root2) ? Fp3.neg(root2) : root2;
}
function getFieldBytesLength(fieldOrder) {
  if (typeof fieldOrder !== "bigint")
    throw new Error("field order must be bigint");
  const bitLength = fieldOrder.toString(2).length;
  return Math.ceil(bitLength / 8);
}
function getMinHashLength(fieldOrder) {
  const length2 = getFieldBytesLength(fieldOrder);
  return length2 + Math.ceil(length2 / 2);
}
function mapHashToField(key, fieldOrder, isLE6 = false) {
  const len = key.length;
  const fieldLen = getFieldBytesLength(fieldOrder);
  const minLen = getMinHashLength(fieldOrder);
  if (len < 16 || len < minLen || len > 1024)
    throw new Error("expected " + minLen + "-1024 bytes of input, got " + len);
  const num2 = isLE6 ? bytesToNumberLE(key) : bytesToNumberBE(key);
  const reduced = mod(num2, fieldOrder - _1n2) + _1n2;
  return isLE6 ? numberToBytesLE(reduced, fieldLen) : numberToBytesBE(reduced, fieldLen);
}
var _0n2, _1n2, _2n, _3n, _4n, _5n, _7n, _8n, _9n, _16n, isNegativeLE, FIELD_FIELDS;
var init_modular = __esm({
  "node_modules/@noble/curves/esm/abstract/modular.js"() {
    init_utils2();
    _0n2 = BigInt(0);
    _1n2 = BigInt(1);
    _2n = BigInt(2);
    _3n = BigInt(3);
    _4n = BigInt(4);
    _5n = BigInt(5);
    _7n = BigInt(7);
    _8n = BigInt(8);
    _9n = BigInt(9);
    _16n = BigInt(16);
    isNegativeLE = (num2, modulo) => (mod(num2, modulo) & _1n2) === _1n2;
    FIELD_FIELDS = [
      "create",
      "isValid",
      "is0",
      "neg",
      "inv",
      "sqrt",
      "sqr",
      "eql",
      "add",
      "sub",
      "mul",
      "pow",
      "div",
      "addN",
      "subN",
      "mulN",
      "sqrN"
    ];
  }
});

// node_modules/@noble/curves/esm/abstract/curve.js
function negateCt(condition, item) {
  const neg = item.negate();
  return condition ? neg : item;
}
function normalizeZ(c, points) {
  const invertedZs = FpInvertBatch(c.Fp, points.map((p) => p.Z));
  return points.map((p, i) => c.fromAffine(p.toAffine(invertedZs[i])));
}
function validateW(W, bits) {
  if (!Number.isSafeInteger(W) || W <= 0 || W > bits)
    throw new Error("invalid window size, expected [1.." + bits + "], got W=" + W);
}
function calcWOpts(W, scalarBits) {
  validateW(W, scalarBits);
  const windows = Math.ceil(scalarBits / W) + 1;
  const windowSize = 2 ** (W - 1);
  const maxNumber = 2 ** W;
  const mask3 = bitMask(W);
  const shiftBy = BigInt(W);
  return { windows, windowSize, mask: mask3, maxNumber, shiftBy };
}
function calcOffsets(n, window2, wOpts) {
  const { windowSize, mask: mask3, maxNumber, shiftBy } = wOpts;
  let wbits = Number(n & mask3);
  let nextN = n >> shiftBy;
  if (wbits > windowSize) {
    wbits -= maxNumber;
    nextN += _1n3;
  }
  const offsetStart = window2 * windowSize;
  const offset3 = offsetStart + Math.abs(wbits) - 1;
  const isZero = wbits === 0;
  const isNeg = wbits < 0;
  const isNegF = window2 % 2 !== 0;
  const offsetF = offsetStart;
  return { nextN, offset: offset3, isZero, isNeg, isNegF, offsetF };
}
function validateMSMPoints(points, c) {
  if (!Array.isArray(points))
    throw new Error("array expected");
  points.forEach((p, i) => {
    if (!(p instanceof c))
      throw new Error("invalid point at index " + i);
  });
}
function validateMSMScalars(scalars, field) {
  if (!Array.isArray(scalars))
    throw new Error("array of scalars expected");
  scalars.forEach((s, i) => {
    if (!field.isValid(s))
      throw new Error("invalid scalar at index " + i);
  });
}
function getW(P) {
  return pointWindowSizes.get(P) || 1;
}
function assert0(n) {
  if (n !== _0n3)
    throw new Error("invalid wNAF");
}
function mulEndoUnsafe(Point2, point, k1, k2) {
  let acc = point;
  let p1 = Point2.ZERO;
  let p2 = Point2.ZERO;
  while (k1 > _0n3 || k2 > _0n3) {
    if (k1 & _1n3)
      p1 = p1.add(acc);
    if (k2 & _1n3)
      p2 = p2.add(acc);
    acc = acc.double();
    k1 >>= _1n3;
    k2 >>= _1n3;
  }
  return { p1, p2 };
}
function pippenger(c, fieldN, points, scalars) {
  validateMSMPoints(points, c);
  validateMSMScalars(scalars, fieldN);
  const plength = points.length;
  const slength = scalars.length;
  if (plength !== slength)
    throw new Error("arrays of points and scalars must have equal length");
  const zero2 = c.ZERO;
  const wbits = bitLen(BigInt(plength));
  let windowSize = 1;
  if (wbits > 12)
    windowSize = wbits - 3;
  else if (wbits > 4)
    windowSize = wbits - 2;
  else if (wbits > 0)
    windowSize = 2;
  const MASK = bitMask(windowSize);
  const buckets = new Array(Number(MASK) + 1).fill(zero2);
  const lastBits = Math.floor((fieldN.BITS - 1) / windowSize) * windowSize;
  let sum = zero2;
  for (let i = lastBits; i >= 0; i -= windowSize) {
    buckets.fill(zero2);
    for (let j = 0; j < slength; j++) {
      const scalar = scalars[j];
      const wbits2 = Number(scalar >> BigInt(i) & MASK);
      buckets[wbits2] = buckets[wbits2].add(points[j]);
    }
    let resI = zero2;
    for (let j = buckets.length - 1, sumI = zero2; j > 0; j--) {
      sumI = sumI.add(buckets[j]);
      resI = resI.add(sumI);
    }
    sum = sum.add(resI);
    if (i !== 0)
      for (let j = 0; j < windowSize; j++)
        sum = sum.double();
  }
  return sum;
}
function createField(order, field, isLE6) {
  if (field) {
    if (field.ORDER !== order)
      throw new Error("Field.ORDER must match order: Fp == p, Fn == n");
    validateField(field);
    return field;
  } else {
    return Field(order, { isLE: isLE6 });
  }
}
function _createCurveFields(type3, CURVE2, curveOpts = {}, FpFnLE) {
  if (FpFnLE === void 0)
    FpFnLE = type3 === "edwards";
  if (!CURVE2 || typeof CURVE2 !== "object")
    throw new Error(`expected valid ${type3} CURVE object`);
  for (const p of ["p", "n", "h"]) {
    const val = CURVE2[p];
    if (!(typeof val === "bigint" && val > _0n3))
      throw new Error(`CURVE.${p} must be positive bigint`);
  }
  const Fp3 = createField(CURVE2.p, curveOpts.Fp, FpFnLE);
  const Fn2 = createField(CURVE2.n, curveOpts.Fn, FpFnLE);
  const _b = type3 === "weierstrass" ? "b" : "d";
  const params = ["Gx", "Gy", "a", _b];
  for (const p of params) {
    if (!Fp3.isValid(CURVE2[p]))
      throw new Error(`CURVE.${p} must be valid field element of CURVE.Fp`);
  }
  CURVE2 = Object.freeze(Object.assign({}, CURVE2));
  return { CURVE: CURVE2, Fp: Fp3, Fn: Fn2 };
}
var _0n3, _1n3, pointPrecomputes, pointWindowSizes, wNAF;
var init_curve = __esm({
  "node_modules/@noble/curves/esm/abstract/curve.js"() {
    init_utils2();
    init_modular();
    _0n3 = BigInt(0);
    _1n3 = BigInt(1);
    pointPrecomputes = /* @__PURE__ */ new WeakMap();
    pointWindowSizes = /* @__PURE__ */ new WeakMap();
    wNAF = class {
      // Parametrized with a given Point class (not individual point)
      constructor(Point2, bits) {
        this.BASE = Point2.BASE;
        this.ZERO = Point2.ZERO;
        this.Fn = Point2.Fn;
        this.bits = bits;
      }
      // non-const time multiplication ladder
      _unsafeLadder(elm, n, p = this.ZERO) {
        let d = elm;
        while (n > _0n3) {
          if (n & _1n3)
            p = p.add(d);
          d = d.double();
          n >>= _1n3;
        }
        return p;
      }
      /**
       * Creates a wNAF precomputation window. Used for caching.
       * Default window size is set by `utils.precompute()` and is equal to 8.
       * Number of precomputed points depends on the curve size:
       * 2^(𝑊−1) * (Math.ceil(𝑛 / 𝑊) + 1), where:
       * - 𝑊 is the window size
       * - 𝑛 is the bitlength of the curve order.
       * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
       * @param point Point instance
       * @param W window size
       * @returns precomputed point tables flattened to a single array
       */
      precomputeWindow(point, W) {
        const { windows, windowSize } = calcWOpts(W, this.bits);
        const points = [];
        let p = point;
        let base3 = p;
        for (let window2 = 0; window2 < windows; window2++) {
          base3 = p;
          points.push(base3);
          for (let i = 1; i < windowSize; i++) {
            base3 = base3.add(p);
            points.push(base3);
          }
          p = base3.double();
        }
        return points;
      }
      /**
       * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
       * More compact implementation:
       * https://github.com/paulmillr/noble-secp256k1/blob/47cb1669b6e506ad66b35fe7d76132ae97465da2/index.ts#L502-L541
       * @returns real and fake (for const-time) points
       */
      wNAF(W, precomputes, n) {
        if (!this.Fn.isValid(n))
          throw new Error("invalid scalar");
        let p = this.ZERO;
        let f3 = this.BASE;
        const wo = calcWOpts(W, this.bits);
        for (let window2 = 0; window2 < wo.windows; window2++) {
          const { nextN, offset: offset3, isZero, isNeg, isNegF, offsetF } = calcOffsets(n, window2, wo);
          n = nextN;
          if (isZero) {
            f3 = f3.add(negateCt(isNegF, precomputes[offsetF]));
          } else {
            p = p.add(negateCt(isNeg, precomputes[offset3]));
          }
        }
        assert0(n);
        return { p, f: f3 };
      }
      /**
       * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.
       * @param acc accumulator point to add result of multiplication
       * @returns point
       */
      wNAFUnsafe(W, precomputes, n, acc = this.ZERO) {
        const wo = calcWOpts(W, this.bits);
        for (let window2 = 0; window2 < wo.windows; window2++) {
          if (n === _0n3)
            break;
          const { nextN, offset: offset3, isZero, isNeg } = calcOffsets(n, window2, wo);
          n = nextN;
          if (isZero) {
            continue;
          } else {
            const item = precomputes[offset3];
            acc = acc.add(isNeg ? item.negate() : item);
          }
        }
        assert0(n);
        return acc;
      }
      getPrecomputes(W, point, transform) {
        let comp = pointPrecomputes.get(point);
        if (!comp) {
          comp = this.precomputeWindow(point, W);
          if (W !== 1) {
            if (typeof transform === "function")
              comp = transform(comp);
            pointPrecomputes.set(point, comp);
          }
        }
        return comp;
      }
      cached(point, scalar, transform) {
        const W = getW(point);
        return this.wNAF(W, this.getPrecomputes(W, point, transform), scalar);
      }
      unsafe(point, scalar, transform, prev) {
        const W = getW(point);
        if (W === 1)
          return this._unsafeLadder(point, scalar, prev);
        return this.wNAFUnsafe(W, this.getPrecomputes(W, point, transform), scalar, prev);
      }
      // We calculate precomputes for elliptic curve point multiplication
      // using windowed method. This specifies window size and
      // stores precomputed values. Usually only base point would be precomputed.
      createCache(P, W) {
        validateW(W, this.bits);
        pointWindowSizes.set(P, W);
        pointPrecomputes.delete(P);
      }
      hasCache(elm) {
        return getW(elm) !== 1;
      }
    };
  }
});

// node_modules/@noble/curves/esm/abstract/edwards.js
function isEdValidXY(Fp3, CURVE2, x, y) {
  const x2 = Fp3.sqr(x);
  const y2 = Fp3.sqr(y);
  const left = Fp3.add(Fp3.mul(CURVE2.a, x2), y2);
  const right = Fp3.add(Fp3.ONE, Fp3.mul(CURVE2.d, Fp3.mul(x2, y2)));
  return Fp3.eql(left, right);
}
function edwards(params, extraOpts = {}) {
  const validated = _createCurveFields("edwards", params, extraOpts, extraOpts.FpFnLE);
  const { Fp: Fp3, Fn: Fn2 } = validated;
  let CURVE2 = validated.CURVE;
  const { h: cofactor } = CURVE2;
  _validateObject(extraOpts, {}, { uvRatio: "function" });
  const MASK = _2n2 << BigInt(Fn2.BYTES * 8) - _1n4;
  const modP = (n) => Fp3.create(n);
  const uvRatio2 = extraOpts.uvRatio || ((u, v) => {
    try {
      return { isValid: true, value: Fp3.sqrt(Fp3.div(u, v)) };
    } catch (e) {
      return { isValid: false, value: _0n4 };
    }
  });
  if (!isEdValidXY(Fp3, CURVE2, CURVE2.Gx, CURVE2.Gy))
    throw new Error("bad curve params: generator point");
  function acoord(title, n, banZero = false) {
    const min = banZero ? _1n4 : _0n4;
    aInRange("coordinate " + title, n, min, MASK);
    return n;
  }
  function aextpoint(other) {
    if (!(other instanceof Point2))
      throw new Error("ExtendedPoint expected");
  }
  const toAffineMemo = memoized((p, iz) => {
    const { X, Y, Z } = p;
    const is0 = p.is0();
    if (iz == null)
      iz = is0 ? _8n2 : Fp3.inv(Z);
    const x = modP(X * iz);
    const y = modP(Y * iz);
    const zz = Fp3.mul(Z, iz);
    if (is0)
      return { x: _0n4, y: _1n4 };
    if (zz !== _1n4)
      throw new Error("invZ was invalid");
    return { x, y };
  });
  const assertValidMemo = memoized((p) => {
    const { a, d } = CURVE2;
    if (p.is0())
      throw new Error("bad point: ZERO");
    const { X, Y, Z, T } = p;
    const X2 = modP(X * X);
    const Y2 = modP(Y * Y);
    const Z2 = modP(Z * Z);
    const Z4 = modP(Z2 * Z2);
    const aX2 = modP(X2 * a);
    const left = modP(Z2 * modP(aX2 + Y2));
    const right = modP(Z4 + modP(d * modP(X2 * Y2)));
    if (left !== right)
      throw new Error("bad point: equation left != right (1)");
    const XY = modP(X * Y);
    const ZT = modP(Z * T);
    if (XY !== ZT)
      throw new Error("bad point: equation left != right (2)");
    return true;
  });
  class Point2 {
    constructor(X, Y, Z, T) {
      this.X = acoord("x", X);
      this.Y = acoord("y", Y);
      this.Z = acoord("z", Z, true);
      this.T = acoord("t", T);
      Object.freeze(this);
    }
    static CURVE() {
      return CURVE2;
    }
    static fromAffine(p) {
      if (p instanceof Point2)
        throw new Error("extended point not allowed");
      const { x, y } = p || {};
      acoord("x", x);
      acoord("y", y);
      return new Point2(x, y, _1n4, modP(x * y));
    }
    // Uses algo from RFC8032 5.1.3.
    static fromBytes(bytes3, zip215 = false) {
      const len = Fp3.BYTES;
      const { a, d } = CURVE2;
      bytes3 = copyBytes(_abytes2(bytes3, len, "point"));
      _abool2(zip215, "zip215");
      const normed = copyBytes(bytes3);
      const lastByte = bytes3[len - 1];
      normed[len - 1] = lastByte & ~128;
      const y = bytesToNumberLE(normed);
      const max = zip215 ? MASK : Fp3.ORDER;
      aInRange("point.y", y, _0n4, max);
      const y2 = modP(y * y);
      const u = modP(y2 - _1n4);
      const v = modP(d * y2 - a);
      let { isValid, value: x } = uvRatio2(u, v);
      if (!isValid)
        throw new Error("bad point: invalid y coordinate");
      const isXOdd = (x & _1n4) === _1n4;
      const isLastByteOdd = (lastByte & 128) !== 0;
      if (!zip215 && x === _0n4 && isLastByteOdd)
        throw new Error("bad point: x=0 and x_0=1");
      if (isLastByteOdd !== isXOdd)
        x = modP(-x);
      return Point2.fromAffine({ x, y });
    }
    static fromHex(bytes3, zip215 = false) {
      return Point2.fromBytes(ensureBytes("point", bytes3), zip215);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    precompute(windowSize = 8, isLazy = true) {
      wnaf.createCache(this, windowSize);
      if (!isLazy)
        this.multiply(_2n2);
      return this;
    }
    // Useful in fromAffine() - not for fromBytes(), which always created valid points.
    assertValidity() {
      assertValidMemo(this);
    }
    // Compare one point to another.
    equals(other) {
      aextpoint(other);
      const { X: X1, Y: Y1, Z: Z1 } = this;
      const { X: X2, Y: Y2, Z: Z2 } = other;
      const X1Z2 = modP(X1 * Z2);
      const X2Z1 = modP(X2 * Z1);
      const Y1Z2 = modP(Y1 * Z2);
      const Y2Z1 = modP(Y2 * Z1);
      return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;
    }
    is0() {
      return this.equals(Point2.ZERO);
    }
    negate() {
      return new Point2(modP(-this.X), this.Y, this.Z, modP(-this.T));
    }
    // Fast algo for doubling Extended Point.
    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd
    // Cost: 4M + 4S + 1*a + 6add + 1*2.
    double() {
      const { a } = CURVE2;
      const { X: X1, Y: Y1, Z: Z1 } = this;
      const A = modP(X1 * X1);
      const B = modP(Y1 * Y1);
      const C = modP(_2n2 * modP(Z1 * Z1));
      const D = modP(a * A);
      const x1y1 = X1 + Y1;
      const E = modP(modP(x1y1 * x1y1) - A - B);
      const G = D + B;
      const F = G - C;
      const H = D - B;
      const X3 = modP(E * F);
      const Y3 = modP(G * H);
      const T3 = modP(E * H);
      const Z3 = modP(F * G);
      return new Point2(X3, Y3, Z3, T3);
    }
    // Fast algo for adding 2 Extended Points.
    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-add-2008-hwcd
    // Cost: 9M + 1*a + 1*d + 7add.
    add(other) {
      aextpoint(other);
      const { a, d } = CURVE2;
      const { X: X1, Y: Y1, Z: Z1, T: T1 } = this;
      const { X: X2, Y: Y2, Z: Z2, T: T2 } = other;
      const A = modP(X1 * X2);
      const B = modP(Y1 * Y2);
      const C = modP(T1 * d * T2);
      const D = modP(Z1 * Z2);
      const E = modP((X1 + Y1) * (X2 + Y2) - A - B);
      const F = D - C;
      const G = D + C;
      const H = modP(B - a * A);
      const X3 = modP(E * F);
      const Y3 = modP(G * H);
      const T3 = modP(E * H);
      const Z3 = modP(F * G);
      return new Point2(X3, Y3, Z3, T3);
    }
    subtract(other) {
      return this.add(other.negate());
    }
    // Constant-time multiplication.
    multiply(scalar) {
      if (!Fn2.isValidNot0(scalar))
        throw new Error("invalid scalar: expected 1 <= sc < curve.n");
      const { p, f: f3 } = wnaf.cached(this, scalar, (p2) => normalizeZ(Point2, p2));
      return normalizeZ(Point2, [p, f3])[0];
    }
    // Non-constant-time multiplication. Uses double-and-add algorithm.
    // It's faster, but should only be used when you don't care about
    // an exposed private key e.g. sig verification.
    // Does NOT allow scalars higher than CURVE.n.
    // Accepts optional accumulator to merge with multiply (important for sparse scalars)
    multiplyUnsafe(scalar, acc = Point2.ZERO) {
      if (!Fn2.isValid(scalar))
        throw new Error("invalid scalar: expected 0 <= sc < curve.n");
      if (scalar === _0n4)
        return Point2.ZERO;
      if (this.is0() || scalar === _1n4)
        return this;
      return wnaf.unsafe(this, scalar, (p) => normalizeZ(Point2, p), acc);
    }
    // Checks if point is of small order.
    // If you add something to small order point, you will have "dirty"
    // point with torsion component.
    // Multiplies point by cofactor and checks if the result is 0.
    isSmallOrder() {
      return this.multiplyUnsafe(cofactor).is0();
    }
    // Multiplies point by curve order and checks if the result is 0.
    // Returns `false` is the point is dirty.
    isTorsionFree() {
      return wnaf.unsafe(this, CURVE2.n).is0();
    }
    // Converts Extended point to default (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    toAffine(invertedZ) {
      return toAffineMemo(this, invertedZ);
    }
    clearCofactor() {
      if (cofactor === _1n4)
        return this;
      return this.multiplyUnsafe(cofactor);
    }
    toBytes() {
      const { x, y } = this.toAffine();
      const bytes3 = Fp3.toBytes(y);
      bytes3[bytes3.length - 1] |= x & _1n4 ? 128 : 0;
      return bytes3;
    }
    toHex() {
      return bytesToHex2(this.toBytes());
    }
    toString() {
      return `<Point ${this.is0() ? "ZERO" : this.toHex()}>`;
    }
    // TODO: remove
    get ex() {
      return this.X;
    }
    get ey() {
      return this.Y;
    }
    get ez() {
      return this.Z;
    }
    get et() {
      return this.T;
    }
    static normalizeZ(points) {
      return normalizeZ(Point2, points);
    }
    static msm(points, scalars) {
      return pippenger(Point2, Fn2, points, scalars);
    }
    _setWindowSize(windowSize) {
      this.precompute(windowSize);
    }
    toRawBytes() {
      return this.toBytes();
    }
  }
  Point2.BASE = new Point2(CURVE2.Gx, CURVE2.Gy, _1n4, modP(CURVE2.Gx * CURVE2.Gy));
  Point2.ZERO = new Point2(_0n4, _1n4, _1n4, _0n4);
  Point2.Fp = Fp3;
  Point2.Fn = Fn2;
  const wnaf = new wNAF(Point2, Fn2.BITS);
  Point2.BASE.precompute(8);
  return Point2;
}
function eddsa(Point2, cHash, eddsaOpts = {}) {
  if (typeof cHash !== "function")
    throw new Error('"hash" function param is required');
  _validateObject(eddsaOpts, {}, {
    adjustScalarBytes: "function",
    randomBytes: "function",
    domain: "function",
    prehash: "function",
    mapToCurve: "function"
  });
  const { prehash } = eddsaOpts;
  const { BASE: BASE2, Fp: Fp3, Fn: Fn2 } = Point2;
  const randomBytes3 = eddsaOpts.randomBytes || randomBytes;
  const adjustScalarBytes2 = eddsaOpts.adjustScalarBytes || ((bytes3) => bytes3);
  const domain = eddsaOpts.domain || ((data, ctx, phflag) => {
    _abool2(phflag, "phflag");
    if (ctx.length || phflag)
      throw new Error("Contexts/pre-hash are not supported");
    return data;
  });
  function modN_LE(hash3) {
    return Fn2.create(bytesToNumberLE(hash3));
  }
  function getPrivateScalar(key) {
    const len = lengths.secretKey;
    key = ensureBytes("private key", key, len);
    const hashed = ensureBytes("hashed private key", cHash(key), 2 * len);
    const head = adjustScalarBytes2(hashed.slice(0, len));
    const prefix = hashed.slice(len, 2 * len);
    const scalar = modN_LE(head);
    return { head, prefix, scalar };
  }
  function getExtendedPublicKey(secretKey) {
    const { head, prefix, scalar } = getPrivateScalar(secretKey);
    const point = BASE2.multiply(scalar);
    const pointBytes = point.toBytes();
    return { head, prefix, scalar, point, pointBytes };
  }
  function getPublicKey2(secretKey) {
    return getExtendedPublicKey(secretKey).pointBytes;
  }
  function hashDomainToScalar(context = Uint8Array.of(), ...msgs) {
    const msg = concatBytes2(...msgs);
    return modN_LE(cHash(domain(msg, ensureBytes("context", context), !!prehash)));
  }
  function sign4(msg, secretKey, options = {}) {
    msg = ensureBytes("message", msg);
    if (prehash)
      msg = prehash(msg);
    const { prefix, scalar, pointBytes } = getExtendedPublicKey(secretKey);
    const r = hashDomainToScalar(options.context, prefix, msg);
    const R = BASE2.multiply(r).toBytes();
    const k = hashDomainToScalar(options.context, R, pointBytes, msg);
    const s = Fn2.create(r + k * scalar);
    if (!Fn2.isValid(s))
      throw new Error("sign failed: invalid s");
    const rs = concatBytes2(R, Fn2.toBytes(s));
    return _abytes2(rs, lengths.signature, "result");
  }
  const verifyOpts = { zip215: true };
  function verify2(sig, msg, publicKey5, options = verifyOpts) {
    const { context, zip215 } = options;
    const len = lengths.signature;
    sig = ensureBytes("signature", sig, len);
    msg = ensureBytes("message", msg);
    publicKey5 = ensureBytes("publicKey", publicKey5, lengths.publicKey);
    if (zip215 !== void 0)
      _abool2(zip215, "zip215");
    if (prehash)
      msg = prehash(msg);
    const mid = len / 2;
    const r = sig.subarray(0, mid);
    const s = bytesToNumberLE(sig.subarray(mid, len));
    let A, R, SB;
    try {
      A = Point2.fromBytes(publicKey5, zip215);
      R = Point2.fromBytes(r, zip215);
      SB = BASE2.multiplyUnsafe(s);
    } catch (error) {
      return false;
    }
    if (!zip215 && A.isSmallOrder())
      return false;
    const k = hashDomainToScalar(context, R.toBytes(), A.toBytes(), msg);
    const RkA = R.add(A.multiplyUnsafe(k));
    return RkA.subtract(SB).clearCofactor().is0();
  }
  const _size = Fp3.BYTES;
  const lengths = {
    secretKey: _size,
    publicKey: _size,
    signature: 2 * _size,
    seed: _size
  };
  function randomSecretKey(seed2 = randomBytes3(lengths.seed)) {
    return _abytes2(seed2, lengths.seed, "seed");
  }
  function keygen(seed2) {
    const secretKey = utils3.randomSecretKey(seed2);
    return { secretKey, publicKey: getPublicKey2(secretKey) };
  }
  function isValidSecretKey(key) {
    return isBytes2(key) && key.length === Fn2.BYTES;
  }
  function isValidPublicKey(key, zip215) {
    try {
      return !!Point2.fromBytes(key, zip215);
    } catch (error) {
      return false;
    }
  }
  const utils3 = {
    getExtendedPublicKey,
    randomSecretKey,
    isValidSecretKey,
    isValidPublicKey,
    /**
     * Converts ed public key to x public key. Uses formula:
     * - ed25519:
     *   - `(u, v) = ((1+y)/(1-y), sqrt(-486664)*u/x)`
     *   - `(x, y) = (sqrt(-486664)*u/v, (u-1)/(u+1))`
     * - ed448:
     *   - `(u, v) = ((y-1)/(y+1), sqrt(156324)*u/x)`
     *   - `(x, y) = (sqrt(156324)*u/v, (1+u)/(1-u))`
     */
    toMontgomery(publicKey5) {
      const { y } = Point2.fromBytes(publicKey5);
      const size4 = lengths.publicKey;
      const is25519 = size4 === 32;
      if (!is25519 && size4 !== 57)
        throw new Error("only defined for 25519 and 448");
      const u = is25519 ? Fp3.div(_1n4 + y, _1n4 - y) : Fp3.div(y - _1n4, y + _1n4);
      return Fp3.toBytes(u);
    },
    toMontgomerySecret(secretKey) {
      const size4 = lengths.secretKey;
      _abytes2(secretKey, size4);
      const hashed = cHash(secretKey.subarray(0, size4));
      return adjustScalarBytes2(hashed).subarray(0, size4);
    },
    /** @deprecated */
    randomPrivateKey: randomSecretKey,
    /** @deprecated */
    precompute(windowSize = 8, point = Point2.BASE) {
      return point.precompute(windowSize, false);
    }
  };
  return Object.freeze({
    keygen,
    getPublicKey: getPublicKey2,
    sign: sign4,
    verify: verify2,
    utils: utils3,
    Point: Point2,
    lengths
  });
}
function _eddsa_legacy_opts_to_new(c) {
  const CURVE2 = {
    a: c.a,
    d: c.d,
    p: c.Fp.ORDER,
    n: c.n,
    h: c.h,
    Gx: c.Gx,
    Gy: c.Gy
  };
  const Fp3 = c.Fp;
  const Fn2 = Field(CURVE2.n, c.nBitLength, true);
  const curveOpts = { Fp: Fp3, Fn: Fn2, uvRatio: c.uvRatio };
  const eddsaOpts = {
    randomBytes: c.randomBytes,
    adjustScalarBytes: c.adjustScalarBytes,
    domain: c.domain,
    prehash: c.prehash,
    mapToCurve: c.mapToCurve
  };
  return { CURVE: CURVE2, curveOpts, hash: c.hash, eddsaOpts };
}
function _eddsa_new_output_to_legacy(c, eddsa2) {
  const Point2 = eddsa2.Point;
  const legacy = Object.assign({}, eddsa2, {
    ExtendedPoint: Point2,
    CURVE: c,
    nBitLength: Point2.Fn.BITS,
    nByteLength: Point2.Fn.BYTES
  });
  return legacy;
}
function twistedEdwards(c) {
  const { CURVE: CURVE2, curveOpts, hash: hash3, eddsaOpts } = _eddsa_legacy_opts_to_new(c);
  const Point2 = edwards(CURVE2, curveOpts);
  const EDDSA = eddsa(Point2, hash3, eddsaOpts);
  return _eddsa_new_output_to_legacy(c, EDDSA);
}
var _0n4, _1n4, _2n2, _8n2, PrimeEdwardsPoint;
var init_edwards = __esm({
  "node_modules/@noble/curves/esm/abstract/edwards.js"() {
    init_utils2();
    init_curve();
    init_modular();
    _0n4 = BigInt(0);
    _1n4 = BigInt(1);
    _2n2 = BigInt(2);
    _8n2 = BigInt(8);
    PrimeEdwardsPoint = class {
      constructor(ep) {
        this.ep = ep;
      }
      // Static methods that must be implemented by subclasses
      static fromBytes(_bytes) {
        notImplemented();
      }
      static fromHex(_hex) {
        notImplemented();
      }
      get x() {
        return this.toAffine().x;
      }
      get y() {
        return this.toAffine().y;
      }
      // Common implementations
      clearCofactor() {
        return this;
      }
      assertValidity() {
        this.ep.assertValidity();
      }
      toAffine(invertedZ) {
        return this.ep.toAffine(invertedZ);
      }
      toHex() {
        return bytesToHex2(this.toBytes());
      }
      toString() {
        return this.toHex();
      }
      isTorsionFree() {
        return true;
      }
      isSmallOrder() {
        return false;
      }
      add(other) {
        this.assertSame(other);
        return this.init(this.ep.add(other.ep));
      }
      subtract(other) {
        this.assertSame(other);
        return this.init(this.ep.subtract(other.ep));
      }
      multiply(scalar) {
        return this.init(this.ep.multiply(scalar));
      }
      multiplyUnsafe(scalar) {
        return this.init(this.ep.multiplyUnsafe(scalar));
      }
      double() {
        return this.init(this.ep.double());
      }
      negate() {
        return this.init(this.ep.negate());
      }
      precompute(windowSize, isLazy) {
        return this.init(this.ep.precompute(windowSize, isLazy));
      }
      /** @deprecated use `toBytes` */
      toRawBytes() {
        return this.toBytes();
      }
    };
  }
});

// node_modules/@noble/curves/esm/abstract/hash-to-curve.js
function i2osp(value, length2) {
  anum(value);
  anum(length2);
  if (value < 0 || value >= 1 << 8 * length2)
    throw new Error("invalid I2OSP input: " + value);
  const res = Array.from({ length: length2 }).fill(0);
  for (let i = length2 - 1; i >= 0; i--) {
    res[i] = value & 255;
    value >>>= 8;
  }
  return new Uint8Array(res);
}
function strxor(a, b) {
  const arr = new Uint8Array(a.length);
  for (let i = 0; i < a.length; i++) {
    arr[i] = a[i] ^ b[i];
  }
  return arr;
}
function anum(item) {
  if (!Number.isSafeInteger(item))
    throw new Error("number expected");
}
function normDST(DST) {
  if (!isBytes2(DST) && typeof DST !== "string")
    throw new Error("DST must be Uint8Array or string");
  return typeof DST === "string" ? utf8ToBytes(DST) : DST;
}
function expand_message_xmd(msg, DST, lenInBytes, H) {
  abytes(msg);
  anum(lenInBytes);
  DST = normDST(DST);
  if (DST.length > 255)
    DST = H(concatBytes2(utf8ToBytes("H2C-OVERSIZE-DST-"), DST));
  const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;
  const ell = Math.ceil(lenInBytes / b_in_bytes);
  if (lenInBytes > 65535 || ell > 255)
    throw new Error("expand_message_xmd: invalid lenInBytes");
  const DST_prime = concatBytes2(DST, i2osp(DST.length, 1));
  const Z_pad = i2osp(0, r_in_bytes);
  const l_i_b_str = i2osp(lenInBytes, 2);
  const b = new Array(ell);
  const b_0 = H(concatBytes2(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));
  b[0] = H(concatBytes2(b_0, i2osp(1, 1), DST_prime));
  for (let i = 1; i <= ell; i++) {
    const args = [strxor(b_0, b[i - 1]), i2osp(i + 1, 1), DST_prime];
    b[i] = H(concatBytes2(...args));
  }
  const pseudo_random_bytes = concatBytes2(...b);
  return pseudo_random_bytes.slice(0, lenInBytes);
}
function expand_message_xof(msg, DST, lenInBytes, k, H) {
  abytes(msg);
  anum(lenInBytes);
  DST = normDST(DST);
  if (DST.length > 255) {
    const dkLen = Math.ceil(2 * k / 8);
    DST = H.create({ dkLen }).update(utf8ToBytes("H2C-OVERSIZE-DST-")).update(DST).digest();
  }
  if (lenInBytes > 65535 || DST.length > 255)
    throw new Error("expand_message_xof: invalid lenInBytes");
  return H.create({ dkLen: lenInBytes }).update(msg).update(i2osp(lenInBytes, 2)).update(DST).update(i2osp(DST.length, 1)).digest();
}
function hash_to_field(msg, count, options) {
  _validateObject(options, {
    p: "bigint",
    m: "number",
    k: "number",
    hash: "function"
  });
  const { p, k, m, hash: hash3, expand, DST } = options;
  if (!isHash2(options.hash))
    throw new Error("expected valid hash");
  abytes(msg);
  anum(count);
  const log2p = p.toString(2).length;
  const L = Math.ceil((log2p + k) / 8);
  const len_in_bytes = count * m * L;
  let prb;
  if (expand === "xmd") {
    prb = expand_message_xmd(msg, DST, len_in_bytes, hash3);
  } else if (expand === "xof") {
    prb = expand_message_xof(msg, DST, len_in_bytes, k, hash3);
  } else if (expand === "_internal_pass") {
    prb = msg;
  } else {
    throw new Error('expand must be "xmd" or "xof"');
  }
  const u = new Array(count);
  for (let i = 0; i < count; i++) {
    const e = new Array(m);
    for (let j = 0; j < m; j++) {
      const elm_offset = L * (j + i * m);
      const tv = prb.subarray(elm_offset, elm_offset + L);
      e[j] = mod(os2ip(tv), p);
    }
    u[i] = e;
  }
  return u;
}
function isogenyMap(field, map) {
  const coeff = map.map((i) => Array.from(i).reverse());
  return (x, y) => {
    const [xn, xd, yn, yd] = coeff.map((val) => val.reduce((acc, i) => field.add(field.mul(acc, x), i)));
    const [xd_inv, yd_inv] = FpInvertBatch(field, [xd, yd], true);
    x = field.mul(xn, xd_inv);
    y = field.mul(y, field.mul(yn, yd_inv));
    return { x, y };
  };
}
function createHasher2(Point2, mapToCurve, defaults) {
  if (typeof mapToCurve !== "function")
    throw new Error("mapToCurve() must be defined");
  function map(num2) {
    return Point2.fromAffine(mapToCurve(num2));
  }
  function clear(initial) {
    const P = initial.clearCofactor();
    if (P.equals(Point2.ZERO))
      return Point2.ZERO;
    P.assertValidity();
    return P;
  }
  return {
    defaults,
    hashToCurve(msg, options) {
      const opts = Object.assign({}, defaults, options);
      const u = hash_to_field(msg, 2, opts);
      const u0 = map(u[0]);
      const u1 = map(u[1]);
      return clear(u0.add(u1));
    },
    encodeToCurve(msg, options) {
      const optsDst = defaults.encodeDST ? { DST: defaults.encodeDST } : {};
      const opts = Object.assign({}, defaults, optsDst, options);
      const u = hash_to_field(msg, 1, opts);
      const u0 = map(u[0]);
      return clear(u0);
    },
    /** See {@link H2CHasher} */
    mapToCurve(scalars) {
      if (!Array.isArray(scalars))
        throw new Error("expected array of bigints");
      for (const i of scalars)
        if (typeof i !== "bigint")
          throw new Error("expected array of bigints");
      return clear(map(scalars));
    },
    // hash_to_scalar can produce 0: https://www.rfc-editor.org/errata/eid8393
    // RFC 9380, draft-irtf-cfrg-bbs-signatures-08
    hashToScalar(msg, options) {
      const N = Point2.Fn.ORDER;
      const opts = Object.assign({}, defaults, { p: N, m: 1, DST: _DST_scalar }, options);
      return hash_to_field(msg, 1, opts)[0][0];
    }
  };
}
var os2ip, _DST_scalar;
var init_hash_to_curve = __esm({
  "node_modules/@noble/curves/esm/abstract/hash-to-curve.js"() {
    init_utils2();
    init_modular();
    os2ip = bytesToNumberBE;
    _DST_scalar = utf8ToBytes("HashToScalar-");
  }
});

// node_modules/@noble/curves/esm/abstract/montgomery.js
function validateOpts(curve) {
  _validateObject(curve, {
    adjustScalarBytes: "function",
    powPminus2: "function"
  });
  return Object.freeze({ ...curve });
}
function montgomery(curveDef) {
  const CURVE2 = validateOpts(curveDef);
  const { P, type: type3, adjustScalarBytes: adjustScalarBytes2, powPminus2, randomBytes: rand } = CURVE2;
  const is25519 = type3 === "x25519";
  if (!is25519 && type3 !== "x448")
    throw new Error("invalid type");
  const randomBytes_ = rand || randomBytes;
  const montgomeryBits = is25519 ? 255 : 448;
  const fieldLen = is25519 ? 32 : 56;
  const Gu = is25519 ? BigInt(9) : BigInt(5);
  const a24 = is25519 ? BigInt(121665) : BigInt(39081);
  const minScalar = is25519 ? _2n3 ** BigInt(254) : _2n3 ** BigInt(447);
  const maxAdded = is25519 ? BigInt(8) * _2n3 ** BigInt(251) - _1n5 : BigInt(4) * _2n3 ** BigInt(445) - _1n5;
  const maxScalar = minScalar + maxAdded + _1n5;
  const modP = (n) => mod(n, P);
  const GuBytes = encodeU(Gu);
  function encodeU(u) {
    return numberToBytesLE(modP(u), fieldLen);
  }
  function decodeU(u) {
    const _u = ensureBytes("u coordinate", u, fieldLen);
    if (is25519)
      _u[31] &= 127;
    return modP(bytesToNumberLE(_u));
  }
  function decodeScalar(scalar) {
    return bytesToNumberLE(adjustScalarBytes2(ensureBytes("scalar", scalar, fieldLen)));
  }
  function scalarMult(scalar, u) {
    const pu = montgomeryLadder(decodeU(u), decodeScalar(scalar));
    if (pu === _0n5)
      throw new Error("invalid private or public key received");
    return encodeU(pu);
  }
  function scalarMultBase(scalar) {
    return scalarMult(scalar, GuBytes);
  }
  function cswap(swap, x_2, x_3) {
    const dummy = modP(swap * (x_2 - x_3));
    x_2 = modP(x_2 - dummy);
    x_3 = modP(x_3 + dummy);
    return { x_2, x_3 };
  }
  function montgomeryLadder(u, scalar) {
    aInRange("u", u, _0n5, P);
    aInRange("scalar", scalar, minScalar, maxScalar);
    const k = scalar;
    const x_1 = u;
    let x_2 = _1n5;
    let z_2 = _0n5;
    let x_3 = u;
    let z_3 = _1n5;
    let swap = _0n5;
    for (let t = BigInt(montgomeryBits - 1); t >= _0n5; t--) {
      const k_t = k >> t & _1n5;
      swap ^= k_t;
      ({ x_2, x_3 } = cswap(swap, x_2, x_3));
      ({ x_2: z_2, x_3: z_3 } = cswap(swap, z_2, z_3));
      swap = k_t;
      const A = x_2 + z_2;
      const AA = modP(A * A);
      const B = x_2 - z_2;
      const BB = modP(B * B);
      const E = AA - BB;
      const C = x_3 + z_3;
      const D = x_3 - z_3;
      const DA = modP(D * A);
      const CB = modP(C * B);
      const dacb = DA + CB;
      const da_cb = DA - CB;
      x_3 = modP(dacb * dacb);
      z_3 = modP(x_1 * modP(da_cb * da_cb));
      x_2 = modP(AA * BB);
      z_2 = modP(E * (AA + modP(a24 * E)));
    }
    ({ x_2, x_3 } = cswap(swap, x_2, x_3));
    ({ x_2: z_2, x_3: z_3 } = cswap(swap, z_2, z_3));
    const z2 = powPminus2(z_2);
    return modP(x_2 * z2);
  }
  const lengths = {
    secretKey: fieldLen,
    publicKey: fieldLen,
    seed: fieldLen
  };
  const randomSecretKey = (seed2 = randomBytes_(fieldLen)) => {
    abytes(seed2, lengths.seed);
    return seed2;
  };
  function keygen(seed2) {
    const secretKey = randomSecretKey(seed2);
    return { secretKey, publicKey: scalarMultBase(secretKey) };
  }
  const utils3 = {
    randomSecretKey,
    randomPrivateKey: randomSecretKey
  };
  return {
    keygen,
    getSharedSecret: (secretKey, publicKey5) => scalarMult(secretKey, publicKey5),
    getPublicKey: (secretKey) => scalarMultBase(secretKey),
    scalarMult,
    scalarMultBase,
    utils: utils3,
    GuBytes: GuBytes.slice(),
    lengths
  };
}
var _0n5, _1n5, _2n3;
var init_montgomery = __esm({
  "node_modules/@noble/curves/esm/abstract/montgomery.js"() {
    init_utils2();
    init_modular();
    _0n5 = BigInt(0);
    _1n5 = BigInt(1);
    _2n3 = BigInt(2);
  }
});

// node_modules/@noble/curves/esm/ed25519.js
function ed25519_pow_2_252_3(x) {
  const _10n = BigInt(10), _20n = BigInt(20), _40n = BigInt(40), _80n = BigInt(80);
  const P = ed25519_CURVE_p;
  const x2 = x * x % P;
  const b2 = x2 * x % P;
  const b4 = pow2(b2, _2n4, P) * b2 % P;
  const b5 = pow2(b4, _1n6, P) * x % P;
  const b10 = pow2(b5, _5n2, P) * b5 % P;
  const b20 = pow2(b10, _10n, P) * b10 % P;
  const b40 = pow2(b20, _20n, P) * b20 % P;
  const b80 = pow2(b40, _40n, P) * b40 % P;
  const b160 = pow2(b80, _80n, P) * b80 % P;
  const b240 = pow2(b160, _80n, P) * b80 % P;
  const b250 = pow2(b240, _10n, P) * b10 % P;
  const pow_p_5_8 = pow2(b250, _2n4, P) * x % P;
  return { pow_p_5_8, b2 };
}
function adjustScalarBytes(bytes3) {
  bytes3[0] &= 248;
  bytes3[31] &= 127;
  bytes3[31] |= 64;
  return bytes3;
}
function uvRatio(u, v) {
  const P = ed25519_CURVE_p;
  const v32 = mod(v * v * v, P);
  const v7 = mod(v32 * v32 * v, P);
  const pow3 = ed25519_pow_2_252_3(u * v7).pow_p_5_8;
  let x = mod(u * v32 * pow3, P);
  const vx2 = mod(v * x * x, P);
  const root1 = x;
  const root2 = mod(x * ED25519_SQRT_M1, P);
  const useRoot1 = vx2 === u;
  const useRoot2 = vx2 === mod(-u, P);
  const noRoot = vx2 === mod(-u * ED25519_SQRT_M1, P);
  if (useRoot1)
    x = root1;
  if (useRoot2 || noRoot)
    x = root2;
  if (isNegativeLE(x, P))
    x = mod(-x, P);
  return { isValid: useRoot1 || useRoot2, value: x };
}
function ed25519_domain(data, ctx, phflag) {
  if (ctx.length > 255)
    throw new Error("Context is too big");
  return concatBytes2(utf8ToBytes("SigEd25519 no Ed25519 collisions"), new Uint8Array([phflag ? 1 : 0, ctx.length]), ctx, data);
}
function map_to_curve_elligator2_curve25519(u) {
  const ELL2_C4 = (ed25519_CURVE_p - _5n2) / _8n3;
  const ELL2_J = BigInt(486662);
  let tv1 = Fp.sqr(u);
  tv1 = Fp.mul(tv1, _2n4);
  let xd = Fp.add(tv1, Fp.ONE);
  let x1n = Fp.neg(ELL2_J);
  let tv2 = Fp.sqr(xd);
  let gxd = Fp.mul(tv2, xd);
  let gx1 = Fp.mul(tv1, ELL2_J);
  gx1 = Fp.mul(gx1, x1n);
  gx1 = Fp.add(gx1, tv2);
  gx1 = Fp.mul(gx1, x1n);
  let tv3 = Fp.sqr(gxd);
  tv2 = Fp.sqr(tv3);
  tv3 = Fp.mul(tv3, gxd);
  tv3 = Fp.mul(tv3, gx1);
  tv2 = Fp.mul(tv2, tv3);
  let y11 = Fp.pow(tv2, ELL2_C4);
  y11 = Fp.mul(y11, tv3);
  let y12 = Fp.mul(y11, ELL2_C3);
  tv2 = Fp.sqr(y11);
  tv2 = Fp.mul(tv2, gxd);
  let e1 = Fp.eql(tv2, gx1);
  let y1 = Fp.cmov(y12, y11, e1);
  let x2n = Fp.mul(x1n, tv1);
  let y21 = Fp.mul(y11, u);
  y21 = Fp.mul(y21, ELL2_C2);
  let y22 = Fp.mul(y21, ELL2_C3);
  let gx2 = Fp.mul(gx1, tv1);
  tv2 = Fp.sqr(y21);
  tv2 = Fp.mul(tv2, gxd);
  let e2 = Fp.eql(tv2, gx2);
  let y2 = Fp.cmov(y22, y21, e2);
  tv2 = Fp.sqr(y1);
  tv2 = Fp.mul(tv2, gxd);
  let e3 = Fp.eql(tv2, gx1);
  let xn = Fp.cmov(x2n, x1n, e3);
  let y = Fp.cmov(y2, y1, e3);
  let e4 = Fp.isOdd(y);
  y = Fp.cmov(y, Fp.neg(y), e3 !== e4);
  return { xMn: xn, xMd: xd, yMn: y, yMd: _1n6 };
}
function map_to_curve_elligator2_edwards25519(u) {
  const { xMn, xMd, yMn, yMd } = map_to_curve_elligator2_curve25519(u);
  let xn = Fp.mul(xMn, yMd);
  xn = Fp.mul(xn, ELL2_C1_EDWARDS);
  let xd = Fp.mul(xMd, yMn);
  let yn = Fp.sub(xMn, xMd);
  let yd = Fp.add(xMn, xMd);
  let tv1 = Fp.mul(xd, yd);
  let e = Fp.eql(tv1, Fp.ZERO);
  xn = Fp.cmov(xn, Fp.ZERO, e);
  xd = Fp.cmov(xd, Fp.ONE, e);
  yn = Fp.cmov(yn, Fp.ONE, e);
  yd = Fp.cmov(yd, Fp.ONE, e);
  const [xd_inv, yd_inv] = FpInvertBatch(Fp, [xd, yd], true);
  return { x: Fp.mul(xn, xd_inv), y: Fp.mul(yn, yd_inv) };
}
function calcElligatorRistrettoMap(r0) {
  const { d } = ed25519_CURVE;
  const P = ed25519_CURVE_p;
  const mod4 = (n) => Fp.create(n);
  const r = mod4(SQRT_M1 * r0 * r0);
  const Ns = mod4((r + _1n6) * ONE_MINUS_D_SQ);
  let c = BigInt(-1);
  const D = mod4((c - d * r) * mod4(r + d));
  let { isValid: Ns_D_is_sq, value: s } = uvRatio(Ns, D);
  let s_ = mod4(s * r0);
  if (!isNegativeLE(s_, P))
    s_ = mod4(-s_);
  if (!Ns_D_is_sq)
    s = s_;
  if (!Ns_D_is_sq)
    c = r;
  const Nt = mod4(c * (r - _1n6) * D_MINUS_ONE_SQ - D);
  const s2 = s * s;
  const W0 = mod4((s + s) * D);
  const W1 = mod4(Nt * SQRT_AD_MINUS_ONE);
  const W2 = mod4(_1n6 - s2);
  const W3 = mod4(_1n6 + s2);
  return new ed25519.Point(mod4(W0 * W3), mod4(W2 * W1), mod4(W1 * W3), mod4(W0 * W2));
}
function ristretto255_map(bytes3) {
  abytes(bytes3, 64);
  const r1 = bytes255ToNumberLE(bytes3.subarray(0, 32));
  const R1 = calcElligatorRistrettoMap(r1);
  const r2 = bytes255ToNumberLE(bytes3.subarray(32, 64));
  const R2 = calcElligatorRistrettoMap(r2);
  return new _RistrettoPoint(R1.add(R2));
}
var _0n6, _1n6, _2n4, _3n2, _5n2, _8n3, ed25519_CURVE_p, ed25519_CURVE, ED25519_SQRT_M1, Fp, Fn, ed25519Defaults, ed25519, ed25519ctx, ed25519ph, x25519, ELL2_C1, ELL2_C2, ELL2_C3, ELL2_C1_EDWARDS, ed25519_hasher, SQRT_M1, SQRT_AD_MINUS_ONE, INVSQRT_A_MINUS_D, ONE_MINUS_D_SQ, D_MINUS_ONE_SQ, invertSqrt, MAX_255B, bytes255ToNumberLE, _RistrettoPoint, ristretto255_hasher, hashToCurve, encodeToCurve, hashToRistretto255, hash_to_ristretto255;
var init_ed25519 = __esm({
  "node_modules/@noble/curves/esm/ed25519.js"() {
    init_sha2();
    init_utils();
    init_curve();
    init_edwards();
    init_hash_to_curve();
    init_modular();
    init_montgomery();
    init_utils2();
    _0n6 = BigInt(0);
    _1n6 = BigInt(1);
    _2n4 = BigInt(2);
    _3n2 = BigInt(3);
    _5n2 = BigInt(5);
    _8n3 = BigInt(8);
    ed25519_CURVE_p = BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed");
    ed25519_CURVE = (() => ({
      p: ed25519_CURVE_p,
      n: BigInt("0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed"),
      h: _8n3,
      a: BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec"),
      d: BigInt("0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3"),
      Gx: BigInt("0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a"),
      Gy: BigInt("0x6666666666666666666666666666666666666666666666666666666666666658")
    }))();
    ED25519_SQRT_M1 = BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");
    Fp = (() => Field(ed25519_CURVE.p, { isLE: true }))();
    Fn = (() => Field(ed25519_CURVE.n, { isLE: true }))();
    ed25519Defaults = (() => ({
      ...ed25519_CURVE,
      Fp,
      hash: sha512,
      adjustScalarBytes,
      // dom2
      // Ratio of u to v. Allows us to combine inversion and square root. Uses algo from RFC8032 5.1.3.
      // Constant-time, u/√v
      uvRatio
    }))();
    ed25519 = (() => twistedEdwards(ed25519Defaults))();
    ed25519ctx = (() => twistedEdwards({
      ...ed25519Defaults,
      domain: ed25519_domain
    }))();
    ed25519ph = (() => twistedEdwards(Object.assign({}, ed25519Defaults, {
      domain: ed25519_domain,
      prehash: sha512
    })))();
    x25519 = (() => {
      const P = Fp.ORDER;
      return montgomery({
        P,
        type: "x25519",
        powPminus2: (x) => {
          const { pow_p_5_8, b2 } = ed25519_pow_2_252_3(x);
          return mod(pow2(pow_p_5_8, _3n2, P) * b2, P);
        },
        adjustScalarBytes
      });
    })();
    ELL2_C1 = (() => (ed25519_CURVE_p + _3n2) / _8n3)();
    ELL2_C2 = (() => Fp.pow(_2n4, ELL2_C1))();
    ELL2_C3 = (() => Fp.sqrt(Fp.neg(Fp.ONE)))();
    ELL2_C1_EDWARDS = (() => FpSqrtEven(Fp, Fp.neg(BigInt(486664))))();
    ed25519_hasher = (() => createHasher2(ed25519.Point, (scalars) => map_to_curve_elligator2_edwards25519(scalars[0]), {
      DST: "edwards25519_XMD:SHA-512_ELL2_RO_",
      encodeDST: "edwards25519_XMD:SHA-512_ELL2_NU_",
      p: ed25519_CURVE_p,
      m: 1,
      k: 128,
      expand: "xmd",
      hash: sha512
    }))();
    SQRT_M1 = ED25519_SQRT_M1;
    SQRT_AD_MINUS_ONE = BigInt("25063068953384623474111414158702152701244531502492656460079210482610430750235");
    INVSQRT_A_MINUS_D = BigInt("54469307008909316920995813868745141605393597292927456921205312896311721017578");
    ONE_MINUS_D_SQ = BigInt("1159843021668779879193775521855586647937357759715417654439879720876111806838");
    D_MINUS_ONE_SQ = BigInt("40440834346308536858101042469323190826248399146238708352240133220865137265952");
    invertSqrt = (number5) => uvRatio(_1n6, number5);
    MAX_255B = BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
    bytes255ToNumberLE = (bytes3) => ed25519.Point.Fp.create(bytesToNumberLE(bytes3) & MAX_255B);
    _RistrettoPoint = class __RistrettoPoint extends PrimeEdwardsPoint {
      constructor(ep) {
        super(ep);
      }
      static fromAffine(ap) {
        return new __RistrettoPoint(ed25519.Point.fromAffine(ap));
      }
      assertSame(other) {
        if (!(other instanceof __RistrettoPoint))
          throw new Error("RistrettoPoint expected");
      }
      init(ep) {
        return new __RistrettoPoint(ep);
      }
      /** @deprecated use `import { ristretto255_hasher } from '@noble/curves/ed25519.js';` */
      static hashToCurve(hex3) {
        return ristretto255_map(ensureBytes("ristrettoHash", hex3, 64));
      }
      static fromBytes(bytes3) {
        abytes(bytes3, 32);
        const { a, d } = ed25519_CURVE;
        const P = ed25519_CURVE_p;
        const mod4 = (n) => Fp.create(n);
        const s = bytes255ToNumberLE(bytes3);
        if (!equalBytes2(Fp.toBytes(s), bytes3) || isNegativeLE(s, P))
          throw new Error("invalid ristretto255 encoding 1");
        const s2 = mod4(s * s);
        const u1 = mod4(_1n6 + a * s2);
        const u2 = mod4(_1n6 - a * s2);
        const u1_2 = mod4(u1 * u1);
        const u2_2 = mod4(u2 * u2);
        const v = mod4(a * d * u1_2 - u2_2);
        const { isValid, value: I } = invertSqrt(mod4(v * u2_2));
        const Dx = mod4(I * u2);
        const Dy = mod4(I * Dx * v);
        let x = mod4((s + s) * Dx);
        if (isNegativeLE(x, P))
          x = mod4(-x);
        const y = mod4(u1 * Dy);
        const t = mod4(x * y);
        if (!isValid || isNegativeLE(t, P) || y === _0n6)
          throw new Error("invalid ristretto255 encoding 2");
        return new __RistrettoPoint(new ed25519.Point(x, y, _1n6, t));
      }
      /**
       * Converts ristretto-encoded string to ristretto point.
       * Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-decode).
       * @param hex Ristretto-encoded 32 bytes. Not every 32-byte string is valid ristretto encoding
       */
      static fromHex(hex3) {
        return __RistrettoPoint.fromBytes(ensureBytes("ristrettoHex", hex3, 32));
      }
      static msm(points, scalars) {
        return pippenger(__RistrettoPoint, ed25519.Point.Fn, points, scalars);
      }
      /**
       * Encodes ristretto point to Uint8Array.
       * Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-encode).
       */
      toBytes() {
        let { X, Y, Z, T } = this.ep;
        const P = ed25519_CURVE_p;
        const mod4 = (n) => Fp.create(n);
        const u1 = mod4(mod4(Z + Y) * mod4(Z - Y));
        const u2 = mod4(X * Y);
        const u2sq = mod4(u2 * u2);
        const { value: invsqrt } = invertSqrt(mod4(u1 * u2sq));
        const D1 = mod4(invsqrt * u1);
        const D2 = mod4(invsqrt * u2);
        const zInv = mod4(D1 * D2 * T);
        let D;
        if (isNegativeLE(T * zInv, P)) {
          let _x = mod4(Y * SQRT_M1);
          let _y = mod4(X * SQRT_M1);
          X = _x;
          Y = _y;
          D = mod4(D1 * INVSQRT_A_MINUS_D);
        } else {
          D = D2;
        }
        if (isNegativeLE(X * zInv, P))
          Y = mod4(-Y);
        let s = mod4((Z - Y) * D);
        if (isNegativeLE(s, P))
          s = mod4(-s);
        return Fp.toBytes(s);
      }
      /**
       * Compares two Ristretto points.
       * Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-equals).
       */
      equals(other) {
        this.assertSame(other);
        const { X: X1, Y: Y1 } = this.ep;
        const { X: X2, Y: Y2 } = other.ep;
        const mod4 = (n) => Fp.create(n);
        const one = mod4(X1 * Y2) === mod4(Y1 * X2);
        const two = mod4(Y1 * Y2) === mod4(X1 * X2);
        return one || two;
      }
      is0() {
        return this.equals(__RistrettoPoint.ZERO);
      }
    };
    _RistrettoPoint.BASE = (() => new _RistrettoPoint(ed25519.Point.BASE))();
    _RistrettoPoint.ZERO = (() => new _RistrettoPoint(ed25519.Point.ZERO))();
    _RistrettoPoint.Fp = /* @__PURE__ */ (() => Fp)();
    _RistrettoPoint.Fn = /* @__PURE__ */ (() => Fn)();
    ristretto255_hasher = {
      hashToCurve(msg, options) {
        const DST = (options == null ? void 0 : options.DST) || "ristretto255_XMD:SHA-512_R255MAP_RO_";
        const xmd = expand_message_xmd(msg, DST, 64, sha512);
        return ristretto255_map(xmd);
      },
      hashToScalar(msg, options = { DST: _DST_scalar }) {
        const xmd = expand_message_xmd(msg, options.DST, 64, sha512);
        return Fn.create(bytesToNumberLE(xmd));
      }
    };
    hashToCurve = (() => ed25519_hasher.hashToCurve)();
    encodeToCurve = (() => ed25519_hasher.encodeToCurve)();
    hashToRistretto255 = (() => ristretto255_hasher.hashToCurve)();
    hash_to_ristretto255 = (() => ristretto255_hasher.hashToCurve)();
  }
});

// browser-external:buffer
var require_buffer2 = __commonJS({
  "browser-external:buffer"(exports2, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "buffer" has been externalized for browser compatibility. Cannot access "buffer.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/bn.js/lib/bn.js
var require_bn = __commonJS({
  "node_modules/bn.js/lib/bn.js"(exports2, module2) {
    (function(module3, exports3) {
      "use strict";
      function assert5(val, msg) {
        if (!val) throw new Error(msg || "Assertion failed");
      }
      function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
      function BN3(number5, base3, endian) {
        if (BN3.isBN(number5)) {
          return number5;
        }
        this.negative = 0;
        this.words = null;
        this.length = 0;
        this.red = null;
        if (number5 !== null) {
          if (base3 === "le" || base3 === "be") {
            endian = base3;
            base3 = 10;
          }
          this._init(number5 || 0, base3 || 10, endian || "be");
        }
      }
      if (typeof module3 === "object") {
        module3.exports = BN3;
      } else {
        exports3.BN = BN3;
      }
      BN3.BN = BN3;
      BN3.wordSize = 26;
      var Buffer4;
      try {
        if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
          Buffer4 = window.Buffer;
        } else {
          Buffer4 = require_buffer2().Buffer;
        }
      } catch (e) {
      }
      BN3.isBN = function isBN(num2) {
        if (num2 instanceof BN3) {
          return true;
        }
        return num2 !== null && typeof num2 === "object" && num2.constructor.wordSize === BN3.wordSize && Array.isArray(num2.words);
      };
      BN3.max = function max(left, right) {
        if (left.cmp(right) > 0) return left;
        return right;
      };
      BN3.min = function min(left, right) {
        if (left.cmp(right) < 0) return left;
        return right;
      };
      BN3.prototype._init = function init(number5, base3, endian) {
        if (typeof number5 === "number") {
          return this._initNumber(number5, base3, endian);
        }
        if (typeof number5 === "object") {
          return this._initArray(number5, base3, endian);
        }
        if (base3 === "hex") {
          base3 = 16;
        }
        assert5(base3 === (base3 | 0) && base3 >= 2 && base3 <= 36);
        number5 = number5.toString().replace(/\s+/g, "");
        var start = 0;
        if (number5[0] === "-") {
          start++;
          this.negative = 1;
        }
        if (start < number5.length) {
          if (base3 === 16) {
            this._parseHex(number5, start, endian);
          } else {
            this._parseBase(number5, base3, start);
            if (endian === "le") {
              this._initArray(this.toArray(), base3, endian);
            }
          }
        }
      };
      BN3.prototype._initNumber = function _initNumber(number5, base3, endian) {
        if (number5 < 0) {
          this.negative = 1;
          number5 = -number5;
        }
        if (number5 < 67108864) {
          this.words = [number5 & 67108863];
          this.length = 1;
        } else if (number5 < 4503599627370496) {
          this.words = [
            number5 & 67108863,
            number5 / 67108864 & 67108863
          ];
          this.length = 2;
        } else {
          assert5(number5 < 9007199254740992);
          this.words = [
            number5 & 67108863,
            number5 / 67108864 & 67108863,
            1
          ];
          this.length = 3;
        }
        if (endian !== "le") return;
        this._initArray(this.toArray(), base3, endian);
      };
      BN3.prototype._initArray = function _initArray(number5, base3, endian) {
        assert5(typeof number5.length === "number");
        if (number5.length <= 0) {
          this.words = [0];
          this.length = 1;
          return this;
        }
        this.length = Math.ceil(number5.length / 3);
        this.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          this.words[i] = 0;
        }
        var j, w;
        var off = 0;
        if (endian === "be") {
          for (i = number5.length - 1, j = 0; i >= 0; i -= 3) {
            w = number5[i] | number5[i - 1] << 8 | number5[i - 2] << 16;
            this.words[j] |= w << off & 67108863;
            this.words[j + 1] = w >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        } else if (endian === "le") {
          for (i = 0, j = 0; i < number5.length; i += 3) {
            w = number5[i] | number5[i + 1] << 8 | number5[i + 2] << 16;
            this.words[j] |= w << off & 67108863;
            this.words[j + 1] = w >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        }
        return this._strip();
      };
      function parseHex4Bits(string3, index4) {
        var c = string3.charCodeAt(index4);
        if (c >= 48 && c <= 57) {
          return c - 48;
        } else if (c >= 65 && c <= 70) {
          return c - 55;
        } else if (c >= 97 && c <= 102) {
          return c - 87;
        } else {
          assert5(false, "Invalid character in " + string3);
        }
      }
      function parseHexByte(string3, lowerBound, index4) {
        var r = parseHex4Bits(string3, index4);
        if (index4 - 1 >= lowerBound) {
          r |= parseHex4Bits(string3, index4 - 1) << 4;
        }
        return r;
      }
      BN3.prototype._parseHex = function _parseHex(number5, start, endian) {
        this.length = Math.ceil((number5.length - start) / 6);
        this.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          this.words[i] = 0;
        }
        var off = 0;
        var j = 0;
        var w;
        if (endian === "be") {
          for (i = number5.length - 1; i >= start; i -= 2) {
            w = parseHexByte(number5, start, i) << off;
            this.words[j] |= w & 67108863;
            if (off >= 18) {
              off -= 18;
              j += 1;
              this.words[j] |= w >>> 26;
            } else {
              off += 8;
            }
          }
        } else {
          var parseLength = number5.length - start;
          for (i = parseLength % 2 === 0 ? start + 1 : start; i < number5.length; i += 2) {
            w = parseHexByte(number5, start, i) << off;
            this.words[j] |= w & 67108863;
            if (off >= 18) {
              off -= 18;
              j += 1;
              this.words[j] |= w >>> 26;
            } else {
              off += 8;
            }
          }
        }
        this._strip();
      };
      function parseBase(str2, start, end, mul) {
        var r = 0;
        var b = 0;
        var len = Math.min(str2.length, end);
        for (var i = start; i < len; i++) {
          var c = str2.charCodeAt(i) - 48;
          r *= mul;
          if (c >= 49) {
            b = c - 49 + 10;
          } else if (c >= 17) {
            b = c - 17 + 10;
          } else {
            b = c;
          }
          assert5(c >= 0 && b < mul, "Invalid character");
          r += b;
        }
        return r;
      }
      BN3.prototype._parseBase = function _parseBase(number5, base3, start) {
        this.words = [0];
        this.length = 1;
        for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base3) {
          limbLen++;
        }
        limbLen--;
        limbPow = limbPow / base3 | 0;
        var total = number5.length - start;
        var mod4 = total % limbLen;
        var end = Math.min(total, total - mod4) + start;
        var word = 0;
        for (var i = start; i < end; i += limbLen) {
          word = parseBase(number5, i, i + limbLen, base3);
          this.imuln(limbPow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        if (mod4 !== 0) {
          var pow3 = 1;
          word = parseBase(number5, i, number5.length, base3);
          for (i = 0; i < mod4; i++) {
            pow3 *= base3;
          }
          this.imuln(pow3);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        this._strip();
      };
      BN3.prototype.copy = function copy(dest) {
        dest.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          dest.words[i] = this.words[i];
        }
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
      };
      function move(dest, src2) {
        dest.words = src2.words;
        dest.length = src2.length;
        dest.negative = src2.negative;
        dest.red = src2.red;
      }
      BN3.prototype._move = function _move(dest) {
        move(dest, this);
      };
      BN3.prototype.clone = function clone2() {
        var r = new BN3(null);
        this.copy(r);
        return r;
      };
      BN3.prototype._expand = function _expand(size4) {
        while (this.length < size4) {
          this.words[this.length++] = 0;
        }
        return this;
      };
      BN3.prototype._strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0) {
          this.length--;
        }
        return this._normSign();
      };
      BN3.prototype._normSign = function _normSign() {
        if (this.length === 1 && this.words[0] === 0) {
          this.negative = 0;
        }
        return this;
      };
      if (typeof Symbol !== "undefined" && typeof Symbol.for === "function") {
        try {
          BN3.prototype[Symbol.for("nodejs.util.inspect.custom")] = inspect;
        } catch (e) {
          BN3.prototype.inspect = inspect;
        }
      } else {
        BN3.prototype.inspect = inspect;
      }
      function inspect() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      }
      var zeros = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ];
      var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ];
      var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      BN3.prototype.toString = function toString2(base3, padding2) {
        base3 = base3 || 10;
        padding2 = padding2 | 0 || 1;
        var out;
        if (base3 === 16 || base3 === "hex") {
          out = "";
          var off = 0;
          var carry = 0;
          for (var i = 0; i < this.length; i++) {
            var w = this.words[i];
            var word = ((w << off | carry) & 16777215).toString(16);
            carry = w >>> 24 - off & 16777215;
            off += 2;
            if (off >= 26) {
              off -= 26;
              i--;
            }
            if (carry !== 0 || i !== this.length - 1) {
              out = zeros[6 - word.length] + word + out;
            } else {
              out = word + out;
            }
          }
          if (carry !== 0) {
            out = carry.toString(16) + out;
          }
          while (out.length % padding2 !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        if (base3 === (base3 | 0) && base3 >= 2 && base3 <= 36) {
          var groupSize = groupSizes[base3];
          var groupBase = groupBases[base3];
          out = "";
          var c = this.clone();
          c.negative = 0;
          while (!c.isZero()) {
            var r = c.modrn(groupBase).toString(base3);
            c = c.idivn(groupBase);
            if (!c.isZero()) {
              out = zeros[groupSize - r.length] + r + out;
            } else {
              out = r + out;
            }
          }
          if (this.isZero()) {
            out = "0" + out;
          }
          while (out.length % padding2 !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        assert5(false, "Base should be between 2 and 36");
      };
      BN3.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2) {
          ret += this.words[1] * 67108864;
        } else if (this.length === 3 && this.words[2] === 1) {
          ret += 4503599627370496 + this.words[1] * 67108864;
        } else if (this.length > 2) {
          assert5(false, "Number can only safely store up to 53 bits");
        }
        return this.negative !== 0 ? -ret : ret;
      };
      BN3.prototype.toJSON = function toJSON() {
        return this.toString(16, 2);
      };
      if (Buffer4) {
        BN3.prototype.toBuffer = function toBuffer2(endian, length2) {
          return this.toArrayLike(Buffer4, endian, length2);
        };
      }
      BN3.prototype.toArray = function toArray(endian, length2) {
        return this.toArrayLike(Array, endian, length2);
      };
      var allocate = function allocate2(ArrayType, size4) {
        if (ArrayType.allocUnsafe) {
          return ArrayType.allocUnsafe(size4);
        }
        return new ArrayType(size4);
      };
      BN3.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length2) {
        this._strip();
        var byteLength2 = this.byteLength();
        var reqLength = length2 || Math.max(1, byteLength2);
        assert5(byteLength2 <= reqLength, "byte array longer than desired length");
        assert5(reqLength > 0, "Requested array length <= 0");
        var res = allocate(ArrayType, reqLength);
        var postfix = endian === "le" ? "LE" : "BE";
        this["_toArrayLike" + postfix](res, byteLength2);
        return res;
      };
      BN3.prototype._toArrayLikeLE = function _toArrayLikeLE(res, byteLength2) {
        var position = 0;
        var carry = 0;
        for (var i = 0, shift = 0; i < this.length; i++) {
          var word = this.words[i] << shift | carry;
          res[position++] = word & 255;
          if (position < res.length) {
            res[position++] = word >> 8 & 255;
          }
          if (position < res.length) {
            res[position++] = word >> 16 & 255;
          }
          if (shift === 6) {
            if (position < res.length) {
              res[position++] = word >> 24 & 255;
            }
            carry = 0;
            shift = 0;
          } else {
            carry = word >>> 24;
            shift += 2;
          }
        }
        if (position < res.length) {
          res[position++] = carry;
          while (position < res.length) {
            res[position++] = 0;
          }
        }
      };
      BN3.prototype._toArrayLikeBE = function _toArrayLikeBE(res, byteLength2) {
        var position = res.length - 1;
        var carry = 0;
        for (var i = 0, shift = 0; i < this.length; i++) {
          var word = this.words[i] << shift | carry;
          res[position--] = word & 255;
          if (position >= 0) {
            res[position--] = word >> 8 & 255;
          }
          if (position >= 0) {
            res[position--] = word >> 16 & 255;
          }
          if (shift === 6) {
            if (position >= 0) {
              res[position--] = word >> 24 & 255;
            }
            carry = 0;
            shift = 0;
          } else {
            carry = word >>> 24;
            shift += 2;
          }
        }
        if (position >= 0) {
          res[position--] = carry;
          while (position >= 0) {
            res[position--] = 0;
          }
        }
      };
      if (Math.clz32) {
        BN3.prototype._countBits = function _countBits(w) {
          return 32 - Math.clz32(w);
        };
      } else {
        BN3.prototype._countBits = function _countBits(w) {
          var t = w;
          var r = 0;
          if (t >= 4096) {
            r += 13;
            t >>>= 13;
          }
          if (t >= 64) {
            r += 7;
            t >>>= 7;
          }
          if (t >= 8) {
            r += 4;
            t >>>= 4;
          }
          if (t >= 2) {
            r += 2;
            t >>>= 2;
          }
          return r + t;
        };
      }
      BN3.prototype._zeroBits = function _zeroBits(w) {
        if (w === 0) return 26;
        var t = w;
        var r = 0;
        if ((t & 8191) === 0) {
          r += 13;
          t >>>= 13;
        }
        if ((t & 127) === 0) {
          r += 7;
          t >>>= 7;
        }
        if ((t & 15) === 0) {
          r += 4;
          t >>>= 4;
        }
        if ((t & 3) === 0) {
          r += 2;
          t >>>= 2;
        }
        if ((t & 1) === 0) {
          r++;
        }
        return r;
      };
      BN3.prototype.bitLength = function bitLength() {
        var w = this.words[this.length - 1];
        var hi = this._countBits(w);
        return (this.length - 1) * 26 + hi;
      };
      function toBitArray(num2) {
        var w = new Array(num2.bitLength());
        for (var bit = 0; bit < w.length; bit++) {
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          w[bit] = num2.words[off] >>> wbit & 1;
        }
        return w;
      }
      BN3.prototype.zeroBits = function zeroBits() {
        if (this.isZero()) return 0;
        var r = 0;
        for (var i = 0; i < this.length; i++) {
          var b = this._zeroBits(this.words[i]);
          r += b;
          if (b !== 26) break;
        }
        return r;
      };
      BN3.prototype.byteLength = function byteLength2() {
        return Math.ceil(this.bitLength() / 8);
      };
      BN3.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) {
          return this.abs().inotn(width).iaddn(1);
        }
        return this.clone();
      };
      BN3.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) {
          return this.notn(width).iaddn(1).ineg();
        }
        return this.clone();
      };
      BN3.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
      };
      BN3.prototype.neg = function neg() {
        return this.clone().ineg();
      };
      BN3.prototype.ineg = function ineg() {
        if (!this.isZero()) {
          this.negative ^= 1;
        }
        return this;
      };
      BN3.prototype.iuor = function iuor(num2) {
        while (this.length < num2.length) {
          this.words[this.length++] = 0;
        }
        for (var i = 0; i < num2.length; i++) {
          this.words[i] = this.words[i] | num2.words[i];
        }
        return this._strip();
      };
      BN3.prototype.ior = function ior(num2) {
        assert5((this.negative | num2.negative) === 0);
        return this.iuor(num2);
      };
      BN3.prototype.or = function or2(num2) {
        if (this.length > num2.length) return this.clone().ior(num2);
        return num2.clone().ior(this);
      };
      BN3.prototype.uor = function uor(num2) {
        if (this.length > num2.length) return this.clone().iuor(num2);
        return num2.clone().iuor(this);
      };
      BN3.prototype.iuand = function iuand(num2) {
        var b;
        if (this.length > num2.length) {
          b = num2;
        } else {
          b = this;
        }
        for (var i = 0; i < b.length; i++) {
          this.words[i] = this.words[i] & num2.words[i];
        }
        this.length = b.length;
        return this._strip();
      };
      BN3.prototype.iand = function iand(num2) {
        assert5((this.negative | num2.negative) === 0);
        return this.iuand(num2);
      };
      BN3.prototype.and = function and(num2) {
        if (this.length > num2.length) return this.clone().iand(num2);
        return num2.clone().iand(this);
      };
      BN3.prototype.uand = function uand(num2) {
        if (this.length > num2.length) return this.clone().iuand(num2);
        return num2.clone().iuand(this);
      };
      BN3.prototype.iuxor = function iuxor(num2) {
        var a;
        var b;
        if (this.length > num2.length) {
          a = this;
          b = num2;
        } else {
          a = num2;
          b = this;
        }
        for (var i = 0; i < b.length; i++) {
          this.words[i] = a.words[i] ^ b.words[i];
        }
        if (this !== a) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        this.length = a.length;
        return this._strip();
      };
      BN3.prototype.ixor = function ixor(num2) {
        assert5((this.negative | num2.negative) === 0);
        return this.iuxor(num2);
      };
      BN3.prototype.xor = function xor(num2) {
        if (this.length > num2.length) return this.clone().ixor(num2);
        return num2.clone().ixor(this);
      };
      BN3.prototype.uxor = function uxor(num2) {
        if (this.length > num2.length) return this.clone().iuxor(num2);
        return num2.clone().iuxor(this);
      };
      BN3.prototype.inotn = function inotn(width) {
        assert5(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        this._expand(bytesNeeded);
        if (bitsLeft > 0) {
          bytesNeeded--;
        }
        for (var i = 0; i < bytesNeeded; i++) {
          this.words[i] = ~this.words[i] & 67108863;
        }
        if (bitsLeft > 0) {
          this.words[i] = ~this.words[i] & 67108863 >> 26 - bitsLeft;
        }
        return this._strip();
      };
      BN3.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
      };
      BN3.prototype.setn = function setn(bit, val) {
        assert5(typeof bit === "number" && bit >= 0);
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off + 1);
        if (val) {
          this.words[off] = this.words[off] | 1 << wbit;
        } else {
          this.words[off] = this.words[off] & ~(1 << wbit);
        }
        return this._strip();
      };
      BN3.prototype.iadd = function iadd(num2) {
        var r;
        if (this.negative !== 0 && num2.negative === 0) {
          this.negative = 0;
          r = this.isub(num2);
          this.negative ^= 1;
          return this._normSign();
        } else if (this.negative === 0 && num2.negative !== 0) {
          num2.negative = 0;
          r = this.isub(num2);
          num2.negative = 1;
          return r._normSign();
        }
        var a, b;
        if (this.length > num2.length) {
          a = this;
          b = num2;
        } else {
          a = num2;
          b = this;
        }
        var carry = 0;
        for (var i = 0; i < b.length; i++) {
          r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
          this.words[i] = r & 67108863;
          carry = r >>> 26;
        }
        for (; carry !== 0 && i < a.length; i++) {
          r = (a.words[i] | 0) + carry;
          this.words[i] = r & 67108863;
          carry = r >>> 26;
        }
        this.length = a.length;
        if (carry !== 0) {
          this.words[this.length] = carry;
          this.length++;
        } else if (a !== this) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        return this;
      };
      BN3.prototype.add = function add5(num2) {
        var res;
        if (num2.negative !== 0 && this.negative === 0) {
          num2.negative = 0;
          res = this.sub(num2);
          num2.negative ^= 1;
          return res;
        } else if (num2.negative === 0 && this.negative !== 0) {
          this.negative = 0;
          res = num2.sub(this);
          this.negative = 1;
          return res;
        }
        if (this.length > num2.length) return this.clone().iadd(num2);
        return num2.clone().iadd(this);
      };
      BN3.prototype.isub = function isub(num2) {
        if (num2.negative !== 0) {
          num2.negative = 0;
          var r = this.iadd(num2);
          num2.negative = 1;
          return r._normSign();
        } else if (this.negative !== 0) {
          this.negative = 0;
          this.iadd(num2);
          this.negative = 1;
          return this._normSign();
        }
        var cmp = this.cmp(num2);
        if (cmp === 0) {
          this.negative = 0;
          this.length = 1;
          this.words[0] = 0;
          return this;
        }
        var a, b;
        if (cmp > 0) {
          a = this;
          b = num2;
        } else {
          a = num2;
          b = this;
        }
        var carry = 0;
        for (var i = 0; i < b.length; i++) {
          r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
          carry = r >> 26;
          this.words[i] = r & 67108863;
        }
        for (; carry !== 0 && i < a.length; i++) {
          r = (a.words[i] | 0) + carry;
          carry = r >> 26;
          this.words[i] = r & 67108863;
        }
        if (carry === 0 && i < a.length && a !== this) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        this.length = Math.max(this.length, i);
        if (a !== this) {
          this.negative = 1;
        }
        return this._strip();
      };
      BN3.prototype.sub = function sub(num2) {
        return this.clone().isub(num2);
      };
      function smallMulTo(self2, num2, out) {
        out.negative = num2.negative ^ self2.negative;
        var len = self2.length + num2.length | 0;
        out.length = len;
        len = len - 1 | 0;
        var a = self2.words[0] | 0;
        var b = num2.words[0] | 0;
        var r = a * b;
        var lo = r & 67108863;
        var carry = r / 67108864 | 0;
        out.words[0] = lo;
        for (var k = 1; k < len; k++) {
          var ncarry = carry >>> 26;
          var rword = carry & 67108863;
          var maxJ = Math.min(k, num2.length - 1);
          for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
            var i = k - j | 0;
            a = self2.words[i] | 0;
            b = num2.words[j] | 0;
            r = a * b + rword;
            ncarry += r / 67108864 | 0;
            rword = r & 67108863;
          }
          out.words[k] = rword | 0;
          carry = ncarry | 0;
        }
        if (carry !== 0) {
          out.words[k] = carry | 0;
        } else {
          out.length--;
        }
        return out._strip();
      }
      var comb10MulTo = function comb10MulTo2(self2, num2, out) {
        var a = self2.words;
        var b = num2.words;
        var o = out.words;
        var c = 0;
        var lo;
        var mid;
        var hi;
        var a0 = a[0] | 0;
        var al0 = a0 & 8191;
        var ah0 = a0 >>> 13;
        var a1 = a[1] | 0;
        var al1 = a1 & 8191;
        var ah1 = a1 >>> 13;
        var a2 = a[2] | 0;
        var al2 = a2 & 8191;
        var ah2 = a2 >>> 13;
        var a3 = a[3] | 0;
        var al3 = a3 & 8191;
        var ah3 = a3 >>> 13;
        var a4 = a[4] | 0;
        var al4 = a4 & 8191;
        var ah4 = a4 >>> 13;
        var a5 = a[5] | 0;
        var al5 = a5 & 8191;
        var ah5 = a5 >>> 13;
        var a6 = a[6] | 0;
        var al6 = a6 & 8191;
        var ah6 = a6 >>> 13;
        var a7 = a[7] | 0;
        var al7 = a7 & 8191;
        var ah7 = a7 >>> 13;
        var a8 = a[8] | 0;
        var al8 = a8 & 8191;
        var ah8 = a8 >>> 13;
        var a9 = a[9] | 0;
        var al9 = a9 & 8191;
        var ah9 = a9 >>> 13;
        var b0 = b[0] | 0;
        var bl0 = b0 & 8191;
        var bh0 = b0 >>> 13;
        var b1 = b[1] | 0;
        var bl1 = b1 & 8191;
        var bh1 = b1 >>> 13;
        var b2 = b[2] | 0;
        var bl2 = b2 & 8191;
        var bh2 = b2 >>> 13;
        var b3 = b[3] | 0;
        var bl3 = b3 & 8191;
        var bh3 = b3 >>> 13;
        var b4 = b[4] | 0;
        var bl4 = b4 & 8191;
        var bh4 = b4 >>> 13;
        var b5 = b[5] | 0;
        var bl5 = b5 & 8191;
        var bh5 = b5 >>> 13;
        var b6 = b[6] | 0;
        var bl6 = b6 & 8191;
        var bh6 = b6 >>> 13;
        var b7 = b[7] | 0;
        var bl7 = b7 & 8191;
        var bh7 = b7 >>> 13;
        var b8 = b[8] | 0;
        var bl8 = b8 & 8191;
        var bh8 = b8 >>> 13;
        var b9 = b[9] | 0;
        var bl9 = b9 & 8191;
        var bh9 = b9 >>> 13;
        out.negative = self2.negative ^ num2.negative;
        out.length = 19;
        lo = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi = Math.imul(ah0, bh0);
        var w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
        w0 &= 67108863;
        lo = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi = Math.imul(ah1, bh0);
        lo = lo + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi = hi + Math.imul(ah0, bh1) | 0;
        var w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
        w1 &= 67108863;
        lo = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi = Math.imul(ah2, bh0);
        lo = lo + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi = hi + Math.imul(ah1, bh1) | 0;
        lo = lo + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi = hi + Math.imul(ah0, bh2) | 0;
        var w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
        w2 &= 67108863;
        lo = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi = Math.imul(ah3, bh0);
        lo = lo + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi = hi + Math.imul(ah2, bh1) | 0;
        lo = lo + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi = hi + Math.imul(ah1, bh2) | 0;
        lo = lo + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi = hi + Math.imul(ah0, bh3) | 0;
        var w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
        w3 &= 67108863;
        lo = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi = Math.imul(ah4, bh0);
        lo = lo + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi = hi + Math.imul(ah3, bh1) | 0;
        lo = lo + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi = hi + Math.imul(ah2, bh2) | 0;
        lo = lo + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi = hi + Math.imul(ah1, bh3) | 0;
        lo = lo + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi = hi + Math.imul(ah0, bh4) | 0;
        var w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
        w4 &= 67108863;
        lo = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi = Math.imul(ah5, bh0);
        lo = lo + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi = hi + Math.imul(ah4, bh1) | 0;
        lo = lo + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi = hi + Math.imul(ah3, bh2) | 0;
        lo = lo + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi = hi + Math.imul(ah2, bh3) | 0;
        lo = lo + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi = hi + Math.imul(ah1, bh4) | 0;
        lo = lo + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi = hi + Math.imul(ah0, bh5) | 0;
        var w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
        w5 &= 67108863;
        lo = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi = Math.imul(ah6, bh0);
        lo = lo + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi = hi + Math.imul(ah5, bh1) | 0;
        lo = lo + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi = hi + Math.imul(ah4, bh2) | 0;
        lo = lo + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi = hi + Math.imul(ah3, bh3) | 0;
        lo = lo + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi = hi + Math.imul(ah2, bh4) | 0;
        lo = lo + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi = hi + Math.imul(ah1, bh5) | 0;
        lo = lo + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi = hi + Math.imul(ah0, bh6) | 0;
        var w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
        w6 &= 67108863;
        lo = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi = Math.imul(ah7, bh0);
        lo = lo + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi = hi + Math.imul(ah6, bh1) | 0;
        lo = lo + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi = hi + Math.imul(ah5, bh2) | 0;
        lo = lo + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi = hi + Math.imul(ah4, bh3) | 0;
        lo = lo + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi = hi + Math.imul(ah3, bh4) | 0;
        lo = lo + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi = hi + Math.imul(ah2, bh5) | 0;
        lo = lo + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi = hi + Math.imul(ah1, bh6) | 0;
        lo = lo + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi = hi + Math.imul(ah0, bh7) | 0;
        var w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
        w7 &= 67108863;
        lo = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi = Math.imul(ah8, bh0);
        lo = lo + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi = hi + Math.imul(ah7, bh1) | 0;
        lo = lo + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi = hi + Math.imul(ah6, bh2) | 0;
        lo = lo + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi = hi + Math.imul(ah5, bh3) | 0;
        lo = lo + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi = hi + Math.imul(ah4, bh4) | 0;
        lo = lo + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi = hi + Math.imul(ah3, bh5) | 0;
        lo = lo + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi = hi + Math.imul(ah2, bh6) | 0;
        lo = lo + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi = hi + Math.imul(ah1, bh7) | 0;
        lo = lo + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi = hi + Math.imul(ah0, bh8) | 0;
        var w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 67108863;
        lo = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi = Math.imul(ah9, bh0);
        lo = lo + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi = hi + Math.imul(ah8, bh1) | 0;
        lo = lo + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi = hi + Math.imul(ah7, bh2) | 0;
        lo = lo + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi = hi + Math.imul(ah6, bh3) | 0;
        lo = lo + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi = hi + Math.imul(ah5, bh4) | 0;
        lo = lo + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi = hi + Math.imul(ah4, bh5) | 0;
        lo = lo + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi = hi + Math.imul(ah3, bh6) | 0;
        lo = lo + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi = hi + Math.imul(ah2, bh7) | 0;
        lo = lo + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi = hi + Math.imul(ah1, bh8) | 0;
        lo = lo + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi = hi + Math.imul(ah0, bh9) | 0;
        var w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 67108863;
        lo = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi = Math.imul(ah9, bh1);
        lo = lo + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi = hi + Math.imul(ah8, bh2) | 0;
        lo = lo + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi = hi + Math.imul(ah7, bh3) | 0;
        lo = lo + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi = hi + Math.imul(ah6, bh4) | 0;
        lo = lo + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi = hi + Math.imul(ah5, bh5) | 0;
        lo = lo + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi = hi + Math.imul(ah4, bh6) | 0;
        lo = lo + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi = hi + Math.imul(ah3, bh7) | 0;
        lo = lo + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi = hi + Math.imul(ah2, bh8) | 0;
        lo = lo + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi = hi + Math.imul(ah1, bh9) | 0;
        var w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 67108863;
        lo = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi = Math.imul(ah9, bh2);
        lo = lo + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi = hi + Math.imul(ah8, bh3) | 0;
        lo = lo + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi = hi + Math.imul(ah7, bh4) | 0;
        lo = lo + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi = hi + Math.imul(ah6, bh5) | 0;
        lo = lo + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi = hi + Math.imul(ah5, bh6) | 0;
        lo = lo + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi = hi + Math.imul(ah4, bh7) | 0;
        lo = lo + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi = hi + Math.imul(ah3, bh8) | 0;
        lo = lo + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi = hi + Math.imul(ah2, bh9) | 0;
        var w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 67108863;
        lo = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi = Math.imul(ah9, bh3);
        lo = lo + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi = hi + Math.imul(ah8, bh4) | 0;
        lo = lo + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi = hi + Math.imul(ah7, bh5) | 0;
        lo = lo + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi = hi + Math.imul(ah6, bh6) | 0;
        lo = lo + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi = hi + Math.imul(ah5, bh7) | 0;
        lo = lo + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi = hi + Math.imul(ah4, bh8) | 0;
        lo = lo + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi = hi + Math.imul(ah3, bh9) | 0;
        var w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 67108863;
        lo = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi = Math.imul(ah9, bh4);
        lo = lo + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi = hi + Math.imul(ah8, bh5) | 0;
        lo = lo + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi = hi + Math.imul(ah7, bh6) | 0;
        lo = lo + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi = hi + Math.imul(ah6, bh7) | 0;
        lo = lo + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi = hi + Math.imul(ah5, bh8) | 0;
        lo = lo + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi = hi + Math.imul(ah4, bh9) | 0;
        var w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 67108863;
        lo = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi = Math.imul(ah9, bh5);
        lo = lo + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi = hi + Math.imul(ah8, bh6) | 0;
        lo = lo + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi = hi + Math.imul(ah7, bh7) | 0;
        lo = lo + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi = hi + Math.imul(ah6, bh8) | 0;
        lo = lo + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi = hi + Math.imul(ah5, bh9) | 0;
        var w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 67108863;
        lo = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi = Math.imul(ah9, bh6);
        lo = lo + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi = hi + Math.imul(ah8, bh7) | 0;
        lo = lo + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi = hi + Math.imul(ah7, bh8) | 0;
        lo = lo + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi = hi + Math.imul(ah6, bh9) | 0;
        var w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 67108863;
        lo = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi = Math.imul(ah9, bh7);
        lo = lo + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi = hi + Math.imul(ah8, bh8) | 0;
        lo = lo + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi = hi + Math.imul(ah7, bh9) | 0;
        var w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 67108863;
        lo = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi = Math.imul(ah9, bh8);
        lo = lo + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi = hi + Math.imul(ah8, bh9) | 0;
        var w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 67108863;
        lo = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi = Math.imul(ah9, bh9);
        var w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 67108863;
        o[0] = w0;
        o[1] = w1;
        o[2] = w2;
        o[3] = w3;
        o[4] = w4;
        o[5] = w5;
        o[6] = w6;
        o[7] = w7;
        o[8] = w8;
        o[9] = w9;
        o[10] = w10;
        o[11] = w11;
        o[12] = w12;
        o[13] = w13;
        o[14] = w14;
        o[15] = w15;
        o[16] = w16;
        o[17] = w17;
        o[18] = w18;
        if (c !== 0) {
          o[19] = c;
          out.length++;
        }
        return out;
      };
      if (!Math.imul) {
        comb10MulTo = smallMulTo;
      }
      function bigMulTo(self2, num2, out) {
        out.negative = num2.negative ^ self2.negative;
        out.length = self2.length + num2.length;
        var carry = 0;
        var hncarry = 0;
        for (var k = 0; k < out.length - 1; k++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 67108863;
          var maxJ = Math.min(k, num2.length - 1);
          for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
            var i = k - j;
            var a = self2.words[i] | 0;
            var b = num2.words[j] | 0;
            var r = a * b;
            var lo = r & 67108863;
            ncarry = ncarry + (r / 67108864 | 0) | 0;
            lo = lo + rword | 0;
            rword = lo & 67108863;
            ncarry = ncarry + (lo >>> 26) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 67108863;
          }
          out.words[k] = rword;
          carry = ncarry;
          ncarry = hncarry;
        }
        if (carry !== 0) {
          out.words[k] = carry;
        } else {
          out.length--;
        }
        return out._strip();
      }
      function jumboMulTo(self2, num2, out) {
        return bigMulTo(self2, num2, out);
      }
      BN3.prototype.mulTo = function mulTo(num2, out) {
        var res;
        var len = this.length + num2.length;
        if (this.length === 10 && num2.length === 10) {
          res = comb10MulTo(this, num2, out);
        } else if (len < 63) {
          res = smallMulTo(this, num2, out);
        } else if (len < 1024) {
          res = bigMulTo(this, num2, out);
        } else {
          res = jumboMulTo(this, num2, out);
        }
        return res;
      };
      function FFTM(x, y) {
        this.x = x;
        this.y = y;
      }
      FFTM.prototype.makeRBT = function makeRBT(N) {
        var t = new Array(N);
        var l = BN3.prototype._countBits(N) - 1;
        for (var i = 0; i < N; i++) {
          t[i] = this.revBin(i, l, N);
        }
        return t;
      };
      FFTM.prototype.revBin = function revBin(x, l, N) {
        if (x === 0 || x === N - 1) return x;
        var rb = 0;
        for (var i = 0; i < l; i++) {
          rb |= (x & 1) << l - i - 1;
          x >>= 1;
        }
        return rb;
      };
      FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
        for (var i = 0; i < N; i++) {
          rtws[i] = rws[rbt[i]];
          itws[i] = iws[rbt[i]];
        }
      };
      FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N);
        for (var s = 1; s < N; s <<= 1) {
          var l = s << 1;
          var rtwdf = Math.cos(2 * Math.PI / l);
          var itwdf = Math.sin(2 * Math.PI / l);
          for (var p = 0; p < N; p += l) {
            var rtwdf_ = rtwdf;
            var itwdf_ = itwdf;
            for (var j = 0; j < s; j++) {
              var re = rtws[p + j];
              var ie = itws[p + j];
              var ro = rtws[p + j + s];
              var io = itws[p + j + s];
              var rx = rtwdf_ * ro - itwdf_ * io;
              io = rtwdf_ * io + itwdf_ * ro;
              ro = rx;
              rtws[p + j] = re + ro;
              itws[p + j] = ie + io;
              rtws[p + j + s] = re - ro;
              itws[p + j + s] = ie - io;
              if (j !== l) {
                rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                rtwdf_ = rx;
              }
            }
          }
        }
      };
      FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
        var N = Math.max(m, n) | 1;
        var odd = N & 1;
        var i = 0;
        for (N = N / 2 | 0; N; N = N >>> 1) {
          i++;
        }
        return 1 << i + 1 + odd;
      };
      FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
        if (N <= 1) return;
        for (var i = 0; i < N / 2; i++) {
          var t = rws[i];
          rws[i] = rws[N - i - 1];
          rws[N - i - 1] = t;
          t = iws[i];
          iws[i] = -iws[N - i - 1];
          iws[N - i - 1] = -t;
        }
      };
      FFTM.prototype.normalize13b = function normalize13b(ws, N) {
        var carry = 0;
        for (var i = 0; i < N / 2; i++) {
          var w = Math.round(ws[2 * i + 1] / N) * 8192 + Math.round(ws[2 * i] / N) + carry;
          ws[i] = w & 67108863;
          if (w < 67108864) {
            carry = 0;
          } else {
            carry = w / 67108864 | 0;
          }
        }
        return ws;
      };
      FFTM.prototype.convert13b = function convert13b(ws, len, rws, N) {
        var carry = 0;
        for (var i = 0; i < len; i++) {
          carry = carry + (ws[i] | 0);
          rws[2 * i] = carry & 8191;
          carry = carry >>> 13;
          rws[2 * i + 1] = carry & 8191;
          carry = carry >>> 13;
        }
        for (i = 2 * len; i < N; ++i) {
          rws[i] = 0;
        }
        assert5(carry === 0);
        assert5((carry & ~8191) === 0);
      };
      FFTM.prototype.stub = function stub(N) {
        var ph = new Array(N);
        for (var i = 0; i < N; i++) {
          ph[i] = 0;
        }
        return ph;
      };
      FFTM.prototype.mulp = function mulp(x, y, out) {
        var N = 2 * this.guessLen13b(x.length, y.length);
        var rbt = this.makeRBT(N);
        var _ = this.stub(N);
        var rws = new Array(N);
        var rwst = new Array(N);
        var iwst = new Array(N);
        var nrws = new Array(N);
        var nrwst = new Array(N);
        var niwst = new Array(N);
        var rmws = out.words;
        rmws.length = N;
        this.convert13b(x.words, x.length, rws, N);
        this.convert13b(y.words, y.length, nrws, N);
        this.transform(rws, _, rwst, iwst, N, rbt);
        this.transform(nrws, _, nrwst, niwst, N, rbt);
        for (var i = 0; i < N; i++) {
          var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
          iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
          rwst[i] = rx;
        }
        this.conjugate(rwst, iwst, N);
        this.transform(rwst, iwst, rmws, _, N, rbt);
        this.conjugate(rmws, _, N);
        this.normalize13b(rmws, N);
        out.negative = x.negative ^ y.negative;
        out.length = x.length + y.length;
        return out._strip();
      };
      BN3.prototype.mul = function mul(num2) {
        var out = new BN3(null);
        out.words = new Array(this.length + num2.length);
        return this.mulTo(num2, out);
      };
      BN3.prototype.mulf = function mulf(num2) {
        var out = new BN3(null);
        out.words = new Array(this.length + num2.length);
        return jumboMulTo(this, num2, out);
      };
      BN3.prototype.imul = function imul(num2) {
        return this.clone().mulTo(num2, this);
      };
      BN3.prototype.imuln = function imuln(num2) {
        var isNegNum = num2 < 0;
        if (isNegNum) num2 = -num2;
        assert5(typeof num2 === "number");
        assert5(num2 < 67108864);
        var carry = 0;
        for (var i = 0; i < this.length; i++) {
          var w = (this.words[i] | 0) * num2;
          var lo = (w & 67108863) + (carry & 67108863);
          carry >>= 26;
          carry += w / 67108864 | 0;
          carry += lo >>> 26;
          this.words[i] = lo & 67108863;
        }
        if (carry !== 0) {
          this.words[i] = carry;
          this.length++;
        }
        this.length = num2 === 0 ? 1 : this.length;
        return isNegNum ? this.ineg() : this;
      };
      BN3.prototype.muln = function muln(num2) {
        return this.clone().imuln(num2);
      };
      BN3.prototype.sqr = function sqr() {
        return this.mul(this);
      };
      BN3.prototype.isqr = function isqr() {
        return this.imul(this.clone());
      };
      BN3.prototype.pow = function pow3(num2) {
        var w = toBitArray(num2);
        if (w.length === 0) return new BN3(1);
        var res = this;
        for (var i = 0; i < w.length; i++, res = res.sqr()) {
          if (w[i] !== 0) break;
        }
        if (++i < w.length) {
          for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
            if (w[i] === 0) continue;
            res = res.mul(q);
          }
        }
        return res;
      };
      BN3.prototype.iushln = function iushln(bits) {
        assert5(typeof bits === "number" && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        var carryMask = 67108863 >>> 26 - r << 26 - r;
        var i;
        if (r !== 0) {
          var carry = 0;
          for (i = 0; i < this.length; i++) {
            var newCarry = this.words[i] & carryMask;
            var c = (this.words[i] | 0) - newCarry << r;
            this.words[i] = c | carry;
            carry = newCarry >>> 26 - r;
          }
          if (carry) {
            this.words[i] = carry;
            this.length++;
          }
        }
        if (s !== 0) {
          for (i = this.length - 1; i >= 0; i--) {
            this.words[i + s] = this.words[i];
          }
          for (i = 0; i < s; i++) {
            this.words[i] = 0;
          }
          this.length += s;
        }
        return this._strip();
      };
      BN3.prototype.ishln = function ishln(bits) {
        assert5(this.negative === 0);
        return this.iushln(bits);
      };
      BN3.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert5(typeof bits === "number" && bits >= 0);
        var h;
        if (hint) {
          h = (hint - hint % 26) / 26;
        } else {
          h = 0;
        }
        var r = bits % 26;
        var s = Math.min((bits - r) / 26, this.length);
        var mask3 = 67108863 ^ 67108863 >>> r << r;
        var maskedWords = extended;
        h -= s;
        h = Math.max(0, h);
        if (maskedWords) {
          for (var i = 0; i < s; i++) {
            maskedWords.words[i] = this.words[i];
          }
          maskedWords.length = s;
        }
        if (s === 0) {
        } else if (this.length > s) {
          this.length -= s;
          for (i = 0; i < this.length; i++) {
            this.words[i] = this.words[i + s];
          }
        } else {
          this.words[0] = 0;
          this.length = 1;
        }
        var carry = 0;
        for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
          var word = this.words[i] | 0;
          this.words[i] = carry << 26 - r | word >>> r;
          carry = word & mask3;
        }
        if (maskedWords && carry !== 0) {
          maskedWords.words[maskedWords.length++] = carry;
        }
        if (this.length === 0) {
          this.words[0] = 0;
          this.length = 1;
        }
        return this._strip();
      };
      BN3.prototype.ishrn = function ishrn(bits, hint, extended) {
        assert5(this.negative === 0);
        return this.iushrn(bits, hint, extended);
      };
      BN3.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
      };
      BN3.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
      };
      BN3.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
      };
      BN3.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
      };
      BN3.prototype.testn = function testn(bit) {
        assert5(typeof bit === "number" && bit >= 0);
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
        if (this.length <= s) return false;
        var w = this.words[s];
        return !!(w & q);
      };
      BN3.prototype.imaskn = function imaskn(bits) {
        assert5(typeof bits === "number" && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        assert5(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s) {
          return this;
        }
        if (r !== 0) {
          s++;
        }
        this.length = Math.min(s, this.length);
        if (r !== 0) {
          var mask3 = 67108863 ^ 67108863 >>> r << r;
          this.words[this.length - 1] &= mask3;
        }
        return this._strip();
      };
      BN3.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
      };
      BN3.prototype.iaddn = function iaddn(num2) {
        assert5(typeof num2 === "number");
        assert5(num2 < 67108864);
        if (num2 < 0) return this.isubn(-num2);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) <= num2) {
            this.words[0] = num2 - (this.words[0] | 0);
            this.negative = 0;
            return this;
          }
          this.negative = 0;
          this.isubn(num2);
          this.negative = 1;
          return this;
        }
        return this._iaddn(num2);
      };
      BN3.prototype._iaddn = function _iaddn(num2) {
        this.words[0] += num2;
        for (var i = 0; i < this.length && this.words[i] >= 67108864; i++) {
          this.words[i] -= 67108864;
          if (i === this.length - 1) {
            this.words[i + 1] = 1;
          } else {
            this.words[i + 1]++;
          }
        }
        this.length = Math.max(this.length, i + 1);
        return this;
      };
      BN3.prototype.isubn = function isubn(num2) {
        assert5(typeof num2 === "number");
        assert5(num2 < 67108864);
        if (num2 < 0) return this.iaddn(-num2);
        if (this.negative !== 0) {
          this.negative = 0;
          this.iaddn(num2);
          this.negative = 1;
          return this;
        }
        this.words[0] -= num2;
        if (this.length === 1 && this.words[0] < 0) {
          this.words[0] = -this.words[0];
          this.negative = 1;
        } else {
          for (var i = 0; i < this.length && this.words[i] < 0; i++) {
            this.words[i] += 67108864;
            this.words[i + 1] -= 1;
          }
        }
        return this._strip();
      };
      BN3.prototype.addn = function addn(num2) {
        return this.clone().iaddn(num2);
      };
      BN3.prototype.subn = function subn(num2) {
        return this.clone().isubn(num2);
      };
      BN3.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
      };
      BN3.prototype.abs = function abs() {
        return this.clone().iabs();
      };
      BN3.prototype._ishlnsubmul = function _ishlnsubmul(num2, mul, shift) {
        var len = num2.length + shift;
        var i;
        this._expand(len);
        var w;
        var carry = 0;
        for (i = 0; i < num2.length; i++) {
          w = (this.words[i + shift] | 0) + carry;
          var right = (num2.words[i] | 0) * mul;
          w -= right & 67108863;
          carry = (w >> 26) - (right / 67108864 | 0);
          this.words[i + shift] = w & 67108863;
        }
        for (; i < this.length - shift; i++) {
          w = (this.words[i + shift] | 0) + carry;
          carry = w >> 26;
          this.words[i + shift] = w & 67108863;
        }
        if (carry === 0) return this._strip();
        assert5(carry === -1);
        carry = 0;
        for (i = 0; i < this.length; i++) {
          w = -(this.words[i] | 0) + carry;
          carry = w >> 26;
          this.words[i] = w & 67108863;
        }
        this.negative = 1;
        return this._strip();
      };
      BN3.prototype._wordDiv = function _wordDiv(num2, mode) {
        var shift = this.length - num2.length;
        var a = this.clone();
        var b = num2;
        var bhi = b.words[b.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
          b = b.ushln(shift);
          a.iushln(shift);
          bhi = b.words[b.length - 1] | 0;
        }
        var m = a.length - b.length;
        var q;
        if (mode !== "mod") {
          q = new BN3(null);
          q.length = m + 1;
          q.words = new Array(q.length);
          for (var i = 0; i < q.length; i++) {
            q.words[i] = 0;
          }
        }
        var diff = a.clone()._ishlnsubmul(b, 1, m);
        if (diff.negative === 0) {
          a = diff;
          if (q) {
            q.words[m] = 1;
          }
        }
        for (var j = m - 1; j >= 0; j--) {
          var qj = (a.words[b.length + j] | 0) * 67108864 + (a.words[b.length + j - 1] | 0);
          qj = Math.min(qj / bhi | 0, 67108863);
          a._ishlnsubmul(b, qj, j);
          while (a.negative !== 0) {
            qj--;
            a.negative = 0;
            a._ishlnsubmul(b, 1, j);
            if (!a.isZero()) {
              a.negative ^= 1;
            }
          }
          if (q) {
            q.words[j] = qj;
          }
        }
        if (q) {
          q._strip();
        }
        a._strip();
        if (mode !== "div" && shift !== 0) {
          a.iushrn(shift);
        }
        return {
          div: q || null,
          mod: a
        };
      };
      BN3.prototype.divmod = function divmod(num2, mode, positive) {
        assert5(!num2.isZero());
        if (this.isZero()) {
          return {
            div: new BN3(0),
            mod: new BN3(0)
          };
        }
        var div, mod4, res;
        if (this.negative !== 0 && num2.negative === 0) {
          res = this.neg().divmod(num2, mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          if (mode !== "div") {
            mod4 = res.mod.neg();
            if (positive && mod4.negative !== 0) {
              mod4.iadd(num2);
            }
          }
          return {
            div,
            mod: mod4
          };
        }
        if (this.negative === 0 && num2.negative !== 0) {
          res = this.divmod(num2.neg(), mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          return {
            div,
            mod: res.mod
          };
        }
        if ((this.negative & num2.negative) !== 0) {
          res = this.neg().divmod(num2.neg(), mode);
          if (mode !== "div") {
            mod4 = res.mod.neg();
            if (positive && mod4.negative !== 0) {
              mod4.isub(num2);
            }
          }
          return {
            div: res.div,
            mod: mod4
          };
        }
        if (num2.length > this.length || this.cmp(num2) < 0) {
          return {
            div: new BN3(0),
            mod: this
          };
        }
        if (num2.length === 1) {
          if (mode === "div") {
            return {
              div: this.divn(num2.words[0]),
              mod: null
            };
          }
          if (mode === "mod") {
            return {
              div: null,
              mod: new BN3(this.modrn(num2.words[0]))
            };
          }
          return {
            div: this.divn(num2.words[0]),
            mod: new BN3(this.modrn(num2.words[0]))
          };
        }
        return this._wordDiv(num2, mode);
      };
      BN3.prototype.div = function div(num2) {
        return this.divmod(num2, "div", false).div;
      };
      BN3.prototype.mod = function mod4(num2) {
        return this.divmod(num2, "mod", false).mod;
      };
      BN3.prototype.umod = function umod(num2) {
        return this.divmod(num2, "mod", true).mod;
      };
      BN3.prototype.divRound = function divRound(num2) {
        var dm = this.divmod(num2);
        if (dm.mod.isZero()) return dm.div;
        var mod4 = dm.div.negative !== 0 ? dm.mod.isub(num2) : dm.mod;
        var half = num2.ushrn(1);
        var r2 = num2.andln(1);
        var cmp = mod4.cmp(half);
        if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      };
      BN3.prototype.modrn = function modrn(num2) {
        var isNegNum = num2 < 0;
        if (isNegNum) num2 = -num2;
        assert5(num2 <= 67108863);
        var p = (1 << 26) % num2;
        var acc = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          acc = (p * acc + (this.words[i] | 0)) % num2;
        }
        return isNegNum ? -acc : acc;
      };
      BN3.prototype.modn = function modn(num2) {
        return this.modrn(num2);
      };
      BN3.prototype.idivn = function idivn(num2) {
        var isNegNum = num2 < 0;
        if (isNegNum) num2 = -num2;
        assert5(num2 <= 67108863);
        var carry = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          var w = (this.words[i] | 0) + carry * 67108864;
          this.words[i] = w / num2 | 0;
          carry = w % num2;
        }
        this._strip();
        return isNegNum ? this.ineg() : this;
      };
      BN3.prototype.divn = function divn(num2) {
        return this.clone().idivn(num2);
      };
      BN3.prototype.egcd = function egcd(p) {
        assert5(p.negative === 0);
        assert5(!p.isZero());
        var x = this;
        var y = p.clone();
        if (x.negative !== 0) {
          x = x.umod(p);
        } else {
          x = x.clone();
        }
        var A = new BN3(1);
        var B = new BN3(0);
        var C = new BN3(0);
        var D = new BN3(1);
        var g = 0;
        while (x.isEven() && y.isEven()) {
          x.iushrn(1);
          y.iushrn(1);
          ++g;
        }
        var yp = y.clone();
        var xp = x.clone();
        while (!x.isZero()) {
          for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1) ;
          if (i > 0) {
            x.iushrn(i);
            while (i-- > 0) {
              if (A.isOdd() || B.isOdd()) {
                A.iadd(yp);
                B.isub(xp);
              }
              A.iushrn(1);
              B.iushrn(1);
            }
          }
          for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1) ;
          if (j > 0) {
            y.iushrn(j);
            while (j-- > 0) {
              if (C.isOdd() || D.isOdd()) {
                C.iadd(yp);
                D.isub(xp);
              }
              C.iushrn(1);
              D.iushrn(1);
            }
          }
          if (x.cmp(y) >= 0) {
            x.isub(y);
            A.isub(C);
            B.isub(D);
          } else {
            y.isub(x);
            C.isub(A);
            D.isub(B);
          }
        }
        return {
          a: C,
          b: D,
          gcd: y.iushln(g)
        };
      };
      BN3.prototype._invmp = function _invmp(p) {
        assert5(p.negative === 0);
        assert5(!p.isZero());
        var a = this;
        var b = p.clone();
        if (a.negative !== 0) {
          a = a.umod(p);
        } else {
          a = a.clone();
        }
        var x1 = new BN3(1);
        var x2 = new BN3(0);
        var delta = b.clone();
        while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
          for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1) ;
          if (i > 0) {
            a.iushrn(i);
            while (i-- > 0) {
              if (x1.isOdd()) {
                x1.iadd(delta);
              }
              x1.iushrn(1);
            }
          }
          for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1) ;
          if (j > 0) {
            b.iushrn(j);
            while (j-- > 0) {
              if (x2.isOdd()) {
                x2.iadd(delta);
              }
              x2.iushrn(1);
            }
          }
          if (a.cmp(b) >= 0) {
            a.isub(b);
            x1.isub(x2);
          } else {
            b.isub(a);
            x2.isub(x1);
          }
        }
        var res;
        if (a.cmpn(1) === 0) {
          res = x1;
        } else {
          res = x2;
        }
        if (res.cmpn(0) < 0) {
          res.iadd(p);
        }
        return res;
      };
      BN3.prototype.gcd = function gcd2(num2) {
        if (this.isZero()) return num2.abs();
        if (num2.isZero()) return this.abs();
        var a = this.clone();
        var b = num2.clone();
        a.negative = 0;
        b.negative = 0;
        for (var shift = 0; a.isEven() && b.isEven(); shift++) {
          a.iushrn(1);
          b.iushrn(1);
        }
        do {
          while (a.isEven()) {
            a.iushrn(1);
          }
          while (b.isEven()) {
            b.iushrn(1);
          }
          var r = a.cmp(b);
          if (r < 0) {
            var t = a;
            a = b;
            b = t;
          } else if (r === 0 || b.cmpn(1) === 0) {
            break;
          }
          a.isub(b);
        } while (true);
        return b.iushln(shift);
      };
      BN3.prototype.invm = function invm(num2) {
        return this.egcd(num2).a.umod(num2);
      };
      BN3.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
      };
      BN3.prototype.isOdd = function isOdd2() {
        return (this.words[0] & 1) === 1;
      };
      BN3.prototype.andln = function andln(num2) {
        return this.words[0] & num2;
      };
      BN3.prototype.bincn = function bincn(bit) {
        assert5(typeof bit === "number");
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
        if (this.length <= s) {
          this._expand(s + 1);
          this.words[s] |= q;
          return this;
        }
        var carry = q;
        for (var i = s; carry !== 0 && i < this.length; i++) {
          var w = this.words[i] | 0;
          w += carry;
          carry = w >>> 26;
          w &= 67108863;
          this.words[i] = w;
        }
        if (carry !== 0) {
          this.words[i] = carry;
          this.length++;
        }
        return this;
      };
      BN3.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
      };
      BN3.prototype.cmpn = function cmpn(num2) {
        var negative = num2 < 0;
        if (this.negative !== 0 && !negative) return -1;
        if (this.negative === 0 && negative) return 1;
        this._strip();
        var res;
        if (this.length > 1) {
          res = 1;
        } else {
          if (negative) {
            num2 = -num2;
          }
          assert5(num2 <= 67108863, "Number is too big");
          var w = this.words[0] | 0;
          res = w === num2 ? 0 : w < num2 ? -1 : 1;
        }
        if (this.negative !== 0) return -res | 0;
        return res;
      };
      BN3.prototype.cmp = function cmp(num2) {
        if (this.negative !== 0 && num2.negative === 0) return -1;
        if (this.negative === 0 && num2.negative !== 0) return 1;
        var res = this.ucmp(num2);
        if (this.negative !== 0) return -res | 0;
        return res;
      };
      BN3.prototype.ucmp = function ucmp(num2) {
        if (this.length > num2.length) return 1;
        if (this.length < num2.length) return -1;
        var res = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          var a = this.words[i] | 0;
          var b = num2.words[i] | 0;
          if (a === b) continue;
          if (a < b) {
            res = -1;
          } else if (a > b) {
            res = 1;
          }
          break;
        }
        return res;
      };
      BN3.prototype.gtn = function gtn(num2) {
        return this.cmpn(num2) === 1;
      };
      BN3.prototype.gt = function gt(num2) {
        return this.cmp(num2) === 1;
      };
      BN3.prototype.gten = function gten(num2) {
        return this.cmpn(num2) >= 0;
      };
      BN3.prototype.gte = function gte(num2) {
        return this.cmp(num2) >= 0;
      };
      BN3.prototype.ltn = function ltn(num2) {
        return this.cmpn(num2) === -1;
      };
      BN3.prototype.lt = function lt(num2) {
        return this.cmp(num2) === -1;
      };
      BN3.prototype.lten = function lten(num2) {
        return this.cmpn(num2) <= 0;
      };
      BN3.prototype.lte = function lte(num2) {
        return this.cmp(num2) <= 0;
      };
      BN3.prototype.eqn = function eqn(num2) {
        return this.cmpn(num2) === 0;
      };
      BN3.prototype.eq = function eq2(num2) {
        return this.cmp(num2) === 0;
      };
      BN3.red = function red(num2) {
        return new Red(num2);
      };
      BN3.prototype.toRed = function toRed(ctx) {
        assert5(!this.red, "Already a number in reduction context");
        assert5(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
      };
      BN3.prototype.fromRed = function fromRed() {
        assert5(this.red, "fromRed works only with numbers in reduction context");
        return this.red.convertFrom(this);
      };
      BN3.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
      };
      BN3.prototype.forceRed = function forceRed(ctx) {
        assert5(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
      };
      BN3.prototype.redAdd = function redAdd(num2) {
        assert5(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num2);
      };
      BN3.prototype.redIAdd = function redIAdd(num2) {
        assert5(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num2);
      };
      BN3.prototype.redSub = function redSub(num2) {
        assert5(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num2);
      };
      BN3.prototype.redISub = function redISub(num2) {
        assert5(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num2);
      };
      BN3.prototype.redShl = function redShl(num2) {
        assert5(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num2);
      };
      BN3.prototype.redMul = function redMul(num2) {
        assert5(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num2);
        return this.red.mul(this, num2);
      };
      BN3.prototype.redIMul = function redIMul(num2) {
        assert5(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num2);
        return this.red.imul(this, num2);
      };
      BN3.prototype.redSqr = function redSqr() {
        assert5(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
      };
      BN3.prototype.redISqr = function redISqr() {
        assert5(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
      };
      BN3.prototype.redSqrt = function redSqrt() {
        assert5(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
      };
      BN3.prototype.redInvm = function redInvm() {
        assert5(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
      };
      BN3.prototype.redNeg = function redNeg() {
        assert5(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
      };
      BN3.prototype.redPow = function redPow(num2) {
        assert5(this.red && !num2.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num2);
      };
      var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function MPrime(name, p) {
        this.name = name;
        this.p = new BN3(p, 16);
        this.n = this.p.bitLength();
        this.k = new BN3(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
      }
      MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN3(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
      };
      MPrime.prototype.ireduce = function ireduce(num2) {
        var r = num2;
        var rlen;
        do {
          this.split(r, this.tmp);
          r = this.imulK(r);
          r = r.iadd(this.tmp);
          rlen = r.bitLength();
        } while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
        if (cmp === 0) {
          r.words[0] = 0;
          r.length = 1;
        } else if (cmp > 0) {
          r.isub(this.p);
        } else {
          if (r.strip !== void 0) {
            r.strip();
          } else {
            r._strip();
          }
        }
        return r;
      };
      MPrime.prototype.split = function split6(input, out) {
        input.iushrn(this.n, 0, out);
      };
      MPrime.prototype.imulK = function imulK(num2) {
        return num2.imul(this.k);
      };
      function K256() {
        MPrime.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      inherits(K256, MPrime);
      K256.prototype.split = function split6(input, output4) {
        var mask3 = 4194303;
        var outLen = Math.min(input.length, 9);
        for (var i = 0; i < outLen; i++) {
          output4.words[i] = input.words[i];
        }
        output4.length = outLen;
        if (input.length <= 9) {
          input.words[0] = 0;
          input.length = 1;
          return;
        }
        var prev = input.words[9];
        output4.words[output4.length++] = prev & mask3;
        for (i = 10; i < input.length; i++) {
          var next = input.words[i] | 0;
          input.words[i - 10] = (next & mask3) << 4 | prev >>> 22;
          prev = next;
        }
        prev >>>= 22;
        input.words[i - 10] = prev;
        if (prev === 0 && input.length > 10) {
          input.length -= 10;
        } else {
          input.length -= 9;
        }
      };
      K256.prototype.imulK = function imulK(num2) {
        num2.words[num2.length] = 0;
        num2.words[num2.length + 1] = 0;
        num2.length += 2;
        var lo = 0;
        for (var i = 0; i < num2.length; i++) {
          var w = num2.words[i] | 0;
          lo += w * 977;
          num2.words[i] = lo & 67108863;
          lo = w * 64 + (lo / 67108864 | 0);
        }
        if (num2.words[num2.length - 1] === 0) {
          num2.length--;
          if (num2.words[num2.length - 1] === 0) {
            num2.length--;
          }
        }
        return num2;
      };
      function P224() {
        MPrime.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      inherits(P224, MPrime);
      function P192() {
        MPrime.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      inherits(P192, MPrime);
      function P25519() {
        MPrime.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      inherits(P25519, MPrime);
      P25519.prototype.imulK = function imulK(num2) {
        var carry = 0;
        for (var i = 0; i < num2.length; i++) {
          var hi = (num2.words[i] | 0) * 19 + carry;
          var lo = hi & 67108863;
          hi >>>= 26;
          num2.words[i] = lo;
          carry = hi;
        }
        if (carry !== 0) {
          num2.words[num2.length++] = carry;
        }
        return num2;
      };
      BN3._prime = function prime(name) {
        if (primes[name]) return primes[name];
        var prime2;
        if (name === "k256") {
          prime2 = new K256();
        } else if (name === "p224") {
          prime2 = new P224();
        } else if (name === "p192") {
          prime2 = new P192();
        } else if (name === "p25519") {
          prime2 = new P25519();
        } else {
          throw new Error("Unknown prime " + name);
        }
        primes[name] = prime2;
        return prime2;
      };
      function Red(m) {
        if (typeof m === "string") {
          var prime = BN3._prime(m);
          this.m = prime.p;
          this.prime = prime;
        } else {
          assert5(m.gtn(1), "modulus must be greater than 1");
          this.m = m;
          this.prime = null;
        }
      }
      Red.prototype._verify1 = function _verify1(a) {
        assert5(a.negative === 0, "red works only with positives");
        assert5(a.red, "red works only with red numbers");
      };
      Red.prototype._verify2 = function _verify2(a, b) {
        assert5((a.negative | b.negative) === 0, "red works only with positives");
        assert5(
          a.red && a.red === b.red,
          "red works only with red numbers"
        );
      };
      Red.prototype.imod = function imod(a) {
        if (this.prime) return this.prime.ireduce(a)._forceRed(this);
        move(a, a.umod(this.m)._forceRed(this));
        return a;
      };
      Red.prototype.neg = function neg(a) {
        if (a.isZero()) {
          return a.clone();
        }
        return this.m.sub(a)._forceRed(this);
      };
      Red.prototype.add = function add5(a, b) {
        this._verify2(a, b);
        var res = a.add(b);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.iadd = function iadd(a, b) {
        this._verify2(a, b);
        var res = a.iadd(b);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res;
      };
      Red.prototype.sub = function sub(a, b) {
        this._verify2(a, b);
        var res = a.sub(b);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.isub = function isub(a, b) {
        this._verify2(a, b);
        var res = a.isub(b);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res;
      };
      Red.prototype.shl = function shl(a, num2) {
        this._verify1(a);
        return this.imod(a.ushln(num2));
      };
      Red.prototype.imul = function imul(a, b) {
        this._verify2(a, b);
        return this.imod(a.imul(b));
      };
      Red.prototype.mul = function mul(a, b) {
        this._verify2(a, b);
        return this.imod(a.mul(b));
      };
      Red.prototype.isqr = function isqr(a) {
        return this.imul(a, a.clone());
      };
      Red.prototype.sqr = function sqr(a) {
        return this.mul(a, a);
      };
      Red.prototype.sqrt = function sqrt(a) {
        if (a.isZero()) return a.clone();
        var mod32 = this.m.andln(3);
        assert5(mod32 % 2 === 1);
        if (mod32 === 3) {
          var pow3 = this.m.add(new BN3(1)).iushrn(2);
          return this.pow(a, pow3);
        }
        var q = this.m.subn(1);
        var s = 0;
        while (!q.isZero() && q.andln(1) === 0) {
          s++;
          q.iushrn(1);
        }
        assert5(!q.isZero());
        var one = new BN3(1).toRed(this);
        var nOne = one.redNeg();
        var lpow = this.m.subn(1).iushrn(1);
        var z2 = this.m.bitLength();
        z2 = new BN3(2 * z2 * z2).toRed(this);
        while (this.pow(z2, lpow).cmp(nOne) !== 0) {
          z2.redIAdd(nOne);
        }
        var c = this.pow(z2, q);
        var r = this.pow(a, q.addn(1).iushrn(1));
        var t = this.pow(a, q);
        var m = s;
        while (t.cmp(one) !== 0) {
          var tmp = t;
          for (var i = 0; tmp.cmp(one) !== 0; i++) {
            tmp = tmp.redSqr();
          }
          assert5(i < m);
          var b = this.pow(c, new BN3(1).iushln(m - i - 1));
          r = r.redMul(b);
          c = b.redSqr();
          t = t.redMul(c);
          m = i;
        }
        return r;
      };
      Red.prototype.invm = function invm(a) {
        var inv = a._invmp(this.m);
        if (inv.negative !== 0) {
          inv.negative = 0;
          return this.imod(inv).redNeg();
        } else {
          return this.imod(inv);
        }
      };
      Red.prototype.pow = function pow3(a, num2) {
        if (num2.isZero()) return new BN3(1).toRed(this);
        if (num2.cmpn(1) === 0) return a.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN3(1).toRed(this);
        wnd[1] = a;
        for (var i = 2; i < wnd.length; i++) {
          wnd[i] = this.mul(wnd[i - 1], a);
        }
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num2.bitLength() % 26;
        if (start === 0) {
          start = 26;
        }
        for (i = num2.length - 1; i >= 0; i--) {
          var word = num2.words[i];
          for (var j = start - 1; j >= 0; j--) {
            var bit = word >> j & 1;
            if (res !== wnd[0]) {
              res = this.sqr(res);
            }
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
          }
          start = 26;
        }
        return res;
      };
      Red.prototype.convertTo = function convertTo(num2) {
        var r = num2.umod(this.m);
        return r === num2 ? r.clone() : r;
      };
      Red.prototype.convertFrom = function convertFrom(num2) {
        var res = num2.clone();
        res.red = null;
        return res;
      };
      BN3.mont = function mont(num2) {
        return new Mont(num2);
      };
      function Mont(m) {
        Red.call(this, m);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) {
          this.shift += 26 - this.shift % 26;
        }
        this.r = new BN3(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
      }
      inherits(Mont, Red);
      Mont.prototype.convertTo = function convertTo(num2) {
        return this.imod(num2.ushln(this.shift));
      };
      Mont.prototype.convertFrom = function convertFrom(num2) {
        var r = this.imod(num2.mul(this.rinv));
        r.red = null;
        return r;
      };
      Mont.prototype.imul = function imul(a, b) {
        if (a.isZero() || b.isZero()) {
          a.words[0] = 0;
          a.length = 1;
          return a;
        }
        var t = a.imul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.mul = function mul(a, b) {
        if (a.isZero() || b.isZero()) return new BN3(0)._forceRed(this);
        var t = a.mul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.invm = function invm(a) {
        var res = this.imod(a._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(typeof module2 === "undefined" || module2, exports2);
  }
});

// node_modules/@solana/web3.js/node_modules/base-x/src/index.js
var require_src = __commonJS({
  "node_modules/@solana/web3.js/node_modules/base-x/src/index.js"(exports2, module2) {
    "use strict";
    var _Buffer = require_safe_buffer().Buffer;
    function base3(ALPHABET2) {
      if (ALPHABET2.length >= 255) {
        throw new TypeError("Alphabet too long");
      }
      var BASE_MAP = new Uint8Array(256);
      for (var j = 0; j < BASE_MAP.length; j++) {
        BASE_MAP[j] = 255;
      }
      for (var i = 0; i < ALPHABET2.length; i++) {
        var x = ALPHABET2.charAt(i);
        var xc = x.charCodeAt(0);
        if (BASE_MAP[xc] !== 255) {
          throw new TypeError(x + " is ambiguous");
        }
        BASE_MAP[xc] = i;
      }
      var BASE2 = ALPHABET2.length;
      var LEADER = ALPHABET2.charAt(0);
      var FACTOR = Math.log(BASE2) / Math.log(256);
      var iFACTOR = Math.log(256) / Math.log(BASE2);
      function encode4(source) {
        if (Array.isArray(source) || source instanceof Uint8Array) {
          source = _Buffer.from(source);
        }
        if (!_Buffer.isBuffer(source)) {
          throw new TypeError("Expected Buffer");
        }
        if (source.length === 0) {
          return "";
        }
        var zeroes = 0;
        var length2 = 0;
        var pbegin = 0;
        var pend = source.length;
        while (pbegin !== pend && source[pbegin] === 0) {
          pbegin++;
          zeroes++;
        }
        var size4 = (pend - pbegin) * iFACTOR + 1 >>> 0;
        var b58 = new Uint8Array(size4);
        while (pbegin !== pend) {
          var carry = source[pbegin];
          var i2 = 0;
          for (var it1 = size4 - 1; (carry !== 0 || i2 < length2) && it1 !== -1; it1--, i2++) {
            carry += 256 * b58[it1] >>> 0;
            b58[it1] = carry % BASE2 >>> 0;
            carry = carry / BASE2 >>> 0;
          }
          if (carry !== 0) {
            throw new Error("Non-zero carry");
          }
          length2 = i2;
          pbegin++;
        }
        var it2 = size4 - length2;
        while (it2 !== size4 && b58[it2] === 0) {
          it2++;
        }
        var str2 = LEADER.repeat(zeroes);
        for (; it2 < size4; ++it2) {
          str2 += ALPHABET2.charAt(b58[it2]);
        }
        return str2;
      }
      function decodeUnsafe(source) {
        if (typeof source !== "string") {
          throw new TypeError("Expected String");
        }
        if (source.length === 0) {
          return _Buffer.alloc(0);
        }
        var psz = 0;
        var zeroes = 0;
        var length2 = 0;
        while (source[psz] === LEADER) {
          zeroes++;
          psz++;
        }
        var size4 = (source.length - psz) * FACTOR + 1 >>> 0;
        var b256 = new Uint8Array(size4);
        while (psz < source.length) {
          var charCode = source.charCodeAt(psz);
          if (charCode > 255) {
            return;
          }
          var carry = BASE_MAP[charCode];
          if (carry === 255) {
            return;
          }
          var i2 = 0;
          for (var it3 = size4 - 1; (carry !== 0 || i2 < length2) && it3 !== -1; it3--, i2++) {
            carry += BASE2 * b256[it3] >>> 0;
            b256[it3] = carry % 256 >>> 0;
            carry = carry / 256 >>> 0;
          }
          if (carry !== 0) {
            throw new Error("Non-zero carry");
          }
          length2 = i2;
          psz++;
        }
        var it4 = size4 - length2;
        while (it4 !== size4 && b256[it4] === 0) {
          it4++;
        }
        var vch = _Buffer.allocUnsafe(zeroes + (size4 - it4));
        vch.fill(0, 0, zeroes);
        var j2 = zeroes;
        while (it4 !== size4) {
          vch[j2++] = b256[it4++];
        }
        return vch;
      }
      function decode4(string3) {
        var buffer3 = decodeUnsafe(string3);
        if (buffer3) {
          return buffer3;
        }
        throw new Error("Non-base" + BASE2 + " character");
      }
      return {
        encode: encode4,
        decodeUnsafe,
        decode: decode4
      };
    }
    module2.exports = base3;
  }
});

// node_modules/@solana/web3.js/node_modules/bs58/index.js
var require_bs58 = __commonJS({
  "node_modules/@solana/web3.js/node_modules/bs58/index.js"(exports2, module2) {
    var basex = require_src();
    var ALPHABET2 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
    module2.exports = basex(ALPHABET2);
  }
});

// node_modules/@solana/web3.js/node_modules/@noble/hashes/esm/crypto.js
var crypto3;
var init_crypto2 = __esm({
  "node_modules/@solana/web3.js/node_modules/@noble/hashes/esm/crypto.js"() {
    crypto3 = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
  }
});

// node_modules/@solana/web3.js/node_modules/@noble/hashes/esm/utils.js
function isBytes3(a) {
  return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
}
function anumber2(n) {
  if (!Number.isSafeInteger(n) || n < 0)
    throw new Error("positive integer expected, got " + n);
}
function abytes2(b, ...lengths) {
  if (!isBytes3(b))
    throw new Error("Uint8Array expected");
  if (lengths.length > 0 && !lengths.includes(b.length))
    throw new Error("Uint8Array expected of length " + lengths + ", got length=" + b.length);
}
function aexists2(instance2, checkFinished = true) {
  if (instance2.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance2.finished)
    throw new Error("Hash#digest() has already been called");
}
function aoutput2(out, instance2) {
  abytes2(out);
  const min = instance2.outputLen;
  if (out.length < min) {
    throw new Error("digestInto() expects output buffer of length at least " + min);
  }
}
function u32(arr) {
  return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
}
function clean2(...arrays) {
  for (let i = 0; i < arrays.length; i++) {
    arrays[i].fill(0);
  }
}
function createView3(arr) {
  return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
}
function rotr3(word, shift) {
  return word << 32 - shift | word >>> shift;
}
function byteSwap(word) {
  return word << 24 & 4278190080 | word << 8 & 16711680 | word >>> 8 & 65280 | word >>> 24 & 255;
}
function byteSwap32(arr) {
  for (let i = 0; i < arr.length; i++) {
    arr[i] = byteSwap(arr[i]);
  }
  return arr;
}
function utf8ToBytes2(str2) {
  if (typeof str2 !== "string")
    throw new Error("string expected");
  return new Uint8Array(new TextEncoder().encode(str2));
}
function toBytes4(data) {
  if (typeof data === "string")
    data = utf8ToBytes2(data);
  abytes2(data);
  return data;
}
function createHasher3(hashCons) {
  const hashC = (msg) => hashCons().update(toBytes4(msg)).digest();
  const tmp = hashCons();
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = () => hashCons();
  return hashC;
}
function createXOFer(hashCons) {
  const hashC = (msg, opts) => hashCons(opts).update(toBytes4(msg)).digest();
  const tmp = hashCons({});
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = (opts) => hashCons(opts);
  return hashC;
}
var isLE2, swap32IfBE, hasHexBuiltin2, hexes2, Hash3;
var init_utils3 = __esm({
  "node_modules/@solana/web3.js/node_modules/@noble/hashes/esm/utils.js"() {
    init_crypto2();
    isLE2 = (() => new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68)();
    swap32IfBE = isLE2 ? (u) => u : byteSwap32;
    hasHexBuiltin2 = (() => (
      // @ts-ignore
      typeof Uint8Array.from([]).toHex === "function" && typeof Uint8Array.fromHex === "function"
    ))();
    hexes2 = Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
    Hash3 = class {
    };
  }
});

// node_modules/@solana/web3.js/node_modules/@noble/hashes/esm/_md.js
function setBigUint643(view, byteOffset, value, isLE6) {
  if (typeof view.setBigUint64 === "function")
    return view.setBigUint64(byteOffset, value, isLE6);
  const _32n6 = BigInt(32);
  const _u32_max = BigInt(4294967295);
  const wh = Number(value >> _32n6 & _u32_max);
  const wl = Number(value & _u32_max);
  const h = isLE6 ? 4 : 0;
  const l = isLE6 ? 0 : 4;
  view.setUint32(byteOffset + h, wh, isLE6);
  view.setUint32(byteOffset + l, wl, isLE6);
}
function Chi3(a, b, c) {
  return a & b ^ ~a & c;
}
function Maj3(a, b, c) {
  return a & b ^ a & c ^ b & c;
}
var HashMD3, SHA256_IV3, SHA224_IV2, SHA384_IV2, SHA512_IV2;
var init_md2 = __esm({
  "node_modules/@solana/web3.js/node_modules/@noble/hashes/esm/_md.js"() {
    init_utils3();
    HashMD3 = class extends Hash3 {
      constructor(blockLen, outputLen, padOffset, isLE6) {
        super();
        this.finished = false;
        this.length = 0;
        this.pos = 0;
        this.destroyed = false;
        this.blockLen = blockLen;
        this.outputLen = outputLen;
        this.padOffset = padOffset;
        this.isLE = isLE6;
        this.buffer = new Uint8Array(blockLen);
        this.view = createView3(this.buffer);
      }
      update(data) {
        aexists2(this);
        data = toBytes4(data);
        abytes2(data);
        const { view, buffer: buffer3, blockLen } = this;
        const len = data.length;
        for (let pos = 0; pos < len; ) {
          const take = Math.min(blockLen - this.pos, len - pos);
          if (take === blockLen) {
            const dataView = createView3(data);
            for (; blockLen <= len - pos; pos += blockLen)
              this.process(dataView, pos);
            continue;
          }
          buffer3.set(data.subarray(pos, pos + take), this.pos);
          this.pos += take;
          pos += take;
          if (this.pos === blockLen) {
            this.process(view, 0);
            this.pos = 0;
          }
        }
        this.length += data.length;
        this.roundClean();
        return this;
      }
      digestInto(out) {
        aexists2(this);
        aoutput2(out, this);
        this.finished = true;
        const { buffer: buffer3, view, blockLen, isLE: isLE6 } = this;
        let { pos } = this;
        buffer3[pos++] = 128;
        clean2(this.buffer.subarray(pos));
        if (this.padOffset > blockLen - pos) {
          this.process(view, 0);
          pos = 0;
        }
        for (let i = pos; i < blockLen; i++)
          buffer3[i] = 0;
        setBigUint643(view, blockLen - 8, BigInt(this.length * 8), isLE6);
        this.process(view, 0);
        const oview = createView3(out);
        const len = this.outputLen;
        if (len % 4)
          throw new Error("_sha2: outputLen should be aligned to 32bit");
        const outLen = len / 4;
        const state = this.get();
        if (outLen > state.length)
          throw new Error("_sha2: outputLen bigger than state");
        for (let i = 0; i < outLen; i++)
          oview.setUint32(4 * i, state[i], isLE6);
      }
      digest() {
        const { buffer: buffer3, outputLen } = this;
        this.digestInto(buffer3);
        const res = buffer3.slice(0, outputLen);
        this.destroy();
        return res;
      }
      _cloneInto(to) {
        to || (to = new this.constructor());
        to.set(...this.get());
        const { blockLen, buffer: buffer3, length: length2, finished: finished2, destroyed, pos } = this;
        to.destroyed = destroyed;
        to.finished = finished2;
        to.length = length2;
        to.pos = pos;
        if (length2 % blockLen)
          to.buffer.set(buffer3);
        return to;
      }
      clone() {
        return this._cloneInto();
      }
    };
    SHA256_IV3 = Uint32Array.from([
      1779033703,
      3144134277,
      1013904242,
      2773480762,
      1359893119,
      2600822924,
      528734635,
      1541459225
    ]);
    SHA224_IV2 = Uint32Array.from([
      3238371032,
      914150663,
      812702999,
      4144912697,
      4290775857,
      1750603025,
      1694076839,
      3204075428
    ]);
    SHA384_IV2 = Uint32Array.from([
      3418070365,
      3238371032,
      1654270250,
      914150663,
      2438529370,
      812702999,
      355462360,
      4144912697,
      1731405415,
      4290775857,
      2394180231,
      1750603025,
      3675008525,
      1694076839,
      1203062813,
      3204075428
    ]);
    SHA512_IV2 = Uint32Array.from([
      1779033703,
      4089235720,
      3144134277,
      2227873595,
      1013904242,
      4271175723,
      2773480762,
      1595750129,
      1359893119,
      2917565137,
      2600822924,
      725511199,
      528734635,
      4215389547,
      1541459225,
      327033209
    ]);
  }
});

// node_modules/@solana/web3.js/node_modules/@noble/hashes/esm/_u64.js
function fromBig2(n, le = false) {
  if (le)
    return { h: Number(n & U32_MASK642), l: Number(n >> _32n2 & U32_MASK642) };
  return { h: Number(n >> _32n2 & U32_MASK642) | 0, l: Number(n & U32_MASK642) | 0 };
}
function split2(lst, le = false) {
  const len = lst.length;
  let Ah = new Uint32Array(len);
  let Al = new Uint32Array(len);
  for (let i = 0; i < len; i++) {
    const { h, l } = fromBig2(lst[i], le);
    [Ah[i], Al[i]] = [h, l];
  }
  return [Ah, Al];
}
function add2(Ah, Al, Bh, Bl) {
  const l = (Al >>> 0) + (Bl >>> 0);
  return { h: Ah + Bh + (l / 2 ** 32 | 0) | 0, l: l | 0 };
}
var U32_MASK642, _32n2, shrSH2, shrSL2, rotrSH2, rotrSL2, rotrBH2, rotrBL2, rotlSH, rotlSL, rotlBH, rotlBL, add3L2, add3H2, add4L2, add4H2, add5L2, add5H2;
var init_u642 = __esm({
  "node_modules/@solana/web3.js/node_modules/@noble/hashes/esm/_u64.js"() {
    U32_MASK642 = BigInt(2 ** 32 - 1);
    _32n2 = BigInt(32);
    shrSH2 = (h, _l, s) => h >>> s;
    shrSL2 = (h, l, s) => h << 32 - s | l >>> s;
    rotrSH2 = (h, l, s) => h >>> s | l << 32 - s;
    rotrSL2 = (h, l, s) => h << 32 - s | l >>> s;
    rotrBH2 = (h, l, s) => h << 64 - s | l >>> s - 32;
    rotrBL2 = (h, l, s) => h >>> s - 32 | l << 64 - s;
    rotlSH = (h, l, s) => h << s | l >>> 32 - s;
    rotlSL = (h, l, s) => l << s | h >>> 32 - s;
    rotlBH = (h, l, s) => l << s - 32 | h >>> 64 - s;
    rotlBL = (h, l, s) => h << s - 32 | l >>> 64 - s;
    add3L2 = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
    add3H2 = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
    add4L2 = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
    add4H2 = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
    add5L2 = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
    add5H2 = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
  }
});

// node_modules/@solana/web3.js/node_modules/@noble/hashes/esm/sha2.js
var SHA256_K3, SHA256_W3, SHA2563, SHA2243, K5122, SHA512_Kh2, SHA512_Kl2, SHA512_W_H2, SHA512_W_L2, SHA5122, SHA3842, T224_IV2, T256_IV2, SHA512_2242, SHA512_2562, sha2564, sha2243, sha5122, sha3842, sha512_2562, sha512_2242;
var init_sha22 = __esm({
  "node_modules/@solana/web3.js/node_modules/@noble/hashes/esm/sha2.js"() {
    init_md2();
    init_u642();
    init_utils3();
    SHA256_K3 = Uint32Array.from([
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ]);
    SHA256_W3 = new Uint32Array(64);
    SHA2563 = class extends HashMD3 {
      constructor(outputLen = 32) {
        super(64, outputLen, 8, false);
        this.A = SHA256_IV3[0] | 0;
        this.B = SHA256_IV3[1] | 0;
        this.C = SHA256_IV3[2] | 0;
        this.D = SHA256_IV3[3] | 0;
        this.E = SHA256_IV3[4] | 0;
        this.F = SHA256_IV3[5] | 0;
        this.G = SHA256_IV3[6] | 0;
        this.H = SHA256_IV3[7] | 0;
      }
      get() {
        const { A, B, C, D, E, F, G, H } = this;
        return [A, B, C, D, E, F, G, H];
      }
      // prettier-ignore
      set(A, B, C, D, E, F, G, H) {
        this.A = A | 0;
        this.B = B | 0;
        this.C = C | 0;
        this.D = D | 0;
        this.E = E | 0;
        this.F = F | 0;
        this.G = G | 0;
        this.H = H | 0;
      }
      process(view, offset3) {
        for (let i = 0; i < 16; i++, offset3 += 4)
          SHA256_W3[i] = view.getUint32(offset3, false);
        for (let i = 16; i < 64; i++) {
          const W15 = SHA256_W3[i - 15];
          const W2 = SHA256_W3[i - 2];
          const s0 = rotr3(W15, 7) ^ rotr3(W15, 18) ^ W15 >>> 3;
          const s1 = rotr3(W2, 17) ^ rotr3(W2, 19) ^ W2 >>> 10;
          SHA256_W3[i] = s1 + SHA256_W3[i - 7] + s0 + SHA256_W3[i - 16] | 0;
        }
        let { A, B, C, D, E, F, G, H } = this;
        for (let i = 0; i < 64; i++) {
          const sigma1 = rotr3(E, 6) ^ rotr3(E, 11) ^ rotr3(E, 25);
          const T1 = H + sigma1 + Chi3(E, F, G) + SHA256_K3[i] + SHA256_W3[i] | 0;
          const sigma0 = rotr3(A, 2) ^ rotr3(A, 13) ^ rotr3(A, 22);
          const T2 = sigma0 + Maj3(A, B, C) | 0;
          H = G;
          G = F;
          F = E;
          E = D + T1 | 0;
          D = C;
          C = B;
          B = A;
          A = T1 + T2 | 0;
        }
        A = A + this.A | 0;
        B = B + this.B | 0;
        C = C + this.C | 0;
        D = D + this.D | 0;
        E = E + this.E | 0;
        F = F + this.F | 0;
        G = G + this.G | 0;
        H = H + this.H | 0;
        this.set(A, B, C, D, E, F, G, H);
      }
      roundClean() {
        clean2(SHA256_W3);
      }
      destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0);
        clean2(this.buffer);
      }
    };
    SHA2243 = class extends SHA2563 {
      constructor() {
        super(28);
        this.A = SHA224_IV2[0] | 0;
        this.B = SHA224_IV2[1] | 0;
        this.C = SHA224_IV2[2] | 0;
        this.D = SHA224_IV2[3] | 0;
        this.E = SHA224_IV2[4] | 0;
        this.F = SHA224_IV2[5] | 0;
        this.G = SHA224_IV2[6] | 0;
        this.H = SHA224_IV2[7] | 0;
      }
    };
    K5122 = (() => split2([
      "0x428a2f98d728ae22",
      "0x7137449123ef65cd",
      "0xb5c0fbcfec4d3b2f",
      "0xe9b5dba58189dbbc",
      "0x3956c25bf348b538",
      "0x59f111f1b605d019",
      "0x923f82a4af194f9b",
      "0xab1c5ed5da6d8118",
      "0xd807aa98a3030242",
      "0x12835b0145706fbe",
      "0x243185be4ee4b28c",
      "0x550c7dc3d5ffb4e2",
      "0x72be5d74f27b896f",
      "0x80deb1fe3b1696b1",
      "0x9bdc06a725c71235",
      "0xc19bf174cf692694",
      "0xe49b69c19ef14ad2",
      "0xefbe4786384f25e3",
      "0x0fc19dc68b8cd5b5",
      "0x240ca1cc77ac9c65",
      "0x2de92c6f592b0275",
      "0x4a7484aa6ea6e483",
      "0x5cb0a9dcbd41fbd4",
      "0x76f988da831153b5",
      "0x983e5152ee66dfab",
      "0xa831c66d2db43210",
      "0xb00327c898fb213f",
      "0xbf597fc7beef0ee4",
      "0xc6e00bf33da88fc2",
      "0xd5a79147930aa725",
      "0x06ca6351e003826f",
      "0x142929670a0e6e70",
      "0x27b70a8546d22ffc",
      "0x2e1b21385c26c926",
      "0x4d2c6dfc5ac42aed",
      "0x53380d139d95b3df",
      "0x650a73548baf63de",
      "0x766a0abb3c77b2a8",
      "0x81c2c92e47edaee6",
      "0x92722c851482353b",
      "0xa2bfe8a14cf10364",
      "0xa81a664bbc423001",
      "0xc24b8b70d0f89791",
      "0xc76c51a30654be30",
      "0xd192e819d6ef5218",
      "0xd69906245565a910",
      "0xf40e35855771202a",
      "0x106aa07032bbd1b8",
      "0x19a4c116b8d2d0c8",
      "0x1e376c085141ab53",
      "0x2748774cdf8eeb99",
      "0x34b0bcb5e19b48a8",
      "0x391c0cb3c5c95a63",
      "0x4ed8aa4ae3418acb",
      "0x5b9cca4f7763e373",
      "0x682e6ff3d6b2b8a3",
      "0x748f82ee5defb2fc",
      "0x78a5636f43172f60",
      "0x84c87814a1f0ab72",
      "0x8cc702081a6439ec",
      "0x90befffa23631e28",
      "0xa4506cebde82bde9",
      "0xbef9a3f7b2c67915",
      "0xc67178f2e372532b",
      "0xca273eceea26619c",
      "0xd186b8c721c0c207",
      "0xeada7dd6cde0eb1e",
      "0xf57d4f7fee6ed178",
      "0x06f067aa72176fba",
      "0x0a637dc5a2c898a6",
      "0x113f9804bef90dae",
      "0x1b710b35131c471b",
      "0x28db77f523047d84",
      "0x32caab7b40c72493",
      "0x3c9ebe0a15c9bebc",
      "0x431d67c49c100d4c",
      "0x4cc5d4becb3e42b6",
      "0x597f299cfc657e2a",
      "0x5fcb6fab3ad6faec",
      "0x6c44198c4a475817"
    ].map((n) => BigInt(n))))();
    SHA512_Kh2 = (() => K5122[0])();
    SHA512_Kl2 = (() => K5122[1])();
    SHA512_W_H2 = new Uint32Array(80);
    SHA512_W_L2 = new Uint32Array(80);
    SHA5122 = class extends HashMD3 {
      constructor(outputLen = 64) {
        super(128, outputLen, 16, false);
        this.Ah = SHA512_IV2[0] | 0;
        this.Al = SHA512_IV2[1] | 0;
        this.Bh = SHA512_IV2[2] | 0;
        this.Bl = SHA512_IV2[3] | 0;
        this.Ch = SHA512_IV2[4] | 0;
        this.Cl = SHA512_IV2[5] | 0;
        this.Dh = SHA512_IV2[6] | 0;
        this.Dl = SHA512_IV2[7] | 0;
        this.Eh = SHA512_IV2[8] | 0;
        this.El = SHA512_IV2[9] | 0;
        this.Fh = SHA512_IV2[10] | 0;
        this.Fl = SHA512_IV2[11] | 0;
        this.Gh = SHA512_IV2[12] | 0;
        this.Gl = SHA512_IV2[13] | 0;
        this.Hh = SHA512_IV2[14] | 0;
        this.Hl = SHA512_IV2[15] | 0;
      }
      // prettier-ignore
      get() {
        const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
        return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
      }
      // prettier-ignore
      set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
        this.Ah = Ah | 0;
        this.Al = Al | 0;
        this.Bh = Bh | 0;
        this.Bl = Bl | 0;
        this.Ch = Ch | 0;
        this.Cl = Cl | 0;
        this.Dh = Dh | 0;
        this.Dl = Dl | 0;
        this.Eh = Eh | 0;
        this.El = El | 0;
        this.Fh = Fh | 0;
        this.Fl = Fl | 0;
        this.Gh = Gh | 0;
        this.Gl = Gl | 0;
        this.Hh = Hh | 0;
        this.Hl = Hl | 0;
      }
      process(view, offset3) {
        for (let i = 0; i < 16; i++, offset3 += 4) {
          SHA512_W_H2[i] = view.getUint32(offset3);
          SHA512_W_L2[i] = view.getUint32(offset3 += 4);
        }
        for (let i = 16; i < 80; i++) {
          const W15h = SHA512_W_H2[i - 15] | 0;
          const W15l = SHA512_W_L2[i - 15] | 0;
          const s0h = rotrSH2(W15h, W15l, 1) ^ rotrSH2(W15h, W15l, 8) ^ shrSH2(W15h, W15l, 7);
          const s0l = rotrSL2(W15h, W15l, 1) ^ rotrSL2(W15h, W15l, 8) ^ shrSL2(W15h, W15l, 7);
          const W2h = SHA512_W_H2[i - 2] | 0;
          const W2l = SHA512_W_L2[i - 2] | 0;
          const s1h = rotrSH2(W2h, W2l, 19) ^ rotrBH2(W2h, W2l, 61) ^ shrSH2(W2h, W2l, 6);
          const s1l = rotrSL2(W2h, W2l, 19) ^ rotrBL2(W2h, W2l, 61) ^ shrSL2(W2h, W2l, 6);
          const SUMl = add4L2(s0l, s1l, SHA512_W_L2[i - 7], SHA512_W_L2[i - 16]);
          const SUMh = add4H2(SUMl, s0h, s1h, SHA512_W_H2[i - 7], SHA512_W_H2[i - 16]);
          SHA512_W_H2[i] = SUMh | 0;
          SHA512_W_L2[i] = SUMl | 0;
        }
        let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
        for (let i = 0; i < 80; i++) {
          const sigma1h = rotrSH2(Eh, El, 14) ^ rotrSH2(Eh, El, 18) ^ rotrBH2(Eh, El, 41);
          const sigma1l = rotrSL2(Eh, El, 14) ^ rotrSL2(Eh, El, 18) ^ rotrBL2(Eh, El, 41);
          const CHIh = Eh & Fh ^ ~Eh & Gh;
          const CHIl = El & Fl ^ ~El & Gl;
          const T1ll = add5L2(Hl, sigma1l, CHIl, SHA512_Kl2[i], SHA512_W_L2[i]);
          const T1h = add5H2(T1ll, Hh, sigma1h, CHIh, SHA512_Kh2[i], SHA512_W_H2[i]);
          const T1l = T1ll | 0;
          const sigma0h = rotrSH2(Ah, Al, 28) ^ rotrBH2(Ah, Al, 34) ^ rotrBH2(Ah, Al, 39);
          const sigma0l = rotrSL2(Ah, Al, 28) ^ rotrBL2(Ah, Al, 34) ^ rotrBL2(Ah, Al, 39);
          const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
          const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;
          Hh = Gh | 0;
          Hl = Gl | 0;
          Gh = Fh | 0;
          Gl = Fl | 0;
          Fh = Eh | 0;
          Fl = El | 0;
          ({ h: Eh, l: El } = add2(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
          Dh = Ch | 0;
          Dl = Cl | 0;
          Ch = Bh | 0;
          Cl = Bl | 0;
          Bh = Ah | 0;
          Bl = Al | 0;
          const All = add3L2(T1l, sigma0l, MAJl);
          Ah = add3H2(All, T1h, sigma0h, MAJh);
          Al = All | 0;
        }
        ({ h: Ah, l: Al } = add2(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
        ({ h: Bh, l: Bl } = add2(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
        ({ h: Ch, l: Cl } = add2(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
        ({ h: Dh, l: Dl } = add2(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
        ({ h: Eh, l: El } = add2(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
        ({ h: Fh, l: Fl } = add2(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
        ({ h: Gh, l: Gl } = add2(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
        ({ h: Hh, l: Hl } = add2(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
        this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
      }
      roundClean() {
        clean2(SHA512_W_H2, SHA512_W_L2);
      }
      destroy() {
        clean2(this.buffer);
        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
      }
    };
    SHA3842 = class extends SHA5122 {
      constructor() {
        super(48);
        this.Ah = SHA384_IV2[0] | 0;
        this.Al = SHA384_IV2[1] | 0;
        this.Bh = SHA384_IV2[2] | 0;
        this.Bl = SHA384_IV2[3] | 0;
        this.Ch = SHA384_IV2[4] | 0;
        this.Cl = SHA384_IV2[5] | 0;
        this.Dh = SHA384_IV2[6] | 0;
        this.Dl = SHA384_IV2[7] | 0;
        this.Eh = SHA384_IV2[8] | 0;
        this.El = SHA384_IV2[9] | 0;
        this.Fh = SHA384_IV2[10] | 0;
        this.Fl = SHA384_IV2[11] | 0;
        this.Gh = SHA384_IV2[12] | 0;
        this.Gl = SHA384_IV2[13] | 0;
        this.Hh = SHA384_IV2[14] | 0;
        this.Hl = SHA384_IV2[15] | 0;
      }
    };
    T224_IV2 = Uint32Array.from([
      2352822216,
      424955298,
      1944164710,
      2312950998,
      502970286,
      855612546,
      1738396948,
      1479516111,
      258812777,
      2077511080,
      2011393907,
      79989058,
      1067287976,
      1780299464,
      286451373,
      2446758561
    ]);
    T256_IV2 = Uint32Array.from([
      573645204,
      4230739756,
      2673172387,
      3360449730,
      596883563,
      1867755857,
      2520282905,
      1497426621,
      2519219938,
      2827943907,
      3193839141,
      1401305490,
      721525244,
      746961066,
      246885852,
      2177182882
    ]);
    SHA512_2242 = class extends SHA5122 {
      constructor() {
        super(28);
        this.Ah = T224_IV2[0] | 0;
        this.Al = T224_IV2[1] | 0;
        this.Bh = T224_IV2[2] | 0;
        this.Bl = T224_IV2[3] | 0;
        this.Ch = T224_IV2[4] | 0;
        this.Cl = T224_IV2[5] | 0;
        this.Dh = T224_IV2[6] | 0;
        this.Dl = T224_IV2[7] | 0;
        this.Eh = T224_IV2[8] | 0;
        this.El = T224_IV2[9] | 0;
        this.Fh = T224_IV2[10] | 0;
        this.Fl = T224_IV2[11] | 0;
        this.Gh = T224_IV2[12] | 0;
        this.Gl = T224_IV2[13] | 0;
        this.Hh = T224_IV2[14] | 0;
        this.Hl = T224_IV2[15] | 0;
      }
    };
    SHA512_2562 = class extends SHA5122 {
      constructor() {
        super(32);
        this.Ah = T256_IV2[0] | 0;
        this.Al = T256_IV2[1] | 0;
        this.Bh = T256_IV2[2] | 0;
        this.Bl = T256_IV2[3] | 0;
        this.Ch = T256_IV2[4] | 0;
        this.Cl = T256_IV2[5] | 0;
        this.Dh = T256_IV2[6] | 0;
        this.Dl = T256_IV2[7] | 0;
        this.Eh = T256_IV2[8] | 0;
        this.El = T256_IV2[9] | 0;
        this.Fh = T256_IV2[10] | 0;
        this.Fl = T256_IV2[11] | 0;
        this.Gh = T256_IV2[12] | 0;
        this.Gl = T256_IV2[13] | 0;
        this.Hh = T256_IV2[14] | 0;
        this.Hl = T256_IV2[15] | 0;
      }
    };
    sha2564 = createHasher3(() => new SHA2563());
    sha2243 = createHasher3(() => new SHA2243());
    sha5122 = createHasher3(() => new SHA5122());
    sha3842 = createHasher3(() => new SHA3842());
    sha512_2562 = createHasher3(() => new SHA512_2562());
    sha512_2242 = createHasher3(() => new SHA512_2242());
  }
});

// node_modules/@solana/web3.js/node_modules/@noble/hashes/esm/sha256.js
var sha2565;
var init_sha256 = __esm({
  "node_modules/@solana/web3.js/node_modules/@noble/hashes/esm/sha256.js"() {
    init_sha22();
    sha2565 = sha2564;
  }
});

// node_modules/text-encoding-utf-8/src/encoding.js
var encoding_exports = {};
__export(encoding_exports, {
  TextDecoder: () => TextDecoder2,
  TextEncoder: () => TextEncoder2
});
function inRange2(a, min, max) {
  return min <= a && a <= max;
}
function ToDictionary(o) {
  if (o === void 0) return {};
  if (o === Object(o)) return o;
  throw TypeError("Could not convert argument to dictionary");
}
function stringToCodePoints(string3) {
  var s = String(string3);
  var n = s.length;
  var i = 0;
  var u = [];
  while (i < n) {
    var c = s.charCodeAt(i);
    if (c < 55296 || c > 57343) {
      u.push(c);
    } else if (56320 <= c && c <= 57343) {
      u.push(65533);
    } else if (55296 <= c && c <= 56319) {
      if (i === n - 1) {
        u.push(65533);
      } else {
        var d = string3.charCodeAt(i + 1);
        if (56320 <= d && d <= 57343) {
          var a = c & 1023;
          var b = d & 1023;
          u.push(65536 + (a << 10) + b);
          i += 1;
        } else {
          u.push(65533);
        }
      }
    }
    i += 1;
  }
  return u;
}
function codePointsToString(code_points) {
  var s = "";
  for (var i = 0; i < code_points.length; ++i) {
    var cp = code_points[i];
    if (cp <= 65535) {
      s += String.fromCharCode(cp);
    } else {
      cp -= 65536;
      s += String.fromCharCode(
        (cp >> 10) + 55296,
        (cp & 1023) + 56320
      );
    }
  }
  return s;
}
function Stream(tokens) {
  this.tokens = [].slice.call(tokens);
}
function decoderError(fatal, opt_code_point) {
  if (fatal)
    throw TypeError("Decoder error");
  return opt_code_point || 65533;
}
function Decoder() {
}
function Encoder() {
}
function TextDecoder2(encoding, options) {
  if (!(this instanceof TextDecoder2)) {
    return new TextDecoder2(encoding, options);
  }
  encoding = encoding !== void 0 ? String(encoding).toLowerCase() : DEFAULT_ENCODING;
  if (encoding !== DEFAULT_ENCODING) {
    throw new Error("Encoding not supported. Only utf-8 is supported");
  }
  options = ToDictionary(options);
  this._streaming = false;
  this._BOMseen = false;
  this._decoder = null;
  this._fatal = Boolean(options["fatal"]);
  this._ignoreBOM = Boolean(options["ignoreBOM"]);
  Object.defineProperty(this, "encoding", { value: "utf-8" });
  Object.defineProperty(this, "fatal", { value: this._fatal });
  Object.defineProperty(this, "ignoreBOM", { value: this._ignoreBOM });
}
function TextEncoder2(encoding, options) {
  if (!(this instanceof TextEncoder2))
    return new TextEncoder2(encoding, options);
  encoding = encoding !== void 0 ? String(encoding).toLowerCase() : DEFAULT_ENCODING;
  if (encoding !== DEFAULT_ENCODING) {
    throw new Error("Encoding not supported. Only utf-8 is supported");
  }
  options = ToDictionary(options);
  this._streaming = false;
  this._encoder = null;
  this._options = { fatal: Boolean(options["fatal"]) };
  Object.defineProperty(this, "encoding", { value: "utf-8" });
}
function UTF8Decoder(options) {
  var fatal = options.fatal;
  var utf8_code_point = 0, utf8_bytes_seen = 0, utf8_bytes_needed = 0, utf8_lower_boundary = 128, utf8_upper_boundary = 191;
  this.handler = function(stream2, bite) {
    if (bite === end_of_stream && utf8_bytes_needed !== 0) {
      utf8_bytes_needed = 0;
      return decoderError(fatal);
    }
    if (bite === end_of_stream)
      return finished;
    if (utf8_bytes_needed === 0) {
      if (inRange2(bite, 0, 127)) {
        return bite;
      }
      if (inRange2(bite, 194, 223)) {
        utf8_bytes_needed = 1;
        utf8_code_point = bite - 192;
      } else if (inRange2(bite, 224, 239)) {
        if (bite === 224)
          utf8_lower_boundary = 160;
        if (bite === 237)
          utf8_upper_boundary = 159;
        utf8_bytes_needed = 2;
        utf8_code_point = bite - 224;
      } else if (inRange2(bite, 240, 244)) {
        if (bite === 240)
          utf8_lower_boundary = 144;
        if (bite === 244)
          utf8_upper_boundary = 143;
        utf8_bytes_needed = 3;
        utf8_code_point = bite - 240;
      } else {
        return decoderError(fatal);
      }
      utf8_code_point = utf8_code_point << 6 * utf8_bytes_needed;
      return null;
    }
    if (!inRange2(bite, utf8_lower_boundary, utf8_upper_boundary)) {
      utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0;
      utf8_lower_boundary = 128;
      utf8_upper_boundary = 191;
      stream2.prepend(bite);
      return decoderError(fatal);
    }
    utf8_lower_boundary = 128;
    utf8_upper_boundary = 191;
    utf8_bytes_seen += 1;
    utf8_code_point += bite - 128 << 6 * (utf8_bytes_needed - utf8_bytes_seen);
    if (utf8_bytes_seen !== utf8_bytes_needed)
      return null;
    var code_point = utf8_code_point;
    utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0;
    return code_point;
  };
}
function UTF8Encoder(options) {
  var fatal = options.fatal;
  this.handler = function(stream2, code_point) {
    if (code_point === end_of_stream)
      return finished;
    if (inRange2(code_point, 0, 127))
      return code_point;
    var count, offset3;
    if (inRange2(code_point, 128, 2047)) {
      count = 1;
      offset3 = 192;
    } else if (inRange2(code_point, 2048, 65535)) {
      count = 2;
      offset3 = 224;
    } else if (inRange2(code_point, 65536, 1114111)) {
      count = 3;
      offset3 = 240;
    }
    var bytes3 = [(code_point >> 6 * count) + offset3];
    while (count > 0) {
      var temp = code_point >> 6 * (count - 1);
      bytes3.push(128 | temp & 63);
      count -= 1;
    }
    return bytes3;
  };
}
var end_of_stream, finished, DEFAULT_ENCODING;
var init_encoding = __esm({
  "node_modules/text-encoding-utf-8/src/encoding.js"() {
    "use strict";
    end_of_stream = -1;
    Stream.prototype = {
      /**
       * @return {boolean} True if end-of-stream has been hit.
       */
      endOfStream: function() {
        return !this.tokens.length;
      },
      /**
       * When a token is read from a stream, the first token in the
       * stream must be returned and subsequently removed, and
       * end-of-stream must be returned otherwise.
       *
       * @return {number} Get the next token from the stream, or
       * end_of_stream.
       */
      read: function() {
        if (!this.tokens.length)
          return end_of_stream;
        return this.tokens.shift();
      },
      /**
       * When one or more tokens are prepended to a stream, those tokens
       * must be inserted, in given order, before the first token in the
       * stream.
       *
       * @param {(number|!Array.<number>)} token The token(s) to prepend to the stream.
       */
      prepend: function(token2) {
        if (Array.isArray(token2)) {
          var tokens = (
            /**@type {!Array.<number>}*/
            token2
          );
          while (tokens.length)
            this.tokens.unshift(tokens.pop());
        } else {
          this.tokens.unshift(token2);
        }
      },
      /**
       * When one or more tokens are pushed to a stream, those tokens
       * must be inserted, in given order, after the last token in the
       * stream.
       *
       * @param {(number|!Array.<number>)} token The tokens(s) to prepend to the stream.
       */
      push: function(token2) {
        if (Array.isArray(token2)) {
          var tokens = (
            /**@type {!Array.<number>}*/
            token2
          );
          while (tokens.length)
            this.tokens.push(tokens.shift());
        } else {
          this.tokens.push(token2);
        }
      }
    };
    finished = -1;
    Decoder.prototype = {
      /**
       * @param {Stream} stream The stream of bytes being decoded.
       * @param {number} bite The next byte read from the stream.
       * @return {?(number|!Array.<number>)} The next code point(s)
       *     decoded, or null if not enough data exists in the input
       *     stream to decode a complete code point, or |finished|.
       */
      handler: function(stream2, bite) {
      }
    };
    Encoder.prototype = {
      /**
       * @param {Stream} stream The stream of code points being encoded.
       * @param {number} code_point Next code point read from the stream.
       * @return {(number|!Array.<number>)} Byte(s) to emit, or |finished|.
       */
      handler: function(stream2, code_point) {
      }
    };
    DEFAULT_ENCODING = "utf-8";
    TextDecoder2.prototype = {
      /**
       * @param {ArrayBufferView=} input The buffer of bytes to decode.
       * @param {Object=} options
       * @return {string} The decoded string.
       */
      decode: function decode(input, options) {
        var bytes3;
        if (typeof input === "object" && input instanceof ArrayBuffer) {
          bytes3 = new Uint8Array(input);
        } else if (typeof input === "object" && "buffer" in input && input.buffer instanceof ArrayBuffer) {
          bytes3 = new Uint8Array(
            input.buffer,
            input.byteOffset,
            input.byteLength
          );
        } else {
          bytes3 = new Uint8Array(0);
        }
        options = ToDictionary(options);
        if (!this._streaming) {
          this._decoder = new UTF8Decoder({ fatal: this._fatal });
          this._BOMseen = false;
        }
        this._streaming = Boolean(options["stream"]);
        var input_stream = new Stream(bytes3);
        var code_points = [];
        var result;
        while (!input_stream.endOfStream()) {
          result = this._decoder.handler(input_stream, input_stream.read());
          if (result === finished)
            break;
          if (result === null)
            continue;
          if (Array.isArray(result))
            code_points.push.apply(
              code_points,
              /**@type {!Array.<number>}*/
              result
            );
          else
            code_points.push(result);
        }
        if (!this._streaming) {
          do {
            result = this._decoder.handler(input_stream, input_stream.read());
            if (result === finished)
              break;
            if (result === null)
              continue;
            if (Array.isArray(result))
              code_points.push.apply(
                code_points,
                /**@type {!Array.<number>}*/
                result
              );
            else
              code_points.push(result);
          } while (!input_stream.endOfStream());
          this._decoder = null;
        }
        if (code_points.length) {
          if (["utf-8"].indexOf(this.encoding) !== -1 && !this._ignoreBOM && !this._BOMseen) {
            if (code_points[0] === 65279) {
              this._BOMseen = true;
              code_points.shift();
            } else {
              this._BOMseen = true;
            }
          }
        }
        return codePointsToString(code_points);
      }
    };
    TextEncoder2.prototype = {
      /**
       * @param {string=} opt_string The string to encode.
       * @param {Object=} options
       * @return {Uint8Array} Encoded bytes, as a Uint8Array.
       */
      encode: function encode(opt_string, options) {
        opt_string = opt_string ? String(opt_string) : "";
        options = ToDictionary(options);
        if (!this._streaming)
          this._encoder = new UTF8Encoder(this._options);
        this._streaming = Boolean(options["stream"]);
        var bytes3 = [];
        var input_stream = new Stream(stringToCodePoints(opt_string));
        var result;
        while (!input_stream.endOfStream()) {
          result = this._encoder.handler(input_stream, input_stream.read());
          if (result === finished)
            break;
          if (Array.isArray(result))
            bytes3.push.apply(
              bytes3,
              /**@type {!Array.<number>}*/
              result
            );
          else
            bytes3.push(result);
        }
        if (!this._streaming) {
          while (true) {
            result = this._encoder.handler(input_stream, input_stream.read());
            if (result === finished)
              break;
            if (Array.isArray(result))
              bytes3.push.apply(
                bytes3,
                /**@type {!Array.<number>}*/
                result
              );
            else
              bytes3.push(result);
          }
          this._encoder = null;
        }
        return new Uint8Array(bytes3);
      }
    };
  }
});

// node_modules/@solana/web3.js/node_modules/borsh/lib/index.js
var require_lib5 = __commonJS({
  "node_modules/@solana/web3.js/node_modules/borsh/lib/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __importStar = exports2 && exports2.__importStar || function(mod4) {
      if (mod4 && mod4.__esModule) return mod4;
      var result = {};
      if (mod4 != null) {
        for (var k in mod4) if (k !== "default" && Object.hasOwnProperty.call(mod4, k)) __createBinding(result, mod4, k);
      }
      __setModuleDefault(result, mod4);
      return result;
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod4) {
      return mod4 && mod4.__esModule ? mod4 : { "default": mod4 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.deserializeUnchecked = exports2.deserialize = exports2.serialize = exports2.BinaryReader = exports2.BinaryWriter = exports2.BorshError = exports2.baseDecode = exports2.baseEncode = void 0;
    var bn_js_1 = __importDefault(require_bn());
    var bs58_1 = __importDefault(require_bs58());
    var encoding = __importStar((init_encoding(), __toCommonJS(encoding_exports)));
    var ResolvedTextDecoder = typeof TextDecoder !== "function" ? encoding.TextDecoder : TextDecoder;
    var textDecoder = new ResolvedTextDecoder("utf-8", { fatal: true });
    function baseEncode(value) {
      if (typeof value === "string") {
        value = Buffer.from(value, "utf8");
      }
      return bs58_1.default.encode(Buffer.from(value));
    }
    exports2.baseEncode = baseEncode;
    function baseDecode(value) {
      return Buffer.from(bs58_1.default.decode(value));
    }
    exports2.baseDecode = baseDecode;
    var INITIAL_LENGTH = 1024;
    var BorshError = class extends Error {
      constructor(message) {
        super(message);
        this.fieldPath = [];
        this.originalMessage = message;
      }
      addToFieldPath(fieldName) {
        this.fieldPath.splice(0, 0, fieldName);
        this.message = this.originalMessage + ": " + this.fieldPath.join(".");
      }
    };
    exports2.BorshError = BorshError;
    var BinaryWriter = class {
      constructor() {
        this.buf = Buffer.alloc(INITIAL_LENGTH);
        this.length = 0;
      }
      maybeResize() {
        if (this.buf.length < 16 + this.length) {
          this.buf = Buffer.concat([this.buf, Buffer.alloc(INITIAL_LENGTH)]);
        }
      }
      writeU8(value) {
        this.maybeResize();
        this.buf.writeUInt8(value, this.length);
        this.length += 1;
      }
      writeU16(value) {
        this.maybeResize();
        this.buf.writeUInt16LE(value, this.length);
        this.length += 2;
      }
      writeU32(value) {
        this.maybeResize();
        this.buf.writeUInt32LE(value, this.length);
        this.length += 4;
      }
      writeU64(value) {
        this.maybeResize();
        this.writeBuffer(Buffer.from(new bn_js_1.default(value).toArray("le", 8)));
      }
      writeU128(value) {
        this.maybeResize();
        this.writeBuffer(Buffer.from(new bn_js_1.default(value).toArray("le", 16)));
      }
      writeU256(value) {
        this.maybeResize();
        this.writeBuffer(Buffer.from(new bn_js_1.default(value).toArray("le", 32)));
      }
      writeU512(value) {
        this.maybeResize();
        this.writeBuffer(Buffer.from(new bn_js_1.default(value).toArray("le", 64)));
      }
      writeBuffer(buffer3) {
        this.buf = Buffer.concat([
          Buffer.from(this.buf.subarray(0, this.length)),
          buffer3,
          Buffer.alloc(INITIAL_LENGTH)
        ]);
        this.length += buffer3.length;
      }
      writeString(str2) {
        this.maybeResize();
        const b = Buffer.from(str2, "utf8");
        this.writeU32(b.length);
        this.writeBuffer(b);
      }
      writeFixedArray(array4) {
        this.writeBuffer(Buffer.from(array4));
      }
      writeArray(array4, fn) {
        this.maybeResize();
        this.writeU32(array4.length);
        for (const elem of array4) {
          this.maybeResize();
          fn(elem);
        }
      }
      toArray() {
        return this.buf.subarray(0, this.length);
      }
    };
    exports2.BinaryWriter = BinaryWriter;
    function handlingRangeError(target, propertyKey, propertyDescriptor) {
      const originalMethod = propertyDescriptor.value;
      propertyDescriptor.value = function(...args) {
        try {
          return originalMethod.apply(this, args);
        } catch (e) {
          if (e instanceof RangeError) {
            const code2 = e.code;
            if (["ERR_BUFFER_OUT_OF_BOUNDS", "ERR_OUT_OF_RANGE"].indexOf(code2) >= 0) {
              throw new BorshError("Reached the end of buffer when deserializing");
            }
          }
          throw e;
        }
      };
    }
    var BinaryReader = class {
      constructor(buf) {
        this.buf = buf;
        this.offset = 0;
      }
      readU8() {
        const value = this.buf.readUInt8(this.offset);
        this.offset += 1;
        return value;
      }
      readU16() {
        const value = this.buf.readUInt16LE(this.offset);
        this.offset += 2;
        return value;
      }
      readU32() {
        const value = this.buf.readUInt32LE(this.offset);
        this.offset += 4;
        return value;
      }
      readU64() {
        const buf = this.readBuffer(8);
        return new bn_js_1.default(buf, "le");
      }
      readU128() {
        const buf = this.readBuffer(16);
        return new bn_js_1.default(buf, "le");
      }
      readU256() {
        const buf = this.readBuffer(32);
        return new bn_js_1.default(buf, "le");
      }
      readU512() {
        const buf = this.readBuffer(64);
        return new bn_js_1.default(buf, "le");
      }
      readBuffer(len) {
        if (this.offset + len > this.buf.length) {
          throw new BorshError(`Expected buffer length ${len} isn't within bounds`);
        }
        const result = this.buf.slice(this.offset, this.offset + len);
        this.offset += len;
        return result;
      }
      readString() {
        const len = this.readU32();
        const buf = this.readBuffer(len);
        try {
          return textDecoder.decode(buf);
        } catch (e) {
          throw new BorshError(`Error decoding UTF-8 string: ${e}`);
        }
      }
      readFixedArray(len) {
        return new Uint8Array(this.readBuffer(len));
      }
      readArray(fn) {
        const len = this.readU32();
        const result = Array();
        for (let i = 0; i < len; ++i) {
          result.push(fn());
        }
        return result;
      }
    };
    __decorate([
      handlingRangeError
    ], BinaryReader.prototype, "readU8", null);
    __decorate([
      handlingRangeError
    ], BinaryReader.prototype, "readU16", null);
    __decorate([
      handlingRangeError
    ], BinaryReader.prototype, "readU32", null);
    __decorate([
      handlingRangeError
    ], BinaryReader.prototype, "readU64", null);
    __decorate([
      handlingRangeError
    ], BinaryReader.prototype, "readU128", null);
    __decorate([
      handlingRangeError
    ], BinaryReader.prototype, "readU256", null);
    __decorate([
      handlingRangeError
    ], BinaryReader.prototype, "readU512", null);
    __decorate([
      handlingRangeError
    ], BinaryReader.prototype, "readString", null);
    __decorate([
      handlingRangeError
    ], BinaryReader.prototype, "readFixedArray", null);
    __decorate([
      handlingRangeError
    ], BinaryReader.prototype, "readArray", null);
    exports2.BinaryReader = BinaryReader;
    function capitalizeFirstLetter(string3) {
      return string3.charAt(0).toUpperCase() + string3.slice(1);
    }
    function serializeField(schema, fieldName, value, fieldType, writer) {
      try {
        if (typeof fieldType === "string") {
          writer[`write${capitalizeFirstLetter(fieldType)}`](value);
        } else if (fieldType instanceof Array) {
          if (typeof fieldType[0] === "number") {
            if (value.length !== fieldType[0]) {
              throw new BorshError(`Expecting byte array of length ${fieldType[0]}, but got ${value.length} bytes`);
            }
            writer.writeFixedArray(value);
          } else if (fieldType.length === 2 && typeof fieldType[1] === "number") {
            if (value.length !== fieldType[1]) {
              throw new BorshError(`Expecting byte array of length ${fieldType[1]}, but got ${value.length} bytes`);
            }
            for (let i = 0; i < fieldType[1]; i++) {
              serializeField(schema, null, value[i], fieldType[0], writer);
            }
          } else {
            writer.writeArray(value, (item) => {
              serializeField(schema, fieldName, item, fieldType[0], writer);
            });
          }
        } else if (fieldType.kind !== void 0) {
          switch (fieldType.kind) {
            case "option": {
              if (value === null || value === void 0) {
                writer.writeU8(0);
              } else {
                writer.writeU8(1);
                serializeField(schema, fieldName, value, fieldType.type, writer);
              }
              break;
            }
            case "map": {
              writer.writeU32(value.size);
              value.forEach((val, key) => {
                serializeField(schema, fieldName, key, fieldType.key, writer);
                serializeField(schema, fieldName, val, fieldType.value, writer);
              });
              break;
            }
            default:
              throw new BorshError(`FieldType ${fieldType} unrecognized`);
          }
        } else {
          serializeStruct(schema, value, writer);
        }
      } catch (error) {
        if (error instanceof BorshError) {
          error.addToFieldPath(fieldName);
        }
        throw error;
      }
    }
    function serializeStruct(schema, obj, writer) {
      if (typeof obj.borshSerialize === "function") {
        obj.borshSerialize(writer);
        return;
      }
      const structSchema = schema.get(obj.constructor);
      if (!structSchema) {
        throw new BorshError(`Class ${obj.constructor.name} is missing in schema`);
      }
      if (structSchema.kind === "struct") {
        structSchema.fields.map(([fieldName, fieldType]) => {
          serializeField(schema, fieldName, obj[fieldName], fieldType, writer);
        });
      } else if (structSchema.kind === "enum") {
        const name = obj[structSchema.field];
        for (let idx = 0; idx < structSchema.values.length; ++idx) {
          const [fieldName, fieldType] = structSchema.values[idx];
          if (fieldName === name) {
            writer.writeU8(idx);
            serializeField(schema, fieldName, obj[fieldName], fieldType, writer);
            break;
          }
        }
      } else {
        throw new BorshError(`Unexpected schema kind: ${structSchema.kind} for ${obj.constructor.name}`);
      }
    }
    function serialize2(schema, obj, Writer = BinaryWriter) {
      const writer = new Writer();
      serializeStruct(schema, obj, writer);
      return writer.toArray();
    }
    exports2.serialize = serialize2;
    function deserializeField(schema, fieldName, fieldType, reader) {
      try {
        if (typeof fieldType === "string") {
          return reader[`read${capitalizeFirstLetter(fieldType)}`]();
        }
        if (fieldType instanceof Array) {
          if (typeof fieldType[0] === "number") {
            return reader.readFixedArray(fieldType[0]);
          } else if (typeof fieldType[1] === "number") {
            const arr = [];
            for (let i = 0; i < fieldType[1]; i++) {
              arr.push(deserializeField(schema, null, fieldType[0], reader));
            }
            return arr;
          } else {
            return reader.readArray(() => deserializeField(schema, fieldName, fieldType[0], reader));
          }
        }
        if (fieldType.kind === "option") {
          const option2 = reader.readU8();
          if (option2) {
            return deserializeField(schema, fieldName, fieldType.type, reader);
          }
          return void 0;
        }
        if (fieldType.kind === "map") {
          let map = /* @__PURE__ */ new Map();
          const length2 = reader.readU32();
          for (let i = 0; i < length2; i++) {
            const key = deserializeField(schema, fieldName, fieldType.key, reader);
            const val = deserializeField(schema, fieldName, fieldType.value, reader);
            map.set(key, val);
          }
          return map;
        }
        return deserializeStruct(schema, fieldType, reader);
      } catch (error) {
        if (error instanceof BorshError) {
          error.addToFieldPath(fieldName);
        }
        throw error;
      }
    }
    function deserializeStruct(schema, classType, reader) {
      if (typeof classType.borshDeserialize === "function") {
        return classType.borshDeserialize(reader);
      }
      const structSchema = schema.get(classType);
      if (!structSchema) {
        throw new BorshError(`Class ${classType.name} is missing in schema`);
      }
      if (structSchema.kind === "struct") {
        const result = {};
        for (const [fieldName, fieldType] of schema.get(classType).fields) {
          result[fieldName] = deserializeField(schema, fieldName, fieldType, reader);
        }
        return new classType(result);
      }
      if (structSchema.kind === "enum") {
        const idx = reader.readU8();
        if (idx >= structSchema.values.length) {
          throw new BorshError(`Enum index: ${idx} is out of range`);
        }
        const [fieldName, fieldType] = structSchema.values[idx];
        const fieldValue = deserializeField(schema, fieldName, fieldType, reader);
        return new classType({ [fieldName]: fieldValue });
      }
      throw new BorshError(`Unexpected schema kind: ${structSchema.kind} for ${classType.constructor.name}`);
    }
    function deserialize2(schema, classType, buffer3, Reader = BinaryReader) {
      const reader = new Reader(buffer3);
      const result = deserializeStruct(schema, classType, reader);
      if (reader.offset < buffer3.length) {
        throw new BorshError(`Unexpected ${buffer3.length - reader.offset} bytes after deserialized data`);
      }
      return result;
    }
    exports2.deserialize = deserialize2;
    function deserializeUnchecked2(schema, classType, buffer3, Reader = BinaryReader) {
      const reader = new Reader(buffer3);
      return deserializeStruct(schema, classType, reader);
    }
    exports2.deserializeUnchecked = deserializeUnchecked2;
  }
});

// node_modules/@solana/buffer-layout/lib/Layout.js
var require_Layout = __commonJS({
  "node_modules/@solana/buffer-layout/lib/Layout.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.s16 = exports2.s8 = exports2.nu64be = exports2.u48be = exports2.u40be = exports2.u32be = exports2.u24be = exports2.u16be = exports2.nu64 = exports2.u48 = exports2.u40 = exports2.u32 = exports2.u24 = exports2.u16 = exports2.u8 = exports2.offset = exports2.greedy = exports2.Constant = exports2.UTF8 = exports2.CString = exports2.Blob = exports2.Boolean = exports2.BitField = exports2.BitStructure = exports2.VariantLayout = exports2.Union = exports2.UnionLayoutDiscriminator = exports2.UnionDiscriminator = exports2.Structure = exports2.Sequence = exports2.DoubleBE = exports2.Double = exports2.FloatBE = exports2.Float = exports2.NearInt64BE = exports2.NearInt64 = exports2.NearUInt64BE = exports2.NearUInt64 = exports2.IntBE = exports2.Int = exports2.UIntBE = exports2.UInt = exports2.OffsetLayout = exports2.GreedyCount = exports2.ExternalLayout = exports2.bindConstructorLayout = exports2.nameWithProperty = exports2.Layout = exports2.uint8ArrayToBuffer = exports2.checkUint8Array = void 0;
    exports2.constant = exports2.utf8 = exports2.cstr = exports2.blob = exports2.unionLayoutDiscriminator = exports2.union = exports2.seq = exports2.bits = exports2.struct = exports2.f64be = exports2.f64 = exports2.f32be = exports2.f32 = exports2.ns64be = exports2.s48be = exports2.s40be = exports2.s32be = exports2.s24be = exports2.s16be = exports2.ns64 = exports2.s48 = exports2.s40 = exports2.s32 = exports2.s24 = void 0;
    var buffer_1 = require_buffer();
    function checkUint8Array(b) {
      if (!(b instanceof Uint8Array)) {
        throw new TypeError("b must be a Uint8Array");
      }
    }
    exports2.checkUint8Array = checkUint8Array;
    function uint8ArrayToBuffer2(b) {
      checkUint8Array(b);
      return buffer_1.Buffer.from(b.buffer, b.byteOffset, b.length);
    }
    exports2.uint8ArrayToBuffer = uint8ArrayToBuffer2;
    var Layout5 = class {
      constructor(span, property) {
        if (!Number.isInteger(span)) {
          throw new TypeError("span must be an integer");
        }
        this.span = span;
        this.property = property;
      }
      /** Function to create an Object into which decoded properties will
       * be written.
       *
       * Used only for layouts that {@link Layout#decode|decode} to Object
       * instances, which means:
       * * {@link Structure}
       * * {@link Union}
       * * {@link VariantLayout}
       * * {@link BitStructure}
       *
       * If left undefined the JavaScript representation of these layouts
       * will be Object instances.
       *
       * See {@link bindConstructorLayout}.
       */
      makeDestinationObject() {
        return {};
      }
      /**
       * Calculate the span of a specific instance of a layout.
       *
       * @param {Uint8Array} b - the buffer that contains an encoded instance.
       *
       * @param {Number} [offset] - the offset at which the encoded instance
       * starts.  If absent a zero offset is inferred.
       *
       * @return {Number} - the number of bytes covered by the layout
       * instance.  If this method is not overridden in a subclass the
       * definition-time constant {@link Layout#span|span} will be
       * returned.
       *
       * @throws {RangeError} - if the length of the value cannot be
       * determined.
       */
      getSpan(b, offset3) {
        if (0 > this.span) {
          throw new RangeError("indeterminate span");
        }
        return this.span;
      }
      /**
       * Replicate the layout using a new property.
       *
       * This function must be used to get a structurally-equivalent layout
       * with a different name since all {@link Layout} instances are
       * immutable.
       *
       * **NOTE** This is a shallow copy.  All fields except {@link
       * Layout#property|property} are strictly equal to the origin layout.
       *
       * @param {String} property - the value for {@link
       * Layout#property|property} in the replica.
       *
       * @returns {Layout} - the copy with {@link Layout#property|property}
       * set to `property`.
       */
      replicate(property) {
        const rv = Object.create(this.constructor.prototype);
        Object.assign(rv, this);
        rv.property = property;
        return rv;
      }
      /**
       * Create an object from layout properties and an array of values.
       *
       * **NOTE** This function returns `undefined` if invoked on a layout
       * that does not return its value as an Object.  Objects are
       * returned for things that are a {@link Structure}, which includes
       * {@link VariantLayout|variant layouts} if they are structures, and
       * excludes {@link Union}s.  If you want this feature for a union
       * you must use {@link Union.getVariant|getVariant} to select the
       * desired layout.
       *
       * @param {Array} values - an array of values that correspond to the
       * default order for properties.  As with {@link Layout#decode|decode}
       * layout elements that have no property name are skipped when
       * iterating over the array values.  Only the top-level properties are
       * assigned; arguments are not assigned to properties of contained
       * layouts.  Any unused values are ignored.
       *
       * @return {(Object|undefined)}
       */
      fromArray(values) {
        return void 0;
      }
    };
    exports2.Layout = Layout5;
    function nameWithProperty2(name, lo) {
      if (lo.property) {
        return name + "[" + lo.property + "]";
      }
      return name;
    }
    exports2.nameWithProperty = nameWithProperty2;
    function bindConstructorLayout(Class, layout) {
      if ("function" !== typeof Class) {
        throw new TypeError("Class must be constructor");
      }
      if (Object.prototype.hasOwnProperty.call(Class, "layout_")) {
        throw new Error("Class is already bound to a layout");
      }
      if (!(layout && layout instanceof Layout5)) {
        throw new TypeError("layout must be a Layout");
      }
      if (Object.prototype.hasOwnProperty.call(layout, "boundConstructor_")) {
        throw new Error("layout is already bound to a constructor");
      }
      Class.layout_ = layout;
      layout.boundConstructor_ = Class;
      layout.makeDestinationObject = (() => new Class());
      Object.defineProperty(Class.prototype, "encode", {
        value(b, offset3) {
          return layout.encode(this, b, offset3);
        },
        writable: true
      });
      Object.defineProperty(Class, "decode", {
        value(b, offset3) {
          return layout.decode(b, offset3);
        },
        writable: true
      });
    }
    exports2.bindConstructorLayout = bindConstructorLayout;
    var ExternalLayout2 = class extends Layout5 {
      /**
       * Return `true` iff the external layout decodes to an unsigned
       * integer layout.
       *
       * In that case it can be used as the source of {@link
       * Sequence#count|Sequence counts}, {@link Blob#length|Blob lengths},
       * or as {@link UnionLayoutDiscriminator#layout|external union
       * discriminators}.
       *
       * @abstract
       */
      isCount() {
        throw new Error("ExternalLayout is abstract");
      }
    };
    exports2.ExternalLayout = ExternalLayout2;
    var GreedyCount = class extends ExternalLayout2 {
      constructor(elementSpan = 1, property) {
        if (!Number.isInteger(elementSpan) || 0 >= elementSpan) {
          throw new TypeError("elementSpan must be a (positive) integer");
        }
        super(-1, property);
        this.elementSpan = elementSpan;
      }
      /** @override */
      isCount() {
        return true;
      }
      /** @override */
      decode(b, offset3 = 0) {
        checkUint8Array(b);
        const rem = b.length - offset3;
        return Math.floor(rem / this.elementSpan);
      }
      /** @override */
      encode(src2, b, offset3) {
        return 0;
      }
    };
    exports2.GreedyCount = GreedyCount;
    var OffsetLayout2 = class extends ExternalLayout2 {
      constructor(layout, offset3 = 0, property) {
        if (!(layout instanceof Layout5)) {
          throw new TypeError("layout must be a Layout");
        }
        if (!Number.isInteger(offset3)) {
          throw new TypeError("offset must be integer or undefined");
        }
        super(layout.span, property || layout.property);
        this.layout = layout;
        this.offset = offset3;
      }
      /** @override */
      isCount() {
        return this.layout instanceof UInt2 || this.layout instanceof UIntBE2;
      }
      /** @override */
      decode(b, offset3 = 0) {
        return this.layout.decode(b, offset3 + this.offset);
      }
      /** @override */
      encode(src2, b, offset3 = 0) {
        return this.layout.encode(src2, b, offset3 + this.offset);
      }
    };
    exports2.OffsetLayout = OffsetLayout2;
    var UInt2 = class extends Layout5 {
      constructor(span, property) {
        super(span, property);
        if (6 < this.span) {
          throw new RangeError("span must not exceed 6 bytes");
        }
      }
      /** @override */
      decode(b, offset3 = 0) {
        return uint8ArrayToBuffer2(b).readUIntLE(offset3, this.span);
      }
      /** @override */
      encode(src2, b, offset3 = 0) {
        uint8ArrayToBuffer2(b).writeUIntLE(src2, offset3, this.span);
        return this.span;
      }
    };
    exports2.UInt = UInt2;
    var UIntBE2 = class extends Layout5 {
      constructor(span, property) {
        super(span, property);
        if (6 < this.span) {
          throw new RangeError("span must not exceed 6 bytes");
        }
      }
      /** @override */
      decode(b, offset3 = 0) {
        return uint8ArrayToBuffer2(b).readUIntBE(offset3, this.span);
      }
      /** @override */
      encode(src2, b, offset3 = 0) {
        uint8ArrayToBuffer2(b).writeUIntBE(src2, offset3, this.span);
        return this.span;
      }
    };
    exports2.UIntBE = UIntBE2;
    var Int = class extends Layout5 {
      constructor(span, property) {
        super(span, property);
        if (6 < this.span) {
          throw new RangeError("span must not exceed 6 bytes");
        }
      }
      /** @override */
      decode(b, offset3 = 0) {
        return uint8ArrayToBuffer2(b).readIntLE(offset3, this.span);
      }
      /** @override */
      encode(src2, b, offset3 = 0) {
        uint8ArrayToBuffer2(b).writeIntLE(src2, offset3, this.span);
        return this.span;
      }
    };
    exports2.Int = Int;
    var IntBE = class extends Layout5 {
      constructor(span, property) {
        super(span, property);
        if (6 < this.span) {
          throw new RangeError("span must not exceed 6 bytes");
        }
      }
      /** @override */
      decode(b, offset3 = 0) {
        return uint8ArrayToBuffer2(b).readIntBE(offset3, this.span);
      }
      /** @override */
      encode(src2, b, offset3 = 0) {
        uint8ArrayToBuffer2(b).writeIntBE(src2, offset3, this.span);
        return this.span;
      }
    };
    exports2.IntBE = IntBE;
    var V2E322 = Math.pow(2, 32);
    function divmodInt642(src2) {
      const hi32 = Math.floor(src2 / V2E322);
      const lo32 = src2 - hi32 * V2E322;
      return { hi32, lo32 };
    }
    function roundedInt642(hi32, lo32) {
      return hi32 * V2E322 + lo32;
    }
    var NearUInt642 = class extends Layout5 {
      constructor(property) {
        super(8, property);
      }
      /** @override */
      decode(b, offset3 = 0) {
        const buffer3 = uint8ArrayToBuffer2(b);
        const lo32 = buffer3.readUInt32LE(offset3);
        const hi32 = buffer3.readUInt32LE(offset3 + 4);
        return roundedInt642(hi32, lo32);
      }
      /** @override */
      encode(src2, b, offset3 = 0) {
        const split6 = divmodInt642(src2);
        const buffer3 = uint8ArrayToBuffer2(b);
        buffer3.writeUInt32LE(split6.lo32, offset3);
        buffer3.writeUInt32LE(split6.hi32, offset3 + 4);
        return 8;
      }
    };
    exports2.NearUInt64 = NearUInt642;
    var NearUInt64BE = class extends Layout5 {
      constructor(property) {
        super(8, property);
      }
      /** @override */
      decode(b, offset3 = 0) {
        const buffer3 = uint8ArrayToBuffer2(b);
        const hi32 = buffer3.readUInt32BE(offset3);
        const lo32 = buffer3.readUInt32BE(offset3 + 4);
        return roundedInt642(hi32, lo32);
      }
      /** @override */
      encode(src2, b, offset3 = 0) {
        const split6 = divmodInt642(src2);
        const buffer3 = uint8ArrayToBuffer2(b);
        buffer3.writeUInt32BE(split6.hi32, offset3);
        buffer3.writeUInt32BE(split6.lo32, offset3 + 4);
        return 8;
      }
    };
    exports2.NearUInt64BE = NearUInt64BE;
    var NearInt642 = class extends Layout5 {
      constructor(property) {
        super(8, property);
      }
      /** @override */
      decode(b, offset3 = 0) {
        const buffer3 = uint8ArrayToBuffer2(b);
        const lo32 = buffer3.readUInt32LE(offset3);
        const hi32 = buffer3.readInt32LE(offset3 + 4);
        return roundedInt642(hi32, lo32);
      }
      /** @override */
      encode(src2, b, offset3 = 0) {
        const split6 = divmodInt642(src2);
        const buffer3 = uint8ArrayToBuffer2(b);
        buffer3.writeUInt32LE(split6.lo32, offset3);
        buffer3.writeInt32LE(split6.hi32, offset3 + 4);
        return 8;
      }
    };
    exports2.NearInt64 = NearInt642;
    var NearInt64BE = class extends Layout5 {
      constructor(property) {
        super(8, property);
      }
      /** @override */
      decode(b, offset3 = 0) {
        const buffer3 = uint8ArrayToBuffer2(b);
        const hi32 = buffer3.readInt32BE(offset3);
        const lo32 = buffer3.readUInt32BE(offset3 + 4);
        return roundedInt642(hi32, lo32);
      }
      /** @override */
      encode(src2, b, offset3 = 0) {
        const split6 = divmodInt642(src2);
        const buffer3 = uint8ArrayToBuffer2(b);
        buffer3.writeInt32BE(split6.hi32, offset3);
        buffer3.writeUInt32BE(split6.lo32, offset3 + 4);
        return 8;
      }
    };
    exports2.NearInt64BE = NearInt64BE;
    var Float = class extends Layout5 {
      constructor(property) {
        super(4, property);
      }
      /** @override */
      decode(b, offset3 = 0) {
        return uint8ArrayToBuffer2(b).readFloatLE(offset3);
      }
      /** @override */
      encode(src2, b, offset3 = 0) {
        uint8ArrayToBuffer2(b).writeFloatLE(src2, offset3);
        return 4;
      }
    };
    exports2.Float = Float;
    var FloatBE = class extends Layout5 {
      constructor(property) {
        super(4, property);
      }
      /** @override */
      decode(b, offset3 = 0) {
        return uint8ArrayToBuffer2(b).readFloatBE(offset3);
      }
      /** @override */
      encode(src2, b, offset3 = 0) {
        uint8ArrayToBuffer2(b).writeFloatBE(src2, offset3);
        return 4;
      }
    };
    exports2.FloatBE = FloatBE;
    var Double = class extends Layout5 {
      constructor(property) {
        super(8, property);
      }
      /** @override */
      decode(b, offset3 = 0) {
        return uint8ArrayToBuffer2(b).readDoubleLE(offset3);
      }
      /** @override */
      encode(src2, b, offset3 = 0) {
        uint8ArrayToBuffer2(b).writeDoubleLE(src2, offset3);
        return 8;
      }
    };
    exports2.Double = Double;
    var DoubleBE = class extends Layout5 {
      constructor(property) {
        super(8, property);
      }
      /** @override */
      decode(b, offset3 = 0) {
        return uint8ArrayToBuffer2(b).readDoubleBE(offset3);
      }
      /** @override */
      encode(src2, b, offset3 = 0) {
        uint8ArrayToBuffer2(b).writeDoubleBE(src2, offset3);
        return 8;
      }
    };
    exports2.DoubleBE = DoubleBE;
    var Sequence = class extends Layout5 {
      constructor(elementLayout, count, property) {
        if (!(elementLayout instanceof Layout5)) {
          throw new TypeError("elementLayout must be a Layout");
        }
        if (!(count instanceof ExternalLayout2 && count.isCount() || Number.isInteger(count) && 0 <= count)) {
          throw new TypeError("count must be non-negative integer or an unsigned integer ExternalLayout");
        }
        let span = -1;
        if (!(count instanceof ExternalLayout2) && 0 < elementLayout.span) {
          span = count * elementLayout.span;
        }
        super(span, property);
        this.elementLayout = elementLayout;
        this.count = count;
      }
      /** @override */
      getSpan(b, offset3 = 0) {
        if (0 <= this.span) {
          return this.span;
        }
        let span = 0;
        let count = this.count;
        if (count instanceof ExternalLayout2) {
          count = count.decode(b, offset3);
        }
        if (0 < this.elementLayout.span) {
          span = count * this.elementLayout.span;
        } else {
          let idx = 0;
          while (idx < count) {
            span += this.elementLayout.getSpan(b, offset3 + span);
            ++idx;
          }
        }
        return span;
      }
      /** @override */
      decode(b, offset3 = 0) {
        const rv = [];
        let i = 0;
        let count = this.count;
        if (count instanceof ExternalLayout2) {
          count = count.decode(b, offset3);
        }
        while (i < count) {
          rv.push(this.elementLayout.decode(b, offset3));
          offset3 += this.elementLayout.getSpan(b, offset3);
          i += 1;
        }
        return rv;
      }
      /** Implement {@link Layout#encode|encode} for {@link Sequence}.
       *
       * **NOTE** If `src` is shorter than {@link Sequence#count|count} then
       * the unused space in the buffer is left unchanged.  If `src` is
       * longer than {@link Sequence#count|count} the unneeded elements are
       * ignored.
       *
       * **NOTE** If {@link Layout#count|count} is an instance of {@link
       * ExternalLayout} then the length of `src` will be encoded as the
       * count after `src` is encoded. */
      encode(src2, b, offset3 = 0) {
        const elo = this.elementLayout;
        const span = src2.reduce((span2, v) => {
          return span2 + elo.encode(v, b, offset3 + span2);
        }, 0);
        if (this.count instanceof ExternalLayout2) {
          this.count.encode(src2.length, b, offset3);
        }
        return span;
      }
    };
    exports2.Sequence = Sequence;
    var Structure2 = class extends Layout5 {
      constructor(fields, property, decodePrefixes) {
        if (!(Array.isArray(fields) && fields.reduce((acc, v) => acc && v instanceof Layout5, true))) {
          throw new TypeError("fields must be array of Layout instances");
        }
        if ("boolean" === typeof property && void 0 === decodePrefixes) {
          decodePrefixes = property;
          property = void 0;
        }
        for (const fd of fields) {
          if (0 > fd.span && void 0 === fd.property) {
            throw new Error("fields cannot contain unnamed variable-length layout");
          }
        }
        let span = -1;
        try {
          span = fields.reduce((span2, fd) => span2 + fd.getSpan(), 0);
        } catch (e) {
        }
        super(span, property);
        this.fields = fields;
        this.decodePrefixes = !!decodePrefixes;
      }
      /** @override */
      getSpan(b, offset3 = 0) {
        if (0 <= this.span) {
          return this.span;
        }
        let span = 0;
        try {
          span = this.fields.reduce((span2, fd) => {
            const fsp = fd.getSpan(b, offset3);
            offset3 += fsp;
            return span2 + fsp;
          }, 0);
        } catch (e) {
          throw new RangeError("indeterminate span");
        }
        return span;
      }
      /** @override */
      decode(b, offset3 = 0) {
        checkUint8Array(b);
        const dest = this.makeDestinationObject();
        for (const fd of this.fields) {
          if (void 0 !== fd.property) {
            dest[fd.property] = fd.decode(b, offset3);
          }
          offset3 += fd.getSpan(b, offset3);
          if (this.decodePrefixes && b.length === offset3) {
            break;
          }
        }
        return dest;
      }
      /** Implement {@link Layout#encode|encode} for {@link Structure}.
       *
       * If `src` is missing a property for a member with a defined {@link
       * Layout#property|property} the corresponding region of the buffer is
       * left unmodified. */
      encode(src2, b, offset3 = 0) {
        const firstOffset = offset3;
        let lastOffset = 0;
        let lastWrote = 0;
        for (const fd of this.fields) {
          let span = fd.span;
          lastWrote = 0 < span ? span : 0;
          if (void 0 !== fd.property) {
            const fv = src2[fd.property];
            if (void 0 !== fv) {
              lastWrote = fd.encode(fv, b, offset3);
              if (0 > span) {
                span = fd.getSpan(b, offset3);
              }
            }
          }
          lastOffset = offset3;
          offset3 += span;
        }
        return lastOffset + lastWrote - firstOffset;
      }
      /** @override */
      fromArray(values) {
        const dest = this.makeDestinationObject();
        for (const fd of this.fields) {
          if (void 0 !== fd.property && 0 < values.length) {
            dest[fd.property] = values.shift();
          }
        }
        return dest;
      }
      /**
       * Get access to the layout of a given property.
       *
       * @param {String} property - the structure member of interest.
       *
       * @return {Layout} - the layout associated with `property`, or
       * undefined if there is no such property.
       */
      layoutFor(property) {
        if ("string" !== typeof property) {
          throw new TypeError("property must be string");
        }
        for (const fd of this.fields) {
          if (fd.property === property) {
            return fd;
          }
        }
        return void 0;
      }
      /**
       * Get the offset of a structure member.
       *
       * @param {String} property - the structure member of interest.
       *
       * @return {Number} - the offset in bytes to the start of `property`
       * within the structure, or undefined if `property` is not a field
       * within the structure.  If the property is a member but follows a
       * variable-length structure member a negative number will be
       * returned.
       */
      offsetOf(property) {
        if ("string" !== typeof property) {
          throw new TypeError("property must be string");
        }
        let offset3 = 0;
        for (const fd of this.fields) {
          if (fd.property === property) {
            return offset3;
          }
          if (0 > fd.span) {
            offset3 = -1;
          } else if (0 <= offset3) {
            offset3 += fd.span;
          }
        }
        return void 0;
      }
    };
    exports2.Structure = Structure2;
    var UnionDiscriminator2 = class {
      constructor(property) {
        this.property = property;
      }
      /** Analog to {@link Layout#decode|Layout decode} for union discriminators.
       *
       * The implementation of this method need not reference the buffer if
       * variant information is available through other means. */
      decode(b, offset3) {
        throw new Error("UnionDiscriminator is abstract");
      }
      /** Analog to {@link Layout#decode|Layout encode} for union discriminators.
       *
       * The implementation of this method need not store the value if
       * variant information is maintained through other means. */
      encode(src2, b, offset3) {
        throw new Error("UnionDiscriminator is abstract");
      }
    };
    exports2.UnionDiscriminator = UnionDiscriminator2;
    var UnionLayoutDiscriminator2 = class extends UnionDiscriminator2 {
      constructor(layout, property) {
        if (!(layout instanceof ExternalLayout2 && layout.isCount())) {
          throw new TypeError("layout must be an unsigned integer ExternalLayout");
        }
        super(property || layout.property || "variant");
        this.layout = layout;
      }
      /** Delegate decoding to {@link UnionLayoutDiscriminator#layout|layout}. */
      decode(b, offset3) {
        return this.layout.decode(b, offset3);
      }
      /** Delegate encoding to {@link UnionLayoutDiscriminator#layout|layout}. */
      encode(src2, b, offset3) {
        return this.layout.encode(src2, b, offset3);
      }
    };
    exports2.UnionLayoutDiscriminator = UnionLayoutDiscriminator2;
    var Union2 = class extends Layout5 {
      constructor(discr, defaultLayout, property) {
        let discriminator2;
        if (discr instanceof UInt2 || discr instanceof UIntBE2) {
          discriminator2 = new UnionLayoutDiscriminator2(new OffsetLayout2(discr));
        } else if (discr instanceof ExternalLayout2 && discr.isCount()) {
          discriminator2 = new UnionLayoutDiscriminator2(discr);
        } else if (!(discr instanceof UnionDiscriminator2)) {
          throw new TypeError("discr must be a UnionDiscriminator or an unsigned integer layout");
        } else {
          discriminator2 = discr;
        }
        if (void 0 === defaultLayout) {
          defaultLayout = null;
        }
        if (!(null === defaultLayout || defaultLayout instanceof Layout5)) {
          throw new TypeError("defaultLayout must be null or a Layout");
        }
        if (null !== defaultLayout) {
          if (0 > defaultLayout.span) {
            throw new Error("defaultLayout must have constant span");
          }
          if (void 0 === defaultLayout.property) {
            defaultLayout = defaultLayout.replicate("content");
          }
        }
        let span = -1;
        if (defaultLayout) {
          span = defaultLayout.span;
          if (0 <= span && (discr instanceof UInt2 || discr instanceof UIntBE2)) {
            span += discriminator2.layout.span;
          }
        }
        super(span, property);
        this.discriminator = discriminator2;
        this.usesPrefixDiscriminator = discr instanceof UInt2 || discr instanceof UIntBE2;
        this.defaultLayout = defaultLayout;
        this.registry = {};
        let boundGetSourceVariant = this.defaultGetSourceVariant.bind(this);
        this.getSourceVariant = function(src2) {
          return boundGetSourceVariant(src2);
        };
        this.configGetSourceVariant = function(gsv) {
          boundGetSourceVariant = gsv.bind(this);
        };
      }
      /** @override */
      getSpan(b, offset3 = 0) {
        if (0 <= this.span) {
          return this.span;
        }
        const vlo = this.getVariant(b, offset3);
        if (!vlo) {
          throw new Error("unable to determine span for unrecognized variant");
        }
        return vlo.getSpan(b, offset3);
      }
      /**
       * Method to infer a registered Union variant compatible with `src`.
       *
       * The first satisfied rule in the following sequence defines the
       * return value:
       * * If `src` has properties matching the Union discriminator and
       *   the default layout, `undefined` is returned regardless of the
       *   value of the discriminator property (this ensures the default
       *   layout will be used);
       * * If `src` has a property matching the Union discriminator, the
       *   value of the discriminator identifies a registered variant, and
       *   either (a) the variant has no layout, or (b) `src` has the
       *   variant's property, then the variant is returned (because the
       *   source satisfies the constraints of the variant it identifies);
       * * If `src` does not have a property matching the Union
       *   discriminator, but does have a property matching a registered
       *   variant, then the variant is returned (because the source
       *   matches a variant without an explicit conflict);
       * * An error is thrown (because we either can't identify a variant,
       *   or we were explicitly told the variant but can't satisfy it).
       *
       * @param {Object} src - an object presumed to be compatible with
       * the content of the Union.
       *
       * @return {(undefined|VariantLayout)} - as described above.
       *
       * @throws {Error} - if `src` cannot be associated with a default or
       * registered variant.
       */
      defaultGetSourceVariant(src2) {
        if (Object.prototype.hasOwnProperty.call(src2, this.discriminator.property)) {
          if (this.defaultLayout && this.defaultLayout.property && Object.prototype.hasOwnProperty.call(src2, this.defaultLayout.property)) {
            return void 0;
          }
          const vlo = this.registry[src2[this.discriminator.property]];
          if (vlo && (!vlo.layout || vlo.property && Object.prototype.hasOwnProperty.call(src2, vlo.property))) {
            return vlo;
          }
        } else {
          for (const tag in this.registry) {
            const vlo = this.registry[tag];
            if (vlo.property && Object.prototype.hasOwnProperty.call(src2, vlo.property)) {
              return vlo;
            }
          }
        }
        throw new Error("unable to infer src variant");
      }
      /** Implement {@link Layout#decode|decode} for {@link Union}.
       *
       * If the variant is {@link Union#addVariant|registered} the return
       * value is an instance of that variant, with no explicit
       * discriminator.  Otherwise the {@link Union#defaultLayout|default
       * layout} is used to decode the content. */
      decode(b, offset3 = 0) {
        let dest;
        const dlo = this.discriminator;
        const discr = dlo.decode(b, offset3);
        const clo = this.registry[discr];
        if (void 0 === clo) {
          const defaultLayout = this.defaultLayout;
          let contentOffset = 0;
          if (this.usesPrefixDiscriminator) {
            contentOffset = dlo.layout.span;
          }
          dest = this.makeDestinationObject();
          dest[dlo.property] = discr;
          dest[defaultLayout.property] = defaultLayout.decode(b, offset3 + contentOffset);
        } else {
          dest = clo.decode(b, offset3);
        }
        return dest;
      }
      /** Implement {@link Layout#encode|encode} for {@link Union}.
       *
       * This API assumes the `src` object is consistent with the union's
       * {@link Union#defaultLayout|default layout}.  To encode variants
       * use the appropriate variant-specific {@link VariantLayout#encode}
       * method. */
      encode(src2, b, offset3 = 0) {
        const vlo = this.getSourceVariant(src2);
        if (void 0 === vlo) {
          const dlo = this.discriminator;
          const clo = this.defaultLayout;
          let contentOffset = 0;
          if (this.usesPrefixDiscriminator) {
            contentOffset = dlo.layout.span;
          }
          dlo.encode(src2[dlo.property], b, offset3);
          return contentOffset + clo.encode(src2[clo.property], b, offset3 + contentOffset);
        }
        return vlo.encode(src2, b, offset3);
      }
      /** Register a new variant structure within a union.  The newly
       * created variant is returned.
       *
       * @param {Number} variant - initializer for {@link
       * VariantLayout#variant|variant}.
       *
       * @param {Layout} layout - initializer for {@link
       * VariantLayout#layout|layout}.
       *
       * @param {String} property - initializer for {@link
       * Layout#property|property}.
       *
       * @return {VariantLayout} */
      addVariant(variant, layout, property) {
        const rv = new VariantLayout2(this, variant, layout, property);
        this.registry[variant] = rv;
        return rv;
      }
      /**
       * Get the layout associated with a registered variant.
       *
       * If `vb` does not produce a registered variant the function returns
       * `undefined`.
       *
       * @param {(Number|Uint8Array)} vb - either the variant number, or a
       * buffer from which the discriminator is to be read.
       *
       * @param {Number} offset - offset into `vb` for the start of the
       * union.  Used only when `vb` is an instance of {Uint8Array}.
       *
       * @return {({VariantLayout}|undefined)}
       */
      getVariant(vb, offset3 = 0) {
        let variant;
        if (vb instanceof Uint8Array) {
          variant = this.discriminator.decode(vb, offset3);
        } else {
          variant = vb;
        }
        return this.registry[variant];
      }
    };
    exports2.Union = Union2;
    var VariantLayout2 = class extends Layout5 {
      constructor(union3, variant, layout, property) {
        if (!(union3 instanceof Union2)) {
          throw new TypeError("union must be a Union");
        }
        if (!Number.isInteger(variant) || 0 > variant) {
          throw new TypeError("variant must be a (non-negative) integer");
        }
        if ("string" === typeof layout && void 0 === property) {
          property = layout;
          layout = null;
        }
        if (layout) {
          if (!(layout instanceof Layout5)) {
            throw new TypeError("layout must be a Layout");
          }
          if (null !== union3.defaultLayout && 0 <= layout.span && layout.span > union3.defaultLayout.span) {
            throw new Error("variant span exceeds span of containing union");
          }
          if ("string" !== typeof property) {
            throw new TypeError("variant must have a String property");
          }
        }
        let span = union3.span;
        if (0 > union3.span) {
          span = layout ? layout.span : 0;
          if (0 <= span && union3.usesPrefixDiscriminator) {
            span += union3.discriminator.layout.span;
          }
        }
        super(span, property);
        this.union = union3;
        this.variant = variant;
        this.layout = layout || null;
      }
      /** @override */
      getSpan(b, offset3 = 0) {
        if (0 <= this.span) {
          return this.span;
        }
        let contentOffset = 0;
        if (this.union.usesPrefixDiscriminator) {
          contentOffset = this.union.discriminator.layout.span;
        }
        let span = 0;
        if (this.layout) {
          span = this.layout.getSpan(b, offset3 + contentOffset);
        }
        return contentOffset + span;
      }
      /** @override */
      decode(b, offset3 = 0) {
        const dest = this.makeDestinationObject();
        if (this !== this.union.getVariant(b, offset3)) {
          throw new Error("variant mismatch");
        }
        let contentOffset = 0;
        if (this.union.usesPrefixDiscriminator) {
          contentOffset = this.union.discriminator.layout.span;
        }
        if (this.layout) {
          dest[this.property] = this.layout.decode(b, offset3 + contentOffset);
        } else if (this.property) {
          dest[this.property] = true;
        } else if (this.union.usesPrefixDiscriminator) {
          dest[this.union.discriminator.property] = this.variant;
        }
        return dest;
      }
      /** @override */
      encode(src2, b, offset3 = 0) {
        let contentOffset = 0;
        if (this.union.usesPrefixDiscriminator) {
          contentOffset = this.union.discriminator.layout.span;
        }
        if (this.layout && !Object.prototype.hasOwnProperty.call(src2, this.property)) {
          throw new TypeError("variant lacks property " + this.property);
        }
        this.union.discriminator.encode(this.variant, b, offset3);
        let span = contentOffset;
        if (this.layout) {
          this.layout.encode(src2[this.property], b, offset3 + contentOffset);
          span += this.layout.getSpan(b, offset3 + contentOffset);
          if (0 <= this.union.span && span > this.union.span) {
            throw new Error("encoded variant overruns containing union");
          }
        }
        return span;
      }
      /** Delegate {@link Layout#fromArray|fromArray} to {@link
       * VariantLayout#layout|layout}. */
      fromArray(values) {
        if (this.layout) {
          return this.layout.fromArray(values);
        }
        return void 0;
      }
    };
    exports2.VariantLayout = VariantLayout2;
    function fixBitwiseResult(v) {
      if (0 > v) {
        v += 4294967296;
      }
      return v;
    }
    var BitStructure = class extends Layout5 {
      constructor(word, msb, property) {
        if (!(word instanceof UInt2 || word instanceof UIntBE2)) {
          throw new TypeError("word must be a UInt or UIntBE layout");
        }
        if ("string" === typeof msb && void 0 === property) {
          property = msb;
          msb = false;
        }
        if (4 < word.span) {
          throw new RangeError("word cannot exceed 32 bits");
        }
        super(word.span, property);
        this.word = word;
        this.msb = !!msb;
        this.fields = [];
        let value = 0;
        this._packedSetValue = function(v) {
          value = fixBitwiseResult(v);
          return this;
        };
        this._packedGetValue = function() {
          return value;
        };
      }
      /** @override */
      decode(b, offset3 = 0) {
        const dest = this.makeDestinationObject();
        const value = this.word.decode(b, offset3);
        this._packedSetValue(value);
        for (const fd of this.fields) {
          if (void 0 !== fd.property) {
            dest[fd.property] = fd.decode(b);
          }
        }
        return dest;
      }
      /** Implement {@link Layout#encode|encode} for {@link BitStructure}.
       *
       * If `src` is missing a property for a member with a defined {@link
       * Layout#property|property} the corresponding region of the packed
       * value is left unmodified.  Unused bits are also left unmodified. */
      encode(src2, b, offset3 = 0) {
        const value = this.word.decode(b, offset3);
        this._packedSetValue(value);
        for (const fd of this.fields) {
          if (void 0 !== fd.property) {
            const fv = src2[fd.property];
            if (void 0 !== fv) {
              fd.encode(fv);
            }
          }
        }
        return this.word.encode(this._packedGetValue(), b, offset3);
      }
      /** Register a new bitfield with a containing bit structure.  The
       * resulting bitfield is returned.
       *
       * @param {Number} bits - initializer for {@link BitField#bits|bits}.
       *
       * @param {string} property - initializer for {@link
       * Layout#property|property}.
       *
       * @return {BitField} */
      addField(bits, property) {
        const bf = new BitField(this, bits, property);
        this.fields.push(bf);
        return bf;
      }
      /** As with {@link BitStructure#addField|addField} for single-bit
       * fields with `boolean` value representation.
       *
       * @param {string} property - initializer for {@link
       * Layout#property|property}.
       *
       * @return {Boolean} */
      // `Boolean` conflicts with the native primitive type
      // eslint-disable-next-line @typescript-eslint/ban-types
      addBoolean(property) {
        const bf = new Boolean2(this, property);
        this.fields.push(bf);
        return bf;
      }
      /**
       * Get access to the bit field for a given property.
       *
       * @param {String} property - the bit field of interest.
       *
       * @return {BitField} - the field associated with `property`, or
       * undefined if there is no such property.
       */
      fieldFor(property) {
        if ("string" !== typeof property) {
          throw new TypeError("property must be string");
        }
        for (const fd of this.fields) {
          if (fd.property === property) {
            return fd;
          }
        }
        return void 0;
      }
    };
    exports2.BitStructure = BitStructure;
    var BitField = class {
      constructor(container, bits, property) {
        if (!(container instanceof BitStructure)) {
          throw new TypeError("container must be a BitStructure");
        }
        if (!Number.isInteger(bits) || 0 >= bits) {
          throw new TypeError("bits must be positive integer");
        }
        const totalBits = 8 * container.span;
        const usedBits = container.fields.reduce((sum, fd) => sum + fd.bits, 0);
        if (bits + usedBits > totalBits) {
          throw new Error("bits too long for span remainder (" + (totalBits - usedBits) + " of " + totalBits + " remain)");
        }
        this.container = container;
        this.bits = bits;
        this.valueMask = (1 << bits) - 1;
        if (32 === bits) {
          this.valueMask = 4294967295;
        }
        this.start = usedBits;
        if (this.container.msb) {
          this.start = totalBits - usedBits - bits;
        }
        this.wordMask = fixBitwiseResult(this.valueMask << this.start);
        this.property = property;
      }
      /** Store a value into the corresponding subsequence of the containing
       * bit field. */
      decode(b, offset3) {
        const word = this.container._packedGetValue();
        const wordValue = fixBitwiseResult(word & this.wordMask);
        const value = wordValue >>> this.start;
        return value;
      }
      /** Store a value into the corresponding subsequence of the containing
       * bit field.
       *
       * **NOTE** This is not a specialization of {@link
       * Layout#encode|Layout.encode} and there is no return value. */
      encode(value) {
        if ("number" !== typeof value || !Number.isInteger(value) || value !== fixBitwiseResult(value & this.valueMask)) {
          throw new TypeError(nameWithProperty2("BitField.encode", this) + " value must be integer not exceeding " + this.valueMask);
        }
        const word = this.container._packedGetValue();
        const wordValue = fixBitwiseResult(value << this.start);
        this.container._packedSetValue(fixBitwiseResult(word & ~this.wordMask) | wordValue);
      }
    };
    exports2.BitField = BitField;
    var Boolean2 = class extends BitField {
      constructor(container, property) {
        super(container, 1, property);
      }
      /** Override {@link BitField#decode|decode} for {@link Boolean|Boolean}.
       *
       * @returns {boolean} */
      decode(b, offset3) {
        return !!super.decode(b, offset3);
      }
      /** @override */
      encode(value) {
        if ("boolean" === typeof value) {
          value = +value;
        }
        super.encode(value);
      }
    };
    exports2.Boolean = Boolean2;
    var Blob2 = class extends Layout5 {
      constructor(length2, property) {
        if (!(length2 instanceof ExternalLayout2 && length2.isCount() || Number.isInteger(length2) && 0 <= length2)) {
          throw new TypeError("length must be positive integer or an unsigned integer ExternalLayout");
        }
        let span = -1;
        if (!(length2 instanceof ExternalLayout2)) {
          span = length2;
        }
        super(span, property);
        this.length = length2;
      }
      /** @override */
      getSpan(b, offset3) {
        let span = this.span;
        if (0 > span) {
          span = this.length.decode(b, offset3);
        }
        return span;
      }
      /** @override */
      decode(b, offset3 = 0) {
        let span = this.span;
        if (0 > span) {
          span = this.length.decode(b, offset3);
        }
        return uint8ArrayToBuffer2(b).slice(offset3, offset3 + span);
      }
      /** Implement {@link Layout#encode|encode} for {@link Blob}.
       *
       * **NOTE** If {@link Layout#count|count} is an instance of {@link
       * ExternalLayout} then the length of `src` will be encoded as the
       * count after `src` is encoded. */
      encode(src2, b, offset3) {
        let span = this.length;
        if (this.length instanceof ExternalLayout2) {
          span = src2.length;
        }
        if (!(src2 instanceof Uint8Array && span === src2.length)) {
          throw new TypeError(nameWithProperty2("Blob.encode", this) + " requires (length " + span + ") Uint8Array as src");
        }
        if (offset3 + span > b.length) {
          throw new RangeError("encoding overruns Uint8Array");
        }
        const srcBuffer = uint8ArrayToBuffer2(src2);
        uint8ArrayToBuffer2(b).write(srcBuffer.toString("hex"), offset3, span, "hex");
        if (this.length instanceof ExternalLayout2) {
          this.length.encode(span, b, offset3);
        }
        return span;
      }
    };
    exports2.Blob = Blob2;
    var CString = class extends Layout5 {
      constructor(property) {
        super(-1, property);
      }
      /** @override */
      getSpan(b, offset3 = 0) {
        checkUint8Array(b);
        let idx = offset3;
        while (idx < b.length && 0 !== b[idx]) {
          idx += 1;
        }
        return 1 + idx - offset3;
      }
      /** @override */
      decode(b, offset3 = 0) {
        const span = this.getSpan(b, offset3);
        return uint8ArrayToBuffer2(b).slice(offset3, offset3 + span - 1).toString("utf-8");
      }
      /** @override */
      encode(src2, b, offset3 = 0) {
        if ("string" !== typeof src2) {
          src2 = String(src2);
        }
        const srcb = buffer_1.Buffer.from(src2, "utf8");
        const span = srcb.length;
        if (offset3 + span > b.length) {
          throw new RangeError("encoding overruns Buffer");
        }
        const buffer3 = uint8ArrayToBuffer2(b);
        srcb.copy(buffer3, offset3);
        buffer3[offset3 + span] = 0;
        return span + 1;
      }
    };
    exports2.CString = CString;
    var UTF8 = class extends Layout5 {
      constructor(maxSpan, property) {
        if ("string" === typeof maxSpan && void 0 === property) {
          property = maxSpan;
          maxSpan = void 0;
        }
        if (void 0 === maxSpan) {
          maxSpan = -1;
        } else if (!Number.isInteger(maxSpan)) {
          throw new TypeError("maxSpan must be an integer");
        }
        super(-1, property);
        this.maxSpan = maxSpan;
      }
      /** @override */
      getSpan(b, offset3 = 0) {
        checkUint8Array(b);
        return b.length - offset3;
      }
      /** @override */
      decode(b, offset3 = 0) {
        const span = this.getSpan(b, offset3);
        if (0 <= this.maxSpan && this.maxSpan < span) {
          throw new RangeError("text length exceeds maxSpan");
        }
        return uint8ArrayToBuffer2(b).slice(offset3, offset3 + span).toString("utf-8");
      }
      /** @override */
      encode(src2, b, offset3 = 0) {
        if ("string" !== typeof src2) {
          src2 = String(src2);
        }
        const srcb = buffer_1.Buffer.from(src2, "utf8");
        const span = srcb.length;
        if (0 <= this.maxSpan && this.maxSpan < span) {
          throw new RangeError("text length exceeds maxSpan");
        }
        if (offset3 + span > b.length) {
          throw new RangeError("encoding overruns Buffer");
        }
        srcb.copy(uint8ArrayToBuffer2(b), offset3);
        return span;
      }
    };
    exports2.UTF8 = UTF8;
    var Constant = class extends Layout5 {
      constructor(value, property) {
        super(0, property);
        this.value = value;
      }
      /** @override */
      decode(b, offset3) {
        return this.value;
      }
      /** @override */
      encode(src2, b, offset3) {
        return 0;
      }
    };
    exports2.Constant = Constant;
    exports2.greedy = ((elementSpan, property) => new GreedyCount(elementSpan, property));
    exports2.offset = ((layout, offset3, property) => new OffsetLayout2(layout, offset3, property));
    exports2.u8 = ((property) => new UInt2(1, property));
    exports2.u16 = ((property) => new UInt2(2, property));
    exports2.u24 = ((property) => new UInt2(3, property));
    exports2.u32 = ((property) => new UInt2(4, property));
    exports2.u40 = ((property) => new UInt2(5, property));
    exports2.u48 = ((property) => new UInt2(6, property));
    exports2.nu64 = ((property) => new NearUInt642(property));
    exports2.u16be = ((property) => new UIntBE2(2, property));
    exports2.u24be = ((property) => new UIntBE2(3, property));
    exports2.u32be = ((property) => new UIntBE2(4, property));
    exports2.u40be = ((property) => new UIntBE2(5, property));
    exports2.u48be = ((property) => new UIntBE2(6, property));
    exports2.nu64be = ((property) => new NearUInt64BE(property));
    exports2.s8 = ((property) => new Int(1, property));
    exports2.s16 = ((property) => new Int(2, property));
    exports2.s24 = ((property) => new Int(3, property));
    exports2.s32 = ((property) => new Int(4, property));
    exports2.s40 = ((property) => new Int(5, property));
    exports2.s48 = ((property) => new Int(6, property));
    exports2.ns64 = ((property) => new NearInt642(property));
    exports2.s16be = ((property) => new IntBE(2, property));
    exports2.s24be = ((property) => new IntBE(3, property));
    exports2.s32be = ((property) => new IntBE(4, property));
    exports2.s40be = ((property) => new IntBE(5, property));
    exports2.s48be = ((property) => new IntBE(6, property));
    exports2.ns64be = ((property) => new NearInt64BE(property));
    exports2.f32 = ((property) => new Float(property));
    exports2.f32be = ((property) => new FloatBE(property));
    exports2.f64 = ((property) => new Double(property));
    exports2.f64be = ((property) => new DoubleBE(property));
    exports2.struct = ((fields, property, decodePrefixes) => new Structure2(fields, property, decodePrefixes));
    exports2.bits = ((word, msb, property) => new BitStructure(word, msb, property));
    exports2.seq = ((elementLayout, count, property) => new Sequence(elementLayout, count, property));
    exports2.union = ((discr, defaultLayout, property) => new Union2(discr, defaultLayout, property));
    exports2.unionLayoutDiscriminator = ((layout, property) => new UnionLayoutDiscriminator2(layout, property));
    exports2.blob = ((length2, property) => new Blob2(length2, property));
    exports2.cstr = ((property) => new CString(property));
    exports2.utf8 = ((maxSpan, property) => new UTF8(maxSpan, property));
    exports2.constant = ((value, property) => new Constant(value, property));
  }
});

// node_modules/@solana/web3.js/node_modules/@solana/errors/dist/index.browser.mjs
function getHumanReadableErrorMessage(code2, context = {}) {
  const messageFormatString = SolanaErrorMessages[code2];
  if (messageFormatString.length === 0) {
    return "";
  }
  let state;
  function commitStateUpTo(endIndex) {
    if (state[TYPE] === 2) {
      const variableName = messageFormatString.slice(state[START_INDEX] + 1, endIndex);
      fragments.push(
        variableName in context ? (
          // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
          `${context[variableName]}`
        ) : `$${variableName}`
      );
    } else if (state[TYPE] === 1) {
      fragments.push(messageFormatString.slice(state[START_INDEX], endIndex));
    }
  }
  const fragments = [];
  messageFormatString.split("").forEach((char, ii) => {
    if (ii === 0) {
      state = {
        [START_INDEX]: 0,
        [TYPE]: messageFormatString[0] === "\\" ? 0 : messageFormatString[0] === "$" ? 2 : 1
        /* Text */
      };
      return;
    }
    let nextState;
    switch (state[TYPE]) {
      case 0:
        nextState = {
          [START_INDEX]: ii,
          [TYPE]: 1
          /* Text */
        };
        break;
      case 1:
        if (char === "\\") {
          nextState = {
            [START_INDEX]: ii,
            [TYPE]: 0
            /* EscapeSequence */
          };
        } else if (char === "$") {
          nextState = {
            [START_INDEX]: ii,
            [TYPE]: 2
            /* Variable */
          };
        }
        break;
      case 2:
        if (char === "\\") {
          nextState = {
            [START_INDEX]: ii,
            [TYPE]: 0
            /* EscapeSequence */
          };
        } else if (char === "$") {
          nextState = {
            [START_INDEX]: ii,
            [TYPE]: 2
            /* Variable */
          };
        } else if (!char.match(/\w/)) {
          nextState = {
            [START_INDEX]: ii,
            [TYPE]: 1
            /* Text */
          };
        }
        break;
    }
    if (nextState) {
      if (state !== nextState) {
        commitStateUpTo(ii);
      }
      state = nextState;
    }
  });
  commitStateUpTo();
  return fragments.join("");
}
function getErrorMessage(code2, context = {}) {
  if (true) {
    return getHumanReadableErrorMessage(code2, context);
  } else {
    let decodingAdviceMessage = `Solana error #${code2}; Decode this error by running \`npx @solana/errors decode -- ${code2}`;
    if (Object.keys(context).length) {
      decodingAdviceMessage += ` '${encodeContextObject(context)}'`;
    }
    return `${decodingAdviceMessage}\``;
  }
}
var SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED, SOLANA_ERROR__INVALID_NONCE, SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND, SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE, SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH, SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE, SOLANA_ERROR__MALFORMED_BIGINT_STRING, SOLANA_ERROR__MALFORMED_NUMBER_STRING, SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE, SOLANA_ERROR__MALFORMED_JSON_RPC_ERROR, SOLANA_ERROR__JSON_RPC__PARSE_ERROR, SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR, SOLANA_ERROR__JSON_RPC__INVALID_PARAMS, SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND, SOLANA_ERROR__JSON_RPC__INVALID_REQUEST, SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED, SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION, SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET, SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH, SOLANA_ERROR__JSON_RPC__SCAN_ERROR, SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE, SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX, SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED, SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NO_SNAPSHOT, SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED, SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE, SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY, SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE, SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE, SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE, SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP, SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH, SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE, SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS, SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY, SOLANA_ERROR__ADDRESSES__MALFORMED_PDA, SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE, SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED, SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED, SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE, SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED, SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER, SOLANA_ERROR__ADDRESSES__INVALID_OFF_CURVE_ADDRESS, SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND, SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND, SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT, SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT, SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED, SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT, SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED, SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED, SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED, SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED, SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED, SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED, SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY, SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED, SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH, SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH, SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH, SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE, SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY, SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS, SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA, SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH, SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN, SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR, SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT, SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA, SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA, SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL, SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS, SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID, SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE, SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED, SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT, SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION, SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID, SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND, SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED, SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE, SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED, SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX, SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED, SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED, SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS, SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED, SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE, SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED, SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING, SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC, SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM, SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR, SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED, SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE, SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT, SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID, SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH, SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT, SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED, SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED, SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS, SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC, SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED, SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION, SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE, SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE, SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE, SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE, SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY, SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR, SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT, SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER, SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW, SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR, SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER, SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED, SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED, SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED, SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS, SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS, SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER, SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER, SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER, SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER, SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER, SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER, SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER, SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER, SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS, SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING, SOLANA_ERROR__SIGNER__WALLET_MULTISIGN_UNIMPLEMENTED, SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES, SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE, SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME, SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME, SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE, SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING, SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE, SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND, SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING, SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING, SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING, SOLANA_ERROR__TRANSACTION__FEE_PAYER_MISSING, SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING, SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_INSTRUCTIONS_MISSING, SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE, SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION, SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES, SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH, SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT, SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT, SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT, SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN, SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_IN_USE, SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_LOADED_TWICE, SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_NOT_FOUND, SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_ACCOUNT_NOT_FOUND, SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE, SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_FOR_FEE, SOLANA_ERROR__TRANSACTION_ERROR__ALREADY_PROCESSED, SOLANA_ERROR__TRANSACTION_ERROR__BLOCKHASH_NOT_FOUND, SOLANA_ERROR__TRANSACTION_ERROR__CALL_CHAIN_TOO_DEEP, SOLANA_ERROR__TRANSACTION_ERROR__MISSING_SIGNATURE_FOR_FEE, SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_INDEX, SOLANA_ERROR__TRANSACTION_ERROR__SIGNATURE_FAILURE, SOLANA_ERROR__TRANSACTION_ERROR__INVALID_PROGRAM_FOR_EXECUTION, SOLANA_ERROR__TRANSACTION_ERROR__SANITIZE_FAILURE, SOLANA_ERROR__TRANSACTION_ERROR__CLUSTER_MAINTENANCE, SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_BORROW_OUTSTANDING, SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_BLOCK_COST_LIMIT, SOLANA_ERROR__TRANSACTION_ERROR__UNSUPPORTED_VERSION, SOLANA_ERROR__TRANSACTION_ERROR__INVALID_WRITABLE_ACCOUNT, SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_ACCOUNT_COST_LIMIT, SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_BLOCK_LIMIT, SOLANA_ERROR__TRANSACTION_ERROR__TOO_MANY_ACCOUNT_LOCKS, SOLANA_ERROR__TRANSACTION_ERROR__ADDRESS_LOOKUP_TABLE_NOT_FOUND, SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_OWNER, SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_DATA, SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_INDEX, SOLANA_ERROR__TRANSACTION_ERROR__INVALID_RENT_PAYING_ACCOUNT, SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_VOTE_COST_LIMIT, SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_TOTAL_LIMIT, SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION, SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT, SOLANA_ERROR__TRANSACTION_ERROR__MAX_LOADED_ACCOUNTS_DATA_SIZE_EXCEEDED, SOLANA_ERROR__TRANSACTION_ERROR__INVALID_LOADED_ACCOUNTS_DATA_SIZE_LIMIT, SOLANA_ERROR__TRANSACTION_ERROR__RESANITIZATION_NEEDED, SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED, SOLANA_ERROR__TRANSACTION_ERROR__UNBALANCED_TRANSACTION, SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY, SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH, SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH, SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH, SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH, SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH, SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH, SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS, SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE, SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT, SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT, SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE, SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE, SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT, SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE, SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE, SOLANA_ERROR__CODECS__INVALID_CONSTANT, SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE, SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL, SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES, SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS, SOLANA_ERROR__RPC__INTEGER_OVERFLOW, SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN, SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR, SOLANA_ERROR__RPC__API_PLAN_MISSING_FOR_RPC_METHOD, SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_PLAN, SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID, SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CLOSED_BEFORE_MESSAGE_BUFFERED, SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED, SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT, SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_STATE_MISSING, SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE, SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING, SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE, SOLANA_ERROR__INVARIANT_VIOLATION__DATA_PUBLISHER_CHANNEL_UNIMPLEMENTED, SolanaErrorMessages, START_INDEX, TYPE, SolanaError;
var init_index_browser = __esm({
  "node_modules/@solana/web3.js/node_modules/@solana/errors/dist/index.browser.mjs"() {
    SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED = 1;
    SOLANA_ERROR__INVALID_NONCE = 2;
    SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND = 3;
    SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE = 4;
    SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH = 5;
    SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE = 6;
    SOLANA_ERROR__MALFORMED_BIGINT_STRING = 7;
    SOLANA_ERROR__MALFORMED_NUMBER_STRING = 8;
    SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE = 9;
    SOLANA_ERROR__MALFORMED_JSON_RPC_ERROR = 10;
    SOLANA_ERROR__JSON_RPC__PARSE_ERROR = -32700;
    SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR = -32603;
    SOLANA_ERROR__JSON_RPC__INVALID_PARAMS = -32602;
    SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND = -32601;
    SOLANA_ERROR__JSON_RPC__INVALID_REQUEST = -32600;
    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED = -32016;
    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION = -32015;
    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET = -32014;
    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH = -32013;
    SOLANA_ERROR__JSON_RPC__SCAN_ERROR = -32012;
    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE = -32011;
    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX = -32010;
    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED = -32009;
    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NO_SNAPSHOT = -32008;
    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED = -32007;
    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE = -32006;
    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY = -32005;
    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE = -32004;
    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE = -32003;
    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE = -32002;
    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP = -32001;
    SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH = 28e5;
    SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE = 2800001;
    SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS = 2800002;
    SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY = 2800003;
    SOLANA_ERROR__ADDRESSES__MALFORMED_PDA = 2800004;
    SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE = 2800005;
    SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED = 2800006;
    SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED = 2800007;
    SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE = 2800008;
    SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED = 2800009;
    SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER = 2800010;
    SOLANA_ERROR__ADDRESSES__INVALID_OFF_CURVE_ADDRESS = 2800011;
    SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND = 323e4;
    SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND = 32300001;
    SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT = 3230002;
    SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT = 3230003;
    SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED = 3230004;
    SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT = 361e4;
    SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED = 3610001;
    SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED = 3610002;
    SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED = 3610003;
    SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED = 3610004;
    SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED = 3610005;
    SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED = 3610006;
    SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY = 3610007;
    SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED = 3611e3;
    SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH = 3704e3;
    SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH = 3704001;
    SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH = 3704002;
    SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE = 3704003;
    SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY = 3704004;
    SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS = 4128e3;
    SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA = 4128001;
    SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH = 4128002;
    SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN = 4615e3;
    SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR = 4615001;
    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT = 4615002;
    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA = 4615003;
    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA = 4615004;
    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL = 4615005;
    SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS = 4615006;
    SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID = 4615007;
    SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE = 4615008;
    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED = 4615009;
    SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT = 4615010;
    SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION = 4615011;
    SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID = 4615012;
    SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND = 4615013;
    SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED = 4615014;
    SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE = 4615015;
    SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED = 4615016;
    SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX = 4615017;
    SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED = 4615018;
    SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED = 4615019;
    SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS = 4615020;
    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED = 4615021;
    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE = 4615022;
    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED = 4615023;
    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING = 4615024;
    SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC = 4615025;
    SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM = 4615026;
    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR = 4615027;
    SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED = 4615028;
    SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE = 4615029;
    SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT = 4615030;
    SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID = 4615031;
    SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH = 4615032;
    SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT = 4615033;
    SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED = 4615034;
    SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED = 4615035;
    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS = 4615036;
    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC = 4615037;
    SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED = 4615038;
    SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION = 4615039;
    SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE = 4615040;
    SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE = 4615041;
    SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE = 4615042;
    SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE = 4615043;
    SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY = 4615044;
    SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR = 4615045;
    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT = 4615046;
    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER = 4615047;
    SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW = 4615048;
    SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR = 4615049;
    SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER = 4615050;
    SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED = 4615051;
    SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED = 4615052;
    SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED = 4615053;
    SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS = 4615054;
    SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS = 5508e3;
    SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER = 5508001;
    SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER = 5508002;
    SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER = 5508003;
    SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER = 5508004;
    SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER = 5508005;
    SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER = 5508006;
    SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER = 5508007;
    SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER = 5508008;
    SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS = 5508009;
    SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING = 5508010;
    SOLANA_ERROR__SIGNER__WALLET_MULTISIGN_UNIMPLEMENTED = 5508011;
    SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES = 5663e3;
    SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE = 5663001;
    SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME = 5663002;
    SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME = 5663003;
    SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE = 5663004;
    SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING = 5663005;
    SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE = 5663006;
    SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND = 5663007;
    SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING = 5663008;
    SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING = 5663009;
    SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING = 5663010;
    SOLANA_ERROR__TRANSACTION__FEE_PAYER_MISSING = 5663011;
    SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING = 5663012;
    SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_INSTRUCTIONS_MISSING = 5663013;
    SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE = 5663014;
    SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION = 5663015;
    SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES = 5663016;
    SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH = 5663017;
    SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT = 5663018;
    SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT = 5663019;
    SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT = 5663020;
    SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN = 705e4;
    SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_IN_USE = 7050001;
    SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_LOADED_TWICE = 7050002;
    SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_NOT_FOUND = 7050003;
    SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_ACCOUNT_NOT_FOUND = 7050004;
    SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE = 7050005;
    SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_FOR_FEE = 7050006;
    SOLANA_ERROR__TRANSACTION_ERROR__ALREADY_PROCESSED = 7050007;
    SOLANA_ERROR__TRANSACTION_ERROR__BLOCKHASH_NOT_FOUND = 7050008;
    SOLANA_ERROR__TRANSACTION_ERROR__CALL_CHAIN_TOO_DEEP = 7050009;
    SOLANA_ERROR__TRANSACTION_ERROR__MISSING_SIGNATURE_FOR_FEE = 7050010;
    SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_INDEX = 7050011;
    SOLANA_ERROR__TRANSACTION_ERROR__SIGNATURE_FAILURE = 7050012;
    SOLANA_ERROR__TRANSACTION_ERROR__INVALID_PROGRAM_FOR_EXECUTION = 7050013;
    SOLANA_ERROR__TRANSACTION_ERROR__SANITIZE_FAILURE = 7050014;
    SOLANA_ERROR__TRANSACTION_ERROR__CLUSTER_MAINTENANCE = 7050015;
    SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_BORROW_OUTSTANDING = 7050016;
    SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_BLOCK_COST_LIMIT = 7050017;
    SOLANA_ERROR__TRANSACTION_ERROR__UNSUPPORTED_VERSION = 7050018;
    SOLANA_ERROR__TRANSACTION_ERROR__INVALID_WRITABLE_ACCOUNT = 7050019;
    SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_ACCOUNT_COST_LIMIT = 7050020;
    SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_BLOCK_LIMIT = 7050021;
    SOLANA_ERROR__TRANSACTION_ERROR__TOO_MANY_ACCOUNT_LOCKS = 7050022;
    SOLANA_ERROR__TRANSACTION_ERROR__ADDRESS_LOOKUP_TABLE_NOT_FOUND = 7050023;
    SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_OWNER = 7050024;
    SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_DATA = 7050025;
    SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_INDEX = 7050026;
    SOLANA_ERROR__TRANSACTION_ERROR__INVALID_RENT_PAYING_ACCOUNT = 7050027;
    SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_VOTE_COST_LIMIT = 7050028;
    SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_TOTAL_LIMIT = 7050029;
    SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION = 7050030;
    SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT = 7050031;
    SOLANA_ERROR__TRANSACTION_ERROR__MAX_LOADED_ACCOUNTS_DATA_SIZE_EXCEEDED = 7050032;
    SOLANA_ERROR__TRANSACTION_ERROR__INVALID_LOADED_ACCOUNTS_DATA_SIZE_LIMIT = 7050033;
    SOLANA_ERROR__TRANSACTION_ERROR__RESANITIZATION_NEEDED = 7050034;
    SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED = 7050035;
    SOLANA_ERROR__TRANSACTION_ERROR__UNBALANCED_TRANSACTION = 7050036;
    SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY = 8078e3;
    SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH = 8078001;
    SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH = 8078002;
    SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH = 8078003;
    SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH = 8078004;
    SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH = 8078005;
    SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH = 8078006;
    SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS = 8078007;
    SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE = 8078008;
    SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT = 8078009;
    SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT = 8078010;
    SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE = 8078011;
    SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE = 8078012;
    SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH = 8078013;
    SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE = 8078014;
    SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT = 8078015;
    SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE = 8078016;
    SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE = 8078017;
    SOLANA_ERROR__CODECS__INVALID_CONSTANT = 8078018;
    SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE = 8078019;
    SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL = 8078020;
    SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES = 8078021;
    SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS = 8078022;
    SOLANA_ERROR__RPC__INTEGER_OVERFLOW = 81e5;
    SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN = 8100001;
    SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR = 8100002;
    SOLANA_ERROR__RPC__API_PLAN_MISSING_FOR_RPC_METHOD = 8100003;
    SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_PLAN = 819e4;
    SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID = 8190001;
    SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CLOSED_BEFORE_MESSAGE_BUFFERED = 8190002;
    SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED = 8190003;
    SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT = 8190004;
    SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_STATE_MISSING = 99e5;
    SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE = 9900001;
    SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING = 9900002;
    SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE = 9900003;
    SOLANA_ERROR__INVARIANT_VIOLATION__DATA_PUBLISHER_CHANNEL_UNIMPLEMENTED = 9900004;
    SolanaErrorMessages = {
      [SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND]: "Account not found at address: $address",
      [SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED]: "Not all accounts were decoded. Encoded accounts found at addresses: $addresses.",
      [SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT]: "Expected decoded account at address: $address",
      [SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT]: "Failed to decode account data at address: $address",
      [SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND]: "Accounts not found at addresses: $addresses",
      [SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED]: "Unable to find a viable program address bump seed.",
      [SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS]: "$putativeAddress is not a base58-encoded address.",
      [SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH]: "Expected base58 encoded address to decode to a byte array of length 32. Actual length: $actualLength.",
      [SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY]: "The `CryptoKey` must be an `Ed25519` public key.",
      [SOLANA_ERROR__ADDRESSES__INVALID_OFF_CURVE_ADDRESS]: "$putativeOffCurveAddress is not a base58-encoded off-curve address.",
      [SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE]: "Invalid seeds; point must fall off the Ed25519 curve.",
      [SOLANA_ERROR__ADDRESSES__MALFORMED_PDA]: "Expected given program derived address to have the following format: [Address, ProgramDerivedAddressBump].",
      [SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED]: "A maximum of $maxSeeds seeds, including the bump seed, may be supplied when creating an address. Received: $actual.",
      [SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED]: "The seed at index $index with length $actual exceeds the maximum length of $maxSeedLength bytes.",
      [SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE]: "Expected program derived address bump to be in the range [0, 255], got: $bump.",
      [SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER]: "Program address cannot end with PDA marker.",
      [SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE]: "Expected base58-encoded address string of length in the range [32, 44]. Actual length: $actualLength.",
      [SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE]: "Expected base58-encoded blockash string of length in the range [32, 44]. Actual length: $actualLength.",
      [SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED]: "The network has progressed past the last block for which this transaction could have been committed.",
      [SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY]: "Codec [$codecDescription] cannot decode empty byte arrays.",
      [SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS]: "Enum codec cannot use lexical values [$stringValues] as discriminators. Either remove all lexical values or set `useValuesAsDiscriminators` to `false`.",
      [SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL]: "Sentinel [$hexSentinel] must not be present in encoded bytes [$hexEncodedBytes].",
      [SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH]: "Encoder and decoder must have the same fixed size, got [$encoderFixedSize] and [$decoderFixedSize].",
      [SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH]: "Encoder and decoder must have the same max size, got [$encoderMaxSize] and [$decoderMaxSize].",
      [SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH]: "Encoder and decoder must either both be fixed-size or variable-size.",
      [SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE]: "Enum discriminator out of range. Expected a number in [$formattedValidDiscriminators], got $discriminator.",
      [SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH]: "Expected a fixed-size codec, got a variable-size one.",
      [SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH]: "Codec [$codecDescription] expected a positive byte length, got $bytesLength.",
      [SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH]: "Expected a variable-size codec, got a fixed-size one.",
      [SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE]: "Codec [$codecDescription] expected zero-value [$hexZeroValue] to have the same size as the provided fixed-size item [$expectedSize bytes].",
      [SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH]: "Codec [$codecDescription] expected $expected bytes, got $bytesLength.",
      [SOLANA_ERROR__CODECS__INVALID_CONSTANT]: "Expected byte array constant [$hexConstant] to be present in data [$hexData] at offset [$offset].",
      [SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT]: "Invalid discriminated union variant. Expected one of [$variants], got $value.",
      [SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT]: "Invalid enum variant. Expected one of [$stringValues] or a number in [$formattedNumericalValues], got $variant.",
      [SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT]: "Invalid literal union variant. Expected one of [$variants], got $value.",
      [SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS]: "Expected [$codecDescription] to have $expected items, got $actual.",
      [SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE]: "Invalid value $value for base $base with alphabet $alphabet.",
      [SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE]: "Literal union discriminator out of range. Expected a number between $minRange and $maxRange, got $discriminator.",
      [SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE]: "Codec [$codecDescription] expected number to be in the range [$min, $max], got $value.",
      [SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE]: "Codec [$codecDescription] expected offset to be in the range [0, $bytesLength], got $offset.",
      [SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES]: "Expected sentinel [$hexSentinel] to be present in decoded bytes [$hexDecodedBytes].",
      [SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE]: "Union variant out of range. Expected an index between $minRange and $maxRange, got $variant.",
      [SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED]: "No random values implementation could be found.",
      [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED]: "instruction requires an uninitialized account",
      [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED]: "instruction tries to borrow reference for an account which is already borrowed",
      [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING]: "instruction left account with an outstanding borrowed reference",
      [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED]: "program other than the account's owner changed the size of the account data",
      [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL]: "account data too small for instruction",
      [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE]: "instruction expected an executable account",
      [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT]: "An account does not have enough lamports to be rent-exempt",
      [SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW]: "Program arithmetic overflowed",
      [SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR]: "Failed to serialize or deserialize account data: $encodedData",
      [SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS]: "Builtin programs must consume compute units",
      [SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH]: "Cross-program invocation call depth too deep",
      [SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED]: "Computational budget exceeded",
      [SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM]: "custom program error: #$code",
      [SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX]: "instruction contains duplicate accounts",
      [SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC]: "instruction modifications of multiply-passed account differ",
      [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT]: "executable accounts must be rent exempt",
      [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED]: "instruction changed executable accounts data",
      [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE]: "instruction changed the balance of an executable account",
      [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED]: "instruction changed executable bit of an account",
      [SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED]: "instruction modified data of an account it does not own",
      [SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND]: "instruction spent from the balance of an account it does not own",
      [SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR]: "generic instruction error",
      [SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER]: "Provided owner is not allowed",
      [SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE]: "Account is immutable",
      [SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY]: "Incorrect authority provided",
      [SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID]: "incorrect program id for instruction",
      [SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS]: "insufficient funds for instruction",
      [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA]: "invalid account data for instruction",
      [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER]: "Invalid account owner",
      [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT]: "invalid program argument",
      [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR]: "program returned invalid error code",
      [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA]: "invalid instruction data",
      [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC]: "Failed to reallocate account data",
      [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS]: "Provided seeds do not result in a valid address",
      [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED]: "Accounts data allocations exceeded the maximum allowed per transaction",
      [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED]: "Max accounts exceeded",
      [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED]: "Max instruction trace length exceeded",
      [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED]: "Length of the seed is too long for address generation",
      [SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT]: "An account required by the instruction is missing",
      [SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE]: "missing required signature for instruction",
      [SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID]: "instruction illegally modified the program id of an account",
      [SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS]: "insufficient account keys for instruction",
      [SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION]: "Cross-program invocation with unauthorized signer or writable account",
      [SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE]: "Failed to create program execution environment",
      [SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE]: "Program failed to compile",
      [SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE]: "Program failed to complete",
      [SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED]: "instruction modified data of a read-only account",
      [SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE]: "instruction changed the balance of a read-only account",
      [SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED]: "Cross-program invocation reentrancy not allowed for this instruction",
      [SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED]: "instruction modified rent epoch of an account",
      [SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION]: "sum of account balances before and after instruction do not match",
      [SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT]: "instruction requires an initialized account",
      [SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN]: "",
      [SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID]: "Unsupported program id",
      [SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR]: "Unsupported sysvar",
      [SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS]: "The instruction does not have any accounts.",
      [SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA]: "The instruction does not have any data.",
      [SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH]: "Expected instruction to have progress address $expectedProgramAddress, got $actualProgramAddress.",
      [SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH]: "Expected base58 encoded blockhash to decode to a byte array of length 32. Actual length: $actualLength.",
      [SOLANA_ERROR__INVALID_NONCE]: "The nonce `$expectedNonceValue` is no longer valid. It has advanced to `$actualNonceValue`",
      [SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING]: "Invariant violation: Found no abortable iterable cache entry for key `$cacheKey`. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant",
      [SOLANA_ERROR__INVARIANT_VIOLATION__DATA_PUBLISHER_CHANNEL_UNIMPLEMENTED]: "Invariant violation: This data publisher does not publish to the channel named `$channelName`. Supported channels include $supportedChannelNames.",
      [SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE]: "Invariant violation: WebSocket message iterator state is corrupt; iterated without first resolving existing message promise. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant",
      [SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_STATE_MISSING]: "Invariant violation: WebSocket message iterator is missing state storage. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant",
      [SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE]: "Invariant violation: Switch statement non-exhaustive. Received unexpected value `$unexpectedValue`. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant",
      [SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR]: "JSON-RPC error: Internal JSON-RPC error ($__serverMessage)",
      [SOLANA_ERROR__JSON_RPC__INVALID_PARAMS]: "JSON-RPC error: Invalid method parameter(s) ($__serverMessage)",
      [SOLANA_ERROR__JSON_RPC__INVALID_REQUEST]: "JSON-RPC error: The JSON sent is not a valid `Request` object ($__serverMessage)",
      [SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND]: "JSON-RPC error: The method does not exist / is not available ($__serverMessage)",
      [SOLANA_ERROR__JSON_RPC__PARSE_ERROR]: "JSON-RPC error: An error occurred on the server while parsing the JSON text ($__serverMessage)",
      [SOLANA_ERROR__JSON_RPC__SCAN_ERROR]: "$__serverMessage",
      [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP]: "$__serverMessage",
      [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE]: "$__serverMessage",
      [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET]: "$__serverMessage",
      [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX]: "$__serverMessage",
      [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED]: "$__serverMessage",
      [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED]: "Minimum context slot has not been reached",
      [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY]: "Node is unhealthy; behind by $numSlotsBehind slots",
      [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NO_SNAPSHOT]: "No snapshot",
      [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE]: "Transaction simulation failed",
      [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED]: "$__serverMessage",
      [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE]: "Transaction history is not available from this node",
      [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE]: "$__serverMessage",
      [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH]: "Transaction signature length mismatch",
      [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE]: "Transaction signature verification failure",
      [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION]: "$__serverMessage",
      [SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH]: "Key pair bytes must be of length 64, got $byteLength.",
      [SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH]: "Expected private key bytes with length 32. Actual length: $actualLength.",
      [SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH]: "Expected base58-encoded signature to decode to a byte array of length 64. Actual length: $actualLength.",
      [SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY]: "The provided private key does not match the provided public key.",
      [SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE]: "Expected base58-encoded signature string of length in the range [64, 88]. Actual length: $actualLength.",
      [SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE]: "Lamports value must be in the range [0, 2e64-1]",
      [SOLANA_ERROR__MALFORMED_BIGINT_STRING]: "`$value` cannot be parsed as a `BigInt`",
      [SOLANA_ERROR__MALFORMED_JSON_RPC_ERROR]: "$message",
      [SOLANA_ERROR__MALFORMED_NUMBER_STRING]: "`$value` cannot be parsed as a `Number`",
      [SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND]: "No nonce account could be found at address `$nonceAccountAddress`",
      [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_PLAN]: "The notification name must end in 'Notifications' and the API must supply a subscription plan creator function for the notification '$notificationName'.",
      [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CLOSED_BEFORE_MESSAGE_BUFFERED]: "WebSocket was closed before payload could be added to the send buffer",
      [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED]: "WebSocket connection closed",
      [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT]: "WebSocket failed to connect",
      [SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID]: "Failed to obtain a subscription id from the server",
      [SOLANA_ERROR__RPC__API_PLAN_MISSING_FOR_RPC_METHOD]: "Could not find an API plan for RPC method: `$method`",
      [SOLANA_ERROR__RPC__INTEGER_OVERFLOW]: "The $argumentLabel argument to the `$methodName` RPC method$optionalPathLabel was `$value`. This number is unsafe for use with the Solana JSON-RPC because it exceeds `Number.MAX_SAFE_INTEGER`.",
      [SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR]: "HTTP error ($statusCode): $message",
      [SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN]: "HTTP header(s) forbidden: $headers. Learn more at https://developer.mozilla.org/en-US/docs/Glossary/Forbidden_header_name.",
      [SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS]: "Multiple distinct signers were identified for address `$address`. Please ensure that you are using the same signer instance for each address.",
      [SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER]: "The provided value does not implement the `KeyPairSigner` interface",
      [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER]: "The provided value does not implement the `MessageModifyingSigner` interface",
      [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER]: "The provided value does not implement the `MessagePartialSigner` interface",
      [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER]: "The provided value does not implement any of the `MessageSigner` interfaces",
      [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER]: "The provided value does not implement the `TransactionModifyingSigner` interface",
      [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER]: "The provided value does not implement the `TransactionPartialSigner` interface",
      [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER]: "The provided value does not implement the `TransactionSendingSigner` interface",
      [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER]: "The provided value does not implement any of the `TransactionSigner` interfaces",
      [SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS]: "More than one `TransactionSendingSigner` was identified.",
      [SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING]: "No `TransactionSendingSigner` was identified. Please provide a valid `TransactionWithSingleSendingSigner` transaction.",
      [SOLANA_ERROR__SIGNER__WALLET_MULTISIGN_UNIMPLEMENTED]: "Wallet account signers do not support signing multiple messages/transactions in a single operation",
      [SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY]: "Cannot export a non-extractable key.",
      [SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED]: "No digest implementation could be found.",
      [SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT]: "Cryptographic operations are only allowed in secure browser contexts. Read more here: https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts.",
      [SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED]: "This runtime does not support the generation of Ed25519 key pairs.\n\nInstall @solana/webcrypto-ed25519-polyfill and call its `install` function before generating keys in environments that do not support Ed25519.\n\nFor a list of runtimes that currently support Ed25519 operations, visit https://github.com/WICG/webcrypto-secure-curves/issues/20.",
      [SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED]: "No signature verification implementation could be found.",
      [SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED]: "No key generation implementation could be found.",
      [SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED]: "No signing implementation could be found.",
      [SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED]: "No key export implementation could be found.",
      [SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE]: "Timestamp value must be in the range [-(2n ** 63n), (2n ** 63n) - 1]. `$value` given",
      [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_BORROW_OUTSTANDING]: "Transaction processing left an account with an outstanding borrowed reference",
      [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_IN_USE]: "Account in use",
      [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_LOADED_TWICE]: "Account loaded twice",
      [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_NOT_FOUND]: "Attempt to debit an account but found no record of a prior credit.",
      [SOLANA_ERROR__TRANSACTION_ERROR__ADDRESS_LOOKUP_TABLE_NOT_FOUND]: "Transaction loads an address table account that doesn't exist",
      [SOLANA_ERROR__TRANSACTION_ERROR__ALREADY_PROCESSED]: "This transaction has already been processed",
      [SOLANA_ERROR__TRANSACTION_ERROR__BLOCKHASH_NOT_FOUND]: "Blockhash not found",
      [SOLANA_ERROR__TRANSACTION_ERROR__CALL_CHAIN_TOO_DEEP]: "Loader call chain is too deep",
      [SOLANA_ERROR__TRANSACTION_ERROR__CLUSTER_MAINTENANCE]: "Transactions are currently disabled due to cluster maintenance",
      [SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION]: "Transaction contains a duplicate instruction ($index) that is not allowed",
      [SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE]: "Insufficient funds for fee",
      [SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT]: "Transaction results in an account ($accountIndex) with insufficient funds for rent",
      [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_FOR_FEE]: "This account may not be used to pay transaction fees",
      [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_INDEX]: "Transaction contains an invalid account reference",
      [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_DATA]: "Transaction loads an address table account with invalid data",
      [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_INDEX]: "Transaction address table lookup uses an invalid index",
      [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_OWNER]: "Transaction loads an address table account with an invalid owner",
      [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_LOADED_ACCOUNTS_DATA_SIZE_LIMIT]: "LoadedAccountsDataSizeLimit set for transaction must be greater than 0.",
      [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_PROGRAM_FOR_EXECUTION]: "This program may not be used for executing instructions",
      [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_RENT_PAYING_ACCOUNT]: "Transaction leaves an account with a lower balance than rent-exempt minimum",
      [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_WRITABLE_ACCOUNT]: "Transaction loads a writable account that cannot be written",
      [SOLANA_ERROR__TRANSACTION_ERROR__MAX_LOADED_ACCOUNTS_DATA_SIZE_EXCEEDED]: "Transaction exceeded max loaded accounts data size cap",
      [SOLANA_ERROR__TRANSACTION_ERROR__MISSING_SIGNATURE_FOR_FEE]: "Transaction requires a fee but has no signature present",
      [SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_ACCOUNT_NOT_FOUND]: "Attempt to load a program that does not exist",
      [SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED]: "Execution of the program referenced by account at index $accountIndex is temporarily restricted.",
      [SOLANA_ERROR__TRANSACTION_ERROR__RESANITIZATION_NEEDED]: "ResanitizationNeeded",
      [SOLANA_ERROR__TRANSACTION_ERROR__SANITIZE_FAILURE]: "Transaction failed to sanitize accounts offsets correctly",
      [SOLANA_ERROR__TRANSACTION_ERROR__SIGNATURE_FAILURE]: "Transaction did not pass signature verification",
      [SOLANA_ERROR__TRANSACTION_ERROR__TOO_MANY_ACCOUNT_LOCKS]: "Transaction locked too many accounts",
      [SOLANA_ERROR__TRANSACTION_ERROR__UNBALANCED_TRANSACTION]: "Sum of account balances before and after transaction do not match",
      [SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN]: "The transaction failed with the error `$errorName`",
      [SOLANA_ERROR__TRANSACTION_ERROR__UNSUPPORTED_VERSION]: "Transaction version is unsupported",
      [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_BLOCK_LIMIT]: "Transaction would exceed account data limit within the block",
      [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_TOTAL_LIMIT]: "Transaction would exceed total account data limit",
      [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_ACCOUNT_COST_LIMIT]: "Transaction would exceed max account limit within the block",
      [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_BLOCK_COST_LIMIT]: "Transaction would exceed max Block Cost Limit",
      [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_VOTE_COST_LIMIT]: "Transaction would exceed max Vote Cost Limit",
      [SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION]: "Attempted to sign a transaction with an address that is not a signer for it",
      [SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING]: "Transaction is missing an address at index: $index.",
      [SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES]: "Transaction has no expected signers therefore it cannot be encoded",
      [SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT]: "Transaction size $transactionSize exceeds limit of $transactionSizeLimit bytes",
      [SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME]: "Transaction does not have a blockhash lifetime",
      [SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME]: "Transaction is not a durable nonce transaction",
      [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING]: "Contents of these address lookup tables unknown: $lookupTableAddresses",
      [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE]: "Lookup of address at index $highestRequestedIndex failed for lookup table `$lookupTableAddress`. Highest known index is $highestKnownIndex. The lookup table may have been extended since its contents were retrieved",
      [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING]: "No fee payer set in CompiledTransaction",
      [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND]: "Could not find program address at index $index",
      [SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT]: "Failed to estimate the compute unit consumption for this transaction message. This is likely because simulating the transaction failed. Inspect the `cause` property of this error to learn more",
      [SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT]: "Transaction failed when it was simulated in order to estimate the compute unit consumption. The compute unit estimate provided is for a transaction that failed when simulated and may not be representative of the compute units this transaction would consume if successful. Inspect the `cause` property of this error to learn more",
      [SOLANA_ERROR__TRANSACTION__FEE_PAYER_MISSING]: "Transaction is missing a fee payer.",
      [SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING]: "Could not determine this transaction's signature. Make sure that the transaction has been signed by its fee payer.",
      [SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE]: "Transaction first instruction is not advance nonce account instruction.",
      [SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_INSTRUCTIONS_MISSING]: "Transaction with no instructions cannot be durable nonce transaction.",
      [SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES]: "This transaction includes an address (`$programAddress`) which is both invoked and set as the fee payer. Program addresses may not pay fees",
      [SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE]: "This transaction includes an address (`$programAddress`) which is both invoked and marked writable. Program addresses may not be writable",
      [SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH]: "The transaction message expected the transaction to have $signerAddressesLength signatures, got $signaturesLength.",
      [SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING]: "Transaction is missing signatures for addresses: $addresses.",
      [SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE]: "Transaction version must be in the range [0, 127]. `$actualVersion` given"
    };
    START_INDEX = "i";
    TYPE = "t";
    SolanaError = class extends Error {
      constructor(...[code2, contextAndErrorOptions]) {
        let context;
        let errorOptions;
        if (contextAndErrorOptions) {
          const { cause, ...contextRest } = contextAndErrorOptions;
          if (cause) {
            errorOptions = { cause };
          }
          if (Object.keys(contextRest).length > 0) {
            context = contextRest;
          }
        }
        const message = getErrorMessage(code2, context);
        super(message, errorOptions);
        /**
         * Indicates the root cause of this {@link SolanaError}, if any.
         *
         * For example, a transaction error might have an instruction error as its root cause. In this
         * case, you will be able to access the instruction error on the transaction error as `cause`.
         */
        __publicField(this, "cause", this.cause);
        /**
         * Contains context that can assist in understanding or recovering from a {@link SolanaError}.
         */
        __publicField(this, "context");
        this.context = {
          __code: code2,
          ...context
        };
        this.name = "SolanaError";
      }
    };
  }
});

// node_modules/@solana/web3.js/node_modules/@solana/codecs-core/dist/index.browser.mjs
function getEncodedSize(value, encoder4) {
  return "fixedSize" in encoder4 ? encoder4.fixedSize : encoder4.getSizeFromValue(value);
}
function createEncoder(encoder4) {
  return Object.freeze({
    ...encoder4,
    encode: (value) => {
      const bytes3 = new Uint8Array(getEncodedSize(value, encoder4));
      encoder4.write(value, bytes3, 0);
      return bytes3;
    }
  });
}
function createDecoder(decoder) {
  return Object.freeze({
    ...decoder,
    decode: (bytes3, offset3 = 0) => decoder.read(bytes3, offset3)[0]
  });
}
function isFixedSize(codec) {
  return "fixedSize" in codec && typeof codec.fixedSize === "number";
}
function combineCodec(encoder4, decoder) {
  if (isFixedSize(encoder4) !== isFixedSize(decoder)) {
    throw new SolanaError(SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH);
  }
  if (isFixedSize(encoder4) && isFixedSize(decoder) && encoder4.fixedSize !== decoder.fixedSize) {
    throw new SolanaError(SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH, {
      decoderFixedSize: decoder.fixedSize,
      encoderFixedSize: encoder4.fixedSize
    });
  }
  if (!isFixedSize(encoder4) && !isFixedSize(decoder) && encoder4.maxSize !== decoder.maxSize) {
    throw new SolanaError(SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH, {
      decoderMaxSize: decoder.maxSize,
      encoderMaxSize: encoder4.maxSize
    });
  }
  return {
    ...decoder,
    ...encoder4,
    decode: decoder.decode,
    encode: encoder4.encode,
    read: decoder.read,
    write: encoder4.write
  };
}
function assertByteArrayIsNotEmptyForCodec(codecDescription, bytes3, offset3 = 0) {
  if (bytes3.length - offset3 <= 0) {
    throw new SolanaError(SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY, {
      codecDescription
    });
  }
}
function assertByteArrayHasEnoughBytesForCodec(codecDescription, expected, bytes3, offset3 = 0) {
  const bytesLength = bytes3.length - offset3;
  if (bytesLength < expected) {
    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH, {
      bytesLength,
      codecDescription,
      expected
    });
  }
}
var init_index_browser2 = __esm({
  "node_modules/@solana/web3.js/node_modules/@solana/codecs-core/dist/index.browser.mjs"() {
    init_index_browser();
  }
});

// node_modules/@solana/web3.js/node_modules/@solana/codecs-numbers/dist/index.browser.mjs
function assertNumberIsBetweenForCodec(codecDescription, min, max, value) {
  if (value < min || value > max) {
    throw new SolanaError(SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE, {
      codecDescription,
      max,
      min,
      value
    });
  }
}
function isLittleEndian(config) {
  return (config == null ? void 0 : config.endian) === 1 ? false : true;
}
function numberEncoderFactory(input) {
  return createEncoder({
    fixedSize: input.size,
    write(value, bytes3, offset3) {
      if (input.range) {
        assertNumberIsBetweenForCodec(input.name, input.range[0], input.range[1], value);
      }
      const arrayBuffer = new ArrayBuffer(input.size);
      input.set(new DataView(arrayBuffer), value, isLittleEndian(input.config));
      bytes3.set(new Uint8Array(arrayBuffer), offset3);
      return offset3 + input.size;
    }
  });
}
function numberDecoderFactory(input) {
  return createDecoder({
    fixedSize: input.size,
    read(bytes3, offset3 = 0) {
      assertByteArrayIsNotEmptyForCodec(input.name, bytes3, offset3);
      assertByteArrayHasEnoughBytesForCodec(input.name, input.size, bytes3, offset3);
      const view = new DataView(toArrayBuffer(bytes3, offset3, input.size));
      return [input.get(view, isLittleEndian(input.config)), offset3 + input.size];
    }
  });
}
function toArrayBuffer(bytes3, offset3, length2) {
  const bytesOffset = bytes3.byteOffset + (offset3 ?? 0);
  const bytesLength = length2 ?? bytes3.byteLength;
  return bytes3.buffer.slice(bytesOffset, bytesOffset + bytesLength);
}
var Endian, getU64Encoder, getU64Decoder, getU64Codec;
var init_index_browser3 = __esm({
  "node_modules/@solana/web3.js/node_modules/@solana/codecs-numbers/dist/index.browser.mjs"() {
    init_index_browser();
    init_index_browser2();
    Endian = ((Endian2) => {
      Endian2[Endian2["Little"] = 0] = "Little";
      Endian2[Endian2["Big"] = 1] = "Big";
      return Endian2;
    })(Endian || {});
    getU64Encoder = (config = {}) => numberEncoderFactory({
      config,
      name: "u64",
      range: [0n, BigInt("0xffffffffffffffff")],
      set: (view, value, le) => view.setBigUint64(0, BigInt(value), le),
      size: 8
    });
    getU64Decoder = (config = {}) => numberDecoderFactory({
      config,
      get: (view, le) => view.getBigUint64(0, le),
      name: "u64",
      size: 8
    });
    getU64Codec = (config = {}) => combineCodec(getU64Encoder(config), getU64Decoder(config));
  }
});

// node_modules/@solana/web3.js/node_modules/superstruct/dist/index.mjs
function isIterable(x) {
  return isObject(x) && typeof x[Symbol.iterator] === "function";
}
function isObject(x) {
  return typeof x === "object" && x != null;
}
function isNonArrayObject(x) {
  return isObject(x) && !Array.isArray(x);
}
function print(value) {
  if (typeof value === "symbol") {
    return value.toString();
  }
  return typeof value === "string" ? JSON.stringify(value) : `${value}`;
}
function shiftIterator(input) {
  const { done, value } = input.next();
  return done ? void 0 : value;
}
function toFailure(result, context, struct52, value) {
  if (result === true) {
    return;
  } else if (result === false) {
    result = {};
  } else if (typeof result === "string") {
    result = { message: result };
  }
  const { path, branch } = context;
  const { type: type3 } = struct52;
  const { refinement, message = `Expected a value of type \`${type3}\`${refinement ? ` with refinement \`${refinement}\`` : ""}, but received: \`${print(value)}\`` } = result;
  return {
    value,
    type: type3,
    refinement,
    key: path[path.length - 1],
    path,
    branch,
    ...result,
    message
  };
}
function* toFailures(result, context, struct52, value) {
  if (!isIterable(result)) {
    result = [result];
  }
  for (const r of result) {
    const failure = toFailure(r, context, struct52, value);
    if (failure) {
      yield failure;
    }
  }
}
function* run(value, struct52, options = {}) {
  const { path = [], branch = [value], coerce: coerce4 = false, mask: mask3 = false } = options;
  const ctx = { path, branch, mask: mask3 };
  if (coerce4) {
    value = struct52.coercer(value, ctx);
  }
  let status = "valid";
  for (const failure of struct52.validator(value, ctx)) {
    failure.explanation = options.message;
    status = "not_valid";
    yield [failure, void 0];
  }
  for (let [k, v, s] of struct52.entries(value, ctx)) {
    const ts = run(v, s, {
      path: k === void 0 ? path : [...path, k],
      branch: k === void 0 ? branch : [...branch, v],
      coerce: coerce4,
      mask: mask3,
      message: options.message
    });
    for (const t of ts) {
      if (t[0]) {
        status = t[0].refinement != null ? "not_refined" : "not_valid";
        yield [t[0], void 0];
      } else if (coerce4) {
        v = t[1];
        if (k === void 0) {
          value = v;
        } else if (value instanceof Map) {
          value.set(k, v);
        } else if (value instanceof Set) {
          value.add(v);
        } else if (isObject(value)) {
          if (v !== void 0 || k in value)
            value[k] = v;
        }
      }
    }
  }
  if (status !== "not_valid") {
    for (const failure of struct52.refiner(value, ctx)) {
      failure.explanation = options.message;
      status = "not_refined";
      yield [failure, void 0];
    }
  }
  if (status === "valid") {
    yield [void 0, value];
  }
}
function assert(value, struct52, message) {
  const result = validate(value, struct52, { message });
  if (result[0]) {
    throw result[0];
  }
}
function create(value, struct52, message) {
  const result = validate(value, struct52, { coerce: true, message });
  if (result[0]) {
    throw result[0];
  } else {
    return result[1];
  }
}
function mask(value, struct52, message) {
  const result = validate(value, struct52, { coerce: true, mask: true, message });
  if (result[0]) {
    throw result[0];
  } else {
    return result[1];
  }
}
function is(value, struct52) {
  const result = validate(value, struct52);
  return !result[0];
}
function validate(value, struct52, options = {}) {
  const tuples = run(value, struct52, options);
  const tuple2 = shiftIterator(tuples);
  if (tuple2[0]) {
    const error = new StructError(tuple2[0], function* () {
      for (const t of tuples) {
        if (t[0]) {
          yield t[0];
        }
      }
    });
    return [error, void 0];
  } else {
    const v = tuple2[1];
    return [void 0, v];
  }
}
function define2(name, validator) {
  return new Struct({ type: name, schema: null, validator });
}
function any() {
  return define2("any", () => true);
}
function array(Element) {
  return new Struct({
    type: "array",
    schema: Element,
    *entries(value) {
      if (Element && Array.isArray(value)) {
        for (const [i, v] of value.entries()) {
          yield [i, v, Element];
        }
      }
    },
    coercer(value) {
      return Array.isArray(value) ? value.slice() : value;
    },
    validator(value) {
      return Array.isArray(value) || `Expected an array value, but received: ${print(value)}`;
    }
  });
}
function boolean() {
  return define2("boolean", (value) => {
    return typeof value === "boolean";
  });
}
function instance(Class) {
  return define2("instance", (value) => {
    return value instanceof Class || `Expected a \`${Class.name}\` instance, but received: ${print(value)}`;
  });
}
function literal(constant2) {
  const description = print(constant2);
  const t = typeof constant2;
  return new Struct({
    type: "literal",
    schema: t === "string" || t === "number" || t === "boolean" ? constant2 : null,
    validator(value) {
      return value === constant2 || `Expected the literal \`${description}\`, but received: ${print(value)}`;
    }
  });
}
function never() {
  return define2("never", () => false);
}
function nullable(struct52) {
  return new Struct({
    ...struct52,
    validator: (value, ctx) => value === null || struct52.validator(value, ctx),
    refiner: (value, ctx) => value === null || struct52.refiner(value, ctx)
  });
}
function number() {
  return define2("number", (value) => {
    return typeof value === "number" && !isNaN(value) || `Expected a number, but received: ${print(value)}`;
  });
}
function optional(struct52) {
  return new Struct({
    ...struct52,
    validator: (value, ctx) => value === void 0 || struct52.validator(value, ctx),
    refiner: (value, ctx) => value === void 0 || struct52.refiner(value, ctx)
  });
}
function record(Key, Value) {
  return new Struct({
    type: "record",
    schema: null,
    *entries(value) {
      if (isObject(value)) {
        for (const k in value) {
          const v = value[k];
          yield [k, k, Key];
          yield [k, v, Value];
        }
      }
    },
    validator(value) {
      return isNonArrayObject(value) || `Expected an object, but received: ${print(value)}`;
    },
    coercer(value) {
      return isNonArrayObject(value) ? { ...value } : value;
    }
  });
}
function string() {
  return define2("string", (value) => {
    return typeof value === "string" || `Expected a string, but received: ${print(value)}`;
  });
}
function tuple(Structs) {
  const Never = never();
  return new Struct({
    type: "tuple",
    schema: null,
    *entries(value) {
      if (Array.isArray(value)) {
        const length2 = Math.max(Structs.length, value.length);
        for (let i = 0; i < length2; i++) {
          yield [i, value[i], Structs[i] || Never];
        }
      }
    },
    validator(value) {
      return Array.isArray(value) || `Expected an array, but received: ${print(value)}`;
    },
    coercer(value) {
      return Array.isArray(value) ? value.slice() : value;
    }
  });
}
function type(schema) {
  const keys = Object.keys(schema);
  return new Struct({
    type: "type",
    schema,
    *entries(value) {
      if (isObject(value)) {
        for (const k of keys) {
          yield [k, value[k], schema[k]];
        }
      }
    },
    validator(value) {
      return isNonArrayObject(value) || `Expected an object, but received: ${print(value)}`;
    },
    coercer(value) {
      return isNonArrayObject(value) ? { ...value } : value;
    }
  });
}
function union(Structs) {
  const description = Structs.map((s) => s.type).join(" | ");
  return new Struct({
    type: "union",
    schema: null,
    coercer(value, ctx) {
      for (const S of Structs) {
        const [error, coerced] = S.validate(value, {
          coerce: true,
          mask: ctx.mask
        });
        if (!error) {
          return coerced;
        }
      }
      return value;
    },
    validator(value, ctx) {
      const failures = [];
      for (const S of Structs) {
        const [...tuples] = run(value, S, ctx);
        const [first] = tuples;
        if (!first[0]) {
          return [];
        } else {
          for (const [failure] of tuples) {
            if (failure) {
              failures.push(failure);
            }
          }
        }
      }
      return [
        `Expected the value to satisfy a union of \`${description}\`, but received: ${print(value)}`,
        ...failures
      ];
    }
  });
}
function unknown() {
  return define2("unknown", () => true);
}
function coerce(struct52, condition, coercer) {
  return new Struct({
    ...struct52,
    coercer: (value, ctx) => {
      return is(value, condition) ? struct52.coercer(coercer(value, ctx), ctx) : struct52.coercer(value, ctx);
    }
  });
}
var StructError, Struct;
var init_dist5 = __esm({
  "node_modules/@solana/web3.js/node_modules/superstruct/dist/index.mjs"() {
    StructError = class extends TypeError {
      constructor(failure, failures) {
        let cached;
        const { message, explanation, ...rest } = failure;
        const { path } = failure;
        const msg = path.length === 0 ? message : `At path: ${path.join(".")} -- ${message}`;
        super(explanation ?? msg);
        if (explanation != null)
          this.cause = msg;
        Object.assign(this, rest);
        this.name = this.constructor.name;
        this.failures = () => {
          return cached ?? (cached = [failure, ...failures()]);
        };
      }
    };
    Struct = class {
      constructor(props) {
        const { type: type3, schema, validator, refiner, coercer = (value) => value, entries = function* () {
        } } = props;
        this.type = type3;
        this.schema = schema;
        this.entries = entries;
        this.coercer = coercer;
        if (validator) {
          this.validator = (value, context) => {
            const result = validator(value, context);
            return toFailures(result, context, this, value);
          };
        } else {
          this.validator = () => [];
        }
        if (refiner) {
          this.refiner = (value, context) => {
            const result = refiner(value, context);
            return toFailures(result, context, this, value);
          };
        } else {
          this.refiner = () => [];
        }
      }
      /**
       * Assert that a value passes the struct's validation, throwing if it doesn't.
       */
      assert(value, message) {
        return assert(value, this, message);
      }
      /**
       * Create a value with the struct's coercion logic, then validate it.
       */
      create(value, message) {
        return create(value, this, message);
      }
      /**
       * Check if a value passes the struct's validation.
       */
      is(value) {
        return is(value, this);
      }
      /**
       * Mask a value, coercing and validating it, but returning only the subset of
       * properties defined by the struct's schema. Masking applies recursively to
       * props of `object` structs only.
       */
      mask(value, message) {
        return mask(value, this, message);
      }
      /**
       * Validate a value with the struct's validation logic, returning a tuple
       * representing the result.
       *
       * You may optionally pass `true` for the `coerce` argument to coerce
       * the value before attempting to validate it. If you do, the result will
       * contain the coerced result when successful. Also, `mask` will turn on
       * masking of the unknown `object` props recursively if passed.
       */
      validate(value, options = {}) {
        return validate(value, this, options);
      }
    };
  }
});

// node_modules/uuid/dist/esm-browser/rng.js
function rng() {
  if (!getRandomValues) {
    getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== "undefined" && typeof msCrypto.getRandomValues === "function" && msCrypto.getRandomValues.bind(msCrypto);
    if (!getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues(rnds8);
}
var getRandomValues, rnds8;
var init_rng = __esm({
  "node_modules/uuid/dist/esm-browser/rng.js"() {
    rnds8 = new Uint8Array(16);
  }
});

// node_modules/uuid/dist/esm-browser/regex.js
var regex_default;
var init_regex = __esm({
  "node_modules/uuid/dist/esm-browser/regex.js"() {
    regex_default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
  }
});

// node_modules/uuid/dist/esm-browser/validate.js
function validate2(uuid) {
  return typeof uuid === "string" && regex_default.test(uuid);
}
var validate_default;
var init_validate = __esm({
  "node_modules/uuid/dist/esm-browser/validate.js"() {
    init_regex();
    validate_default = validate2;
  }
});

// node_modules/uuid/dist/esm-browser/stringify.js
function stringify2(arr) {
  var offset3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  var uuid = (byteToHex[arr[offset3 + 0]] + byteToHex[arr[offset3 + 1]] + byteToHex[arr[offset3 + 2]] + byteToHex[arr[offset3 + 3]] + "-" + byteToHex[arr[offset3 + 4]] + byteToHex[arr[offset3 + 5]] + "-" + byteToHex[arr[offset3 + 6]] + byteToHex[arr[offset3 + 7]] + "-" + byteToHex[arr[offset3 + 8]] + byteToHex[arr[offset3 + 9]] + "-" + byteToHex[arr[offset3 + 10]] + byteToHex[arr[offset3 + 11]] + byteToHex[arr[offset3 + 12]] + byteToHex[arr[offset3 + 13]] + byteToHex[arr[offset3 + 14]] + byteToHex[arr[offset3 + 15]]).toLowerCase();
  if (!validate_default(uuid)) {
    throw TypeError("Stringified UUID is invalid");
  }
  return uuid;
}
var byteToHex, i, stringify_default;
var init_stringify = __esm({
  "node_modules/uuid/dist/esm-browser/stringify.js"() {
    init_validate();
    byteToHex = [];
    for (i = 0; i < 256; ++i) {
      byteToHex.push((i + 256).toString(16).substr(1));
    }
    stringify_default = stringify2;
  }
});

// node_modules/uuid/dist/esm-browser/v1.js
function v1(options, buf, offset3) {
  var i = buf && offset3 || 0;
  var b = buf || new Array(16);
  options = options || {};
  var node = options.node || _nodeId;
  var clockseq = options.clockseq !== void 0 ? options.clockseq : _clockseq;
  if (node == null || clockseq == null) {
    var seedBytes = options.random || (options.rng || rng)();
    if (node == null) {
      node = _nodeId = [seedBytes[0] | 1, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
    }
    if (clockseq == null) {
      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;
    }
  }
  var msecs = options.msecs !== void 0 ? options.msecs : Date.now();
  var nsecs = options.nsecs !== void 0 ? options.nsecs : _lastNSecs + 1;
  var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
  if (dt < 0 && options.clockseq === void 0) {
    clockseq = clockseq + 1 & 16383;
  }
  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === void 0) {
    nsecs = 0;
  }
  if (nsecs >= 1e4) {
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  }
  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq;
  msecs += 122192928e5;
  var tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
  b[i++] = tl >>> 24 & 255;
  b[i++] = tl >>> 16 & 255;
  b[i++] = tl >>> 8 & 255;
  b[i++] = tl & 255;
  var tmh = msecs / 4294967296 * 1e4 & 268435455;
  b[i++] = tmh >>> 8 & 255;
  b[i++] = tmh & 255;
  b[i++] = tmh >>> 24 & 15 | 16;
  b[i++] = tmh >>> 16 & 255;
  b[i++] = clockseq >>> 8 | 128;
  b[i++] = clockseq & 255;
  for (var n = 0; n < 6; ++n) {
    b[i + n] = node[n];
  }
  return buf || stringify_default(b);
}
var _nodeId, _clockseq, _lastMSecs, _lastNSecs, v1_default;
var init_v1 = __esm({
  "node_modules/uuid/dist/esm-browser/v1.js"() {
    init_rng();
    init_stringify();
    _lastMSecs = 0;
    _lastNSecs = 0;
    v1_default = v1;
  }
});

// node_modules/uuid/dist/esm-browser/parse.js
function parse(uuid) {
  if (!validate_default(uuid)) {
    throw TypeError("Invalid UUID");
  }
  var v;
  var arr = new Uint8Array(16);
  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
  arr[1] = v >>> 16 & 255;
  arr[2] = v >>> 8 & 255;
  arr[3] = v & 255;
  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
  arr[5] = v & 255;
  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
  arr[7] = v & 255;
  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
  arr[9] = v & 255;
  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255;
  arr[11] = v / 4294967296 & 255;
  arr[12] = v >>> 24 & 255;
  arr[13] = v >>> 16 & 255;
  arr[14] = v >>> 8 & 255;
  arr[15] = v & 255;
  return arr;
}
var parse_default;
var init_parse = __esm({
  "node_modules/uuid/dist/esm-browser/parse.js"() {
    init_validate();
    parse_default = parse;
  }
});

// node_modules/uuid/dist/esm-browser/v35.js
function stringToBytes3(str2) {
  str2 = unescape(encodeURIComponent(str2));
  var bytes3 = [];
  for (var i = 0; i < str2.length; ++i) {
    bytes3.push(str2.charCodeAt(i));
  }
  return bytes3;
}
function v35_default(name, version3, hashfunc) {
  function generateUUID(value, namespace, buf, offset3) {
    if (typeof value === "string") {
      value = stringToBytes3(value);
    }
    if (typeof namespace === "string") {
      namespace = parse_default(namespace);
    }
    if (namespace.length !== 16) {
      throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
    }
    var bytes3 = new Uint8Array(16 + value.length);
    bytes3.set(namespace);
    bytes3.set(value, namespace.length);
    bytes3 = hashfunc(bytes3);
    bytes3[6] = bytes3[6] & 15 | version3;
    bytes3[8] = bytes3[8] & 63 | 128;
    if (buf) {
      offset3 = offset3 || 0;
      for (var i = 0; i < 16; ++i) {
        buf[offset3 + i] = bytes3[i];
      }
      return buf;
    }
    return stringify_default(bytes3);
  }
  try {
    generateUUID.name = name;
  } catch (err2) {
  }
  generateUUID.DNS = DNS;
  generateUUID.URL = URL2;
  return generateUUID;
}
var DNS, URL2;
var init_v35 = __esm({
  "node_modules/uuid/dist/esm-browser/v35.js"() {
    init_stringify();
    init_parse();
    DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
    URL2 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
  }
});

// node_modules/uuid/dist/esm-browser/md5.js
function md5(bytes3) {
  if (typeof bytes3 === "string") {
    var msg = unescape(encodeURIComponent(bytes3));
    bytes3 = new Uint8Array(msg.length);
    for (var i = 0; i < msg.length; ++i) {
      bytes3[i] = msg.charCodeAt(i);
    }
  }
  return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes3), bytes3.length * 8));
}
function md5ToHexEncodedArray(input) {
  var output4 = [];
  var length32 = input.length * 32;
  var hexTab = "0123456789abcdef";
  for (var i = 0; i < length32; i += 8) {
    var x = input[i >> 5] >>> i % 32 & 255;
    var hex3 = parseInt(hexTab.charAt(x >>> 4 & 15) + hexTab.charAt(x & 15), 16);
    output4.push(hex3);
  }
  return output4;
}
function getOutputLength(inputLength8) {
  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
}
function wordsToMd5(x, len) {
  x[len >> 5] |= 128 << len % 32;
  x[getOutputLength(len) - 1] = len;
  var a = 1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d = 271733878;
  for (var i = 0; i < x.length; i += 16) {
    var olda = a;
    var oldb = b;
    var oldc = c;
    var oldd = d;
    a = md5ff(a, b, c, d, x[i], 7, -680876936);
    d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);
    c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);
    b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);
    a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);
    d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);
    c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);
    b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);
    a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);
    d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);
    c = md5ff(c, d, a, b, x[i + 10], 17, -42063);
    b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);
    a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);
    d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);
    c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);
    b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);
    a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);
    d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);
    c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);
    b = md5gg(b, c, d, a, x[i], 20, -373897302);
    a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);
    d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);
    c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);
    b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);
    a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);
    d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);
    c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);
    b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);
    a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);
    d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);
    c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);
    b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);
    a = md5hh(a, b, c, d, x[i + 5], 4, -378558);
    d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);
    c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);
    b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);
    a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);
    d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);
    c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);
    b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);
    a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);
    d = md5hh(d, a, b, c, x[i], 11, -358537222);
    c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);
    b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);
    a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);
    d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);
    c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);
    b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);
    a = md5ii(a, b, c, d, x[i], 6, -198630844);
    d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);
    c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);
    b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);
    a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);
    d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);
    c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);
    b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);
    a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);
    d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);
    c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);
    b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);
    a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);
    d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);
    c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);
    b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);
    a = safeAdd(a, olda);
    b = safeAdd(b, oldb);
    c = safeAdd(c, oldc);
    d = safeAdd(d, oldd);
  }
  return [a, b, c, d];
}
function bytesToWords(input) {
  if (input.length === 0) {
    return [];
  }
  var length8 = input.length * 8;
  var output4 = new Uint32Array(getOutputLength(length8));
  for (var i = 0; i < length8; i += 8) {
    output4[i >> 5] |= (input[i / 8] & 255) << i % 32;
  }
  return output4;
}
function safeAdd(x, y) {
  var lsw = (x & 65535) + (y & 65535);
  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return msw << 16 | lsw & 65535;
}
function bitRotateLeft(num2, cnt) {
  return num2 << cnt | num2 >>> 32 - cnt;
}
function md5cmn(q, a, b, x, s, t) {
  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);
}
function md5ff(a, b, c, d, x, s, t) {
  return md5cmn(b & c | ~b & d, a, b, x, s, t);
}
function md5gg(a, b, c, d, x, s, t) {
  return md5cmn(b & d | c & ~d, a, b, x, s, t);
}
function md5hh(a, b, c, d, x, s, t) {
  return md5cmn(b ^ c ^ d, a, b, x, s, t);
}
function md5ii(a, b, c, d, x, s, t) {
  return md5cmn(c ^ (b | ~d), a, b, x, s, t);
}
var md5_default;
var init_md5 = __esm({
  "node_modules/uuid/dist/esm-browser/md5.js"() {
    md5_default = md5;
  }
});

// node_modules/uuid/dist/esm-browser/v3.js
var v3, v3_default;
var init_v3 = __esm({
  "node_modules/uuid/dist/esm-browser/v3.js"() {
    init_v35();
    init_md5();
    v3 = v35_default("v3", 48, md5_default);
    v3_default = v3;
  }
});

// node_modules/uuid/dist/esm-browser/v4.js
function v4(options, buf, offset3) {
  options = options || {};
  var rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset3 = offset3 || 0;
    for (var i = 0; i < 16; ++i) {
      buf[offset3 + i] = rnds[i];
    }
    return buf;
  }
  return stringify_default(rnds);
}
var v4_default;
var init_v4 = __esm({
  "node_modules/uuid/dist/esm-browser/v4.js"() {
    init_rng();
    init_stringify();
    v4_default = v4;
  }
});

// node_modules/uuid/dist/esm-browser/sha1.js
function f2(s, x, y, z2) {
  switch (s) {
    case 0:
      return x & y ^ ~x & z2;
    case 1:
      return x ^ y ^ z2;
    case 2:
      return x & y ^ x & z2 ^ y & z2;
    case 3:
      return x ^ y ^ z2;
  }
}
function ROTL(x, n) {
  return x << n | x >>> 32 - n;
}
function sha1(bytes3) {
  var K = [1518500249, 1859775393, 2400959708, 3395469782];
  var H = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
  if (typeof bytes3 === "string") {
    var msg = unescape(encodeURIComponent(bytes3));
    bytes3 = [];
    for (var i = 0; i < msg.length; ++i) {
      bytes3.push(msg.charCodeAt(i));
    }
  } else if (!Array.isArray(bytes3)) {
    bytes3 = Array.prototype.slice.call(bytes3);
  }
  bytes3.push(128);
  var l = bytes3.length / 4 + 2;
  var N = Math.ceil(l / 16);
  var M = new Array(N);
  for (var _i = 0; _i < N; ++_i) {
    var arr = new Uint32Array(16);
    for (var j = 0; j < 16; ++j) {
      arr[j] = bytes3[_i * 64 + j * 4] << 24 | bytes3[_i * 64 + j * 4 + 1] << 16 | bytes3[_i * 64 + j * 4 + 2] << 8 | bytes3[_i * 64 + j * 4 + 3];
    }
    M[_i] = arr;
  }
  M[N - 1][14] = (bytes3.length - 1) * 8 / Math.pow(2, 32);
  M[N - 1][14] = Math.floor(M[N - 1][14]);
  M[N - 1][15] = (bytes3.length - 1) * 8 & 4294967295;
  for (var _i2 = 0; _i2 < N; ++_i2) {
    var W = new Uint32Array(80);
    for (var t = 0; t < 16; ++t) {
      W[t] = M[_i2][t];
    }
    for (var _t = 16; _t < 80; ++_t) {
      W[_t] = ROTL(W[_t - 3] ^ W[_t - 8] ^ W[_t - 14] ^ W[_t - 16], 1);
    }
    var a = H[0];
    var b = H[1];
    var c = H[2];
    var d = H[3];
    var e = H[4];
    for (var _t2 = 0; _t2 < 80; ++_t2) {
      var s = Math.floor(_t2 / 20);
      var T = ROTL(a, 5) + f2(s, b, c, d) + e + K[s] + W[_t2] >>> 0;
      e = d;
      d = c;
      c = ROTL(b, 30) >>> 0;
      b = a;
      a = T;
    }
    H[0] = H[0] + a >>> 0;
    H[1] = H[1] + b >>> 0;
    H[2] = H[2] + c >>> 0;
    H[3] = H[3] + d >>> 0;
    H[4] = H[4] + e >>> 0;
  }
  return [H[0] >> 24 & 255, H[0] >> 16 & 255, H[0] >> 8 & 255, H[0] & 255, H[1] >> 24 & 255, H[1] >> 16 & 255, H[1] >> 8 & 255, H[1] & 255, H[2] >> 24 & 255, H[2] >> 16 & 255, H[2] >> 8 & 255, H[2] & 255, H[3] >> 24 & 255, H[3] >> 16 & 255, H[3] >> 8 & 255, H[3] & 255, H[4] >> 24 & 255, H[4] >> 16 & 255, H[4] >> 8 & 255, H[4] & 255];
}
var sha1_default;
var init_sha1 = __esm({
  "node_modules/uuid/dist/esm-browser/sha1.js"() {
    sha1_default = sha1;
  }
});

// node_modules/uuid/dist/esm-browser/v5.js
var v5, v5_default;
var init_v5 = __esm({
  "node_modules/uuid/dist/esm-browser/v5.js"() {
    init_v35();
    init_sha1();
    v5 = v35_default("v5", 80, sha1_default);
    v5_default = v5;
  }
});

// node_modules/uuid/dist/esm-browser/nil.js
var nil_default;
var init_nil = __esm({
  "node_modules/uuid/dist/esm-browser/nil.js"() {
    nil_default = "00000000-0000-0000-0000-000000000000";
  }
});

// node_modules/uuid/dist/esm-browser/version.js
function version(uuid) {
  if (!validate_default(uuid)) {
    throw TypeError("Invalid UUID");
  }
  return parseInt(uuid.substr(14, 1), 16);
}
var version_default;
var init_version = __esm({
  "node_modules/uuid/dist/esm-browser/version.js"() {
    init_validate();
    version_default = version;
  }
});

// node_modules/uuid/dist/esm-browser/index.js
var esm_browser_exports = {};
__export(esm_browser_exports, {
  NIL: () => nil_default,
  parse: () => parse_default,
  stringify: () => stringify_default,
  v1: () => v1_default,
  v3: () => v3_default,
  v4: () => v4_default,
  v5: () => v5_default,
  validate: () => validate_default,
  version: () => version_default
});
var init_esm_browser = __esm({
  "node_modules/uuid/dist/esm-browser/index.js"() {
    init_v1();
    init_v3();
    init_v4();
    init_v5();
    init_nil();
    init_version();
    init_validate();
    init_stringify();
    init_parse();
  }
});

// node_modules/jayson/lib/generateRequest.js
var require_generateRequest = __commonJS({
  "node_modules/jayson/lib/generateRequest.js"(exports2, module2) {
    "use strict";
    var uuid = (init_esm_browser(), __toCommonJS(esm_browser_exports)).v4;
    var generateRequest = function(method, params, id, options) {
      if (typeof method !== "string") {
        throw new TypeError(method + " must be a string");
      }
      options = options || {};
      const version3 = typeof options.version === "number" ? options.version : 2;
      if (version3 !== 1 && version3 !== 2) {
        throw new TypeError(version3 + " must be 1 or 2");
      }
      const request = {
        method
      };
      if (version3 === 2) {
        request.jsonrpc = "2.0";
      }
      if (params) {
        if (typeof params !== "object" && !Array.isArray(params)) {
          throw new TypeError(params + " must be an object, array or omitted");
        }
        request.params = params;
      }
      if (typeof id === "undefined") {
        const generator = typeof options.generator === "function" ? options.generator : function() {
          return uuid();
        };
        request.id = generator(request, options);
      } else if (version3 === 2 && id === null) {
        if (options.notificationIdNull) {
          request.id = null;
        }
      } else {
        request.id = id;
      }
      return request;
    };
    module2.exports = generateRequest;
  }
});

// node_modules/jayson/lib/client/browser/index.js
var require_browser = __commonJS({
  "node_modules/jayson/lib/client/browser/index.js"(exports2, module2) {
    "use strict";
    var uuid = (init_esm_browser(), __toCommonJS(esm_browser_exports)).v4;
    var generateRequest = require_generateRequest();
    var ClientBrowser = function(callServer, options) {
      if (!(this instanceof ClientBrowser)) {
        return new ClientBrowser(callServer, options);
      }
      if (!options) {
        options = {};
      }
      this.options = {
        reviver: typeof options.reviver !== "undefined" ? options.reviver : null,
        replacer: typeof options.replacer !== "undefined" ? options.replacer : null,
        generator: typeof options.generator !== "undefined" ? options.generator : function() {
          return uuid();
        },
        version: typeof options.version !== "undefined" ? options.version : 2,
        notificationIdNull: typeof options.notificationIdNull === "boolean" ? options.notificationIdNull : false
      };
      this.callServer = callServer;
    };
    module2.exports = ClientBrowser;
    ClientBrowser.prototype.request = function(method, params, id, callback) {
      const self2 = this;
      let request = null;
      const isBatch = Array.isArray(method) && typeof params === "function";
      if (this.options.version === 1 && isBatch) {
        throw new TypeError("JSON-RPC 1.0 does not support batching");
      }
      const isRaw = !isBatch && method && typeof method === "object" && typeof params === "function";
      if (isBatch || isRaw) {
        callback = params;
        request = method;
      } else {
        if (typeof id === "function") {
          callback = id;
          id = void 0;
        }
        const hasCallback = typeof callback === "function";
        try {
          request = generateRequest(method, params, id, {
            generator: this.options.generator,
            version: this.options.version,
            notificationIdNull: this.options.notificationIdNull
          });
        } catch (err2) {
          if (hasCallback) {
            return callback(err2);
          }
          throw err2;
        }
        if (!hasCallback) {
          return request;
        }
      }
      let message;
      try {
        message = JSON.stringify(request, this.options.replacer);
      } catch (err2) {
        return callback(err2);
      }
      this.callServer(message, function(err2, response) {
        self2._parseResponse(err2, response, callback);
      });
      return request;
    };
    ClientBrowser.prototype._parseResponse = function(err2, responseText, callback) {
      if (err2) {
        callback(err2);
        return;
      }
      if (!responseText) {
        return callback();
      }
      let response;
      try {
        response = JSON.parse(responseText, this.options.reviver);
      } catch (err3) {
        return callback(err3);
      }
      if (callback.length === 3) {
        if (Array.isArray(response)) {
          const isError = function(res) {
            return typeof res.error !== "undefined";
          };
          const isNotError = function(res) {
            return !isError(res);
          };
          return callback(null, response.filter(isError), response.filter(isNotError));
        } else {
          return callback(null, response.error, response.result);
        }
      }
      callback(null, response);
    };
  }
});

// node_modules/rpc-websockets/node_modules/eventemitter3/index.js
var require_eventemitter3 = __commonJS({
  "node_modules/rpc-websockets/node_modules/eventemitter3/index.js"(exports2, module2) {
    "use strict";
    var has = Object.prototype.hasOwnProperty;
    var prefix = "~";
    function Events() {
    }
    if (Object.create) {
      Events.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events().__proto__) prefix = false;
    }
    function EE(fn, context, once) {
      this.fn = fn;
      this.context = context;
      this.once = once || false;
    }
    function addListener(emitter, event, fn, context, once) {
      if (typeof fn !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
      if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
      else emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0) emitter._events = new Events();
      else delete emitter._events[evt];
    }
    function EventEmitter4() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    EventEmitter4.prototype.eventNames = function eventNames() {
      var names = [], events2, name;
      if (this._eventsCount === 0) return names;
      for (name in events2 = this._events) {
        if (has.call(events2, name)) names.push(prefix ? name.slice(1) : name);
      }
      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events2));
      }
      return names;
    };
    EventEmitter4.prototype.listeners = function listeners(event) {
      var evt = prefix ? prefix + event : event, handlers = this._events[evt];
      if (!handlers) return [];
      if (handlers.fn) return [handlers.fn];
      for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
        ee[i] = handlers[i].fn;
      }
      return ee;
    };
    EventEmitter4.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix ? prefix + event : event, listeners = this._events[evt];
      if (!listeners) return 0;
      if (listeners.fn) return 1;
      return listeners.length;
    };
    EventEmitter4.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return false;
      var listeners = this._events[evt], len = arguments.length, args, i;
      if (listeners.fn) {
        if (listeners.once) this.removeListener(event, listeners.fn, void 0, true);
        switch (len) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a2), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a2, a3), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
          case 6:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
        }
        for (i = 1, args = new Array(len - 1); i < len; i++) {
          args[i - 1] = arguments[i];
        }
        listeners.fn.apply(listeners.context, args);
      } else {
        var length2 = listeners.length, j;
        for (i = 0; i < length2; i++) {
          if (listeners[i].once) this.removeListener(event, listeners[i].fn, void 0, true);
          switch (len) {
            case 1:
              listeners[i].fn.call(listeners[i].context);
              break;
            case 2:
              listeners[i].fn.call(listeners[i].context, a1);
              break;
            case 3:
              listeners[i].fn.call(listeners[i].context, a1, a2);
              break;
            case 4:
              listeners[i].fn.call(listeners[i].context, a1, a2, a3);
              break;
            default:
              if (!args) for (j = 1, args = new Array(len - 1); j < len; j++) {
                args[j - 1] = arguments[j];
              }
              listeners[i].fn.apply(listeners[i].context, args);
          }
        }
      }
      return true;
    };
    EventEmitter4.prototype.on = function on(event, fn, context) {
      return addListener(this, event, fn, context, false);
    };
    EventEmitter4.prototype.once = function once(event, fn, context) {
      return addListener(this, event, fn, context, true);
    };
    EventEmitter4.prototype.removeListener = function removeListener(event, fn, context, once) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return this;
      if (!fn) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i = 0, events2 = [], length2 = listeners.length; i < length2; i++) {
          if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
            events2.push(listeners[i]);
          }
        }
        if (events2.length) this._events[evt] = events2.length === 1 ? events2[0] : events2;
        else clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter4.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt]) clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter4.prototype.off = EventEmitter4.prototype.removeListener;
    EventEmitter4.prototype.addListener = EventEmitter4.prototype.on;
    EventEmitter4.prefixed = prefix;
    EventEmitter4.EventEmitter = EventEmitter4;
    if ("undefined" !== typeof module2) {
      module2.exports = EventEmitter4;
    }
  }
});

// node_modules/rpc-websockets/node_modules/eventemitter3/index.mjs
var import_index;
var init_eventemitter3 = __esm({
  "node_modules/rpc-websockets/node_modules/eventemitter3/index.mjs"() {
    import_index = __toESM(require_eventemitter3(), 1);
  }
});

// node_modules/rpc-websockets/dist/index.browser.mjs
function WebSocket(address, options) {
  return new WebSocketBrowserImpl(address, options);
}
var import_buffer, WebSocketBrowserImpl, DefaultDataPack, CommonClient;
var init_index_browser4 = __esm({
  "node_modules/rpc-websockets/dist/index.browser.mjs"() {
    import_buffer = __toESM(require_buffer(), 1);
    init_eventemitter3();
    WebSocketBrowserImpl = class extends import_index.default {
      /** Instantiate a WebSocket class
      * @constructor
      * @param {String} address - url to a websocket server
      * @param {(Object)} options - websocket options
      * @param {(String|Array)} protocols - a list of protocols
      * @return {WebSocketBrowserImpl} - returns a WebSocket instance
      */
      constructor(address, options, protocols) {
        super();
        __publicField(this, "socket");
        this.socket = new window.WebSocket(address, protocols);
        this.socket.onopen = () => this.emit("open");
        this.socket.onmessage = (event) => this.emit("message", event.data);
        this.socket.onerror = (error) => this.emit("error", error);
        this.socket.onclose = (event) => {
          this.emit("close", event.code, event.reason);
        };
      }
      /**
      * Sends data through a websocket connection
      * @method
      * @param {(String|Object)} data - data to be sent via websocket
      * @param {Object} optionsOrCallback - ws options
      * @param {Function} callback - a callback called once the data is sent
      * @return {Undefined}
      */
      send(data, optionsOrCallback, callback) {
        const cb = callback || optionsOrCallback;
        try {
          this.socket.send(data);
          cb();
        } catch (error) {
          cb(error);
        }
      }
      /**
      * Closes an underlying socket
      * @method
      * @param {Number} code - status code explaining why the connection is being closed
      * @param {String} reason - a description why the connection is closing
      * @return {Undefined}
      * @throws {Error}
      */
      close(code2, reason) {
        this.socket.close(code2, reason);
      }
      addEventListener(type3, listener, options) {
        this.socket.addEventListener(type3, listener, options);
      }
    };
    DefaultDataPack = class {
      encode(value) {
        return JSON.stringify(value);
      }
      decode(value) {
        return JSON.parse(value);
      }
    };
    CommonClient = class extends import_index.default {
      /**
      * Instantiate a Client class.
      * @constructor
      * @param {webSocketFactory} webSocketFactory - factory method for WebSocket
      * @param {String} address - url to a websocket server
      * @param {Object} options - ws options object with reconnect parameters
      * @param {Function} generate_request_id - custom generation request Id
      * @param {DataPack} dataPack - data pack contains encoder and decoder
      * @return {CommonClient}
      */
      constructor(webSocketFactory, address = "ws://localhost:8080", {
        autoconnect = true,
        reconnect = true,
        reconnect_interval = 1e3,
        max_reconnects = 5,
        ...rest_options
      } = {}, generate_request_id, dataPack) {
        super();
        __publicField(this, "address");
        __publicField(this, "rpc_id");
        __publicField(this, "queue");
        __publicField(this, "options");
        __publicField(this, "autoconnect");
        __publicField(this, "ready");
        __publicField(this, "reconnect");
        __publicField(this, "reconnect_timer_id");
        __publicField(this, "reconnect_interval");
        __publicField(this, "max_reconnects");
        __publicField(this, "rest_options");
        __publicField(this, "current_reconnects");
        __publicField(this, "generate_request_id");
        __publicField(this, "socket");
        __publicField(this, "webSocketFactory");
        __publicField(this, "dataPack");
        this.webSocketFactory = webSocketFactory;
        this.queue = {};
        this.rpc_id = 0;
        this.address = address;
        this.autoconnect = autoconnect;
        this.ready = false;
        this.reconnect = reconnect;
        this.reconnect_timer_id = void 0;
        this.reconnect_interval = reconnect_interval;
        this.max_reconnects = max_reconnects;
        this.rest_options = rest_options;
        this.current_reconnects = 0;
        this.generate_request_id = generate_request_id || (() => typeof this.rpc_id === "number" ? ++this.rpc_id : Number(this.rpc_id) + 1);
        if (!dataPack) this.dataPack = new DefaultDataPack();
        else this.dataPack = dataPack;
        if (this.autoconnect)
          this._connect(this.address, {
            autoconnect: this.autoconnect,
            reconnect: this.reconnect,
            reconnect_interval: this.reconnect_interval,
            max_reconnects: this.max_reconnects,
            ...this.rest_options
          });
      }
      /**
      * Connects to a defined server if not connected already.
      * @method
      * @return {Undefined}
      */
      connect() {
        if (this.socket) return;
        this._connect(this.address, {
          autoconnect: this.autoconnect,
          reconnect: this.reconnect,
          reconnect_interval: this.reconnect_interval,
          max_reconnects: this.max_reconnects,
          ...this.rest_options
        });
      }
      /**
      * Calls a registered RPC method on server.
      * @method
      * @param {String} method - RPC method name
      * @param {Object|Array} params - optional method parameters
      * @param {Number} timeout - RPC reply timeout value
      * @param {Object} ws_opts - options passed to ws
      * @return {Promise}
      */
      call(method, params, timeout, ws_opts) {
        if (!ws_opts && "object" === typeof timeout) {
          ws_opts = timeout;
          timeout = null;
        }
        return new Promise((resolve2, reject2) => {
          if (!this.ready) return reject2(new Error("socket not ready"));
          const rpc_id = this.generate_request_id(method, params);
          const message = {
            jsonrpc: "2.0",
            method,
            params: params || void 0,
            id: rpc_id
          };
          this.socket.send(this.dataPack.encode(message), ws_opts, (error) => {
            if (error) return reject2(error);
            this.queue[rpc_id] = { promise: [resolve2, reject2] };
            if (timeout) {
              this.queue[rpc_id].timeout = setTimeout(() => {
                delete this.queue[rpc_id];
                reject2(new Error("reply timeout"));
              }, timeout);
            }
          });
        });
      }
      /**
      * Logins with the other side of the connection.
      * @method
      * @param {Object} params - Login credentials object
      * @return {Promise}
      */
      async login(params) {
        const resp = await this.call("rpc.login", params);
        if (!resp) throw new Error("authentication failed");
        return resp;
      }
      /**
      * Fetches a list of client's methods registered on server.
      * @method
      * @return {Array}
      */
      async listMethods() {
        return await this.call("__listMethods");
      }
      /**
      * Sends a JSON-RPC 2.0 notification to server.
      * @method
      * @param {String} method - RPC method name
      * @param {Object} params - optional method parameters
      * @return {Promise}
      */
      notify(method, params) {
        return new Promise((resolve2, reject2) => {
          if (!this.ready) return reject2(new Error("socket not ready"));
          const message = {
            jsonrpc: "2.0",
            method,
            params
          };
          this.socket.send(this.dataPack.encode(message), (error) => {
            if (error) return reject2(error);
            resolve2();
          });
        });
      }
      /**
      * Subscribes for a defined event.
      * @method
      * @param {String|Array} event - event name
      * @return {Undefined}
      * @throws {Error}
      */
      async subscribe(event) {
        if (typeof event === "string") event = [event];
        const result = await this.call("rpc.on", event);
        if (typeof event === "string" && result[event] !== "ok")
          throw new Error(
            "Failed subscribing to an event '" + event + "' with: " + result[event]
          );
        return result;
      }
      /**
      * Unsubscribes from a defined event.
      * @method
      * @param {String|Array} event - event name
      * @return {Undefined}
      * @throws {Error}
      */
      async unsubscribe(event) {
        if (typeof event === "string") event = [event];
        const result = await this.call("rpc.off", event);
        if (typeof event === "string" && result[event] !== "ok")
          throw new Error("Failed unsubscribing from an event with: " + result);
        return result;
      }
      /**
      * Closes a WebSocket connection gracefully.
      * @method
      * @param {Number} code - socket close code
      * @param {String} data - optional data to be sent before closing
      * @return {Undefined}
      */
      close(code2, data) {
        if (this.socket) this.socket.close(code2 || 1e3, data);
      }
      /**
      * Enable / disable automatic reconnection.
      * @method
      * @param {Boolean} reconnect - enable / disable reconnection
      * @return {Undefined}
      */
      setAutoReconnect(reconnect) {
        this.reconnect = reconnect;
      }
      /**
      * Set the interval between reconnection attempts.
      * @method
      * @param {Number} interval - reconnection interval in milliseconds
      * @return {Undefined}
      */
      setReconnectInterval(interval) {
        this.reconnect_interval = interval;
      }
      /**
      * Set the maximum number of reconnection attempts.
      * @method
      * @param {Number} max_reconnects - maximum reconnection attempts
      * @return {Undefined}
      */
      setMaxReconnects(max_reconnects) {
        this.max_reconnects = max_reconnects;
      }
      /**
      * Get the current number of reconnection attempts made.
      * @method
      * @return {Number} current reconnection attempts
      */
      getCurrentReconnects() {
        return this.current_reconnects;
      }
      /**
      * Get the maximum number of reconnection attempts.
      * @method
      * @return {Number} maximum reconnection attempts
      */
      getMaxReconnects() {
        return this.max_reconnects;
      }
      /**
      * Check if the client is currently attempting to reconnect.
      * @method
      * @return {Boolean} true if reconnection is in progress
      */
      isReconnecting() {
        return this.reconnect_timer_id !== void 0;
      }
      /**
      * Check if the client will attempt to reconnect on the next close event.
      * @method
      * @return {Boolean} true if reconnection will be attempted
      */
      willReconnect() {
        return this.reconnect && (this.max_reconnects === 0 || this.current_reconnects < this.max_reconnects);
      }
      /**
      * Connection/Message handler.
      * @method
      * @private
      * @param {String} address - WebSocket API address
      * @param {Object} options - ws options object
      * @return {Undefined}
      */
      _connect(address, options) {
        clearTimeout(this.reconnect_timer_id);
        this.socket = this.webSocketFactory(address, options);
        this.socket.addEventListener("open", () => {
          this.ready = true;
          this.emit("open");
          this.current_reconnects = 0;
        });
        this.socket.addEventListener("message", ({ data: message }) => {
          if (message instanceof ArrayBuffer)
            message = import_buffer.Buffer.from(message).toString();
          try {
            message = this.dataPack.decode(message);
          } catch (error) {
            return;
          }
          if (message.notification && this.listeners(message.notification).length) {
            if (!Object.keys(message.params).length)
              return this.emit(message.notification);
            const args = [message.notification];
            if (message.params.constructor === Object) args.push(message.params);
            else
              for (let i = 0; i < message.params.length; i++)
                args.push(message.params[i]);
            return Promise.resolve().then(() => {
              this.emit.apply(this, args);
            });
          }
          if (!this.queue[message.id]) {
            if (message.method) {
              return Promise.resolve().then(() => {
                this.emit(message.method, message == null ? void 0 : message.params);
              });
            }
            return;
          }
          if ("error" in message === "result" in message)
            this.queue[message.id].promise[1](
              new Error(
                'Server response malformed. Response must include either "result" or "error", but not both.'
              )
            );
          if (this.queue[message.id].timeout)
            clearTimeout(this.queue[message.id].timeout);
          if (message.error) this.queue[message.id].promise[1](message.error);
          else this.queue[message.id].promise[0](message.result);
          delete this.queue[message.id];
        });
        this.socket.addEventListener("error", (error) => this.emit("error", error));
        this.socket.addEventListener("close", ({ code: code2, reason }) => {
          if (this.ready)
            setTimeout(() => this.emit("close", code2, reason), 0);
          this.ready = false;
          this.socket = void 0;
          if (code2 === 1e3) return;
          this.current_reconnects++;
          if (this.reconnect && (this.max_reconnects > this.current_reconnects || this.max_reconnects === 0))
            this.reconnect_timer_id = setTimeout(
              () => this._connect(address, options),
              this.reconnect_interval
            );
          else if (this.reconnect && this.max_reconnects > 0 && this.current_reconnects >= this.max_reconnects) {
            setTimeout(() => this.emit("max_reconnects_reached", code2, reason), 1);
          }
        });
      }
    };
  }
});

// node_modules/@solana/web3.js/node_modules/@noble/hashes/esm/sha3.js
function keccakP(s, rounds = 24) {
  const B = new Uint32Array(5 * 2);
  for (let round = 24 - rounds; round < 24; round++) {
    for (let x = 0; x < 10; x++)
      B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
    for (let x = 0; x < 10; x += 2) {
      const idx1 = (x + 8) % 10;
      const idx0 = (x + 2) % 10;
      const B0 = B[idx0];
      const B1 = B[idx0 + 1];
      const Th = rotlH(B0, B1, 1) ^ B[idx1];
      const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];
      for (let y = 0; y < 50; y += 10) {
        s[x + y] ^= Th;
        s[x + y + 1] ^= Tl;
      }
    }
    let curH = s[2];
    let curL = s[3];
    for (let t = 0; t < 24; t++) {
      const shift = SHA3_ROTL[t];
      const Th = rotlH(curH, curL, shift);
      const Tl = rotlL(curH, curL, shift);
      const PI = SHA3_PI[t];
      curH = s[PI];
      curL = s[PI + 1];
      s[PI] = Th;
      s[PI + 1] = Tl;
    }
    for (let y = 0; y < 50; y += 10) {
      for (let x = 0; x < 10; x++)
        B[x] = s[y + x];
      for (let x = 0; x < 10; x++)
        s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
    }
    s[0] ^= SHA3_IOTA_H[round];
    s[1] ^= SHA3_IOTA_L[round];
  }
  clean2(B);
}
var _0n7, _1n7, _2n5, _7n2, _256n, _0x71n, SHA3_PI, SHA3_ROTL, _SHA3_IOTA, IOTAS, SHA3_IOTA_H, SHA3_IOTA_L, rotlH, rotlL, Keccak, gen, sha3_224, sha3_256, sha3_384, sha3_512, keccak_224, keccak_256, keccak_384, keccak_512, genShake, shake128, shake256;
var init_sha3 = __esm({
  "node_modules/@solana/web3.js/node_modules/@noble/hashes/esm/sha3.js"() {
    init_u642();
    init_utils3();
    _0n7 = BigInt(0);
    _1n7 = BigInt(1);
    _2n5 = BigInt(2);
    _7n2 = BigInt(7);
    _256n = BigInt(256);
    _0x71n = BigInt(113);
    SHA3_PI = [];
    SHA3_ROTL = [];
    _SHA3_IOTA = [];
    for (let round = 0, R = _1n7, x = 1, y = 0; round < 24; round++) {
      [x, y] = [y, (2 * x + 3 * y) % 5];
      SHA3_PI.push(2 * (5 * y + x));
      SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);
      let t = _0n7;
      for (let j = 0; j < 7; j++) {
        R = (R << _1n7 ^ (R >> _7n2) * _0x71n) % _256n;
        if (R & _2n5)
          t ^= _1n7 << (_1n7 << BigInt(j)) - _1n7;
      }
      _SHA3_IOTA.push(t);
    }
    IOTAS = split2(_SHA3_IOTA, true);
    SHA3_IOTA_H = IOTAS[0];
    SHA3_IOTA_L = IOTAS[1];
    rotlH = (h, l, s) => s > 32 ? rotlBH(h, l, s) : rotlSH(h, l, s);
    rotlL = (h, l, s) => s > 32 ? rotlBL(h, l, s) : rotlSL(h, l, s);
    Keccak = class _Keccak extends Hash3 {
      // NOTE: we accept arguments in bytes instead of bits here.
      constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
        super();
        this.pos = 0;
        this.posOut = 0;
        this.finished = false;
        this.destroyed = false;
        this.enableXOF = false;
        this.blockLen = blockLen;
        this.suffix = suffix;
        this.outputLen = outputLen;
        this.enableXOF = enableXOF;
        this.rounds = rounds;
        anumber2(outputLen);
        if (!(0 < blockLen && blockLen < 200))
          throw new Error("only keccak-f1600 function is supported");
        this.state = new Uint8Array(200);
        this.state32 = u32(this.state);
      }
      clone() {
        return this._cloneInto();
      }
      keccak() {
        swap32IfBE(this.state32);
        keccakP(this.state32, this.rounds);
        swap32IfBE(this.state32);
        this.posOut = 0;
        this.pos = 0;
      }
      update(data) {
        aexists2(this);
        data = toBytes4(data);
        abytes2(data);
        const { blockLen, state } = this;
        const len = data.length;
        for (let pos = 0; pos < len; ) {
          const take = Math.min(blockLen - this.pos, len - pos);
          for (let i = 0; i < take; i++)
            state[this.pos++] ^= data[pos++];
          if (this.pos === blockLen)
            this.keccak();
        }
        return this;
      }
      finish() {
        if (this.finished)
          return;
        this.finished = true;
        const { state, suffix, pos, blockLen } = this;
        state[pos] ^= suffix;
        if ((suffix & 128) !== 0 && pos === blockLen - 1)
          this.keccak();
        state[blockLen - 1] ^= 128;
        this.keccak();
      }
      writeInto(out) {
        aexists2(this, false);
        abytes2(out);
        this.finish();
        const bufferOut = this.state;
        const { blockLen } = this;
        for (let pos = 0, len = out.length; pos < len; ) {
          if (this.posOut >= blockLen)
            this.keccak();
          const take = Math.min(blockLen - this.posOut, len - pos);
          out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
          this.posOut += take;
          pos += take;
        }
        return out;
      }
      xofInto(out) {
        if (!this.enableXOF)
          throw new Error("XOF is not possible for this instance");
        return this.writeInto(out);
      }
      xof(bytes3) {
        anumber2(bytes3);
        return this.xofInto(new Uint8Array(bytes3));
      }
      digestInto(out) {
        aoutput2(out, this);
        if (this.finished)
          throw new Error("digest() was already called");
        this.writeInto(out);
        this.destroy();
        return out;
      }
      digest() {
        return this.digestInto(new Uint8Array(this.outputLen));
      }
      destroy() {
        this.destroyed = true;
        clean2(this.state);
      }
      _cloneInto(to) {
        const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
        to || (to = new _Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
        to.state32.set(this.state32);
        to.pos = this.pos;
        to.posOut = this.posOut;
        to.finished = this.finished;
        to.rounds = rounds;
        to.suffix = suffix;
        to.outputLen = outputLen;
        to.enableXOF = enableXOF;
        to.destroyed = this.destroyed;
        return to;
      }
    };
    gen = (suffix, blockLen, outputLen) => createHasher3(() => new Keccak(blockLen, suffix, outputLen));
    sha3_224 = (() => gen(6, 144, 224 / 8))();
    sha3_256 = (() => gen(6, 136, 256 / 8))();
    sha3_384 = (() => gen(6, 104, 384 / 8))();
    sha3_512 = (() => gen(6, 72, 512 / 8))();
    keccak_224 = (() => gen(1, 144, 224 / 8))();
    keccak_256 = (() => gen(1, 136, 256 / 8))();
    keccak_384 = (() => gen(1, 104, 384 / 8))();
    keccak_512 = (() => gen(1, 72, 512 / 8))();
    genShake = (suffix, blockLen, outputLen) => createXOFer((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === void 0 ? outputLen : opts.dkLen, true));
    shake128 = (() => genShake(31, 168, 128 / 8))();
    shake256 = (() => genShake(31, 136, 256 / 8))();
  }
});

// node_modules/@noble/curves/node_modules/@noble/hashes/esm/hmac.js
var HMAC, hmac;
var init_hmac = __esm({
  "node_modules/@noble/curves/node_modules/@noble/hashes/esm/hmac.js"() {
    init_utils();
    HMAC = class extends Hash2 {
      constructor(hash3, _key) {
        super();
        this.finished = false;
        this.destroyed = false;
        ahash(hash3);
        const key = toBytes3(_key);
        this.iHash = hash3.create();
        if (typeof this.iHash.update !== "function")
          throw new Error("Expected instance of class which extends utils.Hash");
        this.blockLen = this.iHash.blockLen;
        this.outputLen = this.iHash.outputLen;
        const blockLen = this.blockLen;
        const pad3 = new Uint8Array(blockLen);
        pad3.set(key.length > blockLen ? hash3.create().update(key).digest() : key);
        for (let i = 0; i < pad3.length; i++)
          pad3[i] ^= 54;
        this.iHash.update(pad3);
        this.oHash = hash3.create();
        for (let i = 0; i < pad3.length; i++)
          pad3[i] ^= 54 ^ 92;
        this.oHash.update(pad3);
        clean(pad3);
      }
      update(buf) {
        aexists(this);
        this.iHash.update(buf);
        return this;
      }
      digestInto(out) {
        aexists(this);
        abytes(out, this.outputLen);
        this.finished = true;
        this.iHash.digestInto(out);
        this.oHash.update(out);
        this.oHash.digestInto(out);
        this.destroy();
      }
      digest() {
        const out = new Uint8Array(this.oHash.outputLen);
        this.digestInto(out);
        return out;
      }
      _cloneInto(to) {
        to || (to = Object.create(Object.getPrototypeOf(this), {}));
        const { oHash, iHash, finished: finished2, destroyed, blockLen, outputLen } = this;
        to = to;
        to.finished = finished2;
        to.destroyed = destroyed;
        to.blockLen = blockLen;
        to.outputLen = outputLen;
        to.oHash = oHash._cloneInto(to.oHash);
        to.iHash = iHash._cloneInto(to.iHash);
        return to;
      }
      clone() {
        return this._cloneInto();
      }
      destroy() {
        this.destroyed = true;
        this.oHash.destroy();
        this.iHash.destroy();
      }
    };
    hmac = (hash3, key, message) => new HMAC(hash3, key).update(message).digest();
    hmac.create = (hash3, key) => new HMAC(hash3, key);
  }
});

// node_modules/@noble/curves/esm/abstract/weierstrass.js
function _splitEndoScalar(k, basis, n) {
  const [[a1, b1], [a2, b2]] = basis;
  const c1 = divNearest(b2 * k, n);
  const c2 = divNearest(-b1 * k, n);
  let k1 = k - c1 * a1 - c2 * a2;
  let k2 = -c1 * b1 - c2 * b2;
  const k1neg = k1 < _0n8;
  const k2neg = k2 < _0n8;
  if (k1neg)
    k1 = -k1;
  if (k2neg)
    k2 = -k2;
  const MAX_NUM = bitMask(Math.ceil(bitLen(n) / 2)) + _1n8;
  if (k1 < _0n8 || k1 >= MAX_NUM || k2 < _0n8 || k2 >= MAX_NUM) {
    throw new Error("splitScalar (endomorphism): failed, k=" + k);
  }
  return { k1neg, k1, k2neg, k2 };
}
function validateSigFormat(format2) {
  if (!["compact", "recovered", "der"].includes(format2))
    throw new Error('Signature format must be "compact", "recovered", or "der"');
  return format2;
}
function validateSigOpts(opts, def) {
  const optsn = {};
  for (let optName of Object.keys(def)) {
    optsn[optName] = opts[optName] === void 0 ? def[optName] : opts[optName];
  }
  _abool2(optsn.lowS, "lowS");
  _abool2(optsn.prehash, "prehash");
  if (optsn.format !== void 0)
    validateSigFormat(optsn.format);
  return optsn;
}
function _normFnElement(Fn2, key) {
  const { BYTES: expected } = Fn2;
  let num2;
  if (typeof key === "bigint") {
    num2 = key;
  } else {
    let bytes3 = ensureBytes("private key", key);
    try {
      num2 = Fn2.fromBytes(bytes3);
    } catch (error) {
      throw new Error(`invalid private key: expected ui8a of size ${expected}, got ${typeof key}`);
    }
  }
  if (!Fn2.isValidNot0(num2))
    throw new Error("invalid private key: out of range [1..N-1]");
  return num2;
}
function weierstrassN(params, extraOpts = {}) {
  const validated = _createCurveFields("weierstrass", params, extraOpts);
  const { Fp: Fp3, Fn: Fn2 } = validated;
  let CURVE2 = validated.CURVE;
  const { h: cofactor, n: CURVE_ORDER } = CURVE2;
  _validateObject(extraOpts, {}, {
    allowInfinityPoint: "boolean",
    clearCofactor: "function",
    isTorsionFree: "function",
    fromBytes: "function",
    toBytes: "function",
    endo: "object",
    wrapPrivateKey: "boolean"
  });
  const { endo } = extraOpts;
  if (endo) {
    if (!Fp3.is0(CURVE2.a) || typeof endo.beta !== "bigint" || !Array.isArray(endo.basises)) {
      throw new Error('invalid endo: expected "beta": bigint and "basises": array');
    }
  }
  const lengths = getWLengths(Fp3, Fn2);
  function assertCompressionIsSupported() {
    if (!Fp3.isOdd)
      throw new Error("compression is not supported: Field does not have .isOdd()");
  }
  function pointToBytes2(_c, point, isCompressed) {
    const { x, y } = point.toAffine();
    const bx = Fp3.toBytes(x);
    _abool2(isCompressed, "isCompressed");
    if (isCompressed) {
      assertCompressionIsSupported();
      const hasEvenY = !Fp3.isOdd(y);
      return concatBytes2(pprefix(hasEvenY), bx);
    } else {
      return concatBytes2(Uint8Array.of(4), bx, Fp3.toBytes(y));
    }
  }
  function pointFromBytes(bytes3) {
    _abytes2(bytes3, void 0, "Point");
    const { publicKey: comp, publicKeyUncompressed: uncomp } = lengths;
    const length2 = bytes3.length;
    const head = bytes3[0];
    const tail = bytes3.subarray(1);
    if (length2 === comp && (head === 2 || head === 3)) {
      const x = Fp3.fromBytes(tail);
      if (!Fp3.isValid(x))
        throw new Error("bad point: is not on curve, wrong x");
      const y2 = weierstrassEquation(x);
      let y;
      try {
        y = Fp3.sqrt(y2);
      } catch (sqrtError) {
        const err2 = sqrtError instanceof Error ? ": " + sqrtError.message : "";
        throw new Error("bad point: is not on curve, sqrt error" + err2);
      }
      assertCompressionIsSupported();
      const isYOdd = Fp3.isOdd(y);
      const isHeadOdd = (head & 1) === 1;
      if (isHeadOdd !== isYOdd)
        y = Fp3.neg(y);
      return { x, y };
    } else if (length2 === uncomp && head === 4) {
      const L = Fp3.BYTES;
      const x = Fp3.fromBytes(tail.subarray(0, L));
      const y = Fp3.fromBytes(tail.subarray(L, L * 2));
      if (!isValidXY(x, y))
        throw new Error("bad point: is not on curve");
      return { x, y };
    } else {
      throw new Error(`bad point: got length ${length2}, expected compressed=${comp} or uncompressed=${uncomp}`);
    }
  }
  const encodePoint = extraOpts.toBytes || pointToBytes2;
  const decodePoint = extraOpts.fromBytes || pointFromBytes;
  function weierstrassEquation(x) {
    const x2 = Fp3.sqr(x);
    const x3 = Fp3.mul(x2, x);
    return Fp3.add(Fp3.add(x3, Fp3.mul(x, CURVE2.a)), CURVE2.b);
  }
  function isValidXY(x, y) {
    const left = Fp3.sqr(y);
    const right = weierstrassEquation(x);
    return Fp3.eql(left, right);
  }
  if (!isValidXY(CURVE2.Gx, CURVE2.Gy))
    throw new Error("bad curve params: generator point");
  const _4a3 = Fp3.mul(Fp3.pow(CURVE2.a, _3n3), _4n2);
  const _27b2 = Fp3.mul(Fp3.sqr(CURVE2.b), BigInt(27));
  if (Fp3.is0(Fp3.add(_4a3, _27b2)))
    throw new Error("bad curve params: a or b");
  function acoord(title, n, banZero = false) {
    if (!Fp3.isValid(n) || banZero && Fp3.is0(n))
      throw new Error(`bad point coordinate ${title}`);
    return n;
  }
  function aprjpoint(other) {
    if (!(other instanceof Point2))
      throw new Error("ProjectivePoint expected");
  }
  function splitEndoScalarN(k) {
    if (!endo || !endo.basises)
      throw new Error("no endo");
    return _splitEndoScalar(k, endo.basises, Fn2.ORDER);
  }
  const toAffineMemo = memoized((p, iz) => {
    const { X, Y, Z } = p;
    if (Fp3.eql(Z, Fp3.ONE))
      return { x: X, y: Y };
    const is0 = p.is0();
    if (iz == null)
      iz = is0 ? Fp3.ONE : Fp3.inv(Z);
    const x = Fp3.mul(X, iz);
    const y = Fp3.mul(Y, iz);
    const zz = Fp3.mul(Z, iz);
    if (is0)
      return { x: Fp3.ZERO, y: Fp3.ZERO };
    if (!Fp3.eql(zz, Fp3.ONE))
      throw new Error("invZ was invalid");
    return { x, y };
  });
  const assertValidMemo = memoized((p) => {
    if (p.is0()) {
      if (extraOpts.allowInfinityPoint && !Fp3.is0(p.Y))
        return;
      throw new Error("bad point: ZERO");
    }
    const { x, y } = p.toAffine();
    if (!Fp3.isValid(x) || !Fp3.isValid(y))
      throw new Error("bad point: x or y not field elements");
    if (!isValidXY(x, y))
      throw new Error("bad point: equation left != right");
    if (!p.isTorsionFree())
      throw new Error("bad point: not in prime-order subgroup");
    return true;
  });
  function finishEndo(endoBeta, k1p, k2p, k1neg, k2neg) {
    k2p = new Point2(Fp3.mul(k2p.X, endoBeta), k2p.Y, k2p.Z);
    k1p = negateCt(k1neg, k1p);
    k2p = negateCt(k2neg, k2p);
    return k1p.add(k2p);
  }
  class Point2 {
    /** Does NOT validate if the point is valid. Use `.assertValidity()`. */
    constructor(X, Y, Z) {
      this.X = acoord("x", X);
      this.Y = acoord("y", Y, true);
      this.Z = acoord("z", Z);
      Object.freeze(this);
    }
    static CURVE() {
      return CURVE2;
    }
    /** Does NOT validate if the point is valid. Use `.assertValidity()`. */
    static fromAffine(p) {
      const { x, y } = p || {};
      if (!p || !Fp3.isValid(x) || !Fp3.isValid(y))
        throw new Error("invalid affine point");
      if (p instanceof Point2)
        throw new Error("projective point not allowed");
      if (Fp3.is0(x) && Fp3.is0(y))
        return Point2.ZERO;
      return new Point2(x, y, Fp3.ONE);
    }
    static fromBytes(bytes3) {
      const P = Point2.fromAffine(decodePoint(_abytes2(bytes3, void 0, "point")));
      P.assertValidity();
      return P;
    }
    static fromHex(hex3) {
      return Point2.fromBytes(ensureBytes("pointHex", hex3));
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    /**
     *
     * @param windowSize
     * @param isLazy true will defer table computation until the first multiplication
     * @returns
     */
    precompute(windowSize = 8, isLazy = true) {
      wnaf.createCache(this, windowSize);
      if (!isLazy)
        this.multiply(_3n3);
      return this;
    }
    // TODO: return `this`
    /** A point on curve is valid if it conforms to equation. */
    assertValidity() {
      assertValidMemo(this);
    }
    hasEvenY() {
      const { y } = this.toAffine();
      if (!Fp3.isOdd)
        throw new Error("Field doesn't support isOdd");
      return !Fp3.isOdd(y);
    }
    /** Compare one point to another. */
    equals(other) {
      aprjpoint(other);
      const { X: X1, Y: Y1, Z: Z1 } = this;
      const { X: X2, Y: Y2, Z: Z2 } = other;
      const U1 = Fp3.eql(Fp3.mul(X1, Z2), Fp3.mul(X2, Z1));
      const U2 = Fp3.eql(Fp3.mul(Y1, Z2), Fp3.mul(Y2, Z1));
      return U1 && U2;
    }
    /** Flips point to one corresponding to (x, -y) in Affine coordinates. */
    negate() {
      return new Point2(this.X, Fp3.neg(this.Y), this.Z);
    }
    // Renes-Costello-Batina exception-free doubling formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 3
    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
    double() {
      const { a, b } = CURVE2;
      const b3 = Fp3.mul(b, _3n3);
      const { X: X1, Y: Y1, Z: Z1 } = this;
      let X3 = Fp3.ZERO, Y3 = Fp3.ZERO, Z3 = Fp3.ZERO;
      let t0 = Fp3.mul(X1, X1);
      let t1 = Fp3.mul(Y1, Y1);
      let t2 = Fp3.mul(Z1, Z1);
      let t3 = Fp3.mul(X1, Y1);
      t3 = Fp3.add(t3, t3);
      Z3 = Fp3.mul(X1, Z1);
      Z3 = Fp3.add(Z3, Z3);
      X3 = Fp3.mul(a, Z3);
      Y3 = Fp3.mul(b3, t2);
      Y3 = Fp3.add(X3, Y3);
      X3 = Fp3.sub(t1, Y3);
      Y3 = Fp3.add(t1, Y3);
      Y3 = Fp3.mul(X3, Y3);
      X3 = Fp3.mul(t3, X3);
      Z3 = Fp3.mul(b3, Z3);
      t2 = Fp3.mul(a, t2);
      t3 = Fp3.sub(t0, t2);
      t3 = Fp3.mul(a, t3);
      t3 = Fp3.add(t3, Z3);
      Z3 = Fp3.add(t0, t0);
      t0 = Fp3.add(Z3, t0);
      t0 = Fp3.add(t0, t2);
      t0 = Fp3.mul(t0, t3);
      Y3 = Fp3.add(Y3, t0);
      t2 = Fp3.mul(Y1, Z1);
      t2 = Fp3.add(t2, t2);
      t0 = Fp3.mul(t2, t3);
      X3 = Fp3.sub(X3, t0);
      Z3 = Fp3.mul(t2, t1);
      Z3 = Fp3.add(Z3, Z3);
      Z3 = Fp3.add(Z3, Z3);
      return new Point2(X3, Y3, Z3);
    }
    // Renes-Costello-Batina exception-free addition formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 1
    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
    add(other) {
      aprjpoint(other);
      const { X: X1, Y: Y1, Z: Z1 } = this;
      const { X: X2, Y: Y2, Z: Z2 } = other;
      let X3 = Fp3.ZERO, Y3 = Fp3.ZERO, Z3 = Fp3.ZERO;
      const a = CURVE2.a;
      const b3 = Fp3.mul(CURVE2.b, _3n3);
      let t0 = Fp3.mul(X1, X2);
      let t1 = Fp3.mul(Y1, Y2);
      let t2 = Fp3.mul(Z1, Z2);
      let t3 = Fp3.add(X1, Y1);
      let t4 = Fp3.add(X2, Y2);
      t3 = Fp3.mul(t3, t4);
      t4 = Fp3.add(t0, t1);
      t3 = Fp3.sub(t3, t4);
      t4 = Fp3.add(X1, Z1);
      let t5 = Fp3.add(X2, Z2);
      t4 = Fp3.mul(t4, t5);
      t5 = Fp3.add(t0, t2);
      t4 = Fp3.sub(t4, t5);
      t5 = Fp3.add(Y1, Z1);
      X3 = Fp3.add(Y2, Z2);
      t5 = Fp3.mul(t5, X3);
      X3 = Fp3.add(t1, t2);
      t5 = Fp3.sub(t5, X3);
      Z3 = Fp3.mul(a, t4);
      X3 = Fp3.mul(b3, t2);
      Z3 = Fp3.add(X3, Z3);
      X3 = Fp3.sub(t1, Z3);
      Z3 = Fp3.add(t1, Z3);
      Y3 = Fp3.mul(X3, Z3);
      t1 = Fp3.add(t0, t0);
      t1 = Fp3.add(t1, t0);
      t2 = Fp3.mul(a, t2);
      t4 = Fp3.mul(b3, t4);
      t1 = Fp3.add(t1, t2);
      t2 = Fp3.sub(t0, t2);
      t2 = Fp3.mul(a, t2);
      t4 = Fp3.add(t4, t2);
      t0 = Fp3.mul(t1, t4);
      Y3 = Fp3.add(Y3, t0);
      t0 = Fp3.mul(t5, t4);
      X3 = Fp3.mul(t3, X3);
      X3 = Fp3.sub(X3, t0);
      t0 = Fp3.mul(t3, t1);
      Z3 = Fp3.mul(t5, Z3);
      Z3 = Fp3.add(Z3, t0);
      return new Point2(X3, Y3, Z3);
    }
    subtract(other) {
      return this.add(other.negate());
    }
    is0() {
      return this.equals(Point2.ZERO);
    }
    /**
     * Constant time multiplication.
     * Uses wNAF method. Windowed method may be 10% faster,
     * but takes 2x longer to generate and consumes 2x memory.
     * Uses precomputes when available.
     * Uses endomorphism for Koblitz curves.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */
    multiply(scalar) {
      const { endo: endo2 } = extraOpts;
      if (!Fn2.isValidNot0(scalar))
        throw new Error("invalid scalar: out of range");
      let point, fake;
      const mul = (n) => wnaf.cached(this, n, (p) => normalizeZ(Point2, p));
      if (endo2) {
        const { k1neg, k1, k2neg, k2 } = splitEndoScalarN(scalar);
        const { p: k1p, f: k1f } = mul(k1);
        const { p: k2p, f: k2f } = mul(k2);
        fake = k1f.add(k2f);
        point = finishEndo(endo2.beta, k1p, k2p, k1neg, k2neg);
      } else {
        const { p, f: f3 } = mul(scalar);
        point = p;
        fake = f3;
      }
      return normalizeZ(Point2, [point, fake])[0];
    }
    /**
     * Non-constant-time multiplication. Uses double-and-add algorithm.
     * It's faster, but should only be used when you don't care about
     * an exposed secret key e.g. sig verification, which works over *public* keys.
     */
    multiplyUnsafe(sc) {
      const { endo: endo2 } = extraOpts;
      const p = this;
      if (!Fn2.isValid(sc))
        throw new Error("invalid scalar: out of range");
      if (sc === _0n8 || p.is0())
        return Point2.ZERO;
      if (sc === _1n8)
        return p;
      if (wnaf.hasCache(this))
        return this.multiply(sc);
      if (endo2) {
        const { k1neg, k1, k2neg, k2 } = splitEndoScalarN(sc);
        const { p1, p2 } = mulEndoUnsafe(Point2, p, k1, k2);
        return finishEndo(endo2.beta, p1, p2, k1neg, k2neg);
      } else {
        return wnaf.unsafe(p, sc);
      }
    }
    multiplyAndAddUnsafe(Q, a, b) {
      const sum = this.multiplyUnsafe(a).add(Q.multiplyUnsafe(b));
      return sum.is0() ? void 0 : sum;
    }
    /**
     * Converts Projective point to affine (x, y) coordinates.
     * @param invertedZ Z^-1 (inverted zero) - optional, precomputation is useful for invertBatch
     */
    toAffine(invertedZ) {
      return toAffineMemo(this, invertedZ);
    }
    /**
     * Checks whether Point is free of torsion elements (is in prime subgroup).
     * Always torsion-free for cofactor=1 curves.
     */
    isTorsionFree() {
      const { isTorsionFree } = extraOpts;
      if (cofactor === _1n8)
        return true;
      if (isTorsionFree)
        return isTorsionFree(Point2, this);
      return wnaf.unsafe(this, CURVE_ORDER).is0();
    }
    clearCofactor() {
      const { clearCofactor } = extraOpts;
      if (cofactor === _1n8)
        return this;
      if (clearCofactor)
        return clearCofactor(Point2, this);
      return this.multiplyUnsafe(cofactor);
    }
    isSmallOrder() {
      return this.multiplyUnsafe(cofactor).is0();
    }
    toBytes(isCompressed = true) {
      _abool2(isCompressed, "isCompressed");
      this.assertValidity();
      return encodePoint(Point2, this, isCompressed);
    }
    toHex(isCompressed = true) {
      return bytesToHex2(this.toBytes(isCompressed));
    }
    toString() {
      return `<Point ${this.is0() ? "ZERO" : this.toHex()}>`;
    }
    // TODO: remove
    get px() {
      return this.X;
    }
    get py() {
      return this.X;
    }
    get pz() {
      return this.Z;
    }
    toRawBytes(isCompressed = true) {
      return this.toBytes(isCompressed);
    }
    _setWindowSize(windowSize) {
      this.precompute(windowSize);
    }
    static normalizeZ(points) {
      return normalizeZ(Point2, points);
    }
    static msm(points, scalars) {
      return pippenger(Point2, Fn2, points, scalars);
    }
    static fromPrivateKey(privateKey) {
      return Point2.BASE.multiply(_normFnElement(Fn2, privateKey));
    }
  }
  Point2.BASE = new Point2(CURVE2.Gx, CURVE2.Gy, Fp3.ONE);
  Point2.ZERO = new Point2(Fp3.ZERO, Fp3.ONE, Fp3.ZERO);
  Point2.Fp = Fp3;
  Point2.Fn = Fn2;
  const bits = Fn2.BITS;
  const wnaf = new wNAF(Point2, extraOpts.endo ? Math.ceil(bits / 2) : bits);
  Point2.BASE.precompute(8);
  return Point2;
}
function pprefix(hasEvenY) {
  return Uint8Array.of(hasEvenY ? 2 : 3);
}
function SWUFpSqrtRatio(Fp3, Z) {
  const q = Fp3.ORDER;
  let l = _0n8;
  for (let o = q - _1n8; o % _2n6 === _0n8; o /= _2n6)
    l += _1n8;
  const c1 = l;
  const _2n_pow_c1_1 = _2n6 << c1 - _1n8 - _1n8;
  const _2n_pow_c1 = _2n_pow_c1_1 * _2n6;
  const c2 = (q - _1n8) / _2n_pow_c1;
  const c3 = (c2 - _1n8) / _2n6;
  const c4 = _2n_pow_c1 - _1n8;
  const c5 = _2n_pow_c1_1;
  const c6 = Fp3.pow(Z, c2);
  const c7 = Fp3.pow(Z, (c2 + _1n8) / _2n6);
  let sqrtRatio = (u, v) => {
    let tv1 = c6;
    let tv2 = Fp3.pow(v, c4);
    let tv3 = Fp3.sqr(tv2);
    tv3 = Fp3.mul(tv3, v);
    let tv5 = Fp3.mul(u, tv3);
    tv5 = Fp3.pow(tv5, c3);
    tv5 = Fp3.mul(tv5, tv2);
    tv2 = Fp3.mul(tv5, v);
    tv3 = Fp3.mul(tv5, u);
    let tv4 = Fp3.mul(tv3, tv2);
    tv5 = Fp3.pow(tv4, c5);
    let isQR = Fp3.eql(tv5, Fp3.ONE);
    tv2 = Fp3.mul(tv3, c7);
    tv5 = Fp3.mul(tv4, tv1);
    tv3 = Fp3.cmov(tv2, tv3, isQR);
    tv4 = Fp3.cmov(tv5, tv4, isQR);
    for (let i = c1; i > _1n8; i--) {
      let tv52 = i - _2n6;
      tv52 = _2n6 << tv52 - _1n8;
      let tvv5 = Fp3.pow(tv4, tv52);
      const e1 = Fp3.eql(tvv5, Fp3.ONE);
      tv2 = Fp3.mul(tv3, tv1);
      tv1 = Fp3.mul(tv1, tv1);
      tvv5 = Fp3.mul(tv4, tv1);
      tv3 = Fp3.cmov(tv2, tv3, e1);
      tv4 = Fp3.cmov(tvv5, tv4, e1);
    }
    return { isValid: isQR, value: tv3 };
  };
  if (Fp3.ORDER % _4n2 === _3n3) {
    const c12 = (Fp3.ORDER - _3n3) / _4n2;
    const c22 = Fp3.sqrt(Fp3.neg(Z));
    sqrtRatio = (u, v) => {
      let tv1 = Fp3.sqr(v);
      const tv2 = Fp3.mul(u, v);
      tv1 = Fp3.mul(tv1, tv2);
      let y1 = Fp3.pow(tv1, c12);
      y1 = Fp3.mul(y1, tv2);
      const y2 = Fp3.mul(y1, c22);
      const tv3 = Fp3.mul(Fp3.sqr(y1), v);
      const isQR = Fp3.eql(tv3, u);
      let y = Fp3.cmov(y2, y1, isQR);
      return { isValid: isQR, value: y };
    };
  }
  return sqrtRatio;
}
function mapToCurveSimpleSWU(Fp3, opts) {
  validateField(Fp3);
  const { A, B, Z } = opts;
  if (!Fp3.isValid(A) || !Fp3.isValid(B) || !Fp3.isValid(Z))
    throw new Error("mapToCurveSimpleSWU: invalid opts");
  const sqrtRatio = SWUFpSqrtRatio(Fp3, Z);
  if (!Fp3.isOdd)
    throw new Error("Field does not have .isOdd()");
  return (u) => {
    let tv1, tv2, tv3, tv4, tv5, tv6, x, y;
    tv1 = Fp3.sqr(u);
    tv1 = Fp3.mul(tv1, Z);
    tv2 = Fp3.sqr(tv1);
    tv2 = Fp3.add(tv2, tv1);
    tv3 = Fp3.add(tv2, Fp3.ONE);
    tv3 = Fp3.mul(tv3, B);
    tv4 = Fp3.cmov(Z, Fp3.neg(tv2), !Fp3.eql(tv2, Fp3.ZERO));
    tv4 = Fp3.mul(tv4, A);
    tv2 = Fp3.sqr(tv3);
    tv6 = Fp3.sqr(tv4);
    tv5 = Fp3.mul(tv6, A);
    tv2 = Fp3.add(tv2, tv5);
    tv2 = Fp3.mul(tv2, tv3);
    tv6 = Fp3.mul(tv6, tv4);
    tv5 = Fp3.mul(tv6, B);
    tv2 = Fp3.add(tv2, tv5);
    x = Fp3.mul(tv1, tv3);
    const { isValid, value } = sqrtRatio(tv2, tv6);
    y = Fp3.mul(tv1, u);
    y = Fp3.mul(y, value);
    x = Fp3.cmov(x, tv3, isValid);
    y = Fp3.cmov(y, value, isValid);
    const e1 = Fp3.isOdd(u) === Fp3.isOdd(y);
    y = Fp3.cmov(Fp3.neg(y), y, e1);
    const tv4_inv = FpInvertBatch(Fp3, [tv4], true)[0];
    x = Fp3.mul(x, tv4_inv);
    return { x, y };
  };
}
function getWLengths(Fp3, Fn2) {
  return {
    secretKey: Fn2.BYTES,
    publicKey: 1 + Fp3.BYTES,
    publicKeyUncompressed: 1 + 2 * Fp3.BYTES,
    publicKeyHasPrefix: true,
    signature: 2 * Fn2.BYTES
  };
}
function ecdh(Point2, ecdhOpts = {}) {
  const { Fn: Fn2 } = Point2;
  const randomBytes_ = ecdhOpts.randomBytes || randomBytes;
  const lengths = Object.assign(getWLengths(Point2.Fp, Fn2), { seed: getMinHashLength(Fn2.ORDER) });
  function isValidSecretKey(secretKey) {
    try {
      return !!_normFnElement(Fn2, secretKey);
    } catch (error) {
      return false;
    }
  }
  function isValidPublicKey(publicKey5, isCompressed) {
    const { publicKey: comp, publicKeyUncompressed } = lengths;
    try {
      const l = publicKey5.length;
      if (isCompressed === true && l !== comp)
        return false;
      if (isCompressed === false && l !== publicKeyUncompressed)
        return false;
      return !!Point2.fromBytes(publicKey5);
    } catch (error) {
      return false;
    }
  }
  function randomSecretKey(seed2 = randomBytes_(lengths.seed)) {
    return mapHashToField(_abytes2(seed2, lengths.seed, "seed"), Fn2.ORDER);
  }
  function getPublicKey2(secretKey, isCompressed = true) {
    return Point2.BASE.multiply(_normFnElement(Fn2, secretKey)).toBytes(isCompressed);
  }
  function keygen(seed2) {
    const secretKey = randomSecretKey(seed2);
    return { secretKey, publicKey: getPublicKey2(secretKey) };
  }
  function isProbPub2(item) {
    if (typeof item === "bigint")
      return false;
    if (item instanceof Point2)
      return true;
    const { secretKey, publicKey: publicKey5, publicKeyUncompressed } = lengths;
    if (Fn2.allowedLengths || secretKey === publicKey5)
      return void 0;
    const l = ensureBytes("key", item).length;
    return l === publicKey5 || l === publicKeyUncompressed;
  }
  function getSharedSecret3(secretKeyA, publicKeyB, isCompressed = true) {
    if (isProbPub2(secretKeyA) === true)
      throw new Error("first arg must be private key");
    if (isProbPub2(publicKeyB) === false)
      throw new Error("second arg must be public key");
    const s = _normFnElement(Fn2, secretKeyA);
    const b = Point2.fromHex(publicKeyB);
    return b.multiply(s).toBytes(isCompressed);
  }
  const utils3 = {
    isValidSecretKey,
    isValidPublicKey,
    randomSecretKey,
    // TODO: remove
    isValidPrivateKey: isValidSecretKey,
    randomPrivateKey: randomSecretKey,
    normPrivateKeyToScalar: (key) => _normFnElement(Fn2, key),
    precompute(windowSize = 8, point = Point2.BASE) {
      return point.precompute(windowSize, false);
    }
  };
  return Object.freeze({ getPublicKey: getPublicKey2, getSharedSecret: getSharedSecret3, keygen, Point: Point2, utils: utils3, lengths });
}
function ecdsa(Point2, hash3, ecdsaOpts = {}) {
  ahash(hash3);
  _validateObject(ecdsaOpts, {}, {
    hmac: "function",
    lowS: "boolean",
    randomBytes: "function",
    bits2int: "function",
    bits2int_modN: "function"
  });
  const randomBytes3 = ecdsaOpts.randomBytes || randomBytes;
  const hmac3 = ecdsaOpts.hmac || ((key, ...msgs) => hmac(hash3, key, concatBytes2(...msgs)));
  const { Fp: Fp3, Fn: Fn2 } = Point2;
  const { ORDER: CURVE_ORDER, BITS: fnBits } = Fn2;
  const { keygen, getPublicKey: getPublicKey2, getSharedSecret: getSharedSecret3, utils: utils3, lengths } = ecdh(Point2, ecdsaOpts);
  const defaultSigOpts = {
    prehash: false,
    lowS: typeof ecdsaOpts.lowS === "boolean" ? ecdsaOpts.lowS : false,
    format: void 0,
    //'compact' as ECDSASigFormat,
    extraEntropy: false
  };
  const defaultSigOpts_format = "compact";
  function isBiggerThanHalfOrder(number5) {
    const HALF = CURVE_ORDER >> _1n8;
    return number5 > HALF;
  }
  function validateRS(title, num2) {
    if (!Fn2.isValidNot0(num2))
      throw new Error(`invalid signature ${title}: out of range 1..Point.Fn.ORDER`);
    return num2;
  }
  function validateSigLength(bytes3, format2) {
    validateSigFormat(format2);
    const size4 = lengths.signature;
    const sizer = format2 === "compact" ? size4 : format2 === "recovered" ? size4 + 1 : void 0;
    return _abytes2(bytes3, sizer, `${format2} signature`);
  }
  class Signature2 {
    constructor(r, s, recovery) {
      this.r = validateRS("r", r);
      this.s = validateRS("s", s);
      if (recovery != null)
        this.recovery = recovery;
      Object.freeze(this);
    }
    static fromBytes(bytes3, format2 = defaultSigOpts_format) {
      validateSigLength(bytes3, format2);
      let recid;
      if (format2 === "der") {
        const { r: r2, s: s2 } = DER.toSig(_abytes2(bytes3));
        return new Signature2(r2, s2);
      }
      if (format2 === "recovered") {
        recid = bytes3[0];
        format2 = "compact";
        bytes3 = bytes3.subarray(1);
      }
      const L = Fn2.BYTES;
      const r = bytes3.subarray(0, L);
      const s = bytes3.subarray(L, L * 2);
      return new Signature2(Fn2.fromBytes(r), Fn2.fromBytes(s), recid);
    }
    static fromHex(hex3, format2) {
      return this.fromBytes(hexToBytes2(hex3), format2);
    }
    addRecoveryBit(recovery) {
      return new Signature2(this.r, this.s, recovery);
    }
    recoverPublicKey(messageHash) {
      const FIELD_ORDER = Fp3.ORDER;
      const { r, s, recovery: rec } = this;
      if (rec == null || ![0, 1, 2, 3].includes(rec))
        throw new Error("recovery id invalid");
      const hasCofactor = CURVE_ORDER * _2n6 < FIELD_ORDER;
      if (hasCofactor && rec > 1)
        throw new Error("recovery id is ambiguous for h>1 curve");
      const radj = rec === 2 || rec === 3 ? r + CURVE_ORDER : r;
      if (!Fp3.isValid(radj))
        throw new Error("recovery id 2 or 3 invalid");
      const x = Fp3.toBytes(radj);
      const R = Point2.fromBytes(concatBytes2(pprefix((rec & 1) === 0), x));
      const ir = Fn2.inv(radj);
      const h = bits2int_modN(ensureBytes("msgHash", messageHash));
      const u1 = Fn2.create(-h * ir);
      const u2 = Fn2.create(s * ir);
      const Q = Point2.BASE.multiplyUnsafe(u1).add(R.multiplyUnsafe(u2));
      if (Q.is0())
        throw new Error("point at infinify");
      Q.assertValidity();
      return Q;
    }
    // Signatures should be low-s, to prevent malleability.
    hasHighS() {
      return isBiggerThanHalfOrder(this.s);
    }
    toBytes(format2 = defaultSigOpts_format) {
      validateSigFormat(format2);
      if (format2 === "der")
        return hexToBytes2(DER.hexFromSig(this));
      const r = Fn2.toBytes(this.r);
      const s = Fn2.toBytes(this.s);
      if (format2 === "recovered") {
        if (this.recovery == null)
          throw new Error("recovery bit must be present");
        return concatBytes2(Uint8Array.of(this.recovery), r, s);
      }
      return concatBytes2(r, s);
    }
    toHex(format2) {
      return bytesToHex2(this.toBytes(format2));
    }
    // TODO: remove
    assertValidity() {
    }
    static fromCompact(hex3) {
      return Signature2.fromBytes(ensureBytes("sig", hex3), "compact");
    }
    static fromDER(hex3) {
      return Signature2.fromBytes(ensureBytes("sig", hex3), "der");
    }
    normalizeS() {
      return this.hasHighS() ? new Signature2(this.r, Fn2.neg(this.s), this.recovery) : this;
    }
    toDERRawBytes() {
      return this.toBytes("der");
    }
    toDERHex() {
      return bytesToHex2(this.toBytes("der"));
    }
    toCompactRawBytes() {
      return this.toBytes("compact");
    }
    toCompactHex() {
      return bytesToHex2(this.toBytes("compact"));
    }
  }
  const bits2int2 = ecdsaOpts.bits2int || function bits2int_def(bytes3) {
    if (bytes3.length > 8192)
      throw new Error("input is too large");
    const num2 = bytesToNumberBE(bytes3);
    const delta = bytes3.length * 8 - fnBits;
    return delta > 0 ? num2 >> BigInt(delta) : num2;
  };
  const bits2int_modN = ecdsaOpts.bits2int_modN || function bits2int_modN_def(bytes3) {
    return Fn2.create(bits2int2(bytes3));
  };
  const ORDER_MASK = bitMask(fnBits);
  function int2octets2(num2) {
    aInRange("num < 2^" + fnBits, num2, _0n8, ORDER_MASK);
    return Fn2.toBytes(num2);
  }
  function validateMsgAndHash(message, prehash) {
    _abytes2(message, void 0, "message");
    return prehash ? _abytes2(hash3(message), void 0, "prehashed message") : message;
  }
  function prepSig(message, privateKey, opts) {
    if (["recovered", "canonical"].some((k) => k in opts))
      throw new Error("sign() legacy options not supported");
    const { lowS, prehash, extraEntropy } = validateSigOpts(opts, defaultSigOpts);
    message = validateMsgAndHash(message, prehash);
    const h1int = bits2int_modN(message);
    const d = _normFnElement(Fn2, privateKey);
    const seedArgs = [int2octets2(d), int2octets2(h1int)];
    if (extraEntropy != null && extraEntropy !== false) {
      const e = extraEntropy === true ? randomBytes3(lengths.secretKey) : extraEntropy;
      seedArgs.push(ensureBytes("extraEntropy", e));
    }
    const seed2 = concatBytes2(...seedArgs);
    const m = h1int;
    function k2sig(kBytes) {
      const k = bits2int2(kBytes);
      if (!Fn2.isValidNot0(k))
        return;
      const ik = Fn2.inv(k);
      const q = Point2.BASE.multiply(k).toAffine();
      const r = Fn2.create(q.x);
      if (r === _0n8)
        return;
      const s = Fn2.create(ik * Fn2.create(m + r * d));
      if (s === _0n8)
        return;
      let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n8);
      let normS = s;
      if (lowS && isBiggerThanHalfOrder(s)) {
        normS = Fn2.neg(s);
        recovery ^= 1;
      }
      return new Signature2(r, normS, recovery);
    }
    return { seed: seed2, k2sig };
  }
  function sign4(message, secretKey, opts = {}) {
    message = ensureBytes("message", message);
    const { seed: seed2, k2sig } = prepSig(message, secretKey, opts);
    const drbg = createHmacDrbg(hash3.outputLen, Fn2.BYTES, hmac3);
    const sig = drbg(seed2, k2sig);
    return sig;
  }
  function tryParsingSig(sg) {
    let sig = void 0;
    const isHex3 = typeof sg === "string" || isBytes2(sg);
    const isObj = !isHex3 && sg !== null && typeof sg === "object" && typeof sg.r === "bigint" && typeof sg.s === "bigint";
    if (!isHex3 && !isObj)
      throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");
    if (isObj) {
      sig = new Signature2(sg.r, sg.s);
    } else if (isHex3) {
      try {
        sig = Signature2.fromBytes(ensureBytes("sig", sg), "der");
      } catch (derError) {
        if (!(derError instanceof DER.Err))
          throw derError;
      }
      if (!sig) {
        try {
          sig = Signature2.fromBytes(ensureBytes("sig", sg), "compact");
        } catch (error) {
          return false;
        }
      }
    }
    if (!sig)
      return false;
    return sig;
  }
  function verify2(signature2, message, publicKey5, opts = {}) {
    const { lowS, prehash, format: format2 } = validateSigOpts(opts, defaultSigOpts);
    publicKey5 = ensureBytes("publicKey", publicKey5);
    message = validateMsgAndHash(ensureBytes("message", message), prehash);
    if ("strict" in opts)
      throw new Error("options.strict was renamed to lowS");
    const sig = format2 === void 0 ? tryParsingSig(signature2) : Signature2.fromBytes(ensureBytes("sig", signature2), format2);
    if (sig === false)
      return false;
    try {
      const P = Point2.fromBytes(publicKey5);
      if (lowS && sig.hasHighS())
        return false;
      const { r, s } = sig;
      const h = bits2int_modN(message);
      const is3 = Fn2.inv(s);
      const u1 = Fn2.create(h * is3);
      const u2 = Fn2.create(r * is3);
      const R = Point2.BASE.multiplyUnsafe(u1).add(P.multiplyUnsafe(u2));
      if (R.is0())
        return false;
      const v = Fn2.create(R.x);
      return v === r;
    } catch (e) {
      return false;
    }
  }
  function recoverPublicKey3(signature2, message, opts = {}) {
    const { prehash } = validateSigOpts(opts, defaultSigOpts);
    message = validateMsgAndHash(message, prehash);
    return Signature2.fromBytes(signature2, "recovered").recoverPublicKey(message).toBytes();
  }
  return Object.freeze({
    keygen,
    getPublicKey: getPublicKey2,
    getSharedSecret: getSharedSecret3,
    utils: utils3,
    lengths,
    Point: Point2,
    sign: sign4,
    verify: verify2,
    recoverPublicKey: recoverPublicKey3,
    Signature: Signature2,
    hash: hash3
  });
}
function _weierstrass_legacy_opts_to_new(c) {
  const CURVE2 = {
    a: c.a,
    b: c.b,
    p: c.Fp.ORDER,
    n: c.n,
    h: c.h,
    Gx: c.Gx,
    Gy: c.Gy
  };
  const Fp3 = c.Fp;
  let allowedLengths = c.allowedPrivateKeyLengths ? Array.from(new Set(c.allowedPrivateKeyLengths.map((l) => Math.ceil(l / 2)))) : void 0;
  const Fn2 = Field(CURVE2.n, {
    BITS: c.nBitLength,
    allowedLengths,
    modFromBytes: c.wrapPrivateKey
  });
  const curveOpts = {
    Fp: Fp3,
    Fn: Fn2,
    allowInfinityPoint: c.allowInfinityPoint,
    endo: c.endo,
    isTorsionFree: c.isTorsionFree,
    clearCofactor: c.clearCofactor,
    fromBytes: c.fromBytes,
    toBytes: c.toBytes
  };
  return { CURVE: CURVE2, curveOpts };
}
function _ecdsa_legacy_opts_to_new(c) {
  const { CURVE: CURVE2, curveOpts } = _weierstrass_legacy_opts_to_new(c);
  const ecdsaOpts = {
    hmac: c.hmac,
    randomBytes: c.randomBytes,
    lowS: c.lowS,
    bits2int: c.bits2int,
    bits2int_modN: c.bits2int_modN
  };
  return { CURVE: CURVE2, curveOpts, hash: c.hash, ecdsaOpts };
}
function _ecdsa_new_output_to_legacy(c, _ecdsa) {
  const Point2 = _ecdsa.Point;
  return Object.assign({}, _ecdsa, {
    ProjectivePoint: Point2,
    CURVE: Object.assign({}, c, nLength(Point2.Fn.ORDER, Point2.Fn.BITS))
  });
}
function weierstrass(c) {
  const { CURVE: CURVE2, curveOpts, hash: hash3, ecdsaOpts } = _ecdsa_legacy_opts_to_new(c);
  const Point2 = weierstrassN(CURVE2, curveOpts);
  const signs = ecdsa(Point2, hash3, ecdsaOpts);
  return _ecdsa_new_output_to_legacy(c, signs);
}
var divNearest, DERErr, DER, _0n8, _1n8, _2n6, _3n3, _4n2;
var init_weierstrass = __esm({
  "node_modules/@noble/curves/esm/abstract/weierstrass.js"() {
    init_hmac();
    init_utils();
    init_utils2();
    init_curve();
    init_modular();
    divNearest = (num2, den) => (num2 + (num2 >= 0 ? den : -den) / _2n6) / den;
    DERErr = class extends Error {
      constructor(m = "") {
        super(m);
      }
    };
    DER = {
      // asn.1 DER encoding utils
      Err: DERErr,
      // Basic building block is TLV (Tag-Length-Value)
      _tlv: {
        encode: (tag, data) => {
          const { Err: E } = DER;
          if (tag < 0 || tag > 256)
            throw new E("tlv.encode: wrong tag");
          if (data.length & 1)
            throw new E("tlv.encode: unpadded data");
          const dataLen = data.length / 2;
          const len = numberToHexUnpadded(dataLen);
          if (len.length / 2 & 128)
            throw new E("tlv.encode: long form length too big");
          const lenLen = dataLen > 127 ? numberToHexUnpadded(len.length / 2 | 128) : "";
          const t = numberToHexUnpadded(tag);
          return t + lenLen + len + data;
        },
        // v - value, l - left bytes (unparsed)
        decode(tag, data) {
          const { Err: E } = DER;
          let pos = 0;
          if (tag < 0 || tag > 256)
            throw new E("tlv.encode: wrong tag");
          if (data.length < 2 || data[pos++] !== tag)
            throw new E("tlv.decode: wrong tlv");
          const first = data[pos++];
          const isLong = !!(first & 128);
          let length2 = 0;
          if (!isLong)
            length2 = first;
          else {
            const lenLen = first & 127;
            if (!lenLen)
              throw new E("tlv.decode(long): indefinite length not supported");
            if (lenLen > 4)
              throw new E("tlv.decode(long): byte length is too big");
            const lengthBytes = data.subarray(pos, pos + lenLen);
            if (lengthBytes.length !== lenLen)
              throw new E("tlv.decode: length bytes not complete");
            if (lengthBytes[0] === 0)
              throw new E("tlv.decode(long): zero leftmost byte");
            for (const b of lengthBytes)
              length2 = length2 << 8 | b;
            pos += lenLen;
            if (length2 < 128)
              throw new E("tlv.decode(long): not minimal encoding");
          }
          const v = data.subarray(pos, pos + length2);
          if (v.length !== length2)
            throw new E("tlv.decode: wrong value length");
          return { v, l: data.subarray(pos + length2) };
        }
      },
      // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,
      // since we always use positive integers here. It must always be empty:
      // - add zero byte if exists
      // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)
      _int: {
        encode(num2) {
          const { Err: E } = DER;
          if (num2 < _0n8)
            throw new E("integer: negative integers are not allowed");
          let hex3 = numberToHexUnpadded(num2);
          if (Number.parseInt(hex3[0], 16) & 8)
            hex3 = "00" + hex3;
          if (hex3.length & 1)
            throw new E("unexpected DER parsing assertion: unpadded hex");
          return hex3;
        },
        decode(data) {
          const { Err: E } = DER;
          if (data[0] & 128)
            throw new E("invalid signature integer: negative");
          if (data[0] === 0 && !(data[1] & 128))
            throw new E("invalid signature integer: unnecessary leading zero");
          return bytesToNumberBE(data);
        }
      },
      toSig(hex3) {
        const { Err: E, _int: int, _tlv: tlv } = DER;
        const data = ensureBytes("signature", hex3);
        const { v: seqBytes, l: seqLeftBytes } = tlv.decode(48, data);
        if (seqLeftBytes.length)
          throw new E("invalid signature: left bytes after parsing");
        const { v: rBytes, l: rLeftBytes } = tlv.decode(2, seqBytes);
        const { v: sBytes, l: sLeftBytes } = tlv.decode(2, rLeftBytes);
        if (sLeftBytes.length)
          throw new E("invalid signature: left bytes after parsing");
        return { r: int.decode(rBytes), s: int.decode(sBytes) };
      },
      hexFromSig(sig) {
        const { _tlv: tlv, _int: int } = DER;
        const rs = tlv.encode(2, int.encode(sig.r));
        const ss = tlv.encode(2, int.encode(sig.s));
        const seq4 = rs + ss;
        return tlv.encode(48, seq4);
      }
    };
    _0n8 = BigInt(0);
    _1n8 = BigInt(1);
    _2n6 = BigInt(2);
    _3n3 = BigInt(3);
    _4n2 = BigInt(4);
  }
});

// node_modules/@noble/curves/esm/_shortw_utils.js
function createCurve(curveDef, defHash) {
  const create4 = (hash3) => weierstrass({ ...curveDef, hash: hash3 });
  return { ...create4(defHash), create: create4 };
}
var init_shortw_utils = __esm({
  "node_modules/@noble/curves/esm/_shortw_utils.js"() {
    init_weierstrass();
  }
});

// node_modules/@noble/curves/esm/secp256k1.js
function sqrtMod(y) {
  const P = secp256k1_CURVE.p;
  const _3n6 = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
  const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
  const b2 = y * y * y % P;
  const b3 = b2 * b2 * y % P;
  const b6 = pow2(b3, _3n6, P) * b3 % P;
  const b9 = pow2(b6, _3n6, P) * b3 % P;
  const b11 = pow2(b9, _2n7, P) * b2 % P;
  const b22 = pow2(b11, _11n, P) * b11 % P;
  const b44 = pow2(b22, _22n, P) * b22 % P;
  const b88 = pow2(b44, _44n, P) * b44 % P;
  const b176 = pow2(b88, _88n, P) * b88 % P;
  const b220 = pow2(b176, _44n, P) * b44 % P;
  const b223 = pow2(b220, _3n6, P) * b3 % P;
  const t1 = pow2(b223, _23n, P) * b22 % P;
  const t2 = pow2(t1, _6n, P) * b2 % P;
  const root2 = pow2(t2, _2n7, P);
  if (!Fpk1.eql(Fpk1.sqr(root2), y))
    throw new Error("Cannot find square root");
  return root2;
}
function taggedHash(tag, ...messages3) {
  let tagP = TAGGED_HASH_PREFIXES[tag];
  if (tagP === void 0) {
    const tagH = sha2563(utf8ToBytes(tag));
    tagP = concatBytes2(tagH, tagH);
    TAGGED_HASH_PREFIXES[tag] = tagP;
  }
  return sha2563(concatBytes2(tagP, ...messages3));
}
function schnorrGetExtPubKey(priv) {
  const { Fn: Fn2, BASE: BASE2 } = Pointk1;
  const d_ = _normFnElement(Fn2, priv);
  const p = BASE2.multiply(d_);
  const scalar = hasEven(p.y) ? d_ : Fn2.neg(d_);
  return { scalar, bytes: pointToBytes(p) };
}
function lift_x(x) {
  const Fp3 = Fpk1;
  if (!Fp3.isValidNot0(x))
    throw new Error("invalid x: Fail if x ≥ p");
  const xx = Fp3.create(x * x);
  const c = Fp3.create(xx * x + BigInt(7));
  let y = Fp3.sqrt(c);
  if (!hasEven(y))
    y = Fp3.neg(y);
  const p = Pointk1.fromAffine({ x, y });
  p.assertValidity();
  return p;
}
function challenge(...args) {
  return Pointk1.Fn.create(num(taggedHash("BIP0340/challenge", ...args)));
}
function schnorrGetPublicKey(secretKey) {
  return schnorrGetExtPubKey(secretKey).bytes;
}
function schnorrSign(message, secretKey, auxRand = randomBytes(32)) {
  const { Fn: Fn2 } = Pointk1;
  const m = ensureBytes("message", message);
  const { bytes: px, scalar: d } = schnorrGetExtPubKey(secretKey);
  const a = ensureBytes("auxRand", auxRand, 32);
  const t = Fn2.toBytes(d ^ num(taggedHash("BIP0340/aux", a)));
  const rand = taggedHash("BIP0340/nonce", t, px, m);
  const { bytes: rx, scalar: k } = schnorrGetExtPubKey(rand);
  const e = challenge(rx, px, m);
  const sig = new Uint8Array(64);
  sig.set(rx, 0);
  sig.set(Fn2.toBytes(Fn2.create(k + e * d)), 32);
  if (!schnorrVerify(sig, m, px))
    throw new Error("sign: Invalid signature produced");
  return sig;
}
function schnorrVerify(signature2, message, publicKey5) {
  const { Fn: Fn2, BASE: BASE2 } = Pointk1;
  const sig = ensureBytes("signature", signature2, 64);
  const m = ensureBytes("message", message);
  const pub = ensureBytes("publicKey", publicKey5, 32);
  try {
    const P = lift_x(num(pub));
    const r = num(sig.subarray(0, 32));
    if (!inRange(r, _1n9, secp256k1_CURVE.p))
      return false;
    const s = num(sig.subarray(32, 64));
    if (!inRange(s, _1n9, secp256k1_CURVE.n))
      return false;
    const e = challenge(Fn2.toBytes(r), pointToBytes(P), m);
    const R = BASE2.multiplyUnsafe(s).add(P.multiplyUnsafe(Fn2.neg(e)));
    const { x, y } = R.toAffine();
    if (R.is0() || !hasEven(y) || x !== r)
      return false;
    return true;
  } catch (error) {
    return false;
  }
}
var secp256k1_CURVE, secp256k1_ENDO, _0n9, _1n9, _2n7, Fpk1, secp256k12, TAGGED_HASH_PREFIXES, pointToBytes, Pointk1, hasEven, num, schnorr, isoMap, mapSWU, secp256k1_hasher, hashToCurve2, encodeToCurve2;
var init_secp256k1 = __esm({
  "node_modules/@noble/curves/esm/secp256k1.js"() {
    init_sha2();
    init_utils();
    init_shortw_utils();
    init_hash_to_curve();
    init_modular();
    init_weierstrass();
    init_utils2();
    secp256k1_CURVE = {
      p: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
      n: BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
      h: BigInt(1),
      a: BigInt(0),
      b: BigInt(7),
      Gx: BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),
      Gy: BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")
    };
    secp256k1_ENDO = {
      beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
      basises: [
        [BigInt("0x3086d221a7d46bcde86c90e49284eb15"), -BigInt("0xe4437ed6010e88286f547fa90abfe4c3")],
        [BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), BigInt("0x3086d221a7d46bcde86c90e49284eb15")]
      ]
    };
    _0n9 = BigInt(0);
    _1n9 = BigInt(1);
    _2n7 = BigInt(2);
    Fpk1 = Field(secp256k1_CURVE.p, { sqrt: sqrtMod });
    secp256k12 = createCurve({ ...secp256k1_CURVE, Fp: Fpk1, lowS: true, endo: secp256k1_ENDO }, sha2563);
    TAGGED_HASH_PREFIXES = {};
    pointToBytes = (point) => point.toBytes(true).slice(1);
    Pointk1 = (() => secp256k12.Point)();
    hasEven = (y) => y % _2n7 === _0n9;
    num = bytesToNumberBE;
    schnorr = (() => {
      const size4 = 32;
      const seedLength = 48;
      const randomSecretKey = (seed2 = randomBytes(seedLength)) => {
        return mapHashToField(seed2, secp256k1_CURVE.n);
      };
      secp256k12.utils.randomSecretKey;
      function keygen(seed2) {
        const secretKey = randomSecretKey(seed2);
        return { secretKey, publicKey: schnorrGetPublicKey(secretKey) };
      }
      return {
        keygen,
        getPublicKey: schnorrGetPublicKey,
        sign: schnorrSign,
        verify: schnorrVerify,
        Point: Pointk1,
        utils: {
          randomSecretKey,
          randomPrivateKey: randomSecretKey,
          taggedHash,
          // TODO: remove
          lift_x,
          pointToBytes,
          numberToBytesBE,
          bytesToNumberBE,
          mod
        },
        lengths: {
          secretKey: size4,
          publicKey: size4,
          publicKeyHasPrefix: false,
          signature: size4 * 2,
          seed: seedLength
        }
      };
    })();
    isoMap = (() => isogenyMap(Fpk1, [
      // xNum
      [
        "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7",
        "0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581",
        "0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262",
        "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"
      ],
      // xDen
      [
        "0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b",
        "0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14",
        "0x0000000000000000000000000000000000000000000000000000000000000001"
        // LAST 1
      ],
      // yNum
      [
        "0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c",
        "0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3",
        "0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931",
        "0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"
      ],
      // yDen
      [
        "0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b",
        "0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573",
        "0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f",
        "0x0000000000000000000000000000000000000000000000000000000000000001"
        // LAST 1
      ]
    ].map((i) => i.map((j) => BigInt(j)))))();
    mapSWU = (() => mapToCurveSimpleSWU(Fpk1, {
      A: BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),
      B: BigInt("1771"),
      Z: Fpk1.create(BigInt("-11"))
    }))();
    secp256k1_hasher = (() => createHasher2(secp256k12.Point, (scalars) => {
      const { x, y } = mapSWU(Fpk1.create(scalars[0]));
      return isoMap(x, y);
    }, {
      DST: "secp256k1_XMD:SHA-256_SSWU_RO_",
      encodeDST: "secp256k1_XMD:SHA-256_SSWU_NU_",
      p: Fpk1.ORDER,
      m: 1,
      k: 128,
      expand: "xmd",
      hash: sha2563
    }))();
    hashToCurve2 = (() => secp256k1_hasher.hashToCurve)();
    encodeToCurve2 = (() => secp256k1_hasher.encodeToCurve)();
  }
});

// node_modules/@solana/web3.js/lib/index.browser.esm.js
var index_browser_esm_exports = {};
__export(index_browser_esm_exports, {
  Account: () => Account,
  AddressLookupTableAccount: () => AddressLookupTableAccount,
  AddressLookupTableInstruction: () => AddressLookupTableInstruction,
  AddressLookupTableProgram: () => AddressLookupTableProgram,
  Authorized: () => Authorized,
  BLOCKHASH_CACHE_TIMEOUT_MS: () => BLOCKHASH_CACHE_TIMEOUT_MS,
  BPF_LOADER_DEPRECATED_PROGRAM_ID: () => BPF_LOADER_DEPRECATED_PROGRAM_ID,
  BPF_LOADER_PROGRAM_ID: () => BPF_LOADER_PROGRAM_ID,
  BpfLoader: () => BpfLoader,
  COMPUTE_BUDGET_INSTRUCTION_LAYOUTS: () => COMPUTE_BUDGET_INSTRUCTION_LAYOUTS,
  ComputeBudgetInstruction: () => ComputeBudgetInstruction,
  ComputeBudgetProgram: () => ComputeBudgetProgram,
  Connection: () => Connection,
  Ed25519Program: () => Ed25519Program,
  Enum: () => Enum,
  EpochSchedule: () => EpochSchedule,
  FeeCalculatorLayout: () => FeeCalculatorLayout,
  Keypair: () => Keypair,
  LAMPORTS_PER_SOL: () => LAMPORTS_PER_SOL,
  LOOKUP_TABLE_INSTRUCTION_LAYOUTS: () => LOOKUP_TABLE_INSTRUCTION_LAYOUTS,
  Loader: () => Loader,
  Lockup: () => Lockup,
  MAX_SEED_LENGTH: () => MAX_SEED_LENGTH,
  Message: () => Message,
  MessageAccountKeys: () => MessageAccountKeys,
  MessageV0: () => MessageV0,
  NONCE_ACCOUNT_LENGTH: () => NONCE_ACCOUNT_LENGTH,
  NonceAccount: () => NonceAccount,
  PACKET_DATA_SIZE: () => PACKET_DATA_SIZE,
  PUBLIC_KEY_LENGTH: () => PUBLIC_KEY_LENGTH,
  PublicKey: () => PublicKey,
  SIGNATURE_LENGTH_IN_BYTES: () => SIGNATURE_LENGTH_IN_BYTES,
  SOLANA_SCHEMA: () => SOLANA_SCHEMA,
  STAKE_CONFIG_ID: () => STAKE_CONFIG_ID,
  STAKE_INSTRUCTION_LAYOUTS: () => STAKE_INSTRUCTION_LAYOUTS,
  SYSTEM_INSTRUCTION_LAYOUTS: () => SYSTEM_INSTRUCTION_LAYOUTS,
  SYSVAR_CLOCK_PUBKEY: () => SYSVAR_CLOCK_PUBKEY,
  SYSVAR_EPOCH_SCHEDULE_PUBKEY: () => SYSVAR_EPOCH_SCHEDULE_PUBKEY,
  SYSVAR_INSTRUCTIONS_PUBKEY: () => SYSVAR_INSTRUCTIONS_PUBKEY,
  SYSVAR_RECENT_BLOCKHASHES_PUBKEY: () => SYSVAR_RECENT_BLOCKHASHES_PUBKEY,
  SYSVAR_RENT_PUBKEY: () => SYSVAR_RENT_PUBKEY,
  SYSVAR_REWARDS_PUBKEY: () => SYSVAR_REWARDS_PUBKEY,
  SYSVAR_SLOT_HASHES_PUBKEY: () => SYSVAR_SLOT_HASHES_PUBKEY,
  SYSVAR_SLOT_HISTORY_PUBKEY: () => SYSVAR_SLOT_HISTORY_PUBKEY,
  SYSVAR_STAKE_HISTORY_PUBKEY: () => SYSVAR_STAKE_HISTORY_PUBKEY,
  Secp256k1Program: () => Secp256k1Program,
  SendTransactionError: () => SendTransactionError,
  SolanaJSONRPCError: () => SolanaJSONRPCError,
  SolanaJSONRPCErrorCode: () => SolanaJSONRPCErrorCode,
  StakeAuthorizationLayout: () => StakeAuthorizationLayout,
  StakeInstruction: () => StakeInstruction,
  StakeProgram: () => StakeProgram,
  Struct: () => Struct2,
  SystemInstruction: () => SystemInstruction,
  SystemProgram: () => SystemProgram,
  Transaction: () => Transaction,
  TransactionExpiredBlockheightExceededError: () => TransactionExpiredBlockheightExceededError,
  TransactionExpiredNonceInvalidError: () => TransactionExpiredNonceInvalidError,
  TransactionExpiredTimeoutError: () => TransactionExpiredTimeoutError,
  TransactionInstruction: () => TransactionInstruction,
  TransactionMessage: () => TransactionMessage,
  TransactionStatus: () => TransactionStatus,
  VALIDATOR_INFO_KEY: () => VALIDATOR_INFO_KEY,
  VERSION_PREFIX_MASK: () => VERSION_PREFIX_MASK,
  VOTE_PROGRAM_ID: () => VOTE_PROGRAM_ID,
  ValidatorInfo: () => ValidatorInfo,
  VersionedMessage: () => VersionedMessage,
  VersionedTransaction: () => VersionedTransaction,
  VoteAccount: () => VoteAccount,
  VoteAuthorizationLayout: () => VoteAuthorizationLayout,
  VoteInit: () => VoteInit,
  VoteInstruction: () => VoteInstruction,
  VoteProgram: () => VoteProgram,
  clusterApiUrl: () => clusterApiUrl,
  sendAndConfirmRawTransaction: () => sendAndConfirmRawTransaction,
  sendAndConfirmTransaction: () => sendAndConfirmTransaction
});
function isOnCurve(publicKey5) {
  try {
    ed25519.ExtendedPoint.fromHex(publicKey5);
    return true;
  } catch {
    return false;
  }
}
function isPublicKeyData(value) {
  return value._bn !== void 0;
}
function getAlloc(type3, fields) {
  const getItemAlloc = (item) => {
    if (item.span >= 0) {
      return item.span;
    } else if (typeof item.alloc === "function") {
      return item.alloc(fields[item.property]);
    } else if ("count" in item && "elementLayout" in item) {
      const field = fields[item.property];
      if (Array.isArray(field)) {
        return field.length * getItemAlloc(item.elementLayout);
      }
    } else if ("fields" in item) {
      return getAlloc({
        layout: item
      }, fields[item.property]);
    }
    return 0;
  };
  let alloc = 0;
  type3.layout.fields.forEach((item) => {
    alloc += getItemAlloc(item);
  });
  return alloc;
}
function decodeLength(bytes3) {
  let len = 0;
  let size4 = 0;
  for (; ; ) {
    let elem = bytes3.shift();
    len |= (elem & 127) << size4 * 7;
    size4 += 1;
    if ((elem & 128) === 0) {
      break;
    }
  }
  return len;
}
function encodeLength(bytes3, len) {
  let rem_len = len;
  for (; ; ) {
    let elem = rem_len & 127;
    rem_len >>= 7;
    if (rem_len == 0) {
      bytes3.push(elem);
      break;
    } else {
      elem |= 128;
      bytes3.push(elem);
    }
  }
}
function assert2(condition, message) {
  if (!condition) {
    throw new Error(message || "Assertion failed");
  }
}
function guardedShift(byteArray) {
  if (byteArray.length === 0) {
    throw new Error(END_OF_BUFFER_ERROR_MESSAGE);
  }
  return byteArray.shift();
}
function guardedSplice(byteArray, ...args) {
  const [start] = args;
  if (args.length === 2 ? start + (args[1] ?? 0) > byteArray.length : start >= byteArray.length) {
    throw new Error(END_OF_BUFFER_ERROR_MESSAGE);
  }
  return byteArray.splice(...args);
}
async function sendAndConfirmTransaction(connection, transaction, signers, options) {
  const sendOptions = options && {
    skipPreflight: options.skipPreflight,
    preflightCommitment: options.preflightCommitment || options.commitment,
    maxRetries: options.maxRetries,
    minContextSlot: options.minContextSlot
  };
  const signature2 = await connection.sendTransaction(transaction, signers, sendOptions);
  let status;
  if (transaction.recentBlockhash != null && transaction.lastValidBlockHeight != null) {
    status = (await connection.confirmTransaction({
      abortSignal: options == null ? void 0 : options.abortSignal,
      signature: signature2,
      blockhash: transaction.recentBlockhash,
      lastValidBlockHeight: transaction.lastValidBlockHeight
    }, options && options.commitment)).value;
  } else if (transaction.minNonceContextSlot != null && transaction.nonceInfo != null) {
    const {
      nonceInstruction
    } = transaction.nonceInfo;
    const nonceAccountPubkey = nonceInstruction.keys[0].pubkey;
    status = (await connection.confirmTransaction({
      abortSignal: options == null ? void 0 : options.abortSignal,
      minContextSlot: transaction.minNonceContextSlot,
      nonceAccountPubkey,
      nonceValue: transaction.nonceInfo.nonce,
      signature: signature2
    }, options && options.commitment)).value;
  } else {
    if ((options == null ? void 0 : options.abortSignal) != null) {
      console.warn("sendAndConfirmTransaction(): A transaction with a deprecated confirmation strategy was supplied along with an `abortSignal`. Only transactions having `lastValidBlockHeight` or a combination of `nonceInfo` and `minNonceContextSlot` are abortable.");
    }
    status = (await connection.confirmTransaction(signature2, options && options.commitment)).value;
  }
  if (status.err) {
    if (signature2 != null) {
      throw new SendTransactionError({
        action: "send",
        signature: signature2,
        transactionMessage: `Status: (${JSON.stringify(status)})`
      });
    }
    throw new Error(`Transaction ${signature2} failed (${JSON.stringify(status)})`);
  }
  return signature2;
}
function sleep(ms) {
  return new Promise((resolve2) => setTimeout(resolve2, ms));
}
function encodeData2(type3, fields) {
  const allocLength = type3.layout.span >= 0 ? type3.layout.span : getAlloc(type3, fields);
  const data = import_buffer2.Buffer.alloc(allocLength);
  const layoutFields = Object.assign({
    instruction: type3.index
  }, fields);
  type3.layout.encode(layoutFields, data);
  return data;
}
function decodeData$1(type3, buffer3) {
  let data;
  try {
    data = type3.layout.decode(buffer3);
  } catch (err2) {
    throw new Error("invalid instruction; " + err2);
  }
  if (data.instruction !== type3.index) {
    throw new Error(`invalid instruction; instruction index mismatch ${data.instruction} != ${type3.index}`);
  }
  return data;
}
function u64(property) {
  const layout = (0, import_buffer_layout.blob)(8, property);
  const decode4 = layout.decode.bind(layout);
  const encode4 = layout.encode.bind(layout);
  const bigIntLayout = layout;
  const codec = getU64Codec();
  bigIntLayout.decode = (buffer3, offset3) => {
    const src2 = decode4(buffer3, offset3);
    return codec.decode(src2);
  };
  bigIntLayout.encode = (bigInt2, buffer3, offset3) => {
    const src2 = codec.encode(bigInt2);
    return encode4(src2, buffer3, offset3);
  };
  return bigIntLayout;
}
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
function requireFastStableStringify() {
  if (hasRequiredFastStableStringify) return fastStableStringify$1;
  hasRequiredFastStableStringify = 1;
  var objToString = Object.prototype.toString;
  var objKeys = Object.keys || function(obj) {
    var keys = [];
    for (var name in obj) {
      keys.push(name);
    }
    return keys;
  };
  function stringify4(val, isArrayProp) {
    var i, max, str2, keys, key, propVal, toStr2;
    if (val === true) {
      return "true";
    }
    if (val === false) {
      return "false";
    }
    switch (typeof val) {
      case "object":
        if (val === null) {
          return null;
        } else if (val.toJSON && typeof val.toJSON === "function") {
          return stringify4(val.toJSON(), isArrayProp);
        } else {
          toStr2 = objToString.call(val);
          if (toStr2 === "[object Array]") {
            str2 = "[";
            max = val.length - 1;
            for (i = 0; i < max; i++) {
              str2 += stringify4(val[i], true) + ",";
            }
            if (max > -1) {
              str2 += stringify4(val[i], true);
            }
            return str2 + "]";
          } else if (toStr2 === "[object Object]") {
            keys = objKeys(val).sort();
            max = keys.length;
            str2 = "";
            i = 0;
            while (i < max) {
              key = keys[i];
              propVal = stringify4(val[key], false);
              if (propVal !== void 0) {
                if (str2) {
                  str2 += ",";
                }
                str2 += JSON.stringify(key) + ":" + propVal;
              }
              i++;
            }
            return "{" + str2 + "}";
          } else {
            return JSON.stringify(val);
          }
        }
      case "function":
      case "undefined":
        return isArrayProp ? null : void 0;
      case "string":
        return JSON.stringify(val);
      default:
        return isFinite(val) ? val : null;
    }
  }
  fastStableStringify$1 = function(val) {
    var returnVal = stringify4(val, false);
    if (returnVal !== void 0) {
      return "" + returnVal;
    }
  };
  return fastStableStringify$1;
}
function trailingZeros(n) {
  let trailingZeros2 = 0;
  while (n > 1) {
    n /= 2;
    trailingZeros2++;
  }
  return trailingZeros2;
}
function nextPowerOfTwo(n) {
  if (n === 0) return 1;
  n--;
  n |= n >> 1;
  n |= n >> 2;
  n |= n >> 4;
  n |= n >> 8;
  n |= n >> 16;
  n |= n >> 32;
  return n + 1;
}
function decodeData(type3, data) {
  let decoded;
  try {
    decoded = type3.layout.decode(data);
  } catch (err2) {
    throw new Error("invalid instruction; " + err2);
  }
  if (decoded.typeIndex !== type3.index) {
    throw new Error(`invalid account data; account type mismatch ${decoded.typeIndex} != ${type3.index}`);
  }
  return decoded;
}
function makeWebsocketUrl(endpoint2) {
  const matches = endpoint2.match(URL_RE);
  if (matches == null) {
    throw TypeError(`Failed to validate endpoint URL \`${endpoint2}\``);
  }
  const [
    _,
    // eslint-disable-line @typescript-eslint/no-unused-vars
    hostish,
    portWithColon,
    rest
  ] = matches;
  const protocol = endpoint2.startsWith("https:") ? "wss:" : "ws:";
  const startPort = portWithColon == null ? null : parseInt(portWithColon.slice(1), 10);
  const websocketPort = (
    // Only shift the port by +1 as a convention for ws(s) only if given endpoint
    // is explicitly specifying the endpoint port (HTTP-based RPC), assuming
    // we're directly trying to connect to agave-validator's ws listening port.
    // When the endpoint omits the port, we're connecting to the protocol
    // default ports: http(80) or https(443) and it's assumed we're behind a reverse
    // proxy which manages WebSocket upgrade and backend port redirection.
    startPort == null ? "" : `:${startPort + 1}`
  );
  return `${protocol}//${hostish}${websocketPort}${rest}`;
}
function assertEndpointUrl(putativeUrl) {
  if (/^https?:/.test(putativeUrl) === false) {
    throw new TypeError("Endpoint URL must start with `http:` or `https:`.");
  }
  return putativeUrl;
}
function extractCommitmentFromConfig(commitmentOrConfig) {
  let commitment;
  let config;
  if (typeof commitmentOrConfig === "string") {
    commitment = commitmentOrConfig;
  } else if (commitmentOrConfig) {
    const {
      commitment: specifiedCommitment,
      ...specifiedConfig
    } = commitmentOrConfig;
    commitment = specifiedCommitment;
    config = specifiedConfig;
  }
  return {
    commitment,
    config
  };
}
function applyDefaultMemcmpEncodingToFilters(filters) {
  return filters.map((filter) => "memcmp" in filter ? {
    ...filter,
    memcmp: {
      ...filter.memcmp,
      encoding: filter.memcmp.encoding ?? "base58"
    }
  } : filter);
}
function createRpcResult(result) {
  return union([type({
    jsonrpc: literal("2.0"),
    id: string(),
    result
  }), type({
    jsonrpc: literal("2.0"),
    id: string(),
    error: type({
      code: unknown(),
      message: string(),
      data: optional(any())
    })
  })]);
}
function jsonRpcResult(schema) {
  return coerce(createRpcResult(schema), UnknownRpcResult, (value) => {
    if ("error" in value) {
      return value;
    } else {
      return {
        ...value,
        result: create(value.result, schema)
      };
    }
  });
}
function jsonRpcResultAndContext(value) {
  return jsonRpcResult(type({
    context: type({
      slot: number()
    }),
    value
  }));
}
function notificationResultAndContext(value) {
  return type({
    context: type({
      slot: number()
    }),
    value
  });
}
function versionedMessageFromResponse(version3, response) {
  if (version3 === 0) {
    return new MessageV0({
      header: response.header,
      staticAccountKeys: response.accountKeys.map((accountKey) => new PublicKey(accountKey)),
      recentBlockhash: response.recentBlockhash,
      compiledInstructions: response.instructions.map((ix) => ({
        programIdIndex: ix.programIdIndex,
        accountKeyIndexes: ix.accounts,
        data: import_bs58.default.decode(ix.data)
      })),
      addressTableLookups: response.addressTableLookups
    });
  } else {
    return new Message(response);
  }
}
function createRpcClient(url, httpHeaders, customFetch, fetchMiddleware, disableRetryOnRateLimit, httpAgent) {
  const fetch3 = customFetch ? customFetch : fetchImpl;
  let agent;
  {
    if (httpAgent != null) {
      console.warn("You have supplied an `httpAgent` when creating a `Connection` in a browser environment.It has been ignored; `httpAgent` is only used in Node environments.");
    }
  }
  let fetchWithMiddleware;
  if (fetchMiddleware) {
    fetchWithMiddleware = async (info, init) => {
      const modifiedFetchArgs = await new Promise((resolve2, reject2) => {
        try {
          fetchMiddleware(info, init, (modifiedInfo, modifiedInit) => resolve2([modifiedInfo, modifiedInit]));
        } catch (error) {
          reject2(error);
        }
      });
      return await fetch3(...modifiedFetchArgs);
    };
  }
  const clientBrowser = new import_browser.default(async (request, callback) => {
    const options = {
      method: "POST",
      body: request,
      agent,
      headers: Object.assign({
        "Content-Type": "application/json"
      }, httpHeaders || {}, COMMON_HTTP_HEADERS)
    };
    try {
      let too_many_requests_retries = 5;
      let res;
      let waitTime = 500;
      for (; ; ) {
        if (fetchWithMiddleware) {
          res = await fetchWithMiddleware(url, options);
        } else {
          res = await fetch3(url, options);
        }
        if (res.status !== 429) {
          break;
        }
        if (disableRetryOnRateLimit === true) {
          break;
        }
        too_many_requests_retries -= 1;
        if (too_many_requests_retries === 0) {
          break;
        }
        console.error(`Server responded with ${res.status} ${res.statusText}.  Retrying after ${waitTime}ms delay...`);
        await sleep(waitTime);
        waitTime *= 2;
      }
      const text = await res.text();
      if (res.ok) {
        callback(null, text);
      } else {
        callback(new Error(`${res.status} ${res.statusText}: ${text}`));
      }
    } catch (err2) {
      if (err2 instanceof Error) callback(err2);
    }
  }, {});
  return clientBrowser;
}
function createRpcRequest(client) {
  return (method, args) => {
    return new Promise((resolve2, reject2) => {
      client.request(method, args, (err2, response) => {
        if (err2) {
          reject2(err2);
          return;
        }
        resolve2(response);
      });
    });
  };
}
function createRpcBatchRequest(client) {
  return (requests) => {
    return new Promise((resolve2, reject2) => {
      if (requests.length === 0) resolve2([]);
      const batch = requests.map((params) => {
        return client.request(params.methodName, params.args);
      });
      client.request(batch, (err2, response) => {
        if (err2) {
          reject2(err2);
          return;
        }
        resolve2(response);
      });
    });
  };
}
function parseAuthorizedVoter({
  authorizedVoter,
  epoch
}) {
  return {
    epoch,
    authorizedVoter: new PublicKey(authorizedVoter)
  };
}
function parsePriorVoters({
  authorizedPubkey,
  epochOfLastAuthorizedSwitch,
  targetEpoch
}) {
  return {
    authorizedPubkey: new PublicKey(authorizedPubkey),
    epochOfLastAuthorizedSwitch,
    targetEpoch
  };
}
function getPriorVoters({
  buf,
  idx,
  isEmpty
}) {
  if (isEmpty) {
    return [];
  }
  return [...buf.slice(idx + 1).map(parsePriorVoters), ...buf.slice(0, idx).map(parsePriorVoters)];
}
function clusterApiUrl(cluster, tls) {
  const key = tls === false ? "http" : "https";
  if (!cluster) {
    return endpoint[key]["devnet"];
  }
  const url = endpoint[key][cluster];
  if (!url) {
    throw new Error(`Unknown ${key} cluster: ${cluster}`);
  }
  return url;
}
async function sendAndConfirmRawTransaction(connection, rawTransaction, confirmationStrategyOrConfirmOptions, maybeConfirmOptions) {
  let confirmationStrategy;
  let options;
  if (confirmationStrategyOrConfirmOptions && Object.prototype.hasOwnProperty.call(confirmationStrategyOrConfirmOptions, "lastValidBlockHeight")) {
    confirmationStrategy = confirmationStrategyOrConfirmOptions;
    options = maybeConfirmOptions;
  } else if (confirmationStrategyOrConfirmOptions && Object.prototype.hasOwnProperty.call(confirmationStrategyOrConfirmOptions, "nonceValue")) {
    confirmationStrategy = confirmationStrategyOrConfirmOptions;
    options = maybeConfirmOptions;
  } else {
    options = confirmationStrategyOrConfirmOptions;
  }
  const sendOptions = options && {
    skipPreflight: options.skipPreflight,
    preflightCommitment: options.preflightCommitment || options.commitment,
    minContextSlot: options.minContextSlot
  };
  const signature2 = await connection.sendRawTransaction(rawTransaction, sendOptions);
  const commitment = options && options.commitment;
  const confirmationPromise = confirmationStrategy ? connection.confirmTransaction(confirmationStrategy, commitment) : connection.confirmTransaction(signature2, commitment);
  const status = (await confirmationPromise).value;
  if (status.err) {
    if (signature2 != null) {
      throw new SendTransactionError({
        action: (sendOptions == null ? void 0 : sendOptions.skipPreflight) ? "send" : "simulate",
        signature: signature2,
        transactionMessage: `Status: (${JSON.stringify(status)})`
      });
    }
    throw new Error(`Raw transaction ${signature2} failed (${JSON.stringify(status)})`);
  }
  return signature2;
}
var import_buffer2, import_bn, import_bs58, import_borsh, BufferLayout, import_buffer_layout, import_browser, generatePrivateKey, generateKeypair, getPublicKey, sign, verify, toBuffer, Struct2, Enum, SOLANA_SCHEMA, _PublicKey, MAX_SEED_LENGTH, PUBLIC_KEY_LENGTH, uniquePublicKeyCounter, PublicKey, Account, BPF_LOADER_DEPRECATED_PROGRAM_ID, PACKET_DATA_SIZE, VERSION_PREFIX_MASK, SIGNATURE_LENGTH_IN_BYTES, TransactionExpiredBlockheightExceededError, TransactionExpiredTimeoutError, TransactionExpiredNonceInvalidError, MessageAccountKeys, publicKey, signature, rustString, authorized, lockup, voteInit, voteAuthorizeWithSeedArgs, CompiledKeys, END_OF_BUFFER_ERROR_MESSAGE, Message, MessageV0, VersionedMessage, TransactionStatus, DEFAULT_SIGNATURE, TransactionInstruction, Transaction, TransactionMessage, VersionedTransaction, NUM_TICKS_PER_SECOND, DEFAULT_TICKS_PER_SLOT, NUM_SLOTS_PER_SECOND, MS_PER_SLOT, SYSVAR_CLOCK_PUBKEY, SYSVAR_EPOCH_SCHEDULE_PUBKEY, SYSVAR_INSTRUCTIONS_PUBKEY, SYSVAR_RECENT_BLOCKHASHES_PUBKEY, SYSVAR_RENT_PUBKEY, SYSVAR_REWARDS_PUBKEY, SYSVAR_SLOT_HASHES_PUBKEY, SYSVAR_SLOT_HISTORY_PUBKEY, SYSVAR_STAKE_HISTORY_PUBKEY, SendTransactionError, SolanaJSONRPCErrorCode, SolanaJSONRPCError, FeeCalculatorLayout, NonceAccountLayout, NONCE_ACCOUNT_LENGTH, NonceAccount, SystemInstruction, SYSTEM_INSTRUCTION_LAYOUTS, SystemProgram, CHUNK_SIZE, Loader, BPF_LOADER_PROGRAM_ID, BpfLoader, fastStableStringify$1, hasRequiredFastStableStringify, fastStableStringifyExports, fastStableStringify, MINIMUM_SLOT_PER_EPOCH, EpochSchedule, fetchImpl, RpcWebSocketClient, LOOKUP_TABLE_META_SIZE, AddressLookupTableAccount, LookupTableMetaLayout, URL_RE, PublicKeyFromString, RawAccountDataResult, BufferFromRawAccountData, BLOCKHASH_CACHE_TIMEOUT_MS, UnknownRpcResult, GetInflationGovernorResult, GetInflationRewardResult, GetRecentPrioritizationFeesResult, GetInflationRateResult, GetEpochInfoResult, GetEpochScheduleResult, GetLeaderScheduleResult, TransactionErrorResult, SignatureStatusResult, SignatureReceivedResult, VersionResult, ParsedInstructionStruct, PartiallyDecodedInstructionStruct, SimulatedTransactionResponseStruct, BlockProductionResponseStruct, GetInflationGovernorRpcResult, GetInflationRateRpcResult, GetRecentPrioritizationFeesRpcResult, GetEpochInfoRpcResult, GetEpochScheduleRpcResult, GetLeaderScheduleRpcResult, SlotRpcResult, GetSupplyRpcResult, TokenAmountResult, GetTokenLargestAccountsResult, GetTokenAccountsByOwner, ParsedAccountDataResult, GetParsedTokenAccountsByOwner, GetLargestAccountsRpcResult, AccountInfoResult, KeyedAccountInfoResult, ParsedOrRawAccountData, ParsedAccountInfoResult, KeyedParsedAccountInfoResult, StakeActivationResult, GetConfirmedSignaturesForAddress2RpcResult, GetSignaturesForAddressRpcResult, AccountNotificationResult, ProgramAccountInfoResult, ProgramAccountNotificationResult, SlotInfoResult, SlotNotificationResult, SlotUpdateResult, SlotUpdateNotificationResult, SignatureNotificationResult, RootNotificationResult, ContactInfoResult, VoteAccountInfoResult, GetVoteAccounts, ConfirmationStatus, SignatureStatusResponse, GetSignatureStatusesRpcResult, GetMinimumBalanceForRentExemptionRpcResult, AddressTableLookupStruct, ConfirmedTransactionResult, AnnotatedAccountKey, ConfirmedTransactionAccountsModeResult, ParsedInstructionResult, RawInstructionResult, InstructionResult, UnknownInstructionResult, ParsedOrRawInstruction, ParsedConfirmedTransactionResult, TokenBalanceResult, LoadedAddressesResult, ConfirmedTransactionMetaResult, ParsedConfirmedTransactionMetaResult, TransactionVersionStruct, RewardsResult, GetBlockRpcResult, GetNoneModeBlockRpcResult, GetAccountsModeBlockRpcResult, GetParsedBlockRpcResult, GetParsedAccountsModeBlockRpcResult, GetParsedNoneModeBlockRpcResult, GetConfirmedBlockRpcResult, GetBlockSignaturesRpcResult, GetTransactionRpcResult, GetParsedTransactionRpcResult, GetLatestBlockhashRpcResult, IsBlockhashValidRpcResult, PerfSampleResult, GetRecentPerformanceSamplesRpcResult, GetFeeCalculatorRpcResult, RequestAirdropRpcResult, SendTransactionRpcResult, LogsResult, LogsNotificationResult, COMMON_HTTP_HEADERS, Connection, Keypair, LOOKUP_TABLE_INSTRUCTION_LAYOUTS, AddressLookupTableInstruction, AddressLookupTableProgram, ComputeBudgetInstruction, COMPUTE_BUDGET_INSTRUCTION_LAYOUTS, ComputeBudgetProgram, PRIVATE_KEY_BYTES$1, PUBLIC_KEY_BYTES$1, SIGNATURE_BYTES, ED25519_INSTRUCTION_LAYOUT, Ed25519Program, ecdsaSign, publicKeyCreate, PRIVATE_KEY_BYTES, ETHEREUM_ADDRESS_BYTES, PUBLIC_KEY_BYTES, SIGNATURE_OFFSETS_SERIALIZED_SIZE, SECP256K1_INSTRUCTION_LAYOUT, Secp256k1Program, _Lockup, STAKE_CONFIG_ID, Authorized, Lockup, StakeInstruction, STAKE_INSTRUCTION_LAYOUTS, StakeAuthorizationLayout, StakeProgram, VoteInit, VoteInstruction, VOTE_INSTRUCTION_LAYOUTS, VoteAuthorizationLayout, VoteProgram, VALIDATOR_INFO_KEY, InfoString, ValidatorInfo, VOTE_PROGRAM_ID, VoteAccountLayout, VoteAccount, endpoint, LAMPORTS_PER_SOL;
var init_index_browser_esm = __esm({
  "node_modules/@solana/web3.js/lib/index.browser.esm.js"() {
    import_buffer2 = __toESM(require_buffer());
    init_ed25519();
    import_bn = __toESM(require_bn());
    import_bs58 = __toESM(require_bs58());
    init_sha256();
    import_borsh = __toESM(require_lib5());
    BufferLayout = __toESM(require_Layout());
    import_buffer_layout = __toESM(require_Layout());
    init_index_browser3();
    init_dist5();
    import_browser = __toESM(require_browser());
    init_index_browser4();
    init_sha3();
    init_secp256k1();
    generatePrivateKey = ed25519.utils.randomPrivateKey;
    generateKeypair = () => {
      const privateScalar = ed25519.utils.randomPrivateKey();
      const publicKey5 = getPublicKey(privateScalar);
      const secretKey = new Uint8Array(64);
      secretKey.set(privateScalar);
      secretKey.set(publicKey5, 32);
      return {
        publicKey: publicKey5,
        secretKey
      };
    };
    getPublicKey = ed25519.getPublicKey;
    sign = (message, secretKey) => ed25519.sign(message, secretKey.slice(0, 32));
    verify = ed25519.verify;
    toBuffer = (arr) => {
      if (import_buffer2.Buffer.isBuffer(arr)) {
        return arr;
      } else if (arr instanceof Uint8Array) {
        return import_buffer2.Buffer.from(arr.buffer, arr.byteOffset, arr.byteLength);
      } else {
        return import_buffer2.Buffer.from(arr);
      }
    };
    Struct2 = class {
      constructor(properties) {
        Object.assign(this, properties);
      }
      encode() {
        return import_buffer2.Buffer.from((0, import_borsh.serialize)(SOLANA_SCHEMA, this));
      }
      static decode(data) {
        return (0, import_borsh.deserialize)(SOLANA_SCHEMA, this, data);
      }
      static decodeUnchecked(data) {
        return (0, import_borsh.deserializeUnchecked)(SOLANA_SCHEMA, this, data);
      }
    };
    Enum = class extends Struct2 {
      constructor(properties) {
        super(properties);
        this.enum = "";
        if (Object.keys(properties).length !== 1) {
          throw new Error("Enum can only take single value");
        }
        Object.keys(properties).map((key) => {
          this.enum = key;
        });
      }
    };
    SOLANA_SCHEMA = /* @__PURE__ */ new Map();
    MAX_SEED_LENGTH = 32;
    PUBLIC_KEY_LENGTH = 32;
    uniquePublicKeyCounter = 1;
    PublicKey = class _PublicKey2 extends Struct2 {
      /**
       * Create a new PublicKey object
       * @param value ed25519 public key as buffer or base-58 encoded string
       */
      constructor(value) {
        super({});
        this._bn = void 0;
        if (isPublicKeyData(value)) {
          this._bn = value._bn;
        } else {
          if (typeof value === "string") {
            const decoded = import_bs58.default.decode(value);
            if (decoded.length != PUBLIC_KEY_LENGTH) {
              throw new Error(`Invalid public key input`);
            }
            this._bn = new import_bn.default(decoded);
          } else {
            this._bn = new import_bn.default(value);
          }
          if (this._bn.byteLength() > PUBLIC_KEY_LENGTH) {
            throw new Error(`Invalid public key input`);
          }
        }
      }
      /**
       * Returns a unique PublicKey for tests and benchmarks using a counter
       */
      static unique() {
        const key = new _PublicKey2(uniquePublicKeyCounter);
        uniquePublicKeyCounter += 1;
        return new _PublicKey2(key.toBuffer());
      }
      /**
       * Default public key value. The base58-encoded string representation is all ones (as seen below)
       * The underlying BN number is 32 bytes that are all zeros
       */
      /**
       * Checks if two publicKeys are equal
       */
      equals(publicKey5) {
        return this._bn.eq(publicKey5._bn);
      }
      /**
       * Return the base-58 representation of the public key
       */
      toBase58() {
        return import_bs58.default.encode(this.toBytes());
      }
      toJSON() {
        return this.toBase58();
      }
      /**
       * Return the byte array representation of the public key in big endian
       */
      toBytes() {
        const buf = this.toBuffer();
        return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);
      }
      /**
       * Return the Buffer representation of the public key in big endian
       */
      toBuffer() {
        const b = this._bn.toArrayLike(import_buffer2.Buffer);
        if (b.length === PUBLIC_KEY_LENGTH) {
          return b;
        }
        const zeroPad = import_buffer2.Buffer.alloc(32);
        b.copy(zeroPad, 32 - b.length);
        return zeroPad;
      }
      get [Symbol.toStringTag]() {
        return `PublicKey(${this.toString()})`;
      }
      /**
       * Return the base-58 representation of the public key
       */
      toString() {
        return this.toBase58();
      }
      /**
       * Derive a public key from another key, a seed, and a program ID.
       * The program ID will also serve as the owner of the public key, giving
       * it permission to write data to the account.
       */
      /* eslint-disable require-await */
      static async createWithSeed(fromPublicKey, seed2, programId) {
        const buffer3 = import_buffer2.Buffer.concat([fromPublicKey.toBuffer(), import_buffer2.Buffer.from(seed2), programId.toBuffer()]);
        const publicKeyBytes = sha2565(buffer3);
        return new _PublicKey2(publicKeyBytes);
      }
      /**
       * Derive a program address from seeds and a program ID.
       */
      /* eslint-disable require-await */
      static createProgramAddressSync(seeds, programId) {
        let buffer3 = import_buffer2.Buffer.alloc(0);
        seeds.forEach(function(seed2) {
          if (seed2.length > MAX_SEED_LENGTH) {
            throw new TypeError(`Max seed length exceeded`);
          }
          buffer3 = import_buffer2.Buffer.concat([buffer3, toBuffer(seed2)]);
        });
        buffer3 = import_buffer2.Buffer.concat([buffer3, programId.toBuffer(), import_buffer2.Buffer.from("ProgramDerivedAddress")]);
        const publicKeyBytes = sha2565(buffer3);
        if (isOnCurve(publicKeyBytes)) {
          throw new Error(`Invalid seeds, address must fall off the curve`);
        }
        return new _PublicKey2(publicKeyBytes);
      }
      /**
       * Async version of createProgramAddressSync
       * For backwards compatibility
       *
       * @deprecated Use {@link createProgramAddressSync} instead
       */
      /* eslint-disable require-await */
      static async createProgramAddress(seeds, programId) {
        return this.createProgramAddressSync(seeds, programId);
      }
      /**
       * Find a valid program address
       *
       * Valid program addresses must fall off the ed25519 curve.  This function
       * iterates a nonce until it finds one that when combined with the seeds
       * results in a valid program address.
       */
      static findProgramAddressSync(seeds, programId) {
        let nonce = 255;
        let address;
        while (nonce != 0) {
          try {
            const seedsWithNonce = seeds.concat(import_buffer2.Buffer.from([nonce]));
            address = this.createProgramAddressSync(seedsWithNonce, programId);
          } catch (err2) {
            if (err2 instanceof TypeError) {
              throw err2;
            }
            nonce--;
            continue;
          }
          return [address, nonce];
        }
        throw new Error(`Unable to find a viable program address nonce`);
      }
      /**
       * Async version of findProgramAddressSync
       * For backwards compatibility
       *
       * @deprecated Use {@link findProgramAddressSync} instead
       */
      static async findProgramAddress(seeds, programId) {
        return this.findProgramAddressSync(seeds, programId);
      }
      /**
       * Check that a pubkey is on the ed25519 curve.
       */
      static isOnCurve(pubkeyData) {
        const pubkey2 = new _PublicKey2(pubkeyData);
        return isOnCurve(pubkey2.toBytes());
      }
    };
    _PublicKey = PublicKey;
    PublicKey.default = new _PublicKey("11111111111111111111111111111111");
    SOLANA_SCHEMA.set(PublicKey, {
      kind: "struct",
      fields: [["_bn", "u256"]]
    });
    Account = class {
      /**
       * Create a new Account object
       *
       * If the secretKey parameter is not provided a new key pair is randomly
       * created for the account
       *
       * @param secretKey Secret key for the account
       */
      constructor(secretKey) {
        this._publicKey = void 0;
        this._secretKey = void 0;
        if (secretKey) {
          const secretKeyBuffer = toBuffer(secretKey);
          if (secretKey.length !== 64) {
            throw new Error("bad secret key size");
          }
          this._publicKey = secretKeyBuffer.slice(32, 64);
          this._secretKey = secretKeyBuffer.slice(0, 32);
        } else {
          this._secretKey = toBuffer(generatePrivateKey());
          this._publicKey = toBuffer(getPublicKey(this._secretKey));
        }
      }
      /**
       * The public key for this account
       */
      get publicKey() {
        return new PublicKey(this._publicKey);
      }
      /**
       * The **unencrypted** secret key for this account. The first 32 bytes
       * is the private scalar and the last 32 bytes is the public key.
       * Read more: https://blog.mozilla.org/warner/2011/11/29/ed25519-keys/
       */
      get secretKey() {
        return import_buffer2.Buffer.concat([this._secretKey, this._publicKey], 64);
      }
    };
    BPF_LOADER_DEPRECATED_PROGRAM_ID = new PublicKey("BPFLoader1111111111111111111111111111111111");
    PACKET_DATA_SIZE = 1280 - 40 - 8;
    VERSION_PREFIX_MASK = 127;
    SIGNATURE_LENGTH_IN_BYTES = 64;
    TransactionExpiredBlockheightExceededError = class extends Error {
      constructor(signature2) {
        super(`Signature ${signature2} has expired: block height exceeded.`);
        this.signature = void 0;
        this.signature = signature2;
      }
    };
    Object.defineProperty(TransactionExpiredBlockheightExceededError.prototype, "name", {
      value: "TransactionExpiredBlockheightExceededError"
    });
    TransactionExpiredTimeoutError = class extends Error {
      constructor(signature2, timeoutSeconds) {
        super(`Transaction was not confirmed in ${timeoutSeconds.toFixed(2)} seconds. It is unknown if it succeeded or failed. Check signature ${signature2} using the Solana Explorer or CLI tools.`);
        this.signature = void 0;
        this.signature = signature2;
      }
    };
    Object.defineProperty(TransactionExpiredTimeoutError.prototype, "name", {
      value: "TransactionExpiredTimeoutError"
    });
    TransactionExpiredNonceInvalidError = class extends Error {
      constructor(signature2) {
        super(`Signature ${signature2} has expired: the nonce is no longer valid.`);
        this.signature = void 0;
        this.signature = signature2;
      }
    };
    Object.defineProperty(TransactionExpiredNonceInvalidError.prototype, "name", {
      value: "TransactionExpiredNonceInvalidError"
    });
    MessageAccountKeys = class {
      constructor(staticAccountKeys, accountKeysFromLookups) {
        this.staticAccountKeys = void 0;
        this.accountKeysFromLookups = void 0;
        this.staticAccountKeys = staticAccountKeys;
        this.accountKeysFromLookups = accountKeysFromLookups;
      }
      keySegments() {
        const keySegments = [this.staticAccountKeys];
        if (this.accountKeysFromLookups) {
          keySegments.push(this.accountKeysFromLookups.writable);
          keySegments.push(this.accountKeysFromLookups.readonly);
        }
        return keySegments;
      }
      get(index4) {
        for (const keySegment of this.keySegments()) {
          if (index4 < keySegment.length) {
            return keySegment[index4];
          } else {
            index4 -= keySegment.length;
          }
        }
        return;
      }
      get length() {
        return this.keySegments().flat().length;
      }
      compileInstructions(instructions) {
        const U8_MAX = 255;
        if (this.length > U8_MAX + 1) {
          throw new Error("Account index overflow encountered during compilation");
        }
        const keyIndexMap = /* @__PURE__ */ new Map();
        this.keySegments().flat().forEach((key, index4) => {
          keyIndexMap.set(key.toBase58(), index4);
        });
        const findKeyIndex = (key) => {
          const keyIndex = keyIndexMap.get(key.toBase58());
          if (keyIndex === void 0) throw new Error("Encountered an unknown instruction account key during compilation");
          return keyIndex;
        };
        return instructions.map((instruction) => {
          return {
            programIdIndex: findKeyIndex(instruction.programId),
            accountKeyIndexes: instruction.keys.map((meta) => findKeyIndex(meta.pubkey)),
            data: instruction.data
          };
        });
      }
    };
    publicKey = (property = "publicKey") => {
      return BufferLayout.blob(32, property);
    };
    signature = (property = "signature") => {
      return BufferLayout.blob(64, property);
    };
    rustString = (property = "string") => {
      const rsl = BufferLayout.struct([BufferLayout.u32("length"), BufferLayout.u32("lengthPadding"), BufferLayout.blob(BufferLayout.offset(BufferLayout.u32(), -8), "chars")], property);
      const _decode = rsl.decode.bind(rsl);
      const _encode = rsl.encode.bind(rsl);
      const rslShim = rsl;
      rslShim.decode = (b, offset3) => {
        const data = _decode(b, offset3);
        return data["chars"].toString();
      };
      rslShim.encode = (str2, b, offset3) => {
        const data = {
          chars: import_buffer2.Buffer.from(str2, "utf8")
        };
        return _encode(data, b, offset3);
      };
      rslShim.alloc = (str2) => {
        return BufferLayout.u32().span + BufferLayout.u32().span + import_buffer2.Buffer.from(str2, "utf8").length;
      };
      return rslShim;
    };
    authorized = (property = "authorized") => {
      return BufferLayout.struct([publicKey("staker"), publicKey("withdrawer")], property);
    };
    lockup = (property = "lockup") => {
      return BufferLayout.struct([BufferLayout.ns64("unixTimestamp"), BufferLayout.ns64("epoch"), publicKey("custodian")], property);
    };
    voteInit = (property = "voteInit") => {
      return BufferLayout.struct([publicKey("nodePubkey"), publicKey("authorizedVoter"), publicKey("authorizedWithdrawer"), BufferLayout.u8("commission")], property);
    };
    voteAuthorizeWithSeedArgs = (property = "voteAuthorizeWithSeedArgs") => {
      return BufferLayout.struct([BufferLayout.u32("voteAuthorizationType"), publicKey("currentAuthorityDerivedKeyOwnerPubkey"), rustString("currentAuthorityDerivedKeySeed"), publicKey("newAuthorized")], property);
    };
    CompiledKeys = class _CompiledKeys {
      constructor(payer, keyMetaMap) {
        this.payer = void 0;
        this.keyMetaMap = void 0;
        this.payer = payer;
        this.keyMetaMap = keyMetaMap;
      }
      static compile(instructions, payer) {
        const keyMetaMap = /* @__PURE__ */ new Map();
        const getOrInsertDefault = (pubkey2) => {
          const address = pubkey2.toBase58();
          let keyMeta = keyMetaMap.get(address);
          if (keyMeta === void 0) {
            keyMeta = {
              isSigner: false,
              isWritable: false,
              isInvoked: false
            };
            keyMetaMap.set(address, keyMeta);
          }
          return keyMeta;
        };
        const payerKeyMeta = getOrInsertDefault(payer);
        payerKeyMeta.isSigner = true;
        payerKeyMeta.isWritable = true;
        for (const ix of instructions) {
          getOrInsertDefault(ix.programId).isInvoked = true;
          for (const accountMeta of ix.keys) {
            const keyMeta = getOrInsertDefault(accountMeta.pubkey);
            keyMeta.isSigner || (keyMeta.isSigner = accountMeta.isSigner);
            keyMeta.isWritable || (keyMeta.isWritable = accountMeta.isWritable);
          }
        }
        return new _CompiledKeys(payer, keyMetaMap);
      }
      getMessageComponents() {
        const mapEntries = [...this.keyMetaMap.entries()];
        assert2(mapEntries.length <= 256, "Max static account keys length exceeded");
        const writableSigners = mapEntries.filter(([, meta]) => meta.isSigner && meta.isWritable);
        const readonlySigners = mapEntries.filter(([, meta]) => meta.isSigner && !meta.isWritable);
        const writableNonSigners = mapEntries.filter(([, meta]) => !meta.isSigner && meta.isWritable);
        const readonlyNonSigners = mapEntries.filter(([, meta]) => !meta.isSigner && !meta.isWritable);
        const header = {
          numRequiredSignatures: writableSigners.length + readonlySigners.length,
          numReadonlySignedAccounts: readonlySigners.length,
          numReadonlyUnsignedAccounts: readonlyNonSigners.length
        };
        {
          assert2(writableSigners.length > 0, "Expected at least one writable signer key");
          const [payerAddress] = writableSigners[0];
          assert2(payerAddress === this.payer.toBase58(), "Expected first writable signer key to be the fee payer");
        }
        const staticAccountKeys = [...writableSigners.map(([address]) => new PublicKey(address)), ...readonlySigners.map(([address]) => new PublicKey(address)), ...writableNonSigners.map(([address]) => new PublicKey(address)), ...readonlyNonSigners.map(([address]) => new PublicKey(address))];
        return [header, staticAccountKeys];
      }
      extractTableLookup(lookupTable) {
        const [writableIndexes, drainedWritableKeys] = this.drainKeysFoundInLookupTable(lookupTable.state.addresses, (keyMeta) => !keyMeta.isSigner && !keyMeta.isInvoked && keyMeta.isWritable);
        const [readonlyIndexes, drainedReadonlyKeys] = this.drainKeysFoundInLookupTable(lookupTable.state.addresses, (keyMeta) => !keyMeta.isSigner && !keyMeta.isInvoked && !keyMeta.isWritable);
        if (writableIndexes.length === 0 && readonlyIndexes.length === 0) {
          return;
        }
        return [{
          accountKey: lookupTable.key,
          writableIndexes,
          readonlyIndexes
        }, {
          writable: drainedWritableKeys,
          readonly: drainedReadonlyKeys
        }];
      }
      /** @internal */
      drainKeysFoundInLookupTable(lookupTableEntries, keyMetaFilter) {
        const lookupTableIndexes = new Array();
        const drainedKeys = new Array();
        for (const [address, keyMeta] of this.keyMetaMap.entries()) {
          if (keyMetaFilter(keyMeta)) {
            const key = new PublicKey(address);
            const lookupTableIndex = lookupTableEntries.findIndex((entry) => entry.equals(key));
            if (lookupTableIndex >= 0) {
              assert2(lookupTableIndex < 256, "Max lookup table index exceeded");
              lookupTableIndexes.push(lookupTableIndex);
              drainedKeys.push(key);
              this.keyMetaMap.delete(address);
            }
          }
        }
        return [lookupTableIndexes, drainedKeys];
      }
    };
    END_OF_BUFFER_ERROR_MESSAGE = "Reached end of buffer unexpectedly";
    Message = class _Message {
      constructor(args) {
        this.header = void 0;
        this.accountKeys = void 0;
        this.recentBlockhash = void 0;
        this.instructions = void 0;
        this.indexToProgramIds = /* @__PURE__ */ new Map();
        this.header = args.header;
        this.accountKeys = args.accountKeys.map((account) => new PublicKey(account));
        this.recentBlockhash = args.recentBlockhash;
        this.instructions = args.instructions;
        this.instructions.forEach((ix) => this.indexToProgramIds.set(ix.programIdIndex, this.accountKeys[ix.programIdIndex]));
      }
      get version() {
        return "legacy";
      }
      get staticAccountKeys() {
        return this.accountKeys;
      }
      get compiledInstructions() {
        return this.instructions.map((ix) => ({
          programIdIndex: ix.programIdIndex,
          accountKeyIndexes: ix.accounts,
          data: import_bs58.default.decode(ix.data)
        }));
      }
      get addressTableLookups() {
        return [];
      }
      getAccountKeys() {
        return new MessageAccountKeys(this.staticAccountKeys);
      }
      static compile(args) {
        const compiledKeys = CompiledKeys.compile(args.instructions, args.payerKey);
        const [header, staticAccountKeys] = compiledKeys.getMessageComponents();
        const accountKeys = new MessageAccountKeys(staticAccountKeys);
        const instructions = accountKeys.compileInstructions(args.instructions).map((ix) => ({
          programIdIndex: ix.programIdIndex,
          accounts: ix.accountKeyIndexes,
          data: import_bs58.default.encode(ix.data)
        }));
        return new _Message({
          header,
          accountKeys: staticAccountKeys,
          recentBlockhash: args.recentBlockhash,
          instructions
        });
      }
      isAccountSigner(index4) {
        return index4 < this.header.numRequiredSignatures;
      }
      isAccountWritable(index4) {
        const numSignedAccounts = this.header.numRequiredSignatures;
        if (index4 >= this.header.numRequiredSignatures) {
          const unsignedAccountIndex = index4 - numSignedAccounts;
          const numUnsignedAccounts = this.accountKeys.length - numSignedAccounts;
          const numWritableUnsignedAccounts = numUnsignedAccounts - this.header.numReadonlyUnsignedAccounts;
          return unsignedAccountIndex < numWritableUnsignedAccounts;
        } else {
          const numWritableSignedAccounts = numSignedAccounts - this.header.numReadonlySignedAccounts;
          return index4 < numWritableSignedAccounts;
        }
      }
      isProgramId(index4) {
        return this.indexToProgramIds.has(index4);
      }
      programIds() {
        return [...this.indexToProgramIds.values()];
      }
      nonProgramIds() {
        return this.accountKeys.filter((_, index4) => !this.isProgramId(index4));
      }
      serialize() {
        const numKeys = this.accountKeys.length;
        let keyCount = [];
        encodeLength(keyCount, numKeys);
        const instructions = this.instructions.map((instruction) => {
          const {
            accounts,
            programIdIndex
          } = instruction;
          const data = Array.from(import_bs58.default.decode(instruction.data));
          let keyIndicesCount = [];
          encodeLength(keyIndicesCount, accounts.length);
          let dataCount = [];
          encodeLength(dataCount, data.length);
          return {
            programIdIndex,
            keyIndicesCount: import_buffer2.Buffer.from(keyIndicesCount),
            keyIndices: accounts,
            dataLength: import_buffer2.Buffer.from(dataCount),
            data
          };
        });
        let instructionCount = [];
        encodeLength(instructionCount, instructions.length);
        let instructionBuffer = import_buffer2.Buffer.alloc(PACKET_DATA_SIZE);
        import_buffer2.Buffer.from(instructionCount).copy(instructionBuffer);
        let instructionBufferLength = instructionCount.length;
        instructions.forEach((instruction) => {
          const instructionLayout = BufferLayout.struct([BufferLayout.u8("programIdIndex"), BufferLayout.blob(instruction.keyIndicesCount.length, "keyIndicesCount"), BufferLayout.seq(BufferLayout.u8("keyIndex"), instruction.keyIndices.length, "keyIndices"), BufferLayout.blob(instruction.dataLength.length, "dataLength"), BufferLayout.seq(BufferLayout.u8("userdatum"), instruction.data.length, "data")]);
          const length3 = instructionLayout.encode(instruction, instructionBuffer, instructionBufferLength);
          instructionBufferLength += length3;
        });
        instructionBuffer = instructionBuffer.slice(0, instructionBufferLength);
        const signDataLayout = BufferLayout.struct([BufferLayout.blob(1, "numRequiredSignatures"), BufferLayout.blob(1, "numReadonlySignedAccounts"), BufferLayout.blob(1, "numReadonlyUnsignedAccounts"), BufferLayout.blob(keyCount.length, "keyCount"), BufferLayout.seq(publicKey("key"), numKeys, "keys"), publicKey("recentBlockhash")]);
        const transaction = {
          numRequiredSignatures: import_buffer2.Buffer.from([this.header.numRequiredSignatures]),
          numReadonlySignedAccounts: import_buffer2.Buffer.from([this.header.numReadonlySignedAccounts]),
          numReadonlyUnsignedAccounts: import_buffer2.Buffer.from([this.header.numReadonlyUnsignedAccounts]),
          keyCount: import_buffer2.Buffer.from(keyCount),
          keys: this.accountKeys.map((key) => toBuffer(key.toBytes())),
          recentBlockhash: import_bs58.default.decode(this.recentBlockhash)
        };
        let signData = import_buffer2.Buffer.alloc(2048);
        const length2 = signDataLayout.encode(transaction, signData);
        instructionBuffer.copy(signData, length2);
        return signData.slice(0, length2 + instructionBuffer.length);
      }
      /**
       * Decode a compiled message into a Message object.
       */
      static from(buffer3) {
        let byteArray = [...buffer3];
        const numRequiredSignatures = guardedShift(byteArray);
        if (numRequiredSignatures !== (numRequiredSignatures & VERSION_PREFIX_MASK)) {
          throw new Error("Versioned messages must be deserialized with VersionedMessage.deserialize()");
        }
        const numReadonlySignedAccounts = guardedShift(byteArray);
        const numReadonlyUnsignedAccounts = guardedShift(byteArray);
        const accountCount = decodeLength(byteArray);
        let accountKeys = [];
        for (let i = 0; i < accountCount; i++) {
          const account = guardedSplice(byteArray, 0, PUBLIC_KEY_LENGTH);
          accountKeys.push(new PublicKey(import_buffer2.Buffer.from(account)));
        }
        const recentBlockhash = guardedSplice(byteArray, 0, PUBLIC_KEY_LENGTH);
        const instructionCount = decodeLength(byteArray);
        let instructions = [];
        for (let i = 0; i < instructionCount; i++) {
          const programIdIndex = guardedShift(byteArray);
          const accountCount2 = decodeLength(byteArray);
          const accounts = guardedSplice(byteArray, 0, accountCount2);
          const dataLength = decodeLength(byteArray);
          const dataSlice = guardedSplice(byteArray, 0, dataLength);
          const data = import_bs58.default.encode(import_buffer2.Buffer.from(dataSlice));
          instructions.push({
            programIdIndex,
            accounts,
            data
          });
        }
        const messageArgs = {
          header: {
            numRequiredSignatures,
            numReadonlySignedAccounts,
            numReadonlyUnsignedAccounts
          },
          recentBlockhash: import_bs58.default.encode(import_buffer2.Buffer.from(recentBlockhash)),
          accountKeys,
          instructions
        };
        return new _Message(messageArgs);
      }
    };
    MessageV0 = class _MessageV0 {
      constructor(args) {
        this.header = void 0;
        this.staticAccountKeys = void 0;
        this.recentBlockhash = void 0;
        this.compiledInstructions = void 0;
        this.addressTableLookups = void 0;
        this.header = args.header;
        this.staticAccountKeys = args.staticAccountKeys;
        this.recentBlockhash = args.recentBlockhash;
        this.compiledInstructions = args.compiledInstructions;
        this.addressTableLookups = args.addressTableLookups;
      }
      get version() {
        return 0;
      }
      get numAccountKeysFromLookups() {
        let count = 0;
        for (const lookup2 of this.addressTableLookups) {
          count += lookup2.readonlyIndexes.length + lookup2.writableIndexes.length;
        }
        return count;
      }
      getAccountKeys(args) {
        let accountKeysFromLookups;
        if (args && "accountKeysFromLookups" in args && args.accountKeysFromLookups) {
          if (this.numAccountKeysFromLookups != args.accountKeysFromLookups.writable.length + args.accountKeysFromLookups.readonly.length) {
            throw new Error("Failed to get account keys because of a mismatch in the number of account keys from lookups");
          }
          accountKeysFromLookups = args.accountKeysFromLookups;
        } else if (args && "addressLookupTableAccounts" in args && args.addressLookupTableAccounts) {
          accountKeysFromLookups = this.resolveAddressTableLookups(args.addressLookupTableAccounts);
        } else if (this.addressTableLookups.length > 0) {
          throw new Error("Failed to get account keys because address table lookups were not resolved");
        }
        return new MessageAccountKeys(this.staticAccountKeys, accountKeysFromLookups);
      }
      isAccountSigner(index4) {
        return index4 < this.header.numRequiredSignatures;
      }
      isAccountWritable(index4) {
        const numSignedAccounts = this.header.numRequiredSignatures;
        const numStaticAccountKeys = this.staticAccountKeys.length;
        if (index4 >= numStaticAccountKeys) {
          const lookupAccountKeysIndex = index4 - numStaticAccountKeys;
          const numWritableLookupAccountKeys = this.addressTableLookups.reduce((count, lookup2) => count + lookup2.writableIndexes.length, 0);
          return lookupAccountKeysIndex < numWritableLookupAccountKeys;
        } else if (index4 >= this.header.numRequiredSignatures) {
          const unsignedAccountIndex = index4 - numSignedAccounts;
          const numUnsignedAccounts = numStaticAccountKeys - numSignedAccounts;
          const numWritableUnsignedAccounts = numUnsignedAccounts - this.header.numReadonlyUnsignedAccounts;
          return unsignedAccountIndex < numWritableUnsignedAccounts;
        } else {
          const numWritableSignedAccounts = numSignedAccounts - this.header.numReadonlySignedAccounts;
          return index4 < numWritableSignedAccounts;
        }
      }
      resolveAddressTableLookups(addressLookupTableAccounts) {
        const accountKeysFromLookups = {
          writable: [],
          readonly: []
        };
        for (const tableLookup of this.addressTableLookups) {
          const tableAccount = addressLookupTableAccounts.find((account) => account.key.equals(tableLookup.accountKey));
          if (!tableAccount) {
            throw new Error(`Failed to find address lookup table account for table key ${tableLookup.accountKey.toBase58()}`);
          }
          for (const index4 of tableLookup.writableIndexes) {
            if (index4 < tableAccount.state.addresses.length) {
              accountKeysFromLookups.writable.push(tableAccount.state.addresses[index4]);
            } else {
              throw new Error(`Failed to find address for index ${index4} in address lookup table ${tableLookup.accountKey.toBase58()}`);
            }
          }
          for (const index4 of tableLookup.readonlyIndexes) {
            if (index4 < tableAccount.state.addresses.length) {
              accountKeysFromLookups.readonly.push(tableAccount.state.addresses[index4]);
            } else {
              throw new Error(`Failed to find address for index ${index4} in address lookup table ${tableLookup.accountKey.toBase58()}`);
            }
          }
        }
        return accountKeysFromLookups;
      }
      static compile(args) {
        const compiledKeys = CompiledKeys.compile(args.instructions, args.payerKey);
        const addressTableLookups = new Array();
        const accountKeysFromLookups = {
          writable: new Array(),
          readonly: new Array()
        };
        const lookupTableAccounts = args.addressLookupTableAccounts || [];
        for (const lookupTable of lookupTableAccounts) {
          const extractResult = compiledKeys.extractTableLookup(lookupTable);
          if (extractResult !== void 0) {
            const [addressTableLookup, {
              writable,
              readonly
            }] = extractResult;
            addressTableLookups.push(addressTableLookup);
            accountKeysFromLookups.writable.push(...writable);
            accountKeysFromLookups.readonly.push(...readonly);
          }
        }
        const [header, staticAccountKeys] = compiledKeys.getMessageComponents();
        const accountKeys = new MessageAccountKeys(staticAccountKeys, accountKeysFromLookups);
        const compiledInstructions = accountKeys.compileInstructions(args.instructions);
        return new _MessageV0({
          header,
          staticAccountKeys,
          recentBlockhash: args.recentBlockhash,
          compiledInstructions,
          addressTableLookups
        });
      }
      serialize() {
        const encodedStaticAccountKeysLength = Array();
        encodeLength(encodedStaticAccountKeysLength, this.staticAccountKeys.length);
        const serializedInstructions = this.serializeInstructions();
        const encodedInstructionsLength = Array();
        encodeLength(encodedInstructionsLength, this.compiledInstructions.length);
        const serializedAddressTableLookups = this.serializeAddressTableLookups();
        const encodedAddressTableLookupsLength = Array();
        encodeLength(encodedAddressTableLookupsLength, this.addressTableLookups.length);
        const messageLayout = BufferLayout.struct([BufferLayout.u8("prefix"), BufferLayout.struct([BufferLayout.u8("numRequiredSignatures"), BufferLayout.u8("numReadonlySignedAccounts"), BufferLayout.u8("numReadonlyUnsignedAccounts")], "header"), BufferLayout.blob(encodedStaticAccountKeysLength.length, "staticAccountKeysLength"), BufferLayout.seq(publicKey(), this.staticAccountKeys.length, "staticAccountKeys"), publicKey("recentBlockhash"), BufferLayout.blob(encodedInstructionsLength.length, "instructionsLength"), BufferLayout.blob(serializedInstructions.length, "serializedInstructions"), BufferLayout.blob(encodedAddressTableLookupsLength.length, "addressTableLookupsLength"), BufferLayout.blob(serializedAddressTableLookups.length, "serializedAddressTableLookups")]);
        const serializedMessage = new Uint8Array(PACKET_DATA_SIZE);
        const MESSAGE_VERSION_0_PREFIX = 1 << 7;
        const serializedMessageLength = messageLayout.encode({
          prefix: MESSAGE_VERSION_0_PREFIX,
          header: this.header,
          staticAccountKeysLength: new Uint8Array(encodedStaticAccountKeysLength),
          staticAccountKeys: this.staticAccountKeys.map((key) => key.toBytes()),
          recentBlockhash: import_bs58.default.decode(this.recentBlockhash),
          instructionsLength: new Uint8Array(encodedInstructionsLength),
          serializedInstructions,
          addressTableLookupsLength: new Uint8Array(encodedAddressTableLookupsLength),
          serializedAddressTableLookups
        }, serializedMessage);
        return serializedMessage.slice(0, serializedMessageLength);
      }
      serializeInstructions() {
        let serializedLength = 0;
        const serializedInstructions = new Uint8Array(PACKET_DATA_SIZE);
        for (const instruction of this.compiledInstructions) {
          const encodedAccountKeyIndexesLength = Array();
          encodeLength(encodedAccountKeyIndexesLength, instruction.accountKeyIndexes.length);
          const encodedDataLength = Array();
          encodeLength(encodedDataLength, instruction.data.length);
          const instructionLayout = BufferLayout.struct([BufferLayout.u8("programIdIndex"), BufferLayout.blob(encodedAccountKeyIndexesLength.length, "encodedAccountKeyIndexesLength"), BufferLayout.seq(BufferLayout.u8(), instruction.accountKeyIndexes.length, "accountKeyIndexes"), BufferLayout.blob(encodedDataLength.length, "encodedDataLength"), BufferLayout.blob(instruction.data.length, "data")]);
          serializedLength += instructionLayout.encode({
            programIdIndex: instruction.programIdIndex,
            encodedAccountKeyIndexesLength: new Uint8Array(encodedAccountKeyIndexesLength),
            accountKeyIndexes: instruction.accountKeyIndexes,
            encodedDataLength: new Uint8Array(encodedDataLength),
            data: instruction.data
          }, serializedInstructions, serializedLength);
        }
        return serializedInstructions.slice(0, serializedLength);
      }
      serializeAddressTableLookups() {
        let serializedLength = 0;
        const serializedAddressTableLookups = new Uint8Array(PACKET_DATA_SIZE);
        for (const lookup2 of this.addressTableLookups) {
          const encodedWritableIndexesLength = Array();
          encodeLength(encodedWritableIndexesLength, lookup2.writableIndexes.length);
          const encodedReadonlyIndexesLength = Array();
          encodeLength(encodedReadonlyIndexesLength, lookup2.readonlyIndexes.length);
          const addressTableLookupLayout = BufferLayout.struct([publicKey("accountKey"), BufferLayout.blob(encodedWritableIndexesLength.length, "encodedWritableIndexesLength"), BufferLayout.seq(BufferLayout.u8(), lookup2.writableIndexes.length, "writableIndexes"), BufferLayout.blob(encodedReadonlyIndexesLength.length, "encodedReadonlyIndexesLength"), BufferLayout.seq(BufferLayout.u8(), lookup2.readonlyIndexes.length, "readonlyIndexes")]);
          serializedLength += addressTableLookupLayout.encode({
            accountKey: lookup2.accountKey.toBytes(),
            encodedWritableIndexesLength: new Uint8Array(encodedWritableIndexesLength),
            writableIndexes: lookup2.writableIndexes,
            encodedReadonlyIndexesLength: new Uint8Array(encodedReadonlyIndexesLength),
            readonlyIndexes: lookup2.readonlyIndexes
          }, serializedAddressTableLookups, serializedLength);
        }
        return serializedAddressTableLookups.slice(0, serializedLength);
      }
      static deserialize(serializedMessage) {
        let byteArray = [...serializedMessage];
        const prefix = guardedShift(byteArray);
        const maskedPrefix = prefix & VERSION_PREFIX_MASK;
        assert2(prefix !== maskedPrefix, `Expected versioned message but received legacy message`);
        const version3 = maskedPrefix;
        assert2(version3 === 0, `Expected versioned message with version 0 but found version ${version3}`);
        const header = {
          numRequiredSignatures: guardedShift(byteArray),
          numReadonlySignedAccounts: guardedShift(byteArray),
          numReadonlyUnsignedAccounts: guardedShift(byteArray)
        };
        const staticAccountKeys = [];
        const staticAccountKeysLength = decodeLength(byteArray);
        for (let i = 0; i < staticAccountKeysLength; i++) {
          staticAccountKeys.push(new PublicKey(guardedSplice(byteArray, 0, PUBLIC_KEY_LENGTH)));
        }
        const recentBlockhash = import_bs58.default.encode(guardedSplice(byteArray, 0, PUBLIC_KEY_LENGTH));
        const instructionCount = decodeLength(byteArray);
        const compiledInstructions = [];
        for (let i = 0; i < instructionCount; i++) {
          const programIdIndex = guardedShift(byteArray);
          const accountKeyIndexesLength = decodeLength(byteArray);
          const accountKeyIndexes = guardedSplice(byteArray, 0, accountKeyIndexesLength);
          const dataLength = decodeLength(byteArray);
          const data = new Uint8Array(guardedSplice(byteArray, 0, dataLength));
          compiledInstructions.push({
            programIdIndex,
            accountKeyIndexes,
            data
          });
        }
        const addressTableLookupsCount = decodeLength(byteArray);
        const addressTableLookups = [];
        for (let i = 0; i < addressTableLookupsCount; i++) {
          const accountKey = new PublicKey(guardedSplice(byteArray, 0, PUBLIC_KEY_LENGTH));
          const writableIndexesLength = decodeLength(byteArray);
          const writableIndexes = guardedSplice(byteArray, 0, writableIndexesLength);
          const readonlyIndexesLength = decodeLength(byteArray);
          const readonlyIndexes = guardedSplice(byteArray, 0, readonlyIndexesLength);
          addressTableLookups.push({
            accountKey,
            writableIndexes,
            readonlyIndexes
          });
        }
        return new _MessageV0({
          header,
          staticAccountKeys,
          recentBlockhash,
          compiledInstructions,
          addressTableLookups
        });
      }
    };
    VersionedMessage = {
      deserializeMessageVersion(serializedMessage) {
        const prefix = serializedMessage[0];
        const maskedPrefix = prefix & VERSION_PREFIX_MASK;
        if (maskedPrefix === prefix) {
          return "legacy";
        }
        return maskedPrefix;
      },
      deserialize: (serializedMessage) => {
        const version3 = VersionedMessage.deserializeMessageVersion(serializedMessage);
        if (version3 === "legacy") {
          return Message.from(serializedMessage);
        }
        if (version3 === 0) {
          return MessageV0.deserialize(serializedMessage);
        } else {
          throw new Error(`Transaction message version ${version3} deserialization is not supported`);
        }
      }
    };
    TransactionStatus = (function(TransactionStatus2) {
      TransactionStatus2[TransactionStatus2["BLOCKHEIGHT_EXCEEDED"] = 0] = "BLOCKHEIGHT_EXCEEDED";
      TransactionStatus2[TransactionStatus2["PROCESSED"] = 1] = "PROCESSED";
      TransactionStatus2[TransactionStatus2["TIMED_OUT"] = 2] = "TIMED_OUT";
      TransactionStatus2[TransactionStatus2["NONCE_INVALID"] = 3] = "NONCE_INVALID";
      return TransactionStatus2;
    })({});
    DEFAULT_SIGNATURE = import_buffer2.Buffer.alloc(SIGNATURE_LENGTH_IN_BYTES).fill(0);
    TransactionInstruction = class {
      constructor(opts) {
        this.keys = void 0;
        this.programId = void 0;
        this.data = import_buffer2.Buffer.alloc(0);
        this.programId = opts.programId;
        this.keys = opts.keys;
        if (opts.data) {
          this.data = opts.data;
        }
      }
      /**
       * @internal
       */
      toJSON() {
        return {
          keys: this.keys.map(({
            pubkey: pubkey2,
            isSigner,
            isWritable
          }) => ({
            pubkey: pubkey2.toJSON(),
            isSigner,
            isWritable
          })),
          programId: this.programId.toJSON(),
          data: [...this.data]
        };
      }
    };
    Transaction = class _Transaction {
      /**
       * The first (payer) Transaction signature
       *
       * @returns {Buffer | null} Buffer of payer's signature
       */
      get signature() {
        if (this.signatures.length > 0) {
          return this.signatures[0].signature;
        }
        return null;
      }
      /**
       * The transaction fee payer
       */
      // Construct a transaction with a blockhash and lastValidBlockHeight
      // Construct a transaction using a durable nonce
      /**
       * @deprecated `TransactionCtorFields` has been deprecated and will be removed in a future version.
       * Please supply a `TransactionBlockhashCtor` instead.
       */
      /**
       * Construct an empty Transaction
       */
      constructor(opts) {
        this.signatures = [];
        this.feePayer = void 0;
        this.instructions = [];
        this.recentBlockhash = void 0;
        this.lastValidBlockHeight = void 0;
        this.nonceInfo = void 0;
        this.minNonceContextSlot = void 0;
        this._message = void 0;
        this._json = void 0;
        if (!opts) {
          return;
        }
        if (opts.feePayer) {
          this.feePayer = opts.feePayer;
        }
        if (opts.signatures) {
          this.signatures = opts.signatures;
        }
        if (Object.prototype.hasOwnProperty.call(opts, "nonceInfo")) {
          const {
            minContextSlot,
            nonceInfo
          } = opts;
          this.minNonceContextSlot = minContextSlot;
          this.nonceInfo = nonceInfo;
        } else if (Object.prototype.hasOwnProperty.call(opts, "lastValidBlockHeight")) {
          const {
            blockhash,
            lastValidBlockHeight
          } = opts;
          this.recentBlockhash = blockhash;
          this.lastValidBlockHeight = lastValidBlockHeight;
        } else {
          const {
            recentBlockhash,
            nonceInfo
          } = opts;
          if (nonceInfo) {
            this.nonceInfo = nonceInfo;
          }
          this.recentBlockhash = recentBlockhash;
        }
      }
      /**
       * @internal
       */
      toJSON() {
        return {
          recentBlockhash: this.recentBlockhash || null,
          feePayer: this.feePayer ? this.feePayer.toJSON() : null,
          nonceInfo: this.nonceInfo ? {
            nonce: this.nonceInfo.nonce,
            nonceInstruction: this.nonceInfo.nonceInstruction.toJSON()
          } : null,
          instructions: this.instructions.map((instruction) => instruction.toJSON()),
          signers: this.signatures.map(({
            publicKey: publicKey5
          }) => {
            return publicKey5.toJSON();
          })
        };
      }
      /**
       * Add one or more instructions to this Transaction
       *
       * @param {Array< Transaction | TransactionInstruction | TransactionInstructionCtorFields >} items - Instructions to add to the Transaction
       */
      add(...items) {
        if (items.length === 0) {
          throw new Error("No instructions");
        }
        items.forEach((item) => {
          if ("instructions" in item) {
            this.instructions = this.instructions.concat(item.instructions);
          } else if ("data" in item && "programId" in item && "keys" in item) {
            this.instructions.push(item);
          } else {
            this.instructions.push(new TransactionInstruction(item));
          }
        });
        return this;
      }
      /**
       * Compile transaction data
       */
      compileMessage() {
        if (this._message && JSON.stringify(this.toJSON()) === JSON.stringify(this._json)) {
          return this._message;
        }
        let recentBlockhash;
        let instructions;
        if (this.nonceInfo) {
          recentBlockhash = this.nonceInfo.nonce;
          if (this.instructions[0] != this.nonceInfo.nonceInstruction) {
            instructions = [this.nonceInfo.nonceInstruction, ...this.instructions];
          } else {
            instructions = this.instructions;
          }
        } else {
          recentBlockhash = this.recentBlockhash;
          instructions = this.instructions;
        }
        if (!recentBlockhash) {
          throw new Error("Transaction recentBlockhash required");
        }
        if (instructions.length < 1) {
          console.warn("No instructions provided");
        }
        let feePayer;
        if (this.feePayer) {
          feePayer = this.feePayer;
        } else if (this.signatures.length > 0 && this.signatures[0].publicKey) {
          feePayer = this.signatures[0].publicKey;
        } else {
          throw new Error("Transaction fee payer required");
        }
        for (let i = 0; i < instructions.length; i++) {
          if (instructions[i].programId === void 0) {
            throw new Error(`Transaction instruction index ${i} has undefined program id`);
          }
        }
        const programIds = [];
        const accountMetas = [];
        instructions.forEach((instruction) => {
          instruction.keys.forEach((accountMeta) => {
            accountMetas.push({
              ...accountMeta
            });
          });
          const programId = instruction.programId.toString();
          if (!programIds.includes(programId)) {
            programIds.push(programId);
          }
        });
        programIds.forEach((programId) => {
          accountMetas.push({
            pubkey: new PublicKey(programId),
            isSigner: false,
            isWritable: false
          });
        });
        const uniqueMetas = [];
        accountMetas.forEach((accountMeta) => {
          const pubkeyString = accountMeta.pubkey.toString();
          const uniqueIndex = uniqueMetas.findIndex((x) => {
            return x.pubkey.toString() === pubkeyString;
          });
          if (uniqueIndex > -1) {
            uniqueMetas[uniqueIndex].isWritable = uniqueMetas[uniqueIndex].isWritable || accountMeta.isWritable;
            uniqueMetas[uniqueIndex].isSigner = uniqueMetas[uniqueIndex].isSigner || accountMeta.isSigner;
          } else {
            uniqueMetas.push(accountMeta);
          }
        });
        uniqueMetas.sort(function(x, y) {
          if (x.isSigner !== y.isSigner) {
            return x.isSigner ? -1 : 1;
          }
          if (x.isWritable !== y.isWritable) {
            return x.isWritable ? -1 : 1;
          }
          const options = {
            localeMatcher: "best fit",
            usage: "sort",
            sensitivity: "variant",
            ignorePunctuation: false,
            numeric: false,
            caseFirst: "lower"
          };
          return x.pubkey.toBase58().localeCompare(y.pubkey.toBase58(), "en", options);
        });
        const feePayerIndex = uniqueMetas.findIndex((x) => {
          return x.pubkey.equals(feePayer);
        });
        if (feePayerIndex > -1) {
          const [payerMeta] = uniqueMetas.splice(feePayerIndex, 1);
          payerMeta.isSigner = true;
          payerMeta.isWritable = true;
          uniqueMetas.unshift(payerMeta);
        } else {
          uniqueMetas.unshift({
            pubkey: feePayer,
            isSigner: true,
            isWritable: true
          });
        }
        for (const signature2 of this.signatures) {
          const uniqueIndex = uniqueMetas.findIndex((x) => {
            return x.pubkey.equals(signature2.publicKey);
          });
          if (uniqueIndex > -1) {
            if (!uniqueMetas[uniqueIndex].isSigner) {
              uniqueMetas[uniqueIndex].isSigner = true;
              console.warn("Transaction references a signature that is unnecessary, only the fee payer and instruction signer accounts should sign a transaction. This behavior is deprecated and will throw an error in the next major version release.");
            }
          } else {
            throw new Error(`unknown signer: ${signature2.publicKey.toString()}`);
          }
        }
        let numRequiredSignatures = 0;
        let numReadonlySignedAccounts = 0;
        let numReadonlyUnsignedAccounts = 0;
        const signedKeys = [];
        const unsignedKeys = [];
        uniqueMetas.forEach(({
          pubkey: pubkey2,
          isSigner,
          isWritable
        }) => {
          if (isSigner) {
            signedKeys.push(pubkey2.toString());
            numRequiredSignatures += 1;
            if (!isWritable) {
              numReadonlySignedAccounts += 1;
            }
          } else {
            unsignedKeys.push(pubkey2.toString());
            if (!isWritable) {
              numReadonlyUnsignedAccounts += 1;
            }
          }
        });
        const accountKeys = signedKeys.concat(unsignedKeys);
        const compiledInstructions = instructions.map((instruction) => {
          const {
            data,
            programId
          } = instruction;
          return {
            programIdIndex: accountKeys.indexOf(programId.toString()),
            accounts: instruction.keys.map((meta) => accountKeys.indexOf(meta.pubkey.toString())),
            data: import_bs58.default.encode(data)
          };
        });
        compiledInstructions.forEach((instruction) => {
          assert2(instruction.programIdIndex >= 0);
          instruction.accounts.forEach((keyIndex) => assert2(keyIndex >= 0));
        });
        return new Message({
          header: {
            numRequiredSignatures,
            numReadonlySignedAccounts,
            numReadonlyUnsignedAccounts
          },
          accountKeys,
          recentBlockhash,
          instructions: compiledInstructions
        });
      }
      /**
       * @internal
       */
      _compile() {
        const message = this.compileMessage();
        const signedKeys = message.accountKeys.slice(0, message.header.numRequiredSignatures);
        if (this.signatures.length === signedKeys.length) {
          const valid = this.signatures.every((pair, index4) => {
            return signedKeys[index4].equals(pair.publicKey);
          });
          if (valid) return message;
        }
        this.signatures = signedKeys.map((publicKey5) => ({
          signature: null,
          publicKey: publicKey5
        }));
        return message;
      }
      /**
       * Get a buffer of the Transaction data that need to be covered by signatures
       */
      serializeMessage() {
        return this._compile().serialize();
      }
      /**
       * Get the estimated fee associated with a transaction
       *
       * @param {Connection} connection Connection to RPC Endpoint.
       *
       * @returns {Promise<number | null>} The estimated fee for the transaction
       */
      async getEstimatedFee(connection) {
        return (await connection.getFeeForMessage(this.compileMessage())).value;
      }
      /**
       * Specify the public keys which will be used to sign the Transaction.
       * The first signer will be used as the transaction fee payer account.
       *
       * Signatures can be added with either `partialSign` or `addSignature`
       *
       * @deprecated Deprecated since v0.84.0. Only the fee payer needs to be
       * specified and it can be set in the Transaction constructor or with the
       * `feePayer` property.
       */
      setSigners(...signers) {
        if (signers.length === 0) {
          throw new Error("No signers");
        }
        const seen = /* @__PURE__ */ new Set();
        this.signatures = signers.filter((publicKey5) => {
          const key = publicKey5.toString();
          if (seen.has(key)) {
            return false;
          } else {
            seen.add(key);
            return true;
          }
        }).map((publicKey5) => ({
          signature: null,
          publicKey: publicKey5
        }));
      }
      /**
       * Sign the Transaction with the specified signers. Multiple signatures may
       * be applied to a Transaction. The first signature is considered "primary"
       * and is used identify and confirm transactions.
       *
       * If the Transaction `feePayer` is not set, the first signer will be used
       * as the transaction fee payer account.
       *
       * Transaction fields should not be modified after the first call to `sign`,
       * as doing so may invalidate the signature and cause the Transaction to be
       * rejected.
       *
       * The Transaction must be assigned a valid `recentBlockhash` before invoking this method
       *
       * @param {Array<Signer>} signers Array of signers that will sign the transaction
       */
      sign(...signers) {
        if (signers.length === 0) {
          throw new Error("No signers");
        }
        const seen = /* @__PURE__ */ new Set();
        const uniqueSigners = [];
        for (const signer of signers) {
          const key = signer.publicKey.toString();
          if (seen.has(key)) {
            continue;
          } else {
            seen.add(key);
            uniqueSigners.push(signer);
          }
        }
        this.signatures = uniqueSigners.map((signer) => ({
          signature: null,
          publicKey: signer.publicKey
        }));
        const message = this._compile();
        this._partialSign(message, ...uniqueSigners);
      }
      /**
       * Partially sign a transaction with the specified accounts. All accounts must
       * correspond to either the fee payer or a signer account in the transaction
       * instructions.
       *
       * All the caveats from the `sign` method apply to `partialSign`
       *
       * @param {Array<Signer>} signers Array of signers that will sign the transaction
       */
      partialSign(...signers) {
        if (signers.length === 0) {
          throw new Error("No signers");
        }
        const seen = /* @__PURE__ */ new Set();
        const uniqueSigners = [];
        for (const signer of signers) {
          const key = signer.publicKey.toString();
          if (seen.has(key)) {
            continue;
          } else {
            seen.add(key);
            uniqueSigners.push(signer);
          }
        }
        const message = this._compile();
        this._partialSign(message, ...uniqueSigners);
      }
      /**
       * @internal
       */
      _partialSign(message, ...signers) {
        const signData = message.serialize();
        signers.forEach((signer) => {
          const signature2 = sign(signData, signer.secretKey);
          this._addSignature(signer.publicKey, toBuffer(signature2));
        });
      }
      /**
       * Add an externally created signature to a transaction. The public key
       * must correspond to either the fee payer or a signer account in the transaction
       * instructions.
       *
       * @param {PublicKey} pubkey Public key that will be added to the transaction.
       * @param {Buffer} signature An externally created signature to add to the transaction.
       */
      addSignature(pubkey2, signature2) {
        this._compile();
        this._addSignature(pubkey2, signature2);
      }
      /**
       * @internal
       */
      _addSignature(pubkey2, signature2) {
        assert2(signature2.length === 64);
        const index4 = this.signatures.findIndex((sigpair) => pubkey2.equals(sigpair.publicKey));
        if (index4 < 0) {
          throw new Error(`unknown signer: ${pubkey2.toString()}`);
        }
        this.signatures[index4].signature = import_buffer2.Buffer.from(signature2);
      }
      /**
       * Verify signatures of a Transaction
       * Optional parameter specifies if we're expecting a fully signed Transaction or a partially signed one.
       * If no boolean is provided, we expect a fully signed Transaction by default.
       *
       * @param {boolean} [requireAllSignatures=true] Require a fully signed Transaction
       */
      verifySignatures(requireAllSignatures = true) {
        const signatureErrors = this._getMessageSignednessErrors(this.serializeMessage(), requireAllSignatures);
        return !signatureErrors;
      }
      /**
       * @internal
       */
      _getMessageSignednessErrors(message, requireAllSignatures) {
        const errors2 = {};
        for (const {
          signature: signature2,
          publicKey: publicKey5
        } of this.signatures) {
          if (signature2 === null) {
            if (requireAllSignatures) {
              (errors2.missing || (errors2.missing = [])).push(publicKey5);
            }
          } else {
            if (!verify(signature2, message, publicKey5.toBytes())) {
              (errors2.invalid || (errors2.invalid = [])).push(publicKey5);
            }
          }
        }
        return errors2.invalid || errors2.missing ? errors2 : void 0;
      }
      /**
       * Serialize the Transaction in the wire format.
       *
       * @param {Buffer} [config] Config of transaction.
       *
       * @returns {Buffer} Signature of transaction in wire format.
       */
      serialize(config) {
        const {
          requireAllSignatures,
          verifySignatures
        } = Object.assign({
          requireAllSignatures: true,
          verifySignatures: true
        }, config);
        const signData = this.serializeMessage();
        if (verifySignatures) {
          const sigErrors = this._getMessageSignednessErrors(signData, requireAllSignatures);
          if (sigErrors) {
            let errorMessage = "Signature verification failed.";
            if (sigErrors.invalid) {
              errorMessage += `
Invalid signature for public key${sigErrors.invalid.length === 1 ? "" : "(s)"} [\`${sigErrors.invalid.map((p) => p.toBase58()).join("`, `")}\`].`;
            }
            if (sigErrors.missing) {
              errorMessage += `
Missing signature for public key${sigErrors.missing.length === 1 ? "" : "(s)"} [\`${sigErrors.missing.map((p) => p.toBase58()).join("`, `")}\`].`;
            }
            throw new Error(errorMessage);
          }
        }
        return this._serialize(signData);
      }
      /**
       * @internal
       */
      _serialize(signData) {
        const {
          signatures
        } = this;
        const signatureCount = [];
        encodeLength(signatureCount, signatures.length);
        const transactionLength = signatureCount.length + signatures.length * 64 + signData.length;
        const wireTransaction = import_buffer2.Buffer.alloc(transactionLength);
        assert2(signatures.length < 256);
        import_buffer2.Buffer.from(signatureCount).copy(wireTransaction, 0);
        signatures.forEach(({
          signature: signature2
        }, index4) => {
          if (signature2 !== null) {
            assert2(signature2.length === 64, `signature has invalid length`);
            import_buffer2.Buffer.from(signature2).copy(wireTransaction, signatureCount.length + index4 * 64);
          }
        });
        signData.copy(wireTransaction, signatureCount.length + signatures.length * 64);
        assert2(wireTransaction.length <= PACKET_DATA_SIZE, `Transaction too large: ${wireTransaction.length} > ${PACKET_DATA_SIZE}`);
        return wireTransaction;
      }
      /**
       * Deprecated method
       * @internal
       */
      get keys() {
        assert2(this.instructions.length === 1);
        return this.instructions[0].keys.map((keyObj) => keyObj.pubkey);
      }
      /**
       * Deprecated method
       * @internal
       */
      get programId() {
        assert2(this.instructions.length === 1);
        return this.instructions[0].programId;
      }
      /**
       * Deprecated method
       * @internal
       */
      get data() {
        assert2(this.instructions.length === 1);
        return this.instructions[0].data;
      }
      /**
       * Parse a wire transaction into a Transaction object.
       *
       * @param {Buffer | Uint8Array | Array<number>} buffer Signature of wire Transaction
       *
       * @returns {Transaction} Transaction associated with the signature
       */
      static from(buffer3) {
        let byteArray = [...buffer3];
        const signatureCount = decodeLength(byteArray);
        let signatures = [];
        for (let i = 0; i < signatureCount; i++) {
          const signature2 = guardedSplice(byteArray, 0, SIGNATURE_LENGTH_IN_BYTES);
          signatures.push(import_bs58.default.encode(import_buffer2.Buffer.from(signature2)));
        }
        return _Transaction.populate(Message.from(byteArray), signatures);
      }
      /**
       * Populate Transaction object from message and signatures
       *
       * @param {Message} message Message of transaction
       * @param {Array<string>} signatures List of signatures to assign to the transaction
       *
       * @returns {Transaction} The populated Transaction
       */
      static populate(message, signatures = []) {
        const transaction = new _Transaction();
        transaction.recentBlockhash = message.recentBlockhash;
        if (message.header.numRequiredSignatures > 0) {
          transaction.feePayer = message.accountKeys[0];
        }
        signatures.forEach((signature2, index4) => {
          const sigPubkeyPair = {
            signature: signature2 == import_bs58.default.encode(DEFAULT_SIGNATURE) ? null : import_bs58.default.decode(signature2),
            publicKey: message.accountKeys[index4]
          };
          transaction.signatures.push(sigPubkeyPair);
        });
        message.instructions.forEach((instruction) => {
          const keys = instruction.accounts.map((account) => {
            const pubkey2 = message.accountKeys[account];
            return {
              pubkey: pubkey2,
              isSigner: transaction.signatures.some((keyObj) => keyObj.publicKey.toString() === pubkey2.toString()) || message.isAccountSigner(account),
              isWritable: message.isAccountWritable(account)
            };
          });
          transaction.instructions.push(new TransactionInstruction({
            keys,
            programId: message.accountKeys[instruction.programIdIndex],
            data: import_bs58.default.decode(instruction.data)
          }));
        });
        transaction._message = message;
        transaction._json = transaction.toJSON();
        return transaction;
      }
    };
    TransactionMessage = class _TransactionMessage {
      constructor(args) {
        this.payerKey = void 0;
        this.instructions = void 0;
        this.recentBlockhash = void 0;
        this.payerKey = args.payerKey;
        this.instructions = args.instructions;
        this.recentBlockhash = args.recentBlockhash;
      }
      static decompile(message, args) {
        const {
          header,
          compiledInstructions,
          recentBlockhash
        } = message;
        const {
          numRequiredSignatures,
          numReadonlySignedAccounts,
          numReadonlyUnsignedAccounts
        } = header;
        const numWritableSignedAccounts = numRequiredSignatures - numReadonlySignedAccounts;
        assert2(numWritableSignedAccounts > 0, "Message header is invalid");
        const numWritableUnsignedAccounts = message.staticAccountKeys.length - numRequiredSignatures - numReadonlyUnsignedAccounts;
        assert2(numWritableUnsignedAccounts >= 0, "Message header is invalid");
        const accountKeys = message.getAccountKeys(args);
        const payerKey = accountKeys.get(0);
        if (payerKey === void 0) {
          throw new Error("Failed to decompile message because no account keys were found");
        }
        const instructions = [];
        for (const compiledIx of compiledInstructions) {
          const keys = [];
          for (const keyIndex of compiledIx.accountKeyIndexes) {
            const pubkey2 = accountKeys.get(keyIndex);
            if (pubkey2 === void 0) {
              throw new Error(`Failed to find key for account key index ${keyIndex}`);
            }
            const isSigner = keyIndex < numRequiredSignatures;
            let isWritable;
            if (isSigner) {
              isWritable = keyIndex < numWritableSignedAccounts;
            } else if (keyIndex < accountKeys.staticAccountKeys.length) {
              isWritable = keyIndex - numRequiredSignatures < numWritableUnsignedAccounts;
            } else {
              isWritable = keyIndex - accountKeys.staticAccountKeys.length < // accountKeysFromLookups cannot be undefined because we already found a pubkey for this index above
              accountKeys.accountKeysFromLookups.writable.length;
            }
            keys.push({
              pubkey: pubkey2,
              isSigner: keyIndex < header.numRequiredSignatures,
              isWritable
            });
          }
          const programId = accountKeys.get(compiledIx.programIdIndex);
          if (programId === void 0) {
            throw new Error(`Failed to find program id for program id index ${compiledIx.programIdIndex}`);
          }
          instructions.push(new TransactionInstruction({
            programId,
            data: toBuffer(compiledIx.data),
            keys
          }));
        }
        return new _TransactionMessage({
          payerKey,
          instructions,
          recentBlockhash
        });
      }
      compileToLegacyMessage() {
        return Message.compile({
          payerKey: this.payerKey,
          recentBlockhash: this.recentBlockhash,
          instructions: this.instructions
        });
      }
      compileToV0Message(addressLookupTableAccounts) {
        return MessageV0.compile({
          payerKey: this.payerKey,
          recentBlockhash: this.recentBlockhash,
          instructions: this.instructions,
          addressLookupTableAccounts
        });
      }
    };
    VersionedTransaction = class _VersionedTransaction {
      get version() {
        return this.message.version;
      }
      constructor(message, signatures) {
        this.signatures = void 0;
        this.message = void 0;
        if (signatures !== void 0) {
          assert2(signatures.length === message.header.numRequiredSignatures, "Expected signatures length to be equal to the number of required signatures");
          this.signatures = signatures;
        } else {
          const defaultSignatures = [];
          for (let i = 0; i < message.header.numRequiredSignatures; i++) {
            defaultSignatures.push(new Uint8Array(SIGNATURE_LENGTH_IN_BYTES));
          }
          this.signatures = defaultSignatures;
        }
        this.message = message;
      }
      serialize() {
        const serializedMessage = this.message.serialize();
        const encodedSignaturesLength = Array();
        encodeLength(encodedSignaturesLength, this.signatures.length);
        const transactionLayout = BufferLayout.struct([BufferLayout.blob(encodedSignaturesLength.length, "encodedSignaturesLength"), BufferLayout.seq(signature(), this.signatures.length, "signatures"), BufferLayout.blob(serializedMessage.length, "serializedMessage")]);
        const serializedTransaction = new Uint8Array(2048);
        const serializedTransactionLength = transactionLayout.encode({
          encodedSignaturesLength: new Uint8Array(encodedSignaturesLength),
          signatures: this.signatures,
          serializedMessage
        }, serializedTransaction);
        return serializedTransaction.slice(0, serializedTransactionLength);
      }
      static deserialize(serializedTransaction) {
        let byteArray = [...serializedTransaction];
        const signatures = [];
        const signaturesLength = decodeLength(byteArray);
        for (let i = 0; i < signaturesLength; i++) {
          signatures.push(new Uint8Array(guardedSplice(byteArray, 0, SIGNATURE_LENGTH_IN_BYTES)));
        }
        const message = VersionedMessage.deserialize(new Uint8Array(byteArray));
        return new _VersionedTransaction(message, signatures);
      }
      sign(signers) {
        const messageData = this.message.serialize();
        const signerPubkeys = this.message.staticAccountKeys.slice(0, this.message.header.numRequiredSignatures);
        for (const signer of signers) {
          const signerIndex = signerPubkeys.findIndex((pubkey2) => pubkey2.equals(signer.publicKey));
          assert2(signerIndex >= 0, `Cannot sign with non signer key ${signer.publicKey.toBase58()}`);
          this.signatures[signerIndex] = sign(messageData, signer.secretKey);
        }
      }
      addSignature(publicKey5, signature2) {
        assert2(signature2.byteLength === 64, "Signature must be 64 bytes long");
        const signerPubkeys = this.message.staticAccountKeys.slice(0, this.message.header.numRequiredSignatures);
        const signerIndex = signerPubkeys.findIndex((pubkey2) => pubkey2.equals(publicKey5));
        assert2(signerIndex >= 0, `Can not add signature; \`${publicKey5.toBase58()}\` is not required to sign this transaction`);
        this.signatures[signerIndex] = signature2;
      }
    };
    NUM_TICKS_PER_SECOND = 160;
    DEFAULT_TICKS_PER_SLOT = 64;
    NUM_SLOTS_PER_SECOND = NUM_TICKS_PER_SECOND / DEFAULT_TICKS_PER_SLOT;
    MS_PER_SLOT = 1e3 / NUM_SLOTS_PER_SECOND;
    SYSVAR_CLOCK_PUBKEY = new PublicKey("SysvarC1ock11111111111111111111111111111111");
    SYSVAR_EPOCH_SCHEDULE_PUBKEY = new PublicKey("SysvarEpochSchedu1e111111111111111111111111");
    SYSVAR_INSTRUCTIONS_PUBKEY = new PublicKey("Sysvar1nstructions1111111111111111111111111");
    SYSVAR_RECENT_BLOCKHASHES_PUBKEY = new PublicKey("SysvarRecentB1ockHashes11111111111111111111");
    SYSVAR_RENT_PUBKEY = new PublicKey("SysvarRent111111111111111111111111111111111");
    SYSVAR_REWARDS_PUBKEY = new PublicKey("SysvarRewards111111111111111111111111111111");
    SYSVAR_SLOT_HASHES_PUBKEY = new PublicKey("SysvarS1otHashes111111111111111111111111111");
    SYSVAR_SLOT_HISTORY_PUBKEY = new PublicKey("SysvarS1otHistory11111111111111111111111111");
    SYSVAR_STAKE_HISTORY_PUBKEY = new PublicKey("SysvarStakeHistory1111111111111111111111111");
    SendTransactionError = class extends Error {
      constructor({
        action,
        signature: signature2,
        transactionMessage,
        logs
      }) {
        const maybeLogsOutput = logs ? `Logs: 
${JSON.stringify(logs.slice(-10), null, 2)}. ` : "";
        const guideText = "\nCatch the `SendTransactionError` and call `getLogs()` on it for full details.";
        let message;
        switch (action) {
          case "send":
            message = `Transaction ${signature2} resulted in an error. 
${transactionMessage}. ` + maybeLogsOutput + guideText;
            break;
          case "simulate":
            message = `Simulation failed. 
Message: ${transactionMessage}. 
` + maybeLogsOutput + guideText;
            break;
          default: {
            message = `Unknown action '${/* @__PURE__ */ ((a) => a)(action)}'`;
          }
        }
        super(message);
        this.signature = void 0;
        this.transactionMessage = void 0;
        this.transactionLogs = void 0;
        this.signature = signature2;
        this.transactionMessage = transactionMessage;
        this.transactionLogs = logs ? logs : void 0;
      }
      get transactionError() {
        return {
          message: this.transactionMessage,
          logs: Array.isArray(this.transactionLogs) ? this.transactionLogs : void 0
        };
      }
      /* @deprecated Use `await getLogs()` instead */
      get logs() {
        const cachedLogs = this.transactionLogs;
        if (cachedLogs != null && typeof cachedLogs === "object" && "then" in cachedLogs) {
          return void 0;
        }
        return cachedLogs;
      }
      async getLogs(connection) {
        if (!Array.isArray(this.transactionLogs)) {
          this.transactionLogs = new Promise((resolve2, reject2) => {
            connection.getTransaction(this.signature).then((tx) => {
              if (tx && tx.meta && tx.meta.logMessages) {
                const logs = tx.meta.logMessages;
                this.transactionLogs = logs;
                resolve2(logs);
              } else {
                reject2(new Error("Log messages not found"));
              }
            }).catch(reject2);
          });
        }
        return await this.transactionLogs;
      }
    };
    SolanaJSONRPCErrorCode = {
      JSON_RPC_SERVER_ERROR_BLOCK_CLEANED_UP: -32001,
      JSON_RPC_SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE: -32002,
      JSON_RPC_SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE: -32003,
      JSON_RPC_SERVER_ERROR_BLOCK_NOT_AVAILABLE: -32004,
      JSON_RPC_SERVER_ERROR_NODE_UNHEALTHY: -32005,
      JSON_RPC_SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE: -32006,
      JSON_RPC_SERVER_ERROR_SLOT_SKIPPED: -32007,
      JSON_RPC_SERVER_ERROR_NO_SNAPSHOT: -32008,
      JSON_RPC_SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED: -32009,
      JSON_RPC_SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX: -32010,
      JSON_RPC_SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE: -32011,
      JSON_RPC_SCAN_ERROR: -32012,
      JSON_RPC_SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH: -32013,
      JSON_RPC_SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET: -32014,
      JSON_RPC_SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION: -32015,
      JSON_RPC_SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED: -32016
    };
    SolanaJSONRPCError = class extends Error {
      constructor({
        code: code2,
        message,
        data
      }, customMessage) {
        super(customMessage != null ? `${customMessage}: ${message}` : message);
        this.code = void 0;
        this.data = void 0;
        this.code = code2;
        this.data = data;
        this.name = "SolanaJSONRPCError";
      }
    };
    FeeCalculatorLayout = BufferLayout.nu64("lamportsPerSignature");
    NonceAccountLayout = BufferLayout.struct([BufferLayout.u32("version"), BufferLayout.u32("state"), publicKey("authorizedPubkey"), publicKey("nonce"), BufferLayout.struct([FeeCalculatorLayout], "feeCalculator")]);
    NONCE_ACCOUNT_LENGTH = NonceAccountLayout.span;
    NonceAccount = class _NonceAccount {
      /**
       * @internal
       */
      constructor(args) {
        this.authorizedPubkey = void 0;
        this.nonce = void 0;
        this.feeCalculator = void 0;
        this.authorizedPubkey = args.authorizedPubkey;
        this.nonce = args.nonce;
        this.feeCalculator = args.feeCalculator;
      }
      /**
       * Deserialize NonceAccount from the account data.
       *
       * @param buffer account data
       * @return NonceAccount
       */
      static fromAccountData(buffer3) {
        const nonceAccount = NonceAccountLayout.decode(toBuffer(buffer3), 0);
        return new _NonceAccount({
          authorizedPubkey: new PublicKey(nonceAccount.authorizedPubkey),
          nonce: new PublicKey(nonceAccount.nonce).toString(),
          feeCalculator: nonceAccount.feeCalculator
        });
      }
    };
    SystemInstruction = class {
      /**
       * @internal
       */
      constructor() {
      }
      /**
       * Decode a system instruction and retrieve the instruction type.
       */
      static decodeInstructionType(instruction) {
        this.checkProgramId(instruction.programId);
        const instructionTypeLayout = BufferLayout.u32("instruction");
        const typeIndex = instructionTypeLayout.decode(instruction.data);
        let type3;
        for (const [ixType, layout] of Object.entries(SYSTEM_INSTRUCTION_LAYOUTS)) {
          if (layout.index == typeIndex) {
            type3 = ixType;
            break;
          }
        }
        if (!type3) {
          throw new Error("Instruction type incorrect; not a SystemInstruction");
        }
        return type3;
      }
      /**
       * Decode a create account system instruction and retrieve the instruction params.
       */
      static decodeCreateAccount(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeyLength(instruction.keys, 2);
        const {
          lamports,
          space,
          programId
        } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.Create, instruction.data);
        return {
          fromPubkey: instruction.keys[0].pubkey,
          newAccountPubkey: instruction.keys[1].pubkey,
          lamports,
          space,
          programId: new PublicKey(programId)
        };
      }
      /**
       * Decode a transfer system instruction and retrieve the instruction params.
       */
      static decodeTransfer(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeyLength(instruction.keys, 2);
        const {
          lamports
        } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.Transfer, instruction.data);
        return {
          fromPubkey: instruction.keys[0].pubkey,
          toPubkey: instruction.keys[1].pubkey,
          lamports
        };
      }
      /**
       * Decode a transfer with seed system instruction and retrieve the instruction params.
       */
      static decodeTransferWithSeed(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeyLength(instruction.keys, 3);
        const {
          lamports,
          seed: seed2,
          programId
        } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.TransferWithSeed, instruction.data);
        return {
          fromPubkey: instruction.keys[0].pubkey,
          basePubkey: instruction.keys[1].pubkey,
          toPubkey: instruction.keys[2].pubkey,
          lamports,
          seed: seed2,
          programId: new PublicKey(programId)
        };
      }
      /**
       * Decode an allocate system instruction and retrieve the instruction params.
       */
      static decodeAllocate(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeyLength(instruction.keys, 1);
        const {
          space
        } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.Allocate, instruction.data);
        return {
          accountPubkey: instruction.keys[0].pubkey,
          space
        };
      }
      /**
       * Decode an allocate with seed system instruction and retrieve the instruction params.
       */
      static decodeAllocateWithSeed(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeyLength(instruction.keys, 1);
        const {
          base: base3,
          seed: seed2,
          space,
          programId
        } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.AllocateWithSeed, instruction.data);
        return {
          accountPubkey: instruction.keys[0].pubkey,
          basePubkey: new PublicKey(base3),
          seed: seed2,
          space,
          programId: new PublicKey(programId)
        };
      }
      /**
       * Decode an assign system instruction and retrieve the instruction params.
       */
      static decodeAssign(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeyLength(instruction.keys, 1);
        const {
          programId
        } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.Assign, instruction.data);
        return {
          accountPubkey: instruction.keys[0].pubkey,
          programId: new PublicKey(programId)
        };
      }
      /**
       * Decode an assign with seed system instruction and retrieve the instruction params.
       */
      static decodeAssignWithSeed(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeyLength(instruction.keys, 1);
        const {
          base: base3,
          seed: seed2,
          programId
        } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.AssignWithSeed, instruction.data);
        return {
          accountPubkey: instruction.keys[0].pubkey,
          basePubkey: new PublicKey(base3),
          seed: seed2,
          programId: new PublicKey(programId)
        };
      }
      /**
       * Decode a create account with seed system instruction and retrieve the instruction params.
       */
      static decodeCreateWithSeed(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeyLength(instruction.keys, 2);
        const {
          base: base3,
          seed: seed2,
          lamports,
          space,
          programId
        } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.CreateWithSeed, instruction.data);
        return {
          fromPubkey: instruction.keys[0].pubkey,
          newAccountPubkey: instruction.keys[1].pubkey,
          basePubkey: new PublicKey(base3),
          seed: seed2,
          lamports,
          space,
          programId: new PublicKey(programId)
        };
      }
      /**
       * Decode a nonce initialize system instruction and retrieve the instruction params.
       */
      static decodeNonceInitialize(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeyLength(instruction.keys, 3);
        const {
          authorized: authorized2
        } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.InitializeNonceAccount, instruction.data);
        return {
          noncePubkey: instruction.keys[0].pubkey,
          authorizedPubkey: new PublicKey(authorized2)
        };
      }
      /**
       * Decode a nonce advance system instruction and retrieve the instruction params.
       */
      static decodeNonceAdvance(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeyLength(instruction.keys, 3);
        decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.AdvanceNonceAccount, instruction.data);
        return {
          noncePubkey: instruction.keys[0].pubkey,
          authorizedPubkey: instruction.keys[2].pubkey
        };
      }
      /**
       * Decode a nonce withdraw system instruction and retrieve the instruction params.
       */
      static decodeNonceWithdraw(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeyLength(instruction.keys, 5);
        const {
          lamports
        } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.WithdrawNonceAccount, instruction.data);
        return {
          noncePubkey: instruction.keys[0].pubkey,
          toPubkey: instruction.keys[1].pubkey,
          authorizedPubkey: instruction.keys[4].pubkey,
          lamports
        };
      }
      /**
       * Decode a nonce authorize system instruction and retrieve the instruction params.
       */
      static decodeNonceAuthorize(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeyLength(instruction.keys, 2);
        const {
          authorized: authorized2
        } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.AuthorizeNonceAccount, instruction.data);
        return {
          noncePubkey: instruction.keys[0].pubkey,
          authorizedPubkey: instruction.keys[1].pubkey,
          newAuthorizedPubkey: new PublicKey(authorized2)
        };
      }
      /**
       * @internal
       */
      static checkProgramId(programId) {
        if (!programId.equals(SystemProgram.programId)) {
          throw new Error("invalid instruction; programId is not SystemProgram");
        }
      }
      /**
       * @internal
       */
      static checkKeyLength(keys, expectedLength) {
        if (keys.length < expectedLength) {
          throw new Error(`invalid instruction; found ${keys.length} keys, expected at least ${expectedLength}`);
        }
      }
    };
    SYSTEM_INSTRUCTION_LAYOUTS = Object.freeze({
      Create: {
        index: 0,
        layout: BufferLayout.struct([BufferLayout.u32("instruction"), BufferLayout.ns64("lamports"), BufferLayout.ns64("space"), publicKey("programId")])
      },
      Assign: {
        index: 1,
        layout: BufferLayout.struct([BufferLayout.u32("instruction"), publicKey("programId")])
      },
      Transfer: {
        index: 2,
        layout: BufferLayout.struct([BufferLayout.u32("instruction"), u64("lamports")])
      },
      CreateWithSeed: {
        index: 3,
        layout: BufferLayout.struct([BufferLayout.u32("instruction"), publicKey("base"), rustString("seed"), BufferLayout.ns64("lamports"), BufferLayout.ns64("space"), publicKey("programId")])
      },
      AdvanceNonceAccount: {
        index: 4,
        layout: BufferLayout.struct([BufferLayout.u32("instruction")])
      },
      WithdrawNonceAccount: {
        index: 5,
        layout: BufferLayout.struct([BufferLayout.u32("instruction"), BufferLayout.ns64("lamports")])
      },
      InitializeNonceAccount: {
        index: 6,
        layout: BufferLayout.struct([BufferLayout.u32("instruction"), publicKey("authorized")])
      },
      AuthorizeNonceAccount: {
        index: 7,
        layout: BufferLayout.struct([BufferLayout.u32("instruction"), publicKey("authorized")])
      },
      Allocate: {
        index: 8,
        layout: BufferLayout.struct([BufferLayout.u32("instruction"), BufferLayout.ns64("space")])
      },
      AllocateWithSeed: {
        index: 9,
        layout: BufferLayout.struct([BufferLayout.u32("instruction"), publicKey("base"), rustString("seed"), BufferLayout.ns64("space"), publicKey("programId")])
      },
      AssignWithSeed: {
        index: 10,
        layout: BufferLayout.struct([BufferLayout.u32("instruction"), publicKey("base"), rustString("seed"), publicKey("programId")])
      },
      TransferWithSeed: {
        index: 11,
        layout: BufferLayout.struct([BufferLayout.u32("instruction"), u64("lamports"), rustString("seed"), publicKey("programId")])
      },
      UpgradeNonceAccount: {
        index: 12,
        layout: BufferLayout.struct([BufferLayout.u32("instruction")])
      }
    });
    SystemProgram = class _SystemProgram {
      /**
       * @internal
       */
      constructor() {
      }
      /**
       * Public key that identifies the System program
       */
      /**
       * Generate a transaction instruction that creates a new account
       */
      static createAccount(params) {
        const type3 = SYSTEM_INSTRUCTION_LAYOUTS.Create;
        const data = encodeData2(type3, {
          lamports: params.lamports,
          space: params.space,
          programId: toBuffer(params.programId.toBuffer())
        });
        return new TransactionInstruction({
          keys: [{
            pubkey: params.fromPubkey,
            isSigner: true,
            isWritable: true
          }, {
            pubkey: params.newAccountPubkey,
            isSigner: true,
            isWritable: true
          }],
          programId: this.programId,
          data
        });
      }
      /**
       * Generate a transaction instruction that transfers lamports from one account to another
       */
      static transfer(params) {
        let data;
        let keys;
        if ("basePubkey" in params) {
          const type3 = SYSTEM_INSTRUCTION_LAYOUTS.TransferWithSeed;
          data = encodeData2(type3, {
            lamports: BigInt(params.lamports),
            seed: params.seed,
            programId: toBuffer(params.programId.toBuffer())
          });
          keys = [{
            pubkey: params.fromPubkey,
            isSigner: false,
            isWritable: true
          }, {
            pubkey: params.basePubkey,
            isSigner: true,
            isWritable: false
          }, {
            pubkey: params.toPubkey,
            isSigner: false,
            isWritable: true
          }];
        } else {
          const type3 = SYSTEM_INSTRUCTION_LAYOUTS.Transfer;
          data = encodeData2(type3, {
            lamports: BigInt(params.lamports)
          });
          keys = [{
            pubkey: params.fromPubkey,
            isSigner: true,
            isWritable: true
          }, {
            pubkey: params.toPubkey,
            isSigner: false,
            isWritable: true
          }];
        }
        return new TransactionInstruction({
          keys,
          programId: this.programId,
          data
        });
      }
      /**
       * Generate a transaction instruction that assigns an account to a program
       */
      static assign(params) {
        let data;
        let keys;
        if ("basePubkey" in params) {
          const type3 = SYSTEM_INSTRUCTION_LAYOUTS.AssignWithSeed;
          data = encodeData2(type3, {
            base: toBuffer(params.basePubkey.toBuffer()),
            seed: params.seed,
            programId: toBuffer(params.programId.toBuffer())
          });
          keys = [{
            pubkey: params.accountPubkey,
            isSigner: false,
            isWritable: true
          }, {
            pubkey: params.basePubkey,
            isSigner: true,
            isWritable: false
          }];
        } else {
          const type3 = SYSTEM_INSTRUCTION_LAYOUTS.Assign;
          data = encodeData2(type3, {
            programId: toBuffer(params.programId.toBuffer())
          });
          keys = [{
            pubkey: params.accountPubkey,
            isSigner: true,
            isWritable: true
          }];
        }
        return new TransactionInstruction({
          keys,
          programId: this.programId,
          data
        });
      }
      /**
       * Generate a transaction instruction that creates a new account at
       *   an address generated with `from`, a seed, and programId
       */
      static createAccountWithSeed(params) {
        const type3 = SYSTEM_INSTRUCTION_LAYOUTS.CreateWithSeed;
        const data = encodeData2(type3, {
          base: toBuffer(params.basePubkey.toBuffer()),
          seed: params.seed,
          lamports: params.lamports,
          space: params.space,
          programId: toBuffer(params.programId.toBuffer())
        });
        let keys = [{
          pubkey: params.fromPubkey,
          isSigner: true,
          isWritable: true
        }, {
          pubkey: params.newAccountPubkey,
          isSigner: false,
          isWritable: true
        }];
        if (!params.basePubkey.equals(params.fromPubkey)) {
          keys.push({
            pubkey: params.basePubkey,
            isSigner: true,
            isWritable: false
          });
        }
        return new TransactionInstruction({
          keys,
          programId: this.programId,
          data
        });
      }
      /**
       * Generate a transaction that creates a new Nonce account
       */
      static createNonceAccount(params) {
        const transaction = new Transaction();
        if ("basePubkey" in params && "seed" in params) {
          transaction.add(_SystemProgram.createAccountWithSeed({
            fromPubkey: params.fromPubkey,
            newAccountPubkey: params.noncePubkey,
            basePubkey: params.basePubkey,
            seed: params.seed,
            lamports: params.lamports,
            space: NONCE_ACCOUNT_LENGTH,
            programId: this.programId
          }));
        } else {
          transaction.add(_SystemProgram.createAccount({
            fromPubkey: params.fromPubkey,
            newAccountPubkey: params.noncePubkey,
            lamports: params.lamports,
            space: NONCE_ACCOUNT_LENGTH,
            programId: this.programId
          }));
        }
        const initParams = {
          noncePubkey: params.noncePubkey,
          authorizedPubkey: params.authorizedPubkey
        };
        transaction.add(this.nonceInitialize(initParams));
        return transaction;
      }
      /**
       * Generate an instruction to initialize a Nonce account
       */
      static nonceInitialize(params) {
        const type3 = SYSTEM_INSTRUCTION_LAYOUTS.InitializeNonceAccount;
        const data = encodeData2(type3, {
          authorized: toBuffer(params.authorizedPubkey.toBuffer())
        });
        const instructionData = {
          keys: [{
            pubkey: params.noncePubkey,
            isSigner: false,
            isWritable: true
          }, {
            pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,
            isSigner: false,
            isWritable: false
          }, {
            pubkey: SYSVAR_RENT_PUBKEY,
            isSigner: false,
            isWritable: false
          }],
          programId: this.programId,
          data
        };
        return new TransactionInstruction(instructionData);
      }
      /**
       * Generate an instruction to advance the nonce in a Nonce account
       */
      static nonceAdvance(params) {
        const type3 = SYSTEM_INSTRUCTION_LAYOUTS.AdvanceNonceAccount;
        const data = encodeData2(type3);
        const instructionData = {
          keys: [{
            pubkey: params.noncePubkey,
            isSigner: false,
            isWritable: true
          }, {
            pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,
            isSigner: false,
            isWritable: false
          }, {
            pubkey: params.authorizedPubkey,
            isSigner: true,
            isWritable: false
          }],
          programId: this.programId,
          data
        };
        return new TransactionInstruction(instructionData);
      }
      /**
       * Generate a transaction instruction that withdraws lamports from a Nonce account
       */
      static nonceWithdraw(params) {
        const type3 = SYSTEM_INSTRUCTION_LAYOUTS.WithdrawNonceAccount;
        const data = encodeData2(type3, {
          lamports: params.lamports
        });
        return new TransactionInstruction({
          keys: [{
            pubkey: params.noncePubkey,
            isSigner: false,
            isWritable: true
          }, {
            pubkey: params.toPubkey,
            isSigner: false,
            isWritable: true
          }, {
            pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,
            isSigner: false,
            isWritable: false
          }, {
            pubkey: SYSVAR_RENT_PUBKEY,
            isSigner: false,
            isWritable: false
          }, {
            pubkey: params.authorizedPubkey,
            isSigner: true,
            isWritable: false
          }],
          programId: this.programId,
          data
        });
      }
      /**
       * Generate a transaction instruction that authorizes a new PublicKey as the authority
       * on a Nonce account.
       */
      static nonceAuthorize(params) {
        const type3 = SYSTEM_INSTRUCTION_LAYOUTS.AuthorizeNonceAccount;
        const data = encodeData2(type3, {
          authorized: toBuffer(params.newAuthorizedPubkey.toBuffer())
        });
        return new TransactionInstruction({
          keys: [{
            pubkey: params.noncePubkey,
            isSigner: false,
            isWritable: true
          }, {
            pubkey: params.authorizedPubkey,
            isSigner: true,
            isWritable: false
          }],
          programId: this.programId,
          data
        });
      }
      /**
       * Generate a transaction instruction that allocates space in an account without funding
       */
      static allocate(params) {
        let data;
        let keys;
        if ("basePubkey" in params) {
          const type3 = SYSTEM_INSTRUCTION_LAYOUTS.AllocateWithSeed;
          data = encodeData2(type3, {
            base: toBuffer(params.basePubkey.toBuffer()),
            seed: params.seed,
            space: params.space,
            programId: toBuffer(params.programId.toBuffer())
          });
          keys = [{
            pubkey: params.accountPubkey,
            isSigner: false,
            isWritable: true
          }, {
            pubkey: params.basePubkey,
            isSigner: true,
            isWritable: false
          }];
        } else {
          const type3 = SYSTEM_INSTRUCTION_LAYOUTS.Allocate;
          data = encodeData2(type3, {
            space: params.space
          });
          keys = [{
            pubkey: params.accountPubkey,
            isSigner: true,
            isWritable: true
          }];
        }
        return new TransactionInstruction({
          keys,
          programId: this.programId,
          data
        });
      }
    };
    SystemProgram.programId = new PublicKey("11111111111111111111111111111111");
    CHUNK_SIZE = PACKET_DATA_SIZE - 300;
    Loader = class _Loader {
      /**
       * @internal
       */
      constructor() {
      }
      /**
       * Amount of program data placed in each load Transaction
       */
      /**
       * Minimum number of signatures required to load a program not including
       * retries
       *
       * Can be used to calculate transaction fees
       */
      static getMinNumSignatures(dataLength) {
        return 2 * // Every transaction requires two signatures (payer + program)
        (Math.ceil(dataLength / _Loader.chunkSize) + 1 + // Add one for Create transaction
        1);
      }
      /**
       * Loads a generic program
       *
       * @param connection The connection to use
       * @param payer System account that pays to load the program
       * @param program Account to load the program into
       * @param programId Public key that identifies the loader
       * @param data Program octets
       * @return true if program was loaded successfully, false if program was already loaded
       */
      static async load(connection, payer, program, programId, data) {
        {
          const balanceNeeded = await connection.getMinimumBalanceForRentExemption(data.length);
          const programInfo = await connection.getAccountInfo(program.publicKey, "confirmed");
          let transaction = null;
          if (programInfo !== null) {
            if (programInfo.executable) {
              console.error("Program load failed, account is already executable");
              return false;
            }
            if (programInfo.data.length !== data.length) {
              transaction = transaction || new Transaction();
              transaction.add(SystemProgram.allocate({
                accountPubkey: program.publicKey,
                space: data.length
              }));
            }
            if (!programInfo.owner.equals(programId)) {
              transaction = transaction || new Transaction();
              transaction.add(SystemProgram.assign({
                accountPubkey: program.publicKey,
                programId
              }));
            }
            if (programInfo.lamports < balanceNeeded) {
              transaction = transaction || new Transaction();
              transaction.add(SystemProgram.transfer({
                fromPubkey: payer.publicKey,
                toPubkey: program.publicKey,
                lamports: balanceNeeded - programInfo.lamports
              }));
            }
          } else {
            transaction = new Transaction().add(SystemProgram.createAccount({
              fromPubkey: payer.publicKey,
              newAccountPubkey: program.publicKey,
              lamports: balanceNeeded > 0 ? balanceNeeded : 1,
              space: data.length,
              programId
            }));
          }
          if (transaction !== null) {
            await sendAndConfirmTransaction(connection, transaction, [payer, program], {
              commitment: "confirmed"
            });
          }
        }
        const dataLayout = BufferLayout.struct([BufferLayout.u32("instruction"), BufferLayout.u32("offset"), BufferLayout.u32("bytesLength"), BufferLayout.u32("bytesLengthPadding"), BufferLayout.seq(BufferLayout.u8("byte"), BufferLayout.offset(BufferLayout.u32(), -8), "bytes")]);
        const chunkSize = _Loader.chunkSize;
        let offset3 = 0;
        let array4 = data;
        let transactions = [];
        while (array4.length > 0) {
          const bytes3 = array4.slice(0, chunkSize);
          const data2 = import_buffer2.Buffer.alloc(chunkSize + 16);
          dataLayout.encode({
            instruction: 0,
            // Load instruction
            offset: offset3,
            bytes: bytes3,
            bytesLength: 0,
            bytesLengthPadding: 0
          }, data2);
          const transaction = new Transaction().add({
            keys: [{
              pubkey: program.publicKey,
              isSigner: true,
              isWritable: true
            }],
            programId,
            data: data2
          });
          transactions.push(sendAndConfirmTransaction(connection, transaction, [payer, program], {
            commitment: "confirmed"
          }));
          if (connection._rpcEndpoint.includes("solana.com")) {
            const REQUESTS_PER_SECOND = 4;
            await sleep(1e3 / REQUESTS_PER_SECOND);
          }
          offset3 += chunkSize;
          array4 = array4.slice(chunkSize);
        }
        await Promise.all(transactions);
        {
          const dataLayout2 = BufferLayout.struct([BufferLayout.u32("instruction")]);
          const data2 = import_buffer2.Buffer.alloc(dataLayout2.span);
          dataLayout2.encode({
            instruction: 1
            // Finalize instruction
          }, data2);
          const transaction = new Transaction().add({
            keys: [{
              pubkey: program.publicKey,
              isSigner: true,
              isWritable: true
            }, {
              pubkey: SYSVAR_RENT_PUBKEY,
              isSigner: false,
              isWritable: false
            }],
            programId,
            data: data2
          });
          const deployCommitment = "processed";
          const finalizeSignature = await connection.sendTransaction(transaction, [payer, program], {
            preflightCommitment: deployCommitment
          });
          const {
            context,
            value
          } = await connection.confirmTransaction({
            signature: finalizeSignature,
            lastValidBlockHeight: transaction.lastValidBlockHeight,
            blockhash: transaction.recentBlockhash
          }, deployCommitment);
          if (value.err) {
            throw new Error(`Transaction ${finalizeSignature} failed (${JSON.stringify(value)})`);
          }
          while (true) {
            try {
              const currentSlot = await connection.getSlot({
                commitment: deployCommitment
              });
              if (currentSlot > context.slot) {
                break;
              }
            } catch {
            }
            await new Promise((resolve2) => setTimeout(resolve2, Math.round(MS_PER_SLOT / 2)));
          }
        }
        return true;
      }
    };
    Loader.chunkSize = CHUNK_SIZE;
    BPF_LOADER_PROGRAM_ID = new PublicKey("BPFLoader2111111111111111111111111111111111");
    BpfLoader = class {
      /**
       * Minimum number of signatures required to load a program not including
       * retries
       *
       * Can be used to calculate transaction fees
       */
      static getMinNumSignatures(dataLength) {
        return Loader.getMinNumSignatures(dataLength);
      }
      /**
       * Load a SBF program
       *
       * @param connection The connection to use
       * @param payer Account that will pay program loading fees
       * @param program Account to load the program into
       * @param elf The entire ELF containing the SBF program
       * @param loaderProgramId The program id of the BPF loader to use
       * @return true if program was loaded successfully, false if program was already loaded
       */
      static load(connection, payer, program, elf, loaderProgramId) {
        return Loader.load(connection, payer, program, loaderProgramId, elf);
      }
    };
    fastStableStringifyExports = requireFastStableStringify();
    fastStableStringify = getDefaultExportFromCjs(fastStableStringifyExports);
    MINIMUM_SLOT_PER_EPOCH = 32;
    EpochSchedule = class {
      constructor(slotsPerEpoch, leaderScheduleSlotOffset, warmup, firstNormalEpoch, firstNormalSlot) {
        this.slotsPerEpoch = void 0;
        this.leaderScheduleSlotOffset = void 0;
        this.warmup = void 0;
        this.firstNormalEpoch = void 0;
        this.firstNormalSlot = void 0;
        this.slotsPerEpoch = slotsPerEpoch;
        this.leaderScheduleSlotOffset = leaderScheduleSlotOffset;
        this.warmup = warmup;
        this.firstNormalEpoch = firstNormalEpoch;
        this.firstNormalSlot = firstNormalSlot;
      }
      getEpoch(slot) {
        return this.getEpochAndSlotIndex(slot)[0];
      }
      getEpochAndSlotIndex(slot) {
        if (slot < this.firstNormalSlot) {
          const epoch = trailingZeros(nextPowerOfTwo(slot + MINIMUM_SLOT_PER_EPOCH + 1)) - trailingZeros(MINIMUM_SLOT_PER_EPOCH) - 1;
          const epochLen = this.getSlotsInEpoch(epoch);
          const slotIndex = slot - (epochLen - MINIMUM_SLOT_PER_EPOCH);
          return [epoch, slotIndex];
        } else {
          const normalSlotIndex = slot - this.firstNormalSlot;
          const normalEpochIndex = Math.floor(normalSlotIndex / this.slotsPerEpoch);
          const epoch = this.firstNormalEpoch + normalEpochIndex;
          const slotIndex = normalSlotIndex % this.slotsPerEpoch;
          return [epoch, slotIndex];
        }
      }
      getFirstSlotInEpoch(epoch) {
        if (epoch <= this.firstNormalEpoch) {
          return (Math.pow(2, epoch) - 1) * MINIMUM_SLOT_PER_EPOCH;
        } else {
          return (epoch - this.firstNormalEpoch) * this.slotsPerEpoch + this.firstNormalSlot;
        }
      }
      getLastSlotInEpoch(epoch) {
        return this.getFirstSlotInEpoch(epoch) + this.getSlotsInEpoch(epoch) - 1;
      }
      getSlotsInEpoch(epoch) {
        if (epoch < this.firstNormalEpoch) {
          return Math.pow(2, epoch + trailingZeros(MINIMUM_SLOT_PER_EPOCH));
        } else {
          return this.slotsPerEpoch;
        }
      }
    };
    fetchImpl = globalThis.fetch;
    RpcWebSocketClient = class extends CommonClient {
      constructor(address, options, generate_request_id) {
        const webSocketFactory = (url) => {
          const rpc3 = WebSocket(url, {
            autoconnect: true,
            max_reconnects: 5,
            reconnect: true,
            reconnect_interval: 1e3,
            ...options
          });
          if ("socket" in rpc3) {
            this.underlyingSocket = rpc3.socket;
          } else {
            this.underlyingSocket = rpc3;
          }
          return rpc3;
        };
        super(webSocketFactory, address, options, generate_request_id);
        this.underlyingSocket = void 0;
      }
      call(...args) {
        var _a2;
        const readyState = (_a2 = this.underlyingSocket) == null ? void 0 : _a2.readyState;
        if (readyState === 1) {
          return super.call(...args);
        }
        return Promise.reject(new Error("Tried to call a JSON-RPC method `" + args[0] + "` but the socket was not `CONNECTING` or `OPEN` (`readyState` was " + readyState + ")"));
      }
      notify(...args) {
        var _a2;
        const readyState = (_a2 = this.underlyingSocket) == null ? void 0 : _a2.readyState;
        if (readyState === 1) {
          return super.notify(...args);
        }
        return Promise.reject(new Error("Tried to send a JSON-RPC notification `" + args[0] + "` but the socket was not `CONNECTING` or `OPEN` (`readyState` was " + readyState + ")"));
      }
    };
    LOOKUP_TABLE_META_SIZE = 56;
    AddressLookupTableAccount = class {
      constructor(args) {
        this.key = void 0;
        this.state = void 0;
        this.key = args.key;
        this.state = args.state;
      }
      isActive() {
        const U64_MAX = BigInt("0xffffffffffffffff");
        return this.state.deactivationSlot === U64_MAX;
      }
      static deserialize(accountData) {
        const meta = decodeData(LookupTableMetaLayout, accountData);
        const serializedAddressesLen = accountData.length - LOOKUP_TABLE_META_SIZE;
        assert2(serializedAddressesLen >= 0, "lookup table is invalid");
        assert2(serializedAddressesLen % 32 === 0, "lookup table is invalid");
        const numSerializedAddresses = serializedAddressesLen / 32;
        const {
          addresses
        } = BufferLayout.struct([BufferLayout.seq(publicKey(), numSerializedAddresses, "addresses")]).decode(accountData.slice(LOOKUP_TABLE_META_SIZE));
        return {
          deactivationSlot: meta.deactivationSlot,
          lastExtendedSlot: meta.lastExtendedSlot,
          lastExtendedSlotStartIndex: meta.lastExtendedStartIndex,
          authority: meta.authority.length !== 0 ? new PublicKey(meta.authority[0]) : void 0,
          addresses: addresses.map((address) => new PublicKey(address))
        };
      }
    };
    LookupTableMetaLayout = {
      index: 1,
      layout: BufferLayout.struct([
        BufferLayout.u32("typeIndex"),
        u64("deactivationSlot"),
        BufferLayout.nu64("lastExtendedSlot"),
        BufferLayout.u8("lastExtendedStartIndex"),
        BufferLayout.u8(),
        // option
        BufferLayout.seq(publicKey(), BufferLayout.offset(BufferLayout.u8(), -1), "authority")
      ])
    };
    URL_RE = /^[^:]+:\/\/([^:[]+|\[[^\]]+\])(:\d+)?(.*)/i;
    PublicKeyFromString = coerce(instance(PublicKey), string(), (value) => new PublicKey(value));
    RawAccountDataResult = tuple([string(), literal("base64")]);
    BufferFromRawAccountData = coerce(instance(import_buffer2.Buffer), RawAccountDataResult, (value) => import_buffer2.Buffer.from(value[0], "base64"));
    BLOCKHASH_CACHE_TIMEOUT_MS = 30 * 1e3;
    UnknownRpcResult = createRpcResult(unknown());
    GetInflationGovernorResult = type({
      foundation: number(),
      foundationTerm: number(),
      initial: number(),
      taper: number(),
      terminal: number()
    });
    GetInflationRewardResult = jsonRpcResult(array(nullable(type({
      epoch: number(),
      effectiveSlot: number(),
      amount: number(),
      postBalance: number(),
      commission: optional(nullable(number()))
    }))));
    GetRecentPrioritizationFeesResult = array(type({
      slot: number(),
      prioritizationFee: number()
    }));
    GetInflationRateResult = type({
      total: number(),
      validator: number(),
      foundation: number(),
      epoch: number()
    });
    GetEpochInfoResult = type({
      epoch: number(),
      slotIndex: number(),
      slotsInEpoch: number(),
      absoluteSlot: number(),
      blockHeight: optional(number()),
      transactionCount: optional(number())
    });
    GetEpochScheduleResult = type({
      slotsPerEpoch: number(),
      leaderScheduleSlotOffset: number(),
      warmup: boolean(),
      firstNormalEpoch: number(),
      firstNormalSlot: number()
    });
    GetLeaderScheduleResult = record(string(), array(number()));
    TransactionErrorResult = nullable(union([type({}), string()]));
    SignatureStatusResult = type({
      err: TransactionErrorResult
    });
    SignatureReceivedResult = literal("receivedSignature");
    VersionResult = type({
      "solana-core": string(),
      "feature-set": optional(number())
    });
    ParsedInstructionStruct = type({
      program: string(),
      programId: PublicKeyFromString,
      parsed: unknown()
    });
    PartiallyDecodedInstructionStruct = type({
      programId: PublicKeyFromString,
      accounts: array(PublicKeyFromString),
      data: string()
    });
    SimulatedTransactionResponseStruct = jsonRpcResultAndContext(type({
      err: nullable(union([type({}), string()])),
      logs: nullable(array(string())),
      accounts: optional(nullable(array(nullable(type({
        executable: boolean(),
        owner: string(),
        lamports: number(),
        data: array(string()),
        rentEpoch: optional(number())
      }))))),
      unitsConsumed: optional(number()),
      returnData: optional(nullable(type({
        programId: string(),
        data: tuple([string(), literal("base64")])
      }))),
      innerInstructions: optional(nullable(array(type({
        index: number(),
        instructions: array(union([ParsedInstructionStruct, PartiallyDecodedInstructionStruct]))
      }))))
    }));
    BlockProductionResponseStruct = jsonRpcResultAndContext(type({
      byIdentity: record(string(), array(number())),
      range: type({
        firstSlot: number(),
        lastSlot: number()
      })
    }));
    GetInflationGovernorRpcResult = jsonRpcResult(GetInflationGovernorResult);
    GetInflationRateRpcResult = jsonRpcResult(GetInflationRateResult);
    GetRecentPrioritizationFeesRpcResult = jsonRpcResult(GetRecentPrioritizationFeesResult);
    GetEpochInfoRpcResult = jsonRpcResult(GetEpochInfoResult);
    GetEpochScheduleRpcResult = jsonRpcResult(GetEpochScheduleResult);
    GetLeaderScheduleRpcResult = jsonRpcResult(GetLeaderScheduleResult);
    SlotRpcResult = jsonRpcResult(number());
    GetSupplyRpcResult = jsonRpcResultAndContext(type({
      total: number(),
      circulating: number(),
      nonCirculating: number(),
      nonCirculatingAccounts: array(PublicKeyFromString)
    }));
    TokenAmountResult = type({
      amount: string(),
      uiAmount: nullable(number()),
      decimals: number(),
      uiAmountString: optional(string())
    });
    GetTokenLargestAccountsResult = jsonRpcResultAndContext(array(type({
      address: PublicKeyFromString,
      amount: string(),
      uiAmount: nullable(number()),
      decimals: number(),
      uiAmountString: optional(string())
    })));
    GetTokenAccountsByOwner = jsonRpcResultAndContext(array(type({
      pubkey: PublicKeyFromString,
      account: type({
        executable: boolean(),
        owner: PublicKeyFromString,
        lamports: number(),
        data: BufferFromRawAccountData,
        rentEpoch: number()
      })
    })));
    ParsedAccountDataResult = type({
      program: string(),
      parsed: unknown(),
      space: number()
    });
    GetParsedTokenAccountsByOwner = jsonRpcResultAndContext(array(type({
      pubkey: PublicKeyFromString,
      account: type({
        executable: boolean(),
        owner: PublicKeyFromString,
        lamports: number(),
        data: ParsedAccountDataResult,
        rentEpoch: number()
      })
    })));
    GetLargestAccountsRpcResult = jsonRpcResultAndContext(array(type({
      lamports: number(),
      address: PublicKeyFromString
    })));
    AccountInfoResult = type({
      executable: boolean(),
      owner: PublicKeyFromString,
      lamports: number(),
      data: BufferFromRawAccountData,
      rentEpoch: number()
    });
    KeyedAccountInfoResult = type({
      pubkey: PublicKeyFromString,
      account: AccountInfoResult
    });
    ParsedOrRawAccountData = coerce(union([instance(import_buffer2.Buffer), ParsedAccountDataResult]), union([RawAccountDataResult, ParsedAccountDataResult]), (value) => {
      if (Array.isArray(value)) {
        return create(value, BufferFromRawAccountData);
      } else {
        return value;
      }
    });
    ParsedAccountInfoResult = type({
      executable: boolean(),
      owner: PublicKeyFromString,
      lamports: number(),
      data: ParsedOrRawAccountData,
      rentEpoch: number()
    });
    KeyedParsedAccountInfoResult = type({
      pubkey: PublicKeyFromString,
      account: ParsedAccountInfoResult
    });
    StakeActivationResult = type({
      state: union([literal("active"), literal("inactive"), literal("activating"), literal("deactivating")]),
      active: number(),
      inactive: number()
    });
    GetConfirmedSignaturesForAddress2RpcResult = jsonRpcResult(array(type({
      signature: string(),
      slot: number(),
      err: TransactionErrorResult,
      memo: nullable(string()),
      blockTime: optional(nullable(number()))
    })));
    GetSignaturesForAddressRpcResult = jsonRpcResult(array(type({
      signature: string(),
      slot: number(),
      err: TransactionErrorResult,
      memo: nullable(string()),
      blockTime: optional(nullable(number()))
    })));
    AccountNotificationResult = type({
      subscription: number(),
      result: notificationResultAndContext(AccountInfoResult)
    });
    ProgramAccountInfoResult = type({
      pubkey: PublicKeyFromString,
      account: AccountInfoResult
    });
    ProgramAccountNotificationResult = type({
      subscription: number(),
      result: notificationResultAndContext(ProgramAccountInfoResult)
    });
    SlotInfoResult = type({
      parent: number(),
      slot: number(),
      root: number()
    });
    SlotNotificationResult = type({
      subscription: number(),
      result: SlotInfoResult
    });
    SlotUpdateResult = union([type({
      type: union([literal("firstShredReceived"), literal("completed"), literal("optimisticConfirmation"), literal("root")]),
      slot: number(),
      timestamp: number()
    }), type({
      type: literal("createdBank"),
      parent: number(),
      slot: number(),
      timestamp: number()
    }), type({
      type: literal("frozen"),
      slot: number(),
      timestamp: number(),
      stats: type({
        numTransactionEntries: number(),
        numSuccessfulTransactions: number(),
        numFailedTransactions: number(),
        maxTransactionsPerEntry: number()
      })
    }), type({
      type: literal("dead"),
      slot: number(),
      timestamp: number(),
      err: string()
    })]);
    SlotUpdateNotificationResult = type({
      subscription: number(),
      result: SlotUpdateResult
    });
    SignatureNotificationResult = type({
      subscription: number(),
      result: notificationResultAndContext(union([SignatureStatusResult, SignatureReceivedResult]))
    });
    RootNotificationResult = type({
      subscription: number(),
      result: number()
    });
    ContactInfoResult = type({
      pubkey: string(),
      gossip: nullable(string()),
      tpu: nullable(string()),
      rpc: nullable(string()),
      version: nullable(string())
    });
    VoteAccountInfoResult = type({
      votePubkey: string(),
      nodePubkey: string(),
      activatedStake: number(),
      epochVoteAccount: boolean(),
      epochCredits: array(tuple([number(), number(), number()])),
      commission: number(),
      lastVote: number(),
      rootSlot: nullable(number())
    });
    GetVoteAccounts = jsonRpcResult(type({
      current: array(VoteAccountInfoResult),
      delinquent: array(VoteAccountInfoResult)
    }));
    ConfirmationStatus = union([literal("processed"), literal("confirmed"), literal("finalized")]);
    SignatureStatusResponse = type({
      slot: number(),
      confirmations: nullable(number()),
      err: TransactionErrorResult,
      confirmationStatus: optional(ConfirmationStatus)
    });
    GetSignatureStatusesRpcResult = jsonRpcResultAndContext(array(nullable(SignatureStatusResponse)));
    GetMinimumBalanceForRentExemptionRpcResult = jsonRpcResult(number());
    AddressTableLookupStruct = type({
      accountKey: PublicKeyFromString,
      writableIndexes: array(number()),
      readonlyIndexes: array(number())
    });
    ConfirmedTransactionResult = type({
      signatures: array(string()),
      message: type({
        accountKeys: array(string()),
        header: type({
          numRequiredSignatures: number(),
          numReadonlySignedAccounts: number(),
          numReadonlyUnsignedAccounts: number()
        }),
        instructions: array(type({
          accounts: array(number()),
          data: string(),
          programIdIndex: number()
        })),
        recentBlockhash: string(),
        addressTableLookups: optional(array(AddressTableLookupStruct))
      })
    });
    AnnotatedAccountKey = type({
      pubkey: PublicKeyFromString,
      signer: boolean(),
      writable: boolean(),
      source: optional(union([literal("transaction"), literal("lookupTable")]))
    });
    ConfirmedTransactionAccountsModeResult = type({
      accountKeys: array(AnnotatedAccountKey),
      signatures: array(string())
    });
    ParsedInstructionResult = type({
      parsed: unknown(),
      program: string(),
      programId: PublicKeyFromString
    });
    RawInstructionResult = type({
      accounts: array(PublicKeyFromString),
      data: string(),
      programId: PublicKeyFromString
    });
    InstructionResult = union([RawInstructionResult, ParsedInstructionResult]);
    UnknownInstructionResult = union([type({
      parsed: unknown(),
      program: string(),
      programId: string()
    }), type({
      accounts: array(string()),
      data: string(),
      programId: string()
    })]);
    ParsedOrRawInstruction = coerce(InstructionResult, UnknownInstructionResult, (value) => {
      if ("accounts" in value) {
        return create(value, RawInstructionResult);
      } else {
        return create(value, ParsedInstructionResult);
      }
    });
    ParsedConfirmedTransactionResult = type({
      signatures: array(string()),
      message: type({
        accountKeys: array(AnnotatedAccountKey),
        instructions: array(ParsedOrRawInstruction),
        recentBlockhash: string(),
        addressTableLookups: optional(nullable(array(AddressTableLookupStruct)))
      })
    });
    TokenBalanceResult = type({
      accountIndex: number(),
      mint: string(),
      owner: optional(string()),
      programId: optional(string()),
      uiTokenAmount: TokenAmountResult
    });
    LoadedAddressesResult = type({
      writable: array(PublicKeyFromString),
      readonly: array(PublicKeyFromString)
    });
    ConfirmedTransactionMetaResult = type({
      err: TransactionErrorResult,
      fee: number(),
      innerInstructions: optional(nullable(array(type({
        index: number(),
        instructions: array(type({
          accounts: array(number()),
          data: string(),
          programIdIndex: number()
        }))
      })))),
      preBalances: array(number()),
      postBalances: array(number()),
      logMessages: optional(nullable(array(string()))),
      preTokenBalances: optional(nullable(array(TokenBalanceResult))),
      postTokenBalances: optional(nullable(array(TokenBalanceResult))),
      loadedAddresses: optional(LoadedAddressesResult),
      computeUnitsConsumed: optional(number()),
      costUnits: optional(number())
    });
    ParsedConfirmedTransactionMetaResult = type({
      err: TransactionErrorResult,
      fee: number(),
      innerInstructions: optional(nullable(array(type({
        index: number(),
        instructions: array(ParsedOrRawInstruction)
      })))),
      preBalances: array(number()),
      postBalances: array(number()),
      logMessages: optional(nullable(array(string()))),
      preTokenBalances: optional(nullable(array(TokenBalanceResult))),
      postTokenBalances: optional(nullable(array(TokenBalanceResult))),
      loadedAddresses: optional(LoadedAddressesResult),
      computeUnitsConsumed: optional(number()),
      costUnits: optional(number())
    });
    TransactionVersionStruct = union([literal(0), literal("legacy")]);
    RewardsResult = type({
      pubkey: string(),
      lamports: number(),
      postBalance: nullable(number()),
      rewardType: nullable(string()),
      commission: optional(nullable(number()))
    });
    GetBlockRpcResult = jsonRpcResult(nullable(type({
      blockhash: string(),
      previousBlockhash: string(),
      parentSlot: number(),
      transactions: array(type({
        transaction: ConfirmedTransactionResult,
        meta: nullable(ConfirmedTransactionMetaResult),
        version: optional(TransactionVersionStruct)
      })),
      rewards: optional(array(RewardsResult)),
      blockTime: nullable(number()),
      blockHeight: nullable(number())
    })));
    GetNoneModeBlockRpcResult = jsonRpcResult(nullable(type({
      blockhash: string(),
      previousBlockhash: string(),
      parentSlot: number(),
      rewards: optional(array(RewardsResult)),
      blockTime: nullable(number()),
      blockHeight: nullable(number())
    })));
    GetAccountsModeBlockRpcResult = jsonRpcResult(nullable(type({
      blockhash: string(),
      previousBlockhash: string(),
      parentSlot: number(),
      transactions: array(type({
        transaction: ConfirmedTransactionAccountsModeResult,
        meta: nullable(ConfirmedTransactionMetaResult),
        version: optional(TransactionVersionStruct)
      })),
      rewards: optional(array(RewardsResult)),
      blockTime: nullable(number()),
      blockHeight: nullable(number())
    })));
    GetParsedBlockRpcResult = jsonRpcResult(nullable(type({
      blockhash: string(),
      previousBlockhash: string(),
      parentSlot: number(),
      transactions: array(type({
        transaction: ParsedConfirmedTransactionResult,
        meta: nullable(ParsedConfirmedTransactionMetaResult),
        version: optional(TransactionVersionStruct)
      })),
      rewards: optional(array(RewardsResult)),
      blockTime: nullable(number()),
      blockHeight: nullable(number())
    })));
    GetParsedAccountsModeBlockRpcResult = jsonRpcResult(nullable(type({
      blockhash: string(),
      previousBlockhash: string(),
      parentSlot: number(),
      transactions: array(type({
        transaction: ConfirmedTransactionAccountsModeResult,
        meta: nullable(ParsedConfirmedTransactionMetaResult),
        version: optional(TransactionVersionStruct)
      })),
      rewards: optional(array(RewardsResult)),
      blockTime: nullable(number()),
      blockHeight: nullable(number())
    })));
    GetParsedNoneModeBlockRpcResult = jsonRpcResult(nullable(type({
      blockhash: string(),
      previousBlockhash: string(),
      parentSlot: number(),
      rewards: optional(array(RewardsResult)),
      blockTime: nullable(number()),
      blockHeight: nullable(number())
    })));
    GetConfirmedBlockRpcResult = jsonRpcResult(nullable(type({
      blockhash: string(),
      previousBlockhash: string(),
      parentSlot: number(),
      transactions: array(type({
        transaction: ConfirmedTransactionResult,
        meta: nullable(ConfirmedTransactionMetaResult)
      })),
      rewards: optional(array(RewardsResult)),
      blockTime: nullable(number())
    })));
    GetBlockSignaturesRpcResult = jsonRpcResult(nullable(type({
      blockhash: string(),
      previousBlockhash: string(),
      parentSlot: number(),
      signatures: array(string()),
      blockTime: nullable(number())
    })));
    GetTransactionRpcResult = jsonRpcResult(nullable(type({
      slot: number(),
      meta: nullable(ConfirmedTransactionMetaResult),
      blockTime: optional(nullable(number())),
      transaction: ConfirmedTransactionResult,
      version: optional(TransactionVersionStruct)
    })));
    GetParsedTransactionRpcResult = jsonRpcResult(nullable(type({
      slot: number(),
      transaction: ParsedConfirmedTransactionResult,
      meta: nullable(ParsedConfirmedTransactionMetaResult),
      blockTime: optional(nullable(number())),
      version: optional(TransactionVersionStruct)
    })));
    GetLatestBlockhashRpcResult = jsonRpcResultAndContext(type({
      blockhash: string(),
      lastValidBlockHeight: number()
    }));
    IsBlockhashValidRpcResult = jsonRpcResultAndContext(boolean());
    PerfSampleResult = type({
      slot: number(),
      numTransactions: number(),
      numSlots: number(),
      samplePeriodSecs: number()
    });
    GetRecentPerformanceSamplesRpcResult = jsonRpcResult(array(PerfSampleResult));
    GetFeeCalculatorRpcResult = jsonRpcResultAndContext(nullable(type({
      feeCalculator: type({
        lamportsPerSignature: number()
      })
    })));
    RequestAirdropRpcResult = jsonRpcResult(string());
    SendTransactionRpcResult = jsonRpcResult(string());
    LogsResult = type({
      err: TransactionErrorResult,
      logs: array(string()),
      signature: string()
    });
    LogsNotificationResult = type({
      result: notificationResultAndContext(LogsResult),
      subscription: number()
    });
    COMMON_HTTP_HEADERS = {
      "solana-client": `js/${"1.0.0-maintenance"}`
    };
    Connection = class {
      /**
       * Establish a JSON RPC connection
       *
       * @param endpoint URL to the fullnode JSON RPC endpoint
       * @param commitmentOrConfig optional default commitment level or optional ConnectionConfig configuration object
       */
      constructor(endpoint2, _commitmentOrConfig) {
        this._commitment = void 0;
        this._confirmTransactionInitialTimeout = void 0;
        this._rpcEndpoint = void 0;
        this._rpcWsEndpoint = void 0;
        this._rpcClient = void 0;
        this._rpcRequest = void 0;
        this._rpcBatchRequest = void 0;
        this._rpcWebSocket = void 0;
        this._rpcWebSocketConnected = false;
        this._rpcWebSocketHeartbeat = null;
        this._rpcWebSocketIdleTimeout = null;
        this._rpcWebSocketGeneration = 0;
        this._disableBlockhashCaching = false;
        this._pollingBlockhash = false;
        this._blockhashInfo = {
          latestBlockhash: null,
          lastFetch: 0,
          transactionSignatures: [],
          simulatedSignatures: []
        };
        this._nextClientSubscriptionId = 0;
        this._subscriptionDisposeFunctionsByClientSubscriptionId = {};
        this._subscriptionHashByClientSubscriptionId = {};
        this._subscriptionStateChangeCallbacksByHash = {};
        this._subscriptionCallbacksByServerSubscriptionId = {};
        this._subscriptionsByHash = {};
        this._subscriptionsAutoDisposedByRpc = /* @__PURE__ */ new Set();
        this.getBlockHeight = /* @__PURE__ */ (() => {
          const requestPromises = {};
          return async (commitmentOrConfig) => {
            const {
              commitment,
              config
            } = extractCommitmentFromConfig(commitmentOrConfig);
            const args = this._buildArgs([], commitment, void 0, config);
            const requestHash = fastStableStringify(args);
            requestPromises[requestHash] = requestPromises[requestHash] ?? (async () => {
              try {
                const unsafeRes = await this._rpcRequest("getBlockHeight", args);
                const res = create(unsafeRes, jsonRpcResult(number()));
                if ("error" in res) {
                  throw new SolanaJSONRPCError(res.error, "failed to get block height information");
                }
                return res.result;
              } finally {
                delete requestPromises[requestHash];
              }
            })();
            return await requestPromises[requestHash];
          };
        })();
        let wsEndpoint;
        let httpHeaders;
        let fetch3;
        let fetchMiddleware;
        let disableRetryOnRateLimit;
        let httpAgent;
        if (_commitmentOrConfig && typeof _commitmentOrConfig === "string") {
          this._commitment = _commitmentOrConfig;
        } else if (_commitmentOrConfig) {
          this._commitment = _commitmentOrConfig.commitment;
          this._confirmTransactionInitialTimeout = _commitmentOrConfig.confirmTransactionInitialTimeout;
          wsEndpoint = _commitmentOrConfig.wsEndpoint;
          httpHeaders = _commitmentOrConfig.httpHeaders;
          fetch3 = _commitmentOrConfig.fetch;
          fetchMiddleware = _commitmentOrConfig.fetchMiddleware;
          disableRetryOnRateLimit = _commitmentOrConfig.disableRetryOnRateLimit;
          httpAgent = _commitmentOrConfig.httpAgent;
        }
        this._rpcEndpoint = assertEndpointUrl(endpoint2);
        this._rpcWsEndpoint = wsEndpoint || makeWebsocketUrl(endpoint2);
        this._rpcClient = createRpcClient(endpoint2, httpHeaders, fetch3, fetchMiddleware, disableRetryOnRateLimit, httpAgent);
        this._rpcRequest = createRpcRequest(this._rpcClient);
        this._rpcBatchRequest = createRpcBatchRequest(this._rpcClient);
        this._rpcWebSocket = new RpcWebSocketClient(this._rpcWsEndpoint, {
          autoconnect: false,
          max_reconnects: Infinity
        });
        this._rpcWebSocket.on("open", this._wsOnOpen.bind(this));
        this._rpcWebSocket.on("error", this._wsOnError.bind(this));
        this._rpcWebSocket.on("close", this._wsOnClose.bind(this));
        this._rpcWebSocket.on("accountNotification", this._wsOnAccountNotification.bind(this));
        this._rpcWebSocket.on("programNotification", this._wsOnProgramAccountNotification.bind(this));
        this._rpcWebSocket.on("slotNotification", this._wsOnSlotNotification.bind(this));
        this._rpcWebSocket.on("slotsUpdatesNotification", this._wsOnSlotUpdatesNotification.bind(this));
        this._rpcWebSocket.on("signatureNotification", this._wsOnSignatureNotification.bind(this));
        this._rpcWebSocket.on("rootNotification", this._wsOnRootNotification.bind(this));
        this._rpcWebSocket.on("logsNotification", this._wsOnLogsNotification.bind(this));
      }
      /**
       * The default commitment used for requests
       */
      get commitment() {
        return this._commitment;
      }
      /**
       * The RPC endpoint
       */
      get rpcEndpoint() {
        return this._rpcEndpoint;
      }
      /**
       * Fetch the balance for the specified public key, return with context
       */
      async getBalanceAndContext(publicKey5, commitmentOrConfig) {
        const {
          commitment,
          config
        } = extractCommitmentFromConfig(commitmentOrConfig);
        const args = this._buildArgs([publicKey5.toBase58()], commitment, void 0, config);
        const unsafeRes = await this._rpcRequest("getBalance", args);
        const res = create(unsafeRes, jsonRpcResultAndContext(number()));
        if ("error" in res) {
          throw new SolanaJSONRPCError(res.error, `failed to get balance for ${publicKey5.toBase58()}`);
        }
        return res.result;
      }
      /**
       * Fetch the balance for the specified public key
       */
      async getBalance(publicKey5, commitmentOrConfig) {
        return await this.getBalanceAndContext(publicKey5, commitmentOrConfig).then((x) => x.value).catch((e) => {
          throw new Error("failed to get balance of account " + publicKey5.toBase58() + ": " + e);
        });
      }
      /**
       * Fetch the estimated production time of a block
       */
      async getBlockTime(slot) {
        const unsafeRes = await this._rpcRequest("getBlockTime", [slot]);
        const res = create(unsafeRes, jsonRpcResult(nullable(number())));
        if ("error" in res) {
          throw new SolanaJSONRPCError(res.error, `failed to get block time for slot ${slot}`);
        }
        return res.result;
      }
      /**
       * Fetch the lowest slot that the node has information about in its ledger.
       * This value may increase over time if the node is configured to purge older ledger data
       */
      async getMinimumLedgerSlot() {
        const unsafeRes = await this._rpcRequest("minimumLedgerSlot", []);
        const res = create(unsafeRes, jsonRpcResult(number()));
        if ("error" in res) {
          throw new SolanaJSONRPCError(res.error, "failed to get minimum ledger slot");
        }
        return res.result;
      }
      /**
       * Fetch the slot of the lowest confirmed block that has not been purged from the ledger
       */
      async getFirstAvailableBlock() {
        const unsafeRes = await this._rpcRequest("getFirstAvailableBlock", []);
        const res = create(unsafeRes, SlotRpcResult);
        if ("error" in res) {
          throw new SolanaJSONRPCError(res.error, "failed to get first available block");
        }
        return res.result;
      }
      /**
       * Fetch information about the current supply
       */
      async getSupply(config) {
        let configArg = {};
        if (typeof config === "string") {
          configArg = {
            commitment: config
          };
        } else if (config) {
          configArg = {
            ...config,
            commitment: config && config.commitment || this.commitment
          };
        } else {
          configArg = {
            commitment: this.commitment
          };
        }
        const unsafeRes = await this._rpcRequest("getSupply", [configArg]);
        const res = create(unsafeRes, GetSupplyRpcResult);
        if ("error" in res) {
          throw new SolanaJSONRPCError(res.error, "failed to get supply");
        }
        return res.result;
      }
      /**
       * Fetch the current supply of a token mint
       */
      async getTokenSupply(tokenMintAddress, commitment) {
        const args = this._buildArgs([tokenMintAddress.toBase58()], commitment);
        const unsafeRes = await this._rpcRequest("getTokenSupply", args);
        const res = create(unsafeRes, jsonRpcResultAndContext(TokenAmountResult));
        if ("error" in res) {
          throw new SolanaJSONRPCError(res.error, "failed to get token supply");
        }
        return res.result;
      }
      /**
       * Fetch the current balance of a token account
       */
      async getTokenAccountBalance(tokenAddress, commitment) {
        const args = this._buildArgs([tokenAddress.toBase58()], commitment);
        const unsafeRes = await this._rpcRequest("getTokenAccountBalance", args);
        const res = create(unsafeRes, jsonRpcResultAndContext(TokenAmountResult));
        if ("error" in res) {
          throw new SolanaJSONRPCError(res.error, "failed to get token account balance");
        }
        return res.result;
      }
      /**
       * Fetch all the token accounts owned by the specified account
       *
       * @return {Promise<RpcResponseAndContext<GetProgramAccountsResponse>}
       */
      async getTokenAccountsByOwner(ownerAddress, filter, commitmentOrConfig) {
        const {
          commitment,
          config
        } = extractCommitmentFromConfig(commitmentOrConfig);
        let _args = [ownerAddress.toBase58()];
        if ("mint" in filter) {
          _args.push({
            mint: filter.mint.toBase58()
          });
        } else {
          _args.push({
            programId: filter.programId.toBase58()
          });
        }
        const args = this._buildArgs(_args, commitment, "base64", config);
        const unsafeRes = await this._rpcRequest("getTokenAccountsByOwner", args);
        const res = create(unsafeRes, GetTokenAccountsByOwner);
        if ("error" in res) {
          throw new SolanaJSONRPCError(res.error, `failed to get token accounts owned by account ${ownerAddress.toBase58()}`);
        }
        return res.result;
      }
      /**
       * Fetch parsed token accounts owned by the specified account
       *
       * @return {Promise<RpcResponseAndContext<Array<{pubkey: PublicKey, account: AccountInfo<ParsedAccountData>}>>>}
       */
      async getParsedTokenAccountsByOwner(ownerAddress, filter, commitment) {
        let _args = [ownerAddress.toBase58()];
        if ("mint" in filter) {
          _args.push({
            mint: filter.mint.toBase58()
          });
        } else {
          _args.push({
            programId: filter.programId.toBase58()
          });
        }
        const args = this._buildArgs(_args, commitment, "jsonParsed");
        const unsafeRes = await this._rpcRequest("getTokenAccountsByOwner", args);
        const res = create(unsafeRes, GetParsedTokenAccountsByOwner);
        if ("error" in res) {
          throw new SolanaJSONRPCError(res.error, `failed to get token accounts owned by account ${ownerAddress.toBase58()}`);
        }
        return res.result;
      }
      /**
       * Fetch the 20 largest accounts with their current balances
       */
      async getLargestAccounts(config) {
        const arg = {
          ...config,
          commitment: config && config.commitment || this.commitment
        };
        const args = arg.filter || arg.commitment ? [arg] : [];
        const unsafeRes = await this._rpcRequest("getLargestAccounts", args);
        const res = create(unsafeRes, GetLargestAccountsRpcResult);
        if ("error" in res) {
          throw new SolanaJSONRPCError(res.error, "failed to get largest accounts");
        }
        return res.result;
      }
      /**
       * Fetch the 20 largest token accounts with their current balances
       * for a given mint.
       */
      async getTokenLargestAccounts(mintAddress, commitment) {
        const args = this._buildArgs([mintAddress.toBase58()], commitment);
        const unsafeRes = await this._rpcRequest("getTokenLargestAccounts", args);
        const res = create(unsafeRes, GetTokenLargestAccountsResult);
        if ("error" in res) {
          throw new SolanaJSONRPCError(res.error, "failed to get token largest accounts");
        }
        return res.result;
      }
      /**
       * Fetch all the account info for the specified public key, return with context
       */
      async getAccountInfoAndContext(publicKey5, commitmentOrConfig) {
        const {
          commitment,
          config
        } = extractCommitmentFromConfig(commitmentOrConfig);
        const args = this._buildArgs([publicKey5.toBase58()], commitment, "base64", config);
        const unsafeRes = await this._rpcRequest("getAccountInfo", args);
        const res = create(unsafeRes, jsonRpcResultAndContext(nullable(AccountInfoResult)));
        if ("error" in res) {
          throw new SolanaJSONRPCError(res.error, `failed to get info about account ${publicKey5.toBase58()}`);
        }
        return res.result;
      }
      /**
       * Fetch parsed account info for the specified public key
       */
      async getParsedAccountInfo(publicKey5, commitmentOrConfig) {
        const {
          commitment,
          config
        } = extractCommitmentFromConfig(commitmentOrConfig);
        const args = this._buildArgs([publicKey5.toBase58()], commitment, "jsonParsed", config);
        const unsafeRes = await this._rpcRequest("getAccountInfo", args);
        const res = create(unsafeRes, jsonRpcResultAndContext(nullable(ParsedAccountInfoResult)));
        if ("error" in res) {
          throw new SolanaJSONRPCError(res.error, `failed to get info about account ${publicKey5.toBase58()}`);
        }
        return res.result;
      }
      /**
       * Fetch all the account info for the specified public key
       */
      async getAccountInfo(publicKey5, commitmentOrConfig) {
        try {
          const res = await this.getAccountInfoAndContext(publicKey5, commitmentOrConfig);
          return res.value;
        } catch (e) {
          throw new Error("failed to get info about account " + publicKey5.toBase58() + ": " + e);
        }
      }
      /**
       * Fetch all the account info for multiple accounts specified by an array of public keys, return with context
       */
      async getMultipleParsedAccounts(publicKeys, rawConfig) {
        const {
          commitment,
          config
        } = extractCommitmentFromConfig(rawConfig);
        const keys = publicKeys.map((key) => key.toBase58());
        const args = this._buildArgs([keys], commitment, "jsonParsed", config);
        const unsafeRes = await this._rpcRequest("getMultipleAccounts", args);
        const res = create(unsafeRes, jsonRpcResultAndContext(array(nullable(ParsedAccountInfoResult))));
        if ("error" in res) {
          throw new SolanaJSONRPCError(res.error, `failed to get info for accounts ${keys}`);
        }
        return res.result;
      }
      /**
       * Fetch all the account info for multiple accounts specified by an array of public keys, return with context
       */
      async getMultipleAccountsInfoAndContext(publicKeys, commitmentOrConfig) {
        const {
          commitment,
          config
        } = extractCommitmentFromConfig(commitmentOrConfig);
        const keys = publicKeys.map((key) => key.toBase58());
        const args = this._buildArgs([keys], commitment, "base64", config);
        const unsafeRes = await this._rpcRequest("getMultipleAccounts", args);
        const res = create(unsafeRes, jsonRpcResultAndContext(array(nullable(AccountInfoResult))));
        if ("error" in res) {
          throw new SolanaJSONRPCError(res.error, `failed to get info for accounts ${keys}`);
        }
        return res.result;
      }
      /**
       * Fetch all the account info for multiple accounts specified by an array of public keys
       */
      async getMultipleAccountsInfo(publicKeys, commitmentOrConfig) {
        const res = await this.getMultipleAccountsInfoAndContext(publicKeys, commitmentOrConfig);
        return res.value;
      }
      /**
       * Returns epoch activation information for a stake account that has been delegated
       *
       * @deprecated Deprecated since RPC v1.18; will be removed in a future version.
       */
      async getStakeActivation(publicKey5, commitmentOrConfig, epoch) {
        const {
          commitment,
          config
        } = extractCommitmentFromConfig(commitmentOrConfig);
        const args = this._buildArgs([publicKey5.toBase58()], commitment, void 0, {
          ...config,
          epoch: epoch != null ? epoch : config == null ? void 0 : config.epoch
        });
        const unsafeRes = await this._rpcRequest("getStakeActivation", args);
        const res = create(unsafeRes, jsonRpcResult(StakeActivationResult));
        if ("error" in res) {
          throw new SolanaJSONRPCError(res.error, `failed to get Stake Activation ${publicKey5.toBase58()}`);
        }
        return res.result;
      }
      /**
       * Fetch all the accounts owned by the specified program id
       *
       * @return {Promise<Array<{pubkey: PublicKey, account: AccountInfo<Buffer>}>>}
       */
      // eslint-disable-next-line no-dupe-class-members
      // eslint-disable-next-line no-dupe-class-members
      async getProgramAccounts(programId, configOrCommitment) {
        const {
          commitment,
          config
        } = extractCommitmentFromConfig(configOrCommitment);
        const {
          encoding,
          ...configWithoutEncoding
        } = config || {};
        const args = this._buildArgs([programId.toBase58()], commitment, encoding || "base64", {
          ...configWithoutEncoding,
          ...configWithoutEncoding.filters ? {
            filters: applyDefaultMemcmpEncodingToFilters(configWithoutEncoding.filters)
          } : null
        });
        const unsafeRes = await this._rpcRequest("getProgramAccounts", args);
        const baseSchema = array(KeyedAccountInfoResult);
        const res = configWithoutEncoding.withContext === true ? create(unsafeRes, jsonRpcResultAndContext(baseSchema)) : create(unsafeRes, jsonRpcResult(baseSchema));
        if ("error" in res) {
          throw new SolanaJSONRPCError(res.error, `failed to get accounts owned by program ${programId.toBase58()}`);
        }
        return res.result;
      }
      /**
       * Fetch and parse all the accounts owned by the specified program id
       *
       * @return {Promise<Array<{pubkey: PublicKey, account: AccountInfo<Buffer | ParsedAccountData>}>>}
       */
      async getParsedProgramAccounts(programId, configOrCommitment) {
        const {
          commitment,
          config
        } = extractCommitmentFromConfig(configOrCommitment);
        const args = this._buildArgs([programId.toBase58()], commitment, "jsonParsed", config);
        const unsafeRes = await this._rpcRequest("getProgramAccounts", args);
        const res = create(unsafeRes, jsonRpcResult(array(KeyedParsedAccountInfoResult)));
        if ("error" in res) {
          throw new SolanaJSONRPCError(res.error, `failed to get accounts owned by program ${programId.toBase58()}`);
        }
        return res.result;
      }
      /** @deprecated Instead, call `confirmTransaction` and pass in {@link TransactionConfirmationStrategy} */
      // eslint-disable-next-line no-dupe-class-members
      // eslint-disable-next-line no-dupe-class-members
      async confirmTransaction(strategy, commitment) {
        var _a2;
        let rawSignature;
        if (typeof strategy == "string") {
          rawSignature = strategy;
        } else {
          const config = strategy;
          if ((_a2 = config.abortSignal) == null ? void 0 : _a2.aborted) {
            return Promise.reject(config.abortSignal.reason);
          }
          rawSignature = config.signature;
        }
        let decodedSignature;
        try {
          decodedSignature = import_bs58.default.decode(rawSignature);
        } catch (err2) {
          throw new Error("signature must be base58 encoded: " + rawSignature);
        }
        assert2(decodedSignature.length === 64, "signature has invalid length");
        if (typeof strategy === "string") {
          return await this.confirmTransactionUsingLegacyTimeoutStrategy({
            commitment: commitment || this.commitment,
            signature: rawSignature
          });
        } else if ("lastValidBlockHeight" in strategy) {
          return await this.confirmTransactionUsingBlockHeightExceedanceStrategy({
            commitment: commitment || this.commitment,
            strategy
          });
        } else {
          return await this.confirmTransactionUsingDurableNonceStrategy({
            commitment: commitment || this.commitment,
            strategy
          });
        }
      }
      getCancellationPromise(signal) {
        return new Promise((_, reject2) => {
          if (signal == null) {
            return;
          }
          if (signal.aborted) {
            reject2(signal.reason);
          } else {
            signal.addEventListener("abort", () => {
              reject2(signal.reason);
            });
          }
        });
      }
      getTransactionConfirmationPromise({
        commitment,
        signature: signature2
      }) {
        let signatureSubscriptionId;
        let disposeSignatureSubscriptionStateChangeObserver;
        let done = false;
        const confirmationPromise = new Promise((resolve2, reject2) => {
          try {
            signatureSubscriptionId = this.onSignature(signature2, (result, context) => {
              signatureSubscriptionId = void 0;
              const response = {
                context,
                value: result
              };
              resolve2({
                __type: TransactionStatus.PROCESSED,
                response
              });
            }, commitment);
            const subscriptionSetupPromise = new Promise((resolveSubscriptionSetup) => {
              if (signatureSubscriptionId == null) {
                resolveSubscriptionSetup();
              } else {
                disposeSignatureSubscriptionStateChangeObserver = this._onSubscriptionStateChange(signatureSubscriptionId, (nextState) => {
                  if (nextState === "subscribed") {
                    resolveSubscriptionSetup();
                  }
                });
              }
            });
            (async () => {
              await subscriptionSetupPromise;
              if (done) return;
              const response = await this.getSignatureStatus(signature2);
              if (done) return;
              if (response == null) {
                return;
              }
              const {
                context,
                value
              } = response;
              if (value == null) {
                return;
              }
              if (value == null ? void 0 : value.err) {
                reject2(value.err);
              } else {
                switch (commitment) {
                  case "confirmed":
                  case "single":
                  case "singleGossip": {
                    if (value.confirmationStatus === "processed") {
                      return;
                    }
                    break;
                  }
                  case "finalized":
                  case "max":
                  case "root": {
                    if (value.confirmationStatus === "processed" || value.confirmationStatus === "confirmed") {
                      return;
                    }
                    break;
                  }
                  // exhaust enums to ensure full coverage
                  case "processed":
                  case "recent":
                }
                done = true;
                resolve2({
                  __type: TransactionStatus.PROCESSED,
                  response: {
                    context,
                    value
                  }
                });
              }
            })();
          } catch (err2) {
            reject2(err2);
          }
        });
        const abortConfirmation = () => {
          if (disposeSignatureSubscriptionStateChangeObserver) {
            disposeSignatureSubscriptionStateChangeObserver();
            disposeSignatureSubscriptionStateChangeObserver = void 0;
          }
          if (signatureSubscriptionId != null) {
            this.removeSignatureListener(signatureSubscriptionId);
            signatureSubscriptionId = void 0;
          }
        };
        return {
          abortConfirmation,
          confirmationPromise
        };
      }
      async confirmTransactionUsingBlockHeightExceedanceStrategy({
        commitment,
        strategy: {
          abortSignal,
          lastValidBlockHeight,
          signature: signature2
        }
      }) {
        let done = false;
        const expiryPromise = new Promise((resolve2) => {
          const checkBlockHeight = async () => {
            try {
              const blockHeight = await this.getBlockHeight(commitment);
              return blockHeight;
            } catch (_e) {
              return -1;
            }
          };
          (async () => {
            let currentBlockHeight = await checkBlockHeight();
            if (done) return;
            while (currentBlockHeight <= lastValidBlockHeight) {
              await sleep(1e3);
              if (done) return;
              currentBlockHeight = await checkBlockHeight();
              if (done) return;
            }
            resolve2({
              __type: TransactionStatus.BLOCKHEIGHT_EXCEEDED
            });
          })();
        });
        const {
          abortConfirmation,
          confirmationPromise
        } = this.getTransactionConfirmationPromise({
          commitment,
          signature: signature2
        });
        const cancellationPromise = this.getCancellationPromise(abortSignal);
        let result;
        try {
          const outcome = await Promise.race([cancellationPromise, confirmationPromise, expiryPromise]);
          if (outcome.__type === TransactionStatus.PROCESSED) {
            result = outcome.response;
          } else {
            throw new TransactionExpiredBlockheightExceededError(signature2);
          }
        } finally {
          done = true;
          abortConfirmation();
        }
        return result;
      }
      async confirmTransactionUsingDurableNonceStrategy({
        commitment,
        strategy: {
          abortSignal,
          minContextSlot,
          nonceAccountPubkey,
          nonceValue,
          signature: signature2
        }
      }) {
        let done = false;
        const expiryPromise = new Promise((resolve2) => {
          let currentNonceValue = nonceValue;
          let lastCheckedSlot = null;
          const getCurrentNonceValue = async () => {
            try {
              const {
                context,
                value: nonceAccount
              } = await this.getNonceAndContext(nonceAccountPubkey, {
                commitment,
                minContextSlot
              });
              lastCheckedSlot = context.slot;
              return nonceAccount == null ? void 0 : nonceAccount.nonce;
            } catch (e) {
              return currentNonceValue;
            }
          };
          (async () => {
            currentNonceValue = await getCurrentNonceValue();
            if (done) return;
            while (true) {
              if (nonceValue !== currentNonceValue) {
                resolve2({
                  __type: TransactionStatus.NONCE_INVALID,
                  slotInWhichNonceDidAdvance: lastCheckedSlot
                });
                return;
              }
              await sleep(2e3);
              if (done) return;
              currentNonceValue = await getCurrentNonceValue();
              if (done) return;
            }
          })();
        });
        const {
          abortConfirmation,
          confirmationPromise
        } = this.getTransactionConfirmationPromise({
          commitment,
          signature: signature2
        });
        const cancellationPromise = this.getCancellationPromise(abortSignal);
        let result;
        try {
          const outcome = await Promise.race([cancellationPromise, confirmationPromise, expiryPromise]);
          if (outcome.__type === TransactionStatus.PROCESSED) {
            result = outcome.response;
          } else {
            let signatureStatus;
            while (true) {
              const status = await this.getSignatureStatus(signature2);
              if (status == null) {
                break;
              }
              if (status.context.slot < (outcome.slotInWhichNonceDidAdvance ?? minContextSlot)) {
                await sleep(400);
                continue;
              }
              signatureStatus = status;
              break;
            }
            if (signatureStatus == null ? void 0 : signatureStatus.value) {
              const commitmentForStatus = commitment || "finalized";
              const {
                confirmationStatus
              } = signatureStatus.value;
              switch (commitmentForStatus) {
                case "processed":
                case "recent":
                  if (confirmationStatus !== "processed" && confirmationStatus !== "confirmed" && confirmationStatus !== "finalized") {
                    throw new TransactionExpiredNonceInvalidError(signature2);
                  }
                  break;
                case "confirmed":
                case "single":
                case "singleGossip":
                  if (confirmationStatus !== "confirmed" && confirmationStatus !== "finalized") {
                    throw new TransactionExpiredNonceInvalidError(signature2);
                  }
                  break;
                case "finalized":
                case "max":
                case "root":
                  if (confirmationStatus !== "finalized") {
                    throw new TransactionExpiredNonceInvalidError(signature2);
                  }
                  break;
                default:
                  /* @__PURE__ */ ((_) => {
                  })(commitmentForStatus);
              }
              result = {
                context: signatureStatus.context,
                value: {
                  err: signatureStatus.value.err
                }
              };
            } else {
              throw new TransactionExpiredNonceInvalidError(signature2);
            }
          }
        } finally {
          done = true;
          abortConfirmation();
        }
        return result;
      }
      async confirmTransactionUsingLegacyTimeoutStrategy({
        commitment,
        signature: signature2
      }) {
        let timeoutId;
        const expiryPromise = new Promise((resolve2) => {
          let timeoutMs = this._confirmTransactionInitialTimeout || 60 * 1e3;
          switch (commitment) {
            case "processed":
            case "recent":
            case "single":
            case "confirmed":
            case "singleGossip": {
              timeoutMs = this._confirmTransactionInitialTimeout || 30 * 1e3;
              break;
            }
          }
          timeoutId = setTimeout(() => resolve2({
            __type: TransactionStatus.TIMED_OUT,
            timeoutMs
          }), timeoutMs);
        });
        const {
          abortConfirmation,
          confirmationPromise
        } = this.getTransactionConfirmationPromise({
          commitment,
          signature: signature2
        });
        let result;
        try {
          const outcome = await Promise.race([confirmationPromise, expiryPromise]);
          if (outcome.__type === TransactionStatus.PROCESSED) {
            result = outcome.response;
          } else {
            throw new TransactionExpiredTimeoutError(signature2, outcome.timeoutMs / 1e3);
          }
        } finally {
          clearTimeout(timeoutId);
          abortConfirmation();
        }
        return result;
      }
      /**
       * Return the list of nodes that are currently participating in the cluster
       */
      async getClusterNodes() {
        const unsafeRes = await this._rpcRequest("getClusterNodes", []);
        const res = create(unsafeRes, jsonRpcResult(array(ContactInfoResult)));
        if ("error" in res) {
          throw new SolanaJSONRPCError(res.error, "failed to get cluster nodes");
        }
        return res.result;
      }
      /**
       * Return the list of nodes that are currently participating in the cluster
       */
      async getVoteAccounts(commitment) {
        const args = this._buildArgs([], commitment);
        const unsafeRes = await this._rpcRequest("getVoteAccounts", args);
        const res = create(unsafeRes, GetVoteAccounts);
        if ("error" in res) {
          throw new SolanaJSONRPCError(res.error, "failed to get vote accounts");
        }
        return res.result;
      }
      /**
       * Fetch the current slot that the node is processing
       */
      async getSlot(commitmentOrConfig) {
        const {
          commitment,
          config
        } = extractCommitmentFromConfig(commitmentOrConfig);
        const args = this._buildArgs([], commitment, void 0, config);
        const unsafeRes = await this._rpcRequest("getSlot", args);
        const res = create(unsafeRes, jsonRpcResult(number()));
        if ("error" in res) {
          throw new SolanaJSONRPCError(res.error, "failed to get slot");
        }
        return res.result;
      }
      /**
       * Fetch the current slot leader of the cluster
       */
      async getSlotLeader(commitmentOrConfig) {
        const {
          commitment,
          config
        } = extractCommitmentFromConfig(commitmentOrConfig);
        const args = this._buildArgs([], commitment, void 0, config);
        const unsafeRes = await this._rpcRequest("getSlotLeader", args);
        const res = create(unsafeRes, jsonRpcResult(string()));
        if ("error" in res) {
          throw new SolanaJSONRPCError(res.error, "failed to get slot leader");
        }
        return res.result;
      }
      /**
       * Fetch `limit` number of slot leaders starting from `startSlot`
       *
       * @param startSlot fetch slot leaders starting from this slot
       * @param limit number of slot leaders to return
       */
      async getSlotLeaders(startSlot, limit) {
        const args = [startSlot, limit];
        const unsafeRes = await this._rpcRequest("getSlotLeaders", args);
        const res = create(unsafeRes, jsonRpcResult(array(PublicKeyFromString)));
        if ("error" in res) {
          throw new SolanaJSONRPCError(res.error, "failed to get slot leaders");
        }
        return res.result;
      }
      /**
       * Fetch the current status of a signature
       */
      async getSignatureStatus(signature2, config) {
        const {
          context,
          value: values
        } = await this.getSignatureStatuses([signature2], config);
        assert2(values.length === 1);
        const value = values[0];
        return {
          context,
          value
        };
      }
      /**
       * Fetch the current statuses of a batch of signatures
       */
      async getSignatureStatuses(signatures, config) {
        const params = [signatures];
        if (config) {
          params.push(config);
        }
        const unsafeRes = await this._rpcRequest("getSignatureStatuses", params);
        const res = create(unsafeRes, GetSignatureStatusesRpcResult);
        if ("error" in res) {
          throw new SolanaJSONRPCError(res.error, "failed to get signature status");
        }
        return res.result;
      }
      /**
       * Fetch the current transaction count of the cluster
       */
      async getTransactionCount(commitmentOrConfig) {
        const {
          commitment,
          config
        } = extractCommitmentFromConfig(commitmentOrConfig);
        const args = this._buildArgs([], commitment, void 0, config);
        const unsafeRes = await this._rpcRequest("getTransactionCount", args);
        const res = create(unsafeRes, jsonRpcResult(number()));
        if ("error" in res) {
          throw new SolanaJSONRPCError(res.error, "failed to get transaction count");
        }
        return res.result;
      }
      /**
       * Fetch the current total currency supply of the cluster in lamports
       *
       * @deprecated Deprecated since RPC v1.2.8. Please use {@link getSupply} instead.
       */
      async getTotalSupply(commitment) {
        const result = await this.getSupply({
          commitment,
          excludeNonCirculatingAccountsList: true
        });
        return result.value.total;
      }
      /**
       * Fetch the cluster InflationGovernor parameters
       */
      async getInflationGovernor(commitment) {
        const args = this._buildArgs([], commitment);
        const unsafeRes = await this._rpcRequest("getInflationGovernor", args);
        const res = create(unsafeRes, GetInflationGovernorRpcResult);
        if ("error" in res) {
          throw new SolanaJSONRPCError(res.error, "failed to get inflation");
        }
        return res.result;
      }
      /**
       * Fetch the inflation reward for a list of addresses for an epoch
       */
      async getInflationReward(addresses, epoch, commitmentOrConfig) {
        const {
          commitment,
          config
        } = extractCommitmentFromConfig(commitmentOrConfig);
        const args = this._buildArgs([addresses.map((pubkey2) => pubkey2.toBase58())], commitment, void 0, {
          ...config,
          epoch: epoch != null ? epoch : config == null ? void 0 : config.epoch
        });
        const unsafeRes = await this._rpcRequest("getInflationReward", args);
        const res = create(unsafeRes, GetInflationRewardResult);
        if ("error" in res) {
          throw new SolanaJSONRPCError(res.error, "failed to get inflation reward");
        }
        return res.result;
      }
      /**
       * Fetch the specific inflation values for the current epoch
       */
      async getInflationRate() {
        const unsafeRes = await this._rpcRequest("getInflationRate", []);
        const res = create(unsafeRes, GetInflationRateRpcResult);
        if ("error" in res) {
          throw new SolanaJSONRPCError(res.error, "failed to get inflation rate");
        }
        return res.result;
      }
      /**
       * Fetch the Epoch Info parameters
       */
      async getEpochInfo(commitmentOrConfig) {
        const {
          commitment,
          config
        } = extractCommitmentFromConfig(commitmentOrConfig);
        const args = this._buildArgs([], commitment, void 0, config);
        const unsafeRes = await this._rpcRequest("getEpochInfo", args);
        const res = create(unsafeRes, GetEpochInfoRpcResult);
        if ("error" in res) {
          throw new SolanaJSONRPCError(res.error, "failed to get epoch info");
        }
        return res.result;
      }
      /**
       * Fetch the Epoch Schedule parameters
       */
      async getEpochSchedule() {
        const unsafeRes = await this._rpcRequest("getEpochSchedule", []);
        const res = create(unsafeRes, GetEpochScheduleRpcResult);
        if ("error" in res) {
          throw new SolanaJSONRPCError(res.error, "failed to get epoch schedule");
        }
        const epochSchedule = res.result;
        return new EpochSchedule(epochSchedule.slotsPerEpoch, epochSchedule.leaderScheduleSlotOffset, epochSchedule.warmup, epochSchedule.firstNormalEpoch, epochSchedule.firstNormalSlot);
      }
      /**
       * Fetch the leader schedule for the current epoch
       * @return {Promise<RpcResponseAndContext<LeaderSchedule>>}
       */
      async getLeaderSchedule() {
        const unsafeRes = await this._rpcRequest("getLeaderSchedule", []);
        const res = create(unsafeRes, GetLeaderScheduleRpcResult);
        if ("error" in res) {
          throw new SolanaJSONRPCError(res.error, "failed to get leader schedule");
        }
        return res.result;
      }
      /**
       * Fetch the minimum balance needed to exempt an account of `dataLength`
       * size from rent
       */
      async getMinimumBalanceForRentExemption(dataLength, commitment) {
        const args = this._buildArgs([dataLength], commitment);
        const unsafeRes = await this._rpcRequest("getMinimumBalanceForRentExemption", args);
        const res = create(unsafeRes, GetMinimumBalanceForRentExemptionRpcResult);
        if ("error" in res) {
          console.warn("Unable to fetch minimum balance for rent exemption");
          return 0;
        }
        return res.result;
      }
      /**
       * Fetch a recent blockhash from the cluster, return with context
       * @return {Promise<RpcResponseAndContext<{blockhash: Blockhash, feeCalculator: FeeCalculator}>>}
       *
       * @deprecated Deprecated since RPC v1.9.0. Please use {@link getLatestBlockhash} instead.
       */
      async getRecentBlockhashAndContext(commitment) {
        const {
          context,
          value: {
            blockhash
          }
        } = await this.getLatestBlockhashAndContext(commitment);
        const feeCalculator = {
          get lamportsPerSignature() {
            throw new Error("The capability to fetch `lamportsPerSignature` using the `getRecentBlockhash` API is no longer offered by the network. Use the `getFeeForMessage` API to obtain the fee for a given message.");
          },
          toJSON() {
            return {};
          }
        };
        return {
          context,
          value: {
            blockhash,
            feeCalculator
          }
        };
      }
      /**
       * Fetch recent performance samples
       * @return {Promise<Array<PerfSample>>}
       */
      async getRecentPerformanceSamples(limit) {
        const unsafeRes = await this._rpcRequest("getRecentPerformanceSamples", limit ? [limit] : []);
        const res = create(unsafeRes, GetRecentPerformanceSamplesRpcResult);
        if ("error" in res) {
          throw new SolanaJSONRPCError(res.error, "failed to get recent performance samples");
        }
        return res.result;
      }
      /**
       * Fetch the fee calculator for a recent blockhash from the cluster, return with context
       *
       * @deprecated Deprecated since RPC v1.9.0. Please use {@link getFeeForMessage} instead.
       */
      async getFeeCalculatorForBlockhash(blockhash, commitment) {
        const args = this._buildArgs([blockhash], commitment);
        const unsafeRes = await this._rpcRequest("getFeeCalculatorForBlockhash", args);
        const res = create(unsafeRes, GetFeeCalculatorRpcResult);
        if ("error" in res) {
          throw new SolanaJSONRPCError(res.error, "failed to get fee calculator");
        }
        const {
          context,
          value
        } = res.result;
        return {
          context,
          value: value !== null ? value.feeCalculator : null
        };
      }
      /**
       * Fetch the fee for a message from the cluster, return with context
       */
      async getFeeForMessage(message, commitment) {
        const wireMessage = toBuffer(message.serialize()).toString("base64");
        const args = this._buildArgs([wireMessage], commitment);
        const unsafeRes = await this._rpcRequest("getFeeForMessage", args);
        const res = create(unsafeRes, jsonRpcResultAndContext(nullable(number())));
        if ("error" in res) {
          throw new SolanaJSONRPCError(res.error, "failed to get fee for message");
        }
        if (res.result === null) {
          throw new Error("invalid blockhash");
        }
        return res.result;
      }
      /**
       * Fetch a list of prioritization fees from recent blocks.
       */
      async getRecentPrioritizationFees(config) {
        var _a2;
        const accounts = (_a2 = config == null ? void 0 : config.lockedWritableAccounts) == null ? void 0 : _a2.map((key) => key.toBase58());
        const args = (accounts == null ? void 0 : accounts.length) ? [accounts] : [];
        const unsafeRes = await this._rpcRequest("getRecentPrioritizationFees", args);
        const res = create(unsafeRes, GetRecentPrioritizationFeesRpcResult);
        if ("error" in res) {
          throw new SolanaJSONRPCError(res.error, "failed to get recent prioritization fees");
        }
        return res.result;
      }
      /**
       * Fetch a recent blockhash from the cluster
       * @return {Promise<{blockhash: Blockhash, feeCalculator: FeeCalculator}>}
       *
       * @deprecated Deprecated since RPC v1.8.0. Please use {@link getLatestBlockhash} instead.
       */
      async getRecentBlockhash(commitment) {
        try {
          const res = await this.getRecentBlockhashAndContext(commitment);
          return res.value;
        } catch (e) {
          throw new Error("failed to get recent blockhash: " + e);
        }
      }
      /**
       * Fetch the latest blockhash from the cluster
       * @return {Promise<BlockhashWithExpiryBlockHeight>}
       */
      async getLatestBlockhash(commitmentOrConfig) {
        try {
          const res = await this.getLatestBlockhashAndContext(commitmentOrConfig);
          return res.value;
        } catch (e) {
          throw new Error("failed to get recent blockhash: " + e);
        }
      }
      /**
       * Fetch the latest blockhash from the cluster
       * @return {Promise<BlockhashWithExpiryBlockHeight>}
       */
      async getLatestBlockhashAndContext(commitmentOrConfig) {
        const {
          commitment,
          config
        } = extractCommitmentFromConfig(commitmentOrConfig);
        const args = this._buildArgs([], commitment, void 0, config);
        const unsafeRes = await this._rpcRequest("getLatestBlockhash", args);
        const res = create(unsafeRes, GetLatestBlockhashRpcResult);
        if ("error" in res) {
          throw new SolanaJSONRPCError(res.error, "failed to get latest blockhash");
        }
        return res.result;
      }
      /**
       * Returns whether a blockhash is still valid or not
       */
      async isBlockhashValid(blockhash, rawConfig) {
        const {
          commitment,
          config
        } = extractCommitmentFromConfig(rawConfig);
        const args = this._buildArgs([blockhash], commitment, void 0, config);
        const unsafeRes = await this._rpcRequest("isBlockhashValid", args);
        const res = create(unsafeRes, IsBlockhashValidRpcResult);
        if ("error" in res) {
          throw new SolanaJSONRPCError(res.error, "failed to determine if the blockhash `" + blockhash + "`is valid");
        }
        return res.result;
      }
      /**
       * Fetch the node version
       */
      async getVersion() {
        const unsafeRes = await this._rpcRequest("getVersion", []);
        const res = create(unsafeRes, jsonRpcResult(VersionResult));
        if ("error" in res) {
          throw new SolanaJSONRPCError(res.error, "failed to get version");
        }
        return res.result;
      }
      /**
       * Fetch the genesis hash
       */
      async getGenesisHash() {
        const unsafeRes = await this._rpcRequest("getGenesisHash", []);
        const res = create(unsafeRes, jsonRpcResult(string()));
        if ("error" in res) {
          throw new SolanaJSONRPCError(res.error, "failed to get genesis hash");
        }
        return res.result;
      }
      /**
       * Fetch a processed block from the cluster.
       *
       * @deprecated Instead, call `getBlock` using a `GetVersionedBlockConfig` by
       * setting the `maxSupportedTransactionVersion` property.
       */
      /**
       * @deprecated Instead, call `getBlock` using a `GetVersionedBlockConfig` by
       * setting the `maxSupportedTransactionVersion` property.
       */
      // eslint-disable-next-line no-dupe-class-members
      /**
       * @deprecated Instead, call `getBlock` using a `GetVersionedBlockConfig` by
       * setting the `maxSupportedTransactionVersion` property.
       */
      // eslint-disable-next-line no-dupe-class-members
      /**
       * Fetch a processed block from the cluster.
       */
      // eslint-disable-next-line no-dupe-class-members
      // eslint-disable-next-line no-dupe-class-members
      // eslint-disable-next-line no-dupe-class-members
      /**
       * Fetch a processed block from the cluster.
       */
      // eslint-disable-next-line no-dupe-class-members
      async getBlock(slot, rawConfig) {
        const {
          commitment,
          config
        } = extractCommitmentFromConfig(rawConfig);
        const args = this._buildArgsAtLeastConfirmed([slot], commitment, void 0, config);
        const unsafeRes = await this._rpcRequest("getBlock", args);
        try {
          switch (config == null ? void 0 : config.transactionDetails) {
            case "accounts": {
              const res = create(unsafeRes, GetAccountsModeBlockRpcResult);
              if ("error" in res) {
                throw res.error;
              }
              return res.result;
            }
            case "none": {
              const res = create(unsafeRes, GetNoneModeBlockRpcResult);
              if ("error" in res) {
                throw res.error;
              }
              return res.result;
            }
            default: {
              const res = create(unsafeRes, GetBlockRpcResult);
              if ("error" in res) {
                throw res.error;
              }
              const {
                result
              } = res;
              return result ? {
                ...result,
                transactions: result.transactions.map(({
                  transaction,
                  meta,
                  version: version3
                }) => ({
                  meta,
                  transaction: {
                    ...transaction,
                    message: versionedMessageFromResponse(version3, transaction.message)
                  },
                  version: version3
                }))
              } : null;
            }
          }
        } catch (e) {
          throw new SolanaJSONRPCError(e, "failed to get confirmed block");
        }
      }
      /**
       * Fetch parsed transaction details for a confirmed or finalized block
       */
      // eslint-disable-next-line no-dupe-class-members
      // eslint-disable-next-line no-dupe-class-members
      // eslint-disable-next-line no-dupe-class-members
      async getParsedBlock(slot, rawConfig) {
        const {
          commitment,
          config
        } = extractCommitmentFromConfig(rawConfig);
        const args = this._buildArgsAtLeastConfirmed([slot], commitment, "jsonParsed", config);
        const unsafeRes = await this._rpcRequest("getBlock", args);
        try {
          switch (config == null ? void 0 : config.transactionDetails) {
            case "accounts": {
              const res = create(unsafeRes, GetParsedAccountsModeBlockRpcResult);
              if ("error" in res) {
                throw res.error;
              }
              return res.result;
            }
            case "none": {
              const res = create(unsafeRes, GetParsedNoneModeBlockRpcResult);
              if ("error" in res) {
                throw res.error;
              }
              return res.result;
            }
            default: {
              const res = create(unsafeRes, GetParsedBlockRpcResult);
              if ("error" in res) {
                throw res.error;
              }
              return res.result;
            }
          }
        } catch (e) {
          throw new SolanaJSONRPCError(e, "failed to get block");
        }
      }
      /*
       * Returns recent block production information from the current or previous epoch
       */
      async getBlockProduction(configOrCommitment) {
        let extra;
        let commitment;
        if (typeof configOrCommitment === "string") {
          commitment = configOrCommitment;
        } else if (configOrCommitment) {
          const {
            commitment: c,
            ...rest
          } = configOrCommitment;
          commitment = c;
          extra = rest;
        }
        const args = this._buildArgs([], commitment, "base64", extra);
        const unsafeRes = await this._rpcRequest("getBlockProduction", args);
        const res = create(unsafeRes, BlockProductionResponseStruct);
        if ("error" in res) {
          throw new SolanaJSONRPCError(res.error, "failed to get block production information");
        }
        return res.result;
      }
      /**
       * Fetch a confirmed or finalized transaction from the cluster.
       *
       * @deprecated Instead, call `getTransaction` using a
       * `GetVersionedTransactionConfig` by setting the
       * `maxSupportedTransactionVersion` property.
       */
      /**
       * Fetch a confirmed or finalized transaction from the cluster.
       */
      // eslint-disable-next-line no-dupe-class-members
      /**
       * Fetch a confirmed or finalized transaction from the cluster.
       */
      // eslint-disable-next-line no-dupe-class-members
      async getTransaction(signature2, rawConfig) {
        const {
          commitment,
          config
        } = extractCommitmentFromConfig(rawConfig);
        const args = this._buildArgsAtLeastConfirmed([signature2], commitment, void 0, config);
        const unsafeRes = await this._rpcRequest("getTransaction", args);
        const res = create(unsafeRes, GetTransactionRpcResult);
        if ("error" in res) {
          throw new SolanaJSONRPCError(res.error, "failed to get transaction");
        }
        const result = res.result;
        if (!result) return result;
        return {
          ...result,
          transaction: {
            ...result.transaction,
            message: versionedMessageFromResponse(result.version, result.transaction.message)
          }
        };
      }
      /**
       * Fetch parsed transaction details for a confirmed or finalized transaction
       */
      async getParsedTransaction(signature2, commitmentOrConfig) {
        const {
          commitment,
          config
        } = extractCommitmentFromConfig(commitmentOrConfig);
        const args = this._buildArgsAtLeastConfirmed([signature2], commitment, "jsonParsed", config);
        const unsafeRes = await this._rpcRequest("getTransaction", args);
        const res = create(unsafeRes, GetParsedTransactionRpcResult);
        if ("error" in res) {
          throw new SolanaJSONRPCError(res.error, "failed to get transaction");
        }
        return res.result;
      }
      /**
       * Fetch parsed transaction details for a batch of confirmed transactions
       */
      async getParsedTransactions(signatures, commitmentOrConfig) {
        const {
          commitment,
          config
        } = extractCommitmentFromConfig(commitmentOrConfig);
        const batch = signatures.map((signature2) => {
          const args = this._buildArgsAtLeastConfirmed([signature2], commitment, "jsonParsed", config);
          return {
            methodName: "getTransaction",
            args
          };
        });
        const unsafeRes = await this._rpcBatchRequest(batch);
        const res = unsafeRes.map((unsafeRes2) => {
          const res2 = create(unsafeRes2, GetParsedTransactionRpcResult);
          if ("error" in res2) {
            throw new SolanaJSONRPCError(res2.error, "failed to get transactions");
          }
          return res2.result;
        });
        return res;
      }
      /**
       * Fetch transaction details for a batch of confirmed transactions.
       * Similar to {@link getParsedTransactions} but returns a {@link TransactionResponse}.
       *
       * @deprecated Instead, call `getTransactions` using a
       * `GetVersionedTransactionConfig` by setting the
       * `maxSupportedTransactionVersion` property.
       */
      /**
       * Fetch transaction details for a batch of confirmed transactions.
       * Similar to {@link getParsedTransactions} but returns a {@link
       * VersionedTransactionResponse}.
       */
      // eslint-disable-next-line no-dupe-class-members
      /**
       * Fetch transaction details for a batch of confirmed transactions.
       * Similar to {@link getParsedTransactions} but returns a {@link
       * VersionedTransactionResponse}.
       */
      // eslint-disable-next-line no-dupe-class-members
      async getTransactions(signatures, commitmentOrConfig) {
        const {
          commitment,
          config
        } = extractCommitmentFromConfig(commitmentOrConfig);
        const batch = signatures.map((signature2) => {
          const args = this._buildArgsAtLeastConfirmed([signature2], commitment, void 0, config);
          return {
            methodName: "getTransaction",
            args
          };
        });
        const unsafeRes = await this._rpcBatchRequest(batch);
        const res = unsafeRes.map((unsafeRes2) => {
          const res2 = create(unsafeRes2, GetTransactionRpcResult);
          if ("error" in res2) {
            throw new SolanaJSONRPCError(res2.error, "failed to get transactions");
          }
          const result = res2.result;
          if (!result) return result;
          return {
            ...result,
            transaction: {
              ...result.transaction,
              message: versionedMessageFromResponse(result.version, result.transaction.message)
            }
          };
        });
        return res;
      }
      /**
       * Fetch a list of Transactions and transaction statuses from the cluster
       * for a confirmed block.
       *
       * @deprecated Deprecated since RPC v1.7.0. Please use {@link getBlock} instead.
       */
      async getConfirmedBlock(slot, commitment) {
        const args = this._buildArgsAtLeastConfirmed([slot], commitment);
        const unsafeRes = await this._rpcRequest("getBlock", args);
        const res = create(unsafeRes, GetConfirmedBlockRpcResult);
        if ("error" in res) {
          throw new SolanaJSONRPCError(res.error, "failed to get confirmed block");
        }
        const result = res.result;
        if (!result) {
          throw new Error("Confirmed block " + slot + " not found");
        }
        const block = {
          ...result,
          transactions: result.transactions.map(({
            transaction,
            meta
          }) => {
            const message = new Message(transaction.message);
            return {
              meta,
              transaction: {
                ...transaction,
                message
              }
            };
          })
        };
        return {
          ...block,
          transactions: block.transactions.map(({
            transaction,
            meta
          }) => {
            return {
              meta,
              transaction: Transaction.populate(transaction.message, transaction.signatures)
            };
          })
        };
      }
      /**
       * Fetch confirmed blocks between two slots
       */
      async getBlocks(startSlot, endSlot, commitment) {
        const args = this._buildArgsAtLeastConfirmed(endSlot !== void 0 ? [startSlot, endSlot] : [startSlot], commitment);
        const unsafeRes = await this._rpcRequest("getBlocks", args);
        const res = create(unsafeRes, jsonRpcResult(array(number())));
        if ("error" in res) {
          throw new SolanaJSONRPCError(res.error, "failed to get blocks");
        }
        return res.result;
      }
      /**
       * Fetch a list of Signatures from the cluster for a block, excluding rewards
       */
      async getBlockSignatures(slot, commitment) {
        const args = this._buildArgsAtLeastConfirmed([slot], commitment, void 0, {
          transactionDetails: "signatures",
          rewards: false
        });
        const unsafeRes = await this._rpcRequest("getBlock", args);
        const res = create(unsafeRes, GetBlockSignaturesRpcResult);
        if ("error" in res) {
          throw new SolanaJSONRPCError(res.error, "failed to get block");
        }
        const result = res.result;
        if (!result) {
          throw new Error("Block " + slot + " not found");
        }
        return result;
      }
      /**
       * Fetch a list of Signatures from the cluster for a confirmed block, excluding rewards
       *
       * @deprecated Deprecated since RPC v1.7.0. Please use {@link getBlockSignatures} instead.
       */
      async getConfirmedBlockSignatures(slot, commitment) {
        const args = this._buildArgsAtLeastConfirmed([slot], commitment, void 0, {
          transactionDetails: "signatures",
          rewards: false
        });
        const unsafeRes = await this._rpcRequest("getBlock", args);
        const res = create(unsafeRes, GetBlockSignaturesRpcResult);
        if ("error" in res) {
          throw new SolanaJSONRPCError(res.error, "failed to get confirmed block");
        }
        const result = res.result;
        if (!result) {
          throw new Error("Confirmed block " + slot + " not found");
        }
        return result;
      }
      /**
       * Fetch a transaction details for a confirmed transaction
       *
       * @deprecated Deprecated since RPC v1.7.0. Please use {@link getTransaction} instead.
       */
      async getConfirmedTransaction(signature2, commitment) {
        const args = this._buildArgsAtLeastConfirmed([signature2], commitment);
        const unsafeRes = await this._rpcRequest("getTransaction", args);
        const res = create(unsafeRes, GetTransactionRpcResult);
        if ("error" in res) {
          throw new SolanaJSONRPCError(res.error, "failed to get transaction");
        }
        const result = res.result;
        if (!result) return result;
        const message = new Message(result.transaction.message);
        const signatures = result.transaction.signatures;
        return {
          ...result,
          transaction: Transaction.populate(message, signatures)
        };
      }
      /**
       * Fetch parsed transaction details for a confirmed transaction
       *
       * @deprecated Deprecated since RPC v1.7.0. Please use {@link getParsedTransaction} instead.
       */
      async getParsedConfirmedTransaction(signature2, commitment) {
        const args = this._buildArgsAtLeastConfirmed([signature2], commitment, "jsonParsed");
        const unsafeRes = await this._rpcRequest("getTransaction", args);
        const res = create(unsafeRes, GetParsedTransactionRpcResult);
        if ("error" in res) {
          throw new SolanaJSONRPCError(res.error, "failed to get confirmed transaction");
        }
        return res.result;
      }
      /**
       * Fetch parsed transaction details for a batch of confirmed transactions
       *
       * @deprecated Deprecated since RPC v1.7.0. Please use {@link getParsedTransactions} instead.
       */
      async getParsedConfirmedTransactions(signatures, commitment) {
        const batch = signatures.map((signature2) => {
          const args = this._buildArgsAtLeastConfirmed([signature2], commitment, "jsonParsed");
          return {
            methodName: "getTransaction",
            args
          };
        });
        const unsafeRes = await this._rpcBatchRequest(batch);
        const res = unsafeRes.map((unsafeRes2) => {
          const res2 = create(unsafeRes2, GetParsedTransactionRpcResult);
          if ("error" in res2) {
            throw new SolanaJSONRPCError(res2.error, "failed to get confirmed transactions");
          }
          return res2.result;
        });
        return res;
      }
      /**
       * Fetch a list of all the confirmed signatures for transactions involving an address
       * within a specified slot range. Max range allowed is 10,000 slots.
       *
       * @deprecated Deprecated since RPC v1.3. Please use {@link getConfirmedSignaturesForAddress2} instead.
       *
       * @param address queried address
       * @param startSlot start slot, inclusive
       * @param endSlot end slot, inclusive
       */
      async getConfirmedSignaturesForAddress(address, startSlot, endSlot) {
        let options = {};
        let firstAvailableBlock = await this.getFirstAvailableBlock();
        while (!("until" in options)) {
          startSlot--;
          if (startSlot <= 0 || startSlot < firstAvailableBlock) {
            break;
          }
          try {
            const block = await this.getConfirmedBlockSignatures(startSlot, "finalized");
            if (block.signatures.length > 0) {
              options.until = block.signatures[block.signatures.length - 1].toString();
            }
          } catch (err2) {
            if (err2 instanceof Error && err2.message.includes("skipped")) {
              continue;
            } else {
              throw err2;
            }
          }
        }
        let highestConfirmedRoot = await this.getSlot("finalized");
        while (!("before" in options)) {
          endSlot++;
          if (endSlot > highestConfirmedRoot) {
            break;
          }
          try {
            const block = await this.getConfirmedBlockSignatures(endSlot);
            if (block.signatures.length > 0) {
              options.before = block.signatures[block.signatures.length - 1].toString();
            }
          } catch (err2) {
            if (err2 instanceof Error && err2.message.includes("skipped")) {
              continue;
            } else {
              throw err2;
            }
          }
        }
        const confirmedSignatureInfo = await this.getConfirmedSignaturesForAddress2(address, options);
        return confirmedSignatureInfo.map((info) => info.signature);
      }
      /**
       * Returns confirmed signatures for transactions involving an
       * address backwards in time from the provided signature or most recent confirmed block
       *
       * @deprecated Deprecated since RPC v1.7.0. Please use {@link getSignaturesForAddress} instead.
       */
      async getConfirmedSignaturesForAddress2(address, options, commitment) {
        const args = this._buildArgsAtLeastConfirmed([address.toBase58()], commitment, void 0, options);
        const unsafeRes = await this._rpcRequest("getConfirmedSignaturesForAddress2", args);
        const res = create(unsafeRes, GetConfirmedSignaturesForAddress2RpcResult);
        if ("error" in res) {
          throw new SolanaJSONRPCError(res.error, "failed to get confirmed signatures for address");
        }
        return res.result;
      }
      /**
       * Returns confirmed signatures for transactions involving an
       * address backwards in time from the provided signature or most recent confirmed block
       *
       *
       * @param address queried address
       * @param options
       */
      async getSignaturesForAddress(address, options, commitment) {
        const args = this._buildArgsAtLeastConfirmed([address.toBase58()], commitment, void 0, options);
        const unsafeRes = await this._rpcRequest("getSignaturesForAddress", args);
        const res = create(unsafeRes, GetSignaturesForAddressRpcResult);
        if ("error" in res) {
          throw new SolanaJSONRPCError(res.error, "failed to get signatures for address");
        }
        return res.result;
      }
      async getAddressLookupTable(accountKey, config) {
        const {
          context,
          value: accountInfo
        } = await this.getAccountInfoAndContext(accountKey, config);
        let value = null;
        if (accountInfo !== null) {
          value = new AddressLookupTableAccount({
            key: accountKey,
            state: AddressLookupTableAccount.deserialize(accountInfo.data)
          });
        }
        return {
          context,
          value
        };
      }
      /**
       * Fetch the contents of a Nonce account from the cluster, return with context
       */
      async getNonceAndContext(nonceAccount, commitmentOrConfig) {
        const {
          context,
          value: accountInfo
        } = await this.getAccountInfoAndContext(nonceAccount, commitmentOrConfig);
        let value = null;
        if (accountInfo !== null) {
          value = NonceAccount.fromAccountData(accountInfo.data);
        }
        return {
          context,
          value
        };
      }
      /**
       * Fetch the contents of a Nonce account from the cluster
       */
      async getNonce(nonceAccount, commitmentOrConfig) {
        return await this.getNonceAndContext(nonceAccount, commitmentOrConfig).then((x) => x.value).catch((e) => {
          throw new Error("failed to get nonce for account " + nonceAccount.toBase58() + ": " + e);
        });
      }
      /**
       * Request an allocation of lamports to the specified address
       *
       * ```typescript
       * import { Connection, PublicKey, LAMPORTS_PER_SOL } from "@solana/web3.js";
       *
       * (async () => {
       *   const connection = new Connection("https://api.testnet.solana.com", "confirmed");
       *   const myAddress = new PublicKey("2nr1bHFT86W9tGnyvmYW4vcHKsQB3sVQfnddasz4kExM");
       *   const signature = await connection.requestAirdrop(myAddress, LAMPORTS_PER_SOL);
       *   await connection.confirmTransaction(signature);
       * })();
       * ```
       */
      async requestAirdrop(to, lamports) {
        const unsafeRes = await this._rpcRequest("requestAirdrop", [to.toBase58(), lamports]);
        const res = create(unsafeRes, RequestAirdropRpcResult);
        if ("error" in res) {
          throw new SolanaJSONRPCError(res.error, `airdrop to ${to.toBase58()} failed`);
        }
        return res.result;
      }
      /**
       * @internal
       */
      async _blockhashWithExpiryBlockHeight(disableCache) {
        if (!disableCache) {
          while (this._pollingBlockhash) {
            await sleep(100);
          }
          const timeSinceFetch = Date.now() - this._blockhashInfo.lastFetch;
          const expired = timeSinceFetch >= BLOCKHASH_CACHE_TIMEOUT_MS;
          if (this._blockhashInfo.latestBlockhash !== null && !expired) {
            return this._blockhashInfo.latestBlockhash;
          }
        }
        return await this._pollNewBlockhash();
      }
      /**
       * @internal
       */
      async _pollNewBlockhash() {
        this._pollingBlockhash = true;
        try {
          const startTime = Date.now();
          const cachedLatestBlockhash = this._blockhashInfo.latestBlockhash;
          const cachedBlockhash = cachedLatestBlockhash ? cachedLatestBlockhash.blockhash : null;
          for (let i = 0; i < 50; i++) {
            const latestBlockhash = await this.getLatestBlockhash("finalized");
            if (cachedBlockhash !== latestBlockhash.blockhash) {
              this._blockhashInfo = {
                latestBlockhash,
                lastFetch: Date.now(),
                transactionSignatures: [],
                simulatedSignatures: []
              };
              return latestBlockhash;
            }
            await sleep(MS_PER_SLOT / 2);
          }
          throw new Error(`Unable to obtain a new blockhash after ${Date.now() - startTime}ms`);
        } finally {
          this._pollingBlockhash = false;
        }
      }
      /**
       * get the stake minimum delegation
       */
      async getStakeMinimumDelegation(config) {
        const {
          commitment,
          config: configArg
        } = extractCommitmentFromConfig(config);
        const args = this._buildArgs([], commitment, "base64", configArg);
        const unsafeRes = await this._rpcRequest("getStakeMinimumDelegation", args);
        const res = create(unsafeRes, jsonRpcResultAndContext(number()));
        if ("error" in res) {
          throw new SolanaJSONRPCError(res.error, `failed to get stake minimum delegation`);
        }
        return res.result;
      }
      /**
       * Simulate a transaction
       *
       * @deprecated Instead, call {@link simulateTransaction} with {@link
       * VersionedTransaction} and {@link SimulateTransactionConfig} parameters
       */
      /**
       * Simulate a transaction
       */
      // eslint-disable-next-line no-dupe-class-members
      /**
       * Simulate a transaction
       */
      // eslint-disable-next-line no-dupe-class-members
      async simulateTransaction(transactionOrMessage, configOrSigners, includeAccounts) {
        if ("message" in transactionOrMessage) {
          const versionedTx = transactionOrMessage;
          const wireTransaction2 = versionedTx.serialize();
          const encodedTransaction2 = import_buffer2.Buffer.from(wireTransaction2).toString("base64");
          if (Array.isArray(configOrSigners) || includeAccounts !== void 0) {
            throw new Error("Invalid arguments");
          }
          const config2 = configOrSigners || {};
          config2.encoding = "base64";
          if (!("commitment" in config2)) {
            config2.commitment = this.commitment;
          }
          if (configOrSigners && typeof configOrSigners === "object" && "innerInstructions" in configOrSigners) {
            config2.innerInstructions = configOrSigners.innerInstructions;
          }
          const args2 = [encodedTransaction2, config2];
          const unsafeRes2 = await this._rpcRequest("simulateTransaction", args2);
          const res2 = create(unsafeRes2, SimulatedTransactionResponseStruct);
          if ("error" in res2) {
            throw new Error("failed to simulate transaction: " + res2.error.message);
          }
          return res2.result;
        }
        let transaction;
        if (transactionOrMessage instanceof Transaction) {
          let originalTx = transactionOrMessage;
          transaction = new Transaction();
          transaction.feePayer = originalTx.feePayer;
          transaction.instructions = transactionOrMessage.instructions;
          transaction.nonceInfo = originalTx.nonceInfo;
          transaction.signatures = originalTx.signatures;
        } else {
          transaction = Transaction.populate(transactionOrMessage);
          transaction._message = transaction._json = void 0;
        }
        if (configOrSigners !== void 0 && !Array.isArray(configOrSigners)) {
          throw new Error("Invalid arguments");
        }
        const signers = configOrSigners;
        if (transaction.nonceInfo && signers) {
          transaction.sign(...signers);
        } else {
          let disableCache = this._disableBlockhashCaching;
          for (; ; ) {
            const latestBlockhash = await this._blockhashWithExpiryBlockHeight(disableCache);
            transaction.lastValidBlockHeight = latestBlockhash.lastValidBlockHeight;
            transaction.recentBlockhash = latestBlockhash.blockhash;
            if (!signers) break;
            transaction.sign(...signers);
            if (!transaction.signature) {
              throw new Error("!signature");
            }
            const signature2 = transaction.signature.toString("base64");
            if (!this._blockhashInfo.simulatedSignatures.includes(signature2) && !this._blockhashInfo.transactionSignatures.includes(signature2)) {
              this._blockhashInfo.simulatedSignatures.push(signature2);
              break;
            } else {
              disableCache = true;
            }
          }
        }
        const message = transaction._compile();
        const signData = message.serialize();
        const wireTransaction = transaction._serialize(signData);
        const encodedTransaction = wireTransaction.toString("base64");
        const config = {
          encoding: "base64",
          commitment: this.commitment
        };
        if (includeAccounts) {
          const addresses = (Array.isArray(includeAccounts) ? includeAccounts : message.nonProgramIds()).map((key) => key.toBase58());
          config["accounts"] = {
            encoding: "base64",
            addresses
          };
        }
        if (signers) {
          config.sigVerify = true;
        }
        if (configOrSigners && typeof configOrSigners === "object" && "innerInstructions" in configOrSigners) {
          config.innerInstructions = configOrSigners.innerInstructions;
        }
        const args = [encodedTransaction, config];
        const unsafeRes = await this._rpcRequest("simulateTransaction", args);
        const res = create(unsafeRes, SimulatedTransactionResponseStruct);
        if ("error" in res) {
          let logs;
          if ("data" in res.error) {
            logs = res.error.data.logs;
            if (logs && Array.isArray(logs)) {
              const traceIndent = "\n    ";
              const logTrace = traceIndent + logs.join(traceIndent);
              console.error(res.error.message, logTrace);
            }
          }
          throw new SendTransactionError({
            action: "simulate",
            signature: "",
            transactionMessage: res.error.message,
            logs
          });
        }
        return res.result;
      }
      /**
       * Sign and send a transaction
       *
       * @deprecated Instead, call {@link sendTransaction} with a {@link
       * VersionedTransaction}
       */
      /**
       * Send a signed transaction
       */
      // eslint-disable-next-line no-dupe-class-members
      /**
       * Sign and send a transaction
       */
      // eslint-disable-next-line no-dupe-class-members
      async sendTransaction(transaction, signersOrOptions, options) {
        if ("version" in transaction) {
          if (signersOrOptions && Array.isArray(signersOrOptions)) {
            throw new Error("Invalid arguments");
          }
          const wireTransaction2 = transaction.serialize();
          return await this.sendRawTransaction(wireTransaction2, signersOrOptions);
        }
        if (signersOrOptions === void 0 || !Array.isArray(signersOrOptions)) {
          throw new Error("Invalid arguments");
        }
        const signers = signersOrOptions;
        if (transaction.nonceInfo) {
          transaction.sign(...signers);
        } else {
          let disableCache = this._disableBlockhashCaching;
          for (; ; ) {
            const latestBlockhash = await this._blockhashWithExpiryBlockHeight(disableCache);
            transaction.lastValidBlockHeight = latestBlockhash.lastValidBlockHeight;
            transaction.recentBlockhash = latestBlockhash.blockhash;
            transaction.sign(...signers);
            if (!transaction.signature) {
              throw new Error("!signature");
            }
            const signature2 = transaction.signature.toString("base64");
            if (!this._blockhashInfo.transactionSignatures.includes(signature2)) {
              this._blockhashInfo.transactionSignatures.push(signature2);
              break;
            } else {
              disableCache = true;
            }
          }
        }
        const wireTransaction = transaction.serialize();
        return await this.sendRawTransaction(wireTransaction, options);
      }
      /**
       * Send a transaction that has already been signed and serialized into the
       * wire format
       */
      async sendRawTransaction(rawTransaction, options) {
        const encodedTransaction = toBuffer(rawTransaction).toString("base64");
        const result = await this.sendEncodedTransaction(encodedTransaction, options);
        return result;
      }
      /**
       * Send a transaction that has already been signed, serialized into the
       * wire format, and encoded as a base64 string
       */
      async sendEncodedTransaction(encodedTransaction, options) {
        const config = {
          encoding: "base64"
        };
        const skipPreflight = options && options.skipPreflight;
        const preflightCommitment = skipPreflight === true ? "processed" : options && options.preflightCommitment || this.commitment;
        if (options && options.maxRetries != null) {
          config.maxRetries = options.maxRetries;
        }
        if (options && options.minContextSlot != null) {
          config.minContextSlot = options.minContextSlot;
        }
        if (skipPreflight) {
          config.skipPreflight = skipPreflight;
        }
        if (preflightCommitment) {
          config.preflightCommitment = preflightCommitment;
        }
        const args = [encodedTransaction, config];
        const unsafeRes = await this._rpcRequest("sendTransaction", args);
        const res = create(unsafeRes, SendTransactionRpcResult);
        if ("error" in res) {
          let logs = void 0;
          if ("data" in res.error) {
            logs = res.error.data.logs;
          }
          throw new SendTransactionError({
            action: skipPreflight ? "send" : "simulate",
            signature: "",
            transactionMessage: res.error.message,
            logs
          });
        }
        return res.result;
      }
      /**
       * @internal
       */
      _wsOnOpen() {
        this._rpcWebSocketConnected = true;
        this._rpcWebSocketHeartbeat = setInterval(() => {
          (async () => {
            try {
              await this._rpcWebSocket.notify("ping");
            } catch {
            }
          })();
        }, 5e3);
        this._updateSubscriptions();
      }
      /**
       * @internal
       */
      _wsOnError(err2) {
        this._rpcWebSocketConnected = false;
        console.error("ws error:", err2.message);
      }
      /**
       * @internal
       */
      _wsOnClose(code2) {
        this._rpcWebSocketConnected = false;
        this._rpcWebSocketGeneration = (this._rpcWebSocketGeneration + 1) % Number.MAX_SAFE_INTEGER;
        if (this._rpcWebSocketIdleTimeout) {
          clearTimeout(this._rpcWebSocketIdleTimeout);
          this._rpcWebSocketIdleTimeout = null;
        }
        if (this._rpcWebSocketHeartbeat) {
          clearInterval(this._rpcWebSocketHeartbeat);
          this._rpcWebSocketHeartbeat = null;
        }
        if (code2 === 1e3) {
          this._updateSubscriptions();
          return;
        }
        this._subscriptionCallbacksByServerSubscriptionId = {};
        Object.entries(this._subscriptionsByHash).forEach(([hash3, subscription]) => {
          this._setSubscription(hash3, {
            ...subscription,
            state: "pending"
          });
        });
      }
      /**
       * @internal
       */
      _setSubscription(hash3, nextSubscription) {
        var _a2;
        const prevState = (_a2 = this._subscriptionsByHash[hash3]) == null ? void 0 : _a2.state;
        this._subscriptionsByHash[hash3] = nextSubscription;
        if (prevState !== nextSubscription.state) {
          const stateChangeCallbacks = this._subscriptionStateChangeCallbacksByHash[hash3];
          if (stateChangeCallbacks) {
            stateChangeCallbacks.forEach((cb) => {
              try {
                cb(nextSubscription.state);
              } catch {
              }
            });
          }
        }
      }
      /**
       * @internal
       */
      _onSubscriptionStateChange(clientSubscriptionId, callback) {
        var _a2;
        const hash3 = this._subscriptionHashByClientSubscriptionId[clientSubscriptionId];
        if (hash3 == null) {
          return () => {
          };
        }
        const stateChangeCallbacks = (_a2 = this._subscriptionStateChangeCallbacksByHash)[hash3] || (_a2[hash3] = /* @__PURE__ */ new Set());
        stateChangeCallbacks.add(callback);
        return () => {
          stateChangeCallbacks.delete(callback);
          if (stateChangeCallbacks.size === 0) {
            delete this._subscriptionStateChangeCallbacksByHash[hash3];
          }
        };
      }
      /**
       * @internal
       */
      async _updateSubscriptions() {
        if (Object.keys(this._subscriptionsByHash).length === 0) {
          if (this._rpcWebSocketConnected) {
            this._rpcWebSocketConnected = false;
            this._rpcWebSocketIdleTimeout = setTimeout(() => {
              this._rpcWebSocketIdleTimeout = null;
              try {
                this._rpcWebSocket.close();
              } catch (err2) {
                if (err2 instanceof Error) {
                  console.log(`Error when closing socket connection: ${err2.message}`);
                }
              }
            }, 500);
          }
          return;
        }
        if (this._rpcWebSocketIdleTimeout !== null) {
          clearTimeout(this._rpcWebSocketIdleTimeout);
          this._rpcWebSocketIdleTimeout = null;
          this._rpcWebSocketConnected = true;
        }
        if (!this._rpcWebSocketConnected) {
          this._rpcWebSocket.connect();
          return;
        }
        const activeWebSocketGeneration = this._rpcWebSocketGeneration;
        const isCurrentConnectionStillActive = () => {
          return activeWebSocketGeneration === this._rpcWebSocketGeneration;
        };
        await Promise.all(
          // Don't be tempted to change this to `Object.entries`. We call
          // `_updateSubscriptions` recursively when processing the state,
          // so it's important that we look up the *current* version of
          // each subscription, every time we process a hash.
          Object.keys(this._subscriptionsByHash).map(async (hash3) => {
            const subscription = this._subscriptionsByHash[hash3];
            if (subscription === void 0) {
              return;
            }
            switch (subscription.state) {
              case "pending":
              case "unsubscribed":
                if (subscription.callbacks.size === 0) {
                  delete this._subscriptionsByHash[hash3];
                  if (subscription.state === "unsubscribed") {
                    delete this._subscriptionCallbacksByServerSubscriptionId[subscription.serverSubscriptionId];
                  }
                  await this._updateSubscriptions();
                  return;
                }
                await (async () => {
                  const {
                    args,
                    method
                  } = subscription;
                  try {
                    this._setSubscription(hash3, {
                      ...subscription,
                      state: "subscribing"
                    });
                    const serverSubscriptionId = await this._rpcWebSocket.call(method, args);
                    this._setSubscription(hash3, {
                      ...subscription,
                      serverSubscriptionId,
                      state: "subscribed"
                    });
                    this._subscriptionCallbacksByServerSubscriptionId[serverSubscriptionId] = subscription.callbacks;
                    await this._updateSubscriptions();
                  } catch (e) {
                    console.error(`Received ${e instanceof Error ? "" : "JSON-RPC "}error calling \`${method}\``, {
                      args,
                      error: e
                    });
                    if (!isCurrentConnectionStillActive()) {
                      return;
                    }
                    this._setSubscription(hash3, {
                      ...subscription,
                      state: "pending"
                    });
                    await this._updateSubscriptions();
                  }
                })();
                break;
              case "subscribed":
                if (subscription.callbacks.size === 0) {
                  await (async () => {
                    const {
                      serverSubscriptionId,
                      unsubscribeMethod
                    } = subscription;
                    if (this._subscriptionsAutoDisposedByRpc.has(serverSubscriptionId)) {
                      this._subscriptionsAutoDisposedByRpc.delete(serverSubscriptionId);
                    } else {
                      this._setSubscription(hash3, {
                        ...subscription,
                        state: "unsubscribing"
                      });
                      this._setSubscription(hash3, {
                        ...subscription,
                        state: "unsubscribing"
                      });
                      try {
                        await this._rpcWebSocket.call(unsubscribeMethod, [serverSubscriptionId]);
                      } catch (e) {
                        if (e instanceof Error) {
                          console.error(`${unsubscribeMethod} error:`, e.message);
                        }
                        if (!isCurrentConnectionStillActive()) {
                          return;
                        }
                        this._setSubscription(hash3, {
                          ...subscription,
                          state: "subscribed"
                        });
                        await this._updateSubscriptions();
                        return;
                      }
                    }
                    this._setSubscription(hash3, {
                      ...subscription,
                      state: "unsubscribed"
                    });
                    await this._updateSubscriptions();
                  })();
                }
                break;
            }
          })
        );
      }
      /**
       * @internal
       */
      _handleServerNotification(serverSubscriptionId, callbackArgs) {
        const callbacks = this._subscriptionCallbacksByServerSubscriptionId[serverSubscriptionId];
        if (callbacks === void 0) {
          return;
        }
        callbacks.forEach((cb) => {
          try {
            cb(
              ...callbackArgs
            );
          } catch (e) {
            console.error(e);
          }
        });
      }
      /**
       * @internal
       */
      _wsOnAccountNotification(notification) {
        const {
          result,
          subscription
        } = create(notification, AccountNotificationResult);
        this._handleServerNotification(subscription, [result.value, result.context]);
      }
      /**
       * @internal
       */
      _makeSubscription(subscriptionConfig, args) {
        const clientSubscriptionId = this._nextClientSubscriptionId++;
        const hash3 = fastStableStringify([subscriptionConfig.method, args]);
        const existingSubscription = this._subscriptionsByHash[hash3];
        if (existingSubscription === void 0) {
          this._subscriptionsByHash[hash3] = {
            ...subscriptionConfig,
            args,
            callbacks: /* @__PURE__ */ new Set([subscriptionConfig.callback]),
            state: "pending"
          };
        } else {
          existingSubscription.callbacks.add(subscriptionConfig.callback);
        }
        this._subscriptionHashByClientSubscriptionId[clientSubscriptionId] = hash3;
        this._subscriptionDisposeFunctionsByClientSubscriptionId[clientSubscriptionId] = async () => {
          delete this._subscriptionDisposeFunctionsByClientSubscriptionId[clientSubscriptionId];
          delete this._subscriptionHashByClientSubscriptionId[clientSubscriptionId];
          const subscription = this._subscriptionsByHash[hash3];
          assert2(subscription !== void 0, `Could not find a \`Subscription\` when tearing down client subscription #${clientSubscriptionId}`);
          subscription.callbacks.delete(subscriptionConfig.callback);
          await this._updateSubscriptions();
        };
        this._updateSubscriptions();
        return clientSubscriptionId;
      }
      /**
       * Register a callback to be invoked whenever the specified account changes
       *
       * @param publicKey Public key of the account to monitor
       * @param callback Function to invoke whenever the account is changed
       * @param config
       * @return subscription id
       */
      /** @deprecated Instead, pass in an {@link AccountSubscriptionConfig} */
      // eslint-disable-next-line no-dupe-class-members
      // eslint-disable-next-line no-dupe-class-members
      onAccountChange(publicKey5, callback, commitmentOrConfig) {
        const {
          commitment,
          config
        } = extractCommitmentFromConfig(commitmentOrConfig);
        const args = this._buildArgs(
          [publicKey5.toBase58()],
          commitment || this._commitment || "finalized",
          // Apply connection/server default.
          "base64",
          config
        );
        return this._makeSubscription({
          callback,
          method: "accountSubscribe",
          unsubscribeMethod: "accountUnsubscribe"
        }, args);
      }
      /**
       * Deregister an account notification callback
       *
       * @param clientSubscriptionId client subscription id to deregister
       */
      async removeAccountChangeListener(clientSubscriptionId) {
        await this._unsubscribeClientSubscription(clientSubscriptionId, "account change");
      }
      /**
       * @internal
       */
      _wsOnProgramAccountNotification(notification) {
        const {
          result,
          subscription
        } = create(notification, ProgramAccountNotificationResult);
        this._handleServerNotification(subscription, [{
          accountId: result.value.pubkey,
          accountInfo: result.value.account
        }, result.context]);
      }
      /**
       * Register a callback to be invoked whenever accounts owned by the
       * specified program change
       *
       * @param programId Public key of the program to monitor
       * @param callback Function to invoke whenever the account is changed
       * @param config
       * @return subscription id
       */
      /** @deprecated Instead, pass in a {@link ProgramAccountSubscriptionConfig} */
      // eslint-disable-next-line no-dupe-class-members
      // eslint-disable-next-line no-dupe-class-members
      onProgramAccountChange(programId, callback, commitmentOrConfig, maybeFilters) {
        const {
          commitment,
          config
        } = extractCommitmentFromConfig(commitmentOrConfig);
        const args = this._buildArgs(
          [programId.toBase58()],
          commitment || this._commitment || "finalized",
          // Apply connection/server default.
          "base64",
          config ? config : maybeFilters ? {
            filters: applyDefaultMemcmpEncodingToFilters(maybeFilters)
          } : void 0
          /* extra */
        );
        return this._makeSubscription({
          callback,
          method: "programSubscribe",
          unsubscribeMethod: "programUnsubscribe"
        }, args);
      }
      /**
       * Deregister an account notification callback
       *
       * @param clientSubscriptionId client subscription id to deregister
       */
      async removeProgramAccountChangeListener(clientSubscriptionId) {
        await this._unsubscribeClientSubscription(clientSubscriptionId, "program account change");
      }
      /**
       * Registers a callback to be invoked whenever logs are emitted.
       */
      onLogs(filter, callback, commitment) {
        const args = this._buildArgs(
          [typeof filter === "object" ? {
            mentions: [filter.toString()]
          } : filter],
          commitment || this._commitment || "finalized"
          // Apply connection/server default.
        );
        return this._makeSubscription({
          callback,
          method: "logsSubscribe",
          unsubscribeMethod: "logsUnsubscribe"
        }, args);
      }
      /**
       * Deregister a logs callback.
       *
       * @param clientSubscriptionId client subscription id to deregister.
       */
      async removeOnLogsListener(clientSubscriptionId) {
        await this._unsubscribeClientSubscription(clientSubscriptionId, "logs");
      }
      /**
       * @internal
       */
      _wsOnLogsNotification(notification) {
        const {
          result,
          subscription
        } = create(notification, LogsNotificationResult);
        this._handleServerNotification(subscription, [result.value, result.context]);
      }
      /**
       * @internal
       */
      _wsOnSlotNotification(notification) {
        const {
          result,
          subscription
        } = create(notification, SlotNotificationResult);
        this._handleServerNotification(subscription, [result]);
      }
      /**
       * Register a callback to be invoked upon slot changes
       *
       * @param callback Function to invoke whenever the slot changes
       * @return subscription id
       */
      onSlotChange(callback) {
        return this._makeSubscription(
          {
            callback,
            method: "slotSubscribe",
            unsubscribeMethod: "slotUnsubscribe"
          },
          []
          /* args */
        );
      }
      /**
       * Deregister a slot notification callback
       *
       * @param clientSubscriptionId client subscription id to deregister
       */
      async removeSlotChangeListener(clientSubscriptionId) {
        await this._unsubscribeClientSubscription(clientSubscriptionId, "slot change");
      }
      /**
       * @internal
       */
      _wsOnSlotUpdatesNotification(notification) {
        const {
          result,
          subscription
        } = create(notification, SlotUpdateNotificationResult);
        this._handleServerNotification(subscription, [result]);
      }
      /**
       * Register a callback to be invoked upon slot updates. {@link SlotUpdate}'s
       * may be useful to track live progress of a cluster.
       *
       * @param callback Function to invoke whenever the slot updates
       * @return subscription id
       */
      onSlotUpdate(callback) {
        return this._makeSubscription(
          {
            callback,
            method: "slotsUpdatesSubscribe",
            unsubscribeMethod: "slotsUpdatesUnsubscribe"
          },
          []
          /* args */
        );
      }
      /**
       * Deregister a slot update notification callback
       *
       * @param clientSubscriptionId client subscription id to deregister
       */
      async removeSlotUpdateListener(clientSubscriptionId) {
        await this._unsubscribeClientSubscription(clientSubscriptionId, "slot update");
      }
      /**
       * @internal
       */
      async _unsubscribeClientSubscription(clientSubscriptionId, subscriptionName) {
        const dispose = this._subscriptionDisposeFunctionsByClientSubscriptionId[clientSubscriptionId];
        if (dispose) {
          await dispose();
        } else {
          console.warn(`Ignored unsubscribe request because an active subscription with id \`${clientSubscriptionId}\` for '${subscriptionName}' events could not be found.`);
        }
      }
      _buildArgs(args, override, encoding, extra) {
        const commitment = override || this._commitment;
        if (commitment || encoding || extra) {
          let options = {};
          if (encoding) {
            options.encoding = encoding;
          }
          if (commitment) {
            options.commitment = commitment;
          }
          if (extra) {
            options = Object.assign(options, extra);
          }
          args.push(options);
        }
        return args;
      }
      /**
       * @internal
       */
      _buildArgsAtLeastConfirmed(args, override, encoding, extra) {
        const commitment = override || this._commitment;
        if (commitment && !["confirmed", "finalized"].includes(commitment)) {
          throw new Error("Using Connection with default commitment: `" + this._commitment + "`, but method requires at least `confirmed`");
        }
        return this._buildArgs(args, override, encoding, extra);
      }
      /**
       * @internal
       */
      _wsOnSignatureNotification(notification) {
        const {
          result,
          subscription
        } = create(notification, SignatureNotificationResult);
        if (result.value !== "receivedSignature") {
          this._subscriptionsAutoDisposedByRpc.add(subscription);
        }
        this._handleServerNotification(subscription, result.value === "receivedSignature" ? [{
          type: "received"
        }, result.context] : [{
          type: "status",
          result: result.value
        }, result.context]);
      }
      /**
       * Register a callback to be invoked upon signature updates
       *
       * @param signature Transaction signature string in base 58
       * @param callback Function to invoke on signature notifications
       * @param commitment Specify the commitment level signature must reach before notification
       * @return subscription id
       */
      onSignature(signature2, callback, commitment) {
        const args = this._buildArgs(
          [signature2],
          commitment || this._commitment || "finalized"
          // Apply connection/server default.
        );
        const clientSubscriptionId = this._makeSubscription({
          callback: (notification, context) => {
            if (notification.type === "status") {
              callback(notification.result, context);
              try {
                this.removeSignatureListener(clientSubscriptionId);
              } catch (_err) {
              }
            }
          },
          method: "signatureSubscribe",
          unsubscribeMethod: "signatureUnsubscribe"
        }, args);
        return clientSubscriptionId;
      }
      /**
       * Register a callback to be invoked when a transaction is
       * received and/or processed.
       *
       * @param signature Transaction signature string in base 58
       * @param callback Function to invoke on signature notifications
       * @param options Enable received notifications and set the commitment
       *   level that signature must reach before notification
       * @return subscription id
       */
      onSignatureWithOptions(signature2, callback, options) {
        const {
          commitment,
          ...extra
        } = {
          ...options,
          commitment: options && options.commitment || this._commitment || "finalized"
          // Apply connection/server default.
        };
        const args = this._buildArgs([signature2], commitment, void 0, extra);
        const clientSubscriptionId = this._makeSubscription({
          callback: (notification, context) => {
            callback(notification, context);
            try {
              this.removeSignatureListener(clientSubscriptionId);
            } catch (_err) {
            }
          },
          method: "signatureSubscribe",
          unsubscribeMethod: "signatureUnsubscribe"
        }, args);
        return clientSubscriptionId;
      }
      /**
       * Deregister a signature notification callback
       *
       * @param clientSubscriptionId client subscription id to deregister
       */
      async removeSignatureListener(clientSubscriptionId) {
        await this._unsubscribeClientSubscription(clientSubscriptionId, "signature result");
      }
      /**
       * @internal
       */
      _wsOnRootNotification(notification) {
        const {
          result,
          subscription
        } = create(notification, RootNotificationResult);
        this._handleServerNotification(subscription, [result]);
      }
      /**
       * Register a callback to be invoked upon root changes
       *
       * @param callback Function to invoke whenever the root changes
       * @return subscription id
       */
      onRootChange(callback) {
        return this._makeSubscription(
          {
            callback,
            method: "rootSubscribe",
            unsubscribeMethod: "rootUnsubscribe"
          },
          []
          /* args */
        );
      }
      /**
       * Deregister a root notification callback
       *
       * @param clientSubscriptionId client subscription id to deregister
       */
      async removeRootChangeListener(clientSubscriptionId) {
        await this._unsubscribeClientSubscription(clientSubscriptionId, "root change");
      }
    };
    Keypair = class _Keypair {
      /**
       * Create a new keypair instance.
       * Generate random keypair if no {@link Ed25519Keypair} is provided.
       *
       * @param {Ed25519Keypair} keypair ed25519 keypair
       */
      constructor(keypair) {
        this._keypair = void 0;
        this._keypair = keypair ?? generateKeypair();
      }
      /**
       * Generate a new random keypair
       *
       * @returns {Keypair} Keypair
       */
      static generate() {
        return new _Keypair(generateKeypair());
      }
      /**
       * Create a keypair from a raw secret key byte array.
       *
       * This method should only be used to recreate a keypair from a previously
       * generated secret key. Generating keypairs from a random seed should be done
       * with the {@link Keypair.fromSeed} method.
       *
       * @throws error if the provided secret key is invalid and validation is not skipped.
       *
       * @param secretKey secret key byte array
       * @param options skip secret key validation
       *
       * @returns {Keypair} Keypair
       */
      static fromSecretKey(secretKey, options) {
        if (secretKey.byteLength !== 64) {
          throw new Error("bad secret key size");
        }
        const publicKey5 = secretKey.slice(32, 64);
        if (!options || !options.skipValidation) {
          const privateScalar = secretKey.slice(0, 32);
          const computedPublicKey = getPublicKey(privateScalar);
          for (let ii = 0; ii < 32; ii++) {
            if (publicKey5[ii] !== computedPublicKey[ii]) {
              throw new Error("provided secretKey is invalid");
            }
          }
        }
        return new _Keypair({
          publicKey: publicKey5,
          secretKey
        });
      }
      /**
       * Generate a keypair from a 32 byte seed.
       *
       * @param seed seed byte array
       *
       * @returns {Keypair} Keypair
       */
      static fromSeed(seed2) {
        const publicKey5 = getPublicKey(seed2);
        const secretKey = new Uint8Array(64);
        secretKey.set(seed2);
        secretKey.set(publicKey5, 32);
        return new _Keypair({
          publicKey: publicKey5,
          secretKey
        });
      }
      /**
       * The public key for this keypair
       *
       * @returns {PublicKey} PublicKey
       */
      get publicKey() {
        return new PublicKey(this._keypair.publicKey);
      }
      /**
       * The raw secret key for this keypair
       * @returns {Uint8Array} Secret key in an array of Uint8 bytes
       */
      get secretKey() {
        return new Uint8Array(this._keypair.secretKey);
      }
    };
    LOOKUP_TABLE_INSTRUCTION_LAYOUTS = Object.freeze({
      CreateLookupTable: {
        index: 0,
        layout: BufferLayout.struct([BufferLayout.u32("instruction"), u64("recentSlot"), BufferLayout.u8("bumpSeed")])
      },
      FreezeLookupTable: {
        index: 1,
        layout: BufferLayout.struct([BufferLayout.u32("instruction")])
      },
      ExtendLookupTable: {
        index: 2,
        layout: BufferLayout.struct([BufferLayout.u32("instruction"), u64(), BufferLayout.seq(publicKey(), BufferLayout.offset(BufferLayout.u32(), -8), "addresses")])
      },
      DeactivateLookupTable: {
        index: 3,
        layout: BufferLayout.struct([BufferLayout.u32("instruction")])
      },
      CloseLookupTable: {
        index: 4,
        layout: BufferLayout.struct([BufferLayout.u32("instruction")])
      }
    });
    AddressLookupTableInstruction = class {
      /**
       * @internal
       */
      constructor() {
      }
      static decodeInstructionType(instruction) {
        this.checkProgramId(instruction.programId);
        const instructionTypeLayout = BufferLayout.u32("instruction");
        const index4 = instructionTypeLayout.decode(instruction.data);
        let type3;
        for (const [layoutType, layout] of Object.entries(LOOKUP_TABLE_INSTRUCTION_LAYOUTS)) {
          if (layout.index == index4) {
            type3 = layoutType;
            break;
          }
        }
        if (!type3) {
          throw new Error("Invalid Instruction. Should be a LookupTable Instruction");
        }
        return type3;
      }
      static decodeCreateLookupTable(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeysLength(instruction.keys, 4);
        const {
          recentSlot
        } = decodeData$1(LOOKUP_TABLE_INSTRUCTION_LAYOUTS.CreateLookupTable, instruction.data);
        return {
          authority: instruction.keys[1].pubkey,
          payer: instruction.keys[2].pubkey,
          recentSlot: Number(recentSlot)
        };
      }
      static decodeExtendLookupTable(instruction) {
        this.checkProgramId(instruction.programId);
        if (instruction.keys.length < 2) {
          throw new Error(`invalid instruction; found ${instruction.keys.length} keys, expected at least 2`);
        }
        const {
          addresses
        } = decodeData$1(LOOKUP_TABLE_INSTRUCTION_LAYOUTS.ExtendLookupTable, instruction.data);
        return {
          lookupTable: instruction.keys[0].pubkey,
          authority: instruction.keys[1].pubkey,
          payer: instruction.keys.length > 2 ? instruction.keys[2].pubkey : void 0,
          addresses: addresses.map((buffer3) => new PublicKey(buffer3))
        };
      }
      static decodeCloseLookupTable(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeysLength(instruction.keys, 3);
        return {
          lookupTable: instruction.keys[0].pubkey,
          authority: instruction.keys[1].pubkey,
          recipient: instruction.keys[2].pubkey
        };
      }
      static decodeFreezeLookupTable(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeysLength(instruction.keys, 2);
        return {
          lookupTable: instruction.keys[0].pubkey,
          authority: instruction.keys[1].pubkey
        };
      }
      static decodeDeactivateLookupTable(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeysLength(instruction.keys, 2);
        return {
          lookupTable: instruction.keys[0].pubkey,
          authority: instruction.keys[1].pubkey
        };
      }
      /**
       * @internal
       */
      static checkProgramId(programId) {
        if (!programId.equals(AddressLookupTableProgram.programId)) {
          throw new Error("invalid instruction; programId is not AddressLookupTable Program");
        }
      }
      /**
       * @internal
       */
      static checkKeysLength(keys, expectedLength) {
        if (keys.length < expectedLength) {
          throw new Error(`invalid instruction; found ${keys.length} keys, expected at least ${expectedLength}`);
        }
      }
    };
    AddressLookupTableProgram = class {
      /**
       * @internal
       */
      constructor() {
      }
      static createLookupTable(params) {
        const [lookupTableAddress, bumpSeed] = PublicKey.findProgramAddressSync([params.authority.toBuffer(), getU64Encoder().encode(params.recentSlot)], this.programId);
        const type3 = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.CreateLookupTable;
        const data = encodeData2(type3, {
          recentSlot: BigInt(params.recentSlot),
          bumpSeed
        });
        const keys = [{
          pubkey: lookupTableAddress,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: params.authority,
          isSigner: true,
          isWritable: false
        }, {
          pubkey: params.payer,
          isSigner: true,
          isWritable: true
        }, {
          pubkey: SystemProgram.programId,
          isSigner: false,
          isWritable: false
        }];
        return [new TransactionInstruction({
          programId: this.programId,
          keys,
          data
        }), lookupTableAddress];
      }
      static freezeLookupTable(params) {
        const type3 = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.FreezeLookupTable;
        const data = encodeData2(type3);
        const keys = [{
          pubkey: params.lookupTable,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: params.authority,
          isSigner: true,
          isWritable: false
        }];
        return new TransactionInstruction({
          programId: this.programId,
          keys,
          data
        });
      }
      static extendLookupTable(params) {
        const type3 = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.ExtendLookupTable;
        const data = encodeData2(type3, {
          addresses: params.addresses.map((addr) => addr.toBytes())
        });
        const keys = [{
          pubkey: params.lookupTable,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: params.authority,
          isSigner: true,
          isWritable: false
        }];
        if (params.payer) {
          keys.push({
            pubkey: params.payer,
            isSigner: true,
            isWritable: true
          }, {
            pubkey: SystemProgram.programId,
            isSigner: false,
            isWritable: false
          });
        }
        return new TransactionInstruction({
          programId: this.programId,
          keys,
          data
        });
      }
      static deactivateLookupTable(params) {
        const type3 = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.DeactivateLookupTable;
        const data = encodeData2(type3);
        const keys = [{
          pubkey: params.lookupTable,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: params.authority,
          isSigner: true,
          isWritable: false
        }];
        return new TransactionInstruction({
          programId: this.programId,
          keys,
          data
        });
      }
      static closeLookupTable(params) {
        const type3 = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.CloseLookupTable;
        const data = encodeData2(type3);
        const keys = [{
          pubkey: params.lookupTable,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: params.authority,
          isSigner: true,
          isWritable: false
        }, {
          pubkey: params.recipient,
          isSigner: false,
          isWritable: true
        }];
        return new TransactionInstruction({
          programId: this.programId,
          keys,
          data
        });
      }
    };
    AddressLookupTableProgram.programId = new PublicKey("AddressLookupTab1e1111111111111111111111111");
    ComputeBudgetInstruction = class {
      /**
       * @internal
       */
      constructor() {
      }
      /**
       * Decode a compute budget instruction and retrieve the instruction type.
       */
      static decodeInstructionType(instruction) {
        this.checkProgramId(instruction.programId);
        const instructionTypeLayout = BufferLayout.u8("instruction");
        const typeIndex = instructionTypeLayout.decode(instruction.data);
        let type3;
        for (const [ixType, layout] of Object.entries(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS)) {
          if (layout.index == typeIndex) {
            type3 = ixType;
            break;
          }
        }
        if (!type3) {
          throw new Error("Instruction type incorrect; not a ComputeBudgetInstruction");
        }
        return type3;
      }
      /**
       * Decode request units compute budget instruction and retrieve the instruction params.
       */
      static decodeRequestUnits(instruction) {
        this.checkProgramId(instruction.programId);
        const {
          units,
          additionalFee
        } = decodeData$1(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestUnits, instruction.data);
        return {
          units,
          additionalFee
        };
      }
      /**
       * Decode request heap frame compute budget instruction and retrieve the instruction params.
       */
      static decodeRequestHeapFrame(instruction) {
        this.checkProgramId(instruction.programId);
        const {
          bytes: bytes3
        } = decodeData$1(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestHeapFrame, instruction.data);
        return {
          bytes: bytes3
        };
      }
      /**
       * Decode set compute unit limit compute budget instruction and retrieve the instruction params.
       */
      static decodeSetComputeUnitLimit(instruction) {
        this.checkProgramId(instruction.programId);
        const {
          units
        } = decodeData$1(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitLimit, instruction.data);
        return {
          units
        };
      }
      /**
       * Decode set compute unit price compute budget instruction and retrieve the instruction params.
       */
      static decodeSetComputeUnitPrice(instruction) {
        this.checkProgramId(instruction.programId);
        const {
          microLamports
        } = decodeData$1(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitPrice, instruction.data);
        return {
          microLamports
        };
      }
      /**
       * @internal
       */
      static checkProgramId(programId) {
        if (!programId.equals(ComputeBudgetProgram.programId)) {
          throw new Error("invalid instruction; programId is not ComputeBudgetProgram");
        }
      }
    };
    COMPUTE_BUDGET_INSTRUCTION_LAYOUTS = Object.freeze({
      RequestUnits: {
        index: 0,
        layout: BufferLayout.struct([BufferLayout.u8("instruction"), BufferLayout.u32("units"), BufferLayout.u32("additionalFee")])
      },
      RequestHeapFrame: {
        index: 1,
        layout: BufferLayout.struct([BufferLayout.u8("instruction"), BufferLayout.u32("bytes")])
      },
      SetComputeUnitLimit: {
        index: 2,
        layout: BufferLayout.struct([BufferLayout.u8("instruction"), BufferLayout.u32("units")])
      },
      SetComputeUnitPrice: {
        index: 3,
        layout: BufferLayout.struct([BufferLayout.u8("instruction"), u64("microLamports")])
      }
    });
    ComputeBudgetProgram = class {
      /**
       * @internal
       */
      constructor() {
      }
      /**
       * Public key that identifies the Compute Budget program
       */
      /**
       * @deprecated Instead, call {@link setComputeUnitLimit} and/or {@link setComputeUnitPrice}
       */
      static requestUnits(params) {
        const type3 = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestUnits;
        const data = encodeData2(type3, params);
        return new TransactionInstruction({
          keys: [],
          programId: this.programId,
          data
        });
      }
      static requestHeapFrame(params) {
        const type3 = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestHeapFrame;
        const data = encodeData2(type3, params);
        return new TransactionInstruction({
          keys: [],
          programId: this.programId,
          data
        });
      }
      static setComputeUnitLimit(params) {
        const type3 = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitLimit;
        const data = encodeData2(type3, params);
        return new TransactionInstruction({
          keys: [],
          programId: this.programId,
          data
        });
      }
      static setComputeUnitPrice(params) {
        const type3 = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitPrice;
        const data = encodeData2(type3, {
          microLamports: BigInt(params.microLamports)
        });
        return new TransactionInstruction({
          keys: [],
          programId: this.programId,
          data
        });
      }
    };
    ComputeBudgetProgram.programId = new PublicKey("ComputeBudget111111111111111111111111111111");
    PRIVATE_KEY_BYTES$1 = 64;
    PUBLIC_KEY_BYTES$1 = 32;
    SIGNATURE_BYTES = 64;
    ED25519_INSTRUCTION_LAYOUT = BufferLayout.struct([BufferLayout.u8("numSignatures"), BufferLayout.u8("padding"), BufferLayout.u16("signatureOffset"), BufferLayout.u16("signatureInstructionIndex"), BufferLayout.u16("publicKeyOffset"), BufferLayout.u16("publicKeyInstructionIndex"), BufferLayout.u16("messageDataOffset"), BufferLayout.u16("messageDataSize"), BufferLayout.u16("messageInstructionIndex")]);
    Ed25519Program = class _Ed25519Program {
      /**
       * @internal
       */
      constructor() {
      }
      /**
       * Public key that identifies the ed25519 program
       */
      /**
       * Create an ed25519 instruction with a public key and signature. The
       * public key must be a buffer that is 32 bytes long, and the signature
       * must be a buffer of 64 bytes.
       */
      static createInstructionWithPublicKey(params) {
        const {
          publicKey: publicKey5,
          message,
          signature: signature2,
          instructionIndex
        } = params;
        assert2(publicKey5.length === PUBLIC_KEY_BYTES$1, `Public Key must be ${PUBLIC_KEY_BYTES$1} bytes but received ${publicKey5.length} bytes`);
        assert2(signature2.length === SIGNATURE_BYTES, `Signature must be ${SIGNATURE_BYTES} bytes but received ${signature2.length} bytes`);
        const publicKeyOffset = ED25519_INSTRUCTION_LAYOUT.span;
        const signatureOffset = publicKeyOffset + publicKey5.length;
        const messageDataOffset = signatureOffset + signature2.length;
        const numSignatures = 1;
        const instructionData = import_buffer2.Buffer.alloc(messageDataOffset + message.length);
        const index4 = instructionIndex == null ? 65535 : instructionIndex;
        ED25519_INSTRUCTION_LAYOUT.encode({
          numSignatures,
          padding: 0,
          signatureOffset,
          signatureInstructionIndex: index4,
          publicKeyOffset,
          publicKeyInstructionIndex: index4,
          messageDataOffset,
          messageDataSize: message.length,
          messageInstructionIndex: index4
        }, instructionData);
        instructionData.fill(publicKey5, publicKeyOffset);
        instructionData.fill(signature2, signatureOffset);
        instructionData.fill(message, messageDataOffset);
        return new TransactionInstruction({
          keys: [],
          programId: _Ed25519Program.programId,
          data: instructionData
        });
      }
      /**
       * Create an ed25519 instruction with a private key. The private key
       * must be a buffer that is 64 bytes long.
       */
      static createInstructionWithPrivateKey(params) {
        const {
          privateKey,
          message,
          instructionIndex
        } = params;
        assert2(privateKey.length === PRIVATE_KEY_BYTES$1, `Private key must be ${PRIVATE_KEY_BYTES$1} bytes but received ${privateKey.length} bytes`);
        try {
          const keypair = Keypair.fromSecretKey(privateKey);
          const publicKey5 = keypair.publicKey.toBytes();
          const signature2 = sign(message, keypair.secretKey);
          return this.createInstructionWithPublicKey({
            publicKey: publicKey5,
            message,
            signature: signature2,
            instructionIndex
          });
        } catch (error) {
          throw new Error(`Error creating instruction; ${error}`);
        }
      }
    };
    Ed25519Program.programId = new PublicKey("Ed25519SigVerify111111111111111111111111111");
    ecdsaSign = (msgHash, privKey) => {
      const signature2 = secp256k12.sign(msgHash, privKey);
      return [signature2.toCompactRawBytes(), signature2.recovery];
    };
    secp256k12.utils.isValidPrivateKey;
    publicKeyCreate = secp256k12.getPublicKey;
    PRIVATE_KEY_BYTES = 32;
    ETHEREUM_ADDRESS_BYTES = 20;
    PUBLIC_KEY_BYTES = 64;
    SIGNATURE_OFFSETS_SERIALIZED_SIZE = 11;
    SECP256K1_INSTRUCTION_LAYOUT = BufferLayout.struct([BufferLayout.u8("numSignatures"), BufferLayout.u16("signatureOffset"), BufferLayout.u8("signatureInstructionIndex"), BufferLayout.u16("ethAddressOffset"), BufferLayout.u8("ethAddressInstructionIndex"), BufferLayout.u16("messageDataOffset"), BufferLayout.u16("messageDataSize"), BufferLayout.u8("messageInstructionIndex"), BufferLayout.blob(20, "ethAddress"), BufferLayout.blob(64, "signature"), BufferLayout.u8("recoveryId")]);
    Secp256k1Program = class _Secp256k1Program {
      /**
       * @internal
       */
      constructor() {
      }
      /**
       * Public key that identifies the secp256k1 program
       */
      /**
       * Construct an Ethereum address from a secp256k1 public key buffer.
       * @param {Buffer} publicKey a 64 byte secp256k1 public key buffer
       */
      static publicKeyToEthAddress(publicKey5) {
        assert2(publicKey5.length === PUBLIC_KEY_BYTES, `Public key must be ${PUBLIC_KEY_BYTES} bytes but received ${publicKey5.length} bytes`);
        try {
          return import_buffer2.Buffer.from(keccak_256(toBuffer(publicKey5))).slice(-ETHEREUM_ADDRESS_BYTES);
        } catch (error) {
          throw new Error(`Error constructing Ethereum address: ${error}`);
        }
      }
      /**
       * Create an secp256k1 instruction with a public key. The public key
       * must be a buffer that is 64 bytes long.
       */
      static createInstructionWithPublicKey(params) {
        const {
          publicKey: publicKey5,
          message,
          signature: signature2,
          recoveryId,
          instructionIndex
        } = params;
        return _Secp256k1Program.createInstructionWithEthAddress({
          ethAddress: _Secp256k1Program.publicKeyToEthAddress(publicKey5),
          message,
          signature: signature2,
          recoveryId,
          instructionIndex
        });
      }
      /**
       * Create an secp256k1 instruction with an Ethereum address. The address
       * must be a hex string or a buffer that is 20 bytes long.
       */
      static createInstructionWithEthAddress(params) {
        const {
          ethAddress: rawAddress,
          message,
          signature: signature2,
          recoveryId,
          instructionIndex = 0
        } = params;
        let ethAddress2;
        if (typeof rawAddress === "string") {
          if (rawAddress.startsWith("0x")) {
            ethAddress2 = import_buffer2.Buffer.from(rawAddress.substr(2), "hex");
          } else {
            ethAddress2 = import_buffer2.Buffer.from(rawAddress, "hex");
          }
        } else {
          ethAddress2 = rawAddress;
        }
        assert2(ethAddress2.length === ETHEREUM_ADDRESS_BYTES, `Address must be ${ETHEREUM_ADDRESS_BYTES} bytes but received ${ethAddress2.length} bytes`);
        const dataStart = 1 + SIGNATURE_OFFSETS_SERIALIZED_SIZE;
        const ethAddressOffset = dataStart;
        const signatureOffset = dataStart + ethAddress2.length;
        const messageDataOffset = signatureOffset + signature2.length + 1;
        const numSignatures = 1;
        const instructionData = import_buffer2.Buffer.alloc(SECP256K1_INSTRUCTION_LAYOUT.span + message.length);
        SECP256K1_INSTRUCTION_LAYOUT.encode({
          numSignatures,
          signatureOffset,
          signatureInstructionIndex: instructionIndex,
          ethAddressOffset,
          ethAddressInstructionIndex: instructionIndex,
          messageDataOffset,
          messageDataSize: message.length,
          messageInstructionIndex: instructionIndex,
          signature: toBuffer(signature2),
          ethAddress: toBuffer(ethAddress2),
          recoveryId
        }, instructionData);
        instructionData.fill(toBuffer(message), SECP256K1_INSTRUCTION_LAYOUT.span);
        return new TransactionInstruction({
          keys: [],
          programId: _Secp256k1Program.programId,
          data: instructionData
        });
      }
      /**
       * Create an secp256k1 instruction with a private key. The private key
       * must be a buffer that is 32 bytes long.
       */
      static createInstructionWithPrivateKey(params) {
        const {
          privateKey: pkey,
          message,
          instructionIndex
        } = params;
        assert2(pkey.length === PRIVATE_KEY_BYTES, `Private key must be ${PRIVATE_KEY_BYTES} bytes but received ${pkey.length} bytes`);
        try {
          const privateKey = toBuffer(pkey);
          const publicKey5 = publicKeyCreate(
            privateKey,
            false
            /* isCompressed */
          ).slice(1);
          const messageHash = import_buffer2.Buffer.from(keccak_256(toBuffer(message)));
          const [signature2, recoveryId] = ecdsaSign(messageHash, privateKey);
          return this.createInstructionWithPublicKey({
            publicKey: publicKey5,
            message,
            signature: signature2,
            recoveryId,
            instructionIndex
          });
        } catch (error) {
          throw new Error(`Error creating instruction; ${error}`);
        }
      }
    };
    Secp256k1Program.programId = new PublicKey("KeccakSecp256k11111111111111111111111111111");
    STAKE_CONFIG_ID = new PublicKey("StakeConfig11111111111111111111111111111111");
    Authorized = class {
      /**
       * Create a new Authorized object
       * @param staker the stake authority
       * @param withdrawer the withdraw authority
       */
      constructor(staker, withdrawer) {
        this.staker = void 0;
        this.withdrawer = void 0;
        this.staker = staker;
        this.withdrawer = withdrawer;
      }
    };
    Lockup = class {
      /**
       * Create a new Lockup object
       */
      constructor(unixTimestamp, epoch, custodian) {
        this.unixTimestamp = void 0;
        this.epoch = void 0;
        this.custodian = void 0;
        this.unixTimestamp = unixTimestamp;
        this.epoch = epoch;
        this.custodian = custodian;
      }
      /**
       * Default, inactive Lockup value
       */
    };
    _Lockup = Lockup;
    Lockup.default = new _Lockup(0, 0, PublicKey.default);
    StakeInstruction = class {
      /**
       * @internal
       */
      constructor() {
      }
      /**
       * Decode a stake instruction and retrieve the instruction type.
       */
      static decodeInstructionType(instruction) {
        this.checkProgramId(instruction.programId);
        const instructionTypeLayout = BufferLayout.u32("instruction");
        const typeIndex = instructionTypeLayout.decode(instruction.data);
        let type3;
        for (const [ixType, layout] of Object.entries(STAKE_INSTRUCTION_LAYOUTS)) {
          if (layout.index == typeIndex) {
            type3 = ixType;
            break;
          }
        }
        if (!type3) {
          throw new Error("Instruction type incorrect; not a StakeInstruction");
        }
        return type3;
      }
      /**
       * Decode a initialize stake instruction and retrieve the instruction params.
       */
      static decodeInitialize(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeyLength(instruction.keys, 2);
        const {
          authorized: authorized2,
          lockup: lockup2
        } = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Initialize, instruction.data);
        return {
          stakePubkey: instruction.keys[0].pubkey,
          authorized: new Authorized(new PublicKey(authorized2.staker), new PublicKey(authorized2.withdrawer)),
          lockup: new Lockup(lockup2.unixTimestamp, lockup2.epoch, new PublicKey(lockup2.custodian))
        };
      }
      /**
       * Decode a delegate stake instruction and retrieve the instruction params.
       */
      static decodeDelegate(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeyLength(instruction.keys, 6);
        decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Delegate, instruction.data);
        return {
          stakePubkey: instruction.keys[0].pubkey,
          votePubkey: instruction.keys[1].pubkey,
          authorizedPubkey: instruction.keys[5].pubkey
        };
      }
      /**
       * Decode an authorize stake instruction and retrieve the instruction params.
       */
      static decodeAuthorize(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeyLength(instruction.keys, 3);
        const {
          newAuthorized,
          stakeAuthorizationType
        } = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Authorize, instruction.data);
        const o = {
          stakePubkey: instruction.keys[0].pubkey,
          authorizedPubkey: instruction.keys[2].pubkey,
          newAuthorizedPubkey: new PublicKey(newAuthorized),
          stakeAuthorizationType: {
            index: stakeAuthorizationType
          }
        };
        if (instruction.keys.length > 3) {
          o.custodianPubkey = instruction.keys[3].pubkey;
        }
        return o;
      }
      /**
       * Decode an authorize-with-seed stake instruction and retrieve the instruction params.
       */
      static decodeAuthorizeWithSeed(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeyLength(instruction.keys, 2);
        const {
          newAuthorized,
          stakeAuthorizationType,
          authoritySeed,
          authorityOwner
        } = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed, instruction.data);
        const o = {
          stakePubkey: instruction.keys[0].pubkey,
          authorityBase: instruction.keys[1].pubkey,
          authoritySeed,
          authorityOwner: new PublicKey(authorityOwner),
          newAuthorizedPubkey: new PublicKey(newAuthorized),
          stakeAuthorizationType: {
            index: stakeAuthorizationType
          }
        };
        if (instruction.keys.length > 3) {
          o.custodianPubkey = instruction.keys[3].pubkey;
        }
        return o;
      }
      /**
       * Decode a split stake instruction and retrieve the instruction params.
       */
      static decodeSplit(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeyLength(instruction.keys, 3);
        const {
          lamports
        } = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Split, instruction.data);
        return {
          stakePubkey: instruction.keys[0].pubkey,
          splitStakePubkey: instruction.keys[1].pubkey,
          authorizedPubkey: instruction.keys[2].pubkey,
          lamports
        };
      }
      /**
       * Decode a merge stake instruction and retrieve the instruction params.
       */
      static decodeMerge(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeyLength(instruction.keys, 3);
        decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Merge, instruction.data);
        return {
          stakePubkey: instruction.keys[0].pubkey,
          sourceStakePubKey: instruction.keys[1].pubkey,
          authorizedPubkey: instruction.keys[4].pubkey
        };
      }
      /**
       * Decode a withdraw stake instruction and retrieve the instruction params.
       */
      static decodeWithdraw(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeyLength(instruction.keys, 5);
        const {
          lamports
        } = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Withdraw, instruction.data);
        const o = {
          stakePubkey: instruction.keys[0].pubkey,
          toPubkey: instruction.keys[1].pubkey,
          authorizedPubkey: instruction.keys[4].pubkey,
          lamports
        };
        if (instruction.keys.length > 5) {
          o.custodianPubkey = instruction.keys[5].pubkey;
        }
        return o;
      }
      /**
       * Decode a deactivate stake instruction and retrieve the instruction params.
       */
      static decodeDeactivate(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeyLength(instruction.keys, 3);
        decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Deactivate, instruction.data);
        return {
          stakePubkey: instruction.keys[0].pubkey,
          authorizedPubkey: instruction.keys[2].pubkey
        };
      }
      /**
       * @internal
       */
      static checkProgramId(programId) {
        if (!programId.equals(StakeProgram.programId)) {
          throw new Error("invalid instruction; programId is not StakeProgram");
        }
      }
      /**
       * @internal
       */
      static checkKeyLength(keys, expectedLength) {
        if (keys.length < expectedLength) {
          throw new Error(`invalid instruction; found ${keys.length} keys, expected at least ${expectedLength}`);
        }
      }
    };
    STAKE_INSTRUCTION_LAYOUTS = Object.freeze({
      Initialize: {
        index: 0,
        layout: BufferLayout.struct([BufferLayout.u32("instruction"), authorized(), lockup()])
      },
      Authorize: {
        index: 1,
        layout: BufferLayout.struct([BufferLayout.u32("instruction"), publicKey("newAuthorized"), BufferLayout.u32("stakeAuthorizationType")])
      },
      Delegate: {
        index: 2,
        layout: BufferLayout.struct([BufferLayout.u32("instruction")])
      },
      Split: {
        index: 3,
        layout: BufferLayout.struct([BufferLayout.u32("instruction"), BufferLayout.ns64("lamports")])
      },
      Withdraw: {
        index: 4,
        layout: BufferLayout.struct([BufferLayout.u32("instruction"), BufferLayout.ns64("lamports")])
      },
      Deactivate: {
        index: 5,
        layout: BufferLayout.struct([BufferLayout.u32("instruction")])
      },
      Merge: {
        index: 7,
        layout: BufferLayout.struct([BufferLayout.u32("instruction")])
      },
      AuthorizeWithSeed: {
        index: 8,
        layout: BufferLayout.struct([BufferLayout.u32("instruction"), publicKey("newAuthorized"), BufferLayout.u32("stakeAuthorizationType"), rustString("authoritySeed"), publicKey("authorityOwner")])
      }
    });
    StakeAuthorizationLayout = Object.freeze({
      Staker: {
        index: 0
      },
      Withdrawer: {
        index: 1
      }
    });
    StakeProgram = class {
      /**
       * @internal
       */
      constructor() {
      }
      /**
       * Public key that identifies the Stake program
       */
      /**
       * Generate an Initialize instruction to add to a Stake Create transaction
       */
      static initialize(params) {
        const {
          stakePubkey,
          authorized: authorized2,
          lockup: maybeLockup
        } = params;
        const lockup2 = maybeLockup || Lockup.default;
        const type3 = STAKE_INSTRUCTION_LAYOUTS.Initialize;
        const data = encodeData2(type3, {
          authorized: {
            staker: toBuffer(authorized2.staker.toBuffer()),
            withdrawer: toBuffer(authorized2.withdrawer.toBuffer())
          },
          lockup: {
            unixTimestamp: lockup2.unixTimestamp,
            epoch: lockup2.epoch,
            custodian: toBuffer(lockup2.custodian.toBuffer())
          }
        });
        const instructionData = {
          keys: [{
            pubkey: stakePubkey,
            isSigner: false,
            isWritable: true
          }, {
            pubkey: SYSVAR_RENT_PUBKEY,
            isSigner: false,
            isWritable: false
          }],
          programId: this.programId,
          data
        };
        return new TransactionInstruction(instructionData);
      }
      /**
       * Generate a Transaction that creates a new Stake account at
       *   an address generated with `from`, a seed, and the Stake programId
       */
      static createAccountWithSeed(params) {
        const transaction = new Transaction();
        transaction.add(SystemProgram.createAccountWithSeed({
          fromPubkey: params.fromPubkey,
          newAccountPubkey: params.stakePubkey,
          basePubkey: params.basePubkey,
          seed: params.seed,
          lamports: params.lamports,
          space: this.space,
          programId: this.programId
        }));
        const {
          stakePubkey,
          authorized: authorized2,
          lockup: lockup2
        } = params;
        return transaction.add(this.initialize({
          stakePubkey,
          authorized: authorized2,
          lockup: lockup2
        }));
      }
      /**
       * Generate a Transaction that creates a new Stake account
       */
      static createAccount(params) {
        const transaction = new Transaction();
        transaction.add(SystemProgram.createAccount({
          fromPubkey: params.fromPubkey,
          newAccountPubkey: params.stakePubkey,
          lamports: params.lamports,
          space: this.space,
          programId: this.programId
        }));
        const {
          stakePubkey,
          authorized: authorized2,
          lockup: lockup2
        } = params;
        return transaction.add(this.initialize({
          stakePubkey,
          authorized: authorized2,
          lockup: lockup2
        }));
      }
      /**
       * Generate a Transaction that delegates Stake tokens to a validator
       * Vote PublicKey. This transaction can also be used to redelegate Stake
       * to a new validator Vote PublicKey.
       */
      static delegate(params) {
        const {
          stakePubkey,
          authorizedPubkey,
          votePubkey
        } = params;
        const type3 = STAKE_INSTRUCTION_LAYOUTS.Delegate;
        const data = encodeData2(type3);
        return new Transaction().add({
          keys: [{
            pubkey: stakePubkey,
            isSigner: false,
            isWritable: true
          }, {
            pubkey: votePubkey,
            isSigner: false,
            isWritable: false
          }, {
            pubkey: SYSVAR_CLOCK_PUBKEY,
            isSigner: false,
            isWritable: false
          }, {
            pubkey: SYSVAR_STAKE_HISTORY_PUBKEY,
            isSigner: false,
            isWritable: false
          }, {
            pubkey: STAKE_CONFIG_ID,
            isSigner: false,
            isWritable: false
          }, {
            pubkey: authorizedPubkey,
            isSigner: true,
            isWritable: false
          }],
          programId: this.programId,
          data
        });
      }
      /**
       * Generate a Transaction that authorizes a new PublicKey as Staker
       * or Withdrawer on the Stake account.
       */
      static authorize(params) {
        const {
          stakePubkey,
          authorizedPubkey,
          newAuthorizedPubkey,
          stakeAuthorizationType,
          custodianPubkey
        } = params;
        const type3 = STAKE_INSTRUCTION_LAYOUTS.Authorize;
        const data = encodeData2(type3, {
          newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),
          stakeAuthorizationType: stakeAuthorizationType.index
        });
        const keys = [{
          pubkey: stakePubkey,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: SYSVAR_CLOCK_PUBKEY,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: authorizedPubkey,
          isSigner: true,
          isWritable: false
        }];
        if (custodianPubkey) {
          keys.push({
            pubkey: custodianPubkey,
            isSigner: true,
            isWritable: false
          });
        }
        return new Transaction().add({
          keys,
          programId: this.programId,
          data
        });
      }
      /**
       * Generate a Transaction that authorizes a new PublicKey as Staker
       * or Withdrawer on the Stake account.
       */
      static authorizeWithSeed(params) {
        const {
          stakePubkey,
          authorityBase,
          authoritySeed,
          authorityOwner,
          newAuthorizedPubkey,
          stakeAuthorizationType,
          custodianPubkey
        } = params;
        const type3 = STAKE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed;
        const data = encodeData2(type3, {
          newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),
          stakeAuthorizationType: stakeAuthorizationType.index,
          authoritySeed,
          authorityOwner: toBuffer(authorityOwner.toBuffer())
        });
        const keys = [{
          pubkey: stakePubkey,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: authorityBase,
          isSigner: true,
          isWritable: false
        }, {
          pubkey: SYSVAR_CLOCK_PUBKEY,
          isSigner: false,
          isWritable: false
        }];
        if (custodianPubkey) {
          keys.push({
            pubkey: custodianPubkey,
            isSigner: true,
            isWritable: false
          });
        }
        return new Transaction().add({
          keys,
          programId: this.programId,
          data
        });
      }
      /**
       * @internal
       */
      static splitInstruction(params) {
        const {
          stakePubkey,
          authorizedPubkey,
          splitStakePubkey,
          lamports
        } = params;
        const type3 = STAKE_INSTRUCTION_LAYOUTS.Split;
        const data = encodeData2(type3, {
          lamports
        });
        return new TransactionInstruction({
          keys: [{
            pubkey: stakePubkey,
            isSigner: false,
            isWritable: true
          }, {
            pubkey: splitStakePubkey,
            isSigner: false,
            isWritable: true
          }, {
            pubkey: authorizedPubkey,
            isSigner: true,
            isWritable: false
          }],
          programId: this.programId,
          data
        });
      }
      /**
       * Generate a Transaction that splits Stake tokens into another stake account
       */
      static split(params, rentExemptReserve) {
        const transaction = new Transaction();
        transaction.add(SystemProgram.createAccount({
          fromPubkey: params.authorizedPubkey,
          newAccountPubkey: params.splitStakePubkey,
          lamports: rentExemptReserve,
          space: this.space,
          programId: this.programId
        }));
        return transaction.add(this.splitInstruction(params));
      }
      /**
       * Generate a Transaction that splits Stake tokens into another account
       * derived from a base public key and seed
       */
      static splitWithSeed(params, rentExemptReserve) {
        const {
          stakePubkey,
          authorizedPubkey,
          splitStakePubkey,
          basePubkey,
          seed: seed2,
          lamports
        } = params;
        const transaction = new Transaction();
        transaction.add(SystemProgram.allocate({
          accountPubkey: splitStakePubkey,
          basePubkey,
          seed: seed2,
          space: this.space,
          programId: this.programId
        }));
        if (rentExemptReserve && rentExemptReserve > 0) {
          transaction.add(SystemProgram.transfer({
            fromPubkey: params.authorizedPubkey,
            toPubkey: splitStakePubkey,
            lamports: rentExemptReserve
          }));
        }
        return transaction.add(this.splitInstruction({
          stakePubkey,
          authorizedPubkey,
          splitStakePubkey,
          lamports
        }));
      }
      /**
       * Generate a Transaction that merges Stake accounts.
       */
      static merge(params) {
        const {
          stakePubkey,
          sourceStakePubKey,
          authorizedPubkey
        } = params;
        const type3 = STAKE_INSTRUCTION_LAYOUTS.Merge;
        const data = encodeData2(type3);
        return new Transaction().add({
          keys: [{
            pubkey: stakePubkey,
            isSigner: false,
            isWritable: true
          }, {
            pubkey: sourceStakePubKey,
            isSigner: false,
            isWritable: true
          }, {
            pubkey: SYSVAR_CLOCK_PUBKEY,
            isSigner: false,
            isWritable: false
          }, {
            pubkey: SYSVAR_STAKE_HISTORY_PUBKEY,
            isSigner: false,
            isWritable: false
          }, {
            pubkey: authorizedPubkey,
            isSigner: true,
            isWritable: false
          }],
          programId: this.programId,
          data
        });
      }
      /**
       * Generate a Transaction that withdraws deactivated Stake tokens.
       */
      static withdraw(params) {
        const {
          stakePubkey,
          authorizedPubkey,
          toPubkey,
          lamports,
          custodianPubkey
        } = params;
        const type3 = STAKE_INSTRUCTION_LAYOUTS.Withdraw;
        const data = encodeData2(type3, {
          lamports
        });
        const keys = [{
          pubkey: stakePubkey,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: toPubkey,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: SYSVAR_CLOCK_PUBKEY,
          isSigner: false,
          isWritable: false
        }, {
          pubkey: SYSVAR_STAKE_HISTORY_PUBKEY,
          isSigner: false,
          isWritable: false
        }, {
          pubkey: authorizedPubkey,
          isSigner: true,
          isWritable: false
        }];
        if (custodianPubkey) {
          keys.push({
            pubkey: custodianPubkey,
            isSigner: true,
            isWritable: false
          });
        }
        return new Transaction().add({
          keys,
          programId: this.programId,
          data
        });
      }
      /**
       * Generate a Transaction that deactivates Stake tokens.
       */
      static deactivate(params) {
        const {
          stakePubkey,
          authorizedPubkey
        } = params;
        const type3 = STAKE_INSTRUCTION_LAYOUTS.Deactivate;
        const data = encodeData2(type3);
        return new Transaction().add({
          keys: [{
            pubkey: stakePubkey,
            isSigner: false,
            isWritable: true
          }, {
            pubkey: SYSVAR_CLOCK_PUBKEY,
            isSigner: false,
            isWritable: false
          }, {
            pubkey: authorizedPubkey,
            isSigner: true,
            isWritable: false
          }],
          programId: this.programId,
          data
        });
      }
    };
    StakeProgram.programId = new PublicKey("Stake11111111111111111111111111111111111111");
    StakeProgram.space = 200;
    VoteInit = class {
      /** [0, 100] */
      constructor(nodePubkey, authorizedVoter, authorizedWithdrawer, commission) {
        this.nodePubkey = void 0;
        this.authorizedVoter = void 0;
        this.authorizedWithdrawer = void 0;
        this.commission = void 0;
        this.nodePubkey = nodePubkey;
        this.authorizedVoter = authorizedVoter;
        this.authorizedWithdrawer = authorizedWithdrawer;
        this.commission = commission;
      }
    };
    VoteInstruction = class {
      /**
       * @internal
       */
      constructor() {
      }
      /**
       * Decode a vote instruction and retrieve the instruction type.
       */
      static decodeInstructionType(instruction) {
        this.checkProgramId(instruction.programId);
        const instructionTypeLayout = BufferLayout.u32("instruction");
        const typeIndex = instructionTypeLayout.decode(instruction.data);
        let type3;
        for (const [ixType, layout] of Object.entries(VOTE_INSTRUCTION_LAYOUTS)) {
          if (layout.index == typeIndex) {
            type3 = ixType;
            break;
          }
        }
        if (!type3) {
          throw new Error("Instruction type incorrect; not a VoteInstruction");
        }
        return type3;
      }
      /**
       * Decode an initialize vote instruction and retrieve the instruction params.
       */
      static decodeInitializeAccount(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeyLength(instruction.keys, 4);
        const {
          voteInit: voteInit2
        } = decodeData$1(VOTE_INSTRUCTION_LAYOUTS.InitializeAccount, instruction.data);
        return {
          votePubkey: instruction.keys[0].pubkey,
          nodePubkey: instruction.keys[3].pubkey,
          voteInit: new VoteInit(new PublicKey(voteInit2.nodePubkey), new PublicKey(voteInit2.authorizedVoter), new PublicKey(voteInit2.authorizedWithdrawer), voteInit2.commission)
        };
      }
      /**
       * Decode an authorize instruction and retrieve the instruction params.
       */
      static decodeAuthorize(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeyLength(instruction.keys, 3);
        const {
          newAuthorized,
          voteAuthorizationType
        } = decodeData$1(VOTE_INSTRUCTION_LAYOUTS.Authorize, instruction.data);
        return {
          votePubkey: instruction.keys[0].pubkey,
          authorizedPubkey: instruction.keys[2].pubkey,
          newAuthorizedPubkey: new PublicKey(newAuthorized),
          voteAuthorizationType: {
            index: voteAuthorizationType
          }
        };
      }
      /**
       * Decode an authorize instruction and retrieve the instruction params.
       */
      static decodeAuthorizeWithSeed(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeyLength(instruction.keys, 3);
        const {
          voteAuthorizeWithSeedArgs: {
            currentAuthorityDerivedKeyOwnerPubkey,
            currentAuthorityDerivedKeySeed,
            newAuthorized,
            voteAuthorizationType
          }
        } = decodeData$1(VOTE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed, instruction.data);
        return {
          currentAuthorityDerivedKeyBasePubkey: instruction.keys[2].pubkey,
          currentAuthorityDerivedKeyOwnerPubkey: new PublicKey(currentAuthorityDerivedKeyOwnerPubkey),
          currentAuthorityDerivedKeySeed,
          newAuthorizedPubkey: new PublicKey(newAuthorized),
          voteAuthorizationType: {
            index: voteAuthorizationType
          },
          votePubkey: instruction.keys[0].pubkey
        };
      }
      /**
       * Decode a withdraw instruction and retrieve the instruction params.
       */
      static decodeWithdraw(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeyLength(instruction.keys, 3);
        const {
          lamports
        } = decodeData$1(VOTE_INSTRUCTION_LAYOUTS.Withdraw, instruction.data);
        return {
          votePubkey: instruction.keys[0].pubkey,
          authorizedWithdrawerPubkey: instruction.keys[2].pubkey,
          lamports,
          toPubkey: instruction.keys[1].pubkey
        };
      }
      /**
       * @internal
       */
      static checkProgramId(programId) {
        if (!programId.equals(VoteProgram.programId)) {
          throw new Error("invalid instruction; programId is not VoteProgram");
        }
      }
      /**
       * @internal
       */
      static checkKeyLength(keys, expectedLength) {
        if (keys.length < expectedLength) {
          throw new Error(`invalid instruction; found ${keys.length} keys, expected at least ${expectedLength}`);
        }
      }
    };
    VOTE_INSTRUCTION_LAYOUTS = Object.freeze({
      InitializeAccount: {
        index: 0,
        layout: BufferLayout.struct([BufferLayout.u32("instruction"), voteInit()])
      },
      Authorize: {
        index: 1,
        layout: BufferLayout.struct([BufferLayout.u32("instruction"), publicKey("newAuthorized"), BufferLayout.u32("voteAuthorizationType")])
      },
      Withdraw: {
        index: 3,
        layout: BufferLayout.struct([BufferLayout.u32("instruction"), BufferLayout.ns64("lamports")])
      },
      UpdateValidatorIdentity: {
        index: 4,
        layout: BufferLayout.struct([BufferLayout.u32("instruction")])
      },
      AuthorizeWithSeed: {
        index: 10,
        layout: BufferLayout.struct([BufferLayout.u32("instruction"), voteAuthorizeWithSeedArgs()])
      }
    });
    VoteAuthorizationLayout = Object.freeze({
      Voter: {
        index: 0
      },
      Withdrawer: {
        index: 1
      }
    });
    VoteProgram = class _VoteProgram {
      /**
       * @internal
       */
      constructor() {
      }
      /**
       * Public key that identifies the Vote program
       */
      /**
       * Generate an Initialize instruction.
       */
      static initializeAccount(params) {
        const {
          votePubkey,
          nodePubkey,
          voteInit: voteInit2
        } = params;
        const type3 = VOTE_INSTRUCTION_LAYOUTS.InitializeAccount;
        const data = encodeData2(type3, {
          voteInit: {
            nodePubkey: toBuffer(voteInit2.nodePubkey.toBuffer()),
            authorizedVoter: toBuffer(voteInit2.authorizedVoter.toBuffer()),
            authorizedWithdrawer: toBuffer(voteInit2.authorizedWithdrawer.toBuffer()),
            commission: voteInit2.commission
          }
        });
        const instructionData = {
          keys: [{
            pubkey: votePubkey,
            isSigner: false,
            isWritable: true
          }, {
            pubkey: SYSVAR_RENT_PUBKEY,
            isSigner: false,
            isWritable: false
          }, {
            pubkey: SYSVAR_CLOCK_PUBKEY,
            isSigner: false,
            isWritable: false
          }, {
            pubkey: nodePubkey,
            isSigner: true,
            isWritable: false
          }],
          programId: this.programId,
          data
        };
        return new TransactionInstruction(instructionData);
      }
      /**
       * Generate a transaction that creates a new Vote account.
       */
      static createAccount(params) {
        const transaction = new Transaction();
        transaction.add(SystemProgram.createAccount({
          fromPubkey: params.fromPubkey,
          newAccountPubkey: params.votePubkey,
          lamports: params.lamports,
          space: this.space,
          programId: this.programId
        }));
        return transaction.add(this.initializeAccount({
          votePubkey: params.votePubkey,
          nodePubkey: params.voteInit.nodePubkey,
          voteInit: params.voteInit
        }));
      }
      /**
       * Generate a transaction that authorizes a new Voter or Withdrawer on the Vote account.
       */
      static authorize(params) {
        const {
          votePubkey,
          authorizedPubkey,
          newAuthorizedPubkey,
          voteAuthorizationType
        } = params;
        const type3 = VOTE_INSTRUCTION_LAYOUTS.Authorize;
        const data = encodeData2(type3, {
          newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),
          voteAuthorizationType: voteAuthorizationType.index
        });
        const keys = [{
          pubkey: votePubkey,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: SYSVAR_CLOCK_PUBKEY,
          isSigner: false,
          isWritable: false
        }, {
          pubkey: authorizedPubkey,
          isSigner: true,
          isWritable: false
        }];
        return new Transaction().add({
          keys,
          programId: this.programId,
          data
        });
      }
      /**
       * Generate a transaction that authorizes a new Voter or Withdrawer on the Vote account
       * where the current Voter or Withdrawer authority is a derived key.
       */
      static authorizeWithSeed(params) {
        const {
          currentAuthorityDerivedKeyBasePubkey,
          currentAuthorityDerivedKeyOwnerPubkey,
          currentAuthorityDerivedKeySeed,
          newAuthorizedPubkey,
          voteAuthorizationType,
          votePubkey
        } = params;
        const type3 = VOTE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed;
        const data = encodeData2(type3, {
          voteAuthorizeWithSeedArgs: {
            currentAuthorityDerivedKeyOwnerPubkey: toBuffer(currentAuthorityDerivedKeyOwnerPubkey.toBuffer()),
            currentAuthorityDerivedKeySeed,
            newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),
            voteAuthorizationType: voteAuthorizationType.index
          }
        });
        const keys = [{
          pubkey: votePubkey,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: SYSVAR_CLOCK_PUBKEY,
          isSigner: false,
          isWritable: false
        }, {
          pubkey: currentAuthorityDerivedKeyBasePubkey,
          isSigner: true,
          isWritable: false
        }];
        return new Transaction().add({
          keys,
          programId: this.programId,
          data
        });
      }
      /**
       * Generate a transaction to withdraw from a Vote account.
       */
      static withdraw(params) {
        const {
          votePubkey,
          authorizedWithdrawerPubkey,
          lamports,
          toPubkey
        } = params;
        const type3 = VOTE_INSTRUCTION_LAYOUTS.Withdraw;
        const data = encodeData2(type3, {
          lamports
        });
        const keys = [{
          pubkey: votePubkey,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: toPubkey,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: authorizedWithdrawerPubkey,
          isSigner: true,
          isWritable: false
        }];
        return new Transaction().add({
          keys,
          programId: this.programId,
          data
        });
      }
      /**
       * Generate a transaction to withdraw safely from a Vote account.
       *
       * This function was created as a safeguard for vote accounts running validators, `safeWithdraw`
       * checks that the withdraw amount will not exceed the specified balance while leaving enough left
       * to cover rent. If you wish to close the vote account by withdrawing the full amount, call the
       * `withdraw` method directly.
       */
      static safeWithdraw(params, currentVoteAccountBalance, rentExemptMinimum) {
        if (params.lamports > currentVoteAccountBalance - rentExemptMinimum) {
          throw new Error("Withdraw will leave vote account with insufficient funds.");
        }
        return _VoteProgram.withdraw(params);
      }
      /**
       * Generate a transaction to update the validator identity (node pubkey) of a Vote account.
       */
      static updateValidatorIdentity(params) {
        const {
          votePubkey,
          authorizedWithdrawerPubkey,
          nodePubkey
        } = params;
        const type3 = VOTE_INSTRUCTION_LAYOUTS.UpdateValidatorIdentity;
        const data = encodeData2(type3);
        const keys = [{
          pubkey: votePubkey,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: nodePubkey,
          isSigner: true,
          isWritable: false
        }, {
          pubkey: authorizedWithdrawerPubkey,
          isSigner: true,
          isWritable: false
        }];
        return new Transaction().add({
          keys,
          programId: this.programId,
          data
        });
      }
    };
    VoteProgram.programId = new PublicKey("Vote111111111111111111111111111111111111111");
    VoteProgram.space = 3762;
    VALIDATOR_INFO_KEY = new PublicKey("Va1idator1nfo111111111111111111111111111111");
    InfoString = type({
      name: string(),
      website: optional(string()),
      details: optional(string()),
      iconUrl: optional(string()),
      keybaseUsername: optional(string())
    });
    ValidatorInfo = class _ValidatorInfo {
      /**
       * Construct a valid ValidatorInfo
       *
       * @param key validator public key
       * @param info validator information
       */
      constructor(key, info) {
        this.key = void 0;
        this.info = void 0;
        this.key = key;
        this.info = info;
      }
      /**
       * Deserialize ValidatorInfo from the config account data. Exactly two config
       * keys are required in the data.
       *
       * @param buffer config account data
       * @return null if info was not found
       */
      static fromConfigData(buffer3) {
        let byteArray = [...buffer3];
        const configKeyCount = decodeLength(byteArray);
        if (configKeyCount !== 2) return null;
        const configKeys = [];
        for (let i = 0; i < 2; i++) {
          const publicKey5 = new PublicKey(guardedSplice(byteArray, 0, PUBLIC_KEY_LENGTH));
          const isSigner = guardedShift(byteArray) === 1;
          configKeys.push({
            publicKey: publicKey5,
            isSigner
          });
        }
        if (configKeys[0].publicKey.equals(VALIDATOR_INFO_KEY)) {
          if (configKeys[1].isSigner) {
            const rawInfo = rustString().decode(import_buffer2.Buffer.from(byteArray));
            const info = JSON.parse(rawInfo);
            assert(info, InfoString);
            return new _ValidatorInfo(configKeys[1].publicKey, info);
          }
        }
        return null;
      }
    };
    VOTE_PROGRAM_ID = new PublicKey("Vote111111111111111111111111111111111111111");
    VoteAccountLayout = BufferLayout.struct([
      publicKey("nodePubkey"),
      publicKey("authorizedWithdrawer"),
      BufferLayout.u8("commission"),
      BufferLayout.nu64(),
      // votes.length
      BufferLayout.seq(BufferLayout.struct([BufferLayout.nu64("slot"), BufferLayout.u32("confirmationCount")]), BufferLayout.offset(BufferLayout.u32(), -8), "votes"),
      BufferLayout.u8("rootSlotValid"),
      BufferLayout.nu64("rootSlot"),
      BufferLayout.nu64(),
      // authorizedVoters.length
      BufferLayout.seq(BufferLayout.struct([BufferLayout.nu64("epoch"), publicKey("authorizedVoter")]), BufferLayout.offset(BufferLayout.u32(), -8), "authorizedVoters"),
      BufferLayout.struct([BufferLayout.seq(BufferLayout.struct([publicKey("authorizedPubkey"), BufferLayout.nu64("epochOfLastAuthorizedSwitch"), BufferLayout.nu64("targetEpoch")]), 32, "buf"), BufferLayout.nu64("idx"), BufferLayout.u8("isEmpty")], "priorVoters"),
      BufferLayout.nu64(),
      // epochCredits.length
      BufferLayout.seq(BufferLayout.struct([BufferLayout.nu64("epoch"), BufferLayout.nu64("credits"), BufferLayout.nu64("prevCredits")]), BufferLayout.offset(BufferLayout.u32(), -8), "epochCredits"),
      BufferLayout.struct([BufferLayout.nu64("slot"), BufferLayout.nu64("timestamp")], "lastTimestamp")
    ]);
    VoteAccount = class _VoteAccount {
      /**
       * @internal
       */
      constructor(args) {
        this.nodePubkey = void 0;
        this.authorizedWithdrawer = void 0;
        this.commission = void 0;
        this.rootSlot = void 0;
        this.votes = void 0;
        this.authorizedVoters = void 0;
        this.priorVoters = void 0;
        this.epochCredits = void 0;
        this.lastTimestamp = void 0;
        this.nodePubkey = args.nodePubkey;
        this.authorizedWithdrawer = args.authorizedWithdrawer;
        this.commission = args.commission;
        this.rootSlot = args.rootSlot;
        this.votes = args.votes;
        this.authorizedVoters = args.authorizedVoters;
        this.priorVoters = args.priorVoters;
        this.epochCredits = args.epochCredits;
        this.lastTimestamp = args.lastTimestamp;
      }
      /**
       * Deserialize VoteAccount from the account data.
       *
       * @param buffer account data
       * @return VoteAccount
       */
      static fromAccountData(buffer3) {
        const versionOffset = 4;
        const va = VoteAccountLayout.decode(toBuffer(buffer3), versionOffset);
        let rootSlot = va.rootSlot;
        if (!va.rootSlotValid) {
          rootSlot = null;
        }
        return new _VoteAccount({
          nodePubkey: new PublicKey(va.nodePubkey),
          authorizedWithdrawer: new PublicKey(va.authorizedWithdrawer),
          commission: va.commission,
          votes: va.votes,
          rootSlot,
          authorizedVoters: va.authorizedVoters.map(parseAuthorizedVoter),
          priorVoters: getPriorVoters(va.priorVoters),
          epochCredits: va.epochCredits,
          lastTimestamp: va.lastTimestamp
        });
      }
    };
    endpoint = {
      http: {
        devnet: "http://api.devnet.solana.com",
        testnet: "http://api.testnet.solana.com",
        "mainnet-beta": "http://api.mainnet-beta.solana.com/"
      },
      https: {
        devnet: "https://api.devnet.solana.com",
        testnet: "https://api.testnet.solana.com",
        "mainnet-beta": "https://api.mainnet-beta.solana.com/"
      }
    };
    LAMPORTS_PER_SOL = 1e9;
  }
});

// node_modules/bigint-buffer/dist/browser.js
var require_browser2 = __commonJS({
  "node_modules/bigint-buffer/dist/browser.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var converter;
    function toBigIntLE2(buf) {
      {
        const reversed = Buffer.from(buf);
        reversed.reverse();
        const hex3 = reversed.toString("hex");
        if (hex3.length === 0) {
          return BigInt(0);
        }
        return BigInt(`0x${hex3}`);
      }
      return converter.toBigInt(buf, false);
    }
    exports2.toBigIntLE = toBigIntLE2;
    function toBigIntBE2(buf) {
      {
        const hex3 = buf.toString("hex");
        if (hex3.length === 0) {
          return BigInt(0);
        }
        return BigInt(`0x${hex3}`);
      }
      return converter.toBigInt(buf, true);
    }
    exports2.toBigIntBE = toBigIntBE2;
    function toBufferLE2(num2, width) {
      {
        const hex3 = num2.toString(16);
        const buffer3 = Buffer.from(hex3.padStart(width * 2, "0").slice(0, width * 2), "hex");
        buffer3.reverse();
        return buffer3;
      }
      return converter.fromBigInt(num2, Buffer.allocUnsafe(width), false);
    }
    exports2.toBufferLE = toBufferLE2;
    function toBufferBE2(num2, width) {
      {
        const hex3 = num2.toString(16);
        return Buffer.from(hex3.padStart(width * 2, "0").slice(0, width * 2), "hex");
      }
      return converter.fromBigInt(num2, Buffer.allocUnsafe(width), true);
    }
    exports2.toBufferBE = toBufferBE2;
  }
});

// browser-external:crypto
var require_crypto = __commonJS({
  "browser-external:crypto"(exports2, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "crypto" has been externalized for browser compatibility. Cannot access "crypto.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/@coral-xyz/anchor/node_modules/base-x/src/index.js
var require_src2 = __commonJS({
  "node_modules/@coral-xyz/anchor/node_modules/base-x/src/index.js"(exports2, module2) {
    "use strict";
    var _Buffer = require_safe_buffer().Buffer;
    function base3(ALPHABET2) {
      if (ALPHABET2.length >= 255) {
        throw new TypeError("Alphabet too long");
      }
      var BASE_MAP = new Uint8Array(256);
      for (var j = 0; j < BASE_MAP.length; j++) {
        BASE_MAP[j] = 255;
      }
      for (var i = 0; i < ALPHABET2.length; i++) {
        var x = ALPHABET2.charAt(i);
        var xc = x.charCodeAt(0);
        if (BASE_MAP[xc] !== 255) {
          throw new TypeError(x + " is ambiguous");
        }
        BASE_MAP[xc] = i;
      }
      var BASE2 = ALPHABET2.length;
      var LEADER = ALPHABET2.charAt(0);
      var FACTOR = Math.log(BASE2) / Math.log(256);
      var iFACTOR = Math.log(256) / Math.log(BASE2);
      function encode4(source) {
        if (Array.isArray(source) || source instanceof Uint8Array) {
          source = _Buffer.from(source);
        }
        if (!_Buffer.isBuffer(source)) {
          throw new TypeError("Expected Buffer");
        }
        if (source.length === 0) {
          return "";
        }
        var zeroes = 0;
        var length2 = 0;
        var pbegin = 0;
        var pend = source.length;
        while (pbegin !== pend && source[pbegin] === 0) {
          pbegin++;
          zeroes++;
        }
        var size4 = (pend - pbegin) * iFACTOR + 1 >>> 0;
        var b58 = new Uint8Array(size4);
        while (pbegin !== pend) {
          var carry = source[pbegin];
          var i2 = 0;
          for (var it1 = size4 - 1; (carry !== 0 || i2 < length2) && it1 !== -1; it1--, i2++) {
            carry += 256 * b58[it1] >>> 0;
            b58[it1] = carry % BASE2 >>> 0;
            carry = carry / BASE2 >>> 0;
          }
          if (carry !== 0) {
            throw new Error("Non-zero carry");
          }
          length2 = i2;
          pbegin++;
        }
        var it2 = size4 - length2;
        while (it2 !== size4 && b58[it2] === 0) {
          it2++;
        }
        var str2 = LEADER.repeat(zeroes);
        for (; it2 < size4; ++it2) {
          str2 += ALPHABET2.charAt(b58[it2]);
        }
        return str2;
      }
      function decodeUnsafe(source) {
        if (typeof source !== "string") {
          throw new TypeError("Expected String");
        }
        if (source.length === 0) {
          return _Buffer.alloc(0);
        }
        var psz = 0;
        var zeroes = 0;
        var length2 = 0;
        while (source[psz] === LEADER) {
          zeroes++;
          psz++;
        }
        var size4 = (source.length - psz) * FACTOR + 1 >>> 0;
        var b256 = new Uint8Array(size4);
        while (psz < source.length) {
          var charCode = source.charCodeAt(psz);
          if (charCode > 255) {
            return;
          }
          var carry = BASE_MAP[charCode];
          if (carry === 255) {
            return;
          }
          var i2 = 0;
          for (var it3 = size4 - 1; (carry !== 0 || i2 < length2) && it3 !== -1; it3--, i2++) {
            carry += BASE2 * b256[it3] >>> 0;
            b256[it3] = carry % 256 >>> 0;
            carry = carry / 256 >>> 0;
          }
          if (carry !== 0) {
            throw new Error("Non-zero carry");
          }
          length2 = i2;
          psz++;
        }
        var it4 = size4 - length2;
        while (it4 !== size4 && b256[it4] === 0) {
          it4++;
        }
        var vch = _Buffer.allocUnsafe(zeroes + (size4 - it4));
        vch.fill(0, 0, zeroes);
        var j2 = zeroes;
        while (it4 !== size4) {
          vch[j2++] = b256[it4++];
        }
        return vch;
      }
      function decode4(string3) {
        var buffer3 = decodeUnsafe(string3);
        if (buffer3) {
          return buffer3;
        }
        throw new Error("Non-base" + BASE2 + " character");
      }
      return {
        encode: encode4,
        decodeUnsafe,
        decode: decode4
      };
    }
    module2.exports = base3;
  }
});

// node_modules/@coral-xyz/anchor/node_modules/bs58/index.js
var require_bs582 = __commonJS({
  "node_modules/@coral-xyz/anchor/node_modules/bs58/index.js"(exports2, module2) {
    var basex = require_src2();
    var ALPHABET2 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
    module2.exports = basex(ALPHABET2);
  }
});

// node_modules/camelcase/index.js
var require_camelcase = __commonJS({
  "node_modules/camelcase/index.js"(exports2, module2) {
    "use strict";
    var UPPERCASE = /[\p{Lu}]/u;
    var LOWERCASE = /[\p{Ll}]/u;
    var LEADING_CAPITAL = /^[\p{Lu}](?![\p{Lu}])/gu;
    var IDENTIFIER = /([\p{Alpha}\p{N}_]|$)/u;
    var SEPARATORS = /[_.\- ]+/;
    var LEADING_SEPARATORS = new RegExp("^" + SEPARATORS.source);
    var SEPARATORS_AND_IDENTIFIER = new RegExp(SEPARATORS.source + IDENTIFIER.source, "gu");
    var NUMBERS_AND_IDENTIFIER = new RegExp("\\d+" + IDENTIFIER.source, "gu");
    var preserveCamelCase = (string3, toLowerCase, toUpperCase) => {
      let isLastCharLower = false;
      let isLastCharUpper = false;
      let isLastLastCharUpper = false;
      for (let i = 0; i < string3.length; i++) {
        const character = string3[i];
        if (isLastCharLower && UPPERCASE.test(character)) {
          string3 = string3.slice(0, i) + "-" + string3.slice(i);
          isLastCharLower = false;
          isLastLastCharUpper = isLastCharUpper;
          isLastCharUpper = true;
          i++;
        } else if (isLastCharUpper && isLastLastCharUpper && LOWERCASE.test(character)) {
          string3 = string3.slice(0, i - 1) + "-" + string3.slice(i - 1);
          isLastLastCharUpper = isLastCharUpper;
          isLastCharUpper = false;
          isLastCharLower = true;
        } else {
          isLastCharLower = toLowerCase(character) === character && toUpperCase(character) !== character;
          isLastLastCharUpper = isLastCharUpper;
          isLastCharUpper = toUpperCase(character) === character && toLowerCase(character) !== character;
        }
      }
      return string3;
    };
    var preserveConsecutiveUppercase = (input, toLowerCase) => {
      LEADING_CAPITAL.lastIndex = 0;
      return input.replace(LEADING_CAPITAL, (m1) => toLowerCase(m1));
    };
    var postProcess = (input, toUpperCase) => {
      SEPARATORS_AND_IDENTIFIER.lastIndex = 0;
      NUMBERS_AND_IDENTIFIER.lastIndex = 0;
      return input.replace(SEPARATORS_AND_IDENTIFIER, (_, identifier) => toUpperCase(identifier)).replace(NUMBERS_AND_IDENTIFIER, (m) => toUpperCase(m));
    };
    var camelCase2 = (input, options) => {
      if (!(typeof input === "string" || Array.isArray(input))) {
        throw new TypeError("Expected the input to be `string | string[]`");
      }
      options = {
        pascalCase: false,
        preserveConsecutiveUppercase: false,
        ...options
      };
      if (Array.isArray(input)) {
        input = input.map((x) => x.trim()).filter((x) => x.length).join("-");
      } else {
        input = input.trim();
      }
      if (input.length === 0) {
        return "";
      }
      const toLowerCase = options.locale === false ? (string3) => string3.toLowerCase() : (string3) => string3.toLocaleLowerCase(options.locale);
      const toUpperCase = options.locale === false ? (string3) => string3.toUpperCase() : (string3) => string3.toLocaleUpperCase(options.locale);
      if (input.length === 1) {
        return options.pascalCase ? toUpperCase(input) : toLowerCase(input);
      }
      const hasUpperCase = input !== toLowerCase(input);
      if (hasUpperCase) {
        input = preserveCamelCase(input, toLowerCase, toUpperCase);
      }
      input = input.replace(LEADING_SEPARATORS, "");
      if (options.preserveConsecutiveUppercase) {
        input = preserveConsecutiveUppercase(input, toLowerCase);
      } else {
        input = toLowerCase(input);
      }
      if (options.pascalCase) {
        input = toUpperCase(input.charAt(0)) + input.slice(1);
      }
      return postProcess(input, toUpperCase);
    };
    module2.exports = camelCase2;
    module2.exports.default = camelCase2;
  }
});

// node_modules/buffer-layout/lib/Layout.js
var require_Layout2 = __commonJS({
  "node_modules/buffer-layout/lib/Layout.js"(exports2) {
    "use strict";
    var Layout5 = class {
      constructor(span, property) {
        if (!Number.isInteger(span)) {
          throw new TypeError("span must be an integer");
        }
        this.span = span;
        this.property = property;
      }
      /** Function to create an Object into which decoded properties will
       * be written.
       *
       * Used only for layouts that {@link Layout#decode|decode} to Object
       * instances, which means:
       * * {@link Structure}
       * * {@link Union}
       * * {@link VariantLayout}
       * * {@link BitStructure}
       *
       * If left undefined the JavaScript representation of these layouts
       * will be Object instances.
       *
       * See {@link bindConstructorLayout}.
       */
      makeDestinationObject() {
        return {};
      }
      /**
       * Decode from a Buffer into an JavaScript value.
       *
       * @param {Buffer} b - the buffer from which encoded data is read.
       *
       * @param {Number} [offset] - the offset at which the encoded data
       * starts.  If absent a zero offset is inferred.
       *
       * @returns {(Number|Array|Object)} - the value of the decoded data.
       *
       * @abstract
       */
      decode(b, offset3) {
        throw new Error("Layout is abstract");
      }
      /**
       * Encode a JavaScript value into a Buffer.
       *
       * @param {(Number|Array|Object)} src - the value to be encoded into
       * the buffer.  The type accepted depends on the (sub-)type of {@link
       * Layout}.
       *
       * @param {Buffer} b - the buffer into which encoded data will be
       * written.
       *
       * @param {Number} [offset] - the offset at which the encoded data
       * starts.  If absent a zero offset is inferred.
       *
       * @returns {Number} - the number of bytes encoded, including the
       * space skipped for internal padding, but excluding data such as
       * {@link Sequence#count|lengths} when stored {@link
       * ExternalLayout|externally}.  This is the adjustment to `offset`
       * producing the offset where data for the next layout would be
       * written.
       *
       * @abstract
       */
      encode(src2, b, offset3) {
        throw new Error("Layout is abstract");
      }
      /**
       * Calculate the span of a specific instance of a layout.
       *
       * @param {Buffer} b - the buffer that contains an encoded instance.
       *
       * @param {Number} [offset] - the offset at which the encoded instance
       * starts.  If absent a zero offset is inferred.
       *
       * @return {Number} - the number of bytes covered by the layout
       * instance.  If this method is not overridden in a subclass the
       * definition-time constant {@link Layout#span|span} will be
       * returned.
       *
       * @throws {RangeError} - if the length of the value cannot be
       * determined.
       */
      getSpan(b, offset3) {
        if (0 > this.span) {
          throw new RangeError("indeterminate span");
        }
        return this.span;
      }
      /**
       * Replicate the layout using a new property.
       *
       * This function must be used to get a structurally-equivalent layout
       * with a different name since all {@link Layout} instances are
       * immutable.
       *
       * **NOTE** This is a shallow copy.  All fields except {@link
       * Layout#property|property} are strictly equal to the origin layout.
       *
       * @param {String} property - the value for {@link
       * Layout#property|property} in the replica.
       *
       * @returns {Layout} - the copy with {@link Layout#property|property}
       * set to `property`.
       */
      replicate(property) {
        const rv = Object.create(this.constructor.prototype);
        Object.assign(rv, this);
        rv.property = property;
        return rv;
      }
      /**
       * Create an object from layout properties and an array of values.
       *
       * **NOTE** This function returns `undefined` if invoked on a layout
       * that does not return its value as an Object.  Objects are
       * returned for things that are a {@link Structure}, which includes
       * {@link VariantLayout|variant layouts} if they are structures, and
       * excludes {@link Union}s.  If you want this feature for a union
       * you must use {@link Union.getVariant|getVariant} to select the
       * desired layout.
       *
       * @param {Array} values - an array of values that correspond to the
       * default order for properties.  As with {@link Layout#decode|decode}
       * layout elements that have no property name are skipped when
       * iterating over the array values.  Only the top-level properties are
       * assigned; arguments are not assigned to properties of contained
       * layouts.  Any unused values are ignored.
       *
       * @return {(Object|undefined)}
       */
      fromArray(values) {
        return void 0;
      }
    };
    exports2.Layout = Layout5;
    function nameWithProperty2(name, lo) {
      if (lo.property) {
        return name + "[" + lo.property + "]";
      }
      return name;
    }
    exports2.nameWithProperty = nameWithProperty2;
    function bindConstructorLayout(Class, layout) {
      if ("function" !== typeof Class) {
        throw new TypeError("Class must be constructor");
      }
      if (Class.hasOwnProperty("layout_")) {
        throw new Error("Class is already bound to a layout");
      }
      if (!(layout && layout instanceof Layout5)) {
        throw new TypeError("layout must be a Layout");
      }
      if (layout.hasOwnProperty("boundConstructor_")) {
        throw new Error("layout is already bound to a constructor");
      }
      Class.layout_ = layout;
      layout.boundConstructor_ = Class;
      layout.makeDestinationObject = (() => new Class());
      Object.defineProperty(Class.prototype, "encode", {
        value: function(b, offset3) {
          return layout.encode(this, b, offset3);
        },
        writable: true
      });
      Object.defineProperty(Class, "decode", {
        value: function(b, offset3) {
          return layout.decode(b, offset3);
        },
        writable: true
      });
    }
    exports2.bindConstructorLayout = bindConstructorLayout;
    var ExternalLayout2 = class extends Layout5 {
      /**
       * Return `true` iff the external layout decodes to an unsigned
       * integer layout.
       *
       * In that case it can be used as the source of {@link
       * Sequence#count|Sequence counts}, {@link Blob#length|Blob lengths},
       * or as {@link UnionLayoutDiscriminator#layout|external union
       * discriminators}.
       *
       * @abstract
       */
      isCount() {
        throw new Error("ExternalLayout is abstract");
      }
    };
    var GreedyCount = class extends ExternalLayout2 {
      constructor(elementSpan, property) {
        if (void 0 === elementSpan) {
          elementSpan = 1;
        }
        if (!Number.isInteger(elementSpan) || 0 >= elementSpan) {
          throw new TypeError("elementSpan must be a (positive) integer");
        }
        super(-1, property);
        this.elementSpan = elementSpan;
      }
      /** @override */
      isCount() {
        return true;
      }
      /** @override */
      decode(b, offset3) {
        if (void 0 === offset3) {
          offset3 = 0;
        }
        const rem = b.length - offset3;
        return Math.floor(rem / this.elementSpan);
      }
      /** @override */
      encode(src2, b, offset3) {
        return 0;
      }
    };
    var OffsetLayout2 = class extends ExternalLayout2 {
      constructor(layout, offset3, property) {
        if (!(layout instanceof Layout5)) {
          throw new TypeError("layout must be a Layout");
        }
        if (void 0 === offset3) {
          offset3 = 0;
        } else if (!Number.isInteger(offset3)) {
          throw new TypeError("offset must be integer or undefined");
        }
        super(layout.span, property || layout.property);
        this.layout = layout;
        this.offset = offset3;
      }
      /** @override */
      isCount() {
        return this.layout instanceof UInt2 || this.layout instanceof UIntBE2;
      }
      /** @override */
      decode(b, offset3) {
        if (void 0 === offset3) {
          offset3 = 0;
        }
        return this.layout.decode(b, offset3 + this.offset);
      }
      /** @override */
      encode(src2, b, offset3) {
        if (void 0 === offset3) {
          offset3 = 0;
        }
        return this.layout.encode(src2, b, offset3 + this.offset);
      }
    };
    var UInt2 = class extends Layout5 {
      constructor(span, property) {
        super(span, property);
        if (6 < this.span) {
          throw new RangeError("span must not exceed 6 bytes");
        }
      }
      /** @override */
      decode(b, offset3) {
        if (void 0 === offset3) {
          offset3 = 0;
        }
        return b.readUIntLE(offset3, this.span);
      }
      /** @override */
      encode(src2, b, offset3) {
        if (void 0 === offset3) {
          offset3 = 0;
        }
        b.writeUIntLE(src2, offset3, this.span);
        return this.span;
      }
    };
    var UIntBE2 = class extends Layout5 {
      constructor(span, property) {
        super(span, property);
        if (6 < this.span) {
          throw new RangeError("span must not exceed 6 bytes");
        }
      }
      /** @override */
      decode(b, offset3) {
        if (void 0 === offset3) {
          offset3 = 0;
        }
        return b.readUIntBE(offset3, this.span);
      }
      /** @override */
      encode(src2, b, offset3) {
        if (void 0 === offset3) {
          offset3 = 0;
        }
        b.writeUIntBE(src2, offset3, this.span);
        return this.span;
      }
    };
    var Int = class extends Layout5 {
      constructor(span, property) {
        super(span, property);
        if (6 < this.span) {
          throw new RangeError("span must not exceed 6 bytes");
        }
      }
      /** @override */
      decode(b, offset3) {
        if (void 0 === offset3) {
          offset3 = 0;
        }
        return b.readIntLE(offset3, this.span);
      }
      /** @override */
      encode(src2, b, offset3) {
        if (void 0 === offset3) {
          offset3 = 0;
        }
        b.writeIntLE(src2, offset3, this.span);
        return this.span;
      }
    };
    var IntBE = class extends Layout5 {
      constructor(span, property) {
        super(span, property);
        if (6 < this.span) {
          throw new RangeError("span must not exceed 6 bytes");
        }
      }
      /** @override */
      decode(b, offset3) {
        if (void 0 === offset3) {
          offset3 = 0;
        }
        return b.readIntBE(offset3, this.span);
      }
      /** @override */
      encode(src2, b, offset3) {
        if (void 0 === offset3) {
          offset3 = 0;
        }
        b.writeIntBE(src2, offset3, this.span);
        return this.span;
      }
    };
    var V2E322 = Math.pow(2, 32);
    function divmodInt642(src2) {
      const hi32 = Math.floor(src2 / V2E322);
      const lo32 = src2 - hi32 * V2E322;
      return { hi32, lo32 };
    }
    function roundedInt642(hi32, lo32) {
      return hi32 * V2E322 + lo32;
    }
    var NearUInt642 = class extends Layout5 {
      constructor(property) {
        super(8, property);
      }
      /** @override */
      decode(b, offset3) {
        if (void 0 === offset3) {
          offset3 = 0;
        }
        const lo32 = b.readUInt32LE(offset3);
        const hi32 = b.readUInt32LE(offset3 + 4);
        return roundedInt642(hi32, lo32);
      }
      /** @override */
      encode(src2, b, offset3) {
        if (void 0 === offset3) {
          offset3 = 0;
        }
        const split6 = divmodInt642(src2);
        b.writeUInt32LE(split6.lo32, offset3);
        b.writeUInt32LE(split6.hi32, offset3 + 4);
        return 8;
      }
    };
    var NearUInt64BE = class extends Layout5 {
      constructor(property) {
        super(8, property);
      }
      /** @override */
      decode(b, offset3) {
        if (void 0 === offset3) {
          offset3 = 0;
        }
        const hi32 = b.readUInt32BE(offset3);
        const lo32 = b.readUInt32BE(offset3 + 4);
        return roundedInt642(hi32, lo32);
      }
      /** @override */
      encode(src2, b, offset3) {
        if (void 0 === offset3) {
          offset3 = 0;
        }
        const split6 = divmodInt642(src2);
        b.writeUInt32BE(split6.hi32, offset3);
        b.writeUInt32BE(split6.lo32, offset3 + 4);
        return 8;
      }
    };
    var NearInt642 = class extends Layout5 {
      constructor(property) {
        super(8, property);
      }
      /** @override */
      decode(b, offset3) {
        if (void 0 === offset3) {
          offset3 = 0;
        }
        const lo32 = b.readUInt32LE(offset3);
        const hi32 = b.readInt32LE(offset3 + 4);
        return roundedInt642(hi32, lo32);
      }
      /** @override */
      encode(src2, b, offset3) {
        if (void 0 === offset3) {
          offset3 = 0;
        }
        const split6 = divmodInt642(src2);
        b.writeUInt32LE(split6.lo32, offset3);
        b.writeInt32LE(split6.hi32, offset3 + 4);
        return 8;
      }
    };
    var NearInt64BE = class extends Layout5 {
      constructor(property) {
        super(8, property);
      }
      /** @override */
      decode(b, offset3) {
        if (void 0 === offset3) {
          offset3 = 0;
        }
        const hi32 = b.readInt32BE(offset3);
        const lo32 = b.readUInt32BE(offset3 + 4);
        return roundedInt642(hi32, lo32);
      }
      /** @override */
      encode(src2, b, offset3) {
        if (void 0 === offset3) {
          offset3 = 0;
        }
        const split6 = divmodInt642(src2);
        b.writeInt32BE(split6.hi32, offset3);
        b.writeUInt32BE(split6.lo32, offset3 + 4);
        return 8;
      }
    };
    var Float = class extends Layout5 {
      constructor(property) {
        super(4, property);
      }
      /** @override */
      decode(b, offset3) {
        if (void 0 === offset3) {
          offset3 = 0;
        }
        return b.readFloatLE(offset3);
      }
      /** @override */
      encode(src2, b, offset3) {
        if (void 0 === offset3) {
          offset3 = 0;
        }
        b.writeFloatLE(src2, offset3);
        return 4;
      }
    };
    var FloatBE = class extends Layout5 {
      constructor(property) {
        super(4, property);
      }
      /** @override */
      decode(b, offset3) {
        if (void 0 === offset3) {
          offset3 = 0;
        }
        return b.readFloatBE(offset3);
      }
      /** @override */
      encode(src2, b, offset3) {
        if (void 0 === offset3) {
          offset3 = 0;
        }
        b.writeFloatBE(src2, offset3);
        return 4;
      }
    };
    var Double = class extends Layout5 {
      constructor(property) {
        super(8, property);
      }
      /** @override */
      decode(b, offset3) {
        if (void 0 === offset3) {
          offset3 = 0;
        }
        return b.readDoubleLE(offset3);
      }
      /** @override */
      encode(src2, b, offset3) {
        if (void 0 === offset3) {
          offset3 = 0;
        }
        b.writeDoubleLE(src2, offset3);
        return 8;
      }
    };
    var DoubleBE = class extends Layout5 {
      constructor(property) {
        super(8, property);
      }
      /** @override */
      decode(b, offset3) {
        if (void 0 === offset3) {
          offset3 = 0;
        }
        return b.readDoubleBE(offset3);
      }
      /** @override */
      encode(src2, b, offset3) {
        if (void 0 === offset3) {
          offset3 = 0;
        }
        b.writeDoubleBE(src2, offset3);
        return 8;
      }
    };
    var Sequence = class extends Layout5 {
      constructor(elementLayout, count, property) {
        if (!(elementLayout instanceof Layout5)) {
          throw new TypeError("elementLayout must be a Layout");
        }
        if (!(count instanceof ExternalLayout2 && count.isCount() || Number.isInteger(count) && 0 <= count)) {
          throw new TypeError("count must be non-negative integer or an unsigned integer ExternalLayout");
        }
        let span = -1;
        if (!(count instanceof ExternalLayout2) && 0 < elementLayout.span) {
          span = count * elementLayout.span;
        }
        super(span, property);
        this.elementLayout = elementLayout;
        this.count = count;
      }
      /** @override */
      getSpan(b, offset3) {
        if (0 <= this.span) {
          return this.span;
        }
        if (void 0 === offset3) {
          offset3 = 0;
        }
        let span = 0;
        let count = this.count;
        if (count instanceof ExternalLayout2) {
          count = count.decode(b, offset3);
        }
        if (0 < this.elementLayout.span) {
          span = count * this.elementLayout.span;
        } else {
          let idx = 0;
          while (idx < count) {
            span += this.elementLayout.getSpan(b, offset3 + span);
            ++idx;
          }
        }
        return span;
      }
      /** @override */
      decode(b, offset3) {
        if (void 0 === offset3) {
          offset3 = 0;
        }
        const rv = [];
        let i = 0;
        let count = this.count;
        if (count instanceof ExternalLayout2) {
          count = count.decode(b, offset3);
        }
        while (i < count) {
          rv.push(this.elementLayout.decode(b, offset3));
          offset3 += this.elementLayout.getSpan(b, offset3);
          i += 1;
        }
        return rv;
      }
      /** Implement {@link Layout#encode|encode} for {@link Sequence}.
       *
       * **NOTE** If `src` is shorter than {@link Sequence#count|count} then
       * the unused space in the buffer is left unchanged.  If `src` is
       * longer than {@link Sequence#count|count} the unneeded elements are
       * ignored.
       *
       * **NOTE** If {@link Layout#count|count} is an instance of {@link
       * ExternalLayout} then the length of `src` will be encoded as the
       * count after `src` is encoded. */
      encode(src2, b, offset3) {
        if (void 0 === offset3) {
          offset3 = 0;
        }
        const elo = this.elementLayout;
        const span = src2.reduce((span2, v) => {
          return span2 + elo.encode(v, b, offset3 + span2);
        }, 0);
        if (this.count instanceof ExternalLayout2) {
          this.count.encode(src2.length, b, offset3);
        }
        return span;
      }
    };
    var Structure2 = class extends Layout5 {
      constructor(fields, property, decodePrefixes) {
        if (!(Array.isArray(fields) && fields.reduce((acc, v) => acc && v instanceof Layout5, true))) {
          throw new TypeError("fields must be array of Layout instances");
        }
        if ("boolean" === typeof property && void 0 === decodePrefixes) {
          decodePrefixes = property;
          property = void 0;
        }
        for (const fd of fields) {
          if (0 > fd.span && void 0 === fd.property) {
            throw new Error("fields cannot contain unnamed variable-length layout");
          }
        }
        let span = -1;
        try {
          span = fields.reduce((span2, fd) => span2 + fd.getSpan(), 0);
        } catch (e) {
        }
        super(span, property);
        this.fields = fields;
        this.decodePrefixes = !!decodePrefixes;
      }
      /** @override */
      getSpan(b, offset3) {
        if (0 <= this.span) {
          return this.span;
        }
        if (void 0 === offset3) {
          offset3 = 0;
        }
        let span = 0;
        try {
          span = this.fields.reduce((span2, fd) => {
            const fsp = fd.getSpan(b, offset3);
            offset3 += fsp;
            return span2 + fsp;
          }, 0);
        } catch (e) {
          throw new RangeError("indeterminate span");
        }
        return span;
      }
      /** @override */
      decode(b, offset3) {
        if (void 0 === offset3) {
          offset3 = 0;
        }
        const dest = this.makeDestinationObject();
        for (const fd of this.fields) {
          if (void 0 !== fd.property) {
            dest[fd.property] = fd.decode(b, offset3);
          }
          offset3 += fd.getSpan(b, offset3);
          if (this.decodePrefixes && b.length === offset3) {
            break;
          }
        }
        return dest;
      }
      /** Implement {@link Layout#encode|encode} for {@link Structure}.
       *
       * If `src` is missing a property for a member with a defined {@link
       * Layout#property|property} the corresponding region of the buffer is
       * left unmodified. */
      encode(src2, b, offset3) {
        if (void 0 === offset3) {
          offset3 = 0;
        }
        const firstOffset = offset3;
        let lastOffset = 0;
        let lastWrote = 0;
        for (const fd of this.fields) {
          let span = fd.span;
          lastWrote = 0 < span ? span : 0;
          if (void 0 !== fd.property) {
            const fv = src2[fd.property];
            if (void 0 !== fv) {
              lastWrote = fd.encode(fv, b, offset3);
              if (0 > span) {
                span = fd.getSpan(b, offset3);
              }
            }
          }
          lastOffset = offset3;
          offset3 += span;
        }
        return lastOffset + lastWrote - firstOffset;
      }
      /** @override */
      fromArray(values) {
        const dest = this.makeDestinationObject();
        for (const fd of this.fields) {
          if (void 0 !== fd.property && 0 < values.length) {
            dest[fd.property] = values.shift();
          }
        }
        return dest;
      }
      /**
       * Get access to the layout of a given property.
       *
       * @param {String} property - the structure member of interest.
       *
       * @return {Layout} - the layout associated with `property`, or
       * undefined if there is no such property.
       */
      layoutFor(property) {
        if ("string" !== typeof property) {
          throw new TypeError("property must be string");
        }
        for (const fd of this.fields) {
          if (fd.property === property) {
            return fd;
          }
        }
      }
      /**
       * Get the offset of a structure member.
       *
       * @param {String} property - the structure member of interest.
       *
       * @return {Number} - the offset in bytes to the start of `property`
       * within the structure, or undefined if `property` is not a field
       * within the structure.  If the property is a member but follows a
       * variable-length structure member a negative number will be
       * returned.
       */
      offsetOf(property) {
        if ("string" !== typeof property) {
          throw new TypeError("property must be string");
        }
        let offset3 = 0;
        for (const fd of this.fields) {
          if (fd.property === property) {
            return offset3;
          }
          if (0 > fd.span) {
            offset3 = -1;
          } else if (0 <= offset3) {
            offset3 += fd.span;
          }
        }
      }
    };
    var UnionDiscriminator2 = class {
      constructor(property) {
        this.property = property;
      }
      /** Analog to {@link Layout#decode|Layout decode} for union discriminators.
       *
       * The implementation of this method need not reference the buffer if
       * variant information is available through other means. */
      decode() {
        throw new Error("UnionDiscriminator is abstract");
      }
      /** Analog to {@link Layout#decode|Layout encode} for union discriminators.
       *
       * The implementation of this method need not store the value if
       * variant information is maintained through other means. */
      encode() {
        throw new Error("UnionDiscriminator is abstract");
      }
    };
    var UnionLayoutDiscriminator2 = class extends UnionDiscriminator2 {
      constructor(layout, property) {
        if (!(layout instanceof ExternalLayout2 && layout.isCount())) {
          throw new TypeError("layout must be an unsigned integer ExternalLayout");
        }
        super(property || layout.property || "variant");
        this.layout = layout;
      }
      /** Delegate decoding to {@link UnionLayoutDiscriminator#layout|layout}. */
      decode(b, offset3) {
        return this.layout.decode(b, offset3);
      }
      /** Delegate encoding to {@link UnionLayoutDiscriminator#layout|layout}. */
      encode(src2, b, offset3) {
        return this.layout.encode(src2, b, offset3);
      }
    };
    var Union2 = class extends Layout5 {
      constructor(discr, defaultLayout, property) {
        const upv = discr instanceof UInt2 || discr instanceof UIntBE2;
        if (upv) {
          discr = new UnionLayoutDiscriminator2(new OffsetLayout2(discr));
        } else if (discr instanceof ExternalLayout2 && discr.isCount()) {
          discr = new UnionLayoutDiscriminator2(discr);
        } else if (!(discr instanceof UnionDiscriminator2)) {
          throw new TypeError("discr must be a UnionDiscriminator or an unsigned integer layout");
        }
        if (void 0 === defaultLayout) {
          defaultLayout = null;
        }
        if (!(null === defaultLayout || defaultLayout instanceof Layout5)) {
          throw new TypeError("defaultLayout must be null or a Layout");
        }
        if (null !== defaultLayout) {
          if (0 > defaultLayout.span) {
            throw new Error("defaultLayout must have constant span");
          }
          if (void 0 === defaultLayout.property) {
            defaultLayout = defaultLayout.replicate("content");
          }
        }
        let span = -1;
        if (defaultLayout) {
          span = defaultLayout.span;
          if (0 <= span && upv) {
            span += discr.layout.span;
          }
        }
        super(span, property);
        this.discriminator = discr;
        this.usesPrefixDiscriminator = upv;
        this.defaultLayout = defaultLayout;
        this.registry = {};
        let boundGetSourceVariant = this.defaultGetSourceVariant.bind(this);
        this.getSourceVariant = function(src2) {
          return boundGetSourceVariant(src2);
        };
        this.configGetSourceVariant = function(gsv) {
          boundGetSourceVariant = gsv.bind(this);
        };
      }
      /** @override */
      getSpan(b, offset3) {
        if (0 <= this.span) {
          return this.span;
        }
        if (void 0 === offset3) {
          offset3 = 0;
        }
        const vlo = this.getVariant(b, offset3);
        if (!vlo) {
          throw new Error("unable to determine span for unrecognized variant");
        }
        return vlo.getSpan(b, offset3);
      }
      /**
       * Method to infer a registered Union variant compatible with `src`.
       *
       * The first satisified rule in the following sequence defines the
       * return value:
       * * If `src` has properties matching the Union discriminator and
       *   the default layout, `undefined` is returned regardless of the
       *   value of the discriminator property (this ensures the default
       *   layout will be used);
       * * If `src` has a property matching the Union discriminator, the
       *   value of the discriminator identifies a registered variant, and
       *   either (a) the variant has no layout, or (b) `src` has the
       *   variant's property, then the variant is returned (because the
       *   source satisfies the constraints of the variant it identifies);
       * * If `src` does not have a property matching the Union
       *   discriminator, but does have a property matching a registered
       *   variant, then the variant is returned (because the source
       *   matches a variant without an explicit conflict);
       * * An error is thrown (because we either can't identify a variant,
       *   or we were explicitly told the variant but can't satisfy it).
       *
       * @param {Object} src - an object presumed to be compatible with
       * the content of the Union.
       *
       * @return {(undefined|VariantLayout)} - as described above.
       *
       * @throws {Error} - if `src` cannot be associated with a default or
       * registered variant.
       */
      defaultGetSourceVariant(src2) {
        if (src2.hasOwnProperty(this.discriminator.property)) {
          if (this.defaultLayout && src2.hasOwnProperty(this.defaultLayout.property)) {
            return void 0;
          }
          const vlo = this.registry[src2[this.discriminator.property]];
          if (vlo && (!vlo.layout || src2.hasOwnProperty(vlo.property))) {
            return vlo;
          }
        } else {
          for (const tag in this.registry) {
            const vlo = this.registry[tag];
            if (src2.hasOwnProperty(vlo.property)) {
              return vlo;
            }
          }
        }
        throw new Error("unable to infer src variant");
      }
      /** Implement {@link Layout#decode|decode} for {@link Union}.
       *
       * If the variant is {@link Union#addVariant|registered} the return
       * value is an instance of that variant, with no explicit
       * discriminator.  Otherwise the {@link Union#defaultLayout|default
       * layout} is used to decode the content. */
      decode(b, offset3) {
        if (void 0 === offset3) {
          offset3 = 0;
        }
        let dest;
        const dlo = this.discriminator;
        const discr = dlo.decode(b, offset3);
        let clo = this.registry[discr];
        if (void 0 === clo) {
          let contentOffset = 0;
          clo = this.defaultLayout;
          if (this.usesPrefixDiscriminator) {
            contentOffset = dlo.layout.span;
          }
          dest = this.makeDestinationObject();
          dest[dlo.property] = discr;
          dest[clo.property] = this.defaultLayout.decode(b, offset3 + contentOffset);
        } else {
          dest = clo.decode(b, offset3);
        }
        return dest;
      }
      /** Implement {@link Layout#encode|encode} for {@link Union}.
       *
       * This API assumes the `src` object is consistent with the union's
       * {@link Union#defaultLayout|default layout}.  To encode variants
       * use the appropriate variant-specific {@link VariantLayout#encode}
       * method. */
      encode(src2, b, offset3) {
        if (void 0 === offset3) {
          offset3 = 0;
        }
        const vlo = this.getSourceVariant(src2);
        if (void 0 === vlo) {
          const dlo = this.discriminator;
          const clo = this.defaultLayout;
          let contentOffset = 0;
          if (this.usesPrefixDiscriminator) {
            contentOffset = dlo.layout.span;
          }
          dlo.encode(src2[dlo.property], b, offset3);
          return contentOffset + clo.encode(
            src2[clo.property],
            b,
            offset3 + contentOffset
          );
        }
        return vlo.encode(src2, b, offset3);
      }
      /** Register a new variant structure within a union.  The newly
       * created variant is returned.
       *
       * @param {Number} variant - initializer for {@link
       * VariantLayout#variant|variant}.
       *
       * @param {Layout} layout - initializer for {@link
       * VariantLayout#layout|layout}.
       *
       * @param {String} property - initializer for {@link
       * Layout#property|property}.
       *
       * @return {VariantLayout} */
      addVariant(variant, layout, property) {
        const rv = new VariantLayout2(this, variant, layout, property);
        this.registry[variant] = rv;
        return rv;
      }
      /**
       * Get the layout associated with a registered variant.
       *
       * If `vb` does not produce a registered variant the function returns
       * `undefined`.
       *
       * @param {(Number|Buffer)} vb - either the variant number, or a
       * buffer from which the discriminator is to be read.
       *
       * @param {Number} offset - offset into `vb` for the start of the
       * union.  Used only when `vb` is an instance of {Buffer}.
       *
       * @return {({VariantLayout}|undefined)}
       */
      getVariant(vb, offset3) {
        let variant = vb;
        if (Buffer.isBuffer(vb)) {
          if (void 0 === offset3) {
            offset3 = 0;
          }
          variant = this.discriminator.decode(vb, offset3);
        }
        return this.registry[variant];
      }
    };
    var VariantLayout2 = class extends Layout5 {
      constructor(union3, variant, layout, property) {
        if (!(union3 instanceof Union2)) {
          throw new TypeError("union must be a Union");
        }
        if (!Number.isInteger(variant) || 0 > variant) {
          throw new TypeError("variant must be a (non-negative) integer");
        }
        if ("string" === typeof layout && void 0 === property) {
          property = layout;
          layout = null;
        }
        if (layout) {
          if (!(layout instanceof Layout5)) {
            throw new TypeError("layout must be a Layout");
          }
          if (null !== union3.defaultLayout && 0 <= layout.span && layout.span > union3.defaultLayout.span) {
            throw new Error("variant span exceeds span of containing union");
          }
          if ("string" !== typeof property) {
            throw new TypeError("variant must have a String property");
          }
        }
        let span = union3.span;
        if (0 > union3.span) {
          span = layout ? layout.span : 0;
          if (0 <= span && union3.usesPrefixDiscriminator) {
            span += union3.discriminator.layout.span;
          }
        }
        super(span, property);
        this.union = union3;
        this.variant = variant;
        this.layout = layout || null;
      }
      /** @override */
      getSpan(b, offset3) {
        if (0 <= this.span) {
          return this.span;
        }
        if (void 0 === offset3) {
          offset3 = 0;
        }
        let contentOffset = 0;
        if (this.union.usesPrefixDiscriminator) {
          contentOffset = this.union.discriminator.layout.span;
        }
        return contentOffset + this.layout.getSpan(b, offset3 + contentOffset);
      }
      /** @override */
      decode(b, offset3) {
        const dest = this.makeDestinationObject();
        if (void 0 === offset3) {
          offset3 = 0;
        }
        if (this !== this.union.getVariant(b, offset3)) {
          throw new Error("variant mismatch");
        }
        let contentOffset = 0;
        if (this.union.usesPrefixDiscriminator) {
          contentOffset = this.union.discriminator.layout.span;
        }
        if (this.layout) {
          dest[this.property] = this.layout.decode(b, offset3 + contentOffset);
        } else if (this.property) {
          dest[this.property] = true;
        } else if (this.union.usesPrefixDiscriminator) {
          dest[this.union.discriminator.property] = this.variant;
        }
        return dest;
      }
      /** @override */
      encode(src2, b, offset3) {
        if (void 0 === offset3) {
          offset3 = 0;
        }
        let contentOffset = 0;
        if (this.union.usesPrefixDiscriminator) {
          contentOffset = this.union.discriminator.layout.span;
        }
        if (this.layout && !src2.hasOwnProperty(this.property)) {
          throw new TypeError("variant lacks property " + this.property);
        }
        this.union.discriminator.encode(this.variant, b, offset3);
        let span = contentOffset;
        if (this.layout) {
          this.layout.encode(src2[this.property], b, offset3 + contentOffset);
          span += this.layout.getSpan(b, offset3 + contentOffset);
          if (0 <= this.union.span && span > this.union.span) {
            throw new Error("encoded variant overruns containing union");
          }
        }
        return span;
      }
      /** Delegate {@link Layout#fromArray|fromArray} to {@link
       * VariantLayout#layout|layout}. */
      fromArray(values) {
        if (this.layout) {
          return this.layout.fromArray(values);
        }
      }
    };
    function fixBitwiseResult(v) {
      if (0 > v) {
        v += 4294967296;
      }
      return v;
    }
    var BitStructure = class extends Layout5 {
      constructor(word, msb, property) {
        if (!(word instanceof UInt2 || word instanceof UIntBE2)) {
          throw new TypeError("word must be a UInt or UIntBE layout");
        }
        if ("string" === typeof msb && void 0 === property) {
          property = msb;
          msb = void 0;
        }
        if (4 < word.span) {
          throw new RangeError("word cannot exceed 32 bits");
        }
        super(word.span, property);
        this.word = word;
        this.msb = !!msb;
        this.fields = [];
        let value = 0;
        this._packedSetValue = function(v) {
          value = fixBitwiseResult(v);
          return this;
        };
        this._packedGetValue = function() {
          return value;
        };
      }
      /** @override */
      decode(b, offset3) {
        const dest = this.makeDestinationObject();
        if (void 0 === offset3) {
          offset3 = 0;
        }
        const value = this.word.decode(b, offset3);
        this._packedSetValue(value);
        for (const fd of this.fields) {
          if (void 0 !== fd.property) {
            dest[fd.property] = fd.decode(value);
          }
        }
        return dest;
      }
      /** Implement {@link Layout#encode|encode} for {@link BitStructure}.
       *
       * If `src` is missing a property for a member with a defined {@link
       * Layout#property|property} the corresponding region of the packed
       * value is left unmodified.  Unused bits are also left unmodified. */
      encode(src2, b, offset3) {
        if (void 0 === offset3) {
          offset3 = 0;
        }
        const value = this.word.decode(b, offset3);
        this._packedSetValue(value);
        for (const fd of this.fields) {
          if (void 0 !== fd.property) {
            const fv = src2[fd.property];
            if (void 0 !== fv) {
              fd.encode(fv);
            }
          }
        }
        return this.word.encode(this._packedGetValue(), b, offset3);
      }
      /** Register a new bitfield with a containing bit structure.  The
       * resulting bitfield is returned.
       *
       * @param {Number} bits - initializer for {@link BitField#bits|bits}.
       *
       * @param {string} property - initializer for {@link
       * Layout#property|property}.
       *
       * @return {BitField} */
      addField(bits, property) {
        const bf = new BitField(this, bits, property);
        this.fields.push(bf);
        return bf;
      }
      /** As with {@link BitStructure#addField|addField} for single-bit
       * fields with `boolean` value representation.
       *
       * @param {string} property - initializer for {@link
       * Layout#property|property}.
       *
       * @return {Boolean} */
      addBoolean(property) {
        const bf = new Boolean2(this, property);
        this.fields.push(bf);
        return bf;
      }
      /**
       * Get access to the bit field for a given property.
       *
       * @param {String} property - the bit field of interest.
       *
       * @return {BitField} - the field associated with `property`, or
       * undefined if there is no such property.
       */
      fieldFor(property) {
        if ("string" !== typeof property) {
          throw new TypeError("property must be string");
        }
        for (const fd of this.fields) {
          if (fd.property === property) {
            return fd;
          }
        }
      }
    };
    var BitField = class {
      constructor(container, bits, property) {
        if (!(container instanceof BitStructure)) {
          throw new TypeError("container must be a BitStructure");
        }
        if (!Number.isInteger(bits) || 0 >= bits) {
          throw new TypeError("bits must be positive integer");
        }
        const totalBits = 8 * container.span;
        const usedBits = container.fields.reduce((sum, fd) => sum + fd.bits, 0);
        if (bits + usedBits > totalBits) {
          throw new Error("bits too long for span remainder (" + (totalBits - usedBits) + " of " + totalBits + " remain)");
        }
        this.container = container;
        this.bits = bits;
        this.valueMask = (1 << bits) - 1;
        if (32 === bits) {
          this.valueMask = 4294967295;
        }
        this.start = usedBits;
        if (this.container.msb) {
          this.start = totalBits - usedBits - bits;
        }
        this.wordMask = fixBitwiseResult(this.valueMask << this.start);
        this.property = property;
      }
      /** Store a value into the corresponding subsequence of the containing
       * bit field. */
      decode() {
        const word = this.container._packedGetValue();
        const wordValue = fixBitwiseResult(word & this.wordMask);
        const value = wordValue >>> this.start;
        return value;
      }
      /** Store a value into the corresponding subsequence of the containing
       * bit field.
       *
       * **NOTE** This is not a specialization of {@link
       * Layout#encode|Layout.encode} and there is no return value. */
      encode(value) {
        if (!Number.isInteger(value) || value !== fixBitwiseResult(value & this.valueMask)) {
          throw new TypeError(nameWithProperty2("BitField.encode", this) + " value must be integer not exceeding " + this.valueMask);
        }
        const word = this.container._packedGetValue();
        const wordValue = fixBitwiseResult(value << this.start);
        this.container._packedSetValue(fixBitwiseResult(word & ~this.wordMask) | wordValue);
      }
    };
    var Boolean2 = class extends BitField {
      constructor(container, property) {
        super(container, 1, property);
      }
      /** Override {@link BitField#decode|decode} for {@link Boolean|Boolean}.
       *
       * @returns {boolean} */
      decode(b, offset3) {
        return !!BitField.prototype.decode.call(this, b, offset3);
      }
      /** @override */
      encode(value) {
        if ("boolean" === typeof value) {
          value = +value;
        }
        return BitField.prototype.encode.call(this, value);
      }
    };
    var Blob2 = class extends Layout5 {
      constructor(length2, property) {
        if (!(length2 instanceof ExternalLayout2 && length2.isCount() || Number.isInteger(length2) && 0 <= length2)) {
          throw new TypeError("length must be positive integer or an unsigned integer ExternalLayout");
        }
        let span = -1;
        if (!(length2 instanceof ExternalLayout2)) {
          span = length2;
        }
        super(span, property);
        this.length = length2;
      }
      /** @override */
      getSpan(b, offset3) {
        let span = this.span;
        if (0 > span) {
          span = this.length.decode(b, offset3);
        }
        return span;
      }
      /** @override */
      decode(b, offset3) {
        if (void 0 === offset3) {
          offset3 = 0;
        }
        let span = this.span;
        if (0 > span) {
          span = this.length.decode(b, offset3);
        }
        return b.slice(offset3, offset3 + span);
      }
      /** Implement {@link Layout#encode|encode} for {@link Blob}.
       *
       * **NOTE** If {@link Layout#count|count} is an instance of {@link
       * ExternalLayout} then the length of `src` will be encoded as the
       * count after `src` is encoded. */
      encode(src2, b, offset3) {
        let span = this.length;
        if (this.length instanceof ExternalLayout2) {
          span = src2.length;
        }
        if (!(Buffer.isBuffer(src2) && span === src2.length)) {
          throw new TypeError(nameWithProperty2("Blob.encode", this) + " requires (length " + span + ") Buffer as src");
        }
        if (offset3 + span > b.length) {
          throw new RangeError("encoding overruns Buffer");
        }
        b.write(src2.toString("hex"), offset3, span, "hex");
        if (this.length instanceof ExternalLayout2) {
          this.length.encode(span, b, offset3);
        }
        return span;
      }
    };
    var CString = class extends Layout5 {
      constructor(property) {
        super(-1, property);
      }
      /** @override */
      getSpan(b, offset3) {
        if (!Buffer.isBuffer(b)) {
          throw new TypeError("b must be a Buffer");
        }
        if (void 0 === offset3) {
          offset3 = 0;
        }
        let idx = offset3;
        while (idx < b.length && 0 !== b[idx]) {
          idx += 1;
        }
        return 1 + idx - offset3;
      }
      /** @override */
      decode(b, offset3, dest) {
        if (void 0 === offset3) {
          offset3 = 0;
        }
        let span = this.getSpan(b, offset3);
        return b.slice(offset3, offset3 + span - 1).toString("utf-8");
      }
      /** @override */
      encode(src2, b, offset3) {
        if (void 0 === offset3) {
          offset3 = 0;
        }
        if ("string" !== typeof src2) {
          src2 = src2.toString();
        }
        const srcb = new Buffer(src2, "utf8");
        const span = srcb.length;
        if (offset3 + span > b.length) {
          throw new RangeError("encoding overruns Buffer");
        }
        srcb.copy(b, offset3);
        b[offset3 + span] = 0;
        return span + 1;
      }
    };
    var UTF8 = class extends Layout5 {
      constructor(maxSpan, property) {
        if ("string" === typeof maxSpan && void 0 === property) {
          property = maxSpan;
          maxSpan = void 0;
        }
        if (void 0 === maxSpan) {
          maxSpan = -1;
        } else if (!Number.isInteger(maxSpan)) {
          throw new TypeError("maxSpan must be an integer");
        }
        super(-1, property);
        this.maxSpan = maxSpan;
      }
      /** @override */
      getSpan(b, offset3) {
        if (!Buffer.isBuffer(b)) {
          throw new TypeError("b must be a Buffer");
        }
        if (void 0 === offset3) {
          offset3 = 0;
        }
        return b.length - offset3;
      }
      /** @override */
      decode(b, offset3, dest) {
        if (void 0 === offset3) {
          offset3 = 0;
        }
        let span = this.getSpan(b, offset3);
        if (0 <= this.maxSpan && this.maxSpan < span) {
          throw new RangeError("text length exceeds maxSpan");
        }
        return b.slice(offset3, offset3 + span).toString("utf-8");
      }
      /** @override */
      encode(src2, b, offset3) {
        if (void 0 === offset3) {
          offset3 = 0;
        }
        if ("string" !== typeof src2) {
          src2 = src2.toString();
        }
        const srcb = new Buffer(src2, "utf8");
        const span = srcb.length;
        if (0 <= this.maxSpan && this.maxSpan < span) {
          throw new RangeError("text length exceeds maxSpan");
        }
        if (offset3 + span > b.length) {
          throw new RangeError("encoding overruns Buffer");
        }
        srcb.copy(b, offset3);
        return span;
      }
    };
    var Constant = class extends Layout5 {
      constructor(value, property) {
        super(0, property);
        this.value = value;
      }
      /** @override */
      decode(b, offset3, dest) {
        return this.value;
      }
      /** @override */
      encode(src2, b, offset3) {
        return 0;
      }
    };
    exports2.ExternalLayout = ExternalLayout2;
    exports2.GreedyCount = GreedyCount;
    exports2.OffsetLayout = OffsetLayout2;
    exports2.UInt = UInt2;
    exports2.UIntBE = UIntBE2;
    exports2.Int = Int;
    exports2.IntBE = IntBE;
    exports2.Float = Float;
    exports2.FloatBE = FloatBE;
    exports2.Double = Double;
    exports2.DoubleBE = DoubleBE;
    exports2.Sequence = Sequence;
    exports2.Structure = Structure2;
    exports2.UnionDiscriminator = UnionDiscriminator2;
    exports2.UnionLayoutDiscriminator = UnionLayoutDiscriminator2;
    exports2.Union = Union2;
    exports2.VariantLayout = VariantLayout2;
    exports2.BitStructure = BitStructure;
    exports2.BitField = BitField;
    exports2.Boolean = Boolean2;
    exports2.Blob = Blob2;
    exports2.CString = CString;
    exports2.UTF8 = UTF8;
    exports2.Constant = Constant;
    exports2.greedy = ((elementSpan, property) => new GreedyCount(elementSpan, property));
    exports2.offset = ((layout, offset3, property) => new OffsetLayout2(layout, offset3, property));
    exports2.u8 = ((property) => new UInt2(1, property));
    exports2.u16 = ((property) => new UInt2(2, property));
    exports2.u24 = ((property) => new UInt2(3, property));
    exports2.u32 = ((property) => new UInt2(4, property));
    exports2.u40 = ((property) => new UInt2(5, property));
    exports2.u48 = ((property) => new UInt2(6, property));
    exports2.nu64 = ((property) => new NearUInt642(property));
    exports2.u16be = ((property) => new UIntBE2(2, property));
    exports2.u24be = ((property) => new UIntBE2(3, property));
    exports2.u32be = ((property) => new UIntBE2(4, property));
    exports2.u40be = ((property) => new UIntBE2(5, property));
    exports2.u48be = ((property) => new UIntBE2(6, property));
    exports2.nu64be = ((property) => new NearUInt64BE(property));
    exports2.s8 = ((property) => new Int(1, property));
    exports2.s16 = ((property) => new Int(2, property));
    exports2.s24 = ((property) => new Int(3, property));
    exports2.s32 = ((property) => new Int(4, property));
    exports2.s40 = ((property) => new Int(5, property));
    exports2.s48 = ((property) => new Int(6, property));
    exports2.ns64 = ((property) => new NearInt642(property));
    exports2.s16be = ((property) => new IntBE(2, property));
    exports2.s24be = ((property) => new IntBE(3, property));
    exports2.s32be = ((property) => new IntBE(4, property));
    exports2.s40be = ((property) => new IntBE(5, property));
    exports2.s48be = ((property) => new IntBE(6, property));
    exports2.ns64be = ((property) => new NearInt64BE(property));
    exports2.f32 = ((property) => new Float(property));
    exports2.f32be = ((property) => new FloatBE(property));
    exports2.f64 = ((property) => new Double(property));
    exports2.f64be = ((property) => new DoubleBE(property));
    exports2.struct = ((fields, property, decodePrefixes) => new Structure2(fields, property, decodePrefixes));
    exports2.bits = ((word, msb, property) => new BitStructure(word, msb, property));
    exports2.seq = ((elementLayout, count, property) => new Sequence(elementLayout, count, property));
    exports2.union = ((discr, defaultLayout, property) => new Union2(discr, defaultLayout, property));
    exports2.unionLayoutDiscriminator = ((layout, property) => new UnionLayoutDiscriminator2(layout, property));
    exports2.blob = ((length2, property) => new Blob2(length2, property));
    exports2.cstr = ((property) => new CString(property));
    exports2.utf8 = ((maxSpan, property) => new UTF8(maxSpan, property));
    exports2.const = ((value, property) => new Constant(value, property));
  }
});

// node_modules/@coral-xyz/borsh/dist/index.js
var require_dist = __commonJS({
  "node_modules/@coral-xyz/borsh/dist/index.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod4) {
      return mod4 && mod4.__esModule ? mod4 : { "default": mod4 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.map = exports2.array = exports2.rustEnum = exports2.str = exports2.vecU8 = exports2.tagged = exports2.vec = exports2.bool = exports2.option = exports2.publicKey = exports2.i256 = exports2.u256 = exports2.i128 = exports2.u128 = exports2.i64 = exports2.u64 = exports2.struct = exports2.f64 = exports2.f32 = exports2.i32 = exports2.u32 = exports2.i16 = exports2.u16 = exports2.i8 = exports2.u8 = void 0;
    var buffer_layout_1 = require_Layout2();
    var web3_js_1 = (init_index_browser_esm(), __toCommonJS(index_browser_esm_exports));
    var bn_js_1 = __importDefault(require_bn());
    var buffer_layout_2 = require_Layout2();
    Object.defineProperty(exports2, "u8", { enumerable: true, get: function() {
      return buffer_layout_2.u8;
    } });
    Object.defineProperty(exports2, "i8", { enumerable: true, get: function() {
      return buffer_layout_2.s8;
    } });
    Object.defineProperty(exports2, "u16", { enumerable: true, get: function() {
      return buffer_layout_2.u16;
    } });
    Object.defineProperty(exports2, "i16", { enumerable: true, get: function() {
      return buffer_layout_2.s16;
    } });
    Object.defineProperty(exports2, "u32", { enumerable: true, get: function() {
      return buffer_layout_2.u32;
    } });
    Object.defineProperty(exports2, "i32", { enumerable: true, get: function() {
      return buffer_layout_2.s32;
    } });
    Object.defineProperty(exports2, "f32", { enumerable: true, get: function() {
      return buffer_layout_2.f32;
    } });
    Object.defineProperty(exports2, "f64", { enumerable: true, get: function() {
      return buffer_layout_2.f64;
    } });
    Object.defineProperty(exports2, "struct", { enumerable: true, get: function() {
      return buffer_layout_2.struct;
    } });
    var BNLayout = class extends buffer_layout_1.Layout {
      constructor(span, signed, property) {
        super(span, property);
        this.blob = (0, buffer_layout_1.blob)(span);
        this.signed = signed;
      }
      decode(b, offset3 = 0) {
        const num2 = new bn_js_1.default(this.blob.decode(b, offset3), 10, "le");
        if (this.signed) {
          return num2.fromTwos(this.span * 8).clone();
        }
        return num2;
      }
      encode(src2, b, offset3 = 0) {
        if (this.signed) {
          src2 = src2.toTwos(this.span * 8);
        }
        return this.blob.encode(src2.toArrayLike(Buffer, "le", this.span), b, offset3);
      }
    };
    function u646(property) {
      return new BNLayout(8, false, property);
    }
    exports2.u64 = u646;
    function i642(property) {
      return new BNLayout(8, true, property);
    }
    exports2.i64 = i642;
    function u1283(property) {
      return new BNLayout(16, false, property);
    }
    exports2.u128 = u1283;
    function i1282(property) {
      return new BNLayout(16, true, property);
    }
    exports2.i128 = i1282;
    function u2563(property) {
      return new BNLayout(32, false, property);
    }
    exports2.u256 = u2563;
    function i2562(property) {
      return new BNLayout(32, true, property);
    }
    exports2.i256 = i2562;
    var WrappedLayout2 = class extends buffer_layout_1.Layout {
      constructor(layout, decoder, encoder4, property) {
        super(layout.span, property);
        this.layout = layout;
        this.decoder = decoder;
        this.encoder = encoder4;
      }
      decode(b, offset3) {
        return this.decoder(this.layout.decode(b, offset3));
      }
      encode(src2, b, offset3) {
        return this.layout.encode(this.encoder(src2), b, offset3);
      }
      getSpan(b, offset3) {
        return this.layout.getSpan(b, offset3);
      }
    };
    function publicKey5(property) {
      return new WrappedLayout2((0, buffer_layout_1.blob)(32), (b) => new web3_js_1.PublicKey(b), (key) => key.toBuffer(), property);
    }
    exports2.publicKey = publicKey5;
    var OptionLayout = class extends buffer_layout_1.Layout {
      constructor(layout, property) {
        super(-1, property);
        this.layout = layout;
        this.discriminator = (0, buffer_layout_1.u8)();
      }
      encode(src2, b, offset3 = 0) {
        if (src2 === null || src2 === void 0) {
          return this.discriminator.encode(0, b, offset3);
        }
        this.discriminator.encode(1, b, offset3);
        return this.layout.encode(src2, b, offset3 + 1) + 1;
      }
      decode(b, offset3 = 0) {
        const discriminator2 = this.discriminator.decode(b, offset3);
        if (discriminator2 === 0) {
          return null;
        } else if (discriminator2 === 1) {
          return this.layout.decode(b, offset3 + 1);
        }
        throw new Error("Invalid option " + this.property);
      }
      getSpan(b, offset3 = 0) {
        const discriminator2 = this.discriminator.decode(b, offset3);
        if (discriminator2 === 0) {
          return 1;
        } else if (discriminator2 === 1) {
          return this.layout.getSpan(b, offset3 + 1) + 1;
        }
        throw new Error("Invalid option " + this.property);
      }
    };
    function option2(layout, property) {
      return new OptionLayout(layout, property);
    }
    exports2.option = option2;
    function bool4(property) {
      return new WrappedLayout2((0, buffer_layout_1.u8)(), decodeBool, encodeBool2, property);
    }
    exports2.bool = bool4;
    function decodeBool(value) {
      if (value === 0) {
        return false;
      } else if (value === 1) {
        return true;
      }
      throw new Error("Invalid bool: " + value);
    }
    function encodeBool2(value) {
      return value ? 1 : 0;
    }
    function vec2(elementLayout, property) {
      const length2 = (0, buffer_layout_1.u32)("length");
      const layout = (0, buffer_layout_1.struct)([
        length2,
        (0, buffer_layout_1.seq)(elementLayout, (0, buffer_layout_1.offset)(length2, -length2.span), "values")
      ]);
      return new WrappedLayout2(layout, ({ values }) => values, (values) => ({ values }), property);
    }
    exports2.vec = vec2;
    function tagged(tag, layout, property) {
      const wrappedLayout = (0, buffer_layout_1.struct)([
        u646("tag"),
        layout.replicate("data")
      ]);
      function decodeTag({ tag: receivedTag, data }) {
        if (!receivedTag.eq(tag)) {
          throw new Error("Invalid tag, expected: " + tag.toString("hex") + ", got: " + receivedTag.toString("hex"));
        }
        return data;
      }
      return new WrappedLayout2(wrappedLayout, decodeTag, (data) => ({ tag, data }), property);
    }
    exports2.tagged = tagged;
    function vecU82(property) {
      const length2 = (0, buffer_layout_1.u32)("length");
      const layout = (0, buffer_layout_1.struct)([
        length2,
        (0, buffer_layout_1.blob)((0, buffer_layout_1.offset)(length2, -length2.span), "data")
      ]);
      return new WrappedLayout2(layout, ({ data }) => data, (data) => ({ data }), property);
    }
    exports2.vecU8 = vecU82;
    function str2(property) {
      return new WrappedLayout2(vecU82(), (data) => data.toString("utf-8"), (s) => Buffer.from(s, "utf-8"), property);
    }
    exports2.str = str2;
    function rustEnum2(variants, property, discriminant) {
      const unionLayout = (0, buffer_layout_1.union)(discriminant !== null && discriminant !== void 0 ? discriminant : (0, buffer_layout_1.u8)(), property);
      variants.forEach((variant, index4) => unionLayout.addVariant(index4, variant, variant.property));
      return unionLayout;
    }
    exports2.rustEnum = rustEnum2;
    function array4(elementLayout, length2, property) {
      const layout = (0, buffer_layout_1.struct)([
        (0, buffer_layout_1.seq)(elementLayout, length2, "values")
      ]);
      return new WrappedLayout2(layout, ({ values }) => values, (values) => ({ values }), property);
    }
    exports2.array = array4;
    var MapEntryLayout = class extends buffer_layout_1.Layout {
      constructor(keyLayout, valueLayout, property) {
        super(keyLayout.span + valueLayout.span, property);
        this.keyLayout = keyLayout;
        this.valueLayout = valueLayout;
      }
      decode(b, offset3) {
        offset3 = offset3 || 0;
        const key = this.keyLayout.decode(b, offset3);
        const value = this.valueLayout.decode(b, offset3 + this.keyLayout.getSpan(b, offset3));
        return [key, value];
      }
      encode(src2, b, offset3) {
        offset3 = offset3 || 0;
        const keyBytes = this.keyLayout.encode(src2[0], b, offset3);
        const valueBytes = this.valueLayout.encode(src2[1], b, offset3 + keyBytes);
        return keyBytes + valueBytes;
      }
      getSpan(b, offset3) {
        return this.keyLayout.getSpan(b, offset3) + this.valueLayout.getSpan(b, offset3);
      }
    };
    function map(keyLayout, valueLayout, property) {
      const length2 = (0, buffer_layout_1.u32)("length");
      const layout = (0, buffer_layout_1.struct)([
        length2,
        (0, buffer_layout_1.seq)(new MapEntryLayout(keyLayout, valueLayout), (0, buffer_layout_1.offset)(length2, -length2.span), "values")
      ]);
      return new WrappedLayout2(layout, ({ values }) => new Map(values), (values) => ({ values: Array.from(values.entries()) }), property);
    }
    exports2.map = map;
  }
});

// node_modules/eventemitter3/index.js
var require_eventemitter32 = __commonJS({
  "node_modules/eventemitter3/index.js"(exports2, module2) {
    "use strict";
    var has = Object.prototype.hasOwnProperty;
    var prefix = "~";
    function Events() {
    }
    if (Object.create) {
      Events.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events().__proto__) prefix = false;
    }
    function EE(fn, context, once) {
      this.fn = fn;
      this.context = context;
      this.once = once || false;
    }
    function addListener(emitter, event, fn, context, once) {
      if (typeof fn !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
      if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
      else emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0) emitter._events = new Events();
      else delete emitter._events[evt];
    }
    function EventEmitter4() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    EventEmitter4.prototype.eventNames = function eventNames() {
      var names = [], events2, name;
      if (this._eventsCount === 0) return names;
      for (name in events2 = this._events) {
        if (has.call(events2, name)) names.push(prefix ? name.slice(1) : name);
      }
      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events2));
      }
      return names;
    };
    EventEmitter4.prototype.listeners = function listeners(event) {
      var evt = prefix ? prefix + event : event, handlers = this._events[evt];
      if (!handlers) return [];
      if (handlers.fn) return [handlers.fn];
      for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
        ee[i] = handlers[i].fn;
      }
      return ee;
    };
    EventEmitter4.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix ? prefix + event : event, listeners = this._events[evt];
      if (!listeners) return 0;
      if (listeners.fn) return 1;
      return listeners.length;
    };
    EventEmitter4.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return false;
      var listeners = this._events[evt], len = arguments.length, args, i;
      if (listeners.fn) {
        if (listeners.once) this.removeListener(event, listeners.fn, void 0, true);
        switch (len) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a2), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a2, a3), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
          case 6:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
        }
        for (i = 1, args = new Array(len - 1); i < len; i++) {
          args[i - 1] = arguments[i];
        }
        listeners.fn.apply(listeners.context, args);
      } else {
        var length2 = listeners.length, j;
        for (i = 0; i < length2; i++) {
          if (listeners[i].once) this.removeListener(event, listeners[i].fn, void 0, true);
          switch (len) {
            case 1:
              listeners[i].fn.call(listeners[i].context);
              break;
            case 2:
              listeners[i].fn.call(listeners[i].context, a1);
              break;
            case 3:
              listeners[i].fn.call(listeners[i].context, a1, a2);
              break;
            case 4:
              listeners[i].fn.call(listeners[i].context, a1, a2, a3);
              break;
            default:
              if (!args) for (j = 1, args = new Array(len - 1); j < len; j++) {
                args[j - 1] = arguments[j];
              }
              listeners[i].fn.apply(listeners[i].context, args);
          }
        }
      }
      return true;
    };
    EventEmitter4.prototype.on = function on(event, fn, context) {
      return addListener(this, event, fn, context, false);
    };
    EventEmitter4.prototype.once = function once(event, fn, context) {
      return addListener(this, event, fn, context, true);
    };
    EventEmitter4.prototype.removeListener = function removeListener(event, fn, context, once) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return this;
      if (!fn) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i = 0, events2 = [], length2 = listeners.length; i < length2; i++) {
          if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
            events2.push(listeners[i]);
          }
        }
        if (events2.length) this._events[evt] = events2.length === 1 ? events2[0] : events2;
        else clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter4.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt]) clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter4.prototype.off = EventEmitter4.prototype.removeListener;
    EventEmitter4.prototype.addListener = EventEmitter4.prototype.on;
    EventEmitter4.prefixed = prefix;
    EventEmitter4.EventEmitter = EventEmitter4;
    if ("undefined" !== typeof module2) {
      module2.exports = EventEmitter4;
    }
  }
});

// node_modules/ulid/stubs/crypto.js
var require_crypto2 = __commonJS({
  "node_modules/ulid/stubs/crypto.js"() {
  }
});

// node_modules/axios/lib/helpers/bind.js
var require_bind = __commonJS({
  "node_modules/axios/lib/helpers/bind.js"(exports2, module2) {
    "use strict";
    module2.exports = function bind(fn, thisArg) {
      return function wrap() {
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        return fn.apply(thisArg, args);
      };
    };
  }
});

// node_modules/axios/lib/utils.js
var require_utils = __commonJS({
  "node_modules/axios/lib/utils.js"(exports2, module2) {
    "use strict";
    var bind = require_bind();
    var toString2 = Object.prototype.toString;
    function isArray2(val) {
      return toString2.call(val) === "[object Array]";
    }
    function isUndefined2(val) {
      return typeof val === "undefined";
    }
    function isBuffer2(val) {
      return val !== null && !isUndefined2(val) && val.constructor !== null && !isUndefined2(val.constructor) && typeof val.constructor.isBuffer === "function" && val.constructor.isBuffer(val);
    }
    function isArrayBuffer(val) {
      return toString2.call(val) === "[object ArrayBuffer]";
    }
    function isFormData2(val) {
      return typeof FormData !== "undefined" && val instanceof FormData;
    }
    function isArrayBufferView(val) {
      var result;
      if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
        result = ArrayBuffer.isView(val);
      } else {
        result = val && val.buffer && val.buffer instanceof ArrayBuffer;
      }
      return result;
    }
    function isString2(val) {
      return typeof val === "string";
    }
    function isNumber2(val) {
      return typeof val === "number";
    }
    function isObject4(val) {
      return val !== null && typeof val === "object";
    }
    function isDate(val) {
      return toString2.call(val) === "[object Date]";
    }
    function isFile(val) {
      return toString2.call(val) === "[object File]";
    }
    function isBlob2(val) {
      return toString2.call(val) === "[object Blob]";
    }
    function isFunction2(val) {
      return toString2.call(val) === "[object Function]";
    }
    function isStream(val) {
      return isObject4(val) && isFunction2(val.pipe);
    }
    function isURLSearchParams(val) {
      return typeof URLSearchParams !== "undefined" && val instanceof URLSearchParams;
    }
    function trim3(str2) {
      return str2.replace(/^\s*/, "").replace(/\s*$/, "");
    }
    function isStandardBrowserEnv() {
      if (typeof navigator !== "undefined" && (navigator.product === "ReactNative" || navigator.product === "NativeScript" || navigator.product === "NS")) {
        return false;
      }
      return typeof window !== "undefined" && typeof document !== "undefined";
    }
    function forEach(obj, fn) {
      if (obj === null || typeof obj === "undefined") {
        return;
      }
      if (typeof obj !== "object") {
        obj = [obj];
      }
      if (isArray2(obj)) {
        for (var i = 0, l = obj.length; i < l; i++) {
          fn.call(null, obj[i], i, obj);
        }
      } else {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) {
            fn.call(null, obj[key], key, obj);
          }
        }
      }
    }
    function merge() {
      var result = {};
      function assignValue2(val, key) {
        if (typeof result[key] === "object" && typeof val === "object") {
          result[key] = merge(result[key], val);
        } else {
          result[key] = val;
        }
      }
      for (var i = 0, l = arguments.length; i < l; i++) {
        forEach(arguments[i], assignValue2);
      }
      return result;
    }
    function deepMerge() {
      var result = {};
      function assignValue2(val, key) {
        if (typeof result[key] === "object" && typeof val === "object") {
          result[key] = deepMerge(result[key], val);
        } else if (typeof val === "object") {
          result[key] = deepMerge({}, val);
        } else {
          result[key] = val;
        }
      }
      for (var i = 0, l = arguments.length; i < l; i++) {
        forEach(arguments[i], assignValue2);
      }
      return result;
    }
    function extend(a, b, thisArg) {
      forEach(b, function assignValue2(val, key) {
        if (thisArg && typeof val === "function") {
          a[key] = bind(val, thisArg);
        } else {
          a[key] = val;
        }
      });
      return a;
    }
    module2.exports = {
      isArray: isArray2,
      isArrayBuffer,
      isBuffer: isBuffer2,
      isFormData: isFormData2,
      isArrayBufferView,
      isString: isString2,
      isNumber: isNumber2,
      isObject: isObject4,
      isUndefined: isUndefined2,
      isDate,
      isFile,
      isBlob: isBlob2,
      isFunction: isFunction2,
      isStream,
      isURLSearchParams,
      isStandardBrowserEnv,
      forEach,
      merge,
      deepMerge,
      extend,
      trim: trim3
    };
  }
});

// node_modules/axios/lib/helpers/buildURL.js
var require_buildURL = __commonJS({
  "node_modules/axios/lib/helpers/buildURL.js"(exports2, module2) {
    "use strict";
    var utils3 = require_utils();
    function encode4(val) {
      return encodeURIComponent(val).replace(/%40/gi, "@").replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
    }
    module2.exports = function buildURL(url, params, paramsSerializer) {
      if (!params) {
        return url;
      }
      var serializedParams;
      if (paramsSerializer) {
        serializedParams = paramsSerializer(params);
      } else if (utils3.isURLSearchParams(params)) {
        serializedParams = params.toString();
      } else {
        var parts = [];
        utils3.forEach(params, function serialize2(val, key) {
          if (val === null || typeof val === "undefined") {
            return;
          }
          if (utils3.isArray(val)) {
            key = key + "[]";
          } else {
            val = [val];
          }
          utils3.forEach(val, function parseValue(v) {
            if (utils3.isDate(v)) {
              v = v.toISOString();
            } else if (utils3.isObject(v)) {
              v = JSON.stringify(v);
            }
            parts.push(encode4(key) + "=" + encode4(v));
          });
        });
        serializedParams = parts.join("&");
      }
      if (serializedParams) {
        var hashmarkIndex = url.indexOf("#");
        if (hashmarkIndex !== -1) {
          url = url.slice(0, hashmarkIndex);
        }
        url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
      }
      return url;
    };
  }
});

// node_modules/axios/lib/core/InterceptorManager.js
var require_InterceptorManager = __commonJS({
  "node_modules/axios/lib/core/InterceptorManager.js"(exports2, module2) {
    "use strict";
    var utils3 = require_utils();
    function InterceptorManager() {
      this.handlers = [];
    }
    InterceptorManager.prototype.use = function use(fulfilled, rejected) {
      this.handlers.push({
        fulfilled,
        rejected
      });
      return this.handlers.length - 1;
    };
    InterceptorManager.prototype.eject = function eject(id) {
      if (this.handlers[id]) {
        this.handlers[id] = null;
      }
    };
    InterceptorManager.prototype.forEach = function forEach(fn) {
      utils3.forEach(this.handlers, function forEachHandler(h) {
        if (h !== null) {
          fn(h);
        }
      });
    };
    module2.exports = InterceptorManager;
  }
});

// node_modules/axios/lib/core/transformData.js
var require_transformData = __commonJS({
  "node_modules/axios/lib/core/transformData.js"(exports2, module2) {
    "use strict";
    var utils3 = require_utils();
    module2.exports = function transformData(data, headers, fns) {
      utils3.forEach(fns, function transform(fn) {
        data = fn(data, headers);
      });
      return data;
    };
  }
});

// node_modules/axios/lib/cancel/isCancel.js
var require_isCancel = __commonJS({
  "node_modules/axios/lib/cancel/isCancel.js"(exports2, module2) {
    "use strict";
    module2.exports = function isCancel(value) {
      return !!(value && value.__CANCEL__);
    };
  }
});

// node_modules/axios/lib/helpers/normalizeHeaderName.js
var require_normalizeHeaderName = __commonJS({
  "node_modules/axios/lib/helpers/normalizeHeaderName.js"(exports2, module2) {
    "use strict";
    var utils3 = require_utils();
    module2.exports = function normalizeHeaderName(headers, normalizedName) {
      utils3.forEach(headers, function processHeader(value, name) {
        if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
          headers[normalizedName] = value;
          delete headers[name];
        }
      });
    };
  }
});

// node_modules/axios/lib/core/enhanceError.js
var require_enhanceError = __commonJS({
  "node_modules/axios/lib/core/enhanceError.js"(exports2, module2) {
    "use strict";
    module2.exports = function enhanceError(error, config, code2, request, response) {
      error.config = config;
      if (code2) {
        error.code = code2;
      }
      error.request = request;
      error.response = response;
      error.isAxiosError = true;
      error.toJSON = function() {
        return {
          // Standard
          message: this.message,
          name: this.name,
          // Microsoft
          description: this.description,
          number: this.number,
          // Mozilla
          fileName: this.fileName,
          lineNumber: this.lineNumber,
          columnNumber: this.columnNumber,
          stack: this.stack,
          // Axios
          config: this.config,
          code: this.code
        };
      };
      return error;
    };
  }
});

// node_modules/axios/lib/core/createError.js
var require_createError = __commonJS({
  "node_modules/axios/lib/core/createError.js"(exports2, module2) {
    "use strict";
    var enhanceError = require_enhanceError();
    module2.exports = function createError2(message, config, code2, request, response) {
      var error = new Error(message);
      return enhanceError(error, config, code2, request, response);
    };
  }
});

// node_modules/axios/lib/core/settle.js
var require_settle = __commonJS({
  "node_modules/axios/lib/core/settle.js"(exports2, module2) {
    "use strict";
    var createError2 = require_createError();
    module2.exports = function settle(resolve2, reject2, response) {
      var validateStatus = response.config.validateStatus;
      if (!validateStatus || validateStatus(response.status)) {
        resolve2(response);
      } else {
        reject2(createError2(
          "Request failed with status code " + response.status,
          response.config,
          null,
          response.request,
          response
        ));
      }
    };
  }
});

// node_modules/axios/lib/helpers/isAbsoluteURL.js
var require_isAbsoluteURL = __commonJS({
  "node_modules/axios/lib/helpers/isAbsoluteURL.js"(exports2, module2) {
    "use strict";
    module2.exports = function isAbsoluteURL(url) {
      return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
    };
  }
});

// node_modules/axios/lib/helpers/combineURLs.js
var require_combineURLs = __commonJS({
  "node_modules/axios/lib/helpers/combineURLs.js"(exports2, module2) {
    "use strict";
    module2.exports = function combineURLs(baseURL, relativeURL) {
      return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
    };
  }
});

// node_modules/axios/lib/core/buildFullPath.js
var require_buildFullPath = __commonJS({
  "node_modules/axios/lib/core/buildFullPath.js"(exports2, module2) {
    "use strict";
    var isAbsoluteURL = require_isAbsoluteURL();
    var combineURLs = require_combineURLs();
    module2.exports = function buildFullPath(baseURL, requestedURL) {
      if (baseURL && !isAbsoluteURL(requestedURL)) {
        return combineURLs(baseURL, requestedURL);
      }
      return requestedURL;
    };
  }
});

// node_modules/axios/lib/helpers/parseHeaders.js
var require_parseHeaders = __commonJS({
  "node_modules/axios/lib/helpers/parseHeaders.js"(exports2, module2) {
    "use strict";
    var utils3 = require_utils();
    var ignoreDuplicateOf = [
      "age",
      "authorization",
      "content-length",
      "content-type",
      "etag",
      "expires",
      "from",
      "host",
      "if-modified-since",
      "if-unmodified-since",
      "last-modified",
      "location",
      "max-forwards",
      "proxy-authorization",
      "referer",
      "retry-after",
      "user-agent"
    ];
    module2.exports = function parseHeaders(headers) {
      var parsed = {};
      var key;
      var val;
      var i;
      if (!headers) {
        return parsed;
      }
      utils3.forEach(headers.split("\n"), function parser(line) {
        i = line.indexOf(":");
        key = utils3.trim(line.substr(0, i)).toLowerCase();
        val = utils3.trim(line.substr(i + 1));
        if (key) {
          if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
            return;
          }
          if (key === "set-cookie") {
            parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
          } else {
            parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
          }
        }
      });
      return parsed;
    };
  }
});

// node_modules/axios/lib/helpers/isURLSameOrigin.js
var require_isURLSameOrigin = __commonJS({
  "node_modules/axios/lib/helpers/isURLSameOrigin.js"(exports2, module2) {
    "use strict";
    var utils3 = require_utils();
    module2.exports = utils3.isStandardBrowserEnv() ? (
      // Standard browser envs have full support of the APIs needed to test
      // whether the request URL is of the same origin as current location.
      (function standardBrowserEnv() {
        var msie = /(msie|trident)/i.test(navigator.userAgent);
        var urlParsingNode = document.createElement("a");
        var originURL;
        function resolveURL(url) {
          var href = url;
          if (msie) {
            urlParsingNode.setAttribute("href", href);
            href = urlParsingNode.href;
          }
          urlParsingNode.setAttribute("href", href);
          return {
            href: urlParsingNode.href,
            protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
            host: urlParsingNode.host,
            search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
            hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
            hostname: urlParsingNode.hostname,
            port: urlParsingNode.port,
            pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
          };
        }
        originURL = resolveURL(window.location.href);
        return function isURLSameOrigin(requestURL) {
          var parsed = utils3.isString(requestURL) ? resolveURL(requestURL) : requestURL;
          return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
        };
      })()
    ) : (
      // Non standard browser envs (web workers, react-native) lack needed support.
      /* @__PURE__ */ (function nonStandardBrowserEnv() {
        return function isURLSameOrigin() {
          return true;
        };
      })()
    );
  }
});

// node_modules/axios/lib/helpers/cookies.js
var require_cookies = __commonJS({
  "node_modules/axios/lib/helpers/cookies.js"(exports2, module2) {
    "use strict";
    var utils3 = require_utils();
    module2.exports = utils3.isStandardBrowserEnv() ? (
      // Standard browser envs support document.cookie
      /* @__PURE__ */ (function standardBrowserEnv() {
        return {
          write: function write(name, value, expires, path, domain, secure) {
            var cookie = [];
            cookie.push(name + "=" + encodeURIComponent(value));
            if (utils3.isNumber(expires)) {
              cookie.push("expires=" + new Date(expires).toGMTString());
            }
            if (utils3.isString(path)) {
              cookie.push("path=" + path);
            }
            if (utils3.isString(domain)) {
              cookie.push("domain=" + domain);
            }
            if (secure === true) {
              cookie.push("secure");
            }
            document.cookie = cookie.join("; ");
          },
          read: function read2(name) {
            var match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
            return match ? decodeURIComponent(match[3]) : null;
          },
          remove: function remove(name) {
            this.write(name, "", Date.now() - 864e5);
          }
        };
      })()
    ) : (
      // Non standard browser env (web workers, react-native) lack needed support.
      /* @__PURE__ */ (function nonStandardBrowserEnv() {
        return {
          write: function write() {
          },
          read: function read2() {
            return null;
          },
          remove: function remove() {
          }
        };
      })()
    );
  }
});

// node_modules/axios/lib/adapters/xhr.js
var require_xhr = __commonJS({
  "node_modules/axios/lib/adapters/xhr.js"(exports2, module2) {
    "use strict";
    var utils3 = require_utils();
    var settle = require_settle();
    var buildURL = require_buildURL();
    var buildFullPath = require_buildFullPath();
    var parseHeaders = require_parseHeaders();
    var isURLSameOrigin = require_isURLSameOrigin();
    var createError2 = require_createError();
    module2.exports = function xhrAdapter(config) {
      return new Promise(function dispatchXhrRequest(resolve2, reject2) {
        var requestData = config.data;
        var requestHeaders = config.headers;
        if (utils3.isFormData(requestData)) {
          delete requestHeaders["Content-Type"];
        }
        var request = new XMLHttpRequest();
        if (config.auth) {
          var username = config.auth.username || "";
          var password = config.auth.password || "";
          requestHeaders.Authorization = "Basic " + btoa(username + ":" + password);
        }
        var fullPath = buildFullPath(config.baseURL, config.url);
        request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);
        request.timeout = config.timeout;
        request.onreadystatechange = function handleLoad() {
          if (!request || request.readyState !== 4) {
            return;
          }
          if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
            return;
          }
          var responseHeaders = "getAllResponseHeaders" in request ? parseHeaders(request.getAllResponseHeaders()) : null;
          var responseData = !config.responseType || config.responseType === "text" ? request.responseText : request.response;
          var response = {
            data: responseData,
            status: request.status,
            statusText: request.statusText,
            headers: responseHeaders,
            config,
            request
          };
          settle(resolve2, reject2, response);
          request = null;
        };
        request.onabort = function handleAbort() {
          if (!request) {
            return;
          }
          reject2(createError2("Request aborted", config, "ECONNABORTED", request));
          request = null;
        };
        request.onerror = function handleError() {
          reject2(createError2("Network Error", config, null, request));
          request = null;
        };
        request.ontimeout = function handleTimeout() {
          var timeoutErrorMessage = "timeout of " + config.timeout + "ms exceeded";
          if (config.timeoutErrorMessage) {
            timeoutErrorMessage = config.timeoutErrorMessage;
          }
          reject2(createError2(
            timeoutErrorMessage,
            config,
            "ECONNABORTED",
            request
          ));
          request = null;
        };
        if (utils3.isStandardBrowserEnv()) {
          var cookies = require_cookies();
          var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ? cookies.read(config.xsrfCookieName) : void 0;
          if (xsrfValue) {
            requestHeaders[config.xsrfHeaderName] = xsrfValue;
          }
        }
        if ("setRequestHeader" in request) {
          utils3.forEach(requestHeaders, function setRequestHeader(val, key) {
            if (typeof requestData === "undefined" && key.toLowerCase() === "content-type") {
              delete requestHeaders[key];
            } else {
              request.setRequestHeader(key, val);
            }
          });
        }
        if (!utils3.isUndefined(config.withCredentials)) {
          request.withCredentials = !!config.withCredentials;
        }
        if (config.responseType) {
          try {
            request.responseType = config.responseType;
          } catch (e) {
            if (config.responseType !== "json") {
              throw e;
            }
          }
        }
        if (typeof config.onDownloadProgress === "function") {
          request.addEventListener("progress", config.onDownloadProgress);
        }
        if (typeof config.onUploadProgress === "function" && request.upload) {
          request.upload.addEventListener("progress", config.onUploadProgress);
        }
        if (config.cancelToken) {
          config.cancelToken.promise.then(function onCanceled(cancel) {
            if (!request) {
              return;
            }
            request.abort();
            reject2(cancel);
            request = null;
          });
        }
        if (requestData === void 0) {
          requestData = null;
        }
        request.send(requestData);
      });
    };
  }
});

// node_modules/axios/lib/defaults.js
var require_defaults = __commonJS({
  "node_modules/axios/lib/defaults.js"(exports2, module2) {
    "use strict";
    var utils3 = require_utils();
    var normalizeHeaderName = require_normalizeHeaderName();
    var DEFAULT_CONTENT_TYPE = {
      "Content-Type": "application/x-www-form-urlencoded"
    };
    function setContentTypeIfUnset(headers, value) {
      if (!utils3.isUndefined(headers) && utils3.isUndefined(headers["Content-Type"])) {
        headers["Content-Type"] = value;
      }
    }
    function getDefaultAdapter() {
      var adapter;
      if (typeof XMLHttpRequest !== "undefined") {
        adapter = require_xhr();
      } else if (typeof process !== "undefined" && Object.prototype.toString.call(process) === "[object process]") {
        adapter = require_xhr();
      }
      return adapter;
    }
    var defaults = {
      adapter: getDefaultAdapter(),
      transformRequest: [function transformRequest(data, headers) {
        normalizeHeaderName(headers, "Accept");
        normalizeHeaderName(headers, "Content-Type");
        if (utils3.isFormData(data) || utils3.isArrayBuffer(data) || utils3.isBuffer(data) || utils3.isStream(data) || utils3.isFile(data) || utils3.isBlob(data)) {
          return data;
        }
        if (utils3.isArrayBufferView(data)) {
          return data.buffer;
        }
        if (utils3.isURLSearchParams(data)) {
          setContentTypeIfUnset(headers, "application/x-www-form-urlencoded;charset=utf-8");
          return data.toString();
        }
        if (utils3.isObject(data)) {
          setContentTypeIfUnset(headers, "application/json;charset=utf-8");
          return JSON.stringify(data);
        }
        return data;
      }],
      transformResponse: [function transformResponse(data) {
        if (typeof data === "string") {
          try {
            data = JSON.parse(data);
          } catch (e) {
          }
        }
        return data;
      }],
      /**
       * A timeout in milliseconds to abort a request. If set to 0 (default) a
       * timeout is not created.
       */
      timeout: 0,
      xsrfCookieName: "XSRF-TOKEN",
      xsrfHeaderName: "X-XSRF-TOKEN",
      maxContentLength: -1,
      validateStatus: function validateStatus(status) {
        return status >= 200 && status < 300;
      }
    };
    defaults.headers = {
      common: {
        "Accept": "application/json, text/plain, */*"
      }
    };
    utils3.forEach(["delete", "get", "head"], function forEachMethodNoData(method) {
      defaults.headers[method] = {};
    });
    utils3.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
      defaults.headers[method] = utils3.merge(DEFAULT_CONTENT_TYPE);
    });
    module2.exports = defaults;
  }
});

// node_modules/axios/lib/core/dispatchRequest.js
var require_dispatchRequest = __commonJS({
  "node_modules/axios/lib/core/dispatchRequest.js"(exports2, module2) {
    "use strict";
    var utils3 = require_utils();
    var transformData = require_transformData();
    var isCancel = require_isCancel();
    var defaults = require_defaults();
    function throwIfCancellationRequested(config) {
      if (config.cancelToken) {
        config.cancelToken.throwIfRequested();
      }
    }
    module2.exports = function dispatchRequest(config) {
      throwIfCancellationRequested(config);
      config.headers = config.headers || {};
      config.data = transformData(
        config.data,
        config.headers,
        config.transformRequest
      );
      config.headers = utils3.merge(
        config.headers.common || {},
        config.headers[config.method] || {},
        config.headers
      );
      utils3.forEach(
        ["delete", "get", "head", "post", "put", "patch", "common"],
        function cleanHeaderConfig(method) {
          delete config.headers[method];
        }
      );
      var adapter = config.adapter || defaults.adapter;
      return adapter(config).then(function onAdapterResolution(response) {
        throwIfCancellationRequested(config);
        response.data = transformData(
          response.data,
          response.headers,
          config.transformResponse
        );
        return response;
      }, function onAdapterRejection(reason) {
        if (!isCancel(reason)) {
          throwIfCancellationRequested(config);
          if (reason && reason.response) {
            reason.response.data = transformData(
              reason.response.data,
              reason.response.headers,
              config.transformResponse
            );
          }
        }
        return Promise.reject(reason);
      });
    };
  }
});

// node_modules/axios/lib/core/mergeConfig.js
var require_mergeConfig = __commonJS({
  "node_modules/axios/lib/core/mergeConfig.js"(exports2, module2) {
    "use strict";
    var utils3 = require_utils();
    module2.exports = function mergeConfig(config1, config2) {
      config2 = config2 || {};
      var config = {};
      var valueFromConfig2Keys = ["url", "method", "params", "data"];
      var mergeDeepPropertiesKeys = ["headers", "auth", "proxy"];
      var defaultToConfig2Keys = [
        "baseURL",
        "url",
        "transformRequest",
        "transformResponse",
        "paramsSerializer",
        "timeout",
        "withCredentials",
        "adapter",
        "responseType",
        "xsrfCookieName",
        "xsrfHeaderName",
        "onUploadProgress",
        "onDownloadProgress",
        "maxContentLength",
        "validateStatus",
        "maxRedirects",
        "httpAgent",
        "httpsAgent",
        "cancelToken",
        "socketPath"
      ];
      utils3.forEach(valueFromConfig2Keys, function valueFromConfig2(prop) {
        if (typeof config2[prop] !== "undefined") {
          config[prop] = config2[prop];
        }
      });
      utils3.forEach(mergeDeepPropertiesKeys, function mergeDeepProperties(prop) {
        if (utils3.isObject(config2[prop])) {
          config[prop] = utils3.deepMerge(config1[prop], config2[prop]);
        } else if (typeof config2[prop] !== "undefined") {
          config[prop] = config2[prop];
        } else if (utils3.isObject(config1[prop])) {
          config[prop] = utils3.deepMerge(config1[prop]);
        } else if (typeof config1[prop] !== "undefined") {
          config[prop] = config1[prop];
        }
      });
      utils3.forEach(defaultToConfig2Keys, function defaultToConfig2(prop) {
        if (typeof config2[prop] !== "undefined") {
          config[prop] = config2[prop];
        } else if (typeof config1[prop] !== "undefined") {
          config[prop] = config1[prop];
        }
      });
      var axiosKeys = valueFromConfig2Keys.concat(mergeDeepPropertiesKeys).concat(defaultToConfig2Keys);
      var otherKeys = Object.keys(config2).filter(function filterAxiosKeys(key) {
        return axiosKeys.indexOf(key) === -1;
      });
      utils3.forEach(otherKeys, function otherKeysDefaultToConfig2(prop) {
        if (typeof config2[prop] !== "undefined") {
          config[prop] = config2[prop];
        } else if (typeof config1[prop] !== "undefined") {
          config[prop] = config1[prop];
        }
      });
      return config;
    };
  }
});

// node_modules/axios/lib/core/Axios.js
var require_Axios = __commonJS({
  "node_modules/axios/lib/core/Axios.js"(exports2, module2) {
    "use strict";
    var utils3 = require_utils();
    var buildURL = require_buildURL();
    var InterceptorManager = require_InterceptorManager();
    var dispatchRequest = require_dispatchRequest();
    var mergeConfig = require_mergeConfig();
    function Axios(instanceConfig) {
      this.defaults = instanceConfig;
      this.interceptors = {
        request: new InterceptorManager(),
        response: new InterceptorManager()
      };
    }
    Axios.prototype.request = function request(config) {
      if (typeof config === "string") {
        config = arguments[1] || {};
        config.url = arguments[0];
      } else {
        config = config || {};
      }
      config = mergeConfig(this.defaults, config);
      if (config.method) {
        config.method = config.method.toLowerCase();
      } else if (this.defaults.method) {
        config.method = this.defaults.method.toLowerCase();
      } else {
        config.method = "get";
      }
      var chain2 = [dispatchRequest, void 0];
      var promise = Promise.resolve(config);
      this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
        chain2.unshift(interceptor.fulfilled, interceptor.rejected);
      });
      this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
        chain2.push(interceptor.fulfilled, interceptor.rejected);
      });
      while (chain2.length) {
        promise = promise.then(chain2.shift(), chain2.shift());
      }
      return promise;
    };
    Axios.prototype.getUri = function getUri(config) {
      config = mergeConfig(this.defaults, config);
      return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\?/, "");
    };
    utils3.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
      Axios.prototype[method] = function(url, config) {
        return this.request(utils3.merge(config || {}, {
          method,
          url
        }));
      };
    });
    utils3.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
      Axios.prototype[method] = function(url, data, config) {
        return this.request(utils3.merge(config || {}, {
          method,
          url,
          data
        }));
      };
    });
    module2.exports = Axios;
  }
});

// node_modules/axios/lib/cancel/Cancel.js
var require_Cancel = __commonJS({
  "node_modules/axios/lib/cancel/Cancel.js"(exports2, module2) {
    "use strict";
    function Cancel(message) {
      this.message = message;
    }
    Cancel.prototype.toString = function toString2() {
      return "Cancel" + (this.message ? ": " + this.message : "");
    };
    Cancel.prototype.__CANCEL__ = true;
    module2.exports = Cancel;
  }
});

// node_modules/axios/lib/cancel/CancelToken.js
var require_CancelToken = __commonJS({
  "node_modules/axios/lib/cancel/CancelToken.js"(exports2, module2) {
    "use strict";
    var Cancel = require_Cancel();
    function CancelToken(executor) {
      if (typeof executor !== "function") {
        throw new TypeError("executor must be a function.");
      }
      var resolvePromise;
      this.promise = new Promise(function promiseExecutor(resolve2) {
        resolvePromise = resolve2;
      });
      var token2 = this;
      executor(function cancel(message) {
        if (token2.reason) {
          return;
        }
        token2.reason = new Cancel(message);
        resolvePromise(token2.reason);
      });
    }
    CancelToken.prototype.throwIfRequested = function throwIfRequested() {
      if (this.reason) {
        throw this.reason;
      }
    };
    CancelToken.source = function source() {
      var cancel;
      var token2 = new CancelToken(function executor(c) {
        cancel = c;
      });
      return {
        token: token2,
        cancel
      };
    };
    module2.exports = CancelToken;
  }
});

// node_modules/axios/lib/helpers/spread.js
var require_spread = __commonJS({
  "node_modules/axios/lib/helpers/spread.js"(exports2, module2) {
    "use strict";
    module2.exports = function spread(callback) {
      return function wrap(arr) {
        return callback.apply(null, arr);
      };
    };
  }
});

// node_modules/axios/lib/axios.js
var require_axios = __commonJS({
  "node_modules/axios/lib/axios.js"(exports2, module2) {
    "use strict";
    var utils3 = require_utils();
    var bind = require_bind();
    var Axios = require_Axios();
    var mergeConfig = require_mergeConfig();
    var defaults = require_defaults();
    function createInstance(defaultConfig) {
      var context = new Axios(defaultConfig);
      var instance2 = bind(Axios.prototype.request, context);
      utils3.extend(instance2, Axios.prototype, context);
      utils3.extend(instance2, context);
      return instance2;
    }
    var axios2 = createInstance(defaults);
    axios2.Axios = Axios;
    axios2.create = function create4(instanceConfig) {
      return createInstance(mergeConfig(axios2.defaults, instanceConfig));
    };
    axios2.Cancel = require_Cancel();
    axios2.CancelToken = require_CancelToken();
    axios2.isCancel = require_isCancel();
    axios2.all = function all(promises) {
      return Promise.all(promises);
    };
    axios2.spread = require_spread();
    module2.exports = axios2;
    module2.exports.default = axios2;
  }
});

// node_modules/axios/index.js
var require_axios2 = __commonJS({
  "node_modules/axios/index.js"(exports2, module2) {
    module2.exports = require_axios();
  }
});

// node_modules/form-data/lib/browser.js
var require_browser3 = __commonJS({
  "node_modules/form-data/lib/browser.js"(exports2, module2) {
    module2.exports = typeof self == "object" ? self.FormData : window.FormData;
  }
});

// node_modules/@audius/sdk/node_modules/viem/_esm/utils/getAction.js
function getAction(client, actionFn, name) {
  const action_implicit = client[actionFn.name];
  if (typeof action_implicit === "function")
    return action_implicit;
  const action_explicit = client[name];
  if (typeof action_explicit === "function")
    return action_explicit;
  return (params) => actionFn(client, params);
}

// node_modules/@audius/sdk/node_modules/viem/_esm/errors/log.js
var FilterTypeNotSupportedError = class extends BaseError {
  constructor(type3) {
    super(`Filter type "${type3}" is not supported.`, {
      name: "FilterTypeNotSupportedError"
    });
  }
};

// node_modules/@audius/sdk/node_modules/viem/_esm/utils/abi/encodeEventTopics.js
var docsPath = "/docs/contract/encodeEventTopics";
function encodeEventTopics(parameters) {
  var _a2;
  const { abi: abi14, eventName, args } = parameters;
  let abiItem = abi14[0];
  if (eventName) {
    const item = getAbiItem({ abi: abi14, name: eventName });
    if (!item)
      throw new AbiEventNotFoundError(eventName, { docsPath });
    abiItem = item;
  }
  if (abiItem.type !== "event")
    throw new AbiEventNotFoundError(void 0, { docsPath });
  const definition = formatAbiItem(abiItem);
  const signature2 = toEventSelector(definition);
  let topics = [];
  if (args && "inputs" in abiItem) {
    const indexedInputs = (_a2 = abiItem.inputs) == null ? void 0 : _a2.filter((param) => "indexed" in param && param.indexed);
    const args_ = Array.isArray(args) ? args : Object.values(args).length > 0 ? (indexedInputs == null ? void 0 : indexedInputs.map((x) => args[x.name])) ?? [] : [];
    if (args_.length > 0) {
      topics = (indexedInputs == null ? void 0 : indexedInputs.map((param, i) => {
        if (Array.isArray(args_[i]))
          return args_[i].map((_, j) => encodeArg({ param, value: args_[i][j] }));
        return args_[i] ? encodeArg({ param, value: args_[i] }) : null;
      })) ?? [];
    }
  }
  return [signature2, ...topics];
}
function encodeArg({ param, value }) {
  if (param.type === "string" || param.type === "bytes")
    return keccak256(toBytes(value));
  if (param.type === "tuple" || param.type.match(/^(.*)\[(\d+)?\]$/))
    throw new FilterTypeNotSupportedError(param.type);
  return encodeAbiParameters([param], [value]);
}

// node_modules/@audius/sdk/node_modules/viem/_esm/utils/filters/createFilterRequestScope.js
function createFilterRequestScope(client, { method }) {
  var _a2, _b;
  const requestMap = {};
  if (client.transport.type === "fallback")
    (_b = (_a2 = client.transport).onResponse) == null ? void 0 : _b.call(_a2, ({ method: method_, response: id, status, transport }) => {
      if (status === "success" && method === method_)
        requestMap[id] = transport.request;
    });
  return ((id) => requestMap[id] || client.request);
}

// node_modules/@audius/sdk/node_modules/viem/_esm/actions/public/createContractEventFilter.js
async function createContractEventFilter(client, parameters) {
  const { address, abi: abi14, args, eventName, fromBlock, strict, toBlock } = parameters;
  const getRequest = createFilterRequestScope(client, {
    method: "eth_newFilter"
  });
  const topics = eventName ? encodeEventTopics({
    abi: abi14,
    args,
    eventName
  }) : void 0;
  const id = await client.request({
    method: "eth_newFilter",
    params: [
      {
        address,
        fromBlock: typeof fromBlock === "bigint" ? numberToHex(fromBlock) : fromBlock,
        toBlock: typeof toBlock === "bigint" ? numberToHex(toBlock) : toBlock,
        topics
      }
    ]
  });
  return {
    abi: abi14,
    args,
    eventName,
    id,
    request: getRequest(id),
    strict: Boolean(strict),
    type: "event"
  };
}

// node_modules/@audius/sdk/node_modules/viem/_esm/utils/errors/getContractError.js
var EXECUTION_REVERTED_ERROR_CODE = 3;
function getContractError(err2, { abi: abi14, address, args, docsPath: docsPath3, functionName, sender }) {
  const { code: code2, data, message, shortMessage } = err2 instanceof RawContractError ? err2 : err2 instanceof BaseError ? err2.walk((err3) => "data" in err3) || err2.walk() : {};
  const cause = (() => {
    if (err2 instanceof AbiDecodingZeroDataError)
      return new ContractFunctionZeroDataError({ functionName });
    if ([EXECUTION_REVERTED_ERROR_CODE, InternalRpcError.code].includes(code2) && (data || message || shortMessage)) {
      return new ContractFunctionRevertedError({
        abi: abi14,
        data: typeof data === "object" ? data.data : data,
        functionName,
        message: shortMessage ?? message
      });
    }
    return err2;
  })();
  return new ContractFunctionExecutionError(cause, {
    abi: abi14,
    args,
    contractAddress: address,
    docsPath: docsPath3,
    functionName,
    sender
  });
}

// node_modules/@audius/sdk/node_modules/viem/_esm/accounts/utils/publicKeyToAddress.js
function publicKeyToAddress(publicKey5) {
  const address = keccak256(`0x${publicKey5.substring(4)}`).substring(26);
  return checksumAddress(`0x${address}`);
}

// node_modules/@audius/sdk/node_modules/viem/_esm/utils/signature/recoverPublicKey.js
async function recoverPublicKey({ hash: hash3, signature: signature2 }) {
  const hashHex = isHex(hash3) ? hash3 : toHex(hash3);
  const { secp256k1: secp256k14 } = await import("./secp256k1-BE5FZRC6.js");
  const signature_ = (() => {
    if (typeof signature2 === "object" && "r" in signature2 && "s" in signature2) {
      const { r, s, v, yParity } = signature2;
      const yParityOrV2 = Number(yParity ?? v);
      const recoveryBit2 = toRecoveryBit(yParityOrV2);
      return new secp256k14.Signature(hexToBigInt(r), hexToBigInt(s)).addRecoveryBit(recoveryBit2);
    }
    const signatureHex = isHex(signature2) ? signature2 : toHex(signature2);
    const yParityOrV = hexToNumber(`0x${signatureHex.slice(130)}`);
    const recoveryBit = toRecoveryBit(yParityOrV);
    return secp256k14.Signature.fromCompact(signatureHex.substring(2, 130)).addRecoveryBit(recoveryBit);
  })();
  const publicKey5 = signature_.recoverPublicKey(hashHex.substring(2)).toHex(false);
  return `0x${publicKey5}`;
}
function toRecoveryBit(yParityOrV) {
  if (yParityOrV === 0 || yParityOrV === 1)
    return yParityOrV;
  if (yParityOrV === 27)
    return 0;
  if (yParityOrV === 28)
    return 1;
  throw new Error("Invalid yParityOrV value");
}

// node_modules/@audius/sdk/node_modules/viem/_esm/utils/signature/recoverAddress.js
async function recoverAddress({ hash: hash3, signature: signature2 }) {
  return publicKeyToAddress(await recoverPublicKey({ hash: hash3, signature: signature2 }));
}

// node_modules/@audius/sdk/node_modules/viem/_esm/utils/encoding/toRlp.js
function toRlp(bytes3, to = "hex") {
  const encodable = getEncodable(bytes3);
  const cursor = createCursor(new Uint8Array(encodable.length));
  encodable.encode(cursor);
  if (to === "hex")
    return bytesToHex(cursor.bytes);
  return cursor.bytes;
}
function getEncodable(bytes3) {
  if (Array.isArray(bytes3))
    return getEncodableList(bytes3.map((x) => getEncodable(x)));
  return getEncodableBytes(bytes3);
}
function getEncodableList(list) {
  const bodyLength = list.reduce((acc, x) => acc + x.length, 0);
  const sizeOfBodyLength = getSizeOfLength(bodyLength);
  const length2 = (() => {
    if (bodyLength <= 55)
      return 1 + bodyLength;
    return 1 + sizeOfBodyLength + bodyLength;
  })();
  return {
    length: length2,
    encode(cursor) {
      if (bodyLength <= 55) {
        cursor.pushByte(192 + bodyLength);
      } else {
        cursor.pushByte(192 + 55 + sizeOfBodyLength);
        if (sizeOfBodyLength === 1)
          cursor.pushUint8(bodyLength);
        else if (sizeOfBodyLength === 2)
          cursor.pushUint16(bodyLength);
        else if (sizeOfBodyLength === 3)
          cursor.pushUint24(bodyLength);
        else
          cursor.pushUint32(bodyLength);
      }
      for (const { encode: encode4 } of list) {
        encode4(cursor);
      }
    }
  };
}
function getEncodableBytes(bytesOrHex) {
  const bytes3 = typeof bytesOrHex === "string" ? hexToBytes(bytesOrHex) : bytesOrHex;
  const sizeOfBytesLength = getSizeOfLength(bytes3.length);
  const length2 = (() => {
    if (bytes3.length === 1 && bytes3[0] < 128)
      return 1;
    if (bytes3.length <= 55)
      return 1 + bytes3.length;
    return 1 + sizeOfBytesLength + bytes3.length;
  })();
  return {
    length: length2,
    encode(cursor) {
      if (bytes3.length === 1 && bytes3[0] < 128) {
        cursor.pushBytes(bytes3);
      } else if (bytes3.length <= 55) {
        cursor.pushByte(128 + bytes3.length);
        cursor.pushBytes(bytes3);
      } else {
        cursor.pushByte(128 + 55 + sizeOfBytesLength);
        if (sizeOfBytesLength === 1)
          cursor.pushUint8(bytes3.length);
        else if (sizeOfBytesLength === 2)
          cursor.pushUint16(bytes3.length);
        else if (sizeOfBytesLength === 3)
          cursor.pushUint24(bytes3.length);
        else
          cursor.pushUint32(bytes3.length);
        cursor.pushBytes(bytes3);
      }
    }
  };
}
function getSizeOfLength(length2) {
  if (length2 < 2 ** 8)
    return 1;
  if (length2 < 2 ** 16)
    return 2;
  if (length2 < 2 ** 24)
    return 3;
  if (length2 < 2 ** 32)
    return 4;
  throw new BaseError("Length is too large.");
}

// node_modules/@audius/sdk/node_modules/viem/_esm/experimental/eip7702/utils/hashAuthorization.js
function hashAuthorization(parameters) {
  const { chainId, contractAddress, nonce, to } = parameters;
  const hash3 = keccak256(concatHex([
    "0x05",
    toRlp([
      numberToHex(chainId),
      contractAddress,
      nonce ? numberToHex(nonce) : "0x"
    ])
  ]));
  if (to === "bytes")
    return hexToBytes(hash3);
  return hash3;
}

// node_modules/@audius/sdk/node_modules/viem/_esm/experimental/eip7702/utils/recoverAuthorizationAddress.js
async function recoverAuthorizationAddress(parameters) {
  const { authorization, signature: signature2 } = parameters;
  return recoverAddress({
    hash: hashAuthorization(authorization),
    signature: signature2 ?? authorization
  });
}

// node_modules/@audius/sdk/node_modules/viem/_esm/errors/estimateGas.js
var EstimateGasExecutionError = class extends BaseError {
  constructor(cause, { account, docsPath: docsPath3, chain: chain2, data, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value }) {
    var _a2;
    const prettyArgs = prettyPrint({
      from: account == null ? void 0 : account.address,
      to,
      value: typeof value !== "undefined" && `${formatEther(value)} ${((_a2 = chain2 == null ? void 0 : chain2.nativeCurrency) == null ? void 0 : _a2.symbol) || "ETH"}`,
      data,
      gas,
      gasPrice: typeof gasPrice !== "undefined" && `${formatGwei(gasPrice)} gwei`,
      maxFeePerGas: typeof maxFeePerGas !== "undefined" && `${formatGwei(maxFeePerGas)} gwei`,
      maxPriorityFeePerGas: typeof maxPriorityFeePerGas !== "undefined" && `${formatGwei(maxPriorityFeePerGas)} gwei`,
      nonce
    });
    super(cause.shortMessage, {
      cause,
      docsPath: docsPath3,
      metaMessages: [
        ...cause.metaMessages ? [...cause.metaMessages, " "] : [],
        "Estimate Gas Arguments:",
        prettyArgs
      ].filter(Boolean),
      name: "EstimateGasExecutionError"
    });
    Object.defineProperty(this, "cause", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.cause = cause;
  }
};

// node_modules/@audius/sdk/node_modules/viem/_esm/utils/errors/getEstimateGasError.js
function getEstimateGasError(err2, { docsPath: docsPath3, ...args }) {
  const cause = (() => {
    const cause2 = getNodeError(err2, args);
    if (cause2 instanceof UnknownNodeError)
      return err2;
    return cause2;
  })();
  return new EstimateGasExecutionError(cause, {
    docsPath: docsPath3,
    ...args
  });
}

// node_modules/@audius/sdk/node_modules/viem/_esm/errors/fee.js
var BaseFeeScalarError = class extends BaseError {
  constructor() {
    super("`baseFeeMultiplier` must be greater than 1.", {
      name: "BaseFeeScalarError"
    });
  }
};
var Eip1559FeesNotSupportedError = class extends BaseError {
  constructor() {
    super("Chain does not support EIP-1559 fees.", {
      name: "Eip1559FeesNotSupportedError"
    });
  }
};
var MaxFeePerGasTooLowError = class extends BaseError {
  constructor({ maxPriorityFeePerGas }) {
    super(`\`maxFeePerGas\` cannot be less than the \`maxPriorityFeePerGas\` (${formatGwei(maxPriorityFeePerGas)} gwei).`, { name: "MaxFeePerGasTooLowError" });
  }
};

// node_modules/@audius/sdk/node_modules/viem/_esm/errors/block.js
var BlockNotFoundError = class extends BaseError {
  constructor({ blockHash, blockNumber }) {
    let identifier = "Block";
    if (blockHash)
      identifier = `Block at hash "${blockHash}"`;
    if (blockNumber)
      identifier = `Block at number "${blockNumber}"`;
    super(`${identifier} could not be found.`, { name: "BlockNotFoundError" });
  }
};

// node_modules/@audius/sdk/node_modules/viem/_esm/utils/formatters/transaction.js
var transactionType = {
  "0x0": "legacy",
  "0x1": "eip2930",
  "0x2": "eip1559",
  "0x3": "eip4844",
  "0x4": "eip7702"
};
function formatTransaction(transaction) {
  const transaction_ = {
    ...transaction,
    blockHash: transaction.blockHash ? transaction.blockHash : null,
    blockNumber: transaction.blockNumber ? BigInt(transaction.blockNumber) : null,
    chainId: transaction.chainId ? hexToNumber(transaction.chainId) : void 0,
    gas: transaction.gas ? BigInt(transaction.gas) : void 0,
    gasPrice: transaction.gasPrice ? BigInt(transaction.gasPrice) : void 0,
    maxFeePerBlobGas: transaction.maxFeePerBlobGas ? BigInt(transaction.maxFeePerBlobGas) : void 0,
    maxFeePerGas: transaction.maxFeePerGas ? BigInt(transaction.maxFeePerGas) : void 0,
    maxPriorityFeePerGas: transaction.maxPriorityFeePerGas ? BigInt(transaction.maxPriorityFeePerGas) : void 0,
    nonce: transaction.nonce ? hexToNumber(transaction.nonce) : void 0,
    to: transaction.to ? transaction.to : null,
    transactionIndex: transaction.transactionIndex ? Number(transaction.transactionIndex) : null,
    type: transaction.type ? transactionType[transaction.type] : void 0,
    typeHex: transaction.type ? transaction.type : void 0,
    value: transaction.value ? BigInt(transaction.value) : void 0,
    v: transaction.v ? BigInt(transaction.v) : void 0
  };
  if (transaction.authorizationList)
    transaction_.authorizationList = formatAuthorizationList(transaction.authorizationList);
  transaction_.yParity = (() => {
    if (transaction.yParity)
      return Number(transaction.yParity);
    if (typeof transaction_.v === "bigint") {
      if (transaction_.v === 0n || transaction_.v === 27n)
        return 0;
      if (transaction_.v === 1n || transaction_.v === 28n)
        return 1;
      if (transaction_.v >= 35n)
        return transaction_.v % 2n === 0n ? 1 : 0;
    }
    return void 0;
  })();
  if (transaction_.type === "legacy") {
    delete transaction_.accessList;
    delete transaction_.maxFeePerBlobGas;
    delete transaction_.maxFeePerGas;
    delete transaction_.maxPriorityFeePerGas;
    delete transaction_.yParity;
  }
  if (transaction_.type === "eip2930") {
    delete transaction_.maxFeePerBlobGas;
    delete transaction_.maxFeePerGas;
    delete transaction_.maxPriorityFeePerGas;
  }
  if (transaction_.type === "eip1559") {
    delete transaction_.maxFeePerBlobGas;
  }
  return transaction_;
}
var defineTransaction = defineFormatter("transaction", formatTransaction);
function formatAuthorizationList(authorizationList) {
  return authorizationList.map((authorization) => ({
    contractAddress: authorization.address,
    r: authorization.r,
    s: authorization.s,
    chainId: Number(authorization.chainId),
    nonce: Number(authorization.nonce),
    ...typeof authorization.yParity !== "undefined" ? { yParity: Number(authorization.yParity) } : {},
    ...typeof authorization.v !== "undefined" && typeof authorization.yParity === "undefined" ? { v: Number(authorization.v) } : {}
  }));
}

// node_modules/@audius/sdk/node_modules/viem/_esm/utils/formatters/block.js
function formatBlock(block) {
  var _a2;
  const transactions = (_a2 = block.transactions) == null ? void 0 : _a2.map((transaction) => {
    if (typeof transaction === "string")
      return transaction;
    return formatTransaction(transaction);
  });
  return {
    ...block,
    baseFeePerGas: block.baseFeePerGas ? BigInt(block.baseFeePerGas) : null,
    blobGasUsed: block.blobGasUsed ? BigInt(block.blobGasUsed) : void 0,
    difficulty: block.difficulty ? BigInt(block.difficulty) : void 0,
    excessBlobGas: block.excessBlobGas ? BigInt(block.excessBlobGas) : void 0,
    gasLimit: block.gasLimit ? BigInt(block.gasLimit) : void 0,
    gasUsed: block.gasUsed ? BigInt(block.gasUsed) : void 0,
    hash: block.hash ? block.hash : null,
    logsBloom: block.logsBloom ? block.logsBloom : null,
    nonce: block.nonce ? block.nonce : null,
    number: block.number ? BigInt(block.number) : null,
    size: block.size ? BigInt(block.size) : void 0,
    timestamp: block.timestamp ? BigInt(block.timestamp) : void 0,
    transactions,
    totalDifficulty: block.totalDifficulty ? BigInt(block.totalDifficulty) : null
  };
}
var defineBlock = defineFormatter("block", formatBlock);

// node_modules/@audius/sdk/node_modules/viem/_esm/actions/public/getBlock.js
async function getBlock(client, { blockHash, blockNumber, blockTag: blockTag_, includeTransactions: includeTransactions_ } = {}) {
  var _a2, _b, _c;
  const blockTag = blockTag_ ?? "latest";
  const includeTransactions = includeTransactions_ ?? false;
  const blockNumberHex = blockNumber !== void 0 ? numberToHex(blockNumber) : void 0;
  let block = null;
  if (blockHash) {
    block = await client.request({
      method: "eth_getBlockByHash",
      params: [blockHash, includeTransactions]
    }, { dedupe: true });
  } else {
    block = await client.request({
      method: "eth_getBlockByNumber",
      params: [blockNumberHex || blockTag, includeTransactions]
    }, { dedupe: Boolean(blockNumberHex) });
  }
  if (!block)
    throw new BlockNotFoundError({ blockHash, blockNumber });
  const format2 = ((_c = (_b = (_a2 = client.chain) == null ? void 0 : _a2.formatters) == null ? void 0 : _b.block) == null ? void 0 : _c.format) || formatBlock;
  return format2(block);
}

// node_modules/@audius/sdk/node_modules/viem/_esm/actions/public/getGasPrice.js
async function getGasPrice(client) {
  const gasPrice = await client.request({
    method: "eth_gasPrice"
  });
  return BigInt(gasPrice);
}

// node_modules/@audius/sdk/node_modules/viem/_esm/actions/public/estimateMaxPriorityFeePerGas.js
async function estimateMaxPriorityFeePerGas(client, args) {
  return internal_estimateMaxPriorityFeePerGas(client, args);
}
async function internal_estimateMaxPriorityFeePerGas(client, args) {
  var _a2, _b;
  const { block: block_, chain: chain2 = client.chain, request } = args || {};
  try {
    const maxPriorityFeePerGas = ((_a2 = chain2 == null ? void 0 : chain2.fees) == null ? void 0 : _a2.maxPriorityFeePerGas) ?? ((_b = chain2 == null ? void 0 : chain2.fees) == null ? void 0 : _b.defaultPriorityFee);
    if (typeof maxPriorityFeePerGas === "function") {
      const block = block_ || await getAction(client, getBlock, "getBlock")({});
      const maxPriorityFeePerGas_ = await maxPriorityFeePerGas({
        block,
        client,
        request
      });
      if (maxPriorityFeePerGas_ === null)
        throw new Error();
      return maxPriorityFeePerGas_;
    }
    if (typeof maxPriorityFeePerGas !== "undefined")
      return maxPriorityFeePerGas;
    const maxPriorityFeePerGasHex = await client.request({
      method: "eth_maxPriorityFeePerGas"
    });
    return hexToBigInt(maxPriorityFeePerGasHex);
  } catch {
    const [block, gasPrice] = await Promise.all([
      block_ ? Promise.resolve(block_) : getAction(client, getBlock, "getBlock")({}),
      getAction(client, getGasPrice, "getGasPrice")({})
    ]);
    if (typeof block.baseFeePerGas !== "bigint")
      throw new Eip1559FeesNotSupportedError();
    const maxPriorityFeePerGas = gasPrice - block.baseFeePerGas;
    if (maxPriorityFeePerGas < 0n)
      return 0n;
    return maxPriorityFeePerGas;
  }
}

// node_modules/@audius/sdk/node_modules/viem/_esm/actions/public/estimateFeesPerGas.js
async function estimateFeesPerGas(client, args) {
  return internal_estimateFeesPerGas(client, args);
}
async function internal_estimateFeesPerGas(client, args) {
  var _a2, _b;
  const { block: block_, chain: chain2 = client.chain, request, type: type3 = "eip1559" } = args || {};
  const baseFeeMultiplier = await (async () => {
    var _a3, _b2;
    if (typeof ((_a3 = chain2 == null ? void 0 : chain2.fees) == null ? void 0 : _a3.baseFeeMultiplier) === "function")
      return chain2.fees.baseFeeMultiplier({
        block: block_,
        client,
        request
      });
    return ((_b2 = chain2 == null ? void 0 : chain2.fees) == null ? void 0 : _b2.baseFeeMultiplier) ?? 1.2;
  })();
  if (baseFeeMultiplier < 1)
    throw new BaseFeeScalarError();
  const decimals = ((_a2 = baseFeeMultiplier.toString().split(".")[1]) == null ? void 0 : _a2.length) ?? 0;
  const denominator = 10 ** decimals;
  const multiply = (base3) => base3 * BigInt(Math.ceil(baseFeeMultiplier * denominator)) / BigInt(denominator);
  const block = block_ ? block_ : await getAction(client, getBlock, "getBlock")({});
  if (typeof ((_b = chain2 == null ? void 0 : chain2.fees) == null ? void 0 : _b.estimateFeesPerGas) === "function") {
    const fees = await chain2.fees.estimateFeesPerGas({
      block: block_,
      client,
      multiply,
      request,
      type: type3
    });
    if (fees !== null)
      return fees;
  }
  if (type3 === "eip1559") {
    if (typeof block.baseFeePerGas !== "bigint")
      throw new Eip1559FeesNotSupportedError();
    const maxPriorityFeePerGas = typeof (request == null ? void 0 : request.maxPriorityFeePerGas) === "bigint" ? request.maxPriorityFeePerGas : await internal_estimateMaxPriorityFeePerGas(client, {
      block,
      chain: chain2,
      request
    });
    const baseFeePerGas = multiply(block.baseFeePerGas);
    const maxFeePerGas = (request == null ? void 0 : request.maxFeePerGas) ?? baseFeePerGas + maxPriorityFeePerGas;
    return {
      maxFeePerGas,
      maxPriorityFeePerGas
    };
  }
  const gasPrice = (request == null ? void 0 : request.gasPrice) ?? multiply(await getAction(client, getGasPrice, "getGasPrice")({}));
  return {
    gasPrice
  };
}

// node_modules/@audius/sdk/node_modules/viem/_esm/actions/public/getTransactionCount.js
async function getTransactionCount(client, { address, blockTag = "latest", blockNumber }) {
  const count = await client.request({
    method: "eth_getTransactionCount",
    params: [address, blockNumber ? numberToHex(blockNumber) : blockTag]
  }, { dedupe: Boolean(blockNumber) });
  return hexToNumber(count);
}

// node_modules/@audius/sdk/node_modules/viem/_esm/utils/blob/blobsToCommitments.js
function blobsToCommitments(parameters) {
  const { kzg } = parameters;
  const to = parameters.to ?? (typeof parameters.blobs[0] === "string" ? "hex" : "bytes");
  const blobs = typeof parameters.blobs[0] === "string" ? parameters.blobs.map((x) => hexToBytes(x)) : parameters.blobs;
  const commitments = [];
  for (const blob12 of blobs)
    commitments.push(Uint8Array.from(kzg.blobToKzgCommitment(blob12)));
  return to === "bytes" ? commitments : commitments.map((x) => bytesToHex(x));
}

// node_modules/@audius/sdk/node_modules/viem/_esm/utils/blob/blobsToProofs.js
function blobsToProofs(parameters) {
  const { kzg } = parameters;
  const to = parameters.to ?? (typeof parameters.blobs[0] === "string" ? "hex" : "bytes");
  const blobs = typeof parameters.blobs[0] === "string" ? parameters.blobs.map((x) => hexToBytes(x)) : parameters.blobs;
  const commitments = typeof parameters.commitments[0] === "string" ? parameters.commitments.map((x) => hexToBytes(x)) : parameters.commitments;
  const proofs = [];
  for (let i = 0; i < blobs.length; i++) {
    const blob12 = blobs[i];
    const commitment = commitments[i];
    proofs.push(Uint8Array.from(kzg.computeBlobKzgProof(blob12, commitment)));
  }
  return to === "bytes" ? proofs : proofs.map((x) => bytesToHex(x));
}

// node_modules/@audius/sdk/node_modules/viem/node_modules/@noble/hashes/esm/_md.js
function setBigUint64(view, byteOffset, value, isLE6) {
  if (typeof view.setBigUint64 === "function")
    return view.setBigUint64(byteOffset, value, isLE6);
  const _32n6 = BigInt(32);
  const _u32_max = BigInt(4294967295);
  const wh = Number(value >> _32n6 & _u32_max);
  const wl = Number(value & _u32_max);
  const h = isLE6 ? 4 : 0;
  const l = isLE6 ? 0 : 4;
  view.setUint32(byteOffset + h, wh, isLE6);
  view.setUint32(byteOffset + l, wl, isLE6);
}
var Chi = (a, b, c) => a & b ^ ~a & c;
var Maj = (a, b, c) => a & b ^ a & c ^ b & c;
var HashMD = class extends Hash {
  constructor(blockLen, outputLen, padOffset, isLE6) {
    super();
    this.blockLen = blockLen;
    this.outputLen = outputLen;
    this.padOffset = padOffset;
    this.isLE = isLE6;
    this.finished = false;
    this.length = 0;
    this.pos = 0;
    this.destroyed = false;
    this.buffer = new Uint8Array(blockLen);
    this.view = createView(this.buffer);
  }
  update(data) {
    exists(this);
    const { view, buffer: buffer3, blockLen } = this;
    data = toBytes2(data);
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      if (take === blockLen) {
        const dataView = createView(data);
        for (; blockLen <= len - pos; pos += blockLen)
          this.process(dataView, pos);
        continue;
      }
      buffer3.set(data.subarray(pos, pos + take), this.pos);
      this.pos += take;
      pos += take;
      if (this.pos === blockLen) {
        this.process(view, 0);
        this.pos = 0;
      }
    }
    this.length += data.length;
    this.roundClean();
    return this;
  }
  digestInto(out) {
    exists(this);
    output(out, this);
    this.finished = true;
    const { buffer: buffer3, view, blockLen, isLE: isLE6 } = this;
    let { pos } = this;
    buffer3[pos++] = 128;
    this.buffer.subarray(pos).fill(0);
    if (this.padOffset > blockLen - pos) {
      this.process(view, 0);
      pos = 0;
    }
    for (let i = pos; i < blockLen; i++)
      buffer3[i] = 0;
    setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE6);
    this.process(view, 0);
    const oview = createView(out);
    const len = this.outputLen;
    if (len % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const outLen = len / 4;
    const state = this.get();
    if (outLen > state.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let i = 0; i < outLen; i++)
      oview.setUint32(4 * i, state[i], isLE6);
  }
  digest() {
    const { buffer: buffer3, outputLen } = this;
    this.digestInto(buffer3);
    const res = buffer3.slice(0, outputLen);
    this.destroy();
    return res;
  }
  _cloneInto(to) {
    to || (to = new this.constructor());
    to.set(...this.get());
    const { blockLen, buffer: buffer3, length: length2, finished: finished2, destroyed, pos } = this;
    to.length = length2;
    to.pos = pos;
    to.finished = finished2;
    to.destroyed = destroyed;
    if (length2 % blockLen)
      to.buffer.set(buffer3);
    return to;
  }
};

// node_modules/@audius/sdk/node_modules/viem/node_modules/@noble/hashes/esm/sha256.js
var SHA256_K = new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
var SHA256_IV = new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
var SHA256_W = new Uint32Array(64);
var SHA256 = class extends HashMD {
  constructor() {
    super(64, 32, 8, false);
    this.A = SHA256_IV[0] | 0;
    this.B = SHA256_IV[1] | 0;
    this.C = SHA256_IV[2] | 0;
    this.D = SHA256_IV[3] | 0;
    this.E = SHA256_IV[4] | 0;
    this.F = SHA256_IV[5] | 0;
    this.G = SHA256_IV[6] | 0;
    this.H = SHA256_IV[7] | 0;
  }
  get() {
    const { A, B, C, D, E, F, G, H } = this;
    return [A, B, C, D, E, F, G, H];
  }
  // prettier-ignore
  set(A, B, C, D, E, F, G, H) {
    this.A = A | 0;
    this.B = B | 0;
    this.C = C | 0;
    this.D = D | 0;
    this.E = E | 0;
    this.F = F | 0;
    this.G = G | 0;
    this.H = H | 0;
  }
  process(view, offset3) {
    for (let i = 0; i < 16; i++, offset3 += 4)
      SHA256_W[i] = view.getUint32(offset3, false);
    for (let i = 16; i < 64; i++) {
      const W15 = SHA256_W[i - 15];
      const W2 = SHA256_W[i - 2];
      const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ W15 >>> 3;
      const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ W2 >>> 10;
      SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;
    }
    let { A, B, C, D, E, F, G, H } = this;
    for (let i = 0; i < 64; i++) {
      const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);
      const T1 = H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;
      const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);
      const T2 = sigma0 + Maj(A, B, C) | 0;
      H = G;
      G = F;
      F = E;
      E = D + T1 | 0;
      D = C;
      C = B;
      B = A;
      A = T1 + T2 | 0;
    }
    A = A + this.A | 0;
    B = B + this.B | 0;
    C = C + this.C | 0;
    D = D + this.D | 0;
    E = E + this.E | 0;
    F = F + this.F | 0;
    G = G + this.G | 0;
    H = H + this.H | 0;
    this.set(A, B, C, D, E, F, G, H);
  }
  roundClean() {
    SHA256_W.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0);
    this.buffer.fill(0);
  }
};
var SHA224 = class extends SHA256 {
  constructor() {
    super();
    this.A = 3238371032 | 0;
    this.B = 914150663 | 0;
    this.C = 812702999 | 0;
    this.D = 4144912697 | 0;
    this.E = 4290775857 | 0;
    this.F = 1750603025 | 0;
    this.G = 1694076839 | 0;
    this.H = 3204075428 | 0;
    this.outputLen = 28;
  }
};
var sha256 = wrapConstructor(() => new SHA256());
var sha224 = wrapConstructor(() => new SHA224());

// node_modules/@audius/sdk/node_modules/viem/_esm/utils/hash/sha256.js
function sha2562(value, to_) {
  const to = to_ || "hex";
  const bytes3 = sha256(isHex(value, { strict: false }) ? toBytes(value) : value);
  if (to === "bytes")
    return bytes3;
  return toHex(bytes3);
}

// node_modules/@audius/sdk/node_modules/viem/_esm/utils/blob/commitmentToVersionedHash.js
function commitmentToVersionedHash(parameters) {
  const { commitment, version: version3 = 1 } = parameters;
  const to = parameters.to ?? (typeof commitment === "string" ? "hex" : "bytes");
  const versionedHash = sha2562(commitment, "bytes");
  versionedHash.set([version3], 0);
  return to === "bytes" ? versionedHash : bytesToHex(versionedHash);
}

// node_modules/@audius/sdk/node_modules/viem/_esm/utils/blob/commitmentsToVersionedHashes.js
function commitmentsToVersionedHashes(parameters) {
  const { commitments, version: version3 } = parameters;
  const to = parameters.to ?? (typeof commitments[0] === "string" ? "hex" : "bytes");
  const hashes = [];
  for (const commitment of commitments) {
    hashes.push(commitmentToVersionedHash({
      commitment,
      to,
      version: version3
    }));
  }
  return hashes;
}

// node_modules/@audius/sdk/node_modules/viem/_esm/constants/blob.js
var blobsPerTransaction = 6;
var bytesPerFieldElement = 32;
var fieldElementsPerBlob = 4096;
var bytesPerBlob = bytesPerFieldElement * fieldElementsPerBlob;
var maxBytesPerTransaction = bytesPerBlob * blobsPerTransaction - // terminator byte (0x80).
1 - // zero byte (0x00) appended to each field element.
1 * fieldElementsPerBlob * blobsPerTransaction;

// node_modules/@audius/sdk/node_modules/viem/_esm/errors/blob.js
var BlobSizeTooLargeError = class extends BaseError {
  constructor({ maxSize, size: size4 }) {
    super("Blob size is too large.", {
      metaMessages: [`Max: ${maxSize} bytes`, `Given: ${size4} bytes`],
      name: "BlobSizeTooLargeError"
    });
  }
};
var EmptyBlobError = class extends BaseError {
  constructor() {
    super("Blob data must not be empty.", { name: "EmptyBlobError" });
  }
};

// node_modules/@audius/sdk/node_modules/viem/_esm/utils/blob/toBlobs.js
function toBlobs(parameters) {
  const to = parameters.to ?? (typeof parameters.data === "string" ? "hex" : "bytes");
  const data = typeof parameters.data === "string" ? hexToBytes(parameters.data) : parameters.data;
  const size_ = size(data);
  if (!size_)
    throw new EmptyBlobError();
  if (size_ > maxBytesPerTransaction)
    throw new BlobSizeTooLargeError({
      maxSize: maxBytesPerTransaction,
      size: size_
    });
  const blobs = [];
  let active = true;
  let position = 0;
  while (active) {
    const blob12 = createCursor(new Uint8Array(bytesPerBlob));
    let size4 = 0;
    while (size4 < fieldElementsPerBlob) {
      const bytes3 = data.slice(position, position + (bytesPerFieldElement - 1));
      blob12.pushByte(0);
      blob12.pushBytes(bytes3);
      if (bytes3.length < 31) {
        blob12.pushByte(128);
        active = false;
        break;
      }
      size4++;
      position += 31;
    }
    blobs.push(blob12);
  }
  return to === "bytes" ? blobs.map((x) => x.bytes) : blobs.map((x) => bytesToHex(x.bytes));
}

// node_modules/@audius/sdk/node_modules/viem/_esm/utils/blob/toBlobSidecars.js
function toBlobSidecars(parameters) {
  const { data, kzg, to } = parameters;
  const blobs = parameters.blobs ?? toBlobs({ data, to });
  const commitments = parameters.commitments ?? blobsToCommitments({ blobs, kzg, to });
  const proofs = parameters.proofs ?? blobsToProofs({ blobs, commitments, kzg, to });
  const sidecars = [];
  for (let i = 0; i < blobs.length; i++)
    sidecars.push({
      blob: blobs[i],
      commitment: commitments[i],
      proof: proofs[i]
    });
  return sidecars;
}

// node_modules/@audius/sdk/node_modules/viem/_esm/utils/transaction/getTransactionType.js
function getTransactionType(transaction) {
  if (transaction.type)
    return transaction.type;
  if (typeof transaction.authorizationList !== "undefined")
    return "eip7702";
  if (typeof transaction.blobs !== "undefined" || typeof transaction.blobVersionedHashes !== "undefined" || typeof transaction.maxFeePerBlobGas !== "undefined" || typeof transaction.sidecars !== "undefined")
    return "eip4844";
  if (typeof transaction.maxFeePerGas !== "undefined" || typeof transaction.maxPriorityFeePerGas !== "undefined") {
    return "eip1559";
  }
  if (typeof transaction.gasPrice !== "undefined") {
    if (typeof transaction.accessList !== "undefined")
      return "eip2930";
    return "legacy";
  }
  throw new InvalidSerializableTransactionError({ transaction });
}

// node_modules/@audius/sdk/node_modules/viem/_esm/actions/public/getChainId.js
async function getChainId(client) {
  const chainIdHex = await client.request({
    method: "eth_chainId"
  }, { dedupe: true });
  return hexToNumber(chainIdHex);
}

// node_modules/@audius/sdk/node_modules/viem/_esm/actions/wallet/prepareTransactionRequest.js
var defaultParameters = [
  "blobVersionedHashes",
  "chainId",
  "fees",
  "gas",
  "nonce",
  "type"
];
async function prepareTransactionRequest(client, args) {
  const { account: account_ = client.account, blobs, chain: chain2, gas, kzg, nonce, nonceManager: nonceManager2, parameters = defaultParameters, type: type3 } = args;
  const account = account_ ? parseAccount(account_) : void 0;
  const request = { ...args, ...account ? { from: account == null ? void 0 : account.address } : {} };
  let block;
  async function getBlock2() {
    if (block)
      return block;
    block = await getAction(client, getBlock, "getBlock")({ blockTag: "latest" });
    return block;
  }
  let chainId;
  async function getChainId2() {
    if (chainId)
      return chainId;
    if (chain2)
      return chain2.id;
    if (typeof args.chainId !== "undefined")
      return args.chainId;
    const chainId_ = await getAction(client, getChainId, "getChainId")({});
    chainId = chainId_;
    return chainId;
  }
  if ((parameters.includes("blobVersionedHashes") || parameters.includes("sidecars")) && blobs && kzg) {
    const commitments = blobsToCommitments({ blobs, kzg });
    if (parameters.includes("blobVersionedHashes")) {
      const versionedHashes = commitmentsToVersionedHashes({
        commitments,
        to: "hex"
      });
      request.blobVersionedHashes = versionedHashes;
    }
    if (parameters.includes("sidecars")) {
      const proofs = blobsToProofs({ blobs, commitments, kzg });
      const sidecars = toBlobSidecars({
        blobs,
        commitments,
        proofs,
        to: "hex"
      });
      request.sidecars = sidecars;
    }
  }
  if (parameters.includes("chainId"))
    request.chainId = await getChainId2();
  if (parameters.includes("nonce") && typeof nonce === "undefined" && account) {
    if (nonceManager2) {
      const chainId2 = await getChainId2();
      request.nonce = await nonceManager2.consume({
        address: account.address,
        chainId: chainId2,
        client
      });
    } else {
      request.nonce = await getAction(client, getTransactionCount, "getTransactionCount")({
        address: account.address,
        blockTag: "pending"
      });
    }
  }
  if ((parameters.includes("fees") || parameters.includes("type")) && typeof type3 === "undefined") {
    try {
      request.type = getTransactionType(request);
    } catch {
      const block2 = await getBlock2();
      request.type = typeof (block2 == null ? void 0 : block2.baseFeePerGas) === "bigint" ? "eip1559" : "legacy";
    }
  }
  if (parameters.includes("fees")) {
    if (request.type !== "legacy" && request.type !== "eip2930") {
      if (typeof request.maxFeePerGas === "undefined" || typeof request.maxPriorityFeePerGas === "undefined") {
        const block2 = await getBlock2();
        const { maxFeePerGas, maxPriorityFeePerGas } = await internal_estimateFeesPerGas(client, {
          block: block2,
          chain: chain2,
          request
        });
        if (typeof args.maxPriorityFeePerGas === "undefined" && args.maxFeePerGas && args.maxFeePerGas < maxPriorityFeePerGas)
          throw new MaxFeePerGasTooLowError({
            maxPriorityFeePerGas
          });
        request.maxPriorityFeePerGas = maxPriorityFeePerGas;
        request.maxFeePerGas = maxFeePerGas;
      }
    } else {
      if (typeof args.maxFeePerGas !== "undefined" || typeof args.maxPriorityFeePerGas !== "undefined")
        throw new Eip1559FeesNotSupportedError();
      const block2 = await getBlock2();
      const { gasPrice: gasPrice_ } = await internal_estimateFeesPerGas(client, {
        block: block2,
        chain: chain2,
        request,
        type: "legacy"
      });
      request.gasPrice = gasPrice_;
    }
  }
  if (parameters.includes("gas") && typeof gas === "undefined")
    request.gas = await getAction(client, estimateGas, "estimateGas")({
      ...request,
      account: account ? { address: account.address, type: "json-rpc" } : void 0
    });
  assertRequest(request);
  delete request.parameters;
  return request;
}

// node_modules/@audius/sdk/node_modules/viem/_esm/actions/public/getBalance.js
async function getBalance(client, { address, blockNumber, blockTag = "latest" }) {
  const blockNumberHex = blockNumber ? numberToHex(blockNumber) : void 0;
  const balance = await client.request({
    method: "eth_getBalance",
    params: [address, blockNumberHex || blockTag]
  });
  return BigInt(balance);
}

// node_modules/@audius/sdk/node_modules/viem/_esm/actions/public/estimateGas.js
async function estimateGas(client, args) {
  var _a2, _b, _c;
  const account_ = args.account ?? client.account;
  const account = account_ ? parseAccount(account_) : void 0;
  try {
    let estimateGas_rpc = function(parameters) {
      const { block: block2, request: request2, rpcStateOverride: rpcStateOverride2 } = parameters;
      return client.request({
        method: "eth_estimateGas",
        params: rpcStateOverride2 ? [request2, block2 ?? "latest", rpcStateOverride2] : block2 ? [request2, block2] : [request2]
      });
    };
    const { accessList, authorizationList, blobs, blobVersionedHashes, blockNumber, blockTag, data, gas, gasPrice, maxFeePerBlobGas, maxFeePerGas, maxPriorityFeePerGas, nonce, value, stateOverride, ...rest } = await prepareTransactionRequest(client, {
      ...args,
      parameters: (
        // Some RPC Providers do not compute versioned hashes from blobs. We will need
        // to compute them.
        (account == null ? void 0 : account.type) === "local" ? void 0 : ["blobVersionedHashes"]
      )
    });
    const blockNumberHex = blockNumber ? numberToHex(blockNumber) : void 0;
    const block = blockNumberHex || blockTag;
    const rpcStateOverride = serializeStateOverride(stateOverride);
    const to = await (async () => {
      if (rest.to)
        return rest.to;
      if (authorizationList && authorizationList.length > 0)
        return await recoverAuthorizationAddress({
          authorization: authorizationList[0]
        }).catch(() => {
          throw new BaseError("`to` is required. Could not infer from `authorizationList`");
        });
      return void 0;
    })();
    assertRequest(args);
    const chainFormat = (_c = (_b = (_a2 = client.chain) == null ? void 0 : _a2.formatters) == null ? void 0 : _b.transactionRequest) == null ? void 0 : _c.format;
    const format2 = chainFormat || formatTransactionRequest;
    const request = format2({
      // Pick out extra data that might exist on the chain's transaction request type.
      ...extract(rest, { format: chainFormat }),
      from: account == null ? void 0 : account.address,
      accessList,
      authorizationList,
      blobs,
      blobVersionedHashes,
      data,
      gas,
      gasPrice,
      maxFeePerBlobGas,
      maxFeePerGas,
      maxPriorityFeePerGas,
      nonce,
      to,
      value
    });
    let estimate = BigInt(await estimateGas_rpc({ block, request, rpcStateOverride }));
    if (authorizationList) {
      const value2 = await getBalance(client, { address: request.from });
      const estimates = await Promise.all(authorizationList.map(async (authorization) => {
        const { contractAddress } = authorization;
        const estimate2 = await estimateGas_rpc({
          block,
          request: {
            authorizationList: void 0,
            data,
            from: account == null ? void 0 : account.address,
            to: contractAddress,
            value: numberToHex(value2)
          },
          rpcStateOverride
        }).catch(() => 100000n);
        return 2n * BigInt(estimate2);
      }));
      estimate += estimates.reduce((acc, curr) => acc + curr, 0n);
    }
    return estimate;
  } catch (err2) {
    throw getEstimateGasError(err2, {
      ...args,
      account,
      chain: client.chain
    });
  }
}

// node_modules/@audius/sdk/node_modules/viem/_esm/actions/public/estimateContractGas.js
async function estimateContractGas(client, parameters) {
  const { abi: abi14, address, args, functionName, ...request } = parameters;
  const data = encodeFunctionData({
    abi: abi14,
    args,
    functionName
  });
  try {
    const gas = await getAction(client, estimateGas, "estimateGas")({
      data,
      to: address,
      ...request
    });
    return gas;
  } catch (error) {
    const account = request.account ? parseAccount(request.account) : void 0;
    throw getContractError(error, {
      abi: abi14,
      address,
      args,
      docsPath: "/docs/contract/estimateContractGas",
      functionName,
      sender: account == null ? void 0 : account.address
    });
  }
}

// node_modules/@audius/sdk/node_modules/viem/_esm/utils/abi/decodeEventLog.js
var docsPath2 = "/docs/contract/decodeEventLog";
function decodeEventLog(parameters) {
  const { abi: abi14, data, strict: strict_, topics } = parameters;
  const strict = strict_ ?? true;
  const [signature2, ...argTopics] = topics;
  if (!signature2)
    throw new AbiEventSignatureEmptyTopicsError({ docsPath: docsPath2 });
  const abiItem = (() => {
    if (abi14.length === 1)
      return abi14[0];
    return abi14.find((x) => x.type === "event" && signature2 === toEventSelector(formatAbiItem(x)));
  })();
  if (!(abiItem && "name" in abiItem) || abiItem.type !== "event")
    throw new AbiEventSignatureNotFoundError(signature2, { docsPath: docsPath2 });
  const { name, inputs } = abiItem;
  const isUnnamed = inputs == null ? void 0 : inputs.some((x) => !("name" in x && x.name));
  let args = isUnnamed ? [] : {};
  const indexedInputs = inputs.filter((x) => "indexed" in x && x.indexed);
  for (let i = 0; i < indexedInputs.length; i++) {
    const param = indexedInputs[i];
    const topic = argTopics[i];
    if (!topic)
      throw new DecodeLogTopicsMismatch({
        abiItem,
        param
      });
    args[isUnnamed ? i : param.name || i] = decodeTopic({ param, value: topic });
  }
  const nonIndexedInputs = inputs.filter((x) => !("indexed" in x && x.indexed));
  if (nonIndexedInputs.length > 0) {
    if (data && data !== "0x") {
      try {
        const decodedData = decodeAbiParameters(nonIndexedInputs, data);
        if (decodedData) {
          if (isUnnamed)
            args = [...args, ...decodedData];
          else {
            for (let i = 0; i < nonIndexedInputs.length; i++) {
              args[nonIndexedInputs[i].name] = decodedData[i];
            }
          }
        }
      } catch (err2) {
        if (strict) {
          if (err2 instanceof AbiDecodingDataSizeTooSmallError || err2 instanceof PositionOutOfBoundsError)
            throw new DecodeLogDataMismatch({
              abiItem,
              data,
              params: nonIndexedInputs,
              size: size(data)
            });
          throw err2;
        }
      }
    } else if (strict) {
      throw new DecodeLogDataMismatch({
        abiItem,
        data: "0x",
        params: nonIndexedInputs,
        size: 0
      });
    }
  }
  return {
    eventName: name,
    args: Object.values(args).length > 0 ? args : void 0
  };
}
function decodeTopic({ param, value }) {
  if (param.type === "string" || param.type === "bytes" || param.type === "tuple" || param.type.match(/^(.*)\[(\d+)?\]$/))
    return value;
  const decodedArg = decodeAbiParameters([param], value) || [];
  return decodedArg[0];
}

// node_modules/@audius/sdk/node_modules/viem/_esm/utils/abi/parseEventLogs.js
function parseEventLogs(parameters) {
  const { abi: abi14, args, logs, strict = true } = parameters;
  const eventName = (() => {
    if (!parameters.eventName)
      return void 0;
    if (Array.isArray(parameters.eventName))
      return parameters.eventName;
    return [parameters.eventName];
  })();
  return logs.map((log) => {
    var _a2;
    try {
      const abiItem = abi14.find((abiItem2) => abiItem2.type === "event" && log.topics[0] === toEventSelector(abiItem2));
      if (!abiItem)
        return null;
      const event = decodeEventLog({
        ...log,
        abi: [abiItem],
        strict
      });
      if (eventName && !eventName.includes(event.eventName))
        return null;
      if (!includesArgs({
        args: event.args,
        inputs: abiItem.inputs,
        matchArgs: args
      }))
        return null;
      return { ...event, ...log };
    } catch (err2) {
      let eventName2;
      let isUnnamed;
      if (err2 instanceof AbiEventSignatureNotFoundError)
        return null;
      if (err2 instanceof DecodeLogDataMismatch || err2 instanceof DecodeLogTopicsMismatch) {
        if (strict)
          return null;
        eventName2 = err2.abiItem.name;
        isUnnamed = (_a2 = err2.abiItem.inputs) == null ? void 0 : _a2.some((x) => !("name" in x && x.name));
      }
      return { ...log, args: isUnnamed ? [] : {}, eventName: eventName2 };
    }
  }).filter(Boolean);
}
function includesArgs(parameters) {
  const { args, inputs, matchArgs } = parameters;
  if (!matchArgs)
    return true;
  if (!args)
    return false;
  function isEqual(input, value, arg) {
    try {
      if (input.type === "address")
        return isAddressEqual(value, arg);
      if (input.type === "string" || input.type === "bytes")
        return keccak256(toBytes(value)) === arg;
      return value === arg;
    } catch {
      return false;
    }
  }
  if (Array.isArray(args) && Array.isArray(matchArgs)) {
    return matchArgs.every((value, index4) => {
      if (value === null || value === void 0)
        return true;
      const input = inputs[index4];
      if (!input)
        return false;
      const value_ = Array.isArray(value) ? value : [value];
      return value_.some((value2) => isEqual(input, value2, args[index4]));
    });
  }
  if (typeof args === "object" && !Array.isArray(args) && typeof matchArgs === "object" && !Array.isArray(matchArgs))
    return Object.entries(matchArgs).every(([key, value]) => {
      if (value === null || value === void 0)
        return true;
      const input = inputs.find((input2) => input2.name === key);
      if (!input)
        return false;
      const value_ = Array.isArray(value) ? value : [value];
      return value_.some((value2) => isEqual(input, value2, args[key]));
    });
  return false;
}

// node_modules/@audius/sdk/node_modules/viem/_esm/utils/formatters/log.js
function formatLog(log, { args, eventName } = {}) {
  return {
    ...log,
    blockHash: log.blockHash ? log.blockHash : null,
    blockNumber: log.blockNumber ? BigInt(log.blockNumber) : null,
    logIndex: log.logIndex ? Number(log.logIndex) : null,
    transactionHash: log.transactionHash ? log.transactionHash : null,
    transactionIndex: log.transactionIndex ? Number(log.transactionIndex) : null,
    ...eventName ? { args, eventName } : {}
  };
}

// node_modules/@audius/sdk/node_modules/viem/_esm/actions/public/getLogs.js
async function getLogs(client, { address, blockHash, fromBlock, toBlock, event, events: events_, args, strict: strict_ } = {}) {
  const strict = strict_ ?? false;
  const events2 = events_ ?? (event ? [event] : void 0);
  let topics = [];
  if (events2) {
    const encoded = events2.flatMap((event2) => encodeEventTopics({
      abi: [event2],
      eventName: event2.name,
      args: events_ ? void 0 : args
    }));
    topics = [encoded];
    if (event)
      topics = topics[0];
  }
  let logs;
  if (blockHash) {
    logs = await client.request({
      method: "eth_getLogs",
      params: [{ address, topics, blockHash }]
    });
  } else {
    logs = await client.request({
      method: "eth_getLogs",
      params: [
        {
          address,
          topics,
          fromBlock: typeof fromBlock === "bigint" ? numberToHex(fromBlock) : fromBlock,
          toBlock: typeof toBlock === "bigint" ? numberToHex(toBlock) : toBlock
        }
      ]
    });
  }
  const formattedLogs = logs.map((log) => formatLog(log));
  if (!events2)
    return formattedLogs;
  return parseEventLogs({
    abi: events2,
    args,
    logs: formattedLogs,
    strict
  });
}

// node_modules/@audius/sdk/node_modules/viem/_esm/actions/public/getContractEvents.js
async function getContractEvents(client, parameters) {
  const { abi: abi14, address, args, blockHash, eventName, fromBlock, toBlock, strict } = parameters;
  const event = eventName ? getAbiItem({ abi: abi14, name: eventName }) : void 0;
  const events2 = !event ? abi14.filter((x) => x.type === "event") : void 0;
  return getAction(client, getLogs, "getLogs")({
    address,
    args,
    blockHash,
    event,
    events: events2,
    fromBlock,
    toBlock,
    strict
  });
}

// node_modules/@audius/sdk/node_modules/viem/_esm/actions/public/readContract.js
async function readContract(client, parameters) {
  const { abi: abi14, address, args, functionName, ...rest } = parameters;
  const calldata = encodeFunctionData({
    abi: abi14,
    args,
    functionName
  });
  try {
    const { data } = await getAction(client, call, "call")({
      ...rest,
      data: calldata,
      to: address
    });
    return decodeFunctionResult({
      abi: abi14,
      args,
      functionName,
      data: data || "0x"
    });
  } catch (error) {
    throw getContractError(error, {
      abi: abi14,
      address,
      args,
      docsPath: "/docs/contract/readContract",
      functionName
    });
  }
}

// node_modules/@audius/sdk/node_modules/viem/_esm/actions/public/simulateContract.js
async function simulateContract(client, parameters) {
  const { abi: abi14, address, args, dataSuffix, functionName, ...callRequest } = parameters;
  const account = callRequest.account ? parseAccount(callRequest.account) : client.account;
  const calldata = encodeFunctionData({ abi: abi14, args, functionName });
  try {
    const { data } = await getAction(client, call, "call")({
      batch: false,
      data: `${calldata}${dataSuffix ? dataSuffix.replace("0x", "") : ""}`,
      to: address,
      ...callRequest,
      account
    });
    const result = decodeFunctionResult({
      abi: abi14,
      args,
      functionName,
      data: data || "0x"
    });
    const minimizedAbi = abi14.filter((abiItem) => "name" in abiItem && abiItem.name === parameters.functionName);
    return {
      result,
      request: {
        abi: minimizedAbi,
        address,
        args,
        dataSuffix,
        functionName,
        ...callRequest,
        account
      }
    };
  } catch (error) {
    throw getContractError(error, {
      abi: abi14,
      address,
      args,
      docsPath: "/docs/contract/simulateContract",
      functionName,
      sender: account == null ? void 0 : account.address
    });
  }
}

// node_modules/@audius/sdk/node_modules/viem/_esm/utils/observe.js
var listenersCache = /* @__PURE__ */ new Map();
var cleanupCache = /* @__PURE__ */ new Map();
var callbackCount = 0;
function observe(observerId, callbacks, fn) {
  const callbackId = ++callbackCount;
  const getListeners = () => listenersCache.get(observerId) || [];
  const unsubscribe = () => {
    const listeners2 = getListeners();
    listenersCache.set(observerId, listeners2.filter((cb) => cb.id !== callbackId));
  };
  const unwatch = () => {
    const cleanup2 = cleanupCache.get(observerId);
    if (getListeners().length === 1 && cleanup2)
      cleanup2();
    unsubscribe();
  };
  const listeners = getListeners();
  listenersCache.set(observerId, [
    ...listeners,
    { id: callbackId, fns: callbacks }
  ]);
  if (listeners && listeners.length > 0)
    return unwatch;
  const emit = {};
  for (const key in callbacks) {
    emit[key] = ((...args) => {
      var _a2, _b;
      const listeners2 = getListeners();
      if (listeners2.length === 0)
        return;
      for (const listener of listeners2)
        (_b = (_a2 = listener.fns)[key]) == null ? void 0 : _b.call(_a2, ...args);
    });
  }
  const cleanup = fn(emit);
  if (typeof cleanup === "function")
    cleanupCache.set(observerId, cleanup);
  return unwatch;
}

// node_modules/@audius/sdk/node_modules/viem/_esm/utils/wait.js
async function wait(time) {
  return new Promise((res) => setTimeout(res, time));
}

// node_modules/@audius/sdk/node_modules/viem/_esm/utils/poll.js
function poll(fn, { emitOnBegin, initialWaitTime, interval }) {
  let active = true;
  const unwatch = () => active = false;
  const watch = async () => {
    let data = void 0;
    if (emitOnBegin)
      data = await fn({ unpoll: unwatch });
    const initialWait = await (initialWaitTime == null ? void 0 : initialWaitTime(data)) ?? interval;
    await wait(initialWait);
    const poll2 = async () => {
      if (!active)
        return;
      await fn({ unpoll: unwatch });
      await wait(interval);
      poll2();
    };
    poll2();
  };
  watch();
  return unwatch;
}

// node_modules/@audius/sdk/node_modules/viem/_esm/utils/promise/withCache.js
var promiseCache = /* @__PURE__ */ new Map();
var responseCache = /* @__PURE__ */ new Map();
function getCache(cacheKey2) {
  const buildCache = (cacheKey3, cache2) => ({
    clear: () => cache2.delete(cacheKey3),
    get: () => cache2.get(cacheKey3),
    set: (data) => cache2.set(cacheKey3, data)
  });
  const promise = buildCache(cacheKey2, promiseCache);
  const response = buildCache(cacheKey2, responseCache);
  return {
    clear: () => {
      promise.clear();
      response.clear();
    },
    promise,
    response
  };
}
async function withCache(fn, { cacheKey: cacheKey2, cacheTime = Number.POSITIVE_INFINITY }) {
  const cache2 = getCache(cacheKey2);
  const response = cache2.response.get();
  if (response && cacheTime > 0) {
    const age = (/* @__PURE__ */ new Date()).getTime() - response.created.getTime();
    if (age < cacheTime)
      return response.data;
  }
  let promise = cache2.promise.get();
  if (!promise) {
    promise = fn();
    cache2.promise.set(promise);
  }
  try {
    const data = await promise;
    cache2.response.set({ created: /* @__PURE__ */ new Date(), data });
    return data;
  } finally {
    cache2.promise.clear();
  }
}

// node_modules/@audius/sdk/node_modules/viem/_esm/actions/public/getBlockNumber.js
var cacheKey = (id) => `blockNumber.${id}`;
async function getBlockNumber(client, { cacheTime = client.cacheTime } = {}) {
  const blockNumberHex = await withCache(() => client.request({
    method: "eth_blockNumber"
  }), { cacheKey: cacheKey(client.uid), cacheTime });
  return BigInt(blockNumberHex);
}

// node_modules/@audius/sdk/node_modules/viem/_esm/actions/public/getFilterChanges.js
async function getFilterChanges(_client, { filter }) {
  const strict = "strict" in filter && filter.strict;
  const logs = await filter.request({
    method: "eth_getFilterChanges",
    params: [filter.id]
  });
  if (typeof logs[0] === "string")
    return logs;
  const formattedLogs = logs.map((log) => formatLog(log));
  if (!("abi" in filter) || !filter.abi)
    return formattedLogs;
  return parseEventLogs({
    abi: filter.abi,
    logs: formattedLogs,
    strict
  });
}

// node_modules/@audius/sdk/node_modules/viem/_esm/actions/public/uninstallFilter.js
async function uninstallFilter(_client, { filter }) {
  return filter.request({
    method: "eth_uninstallFilter",
    params: [filter.id]
  });
}

// node_modules/@audius/sdk/node_modules/viem/_esm/actions/public/watchContractEvent.js
function watchContractEvent(client, parameters) {
  const { abi: abi14, address, args, batch = true, eventName, fromBlock, onError, onLogs, poll: poll_, pollingInterval = client.pollingInterval, strict: strict_ } = parameters;
  const enablePolling = (() => {
    if (typeof poll_ !== "undefined")
      return poll_;
    if (typeof fromBlock === "bigint")
      return true;
    if (client.transport.type === "webSocket")
      return false;
    if (client.transport.type === "fallback" && client.transport.transports[0].config.type === "webSocket")
      return false;
    return true;
  })();
  const pollContractEvent = () => {
    const strict = strict_ ?? false;
    const observerId = stringify([
      "watchContractEvent",
      address,
      args,
      batch,
      client.uid,
      eventName,
      pollingInterval,
      strict,
      fromBlock
    ]);
    return observe(observerId, { onLogs, onError }, (emit) => {
      let previousBlockNumber;
      if (fromBlock !== void 0)
        previousBlockNumber = fromBlock - 1n;
      let filter;
      let initialized = false;
      const unwatch = poll(async () => {
        var _a2;
        if (!initialized) {
          try {
            filter = await getAction(client, createContractEventFilter, "createContractEventFilter")({
              abi: abi14,
              address,
              args,
              eventName,
              strict,
              fromBlock
            });
          } catch {
          }
          initialized = true;
          return;
        }
        try {
          let logs;
          if (filter) {
            logs = await getAction(client, getFilterChanges, "getFilterChanges")({ filter });
          } else {
            const blockNumber = await getAction(client, getBlockNumber, "getBlockNumber")({});
            if (previousBlockNumber && previousBlockNumber < blockNumber) {
              logs = await getAction(client, getContractEvents, "getContractEvents")({
                abi: abi14,
                address,
                args,
                eventName,
                fromBlock: previousBlockNumber + 1n,
                toBlock: blockNumber,
                strict
              });
            } else {
              logs = [];
            }
            previousBlockNumber = blockNumber;
          }
          if (logs.length === 0)
            return;
          if (batch)
            emit.onLogs(logs);
          else
            for (const log of logs)
              emit.onLogs([log]);
        } catch (err2) {
          if (filter && err2 instanceof InvalidInputRpcError)
            initialized = false;
          (_a2 = emit.onError) == null ? void 0 : _a2.call(emit, err2);
        }
      }, {
        emitOnBegin: true,
        interval: pollingInterval
      });
      return async () => {
        if (filter)
          await getAction(client, uninstallFilter, "uninstallFilter")({ filter });
        unwatch();
      };
    });
  };
  const subscribeContractEvent = () => {
    const strict = strict_ ?? false;
    const observerId = stringify([
      "watchContractEvent",
      address,
      args,
      batch,
      client.uid,
      eventName,
      pollingInterval,
      strict
    ]);
    let active = true;
    let unsubscribe = () => active = false;
    return observe(observerId, { onLogs, onError }, (emit) => {
      ;
      (async () => {
        try {
          const transport = (() => {
            if (client.transport.type === "fallback") {
              const transport2 = client.transport.transports.find((transport3) => transport3.config.type === "webSocket");
              if (!transport2)
                return client.transport;
              return transport2.value;
            }
            return client.transport;
          })();
          const topics = eventName ? encodeEventTopics({
            abi: abi14,
            eventName,
            args
          }) : [];
          const { unsubscribe: unsubscribe_ } = await transport.subscribe({
            params: ["logs", { address, topics }],
            onData(data) {
              var _a2;
              if (!active)
                return;
              const log = data.result;
              try {
                const { eventName: eventName2, args: args2 } = decodeEventLog({
                  abi: abi14,
                  data: log.data,
                  topics: log.topics,
                  strict: strict_
                });
                const formatted = formatLog(log, {
                  args: args2,
                  eventName: eventName2
                });
                emit.onLogs([formatted]);
              } catch (err2) {
                let eventName2;
                let isUnnamed;
                if (err2 instanceof DecodeLogDataMismatch || err2 instanceof DecodeLogTopicsMismatch) {
                  if (strict_)
                    return;
                  eventName2 = err2.abiItem.name;
                  isUnnamed = (_a2 = err2.abiItem.inputs) == null ? void 0 : _a2.some((x) => !("name" in x && x.name));
                }
                const formatted = formatLog(log, {
                  args: isUnnamed ? [] : {},
                  eventName: eventName2
                });
                emit.onLogs([formatted]);
              }
            },
            onError(error) {
              var _a2;
              (_a2 = emit.onError) == null ? void 0 : _a2.call(emit, error);
            }
          });
          unsubscribe = unsubscribe_;
          if (!active)
            unsubscribe();
        } catch (err2) {
          onError == null ? void 0 : onError(err2);
        }
      })();
      return () => unsubscribe();
    });
  };
  return enablePolling ? pollContractEvent() : subscribeContractEvent();
}

// node_modules/@audius/sdk/node_modules/viem/_esm/errors/account.js
var AccountNotFoundError = class extends BaseError {
  constructor({ docsPath: docsPath3 } = {}) {
    super([
      "Could not find an Account to execute with this Action.",
      "Please provide an Account with the `account` argument on the Action, or by supplying an `account` to the Client."
    ].join("\n"), {
      docsPath: docsPath3,
      docsSlug: "account",
      name: "AccountNotFoundError"
    });
  }
};
var AccountTypeNotSupportedError = class extends BaseError {
  constructor({ docsPath: docsPath3, metaMessages, type: type3 }) {
    super(`Account type "${type3}" is not supported.`, {
      docsPath: docsPath3,
      metaMessages,
      name: "AccountTypeNotSupportedError"
    });
  }
};

// node_modules/@audius/sdk/node_modules/viem/_esm/utils/chain/assertCurrentChain.js
function assertCurrentChain({ chain: chain2, currentChainId }) {
  if (!chain2)
    throw new ChainNotFoundError();
  if (currentChainId !== chain2.id)
    throw new ChainMismatchError({ chain: chain2, currentChainId });
}

// node_modules/@audius/sdk/node_modules/viem/_esm/utils/errors/getTransactionError.js
function getTransactionError(err2, { docsPath: docsPath3, ...args }) {
  const cause = (() => {
    const cause2 = getNodeError(err2, args);
    if (cause2 instanceof UnknownNodeError)
      return err2;
    return cause2;
  })();
  return new TransactionExecutionError(cause, {
    docsPath: docsPath3,
    ...args
  });
}

// node_modules/@audius/sdk/node_modules/viem/_esm/actions/wallet/sendRawTransaction.js
async function sendRawTransaction(client, { serializedTransaction }) {
  return client.request({
    method: "eth_sendRawTransaction",
    params: [serializedTransaction]
  }, { retryCount: 0 });
}

// node_modules/@audius/sdk/node_modules/viem/_esm/actions/wallet/sendTransaction.js
async function sendTransaction(client, parameters) {
  var _a2, _b, _c, _d;
  const { account: account_ = client.account, chain: chain2 = client.chain, accessList, authorizationList, blobs, data, gas, gasPrice, maxFeePerBlobGas, maxFeePerGas, maxPriorityFeePerGas, nonce, value, ...rest } = parameters;
  if (!account_)
    throw new AccountNotFoundError({
      docsPath: "/docs/actions/wallet/sendTransaction"
    });
  const account = parseAccount(account_);
  try {
    assertRequest(parameters);
    const to = await (async () => {
      if (parameters.to)
        return parameters.to;
      if (authorizationList && authorizationList.length > 0)
        return await recoverAuthorizationAddress({
          authorization: authorizationList[0]
        }).catch(() => {
          throw new BaseError("`to` is required. Could not infer from `authorizationList`.");
        });
      return void 0;
    })();
    if (account.type === "json-rpc") {
      let chainId;
      if (chain2 !== null) {
        chainId = await getAction(client, getChainId, "getChainId")({});
        assertCurrentChain({
          currentChainId: chainId,
          chain: chain2
        });
      }
      const chainFormat = (_c = (_b = (_a2 = client.chain) == null ? void 0 : _a2.formatters) == null ? void 0 : _b.transactionRequest) == null ? void 0 : _c.format;
      const format2 = chainFormat || formatTransactionRequest;
      const request = format2({
        // Pick out extra data that might exist on the chain's transaction request type.
        ...extract(rest, { format: chainFormat }),
        accessList,
        authorizationList,
        blobs,
        chainId,
        data,
        from: account.address,
        gas,
        gasPrice,
        maxFeePerBlobGas,
        maxFeePerGas,
        maxPriorityFeePerGas,
        nonce,
        to,
        value
      });
      return await client.request({
        method: "eth_sendTransaction",
        params: [request]
      }, { retryCount: 0 });
    }
    if (account.type === "local") {
      const request = await getAction(client, prepareTransactionRequest, "prepareTransactionRequest")({
        account,
        accessList,
        authorizationList,
        blobs,
        chain: chain2,
        data,
        gas,
        gasPrice,
        maxFeePerBlobGas,
        maxFeePerGas,
        maxPriorityFeePerGas,
        nonce,
        nonceManager: account.nonceManager,
        parameters: [...defaultParameters, "sidecars"],
        value,
        ...rest,
        to
      });
      const serializer = (_d = chain2 == null ? void 0 : chain2.serializers) == null ? void 0 : _d.transaction;
      const serializedTransaction = await account.signTransaction(request, {
        serializer
      });
      return await getAction(client, sendRawTransaction, "sendRawTransaction")({
        serializedTransaction
      });
    }
    if (account.type === "smart")
      throw new AccountTypeNotSupportedError({
        metaMessages: [
          "Consider using the `sendUserOperation` Action instead."
        ],
        docsPath: "/docs/actions/bundler/sendUserOperation",
        type: "smart"
      });
    throw new AccountTypeNotSupportedError({
      docsPath: "/docs/actions/wallet/sendTransaction",
      type: account.type
    });
  } catch (err2) {
    if (err2 instanceof AccountTypeNotSupportedError)
      throw err2;
    throw getTransactionError(err2, {
      ...parameters,
      account,
      chain: parameters.chain || void 0
    });
  }
}

// node_modules/@audius/sdk/node_modules/viem/_esm/actions/wallet/writeContract.js
async function writeContract(client, parameters) {
  const { abi: abi14, account: account_ = client.account, address, args, dataSuffix, functionName, ...request } = parameters;
  if (!account_)
    throw new AccountNotFoundError({
      docsPath: "/docs/contract/writeContract"
    });
  const account = parseAccount(account_);
  const data = encodeFunctionData({
    abi: abi14,
    args,
    functionName
  });
  try {
    return await getAction(client, sendTransaction, "sendTransaction")({
      data: `${data}${dataSuffix ? dataSuffix.replace("0x", "") : ""}`,
      to: address,
      account,
      ...request
    });
  } catch (error) {
    throw getContractError(error, {
      abi: abi14,
      address,
      args,
      docsPath: "/docs/contract/writeContract",
      functionName,
      sender: account.address
    });
  }
}

// node_modules/@audius/sdk/node_modules/viem/_esm/errors/eip712.js
var Eip712DomainNotFoundError = class extends BaseError {
  constructor({ address }) {
    super(`No EIP-712 domain found on contract "${address}".`, {
      metaMessages: [
        "Ensure that:",
        `- The contract is deployed at the address "${address}".`,
        "- `eip712Domain()` function exists on the contract.",
        "- `eip712Domain()` function matches signature to ERC-5267 specification."
      ],
      name: "Eip712DomainNotFoundError"
    });
  }
};

// node_modules/@audius/sdk/node_modules/viem/_esm/actions/public/getEip712Domain.js
async function getEip712Domain(client, parameters) {
  const { address, factory: factory2, factoryData } = parameters;
  try {
    const [fields, name, version3, chainId, verifyingContract, salt, extensions] = await getAction(client, readContract, "readContract")({
      abi,
      address,
      functionName: "eip712Domain",
      factory: factory2,
      factoryData
    });
    return {
      domain: {
        name,
        version: version3,
        chainId: Number(chainId),
        verifyingContract,
        salt
      },
      extensions,
      fields
    };
  } catch (e) {
    const error = e;
    if (error.name === "ContractFunctionExecutionError" && error.cause.name === "ContractFunctionZeroDataError") {
      throw new Eip712DomainNotFoundError({ address });
    }
    throw error;
  }
}
var abi = [
  {
    inputs: [],
    name: "eip712Domain",
    outputs: [
      { name: "fields", type: "bytes1" },
      { name: "name", type: "string" },
      { name: "version", type: "string" },
      { name: "chainId", type: "uint256" },
      { name: "verifyingContract", type: "address" },
      { name: "salt", type: "bytes32" },
      { name: "extensions", type: "uint256[]" }
    ],
    stateMutability: "view",
    type: "function"
  }
];

// node_modules/@audius/sdk/node_modules/viem/_esm/actions/wallet/addChain.js
async function addChain(client, { chain: chain2 }) {
  const { id, name, nativeCurrency, rpcUrls, blockExplorers } = chain2;
  await client.request({
    method: "wallet_addEthereumChain",
    params: [
      {
        chainId: numberToHex(id),
        chainName: name,
        nativeCurrency,
        rpcUrls: rpcUrls.default.http,
        blockExplorerUrls: blockExplorers ? Object.values(blockExplorers).map(({ url }) => url) : void 0
      }
    ]
  }, { dedupe: true, retryCount: 0 });
}

// node_modules/@audius/sdk/node_modules/viem/_esm/utils/uid.js
var size2 = 256;
var index = size2;
var buffer;
function uid(length2 = 11) {
  if (!buffer || index + length2 > size2 * 2) {
    buffer = "";
    index = 0;
    for (let i = 0; i < size2; i++) {
      buffer += (256 + Math.random() * 256 | 0).toString(16).substring(1);
    }
  }
  return buffer.substring(index, index++ + length2);
}

// node_modules/@audius/sdk/node_modules/viem/_esm/clients/createClient.js
function createClient(parameters) {
  const { batch, cacheTime = parameters.pollingInterval ?? 4e3, ccipRead, key = "base", name = "Base Client", pollingInterval = 4e3, type: type3 = "base" } = parameters;
  const chain2 = parameters.chain;
  const account = parameters.account ? parseAccount(parameters.account) : void 0;
  const { config, request, value } = parameters.transport({
    chain: chain2,
    pollingInterval
  });
  const transport = { ...config, ...value };
  const client = {
    account,
    batch,
    cacheTime,
    ccipRead,
    chain: chain2,
    key,
    name,
    pollingInterval,
    request,
    transport,
    type: type3,
    uid: uid()
  };
  function extend(base3) {
    return (extendFn) => {
      const extended = extendFn(base3);
      for (const key2 in client)
        delete extended[key2];
      const combined = { ...base3, ...extended };
      return Object.assign(combined, { extend: extend(combined) });
    };
  }
  return Object.assign(client, { extend: extend(client) });
}

// node_modules/@audius/sdk/node_modules/viem/_esm/utils/promise/withDedupe.js
var promiseCache2 = new LruMap(8192);
function withDedupe(fn, { enabled = true, id }) {
  if (!enabled || !id)
    return fn();
  if (promiseCache2.get(id))
    return promiseCache2.get(id);
  const promise = fn().finally(() => promiseCache2.delete(id));
  promiseCache2.set(id, promise);
  return promise;
}

// node_modules/@audius/sdk/node_modules/viem/_esm/utils/promise/withRetry.js
function withRetry(fn, { delay: delay_ = 100, retryCount = 2, shouldRetry: shouldRetry2 = () => true } = {}) {
  return new Promise((resolve2, reject2) => {
    const attemptRetry = async ({ count = 0 } = {}) => {
      const retry2 = async ({ error }) => {
        const delay = typeof delay_ === "function" ? delay_({ count, error }) : delay_;
        if (delay)
          await wait(delay);
        attemptRetry({ count: count + 1 });
      };
      try {
        const data = await fn();
        resolve2(data);
      } catch (err2) {
        if (count < retryCount && await shouldRetry2({ count, error: err2 }))
          return retry2({ error: err2 });
        reject2(err2);
      }
    };
    attemptRetry();
  });
}

// node_modules/@audius/sdk/node_modules/viem/_esm/utils/buildRequest.js
function buildRequest(request, options = {}) {
  return async (args, overrideOptions = {}) => {
    const { dedupe = false, retryDelay = 150, retryCount = 3, uid: uid2 } = {
      ...options,
      ...overrideOptions
    };
    const requestId = dedupe ? keccak256(stringToHex(`${uid2}.${stringify(args)}`)) : void 0;
    return withDedupe(() => withRetry(async () => {
      try {
        return await request(args);
      } catch (err_) {
        const err2 = err_;
        switch (err2.code) {
          // -32700
          case ParseRpcError.code:
            throw new ParseRpcError(err2);
          // -32600
          case InvalidRequestRpcError.code:
            throw new InvalidRequestRpcError(err2);
          // -32601
          case MethodNotFoundRpcError.code:
            throw new MethodNotFoundRpcError(err2, { method: args.method });
          // -32602
          case InvalidParamsRpcError.code:
            throw new InvalidParamsRpcError(err2);
          // -32603
          case InternalRpcError.code:
            throw new InternalRpcError(err2);
          // -32000
          case InvalidInputRpcError.code:
            throw new InvalidInputRpcError(err2);
          // -32001
          case ResourceNotFoundRpcError.code:
            throw new ResourceNotFoundRpcError(err2);
          // -32002
          case ResourceUnavailableRpcError.code:
            throw new ResourceUnavailableRpcError(err2);
          // -32003
          case TransactionRejectedRpcError.code:
            throw new TransactionRejectedRpcError(err2);
          // -32004
          case MethodNotSupportedRpcError.code:
            throw new MethodNotSupportedRpcError(err2, {
              method: args.method
            });
          // -32005
          case LimitExceededRpcError.code:
            throw new LimitExceededRpcError(err2);
          // -32006
          case JsonRpcVersionUnsupportedError.code:
            throw new JsonRpcVersionUnsupportedError(err2);
          // 4001
          case UserRejectedRequestError.code:
            throw new UserRejectedRequestError(err2);
          // 4100
          case UnauthorizedProviderError.code:
            throw new UnauthorizedProviderError(err2);
          // 4200
          case UnsupportedProviderMethodError.code:
            throw new UnsupportedProviderMethodError(err2);
          // 4900
          case ProviderDisconnectedError.code:
            throw new ProviderDisconnectedError(err2);
          // 4901
          case ChainDisconnectedError.code:
            throw new ChainDisconnectedError(err2);
          // 4902
          case SwitchChainError.code:
            throw new SwitchChainError(err2);
          // CAIP-25: User Rejected Error
          // https://docs.walletconnect.com/2.0/specs/clients/sign/error-codes#rejected-caip-25
          case 5e3:
            throw new UserRejectedRequestError(err2);
          default:
            if (err_ instanceof BaseError)
              throw err_;
            throw new UnknownRpcError(err2);
        }
      }
    }, {
      delay: ({ count, error }) => {
        var _a2;
        if (error && error instanceof HttpRequestError) {
          const retryAfter = (_a2 = error == null ? void 0 : error.headers) == null ? void 0 : _a2.get("Retry-After");
          if (retryAfter == null ? void 0 : retryAfter.match(/\d/))
            return Number.parseInt(retryAfter) * 1e3;
        }
        return ~~(1 << count) * retryDelay;
      },
      retryCount,
      shouldRetry: ({ error }) => shouldRetry(error)
    }), { enabled: dedupe, id: requestId });
  };
}
function shouldRetry(error) {
  if ("code" in error && typeof error.code === "number") {
    if (error.code === -1)
      return true;
    if (error.code === LimitExceededRpcError.code)
      return true;
    if (error.code === InternalRpcError.code)
      return true;
    return false;
  }
  if (error instanceof HttpRequestError && error.status) {
    if (error.status === 403)
      return true;
    if (error.status === 408)
      return true;
    if (error.status === 413)
      return true;
    if (error.status === 429)
      return true;
    if (error.status === 500)
      return true;
    if (error.status === 502)
      return true;
    if (error.status === 503)
      return true;
    if (error.status === 504)
      return true;
    return false;
  }
  return true;
}

// node_modules/@audius/sdk/node_modules/viem/_esm/clients/transports/createTransport.js
function createTransport({ key, name, request, retryCount = 3, retryDelay = 150, timeout, type: type3 }, value) {
  const uid2 = uid();
  return {
    config: {
      key,
      name,
      request,
      retryCount,
      retryDelay,
      timeout,
      type: type3
    },
    request: buildRequest(request, { retryCount, retryDelay, uid: uid2 }),
    value
  };
}

// node_modules/@audius/sdk/node_modules/viem/_esm/clients/transports/custom.js
function custom(provider, config = {}) {
  const { key = "custom", name = "Custom Provider", retryDelay } = config;
  return ({ retryCount: defaultRetryCount }) => createTransport({
    key,
    name,
    request: provider.request.bind(provider),
    retryCount: config.retryCount ?? defaultRetryCount,
    retryDelay,
    type: "custom"
  });
}

// node_modules/@audius/sdk/node_modules/viem/_esm/errors/transport.js
var UrlRequiredError = class extends BaseError {
  constructor() {
    super("No URL was provided to the Transport. Please provide a valid RPC URL to the Transport.", {
      docsPath: "/docs/clients/intro",
      name: "UrlRequiredError"
    });
  }
};

// node_modules/@audius/sdk/node_modules/viem/_esm/utils/promise/withTimeout.js
function withTimeout(fn, { errorInstance = new Error("timed out"), timeout, signal }) {
  return new Promise((resolve2, reject2) => {
    ;
    (async () => {
      let timeoutId;
      try {
        const controller = new AbortController();
        if (timeout > 0) {
          timeoutId = setTimeout(() => {
            if (signal) {
              controller.abort();
            } else {
              reject2(errorInstance);
            }
          }, timeout);
        }
        resolve2(await fn({ signal: (controller == null ? void 0 : controller.signal) || null }));
      } catch (err2) {
        if ((err2 == null ? void 0 : err2.name) === "AbortError")
          reject2(errorInstance);
        reject2(err2);
      } finally {
        clearTimeout(timeoutId);
      }
    })();
  });
}

// node_modules/@audius/sdk/node_modules/viem/_esm/utils/rpc/id.js
function createIdStore() {
  return {
    current: 0,
    take() {
      return this.current++;
    },
    reset() {
      this.current = 0;
    }
  };
}
var idCache = createIdStore();

// node_modules/@audius/sdk/node_modules/viem/_esm/utils/rpc/http.js
function getHttpRpcClient(url, options = {}) {
  return {
    async request(params) {
      var _a2;
      const { body, onRequest = options.onRequest, onResponse = options.onResponse, timeout = options.timeout ?? 1e4 } = params;
      const fetchOptions = {
        ...options.fetchOptions ?? {},
        ...params.fetchOptions ?? {}
      };
      const { headers, method, signal: signal_ } = fetchOptions;
      try {
        const response = await withTimeout(async ({ signal }) => {
          const init = {
            ...fetchOptions,
            body: Array.isArray(body) ? stringify(body.map((body2) => ({
              jsonrpc: "2.0",
              id: body2.id ?? idCache.take(),
              ...body2
            }))) : stringify({
              jsonrpc: "2.0",
              id: body.id ?? idCache.take(),
              ...body
            }),
            headers: {
              "Content-Type": "application/json",
              ...headers
            },
            method: method || "POST",
            signal: signal_ || (timeout > 0 ? signal : null)
          };
          const request = new Request(url, init);
          if (onRequest)
            await onRequest(request);
          const response2 = await fetch(url, init);
          return response2;
        }, {
          errorInstance: new TimeoutError({ body, url }),
          timeout,
          signal: true
        });
        if (onResponse)
          await onResponse(response);
        let data;
        if ((_a2 = response.headers.get("Content-Type")) == null ? void 0 : _a2.startsWith("application/json"))
          data = await response.json();
        else {
          data = await response.text();
          try {
            data = JSON.parse(data || "{}");
          } catch (err2) {
            if (response.ok)
              throw err2;
            data = { error: data };
          }
        }
        if (!response.ok) {
          throw new HttpRequestError({
            body,
            details: stringify(data.error) || response.statusText,
            headers: response.headers,
            status: response.status,
            url
          });
        }
        return data;
      } catch (err2) {
        if (err2 instanceof HttpRequestError)
          throw err2;
        if (err2 instanceof TimeoutError)
          throw err2;
        throw new HttpRequestError({
          body,
          cause: err2,
          url
        });
      }
    }
  };
}

// node_modules/@audius/sdk/node_modules/viem/_esm/clients/transports/http.js
function http(url, config = {}) {
  const { batch, fetchOptions, key = "http", name = "HTTP JSON-RPC", onFetchRequest, onFetchResponse, retryDelay } = config;
  return ({ chain: chain2, retryCount: retryCount_, timeout: timeout_ }) => {
    const { batchSize = 1e3, wait: wait3 = 0 } = typeof batch === "object" ? batch : {};
    const retryCount = config.retryCount ?? retryCount_;
    const timeout = timeout_ ?? config.timeout ?? 1e4;
    const url_ = url || (chain2 == null ? void 0 : chain2.rpcUrls.default.http[0]);
    if (!url_)
      throw new UrlRequiredError();
    const rpcClient = getHttpRpcClient(url_, {
      fetchOptions,
      onRequest: onFetchRequest,
      onResponse: onFetchResponse,
      timeout
    });
    return createTransport({
      key,
      name,
      async request({ method, params }) {
        const body = { method, params };
        const { schedule } = createBatchScheduler({
          id: url_,
          wait: wait3,
          shouldSplitBatch(requests) {
            return requests.length > batchSize;
          },
          fn: (body2) => rpcClient.request({
            body: body2
          }),
          sort: (a, b) => a.id - b.id
        });
        const fn = async (body2) => batch ? schedule(body2) : [
          await rpcClient.request({
            body: body2
          })
        ];
        const [{ error, result }] = await fn(body);
        if (error)
          throw new RpcRequestError({
            body,
            error,
            url: url_
          });
        return result;
      },
      retryCount,
      retryDelay,
      timeout,
      type: "http"
    }, {
      fetchOptions,
      url: url_
    });
  };
}

// node_modules/@audius/sdk/node_modules/viem/_esm/utils/ens/errors.js
function isNullUniversalResolverError(err2, callType) {
  var _a2, _b, _c, _d, _e, _f;
  if (!(err2 instanceof BaseError))
    return false;
  const cause = err2.walk((e) => e instanceof ContractFunctionRevertedError);
  if (!(cause instanceof ContractFunctionRevertedError))
    return false;
  if (((_a2 = cause.data) == null ? void 0 : _a2.errorName) === "ResolverNotFound")
    return true;
  if (((_b = cause.data) == null ? void 0 : _b.errorName) === "ResolverWildcardNotSupported")
    return true;
  if (((_c = cause.data) == null ? void 0 : _c.errorName) === "ResolverNotContract")
    return true;
  if (((_d = cause.data) == null ? void 0 : _d.errorName) === "ResolverError")
    return true;
  if (((_e = cause.data) == null ? void 0 : _e.errorName) === "HttpError")
    return true;
  if ((_f = cause.reason) == null ? void 0 : _f.includes("Wildcard on non-extended resolvers is not supported"))
    return true;
  if (callType === "reverse" && cause.reason === panicReasons[50])
    return true;
  return false;
}

// node_modules/@audius/sdk/node_modules/viem/_esm/utils/ens/encodedLabelToLabelhash.js
function encodedLabelToLabelhash(label) {
  if (label.length !== 66)
    return null;
  if (label.indexOf("[") !== 0)
    return null;
  if (label.indexOf("]") !== 65)
    return null;
  const hash3 = `0x${label.slice(1, 65)}`;
  if (!isHex(hash3))
    return null;
  return hash3;
}

// node_modules/@audius/sdk/node_modules/viem/_esm/utils/ens/namehash.js
function namehash(name) {
  let result = new Uint8Array(32).fill(0);
  if (!name)
    return bytesToHex(result);
  const labels = name.split(".");
  for (let i = labels.length - 1; i >= 0; i -= 1) {
    const hashFromEncodedLabel = encodedLabelToLabelhash(labels[i]);
    const hashed = hashFromEncodedLabel ? toBytes(hashFromEncodedLabel) : keccak256(stringToBytes2(labels[i]), "bytes");
    result = keccak256(concat([result, hashed]), "bytes");
  }
  return bytesToHex(result);
}

// node_modules/@audius/sdk/node_modules/viem/_esm/utils/ens/encodeLabelhash.js
function encodeLabelhash(hash3) {
  return `[${hash3.slice(2)}]`;
}

// node_modules/@audius/sdk/node_modules/viem/_esm/utils/ens/labelhash.js
function labelhash(label) {
  const result = new Uint8Array(32).fill(0);
  if (!label)
    return bytesToHex(result);
  return encodedLabelToLabelhash(label) || keccak256(stringToBytes2(label));
}

// node_modules/@audius/sdk/node_modules/viem/_esm/utils/ens/packetToBytes.js
function packetToBytes(packet) {
  const value = packet.replace(/^\.|\.$/gm, "");
  if (value.length === 0)
    return new Uint8Array(1);
  const bytes3 = new Uint8Array(stringToBytes2(value).byteLength + 2);
  let offset3 = 0;
  const list = value.split(".");
  for (let i = 0; i < list.length; i++) {
    let encoded = stringToBytes2(list[i]);
    if (encoded.byteLength > 255)
      encoded = stringToBytes2(encodeLabelhash(labelhash(list[i])));
    bytes3[offset3] = encoded.length;
    bytes3.set(encoded, offset3 + 1);
    offset3 += encoded.length + 1;
  }
  if (bytes3.byteLength !== offset3 + 1)
    return bytes3.slice(0, offset3 + 1);
  return bytes3;
}

// node_modules/@audius/sdk/node_modules/viem/_esm/actions/ens/getEnsAddress.js
async function getEnsAddress(client, { blockNumber, blockTag, coinType, name, gatewayUrls, strict, universalResolverAddress: universalResolverAddress_ }) {
  let universalResolverAddress = universalResolverAddress_;
  if (!universalResolverAddress) {
    if (!client.chain)
      throw new Error("client chain not configured. universalResolverAddress is required.");
    universalResolverAddress = getChainContractAddress({
      blockNumber,
      chain: client.chain,
      contract: "ensUniversalResolver"
    });
  }
  try {
    const functionData = encodeFunctionData({
      abi: addressResolverAbi,
      functionName: "addr",
      ...coinType != null ? { args: [namehash(name), BigInt(coinType)] } : { args: [namehash(name)] }
    });
    const readContractParameters = {
      address: universalResolverAddress,
      abi: universalResolverResolveAbi,
      functionName: "resolve",
      args: [toHex(packetToBytes(name)), functionData],
      blockNumber,
      blockTag
    };
    const readContractAction = getAction(client, readContract, "readContract");
    const res = gatewayUrls ? await readContractAction({
      ...readContractParameters,
      args: [...readContractParameters.args, gatewayUrls]
    }) : await readContractAction(readContractParameters);
    if (res[0] === "0x")
      return null;
    const address = decodeFunctionResult({
      abi: addressResolverAbi,
      args: coinType != null ? [namehash(name), BigInt(coinType)] : void 0,
      functionName: "addr",
      data: res[0]
    });
    if (address === "0x")
      return null;
    if (trim(address) === "0x00")
      return null;
    return address;
  } catch (err2) {
    if (strict)
      throw err2;
    if (isNullUniversalResolverError(err2, "resolve"))
      return null;
    throw err2;
  }
}

// node_modules/@audius/sdk/node_modules/viem/_esm/errors/ens.js
var EnsAvatarInvalidMetadataError = class extends BaseError {
  constructor({ data }) {
    super("Unable to extract image from metadata. The metadata may be malformed or invalid.", {
      metaMessages: [
        "- Metadata must be a JSON object with at least an `image`, `image_url` or `image_data` property.",
        "",
        `Provided data: ${JSON.stringify(data)}`
      ],
      name: "EnsAvatarInvalidMetadataError"
    });
  }
};
var EnsAvatarInvalidNftUriError = class extends BaseError {
  constructor({ reason }) {
    super(`ENS NFT avatar URI is invalid. ${reason}`, {
      name: "EnsAvatarInvalidNftUriError"
    });
  }
};
var EnsAvatarUriResolutionError = class extends BaseError {
  constructor({ uri }) {
    super(`Unable to resolve ENS avatar URI "${uri}". The URI may be malformed, invalid, or does not respond with a valid image.`, { name: "EnsAvatarUriResolutionError" });
  }
};
var EnsAvatarUnsupportedNamespaceError = class extends BaseError {
  constructor({ namespace }) {
    super(`ENS NFT avatar namespace "${namespace}" is not supported. Must be "erc721" or "erc1155".`, { name: "EnsAvatarUnsupportedNamespaceError" });
  }
};

// node_modules/@audius/sdk/node_modules/viem/_esm/utils/ens/avatar/utils.js
var networkRegex = /(?<protocol>https?:\/\/[^\/]*|ipfs:\/|ipns:\/|ar:\/)?(?<root>\/)?(?<subpath>ipfs\/|ipns\/)?(?<target>[\w\-.]+)(?<subtarget>\/.*)?/;
var ipfsHashRegex = /^(Qm[1-9A-HJ-NP-Za-km-z]{44,}|b[A-Za-z2-7]{58,}|B[A-Z2-7]{58,}|z[1-9A-HJ-NP-Za-km-z]{48,}|F[0-9A-F]{50,})(\/(?<target>[\w\-.]+))?(?<subtarget>\/.*)?$/;
var base64Regex = /^data:([a-zA-Z\-/+]*);base64,([^"].*)/;
var dataURIRegex = /^data:([a-zA-Z\-/+]*)?(;[a-zA-Z0-9].*?)?(,)/;
async function isImageUri(uri) {
  try {
    const res = await fetch(uri, { method: "HEAD" });
    if (res.status === 200) {
      const contentType = res.headers.get("content-type");
      return contentType == null ? void 0 : contentType.startsWith("image/");
    }
    return false;
  } catch (error) {
    if (typeof error === "object" && typeof error.response !== "undefined") {
      return false;
    }
    if (!globalThis.hasOwnProperty("Image"))
      return false;
    return new Promise((resolve2) => {
      const img = new Image();
      img.onload = () => {
        resolve2(true);
      };
      img.onerror = () => {
        resolve2(false);
      };
      img.src = uri;
    });
  }
}
function getGateway(custom2, defaultGateway) {
  if (!custom2)
    return defaultGateway;
  if (custom2.endsWith("/"))
    return custom2.slice(0, -1);
  return custom2;
}
function resolveAvatarUri({ uri, gatewayUrls }) {
  const isEncoded = base64Regex.test(uri);
  if (isEncoded)
    return { uri, isOnChain: true, isEncoded };
  const ipfsGateway = getGateway(gatewayUrls == null ? void 0 : gatewayUrls.ipfs, "https://ipfs.io");
  const arweaveGateway = getGateway(gatewayUrls == null ? void 0 : gatewayUrls.arweave, "https://arweave.net");
  const networkRegexMatch = uri.match(networkRegex);
  const { protocol, subpath, target, subtarget = "" } = (networkRegexMatch == null ? void 0 : networkRegexMatch.groups) || {};
  const isIPNS = protocol === "ipns:/" || subpath === "ipns/";
  const isIPFS = protocol === "ipfs:/" || subpath === "ipfs/" || ipfsHashRegex.test(uri);
  if (uri.startsWith("http") && !isIPNS && !isIPFS) {
    let replacedUri = uri;
    if (gatewayUrls == null ? void 0 : gatewayUrls.arweave)
      replacedUri = uri.replace(/https:\/\/arweave.net/g, gatewayUrls == null ? void 0 : gatewayUrls.arweave);
    return { uri: replacedUri, isOnChain: false, isEncoded: false };
  }
  if ((isIPNS || isIPFS) && target) {
    return {
      uri: `${ipfsGateway}/${isIPNS ? "ipns" : "ipfs"}/${target}${subtarget}`,
      isOnChain: false,
      isEncoded: false
    };
  }
  if (protocol === "ar:/" && target) {
    return {
      uri: `${arweaveGateway}/${target}${subtarget || ""}`,
      isOnChain: false,
      isEncoded: false
    };
  }
  let parsedUri = uri.replace(dataURIRegex, "");
  if (parsedUri.startsWith("<svg")) {
    parsedUri = `data:image/svg+xml;base64,${btoa(parsedUri)}`;
  }
  if (parsedUri.startsWith("data:") || parsedUri.startsWith("{")) {
    return {
      uri: parsedUri,
      isOnChain: true,
      isEncoded: false
    };
  }
  throw new EnsAvatarUriResolutionError({ uri });
}
function getJsonImage(data) {
  if (typeof data !== "object" || !("image" in data) && !("image_url" in data) && !("image_data" in data)) {
    throw new EnsAvatarInvalidMetadataError({ data });
  }
  return data.image || data.image_url || data.image_data;
}
async function getMetadataAvatarUri({ gatewayUrls, uri }) {
  try {
    const res = await fetch(uri).then((res2) => res2.json());
    const image = await parseAvatarUri({
      gatewayUrls,
      uri: getJsonImage(res)
    });
    return image;
  } catch {
    throw new EnsAvatarUriResolutionError({ uri });
  }
}
async function parseAvatarUri({ gatewayUrls, uri }) {
  const { uri: resolvedURI, isOnChain } = resolveAvatarUri({ uri, gatewayUrls });
  if (isOnChain)
    return resolvedURI;
  const isImage = await isImageUri(resolvedURI);
  if (isImage)
    return resolvedURI;
  throw new EnsAvatarUriResolutionError({ uri });
}
function parseNftUri(uri_) {
  let uri = uri_;
  if (uri.startsWith("did:nft:")) {
    uri = uri.replace("did:nft:", "").replace(/_/g, "/");
  }
  const [reference, asset_namespace, tokenID] = uri.split("/");
  const [eip_namespace, chainID] = reference.split(":");
  const [erc_namespace, contractAddress] = asset_namespace.split(":");
  if (!eip_namespace || eip_namespace.toLowerCase() !== "eip155")
    throw new EnsAvatarInvalidNftUriError({ reason: "Only EIP-155 supported" });
  if (!chainID)
    throw new EnsAvatarInvalidNftUriError({ reason: "Chain ID not found" });
  if (!contractAddress)
    throw new EnsAvatarInvalidNftUriError({
      reason: "Contract address not found"
    });
  if (!tokenID)
    throw new EnsAvatarInvalidNftUriError({ reason: "Token ID not found" });
  if (!erc_namespace)
    throw new EnsAvatarInvalidNftUriError({ reason: "ERC namespace not found" });
  return {
    chainID: Number.parseInt(chainID),
    namespace: erc_namespace.toLowerCase(),
    contractAddress,
    tokenID
  };
}
async function getNftTokenUri(client, { nft }) {
  if (nft.namespace === "erc721") {
    return readContract(client, {
      address: nft.contractAddress,
      abi: [
        {
          name: "tokenURI",
          type: "function",
          stateMutability: "view",
          inputs: [{ name: "tokenId", type: "uint256" }],
          outputs: [{ name: "", type: "string" }]
        }
      ],
      functionName: "tokenURI",
      args: [BigInt(nft.tokenID)]
    });
  }
  if (nft.namespace === "erc1155") {
    return readContract(client, {
      address: nft.contractAddress,
      abi: [
        {
          name: "uri",
          type: "function",
          stateMutability: "view",
          inputs: [{ name: "_id", type: "uint256" }],
          outputs: [{ name: "", type: "string" }]
        }
      ],
      functionName: "uri",
      args: [BigInt(nft.tokenID)]
    });
  }
  throw new EnsAvatarUnsupportedNamespaceError({ namespace: nft.namespace });
}

// node_modules/@audius/sdk/node_modules/viem/_esm/utils/ens/avatar/parseAvatarRecord.js
async function parseAvatarRecord(client, { gatewayUrls, record: record2 }) {
  if (/eip155:/i.test(record2))
    return parseNftAvatarUri(client, { gatewayUrls, record: record2 });
  return parseAvatarUri({ uri: record2, gatewayUrls });
}
async function parseNftAvatarUri(client, { gatewayUrls, record: record2 }) {
  const nft = parseNftUri(record2);
  const nftUri = await getNftTokenUri(client, { nft });
  const { uri: resolvedNftUri, isOnChain, isEncoded } = resolveAvatarUri({ uri: nftUri, gatewayUrls });
  if (isOnChain && (resolvedNftUri.includes("data:application/json;base64,") || resolvedNftUri.startsWith("{"))) {
    const encodedJson = isEncoded ? (
      // if it is encoded, decode it
      atob(resolvedNftUri.replace("data:application/json;base64,", ""))
    ) : (
      // if it isn't encoded assume it is a JSON string, but it could be anything (it will error if it is)
      resolvedNftUri
    );
    const decoded = JSON.parse(encodedJson);
    return parseAvatarUri({ uri: getJsonImage(decoded), gatewayUrls });
  }
  let uriTokenId = nft.tokenID;
  if (nft.namespace === "erc1155")
    uriTokenId = uriTokenId.replace("0x", "").padStart(64, "0");
  return getMetadataAvatarUri({
    gatewayUrls,
    uri: resolvedNftUri.replace(/(?:0x)?{id}/, uriTokenId)
  });
}

// node_modules/@audius/sdk/node_modules/viem/_esm/actions/ens/getEnsText.js
async function getEnsText(client, { blockNumber, blockTag, name, key, gatewayUrls, strict, universalResolverAddress: universalResolverAddress_ }) {
  let universalResolverAddress = universalResolverAddress_;
  if (!universalResolverAddress) {
    if (!client.chain)
      throw new Error("client chain not configured. universalResolverAddress is required.");
    universalResolverAddress = getChainContractAddress({
      blockNumber,
      chain: client.chain,
      contract: "ensUniversalResolver"
    });
  }
  try {
    const readContractParameters = {
      address: universalResolverAddress,
      abi: universalResolverResolveAbi,
      functionName: "resolve",
      args: [
        toHex(packetToBytes(name)),
        encodeFunctionData({
          abi: textResolverAbi,
          functionName: "text",
          args: [namehash(name), key]
        })
      ],
      blockNumber,
      blockTag
    };
    const readContractAction = getAction(client, readContract, "readContract");
    const res = gatewayUrls ? await readContractAction({
      ...readContractParameters,
      args: [...readContractParameters.args, gatewayUrls]
    }) : await readContractAction(readContractParameters);
    if (res[0] === "0x")
      return null;
    const record2 = decodeFunctionResult({
      abi: textResolverAbi,
      functionName: "text",
      data: res[0]
    });
    return record2 === "" ? null : record2;
  } catch (err2) {
    if (strict)
      throw err2;
    if (isNullUniversalResolverError(err2, "resolve"))
      return null;
    throw err2;
  }
}

// node_modules/@audius/sdk/node_modules/viem/_esm/actions/ens/getEnsAvatar.js
async function getEnsAvatar(client, { blockNumber, blockTag, assetGatewayUrls, name, gatewayUrls, strict, universalResolverAddress }) {
  const record2 = await getAction(client, getEnsText, "getEnsText")({
    blockNumber,
    blockTag,
    key: "avatar",
    name,
    universalResolverAddress,
    gatewayUrls,
    strict
  });
  if (!record2)
    return null;
  try {
    return await parseAvatarRecord(client, {
      record: record2,
      gatewayUrls: assetGatewayUrls
    });
  } catch {
    return null;
  }
}

// node_modules/@audius/sdk/node_modules/viem/_esm/actions/ens/getEnsName.js
async function getEnsName(client, { address, blockNumber, blockTag, gatewayUrls, strict, universalResolverAddress: universalResolverAddress_ }) {
  let universalResolverAddress = universalResolverAddress_;
  if (!universalResolverAddress) {
    if (!client.chain)
      throw new Error("client chain not configured. universalResolverAddress is required.");
    universalResolverAddress = getChainContractAddress({
      blockNumber,
      chain: client.chain,
      contract: "ensUniversalResolver"
    });
  }
  const reverseNode = `${address.toLowerCase().substring(2)}.addr.reverse`;
  try {
    const readContractParameters = {
      address: universalResolverAddress,
      abi: universalResolverReverseAbi,
      functionName: "reverse",
      args: [toHex(packetToBytes(reverseNode))],
      blockNumber,
      blockTag
    };
    const readContractAction = getAction(client, readContract, "readContract");
    const [name, resolvedAddress] = gatewayUrls ? await readContractAction({
      ...readContractParameters,
      args: [...readContractParameters.args, gatewayUrls]
    }) : await readContractAction(readContractParameters);
    if (address.toLowerCase() !== resolvedAddress.toLowerCase())
      return null;
    return name;
  } catch (err2) {
    if (strict)
      throw err2;
    if (isNullUniversalResolverError(err2, "reverse"))
      return null;
    throw err2;
  }
}

// node_modules/@audius/sdk/node_modules/viem/_esm/actions/ens/getEnsResolver.js
async function getEnsResolver(client, { blockNumber, blockTag, name, universalResolverAddress: universalResolverAddress_ }) {
  let universalResolverAddress = universalResolverAddress_;
  if (!universalResolverAddress) {
    if (!client.chain)
      throw new Error("client chain not configured. universalResolverAddress is required.");
    universalResolverAddress = getChainContractAddress({
      blockNumber,
      chain: client.chain,
      contract: "ensUniversalResolver"
    });
  }
  const [resolverAddress] = await getAction(client, readContract, "readContract")({
    address: universalResolverAddress,
    abi: [
      {
        inputs: [{ type: "bytes" }],
        name: "findResolver",
        outputs: [{ type: "address" }, { type: "bytes32" }],
        stateMutability: "view",
        type: "function"
      }
    ],
    functionName: "findResolver",
    args: [toHex(packetToBytes(name))],
    blockNumber,
    blockTag
  });
  return resolverAddress;
}

// node_modules/@audius/sdk/node_modules/viem/_esm/actions/public/createBlockFilter.js
async function createBlockFilter(client) {
  const getRequest = createFilterRequestScope(client, {
    method: "eth_newBlockFilter"
  });
  const id = await client.request({
    method: "eth_newBlockFilter"
  });
  return { id, request: getRequest(id), type: "block" };
}

// node_modules/@audius/sdk/node_modules/viem/_esm/actions/public/createEventFilter.js
async function createEventFilter(client, { address, args, event, events: events_, fromBlock, strict, toBlock } = {}) {
  const events2 = events_ ?? (event ? [event] : void 0);
  const getRequest = createFilterRequestScope(client, {
    method: "eth_newFilter"
  });
  let topics = [];
  if (events2) {
    const encoded = events2.flatMap((event2) => encodeEventTopics({
      abi: [event2],
      eventName: event2.name,
      args
    }));
    topics = [encoded];
    if (event)
      topics = topics[0];
  }
  const id = await client.request({
    method: "eth_newFilter",
    params: [
      {
        address,
        fromBlock: typeof fromBlock === "bigint" ? numberToHex(fromBlock) : fromBlock,
        toBlock: typeof toBlock === "bigint" ? numberToHex(toBlock) : toBlock,
        ...topics.length ? { topics } : {}
      }
    ]
  });
  return {
    abi: events2,
    args,
    eventName: event ? event.name : void 0,
    fromBlock,
    id,
    request: getRequest(id),
    strict: Boolean(strict),
    toBlock,
    type: "event"
  };
}

// node_modules/@audius/sdk/node_modules/viem/_esm/actions/public/createPendingTransactionFilter.js
async function createPendingTransactionFilter(client) {
  const getRequest = createFilterRequestScope(client, {
    method: "eth_newPendingTransactionFilter"
  });
  const id = await client.request({
    method: "eth_newPendingTransactionFilter"
  });
  return { id, request: getRequest(id), type: "transaction" };
}

// node_modules/@audius/sdk/node_modules/viem/_esm/actions/public/getBlobBaseFee.js
async function getBlobBaseFee(client) {
  const baseFee = await client.request({
    method: "eth_blobBaseFee"
  });
  return BigInt(baseFee);
}

// node_modules/@audius/sdk/node_modules/viem/_esm/actions/public/getBlockTransactionCount.js
async function getBlockTransactionCount(client, { blockHash, blockNumber, blockTag = "latest" } = {}) {
  const blockNumberHex = blockNumber !== void 0 ? numberToHex(blockNumber) : void 0;
  let count;
  if (blockHash) {
    count = await client.request({
      method: "eth_getBlockTransactionCountByHash",
      params: [blockHash]
    }, { dedupe: true });
  } else {
    count = await client.request({
      method: "eth_getBlockTransactionCountByNumber",
      params: [blockNumberHex || blockTag]
    }, { dedupe: Boolean(blockNumberHex) });
  }
  return hexToNumber(count);
}

// node_modules/@audius/sdk/node_modules/viem/_esm/actions/public/getCode.js
async function getCode(client, { address, blockNumber, blockTag = "latest" }) {
  const blockNumberHex = blockNumber !== void 0 ? numberToHex(blockNumber) : void 0;
  const hex3 = await client.request({
    method: "eth_getCode",
    params: [address, blockNumberHex || blockTag]
  }, { dedupe: Boolean(blockNumberHex) });
  if (hex3 === "0x")
    return void 0;
  return hex3;
}

// node_modules/@audius/sdk/node_modules/viem/_esm/utils/formatters/feeHistory.js
function formatFeeHistory(feeHistory) {
  var _a2;
  return {
    baseFeePerGas: feeHistory.baseFeePerGas.map((value) => BigInt(value)),
    gasUsedRatio: feeHistory.gasUsedRatio,
    oldestBlock: BigInt(feeHistory.oldestBlock),
    reward: (_a2 = feeHistory.reward) == null ? void 0 : _a2.map((reward) => reward.map((value) => BigInt(value)))
  };
}

// node_modules/@audius/sdk/node_modules/viem/_esm/actions/public/getFeeHistory.js
async function getFeeHistory(client, { blockCount, blockNumber, blockTag = "latest", rewardPercentiles }) {
  const blockNumberHex = blockNumber ? numberToHex(blockNumber) : void 0;
  const feeHistory = await client.request({
    method: "eth_feeHistory",
    params: [
      numberToHex(blockCount),
      blockNumberHex || blockTag,
      rewardPercentiles
    ]
  }, { dedupe: Boolean(blockNumberHex) });
  return formatFeeHistory(feeHistory);
}

// node_modules/@audius/sdk/node_modules/viem/_esm/actions/public/getFilterLogs.js
async function getFilterLogs(_client, { filter }) {
  const strict = filter.strict ?? false;
  const logs = await filter.request({
    method: "eth_getFilterLogs",
    params: [filter.id]
  });
  const formattedLogs = logs.map((log) => formatLog(log));
  if (!filter.abi)
    return formattedLogs;
  return parseEventLogs({
    abi: filter.abi,
    logs: formattedLogs,
    strict
  });
}

// node_modules/@audius/sdk/node_modules/viem/_esm/utils/regex.js
var bytesRegex = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/;
var integerRegex = /^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;

// node_modules/@audius/sdk/node_modules/viem/_esm/utils/signature/hashTypedData.js
function hashTypedData(parameters) {
  const { domain = {}, message, primaryType } = parameters;
  const types = {
    EIP712Domain: getTypesForEIP712Domain({ domain }),
    ...parameters.types
  };
  validateTypedData({
    domain,
    message,
    primaryType,
    types
  });
  const parts = ["0x1901"];
  if (domain)
    parts.push(hashDomain({
      domain,
      types
    }));
  if (primaryType !== "EIP712Domain")
    parts.push(hashStruct({
      data: message,
      primaryType,
      types
    }));
  return keccak256(concat(parts));
}
function hashDomain({ domain, types }) {
  return hashStruct({
    data: domain,
    primaryType: "EIP712Domain",
    types
  });
}
function hashStruct({ data, primaryType, types }) {
  const encoded = encodeData({
    data,
    primaryType,
    types
  });
  return keccak256(encoded);
}
function encodeData({ data, primaryType, types }) {
  const encodedTypes = [{ type: "bytes32" }];
  const encodedValues = [hashType({ primaryType, types })];
  for (const field of types[primaryType]) {
    const [type3, value] = encodeField({
      types,
      name: field.name,
      type: field.type,
      value: data[field.name]
    });
    encodedTypes.push(type3);
    encodedValues.push(value);
  }
  return encodeAbiParameters(encodedTypes, encodedValues);
}
function hashType({ primaryType, types }) {
  const encodedHashType = toHex(encodeType({ primaryType, types }));
  return keccak256(encodedHashType);
}
function encodeType({ primaryType, types }) {
  let result = "";
  const unsortedDeps = findTypeDependencies({ primaryType, types });
  unsortedDeps.delete(primaryType);
  const deps = [primaryType, ...Array.from(unsortedDeps).sort()];
  for (const type3 of deps) {
    result += `${type3}(${types[type3].map(({ name, type: t }) => `${t} ${name}`).join(",")})`;
  }
  return result;
}
function findTypeDependencies({ primaryType: primaryType_, types }, results = /* @__PURE__ */ new Set()) {
  const match = primaryType_.match(/^\w*/u);
  const primaryType = match == null ? void 0 : match[0];
  if (results.has(primaryType) || types[primaryType] === void 0) {
    return results;
  }
  results.add(primaryType);
  for (const field of types[primaryType]) {
    findTypeDependencies({ primaryType: field.type, types }, results);
  }
  return results;
}
function encodeField({ types, name, type: type3, value }) {
  if (types[type3] !== void 0) {
    return [
      { type: "bytes32" },
      keccak256(encodeData({ data: value, primaryType: type3, types }))
    ];
  }
  if (type3 === "bytes") {
    const prepend = value.length % 2 ? "0" : "";
    value = `0x${prepend + value.slice(2)}`;
    return [{ type: "bytes32" }, keccak256(value)];
  }
  if (type3 === "string")
    return [{ type: "bytes32" }, keccak256(toHex(value))];
  if (type3.lastIndexOf("]") === type3.length - 1) {
    const parsedType = type3.slice(0, type3.lastIndexOf("["));
    const typeValuePairs = value.map((item) => encodeField({
      name,
      type: parsedType,
      types,
      value: item
    }));
    return [
      { type: "bytes32" },
      keccak256(encodeAbiParameters(typeValuePairs.map(([t]) => t), typeValuePairs.map(([, v]) => v)))
    ];
  }
  return [{ type: type3 }, value];
}

// node_modules/@audius/sdk/node_modules/viem/_esm/utils/typedData.js
function serializeTypedData(parameters) {
  const { domain: domain_, message: message_, primaryType, types } = parameters;
  const normalizeData = (struct52, data_) => {
    const data = { ...data_ };
    for (const param of struct52) {
      const { name, type: type3 } = param;
      if (type3 === "address")
        data[name] = data[name].toLowerCase();
    }
    return data;
  };
  const domain = (() => {
    if (!types.EIP712Domain)
      return {};
    if (!domain_)
      return {};
    return normalizeData(types.EIP712Domain, domain_);
  })();
  const message = (() => {
    if (primaryType === "EIP712Domain")
      return void 0;
    return normalizeData(types[primaryType], message_);
  })();
  return stringify({ domain, message, primaryType, types });
}
function validateTypedData(parameters) {
  const { domain, message, primaryType, types } = parameters;
  const validateData = (struct52, data) => {
    for (const param of struct52) {
      const { name, type: type3 } = param;
      const value = data[name];
      const integerMatch = type3.match(integerRegex);
      if (integerMatch && (typeof value === "number" || typeof value === "bigint")) {
        const [_type, base3, size_] = integerMatch;
        numberToHex(value, {
          signed: base3 === "int",
          size: Number.parseInt(size_) / 8
        });
      }
      if (type3 === "address" && typeof value === "string" && !isAddress(value))
        throw new InvalidAddressError({ address: value });
      const bytesMatch = type3.match(bytesRegex);
      if (bytesMatch) {
        const [_type, size_] = bytesMatch;
        if (size_ && size(value) !== Number.parseInt(size_))
          throw new BytesSizeMismatchError({
            expectedSize: Number.parseInt(size_),
            givenSize: size(value)
          });
      }
      const struct53 = types[type3];
      if (struct53)
        validateData(struct53, value);
    }
  };
  if (types.EIP712Domain && domain)
    validateData(types.EIP712Domain, domain);
  if (primaryType !== "EIP712Domain")
    validateData(types[primaryType], message);
}
function getTypesForEIP712Domain({ domain }) {
  return [
    typeof (domain == null ? void 0 : domain.name) === "string" && { name: "name", type: "string" },
    (domain == null ? void 0 : domain.version) && { name: "version", type: "string" },
    typeof (domain == null ? void 0 : domain.chainId) === "number" && {
      name: "chainId",
      type: "uint256"
    },
    (domain == null ? void 0 : domain.verifyingContract) && {
      name: "verifyingContract",
      type: "address"
    },
    (domain == null ? void 0 : domain.salt) && { name: "salt", type: "bytes32" }
  ].filter(Boolean);
}

// node_modules/@audius/sdk/node_modules/viem/_esm/utils/abi/decodeFunctionData.js
function decodeFunctionData(parameters) {
  const { abi: abi14, data } = parameters;
  const signature2 = slice(data, 0, 4);
  const description = abi14.find((x) => x.type === "function" && signature2 === toFunctionSelector(formatAbiItem(x)));
  if (!description)
    throw new AbiFunctionSignatureNotFoundError(signature2, {
      docsPath: "/docs/contract/decodeFunctionData"
    });
  return {
    functionName: description.name,
    args: "inputs" in description && description.inputs && description.inputs.length > 0 ? decodeAbiParameters(description.inputs, slice(data, 4)) : void 0
  };
}

// node_modules/@audius/sdk/node_modules/viem/_esm/utils/formatters/transactionReceipt.js
var receiptStatuses = {
  "0x0": "reverted",
  "0x1": "success"
};
function formatTransactionReceipt(transactionReceipt) {
  const receipt = {
    ...transactionReceipt,
    blockNumber: transactionReceipt.blockNumber ? BigInt(transactionReceipt.blockNumber) : null,
    contractAddress: transactionReceipt.contractAddress ? transactionReceipt.contractAddress : null,
    cumulativeGasUsed: transactionReceipt.cumulativeGasUsed ? BigInt(transactionReceipt.cumulativeGasUsed) : null,
    effectiveGasPrice: transactionReceipt.effectiveGasPrice ? BigInt(transactionReceipt.effectiveGasPrice) : null,
    gasUsed: transactionReceipt.gasUsed ? BigInt(transactionReceipt.gasUsed) : null,
    logs: transactionReceipt.logs ? transactionReceipt.logs.map((log) => formatLog(log)) : null,
    to: transactionReceipt.to ? transactionReceipt.to : null,
    transactionIndex: transactionReceipt.transactionIndex ? hexToNumber(transactionReceipt.transactionIndex) : null,
    status: transactionReceipt.status ? receiptStatuses[transactionReceipt.status] : null,
    type: transactionReceipt.type ? transactionType[transactionReceipt.type] || transactionReceipt.type : null
  };
  if (transactionReceipt.blobGasPrice)
    receipt.blobGasPrice = BigInt(transactionReceipt.blobGasPrice);
  if (transactionReceipt.blobGasUsed)
    receipt.blobGasUsed = BigInt(transactionReceipt.blobGasUsed);
  return receipt;
}
var defineTransactionReceipt = defineFormatter("transactionReceipt", formatTransactionReceipt);

// node_modules/@audius/sdk/node_modules/viem/node_modules/@noble/hashes/esm/ripemd160.js
var Rho = new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]);
var Id = new Uint8Array(new Array(16).fill(0).map((_, i) => i));
var Pi = Id.map((i) => (9 * i + 5) % 16);
var idxL = [Id];
var idxR = [Pi];
for (let i = 0; i < 4; i++)
  for (let j of [idxL, idxR])
    j.push(j[i].map((k) => Rho[k]));
var shifts = [
  [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
  [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
  [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
  [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
  [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]
].map((i) => new Uint8Array(i));
var shiftsL = idxL.map((idx, i) => idx.map((j) => shifts[i][j]));
var shiftsR = idxR.map((idx, i) => idx.map((j) => shifts[i][j]));
var Kl = new Uint32Array([
  0,
  1518500249,
  1859775393,
  2400959708,
  2840853838
]);
var Kr = new Uint32Array([
  1352829926,
  1548603684,
  1836072691,
  2053994217,
  0
]);
function f(group, x, y, z2) {
  if (group === 0)
    return x ^ y ^ z2;
  else if (group === 1)
    return x & y | ~x & z2;
  else if (group === 2)
    return (x | ~y) ^ z2;
  else if (group === 3)
    return x & z2 | y & ~z2;
  else
    return x ^ (y | ~z2);
}
var R_BUF = new Uint32Array(16);
var RIPEMD160 = class extends HashMD {
  constructor() {
    super(64, 20, 8, true);
    this.h0 = 1732584193 | 0;
    this.h1 = 4023233417 | 0;
    this.h2 = 2562383102 | 0;
    this.h3 = 271733878 | 0;
    this.h4 = 3285377520 | 0;
  }
  get() {
    const { h0, h1, h2, h3, h4 } = this;
    return [h0, h1, h2, h3, h4];
  }
  set(h0, h1, h2, h3, h4) {
    this.h0 = h0 | 0;
    this.h1 = h1 | 0;
    this.h2 = h2 | 0;
    this.h3 = h3 | 0;
    this.h4 = h4 | 0;
  }
  process(view, offset3) {
    for (let i = 0; i < 16; i++, offset3 += 4)
      R_BUF[i] = view.getUint32(offset3, true);
    let al = this.h0 | 0, ar = al, bl = this.h1 | 0, br = bl, cl = this.h2 | 0, cr2 = cl, dl = this.h3 | 0, dr = dl, el = this.h4 | 0, er = el;
    for (let group = 0; group < 5; group++) {
      const rGroup = 4 - group;
      const hbl = Kl[group], hbr = Kr[group];
      const rl = idxL[group], rr = idxR[group];
      const sl = shiftsL[group], sr = shiftsR[group];
      for (let i = 0; i < 16; i++) {
        const tl = rotl(al + f(group, bl, cl, dl) + R_BUF[rl[i]] + hbl, sl[i]) + el | 0;
        al = el, el = dl, dl = rotl(cl, 10) | 0, cl = bl, bl = tl;
      }
      for (let i = 0; i < 16; i++) {
        const tr = rotl(ar + f(rGroup, br, cr2, dr) + R_BUF[rr[i]] + hbr, sr[i]) + er | 0;
        ar = er, er = dr, dr = rotl(cr2, 10) | 0, cr2 = br, br = tr;
      }
    }
    this.set(this.h1 + cl + dr | 0, this.h2 + dl + er | 0, this.h3 + el + ar | 0, this.h4 + al + br | 0, this.h0 + bl + cr2 | 0);
  }
  roundClean() {
    R_BUF.fill(0);
  }
  destroy() {
    this.destroyed = true;
    this.buffer.fill(0);
    this.set(0, 0, 0, 0, 0);
  }
};
var ripemd160 = wrapConstructor(() => new RIPEMD160());

// node_modules/@audius/sdk/node_modules/viem/_esm/constants/strings.js
var presignMessagePrefix = "Ethereum Signed Message:\n";

// node_modules/@audius/sdk/node_modules/viem/_esm/utils/signature/toPrefixedMessage.js
function toPrefixedMessage(message_) {
  const message = (() => {
    if (typeof message_ === "string")
      return stringToHex(message_);
    if (typeof message_.raw === "string")
      return message_.raw;
    return bytesToHex(message_.raw);
  })();
  const prefix = stringToHex(`${presignMessagePrefix}${size(message)}`);
  return concat([prefix, message]);
}

// node_modules/@audius/sdk/node_modules/viem/_esm/utils/signature/hashMessage.js
function hashMessage(message, to_) {
  return keccak256(toPrefixedMessage(message), to_);
}

// node_modules/@audius/sdk/node_modules/viem/_esm/utils/signature/recoverTypedDataAddress.js
async function recoverTypedDataAddress(parameters) {
  const { domain, message, primaryType, signature: signature2, types } = parameters;
  return recoverAddress({
    hash: hashTypedData({
      domain,
      message,
      primaryType,
      types
    }),
    signature: signature2
  });
}

// node_modules/@audius/sdk/node_modules/viem/_esm/constants/bytes.js
var erc6492MagicBytes = "0x6492649264926492649264926492649264926492649264926492649264926492";

// node_modules/@audius/sdk/node_modules/viem/_esm/utils/signature/isErc6492Signature.js
function isErc6492Signature(signature2) {
  return sliceHex(signature2, -32) === erc6492MagicBytes;
}

// node_modules/@audius/sdk/node_modules/viem/_esm/utils/signature/serializeErc6492Signature.js
function serializeErc6492Signature(parameters) {
  const { address, data, signature: signature2, to = "hex" } = parameters;
  const signature_ = concatHex([
    encodeAbiParameters([{ type: "address" }, { type: "bytes" }, { type: "bytes" }], [address, data, signature2]),
    erc6492MagicBytes
  ]);
  if (to === "hex")
    return signature_;
  return hexToBytes(signature_);
}

// node_modules/@audius/sdk/node_modules/viem/_esm/utils/nonceManager.js
function createNonceManager(parameters) {
  const { source } = parameters;
  const deltaMap = /* @__PURE__ */ new Map();
  const nonceMap = new LruMap(8192);
  const promiseMap = /* @__PURE__ */ new Map();
  const getKey = ({ address, chainId }) => `${address}.${chainId}`;
  return {
    async consume({ address, chainId, client }) {
      const key = getKey({ address, chainId });
      const promise = this.get({ address, chainId, client });
      this.increment({ address, chainId });
      const nonce = await promise;
      await source.set({ address, chainId }, nonce);
      nonceMap.set(key, nonce);
      return nonce;
    },
    async increment({ address, chainId }) {
      const key = getKey({ address, chainId });
      const delta = deltaMap.get(key) ?? 0;
      deltaMap.set(key, delta + 1);
    },
    async get({ address, chainId, client }) {
      const key = getKey({ address, chainId });
      let promise = promiseMap.get(key);
      if (!promise) {
        promise = (async () => {
          try {
            const nonce = await source.get({ address, chainId, client });
            const previousNonce = nonceMap.get(key) ?? 0;
            if (previousNonce > 0 && nonce <= previousNonce)
              return previousNonce + 1;
            nonceMap.delete(key);
            return nonce;
          } finally {
            this.reset({ address, chainId });
          }
        })();
        promiseMap.set(key, promise);
      }
      const delta = deltaMap.get(key) ?? 0;
      return delta + await promise;
    },
    reset({ address, chainId }) {
      const key = getKey({ address, chainId });
      deltaMap.delete(key);
      promiseMap.delete(key);
    }
  };
}
function jsonRpc() {
  return {
    async get(parameters) {
      const { address, client } = parameters;
      return getTransactionCount(client, {
        address,
        blockTag: "pending"
      });
    },
    set() {
    }
  };
}
var nonceManager = createNonceManager({
  source: jsonRpc()
});

// node_modules/@audius/sdk/node_modules/viem/_esm/utils/formatters/proof.js
function formatStorageProof(storageProof) {
  return storageProof.map((proof) => ({
    ...proof,
    value: BigInt(proof.value)
  }));
}
function formatProof(proof) {
  return {
    ...proof,
    balance: proof.balance ? BigInt(proof.balance) : void 0,
    nonce: proof.nonce ? hexToNumber(proof.nonce) : void 0,
    storageProof: proof.storageProof ? formatStorageProof(proof.storageProof) : void 0
  };
}

// node_modules/@audius/sdk/node_modules/viem/_esm/actions/public/getProof.js
async function getProof(client, { address, blockNumber, blockTag: blockTag_, storageKeys }) {
  const blockTag = blockTag_ ?? "latest";
  const blockNumberHex = blockNumber !== void 0 ? numberToHex(blockNumber) : void 0;
  const proof = await client.request({
    method: "eth_getProof",
    params: [address, storageKeys, blockNumberHex || blockTag]
  });
  return formatProof(proof);
}

// node_modules/@audius/sdk/node_modules/viem/_esm/actions/public/getStorageAt.js
async function getStorageAt(client, { address, blockNumber, blockTag = "latest", slot }) {
  const blockNumberHex = blockNumber !== void 0 ? numberToHex(blockNumber) : void 0;
  const data = await client.request({
    method: "eth_getStorageAt",
    params: [address, slot, blockNumberHex || blockTag]
  });
  return data;
}

// node_modules/@audius/sdk/node_modules/viem/_esm/actions/public/getTransaction.js
async function getTransaction(client, { blockHash, blockNumber, blockTag: blockTag_, hash: hash3, index: index4 }) {
  var _a2, _b, _c;
  const blockTag = blockTag_ || "latest";
  const blockNumberHex = blockNumber !== void 0 ? numberToHex(blockNumber) : void 0;
  let transaction = null;
  if (hash3) {
    transaction = await client.request({
      method: "eth_getTransactionByHash",
      params: [hash3]
    }, { dedupe: true });
  } else if (blockHash) {
    transaction = await client.request({
      method: "eth_getTransactionByBlockHashAndIndex",
      params: [blockHash, numberToHex(index4)]
    }, { dedupe: true });
  } else if (blockNumberHex || blockTag) {
    transaction = await client.request({
      method: "eth_getTransactionByBlockNumberAndIndex",
      params: [blockNumberHex || blockTag, numberToHex(index4)]
    }, { dedupe: Boolean(blockNumberHex) });
  }
  if (!transaction)
    throw new TransactionNotFoundError({
      blockHash,
      blockNumber,
      blockTag,
      hash: hash3,
      index: index4
    });
  const format2 = ((_c = (_b = (_a2 = client.chain) == null ? void 0 : _a2.formatters) == null ? void 0 : _b.transaction) == null ? void 0 : _c.format) || formatTransaction;
  return format2(transaction);
}

// node_modules/@audius/sdk/node_modules/viem/_esm/actions/public/getTransactionConfirmations.js
async function getTransactionConfirmations(client, { hash: hash3, transactionReceipt }) {
  const [blockNumber, transaction] = await Promise.all([
    getAction(client, getBlockNumber, "getBlockNumber")({}),
    hash3 ? getAction(client, getTransaction, "getTransaction")({ hash: hash3 }) : void 0
  ]);
  const transactionBlockNumber = (transactionReceipt == null ? void 0 : transactionReceipt.blockNumber) || (transaction == null ? void 0 : transaction.blockNumber);
  if (!transactionBlockNumber)
    return 0n;
  return blockNumber - transactionBlockNumber + 1n;
}

// node_modules/@audius/sdk/node_modules/viem/_esm/actions/public/getTransactionReceipt.js
async function getTransactionReceipt(client, { hash: hash3 }) {
  var _a2, _b, _c;
  const receipt = await client.request({
    method: "eth_getTransactionReceipt",
    params: [hash3]
  }, { dedupe: true });
  if (!receipt)
    throw new TransactionReceiptNotFoundError({ hash: hash3 });
  const format2 = ((_c = (_b = (_a2 = client.chain) == null ? void 0 : _a2.formatters) == null ? void 0 : _b.transactionReceipt) == null ? void 0 : _c.format) || formatTransactionReceipt;
  return format2(receipt);
}

// node_modules/@audius/sdk/node_modules/viem/_esm/actions/public/multicall.js
async function multicall(client, parameters) {
  var _a2;
  const { allowFailure = true, batchSize: batchSize_, blockNumber, blockTag, multicallAddress: multicallAddress_, stateOverride } = parameters;
  const contracts = parameters.contracts;
  const batchSize = batchSize_ ?? (typeof ((_a2 = client.batch) == null ? void 0 : _a2.multicall) === "object" && client.batch.multicall.batchSize || 1024);
  let multicallAddress = multicallAddress_;
  if (!multicallAddress) {
    if (!client.chain)
      throw new Error("client chain not configured. multicallAddress is required.");
    multicallAddress = getChainContractAddress({
      blockNumber,
      chain: client.chain,
      contract: "multicall3"
    });
  }
  const chunkedCalls = [[]];
  let currentChunk = 0;
  let currentChunkSize = 0;
  for (let i = 0; i < contracts.length; i++) {
    const { abi: abi14, address, args, functionName } = contracts[i];
    try {
      const callData = encodeFunctionData({ abi: abi14, args, functionName });
      currentChunkSize += (callData.length - 2) / 2;
      if (
        // Check if batching is enabled.
        batchSize > 0 && // Check if the current size of the batch exceeds the size limit.
        currentChunkSize > batchSize && // Check if the current chunk is not already empty.
        chunkedCalls[currentChunk].length > 0
      ) {
        currentChunk++;
        currentChunkSize = (callData.length - 2) / 2;
        chunkedCalls[currentChunk] = [];
      }
      chunkedCalls[currentChunk] = [
        ...chunkedCalls[currentChunk],
        {
          allowFailure: true,
          callData,
          target: address
        }
      ];
    } catch (err2) {
      const error = getContractError(err2, {
        abi: abi14,
        address,
        args,
        docsPath: "/docs/contract/multicall",
        functionName
      });
      if (!allowFailure)
        throw error;
      chunkedCalls[currentChunk] = [
        ...chunkedCalls[currentChunk],
        {
          allowFailure: true,
          callData: "0x",
          target: address
        }
      ];
    }
  }
  const aggregate3Results = await Promise.allSettled(chunkedCalls.map((calls) => getAction(client, readContract, "readContract")({
    abi: multicall3Abi,
    address: multicallAddress,
    args: [calls],
    blockNumber,
    blockTag,
    functionName: "aggregate3",
    stateOverride
  })));
  const results = [];
  for (let i = 0; i < aggregate3Results.length; i++) {
    const result = aggregate3Results[i];
    if (result.status === "rejected") {
      if (!allowFailure)
        throw result.reason;
      for (let j = 0; j < chunkedCalls[i].length; j++) {
        results.push({
          status: "failure",
          error: result.reason,
          result: void 0
        });
      }
      continue;
    }
    const aggregate3Result = result.value;
    for (let j = 0; j < aggregate3Result.length; j++) {
      const { returnData, success } = aggregate3Result[j];
      const { callData } = chunkedCalls[i][j];
      const { abi: abi14, address, functionName, args } = contracts[results.length];
      try {
        if (callData === "0x")
          throw new AbiDecodingZeroDataError();
        if (!success)
          throw new RawContractError({ data: returnData });
        const result2 = decodeFunctionResult({
          abi: abi14,
          args,
          data: returnData,
          functionName
        });
        results.push(allowFailure ? { result: result2, status: "success" } : result2);
      } catch (err2) {
        const error = getContractError(err2, {
          abi: abi14,
          address,
          args,
          docsPath: "/docs/contract/multicall",
          functionName
        });
        if (!allowFailure)
          throw error;
        results.push({ error, result: void 0, status: "failure" });
      }
    }
  }
  if (results.length !== contracts.length)
    throw new BaseError("multicall results mismatch");
  return results;
}

// node_modules/@audius/sdk/node_modules/viem/_esm/utils/data/isBytesEqual.js
function isBytesEqual(a_, b_) {
  const a = isHex(a_) ? toBytes(a_) : a_;
  const b = isHex(b_) ? toBytes(b_) : b_;
  return equalBytes(a, b);
}

// node_modules/@audius/sdk/node_modules/viem/_esm/utils/signature/serializeSignature.js
function serializeSignature({ r, s, to = "hex", v, yParity }) {
  const yParity_ = (() => {
    if (yParity === 0 || yParity === 1)
      return yParity;
    if (v && (v === 27n || v === 28n || v >= 35n))
      return v % 2n === 0n ? 1 : 0;
    throw new Error("Invalid `v` or `yParity` value");
  })();
  const signature2 = `0x${new secp256k1.Signature(hexToBigInt(r), hexToBigInt(s)).toCompactHex()}${yParity_ === 0 ? "1b" : "1c"}`;
  if (to === "hex")
    return signature2;
  return hexToBytes(signature2);
}

// node_modules/@audius/sdk/node_modules/viem/_esm/actions/public/verifyHash.js
async function verifyHash2(client, parameters) {
  const { address, factory: factory2, factoryData, hash: hash3, signature: signature2, ...rest } = parameters;
  const signatureHex = (() => {
    if (isHex(signature2))
      return signature2;
    if (typeof signature2 === "object" && "r" in signature2 && "s" in signature2)
      return serializeSignature(signature2);
    return bytesToHex(signature2);
  })();
  const wrappedSignature = await (async () => {
    if (!factory2 && !factoryData)
      return signatureHex;
    if (isErc6492Signature(signatureHex))
      return signatureHex;
    return serializeErc6492Signature({
      address: factory2,
      data: factoryData,
      signature: signatureHex
    });
  })();
  try {
    const { data } = await getAction(client, call, "call")({
      data: encodeDeployData({
        abi: universalSignatureValidatorAbi,
        args: [address, hash3, wrappedSignature],
        bytecode: universalSignatureValidatorByteCode
      }),
      ...rest
    });
    return isBytesEqual(data ?? "0x0", "0x1");
  } catch (error) {
    try {
      const verified = isAddressEqual(getAddress(address), await recoverAddress({ hash: hash3, signature: signature2 }));
      if (verified)
        return true;
    } catch {
    }
    if (error instanceof CallExecutionError) {
      return false;
    }
    throw error;
  }
}

// node_modules/@audius/sdk/node_modules/viem/_esm/actions/public/verifyMessage.js
async function verifyMessage2(client, { address, message, factory: factory2, factoryData, signature: signature2, ...callRequest }) {
  const hash3 = hashMessage(message);
  return verifyHash2(client, {
    address,
    factory: factory2,
    factoryData,
    hash: hash3,
    signature: signature2,
    ...callRequest
  });
}

// node_modules/@audius/sdk/node_modules/viem/_esm/actions/public/verifyTypedData.js
async function verifyTypedData2(client, parameters) {
  const { address, factory: factory2, factoryData, signature: signature2, message, primaryType, types, domain, ...callRequest } = parameters;
  const hash3 = hashTypedData({ message, primaryType, types, domain });
  return verifyHash2(client, {
    address,
    factory: factory2,
    factoryData,
    hash: hash3,
    signature: signature2,
    ...callRequest
  });
}

// node_modules/@audius/sdk/node_modules/viem/_esm/actions/public/watchBlockNumber.js
function watchBlockNumber(client, { emitOnBegin = false, emitMissed = false, onBlockNumber, onError, poll: poll_, pollingInterval = client.pollingInterval }) {
  const enablePolling = (() => {
    if (typeof poll_ !== "undefined")
      return poll_;
    if (client.transport.type === "webSocket")
      return false;
    if (client.transport.type === "fallback" && client.transport.transports[0].config.type === "webSocket")
      return false;
    return true;
  })();
  let prevBlockNumber;
  const pollBlockNumber = () => {
    const observerId = stringify([
      "watchBlockNumber",
      client.uid,
      emitOnBegin,
      emitMissed,
      pollingInterval
    ]);
    return observe(observerId, { onBlockNumber, onError }, (emit) => poll(async () => {
      var _a2;
      try {
        const blockNumber = await getAction(client, getBlockNumber, "getBlockNumber")({ cacheTime: 0 });
        if (prevBlockNumber) {
          if (blockNumber === prevBlockNumber)
            return;
          if (blockNumber - prevBlockNumber > 1 && emitMissed) {
            for (let i = prevBlockNumber + 1n; i < blockNumber; i++) {
              emit.onBlockNumber(i, prevBlockNumber);
              prevBlockNumber = i;
            }
          }
        }
        if (!prevBlockNumber || blockNumber > prevBlockNumber) {
          emit.onBlockNumber(blockNumber, prevBlockNumber);
          prevBlockNumber = blockNumber;
        }
      } catch (err2) {
        (_a2 = emit.onError) == null ? void 0 : _a2.call(emit, err2);
      }
    }, {
      emitOnBegin,
      interval: pollingInterval
    }));
  };
  const subscribeBlockNumber = () => {
    const observerId = stringify([
      "watchBlockNumber",
      client.uid,
      emitOnBegin,
      emitMissed
    ]);
    return observe(observerId, { onBlockNumber, onError }, (emit) => {
      let active = true;
      let unsubscribe = () => active = false;
      (async () => {
        try {
          const transport = (() => {
            if (client.transport.type === "fallback") {
              const transport2 = client.transport.transports.find((transport3) => transport3.config.type === "webSocket");
              if (!transport2)
                return client.transport;
              return transport2.value;
            }
            return client.transport;
          })();
          const { unsubscribe: unsubscribe_ } = await transport.subscribe({
            params: ["newHeads"],
            onData(data) {
              var _a2;
              if (!active)
                return;
              const blockNumber = hexToBigInt((_a2 = data.result) == null ? void 0 : _a2.number);
              emit.onBlockNumber(blockNumber, prevBlockNumber);
              prevBlockNumber = blockNumber;
            },
            onError(error) {
              var _a2;
              (_a2 = emit.onError) == null ? void 0 : _a2.call(emit, error);
            }
          });
          unsubscribe = unsubscribe_;
          if (!active)
            unsubscribe();
        } catch (err2) {
          onError == null ? void 0 : onError(err2);
        }
      })();
      return () => unsubscribe();
    });
  };
  return enablePolling ? pollBlockNumber() : subscribeBlockNumber();
}

// node_modules/@audius/sdk/node_modules/viem/_esm/actions/public/waitForTransactionReceipt.js
async function waitForTransactionReceipt(client, {
  confirmations = 1,
  hash: hash3,
  onReplaced,
  pollingInterval = client.pollingInterval,
  retryCount = 6,
  retryDelay = ({ count }) => ~~(1 << count) * 200,
  // exponential backoff
  timeout = 18e4
}) {
  const observerId = stringify(["waitForTransactionReceipt", client.uid, hash3]);
  let transaction;
  let replacedTransaction;
  let receipt;
  let retrying = false;
  return new Promise((resolve2, reject2) => {
    if (timeout)
      setTimeout(() => reject2(new WaitForTransactionReceiptTimeoutError({ hash: hash3 })), timeout);
    const _unobserve = observe(observerId, { onReplaced, resolve: resolve2, reject: reject2 }, (emit) => {
      const _unwatch = getAction(client, watchBlockNumber, "watchBlockNumber")({
        emitMissed: true,
        emitOnBegin: true,
        poll: true,
        pollingInterval,
        async onBlockNumber(blockNumber_) {
          const done = (fn) => {
            _unwatch();
            fn();
            _unobserve();
          };
          let blockNumber = blockNumber_;
          if (retrying)
            return;
          try {
            if (receipt) {
              if (confirmations > 1 && (!receipt.blockNumber || blockNumber - receipt.blockNumber + 1n < confirmations))
                return;
              done(() => emit.resolve(receipt));
              return;
            }
            if (!transaction) {
              retrying = true;
              await withRetry(async () => {
                transaction = await getAction(client, getTransaction, "getTransaction")({ hash: hash3 });
                if (transaction.blockNumber)
                  blockNumber = transaction.blockNumber;
              }, {
                delay: retryDelay,
                retryCount
              });
              retrying = false;
            }
            receipt = await getAction(client, getTransactionReceipt, "getTransactionReceipt")({ hash: hash3 });
            if (confirmations > 1 && (!receipt.blockNumber || blockNumber - receipt.blockNumber + 1n < confirmations))
              return;
            done(() => emit.resolve(receipt));
          } catch (err2) {
            if (err2 instanceof TransactionNotFoundError || err2 instanceof TransactionReceiptNotFoundError) {
              if (!transaction) {
                retrying = false;
                return;
              }
              try {
                replacedTransaction = transaction;
                retrying = true;
                const block = await withRetry(() => getAction(client, getBlock, "getBlock")({
                  blockNumber,
                  includeTransactions: true
                }), {
                  delay: retryDelay,
                  retryCount,
                  shouldRetry: ({ error }) => error instanceof BlockNotFoundError
                });
                retrying = false;
                const replacementTransaction = block.transactions.find(({ from: from2, nonce }) => from2 === replacedTransaction.from && nonce === replacedTransaction.nonce);
                if (!replacementTransaction)
                  return;
                receipt = await getAction(client, getTransactionReceipt, "getTransactionReceipt")({
                  hash: replacementTransaction.hash
                });
                if (confirmations > 1 && (!receipt.blockNumber || blockNumber - receipt.blockNumber + 1n < confirmations))
                  return;
                let reason = "replaced";
                if (replacementTransaction.to === replacedTransaction.to && replacementTransaction.value === replacedTransaction.value) {
                  reason = "repriced";
                } else if (replacementTransaction.from === replacementTransaction.to && replacementTransaction.value === 0n) {
                  reason = "cancelled";
                }
                done(() => {
                  var _a2;
                  (_a2 = emit.onReplaced) == null ? void 0 : _a2.call(emit, {
                    reason,
                    replacedTransaction,
                    transaction: replacementTransaction,
                    transactionReceipt: receipt
                  });
                  emit.resolve(receipt);
                });
              } catch (err_) {
                done(() => emit.reject(err_));
              }
            } else {
              done(() => emit.reject(err2));
            }
          }
        }
      });
    });
  });
}

// node_modules/@audius/sdk/node_modules/viem/_esm/actions/public/watchBlocks.js
function watchBlocks(client, { blockTag = "latest", emitMissed = false, emitOnBegin = false, onBlock, onError, includeTransactions: includeTransactions_, poll: poll_, pollingInterval = client.pollingInterval }) {
  const enablePolling = (() => {
    if (typeof poll_ !== "undefined")
      return poll_;
    if (client.transport.type === "webSocket")
      return false;
    if (client.transport.type === "fallback" && client.transport.transports[0].config.type === "webSocket")
      return false;
    return true;
  })();
  const includeTransactions = includeTransactions_ ?? false;
  let prevBlock;
  const pollBlocks = () => {
    const observerId = stringify([
      "watchBlocks",
      client.uid,
      blockTag,
      emitMissed,
      emitOnBegin,
      includeTransactions,
      pollingInterval
    ]);
    return observe(observerId, { onBlock, onError }, (emit) => poll(async () => {
      var _a2;
      try {
        const block = await getAction(client, getBlock, "getBlock")({
          blockTag,
          includeTransactions
        });
        if (block.number && (prevBlock == null ? void 0 : prevBlock.number)) {
          if (block.number === prevBlock.number)
            return;
          if (block.number - prevBlock.number > 1 && emitMissed) {
            for (let i = (prevBlock == null ? void 0 : prevBlock.number) + 1n; i < block.number; i++) {
              const block2 = await getAction(client, getBlock, "getBlock")({
                blockNumber: i,
                includeTransactions
              });
              emit.onBlock(block2, prevBlock);
              prevBlock = block2;
            }
          }
        }
        if (
          // If no previous block exists, emit.
          !(prevBlock == null ? void 0 : prevBlock.number) || // If the block tag is "pending" with no block number, emit.
          blockTag === "pending" && !(block == null ? void 0 : block.number) || // If the next block number is greater than the previous block number, emit.
          // We don't want to emit blocks in the past.
          block.number && block.number > prevBlock.number
        ) {
          emit.onBlock(block, prevBlock);
          prevBlock = block;
        }
      } catch (err2) {
        (_a2 = emit.onError) == null ? void 0 : _a2.call(emit, err2);
      }
    }, {
      emitOnBegin,
      interval: pollingInterval
    }));
  };
  const subscribeBlocks = () => {
    let active = true;
    let emitFetched = true;
    let unsubscribe = () => active = false;
    (async () => {
      try {
        if (emitOnBegin) {
          getAction(client, getBlock, "getBlock")({
            blockTag,
            includeTransactions
          }).then((block) => {
            if (!active)
              return;
            if (!emitFetched)
              return;
            onBlock(block, void 0);
            emitFetched = false;
          });
        }
        const transport = (() => {
          if (client.transport.type === "fallback") {
            const transport2 = client.transport.transports.find((transport3) => transport3.config.type === "webSocket");
            if (!transport2)
              return client.transport;
            return transport2.value;
          }
          return client.transport;
        })();
        const { unsubscribe: unsubscribe_ } = await transport.subscribe({
          params: ["newHeads"],
          onData(data) {
            var _a2, _b, _c;
            if (!active)
              return;
            const format2 = ((_c = (_b = (_a2 = client.chain) == null ? void 0 : _a2.formatters) == null ? void 0 : _b.block) == null ? void 0 : _c.format) || formatBlock;
            const block = format2(data.result);
            onBlock(block, prevBlock);
            emitFetched = false;
            prevBlock = block;
          },
          onError(error) {
            onError == null ? void 0 : onError(error);
          }
        });
        unsubscribe = unsubscribe_;
        if (!active)
          unsubscribe();
      } catch (err2) {
        onError == null ? void 0 : onError(err2);
      }
    })();
    return () => unsubscribe();
  };
  return enablePolling ? pollBlocks() : subscribeBlocks();
}

// node_modules/@audius/sdk/node_modules/viem/_esm/actions/public/watchEvent.js
function watchEvent(client, { address, args, batch = true, event, events: events2, fromBlock, onError, onLogs, poll: poll_, pollingInterval = client.pollingInterval, strict: strict_ }) {
  const enablePolling = (() => {
    if (typeof poll_ !== "undefined")
      return poll_;
    if (typeof fromBlock === "bigint")
      return true;
    if (client.transport.type === "webSocket")
      return false;
    if (client.transport.type === "fallback" && client.transport.transports[0].config.type === "webSocket")
      return false;
    return true;
  })();
  const strict = strict_ ?? false;
  const pollEvent = () => {
    const observerId = stringify([
      "watchEvent",
      address,
      args,
      batch,
      client.uid,
      event,
      pollingInterval,
      fromBlock
    ]);
    return observe(observerId, { onLogs, onError }, (emit) => {
      let previousBlockNumber;
      if (fromBlock !== void 0)
        previousBlockNumber = fromBlock - 1n;
      let filter;
      let initialized = false;
      const unwatch = poll(async () => {
        var _a2;
        if (!initialized) {
          try {
            filter = await getAction(client, createEventFilter, "createEventFilter")({
              address,
              args,
              event,
              events: events2,
              strict,
              fromBlock
            });
          } catch {
          }
          initialized = true;
          return;
        }
        try {
          let logs;
          if (filter) {
            logs = await getAction(client, getFilterChanges, "getFilterChanges")({ filter });
          } else {
            const blockNumber = await getAction(client, getBlockNumber, "getBlockNumber")({});
            if (previousBlockNumber && previousBlockNumber !== blockNumber) {
              logs = await getAction(client, getLogs, "getLogs")({
                address,
                args,
                event,
                events: events2,
                fromBlock: previousBlockNumber + 1n,
                toBlock: blockNumber
              });
            } else {
              logs = [];
            }
            previousBlockNumber = blockNumber;
          }
          if (logs.length === 0)
            return;
          if (batch)
            emit.onLogs(logs);
          else
            for (const log of logs)
              emit.onLogs([log]);
        } catch (err2) {
          if (filter && err2 instanceof InvalidInputRpcError)
            initialized = false;
          (_a2 = emit.onError) == null ? void 0 : _a2.call(emit, err2);
        }
      }, {
        emitOnBegin: true,
        interval: pollingInterval
      });
      return async () => {
        if (filter)
          await getAction(client, uninstallFilter, "uninstallFilter")({ filter });
        unwatch();
      };
    });
  };
  const subscribeEvent = () => {
    let active = true;
    let unsubscribe = () => active = false;
    (async () => {
      try {
        const transport = (() => {
          if (client.transport.type === "fallback") {
            const transport2 = client.transport.transports.find((transport3) => transport3.config.type === "webSocket");
            if (!transport2)
              return client.transport;
            return transport2.value;
          }
          return client.transport;
        })();
        const events_ = events2 ?? (event ? [event] : void 0);
        let topics = [];
        if (events_) {
          const encoded = events_.flatMap((event2) => encodeEventTopics({
            abi: [event2],
            eventName: event2.name,
            args
          }));
          topics = [encoded];
          if (event)
            topics = topics[0];
        }
        const { unsubscribe: unsubscribe_ } = await transport.subscribe({
          params: ["logs", { address, topics }],
          onData(data) {
            var _a2;
            if (!active)
              return;
            const log = data.result;
            try {
              const { eventName, args: args2 } = decodeEventLog({
                abi: events_ ?? [],
                data: log.data,
                topics: log.topics,
                strict
              });
              const formatted = formatLog(log, { args: args2, eventName });
              onLogs([formatted]);
            } catch (err2) {
              let eventName;
              let isUnnamed;
              if (err2 instanceof DecodeLogDataMismatch || err2 instanceof DecodeLogTopicsMismatch) {
                if (strict_)
                  return;
                eventName = err2.abiItem.name;
                isUnnamed = (_a2 = err2.abiItem.inputs) == null ? void 0 : _a2.some((x) => !("name" in x && x.name));
              }
              const formatted = formatLog(log, {
                args: isUnnamed ? [] : {},
                eventName
              });
              onLogs([formatted]);
            }
          },
          onError(error) {
            onError == null ? void 0 : onError(error);
          }
        });
        unsubscribe = unsubscribe_;
        if (!active)
          unsubscribe();
      } catch (err2) {
        onError == null ? void 0 : onError(err2);
      }
    })();
    return () => unsubscribe();
  };
  return enablePolling ? pollEvent() : subscribeEvent();
}

// node_modules/@audius/sdk/node_modules/viem/_esm/actions/public/watchPendingTransactions.js
function watchPendingTransactions(client, { batch = true, onError, onTransactions, poll: poll_, pollingInterval = client.pollingInterval }) {
  const enablePolling = typeof poll_ !== "undefined" ? poll_ : client.transport.type !== "webSocket";
  const pollPendingTransactions = () => {
    const observerId = stringify([
      "watchPendingTransactions",
      client.uid,
      batch,
      pollingInterval
    ]);
    return observe(observerId, { onTransactions, onError }, (emit) => {
      let filter;
      const unwatch = poll(async () => {
        var _a2;
        try {
          if (!filter) {
            try {
              filter = await getAction(client, createPendingTransactionFilter, "createPendingTransactionFilter")({});
              return;
            } catch (err2) {
              unwatch();
              throw err2;
            }
          }
          const hashes = await getAction(client, getFilterChanges, "getFilterChanges")({ filter });
          if (hashes.length === 0)
            return;
          if (batch)
            emit.onTransactions(hashes);
          else
            for (const hash3 of hashes)
              emit.onTransactions([hash3]);
        } catch (err2) {
          (_a2 = emit.onError) == null ? void 0 : _a2.call(emit, err2);
        }
      }, {
        emitOnBegin: true,
        interval: pollingInterval
      });
      return async () => {
        if (filter)
          await getAction(client, uninstallFilter, "uninstallFilter")({ filter });
        unwatch();
      };
    });
  };
  const subscribePendingTransactions = () => {
    let active = true;
    let unsubscribe = () => active = false;
    (async () => {
      try {
        const { unsubscribe: unsubscribe_ } = await client.transport.subscribe({
          params: ["newPendingTransactions"],
          onData(data) {
            if (!active)
              return;
            const transaction = data.result;
            onTransactions([transaction]);
          },
          onError(error) {
            onError == null ? void 0 : onError(error);
          }
        });
        unsubscribe = unsubscribe_;
        if (!active)
          unsubscribe();
      } catch (err2) {
        onError == null ? void 0 : onError(err2);
      }
    })();
    return () => unsubscribe();
  };
  return enablePolling ? pollPendingTransactions() : subscribePendingTransactions();
}

// node_modules/@audius/sdk/node_modules/viem/_esm/utils/siwe/parseSiweMessage.js
function parseSiweMessage(message) {
  var _a2, _b, _c;
  const { scheme, statement, ...prefix } = ((_a2 = message.match(prefixRegex)) == null ? void 0 : _a2.groups) ?? {};
  const { chainId, expirationTime, issuedAt, notBefore, requestId, ...suffix } = ((_b = message.match(suffixRegex)) == null ? void 0 : _b.groups) ?? {};
  const resources = (_c = message.split("Resources:")[1]) == null ? void 0 : _c.split("\n- ").slice(1);
  return {
    ...prefix,
    ...suffix,
    ...chainId ? { chainId: Number(chainId) } : {},
    ...expirationTime ? { expirationTime: new Date(expirationTime) } : {},
    ...issuedAt ? { issuedAt: new Date(issuedAt) } : {},
    ...notBefore ? { notBefore: new Date(notBefore) } : {},
    ...requestId ? { requestId } : {},
    ...resources ? { resources } : {},
    ...scheme ? { scheme } : {},
    ...statement ? { statement } : {}
  };
}
var prefixRegex = /^(?:(?<scheme>[a-zA-Z][a-zA-Z0-9+-.]*):\/\/)?(?<domain>[a-zA-Z0-9+-.]*(?::[0-9]{1,5})?) (?:wants you to sign in with your Ethereum account:\n)(?<address>0x[a-fA-F0-9]{40})\n\n(?:(?<statement>.*)\n\n)?/;
var suffixRegex = /(?:URI: (?<uri>.+))\n(?:Version: (?<version>.+))\n(?:Chain ID: (?<chainId>\d+))\n(?:Nonce: (?<nonce>[a-zA-Z0-9]+))\n(?:Issued At: (?<issuedAt>.+))(?:\nExpiration Time: (?<expirationTime>.+))?(?:\nNot Before: (?<notBefore>.+))?(?:\nRequest ID: (?<requestId>.+))?/;

// node_modules/@audius/sdk/node_modules/viem/_esm/utils/siwe/validateSiweMessage.js
function validateSiweMessage(parameters) {
  const { address, domain, message, nonce, scheme, time = /* @__PURE__ */ new Date() } = parameters;
  if (domain && message.domain !== domain)
    return false;
  if (nonce && message.nonce !== nonce)
    return false;
  if (scheme && message.scheme !== scheme)
    return false;
  if (message.expirationTime && time >= message.expirationTime)
    return false;
  if (message.notBefore && time < message.notBefore)
    return false;
  try {
    if (!message.address)
      return false;
    if (address && !isAddressEqual(message.address, address))
      return false;
  } catch {
    return false;
  }
  return true;
}

// node_modules/@audius/sdk/node_modules/viem/_esm/actions/siwe/verifySiweMessage.js
async function verifySiweMessage(client, parameters) {
  const { address, domain, message, nonce, scheme, signature: signature2, time = /* @__PURE__ */ new Date(), ...callRequest } = parameters;
  const parsed = parseSiweMessage(message);
  if (!parsed.address)
    return false;
  const isValid = validateSiweMessage({
    address,
    domain,
    message: parsed,
    nonce,
    scheme,
    time
  });
  if (!isValid)
    return false;
  const hash3 = hashMessage(message);
  return verifyHash2(client, {
    address: parsed.address,
    hash: hash3,
    signature: signature2,
    ...callRequest
  });
}

// node_modules/@audius/sdk/node_modules/viem/_esm/clients/decorators/public.js
function publicActions(client) {
  return {
    call: (args) => call(client, args),
    createBlockFilter: () => createBlockFilter(client),
    createContractEventFilter: (args) => createContractEventFilter(client, args),
    createEventFilter: (args) => createEventFilter(client, args),
    createPendingTransactionFilter: () => createPendingTransactionFilter(client),
    estimateContractGas: (args) => estimateContractGas(client, args),
    estimateGas: (args) => estimateGas(client, args),
    getBalance: (args) => getBalance(client, args),
    getBlobBaseFee: () => getBlobBaseFee(client),
    getBlock: (args) => getBlock(client, args),
    getBlockNumber: (args) => getBlockNumber(client, args),
    getBlockTransactionCount: (args) => getBlockTransactionCount(client, args),
    getBytecode: (args) => getCode(client, args),
    getChainId: () => getChainId(client),
    getCode: (args) => getCode(client, args),
    getContractEvents: (args) => getContractEvents(client, args),
    getEip712Domain: (args) => getEip712Domain(client, args),
    getEnsAddress: (args) => getEnsAddress(client, args),
    getEnsAvatar: (args) => getEnsAvatar(client, args),
    getEnsName: (args) => getEnsName(client, args),
    getEnsResolver: (args) => getEnsResolver(client, args),
    getEnsText: (args) => getEnsText(client, args),
    getFeeHistory: (args) => getFeeHistory(client, args),
    estimateFeesPerGas: (args) => estimateFeesPerGas(client, args),
    getFilterChanges: (args) => getFilterChanges(client, args),
    getFilterLogs: (args) => getFilterLogs(client, args),
    getGasPrice: () => getGasPrice(client),
    getLogs: (args) => getLogs(client, args),
    getProof: (args) => getProof(client, args),
    estimateMaxPriorityFeePerGas: (args) => estimateMaxPriorityFeePerGas(client, args),
    getStorageAt: (args) => getStorageAt(client, args),
    getTransaction: (args) => getTransaction(client, args),
    getTransactionConfirmations: (args) => getTransactionConfirmations(client, args),
    getTransactionCount: (args) => getTransactionCount(client, args),
    getTransactionReceipt: (args) => getTransactionReceipt(client, args),
    multicall: (args) => multicall(client, args),
    prepareTransactionRequest: (args) => prepareTransactionRequest(client, args),
    readContract: (args) => readContract(client, args),
    sendRawTransaction: (args) => sendRawTransaction(client, args),
    simulateContract: (args) => simulateContract(client, args),
    verifyMessage: (args) => verifyMessage2(client, args),
    verifySiweMessage: (args) => verifySiweMessage(client, args),
    verifyTypedData: (args) => verifyTypedData2(client, args),
    uninstallFilter: (args) => uninstallFilter(client, args),
    waitForTransactionReceipt: (args) => waitForTransactionReceipt(client, args),
    watchBlocks: (args) => watchBlocks(client, args),
    watchBlockNumber: (args) => watchBlockNumber(client, args),
    watchContractEvent: (args) => watchContractEvent(client, args),
    watchEvent: (args) => watchEvent(client, args),
    watchPendingTransactions: (args) => watchPendingTransactions(client, args)
  };
}

// node_modules/@audius/sdk/node_modules/viem/_esm/clients/createPublicClient.js
function createPublicClient(parameters) {
  const { key = "public", name = "Public Client" } = parameters;
  const client = createClient({
    ...parameters,
    key,
    name,
    type: "publicClient"
  });
  return client.extend(publicActions);
}

// node_modules/@audius/sdk/node_modules/viem/_esm/actions/wallet/deployContract.js
function deployContract(walletClient, parameters) {
  const { abi: abi14, args, bytecode, ...request } = parameters;
  const calldata = encodeDeployData({ abi: abi14, args, bytecode });
  return sendTransaction(walletClient, {
    ...request,
    data: calldata
  });
}

// node_modules/@audius/sdk/node_modules/viem/_esm/actions/wallet/getAddresses.js
async function getAddresses(client) {
  var _a2;
  if (((_a2 = client.account) == null ? void 0 : _a2.type) === "local")
    return [client.account.address];
  const addresses = await client.request({ method: "eth_accounts" }, { dedupe: true });
  return addresses.map((address) => checksumAddress(address));
}

// node_modules/@audius/sdk/node_modules/viem/_esm/actions/wallet/getPermissions.js
async function getPermissions(client) {
  const permissions = await client.request({ method: "wallet_getPermissions" }, { dedupe: true });
  return permissions;
}

// node_modules/@audius/sdk/node_modules/viem/_esm/actions/wallet/requestAddresses.js
async function requestAddresses(client) {
  const addresses = await client.request({ method: "eth_requestAccounts" }, { dedupe: true, retryCount: 0 });
  return addresses.map((address) => getAddress(address));
}

// node_modules/@audius/sdk/node_modules/viem/_esm/actions/wallet/requestPermissions.js
async function requestPermissions(client, permissions) {
  return client.request({
    method: "wallet_requestPermissions",
    params: [permissions]
  }, { retryCount: 0 });
}

// node_modules/@audius/sdk/node_modules/viem/_esm/actions/wallet/signMessage.js
async function signMessage(client, { account: account_ = client.account, message }) {
  if (!account_)
    throw new AccountNotFoundError({
      docsPath: "/docs/actions/wallet/signMessage"
    });
  const account = parseAccount(account_);
  if (account.signMessage)
    return account.signMessage({ message });
  const message_ = (() => {
    if (typeof message === "string")
      return stringToHex(message);
    if (message.raw instanceof Uint8Array)
      return toHex(message.raw);
    return message.raw;
  })();
  return client.request({
    method: "personal_sign",
    params: [message_, account.address]
  }, { retryCount: 0 });
}

// node_modules/@audius/sdk/node_modules/viem/_esm/actions/wallet/signTransaction.js
async function signTransaction(client, parameters) {
  var _a2, _b, _c, _d;
  const { account: account_ = client.account, chain: chain2 = client.chain, ...transaction } = parameters;
  if (!account_)
    throw new AccountNotFoundError({
      docsPath: "/docs/actions/wallet/signTransaction"
    });
  const account = parseAccount(account_);
  assertRequest({
    account,
    ...parameters
  });
  const chainId = await getAction(client, getChainId, "getChainId")({});
  if (chain2 !== null)
    assertCurrentChain({
      currentChainId: chainId,
      chain: chain2
    });
  const formatters = (chain2 == null ? void 0 : chain2.formatters) || ((_a2 = client.chain) == null ? void 0 : _a2.formatters);
  const format2 = ((_b = formatters == null ? void 0 : formatters.transactionRequest) == null ? void 0 : _b.format) || formatTransactionRequest;
  if (account.signTransaction)
    return account.signTransaction({
      ...transaction,
      chainId
    }, { serializer: (_d = (_c = client.chain) == null ? void 0 : _c.serializers) == null ? void 0 : _d.transaction });
  return await client.request({
    method: "eth_signTransaction",
    params: [
      {
        ...format2(transaction),
        chainId: numberToHex(chainId),
        from: account.address
      }
    ]
  }, { retryCount: 0 });
}

// node_modules/@audius/sdk/node_modules/viem/_esm/actions/wallet/signTypedData.js
async function signTypedData(client, parameters) {
  const { account: account_ = client.account, domain, message, primaryType } = parameters;
  if (!account_)
    throw new AccountNotFoundError({
      docsPath: "/docs/actions/wallet/signTypedData"
    });
  const account = parseAccount(account_);
  const types = {
    EIP712Domain: getTypesForEIP712Domain({ domain }),
    ...parameters.types
  };
  validateTypedData({ domain, message, primaryType, types });
  if (account.signTypedData)
    return account.signTypedData({ domain, message, primaryType, types });
  const typedData = serializeTypedData({ domain, message, primaryType, types });
  return client.request({
    method: "eth_signTypedData_v4",
    params: [account.address, typedData]
  }, { retryCount: 0 });
}

// node_modules/@audius/sdk/node_modules/viem/_esm/actions/wallet/switchChain.js
async function switchChain(client, { id }) {
  await client.request({
    method: "wallet_switchEthereumChain",
    params: [
      {
        chainId: numberToHex(id)
      }
    ]
  }, { retryCount: 0 });
}

// node_modules/@audius/sdk/node_modules/viem/_esm/actions/wallet/watchAsset.js
async function watchAsset(client, params) {
  const added = await client.request({
    method: "wallet_watchAsset",
    params
  }, { retryCount: 0 });
  return added;
}

// node_modules/@audius/sdk/node_modules/viem/_esm/clients/decorators/wallet.js
function walletActions(client) {
  return {
    addChain: (args) => addChain(client, args),
    deployContract: (args) => deployContract(client, args),
    getAddresses: () => getAddresses(client),
    getChainId: () => getChainId(client),
    getPermissions: () => getPermissions(client),
    prepareTransactionRequest: (args) => prepareTransactionRequest(client, args),
    requestAddresses: () => requestAddresses(client),
    requestPermissions: (args) => requestPermissions(client, args),
    sendRawTransaction: (args) => sendRawTransaction(client, args),
    sendTransaction: (args) => sendTransaction(client, args),
    signMessage: (args) => signMessage(client, args),
    signTransaction: (args) => signTransaction(client, args),
    signTypedData: (args) => signTypedData(client, args),
    switchChain: (args) => switchChain(client, args),
    watchAsset: (args) => watchAsset(client, args),
    writeContract: (args) => writeContract(client, args)
  };
}

// node_modules/@audius/sdk/node_modules/viem/_esm/clients/createWalletClient.js
function createWalletClient(parameters) {
  const { key = "wallet", name = "Wallet Client", transport } = parameters;
  const client = createClient({
    ...parameters,
    key,
    name,
    transport,
    type: "walletClient"
  });
  return client.extend(walletActions);
}

// node_modules/@audius/sdk/node_modules/viem/_esm/utils/signature/parseSignature.js
function parseSignature(signatureHex) {
  const { r, s } = secp256k1.Signature.fromCompact(signatureHex.slice(2, 130));
  const yParityOrV = Number(`0x${signatureHex.slice(130)}`);
  const [v, yParity] = (() => {
    if (yParityOrV === 0 || yParityOrV === 1)
      return [void 0, yParityOrV];
    if (yParityOrV === 27)
      return [BigInt(yParityOrV), 0];
    if (yParityOrV === 28)
      return [BigInt(yParityOrV), 1];
    throw new Error("Invalid yParityOrV value");
  })();
  if (typeof v !== "undefined")
    return {
      r: numberToHex(r, { size: 32 }),
      s: numberToHex(s, { size: 32 }),
      v,
      yParity
    };
  return {
    r: numberToHex(r, { size: 32 }),
    s: numberToHex(s, { size: 32 }),
    yParity
  };
}

// node_modules/@audius/fixed-decimal/dist/esm/FixedDecimal.js
var parseFixedDecimalString = (value, decimalPlaces) => {
  let [whole, decimal] = value.split(".");
  decimal = decimal ?? "";
  if (decimalPlaces !== void 0) {
    decimal = decimal.padEnd(decimalPlaces, "0").substring(0, decimalPlaces);
  }
  return {
    value: BigInt(`${whole}${decimal}`),
    decimalPlaces: decimalPlaces ?? decimal.length
  };
};
var getDefaultFormatOptions = (value) => ({
  useGrouping: true,
  minimumFractionDigits: 0,
  maximumFractionDigits: value.decimalPlaces,
  roundingMode: "trunc",
  trailingZeroDisplay: "auto"
});
var FixedDecimal = class _FixedDecimal {
  /**
   * Constructs a {@link FixedDecimal}.
   *
   * If `decimalPlaces` is not specified, the number of decimals is inferred.
   *
   * If `value` is a {@link FixedDecimal}, converts to the new amount of
   * decimals, changing precision. Precision data loss may occur.
   *
   * @param value The value to be represented.
   * @param decimalPlaces The number of decimal places the value has.
   */
  constructor(value, decimalPlaces, defaultFormatOptions = {}) {
    __publicField(this, "value");
    __publicField(this, "decimalPlaces");
    __publicField(this, "_defaultFormatOptions");
    switch (typeof value) {
      case "number": {
        if (!Number.isFinite(value)) {
          throw new Error("Number must be finite");
        }
        if (value.toString() === value.toExponential()) {
          throw new Error("Number must not be in scientific notation");
        }
        const parsed = parseFixedDecimalString(value.toString(), decimalPlaces);
        this.value = parsed.value;
        this.decimalPlaces = parsed.decimalPlaces;
        break;
      }
      case "string": {
        const parsed = parseFixedDecimalString(value, decimalPlaces);
        this.value = parsed.value;
        this.decimalPlaces = parsed.decimalPlaces;
        break;
      }
      case "object": {
        if (value instanceof _FixedDecimal) {
          const parsed = parseFixedDecimalString(value.toString(), decimalPlaces);
          this.value = parsed.value;
          this.decimalPlaces = parsed.decimalPlaces;
        } else if ("value" in value) {
          this.value = value.value;
          this.decimalPlaces = value.decimalPlaces;
        } else {
          throw new Error("Invalid object type for FixedDecimal constructor");
        }
        break;
      }
      default:
        this.value = value;
        this.decimalPlaces = decimalPlaces ?? 0;
    }
    this._defaultFormatOptions = {
      ...getDefaultFormatOptions(this),
      ...defaultFormatOptions
    };
  }
  /**
   * Math.ceil() but for {@link FixedDecimal}.
   * @param decimalPlaces The number of decimal places ceil to.
   * @returns A new {@link FixedDecimal} with the result for chaining.
   */
  ceil(decimalPlaces) {
    const digits = this.decimalPlaces - (decimalPlaces ?? 0);
    return this._ceil(digits);
  }
  _ceil(digitsToRemove) {
    if (digitsToRemove < 0) {
      throw new RangeError("Digits must be non-negative");
    }
    const divisor = BigInt(10 ** digitsToRemove);
    const bump = this.value % divisor > 0 ? BigInt(1) : BigInt(0);
    return new _FixedDecimal({
      value: (this.value / divisor + bump) * divisor,
      decimalPlaces: this.decimalPlaces
    });
  }
  /**
   * Math.floor() but for {@link FixedDecimal}.
   * @param decimalPlaces The number of decimal places to floor to.
   * @returns A new {@link FixedDecimal} with the result for chaining.
   */
  floor(decimalPlaces) {
    const digits = this.decimalPlaces - (decimalPlaces ?? 0);
    return this._floor(digits);
  }
  _floor(digitsToRemove) {
    if (digitsToRemove < 0) {
      throw new RangeError("Digits must be non-negative");
    }
    const divisor = BigInt(10 ** digitsToRemove);
    if (this.value < 0 && this.value % divisor !== BigInt(0)) {
      return new _FixedDecimal({
        value: this.value / divisor * divisor - divisor,
        decimalPlaces: this.decimalPlaces
      });
    }
    return new _FixedDecimal({
      value: this.value / divisor * divisor,
      decimalPlaces: this.decimalPlaces
    });
  }
  /**
   * Math.trunc() but for {@link FixedDecimal}.
   * @param decimalPlaces The number of decimal places to truncate to.
   * @returns A new {@link FixedDecimal} with the result for chaining.
   */
  trunc(decimalPlaces) {
    const digits = this.decimalPlaces - (decimalPlaces ?? 0);
    return this._trunc(digits);
  }
  _trunc(digitsToRemove) {
    if (digitsToRemove < 0) {
      throw new RangeError("Digits must be non-negative");
    }
    const divisor = BigInt(10 ** digitsToRemove);
    return new _FixedDecimal({
      value: this.value / divisor * divisor,
      decimalPlaces: this.decimalPlaces
    });
  }
  /**
   * Math.round() but for {@link FixedDecimal}.
   * @param decimalPlaces The number of decimal places to round to.
   * @returns A new {@link FixedDecimal} with the result for chaining.
   */
  round(decimalPlaces) {
    const digits = this.decimalPlaces - (decimalPlaces ?? 0);
    return this._round(digits);
  }
  _round(digitsToRemove) {
    if (digitsToRemove < 0) {
      throw new RangeError("Digits must be non-negative");
    }
    const signMultiplier = this.value > 0 ? BigInt(1) : BigInt(-1);
    const divisor = BigInt(10 ** (digitsToRemove - 1));
    let quotient = this.value / divisor;
    quotient += signMultiplier * BigInt(5);
    quotient /= BigInt(10);
    return new _FixedDecimal({
      value: quotient * divisor * BigInt(10),
      decimalPlaces: this.decimalPlaces
    });
  }
  /**
   * Rounds away from zero. (Opposite of trunc())
   * @param decimalPlaces The number of decimal places to round to.
   * @returns A new {@link FixedDecimal} with the result for chaining.
   */
  expand(decimalPlaces) {
    const digits = this.decimalPlaces - (decimalPlaces ?? 0);
    return this._expand(digits);
  }
  _expand(digitsToRemove) {
    if (digitsToRemove < 0) {
      throw new RangeError("Digits must be non-negative");
    }
    const divisor = BigInt(10 ** digitsToRemove);
    const remainder = this.value % divisor;
    if (remainder === BigInt(0)) {
      return this;
    }
    const signMultiplier = this.value > 0 ? BigInt(1) : BigInt(-1);
    return new _FixedDecimal({
      value: this.value / divisor * divisor + divisor * signMultiplier,
      decimalPlaces: this.decimalPlaces
    });
  }
  /**
   * Number.toPrecision() but for {@link FixedDecimal}.
   * @param significantDigits The number of significant digits to keep.
   * @returns The number truncated to the significant digits specified as a string.
   */
  toPrecision(significantDigits) {
    const signOffset = this.value < 0 ? 1 : 0;
    const digitsToRemove = this.value.toString().length - significantDigits - signOffset;
    const hasDecimalPoint = this.decimalPlaces > 0;
    const addDecimalPoint = !hasDecimalPoint && digitsToRemove < 0;
    const decimalOffset = hasDecimalPoint || addDecimalPoint ? 1 : 0;
    const str2 = this._trunc(Math.max(digitsToRemove, 0)).toString();
    return `${str2}${addDecimalPoint ? "." : ""}`.padEnd(significantDigits + decimalOffset + signOffset, "0");
  }
  /**
   * Number.toFixed() but for {@link FixedDecimal}.
   * @param decimalPlaces The number of decimal places to show.
   * @returns The number rounded to the decimal places specifed as a string.
   */
  toFixed(decimalPlaces) {
    const decimalCount = decimalPlaces ?? 0;
    if (decimalCount < 0) {
      throw new RangeError("decimalPlaces must be non-negative");
    }
    const d = decimalCount > this.decimalPlaces ? this : this.round(decimalCount);
    const [whole, decimalOrUndefined] = d.toString().split(".");
    const decimal = (decimalOrUndefined ?? "").padEnd(decimalCount + 1, "0");
    const decimalTruncated = decimal.substring(0, decimalCount);
    return decimalCount > 0 ? `${whole}.${decimalTruncated}` : whole;
  }
  /**
   * Represents the {@link FixedDecimal} as a fixed decimal string by inserting the
   * decimal point in the appropriate spot and padding any needed zeros.
   *
   * Not to be used for UI purposes.
   *
   * @see {@link toLocaleString} for UI appropriate strings.
   */
  toString() {
    const str2 = this.value.toString().replace("-", "").padStart(this.decimalPlaces + 1, "0");
    return `${this.value < 0 ? "-" : ""}${this.decimalPlaces > 0 ? `${str2.substring(0, str2.length - this.decimalPlaces)}.${str2.substring(str2.length - this.decimalPlaces)}` : str2}`;
  }
  /**
   * Analogous to Number().toLocaleString(), with some important differences in
   * the options available and the defaults. Be sure to check the defaults.
   * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/NumberFormat/NumberFormat Mozilla NumberFormat documentation}
   *
   * @param locale The string specifying the locale (default is 'en-US').
   * @param options The options for formatting. The available options and defaults are different than NumberFormat.
   */
  toLocaleString(locale, options) {
    const mergedOptions = {
      ...this._defaultFormatOptions,
      ...options
    };
    let str2 = "";
    switch (mergedOptions.roundingMode) {
      case "ceil":
        str2 = this.ceil(mergedOptions.maximumFractionDigits).toString();
        break;
      case "floor":
        str2 = this.floor(mergedOptions.maximumFractionDigits).toString();
        break;
      case "trunc":
        str2 = this.trunc(mergedOptions.maximumFractionDigits).toString();
        break;
      case "halfExpand":
        str2 = this.round(mergedOptions.maximumFractionDigits).toString();
        break;
      case "expand":
        str2 = this.expand(mergedOptions.maximumFractionDigits).toString();
        break;
    }
    let [whole, decimal] = str2.split(".");
    decimal = (decimal ?? "").replace(/0+$/, "");
    if (mergedOptions.minimumFractionDigits !== void 0) {
      if (mergedOptions.trailingZeroDisplay !== "stripIfInteger" || BigInt(decimal) !== BigInt(0)) {
        decimal = decimal.padEnd(mergedOptions.minimumFractionDigits, "0");
      }
    }
    const wholeInt = BigInt(whole.replace("-", ""));
    whole = wholeInt.toLocaleString(locale, {
      ...mergedOptions,
      minimumFractionDigits: 0,
      maximumFractionDigits: 0
    });
    const decimalSeparator = Number(0).toLocaleString(locale, {
      minimumFractionDigits: 1,
      maximumFractionDigits: 1
    })[1];
    return (this.value < 0 ? "-" : "") + (decimal.length > 0 ? `${whole}${decimalSeparator}${decimal}` : whole);
  }
  /**
   * Formats the decimal as an easy-to-read shorthand summary.
   * Used primarily for balances in tiles and headers.
   *
   * - Always truncates, never rounds up. (eg. `1.9999 => "1.99"`)
   * - Don't show decimal places if they'd appear as 0. (eg. `1.00234 => "1"`)
   * - Shows two decimal places if they'd be non-zero. (eg. `1.234 => "1.23"`)
   * - Count by 1,000s if over 10k (eg. `25413 => "25k"`)
   *
   * @example
   * new FixedDecimal(0, 5).toShorthand() // "0"
   * new FixedDecimal(8, 5).toShorthand() // "8"
   * new FixedDecimal(8.01, 5).toShorthand() // "8.01"
   * new FixedDecimal(8.1, 5).toShorthand() // "8.10"
   * new FixedDecimal(4210, 5).toShorthand() // "4210"
   * new FixedDecimal(9999.99, 5).toShorthand() // "9999.99"
   * new FixedDecimal(56001.43, 5).toShorthand() // "56K"
   * new FixedDecimal(443123.23, 5).toShorthand() // "443K"
   */
  toShorthand() {
    if (this.value === BigInt(0)) {
      return "0";
    }
    const signMultiplier = this.value > 0 ? BigInt(1) : BigInt(-1);
    const divisor = BigInt(10 ** this.decimalPlaces);
    const quotient = this.value / divisor;
    if (quotient * signMultiplier >= 1e4) {
      return `${quotient / BigInt(1e3)}K`;
    } else if (this.value % divisor === BigInt(0)) {
      return quotient.toString();
    } else {
      const amountString = this.value.toString().padStart(this.decimalPlaces, "0");
      const decimalStart = amountString.length - this.decimalPlaces;
      const decimal = amountString.substring(decimalStart, decimalStart + 2);
      if (decimal === "00") {
        return quotient.toString();
      }
      return `${quotient}.${decimal}`;
    }
  }
};

// node_modules/@audius/fixed-decimal/dist/esm/currencies.js
var createTokenConstructor = (decimalPlaces, defaultFormatOptions) => (value) => new FixedDecimal(value, decimalPlaces, defaultFormatOptions);
var AUDIO = createTokenConstructor(18);
var wAUDIO = createTokenConstructor(8);
var SOL = createTokenConstructor(9);
var USDC = createTokenConstructor(6, {
  style: "currency",
  currency: "USD",
  currencyDisplay: "narrowSymbol",
  minimumFractionDigits: 2,
  maximumFractionDigits: 2
});
var BONK = createTokenConstructor(5);

// node_modules/@audius/sdk/dist/index.browser.esm.js
var import_lodash = __toESM(require_lodash());
var import_snakecase_keys = __toESM(require_snakecase_keys());

// node_modules/hashids/esm/util.js
var keepUnique = (content) => [
  ...new Set(content)
];
var withoutChars = (chars, charsToExclude) => chars.filter((char) => !charsToExclude.includes(char));
var onlyChars = (chars, keepChars) => chars.filter((char) => keepChars.includes(char));
var isIntegerNumber = (n) => typeof n === "bigint" || !Number.isNaN(Number(n)) && Math.floor(Number(n)) === n;
var isPositiveAndFinite = (n) => typeof n === "bigint" || n >= 0 && Number.isSafeInteger(n);
function shuffle(alphabetChars, saltChars) {
  if (saltChars.length === 0) {
    return alphabetChars;
  }
  let integer;
  const transformed = [...alphabetChars];
  for (let i = transformed.length - 1, v = 0, p = 0; i > 0; i--, v++) {
    v %= saltChars.length;
    p += integer = saltChars[v].codePointAt(0);
    const j = (integer + v + p) % i;
    const a = transformed[i];
    const b = transformed[j];
    transformed[j] = a;
    transformed[i] = b;
  }
  return transformed;
}
var toAlphabet = (input, alphabetChars) => {
  const id = [];
  let value = input;
  if (typeof value === "bigint") {
    const alphabetLength = BigInt(alphabetChars.length);
    do {
      id.unshift(alphabetChars[Number(value % alphabetLength)]);
      value /= alphabetLength;
    } while (value > BigInt(0));
  } else {
    do {
      id.unshift(alphabetChars[value % alphabetChars.length]);
      value = Math.floor(value / alphabetChars.length);
    } while (value > 0);
  }
  return id;
};
var fromAlphabet = (inputChars, alphabetChars) => inputChars.reduce((carry, item) => {
  const index4 = alphabetChars.indexOf(item);
  if (index4 === -1) {
    throw new Error(`The provided ID (${inputChars.join("")}) is invalid, as it contains characters that do not exist in the alphabet (${alphabetChars.join("")})`);
  }
  if (typeof carry === "bigint") {
    return carry * BigInt(alphabetChars.length) + BigInt(index4);
  }
  const value = carry * alphabetChars.length + index4;
  const isSafeValue = Number.isSafeInteger(value);
  if (isSafeValue) {
    return value;
  }
  if (typeof BigInt === "function") {
    return BigInt(carry) * BigInt(alphabetChars.length) + BigInt(index4);
  }
  throw new Error(`Unable to decode the provided string, due to lack of support for BigInt numbers in the current environment`);
}, 0);
var safeToParseNumberRegExp = /^\+?\d+$/;
var safeParseInt10 = (str2) => safeToParseNumberRegExp.test(str2) ? Number.parseInt(str2, 10) : Number.NaN;
var splitAtIntervalAndMap = (str2, nth, map) => Array.from({ length: Math.ceil(str2.length / nth) }, (_, index4) => map(str2.slice(index4 * nth, (index4 + 1) * nth)));
var makeAnyOfCharsRegExp = (chars) => new RegExp(chars.map((char) => escapeRegExp(char)).sort((a, b) => b.length - a.length).join("|"));
var makeAtLeastSomeCharRegExp = (chars) => new RegExp(`^[${chars.map((char) => escapeRegExp(char)).sort((a, b) => b.length - a.length).join("")}]+$`);
var escapeRegExp = (text) => text.replace(/[\s#$()*+,.?[\\\]^{|}-]/g, "\\$&");

// node_modules/hashids/esm/hashids.js
var MIN_ALPHABET_LENGTH = 16;
var SEPARATOR_DIV = 3.5;
var GUARD_DIV = 12;
var HEXADECIMAL = 16;
var SPLIT_AT_EVERY_NTH = 12;
var MODULO_PART = 100;
var Hashids = class {
  constructor(salt = "", minLength = 0, alphabet2 = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890", seps = "cfhistuCFHISTU") {
    this.minLength = minLength;
    if (typeof minLength !== "number") {
      throw new TypeError(`Hashids: Provided 'minLength' has to be a number (is ${typeof minLength})`);
    }
    if (typeof salt !== "string") {
      throw new TypeError(`Hashids: Provided 'salt' has to be a string (is ${typeof salt})`);
    }
    if (typeof alphabet2 !== "string") {
      throw new TypeError(`Hashids: Provided alphabet has to be a string (is ${typeof alphabet2})`);
    }
    const saltChars = Array.from(salt);
    const alphabetChars = Array.from(alphabet2);
    const sepsChars = Array.from(seps);
    this.salt = saltChars;
    const uniqueAlphabet = keepUnique(alphabetChars);
    if (uniqueAlphabet.length < MIN_ALPHABET_LENGTH) {
      throw new Error(`Hashids: alphabet must contain at least ${MIN_ALPHABET_LENGTH} unique characters, provided: ${uniqueAlphabet.join("")}`);
    }
    this.alphabet = withoutChars(uniqueAlphabet, sepsChars);
    const filteredSeps = onlyChars(sepsChars, uniqueAlphabet);
    this.seps = shuffle(filteredSeps, saltChars);
    let sepsLength;
    let diff;
    if (this.seps.length === 0 || this.alphabet.length / this.seps.length > SEPARATOR_DIV) {
      sepsLength = Math.ceil(this.alphabet.length / SEPARATOR_DIV);
      if (sepsLength > this.seps.length) {
        diff = sepsLength - this.seps.length;
        this.seps.push(...this.alphabet.slice(0, diff));
        this.alphabet = this.alphabet.slice(diff);
      }
    }
    this.alphabet = shuffle(this.alphabet, saltChars);
    const guardCount = Math.ceil(this.alphabet.length / GUARD_DIV);
    if (this.alphabet.length < 3) {
      this.guards = this.seps.slice(0, guardCount);
      this.seps = this.seps.slice(guardCount);
    } else {
      this.guards = this.alphabet.slice(0, guardCount);
      this.alphabet = this.alphabet.slice(guardCount);
    }
    this.guardsRegExp = makeAnyOfCharsRegExp(this.guards);
    this.sepsRegExp = makeAnyOfCharsRegExp(this.seps);
    this.allowedCharsRegExp = makeAtLeastSomeCharRegExp([
      ...this.alphabet,
      ...this.guards,
      ...this.seps
    ]);
  }
  encode(first, ...inputNumbers) {
    const ret = "";
    let numbers = Array.isArray(first) ? first : [...first != null ? [first] : [], ...inputNumbers];
    if (numbers.length === 0) {
      return ret;
    }
    if (!numbers.every(isIntegerNumber)) {
      numbers = numbers.map((n) => typeof n === "bigint" || typeof n === "number" ? n : safeParseInt10(String(n)));
    }
    if (!numbers.every(isPositiveAndFinite)) {
      return ret;
    }
    return this._encode(numbers).join("");
  }
  decode(id) {
    if (!id || typeof id !== "string" || id.length === 0)
      return [];
    return this._decode(id);
  }
  /**
   * @description Splits a hex string into groups of 12-digit hexadecimal numbers,
   * then prefixes each with '1' and encodes the resulting array of numbers
   *
   * Encoding '00000000000f00000000000f000f' would be the equivalent of:
   * Hashids.encode([0x100000000000f, 0x100000000000f, 0x1000f])
   *
   * This means that if your environment supports BigInts,
   * you will get different (shorter) results if you provide
   * a BigInt representation of your hex and use `encode` directly, e.g.:
   * Hashids.encode(BigInt(`0x${hex}`))
   *
   * To decode such a representation back to a hex string, use the following snippet:
   * Hashids.decode(id)[0].toString(16)
   */
  encodeHex(inputHex) {
    let hex3 = inputHex;
    switch (typeof hex3) {
      case "bigint":
        hex3 = hex3.toString(HEXADECIMAL);
        break;
      case "string":
        if (!/^[\dA-Fa-f]+$/.test(hex3))
          return "";
        break;
      default:
        throw new Error(`Hashids: The provided value is neither a string, nor a BigInt (got: ${typeof hex3})`);
    }
    const numbers = splitAtIntervalAndMap(hex3, SPLIT_AT_EVERY_NTH, (part) => Number.parseInt(`1${part}`, 16));
    return this.encode(numbers);
  }
  decodeHex(id) {
    return this.decode(id).map((number5) => number5.toString(HEXADECIMAL).slice(1)).join("");
  }
  isValidId(id) {
    return this.allowedCharsRegExp.test(id);
  }
  _encode(numbers) {
    let { alphabet: alphabet2 } = this;
    const numbersIdInt = numbers.reduce((last, number5, i) => last + (typeof number5 === "bigint" ? Number(number5 % BigInt(i + MODULO_PART)) : number5 % (i + MODULO_PART)), 0);
    let ret = [alphabet2[numbersIdInt % alphabet2.length]];
    const lottery = [...ret];
    const { seps } = this;
    const { guards } = this;
    numbers.forEach((number5, i) => {
      const buffer3 = lottery.concat(this.salt, alphabet2);
      alphabet2 = shuffle(alphabet2, buffer3);
      const last = toAlphabet(number5, alphabet2);
      ret.push(...last);
      if (i + 1 < numbers.length) {
        const charCode = last[0].codePointAt(0) + i;
        const extraNumber = typeof number5 === "bigint" ? Number(number5 % BigInt(charCode)) : number5 % charCode;
        ret.push(seps[extraNumber % seps.length]);
      }
    });
    if (ret.length < this.minLength) {
      const prefixGuardIndex = (numbersIdInt + ret[0].codePointAt(0)) % guards.length;
      ret.unshift(guards[prefixGuardIndex]);
      if (ret.length < this.minLength) {
        const suffixGuardIndex = (numbersIdInt + ret[2].codePointAt(0)) % guards.length;
        ret.push(guards[suffixGuardIndex]);
      }
    }
    const halfLength = Math.floor(alphabet2.length / 2);
    while (ret.length < this.minLength) {
      alphabet2 = shuffle(alphabet2, alphabet2);
      ret.unshift(...alphabet2.slice(halfLength));
      ret.push(...alphabet2.slice(0, halfLength));
      const excess = ret.length - this.minLength;
      if (excess > 0) {
        const halfOfExcess = excess / 2;
        ret = ret.slice(halfOfExcess, halfOfExcess + this.minLength);
      }
    }
    return ret;
  }
  _decode(id) {
    if (!this.isValidId(id)) {
      throw new Error(`The provided ID (${id}) is invalid, as it contains characters that do not exist in the alphabet (${this.guards.join("")}${this.seps.join("")}${this.alphabet.join("")})`);
    }
    const idGuardsArray = id.split(this.guardsRegExp);
    const splitIndex = idGuardsArray.length === 3 || idGuardsArray.length === 2 ? 1 : 0;
    const idBreakdown = idGuardsArray[splitIndex];
    if (idBreakdown.length === 0)
      return [];
    const lotteryChar = idBreakdown[Symbol.iterator]().next().value;
    const idArray = idBreakdown.slice(lotteryChar.length).split(this.sepsRegExp);
    let lastAlphabet = this.alphabet;
    const result = [];
    for (const subId of idArray) {
      const buffer3 = [lotteryChar, ...this.salt, ...lastAlphabet];
      const nextAlphabet = shuffle(lastAlphabet, buffer3.slice(0, lastAlphabet.length));
      result.push(fromAlphabet(Array.from(subId), nextAlphabet));
      lastAlphabet = nextAlphabet;
    }
    if (this._encode(result).join("") !== id)
      return [];
    return result;
  }
};

// node_modules/@audius/sdk/dist/index.browser.esm.js
var import_async_retry = __toESM(require_lib());
var fileType2 = __toESM(require_file_type());
init_index_browser_esm();

// node_modules/@audius/spl/dist/esm/claimable-tokens/ClaimableTokensProgram.js
var import_buffer_layout52 = __toESM(require_Layout());

// node_modules/@solana/buffer-layout-utils/lib/esm/base.mjs
var encodeDecode = (layout) => {
  const decode4 = layout.decode.bind(layout);
  const encode4 = layout.encode.bind(layout);
  return { decode: decode4, encode: encode4 };
};

// node_modules/@solana/buffer-layout-utils/lib/esm/bigint.mjs
var import_buffer_layout2 = __toESM(require_Layout(), 1);
var import_bigint_buffer = __toESM(require_browser2(), 1);
var bigInt = (length2) => (property) => {
  const layout = (0, import_buffer_layout2.blob)(length2, property);
  const { encode: encode4, decode: decode4 } = encodeDecode(layout);
  const bigIntLayout = layout;
  bigIntLayout.decode = (buffer3, offset3) => {
    const src2 = decode4(buffer3, offset3);
    return (0, import_bigint_buffer.toBigIntLE)(Buffer.from(src2));
  };
  bigIntLayout.encode = (bigInt2, buffer3, offset3) => {
    const src2 = (0, import_bigint_buffer.toBufferLE)(bigInt2, length2);
    return encode4(src2, buffer3, offset3);
  };
  return bigIntLayout;
};
var bigIntBE = (length2) => (property) => {
  const layout = (0, import_buffer_layout2.blob)(length2, property);
  const { encode: encode4, decode: decode4 } = encodeDecode(layout);
  const bigIntLayout = layout;
  bigIntLayout.decode = (buffer3, offset3) => {
    const src2 = decode4(buffer3, offset3);
    return (0, import_bigint_buffer.toBigIntBE)(Buffer.from(src2));
  };
  bigIntLayout.encode = (bigInt2, buffer3, offset3) => {
    const src2 = (0, import_bigint_buffer.toBufferBE)(bigInt2, length2);
    return encode4(src2, buffer3, offset3);
  };
  return bigIntLayout;
};
var u642 = bigInt(8);
var u64be = bigIntBE(8);
var u128 = bigInt(16);
var u128be = bigIntBE(16);
var u192 = bigInt(24);
var u192be = bigIntBE(24);
var u256 = bigInt(32);
var u256be = bigIntBE(32);

// node_modules/bignumber.js/bignumber.mjs
var isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i;
var mathceil = Math.ceil;
var mathfloor = Math.floor;
var bignumberError = "[BigNumber Error] ";
var tooManyDigits = bignumberError + "Number primitive has more than 15 significant digits: ";
var BASE = 1e14;
var LOG_BASE = 14;
var MAX_SAFE_INTEGER = 9007199254740991;
var POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13];
var SQRT_BASE = 1e7;
var MAX = 1e9;
function clone(configObject) {
  var div, convertBase, parseNumeric, P = BigNumber2.prototype = { constructor: BigNumber2, toString: null, valueOf: null }, ONE = new BigNumber2(1), DECIMAL_PLACES = 20, ROUNDING_MODE = 4, TO_EXP_NEG = -7, TO_EXP_POS = 21, MIN_EXP = -1e7, MAX_EXP = 1e7, CRYPTO = false, MODULO_MODE = 1, POW_PRECISION = 0, FORMAT = {
    prefix: "",
    groupSize: 3,
    secondaryGroupSize: 0,
    groupSeparator: ",",
    decimalSeparator: ".",
    fractionGroupSize: 0,
    fractionGroupSeparator: " ",
    // non-breaking space
    suffix: ""
  }, ALPHABET2 = "0123456789abcdefghijklmnopqrstuvwxyz", alphabetHasNormalDecimalDigits = true;
  function BigNumber2(v, b) {
    var alphabet2, c, caseChanged, e, i, isNum, len, str2, x = this;
    if (!(x instanceof BigNumber2)) return new BigNumber2(v, b);
    if (b == null) {
      if (v && v._isBigNumber === true) {
        x.s = v.s;
        if (!v.c || v.e > MAX_EXP) {
          x.c = x.e = null;
        } else if (v.e < MIN_EXP) {
          x.c = [x.e = 0];
        } else {
          x.e = v.e;
          x.c = v.c.slice();
        }
        return;
      }
      if ((isNum = typeof v == "number") && v * 0 == 0) {
        x.s = 1 / v < 0 ? (v = -v, -1) : 1;
        if (v === ~~v) {
          for (e = 0, i = v; i >= 10; i /= 10, e++) ;
          if (e > MAX_EXP) {
            x.c = x.e = null;
          } else {
            x.e = e;
            x.c = [v];
          }
          return;
        }
        str2 = String(v);
      } else {
        if (!isNumeric.test(str2 = String(v))) return parseNumeric(x, str2, isNum);
        x.s = str2.charCodeAt(0) == 45 ? (str2 = str2.slice(1), -1) : 1;
      }
      if ((e = str2.indexOf(".")) > -1) str2 = str2.replace(".", "");
      if ((i = str2.search(/e/i)) > 0) {
        if (e < 0) e = i;
        e += +str2.slice(i + 1);
        str2 = str2.substring(0, i);
      } else if (e < 0) {
        e = str2.length;
      }
    } else {
      intCheck(b, 2, ALPHABET2.length, "Base");
      if (b == 10 && alphabetHasNormalDecimalDigits) {
        x = new BigNumber2(v);
        return round(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);
      }
      str2 = String(v);
      if (isNum = typeof v == "number") {
        if (v * 0 != 0) return parseNumeric(x, str2, isNum, b);
        x.s = 1 / v < 0 ? (str2 = str2.slice(1), -1) : 1;
        if (BigNumber2.DEBUG && str2.replace(/^0\.0*|\./, "").length > 15) {
          throw Error(tooManyDigits + v);
        }
      } else {
        x.s = str2.charCodeAt(0) === 45 ? (str2 = str2.slice(1), -1) : 1;
      }
      alphabet2 = ALPHABET2.slice(0, b);
      e = i = 0;
      for (len = str2.length; i < len; i++) {
        if (alphabet2.indexOf(c = str2.charAt(i)) < 0) {
          if (c == ".") {
            if (i > e) {
              e = len;
              continue;
            }
          } else if (!caseChanged) {
            if (str2 == str2.toUpperCase() && (str2 = str2.toLowerCase()) || str2 == str2.toLowerCase() && (str2 = str2.toUpperCase())) {
              caseChanged = true;
              i = -1;
              e = 0;
              continue;
            }
          }
          return parseNumeric(x, String(v), isNum, b);
        }
      }
      isNum = false;
      str2 = convertBase(str2, b, 10, x.s);
      if ((e = str2.indexOf(".")) > -1) str2 = str2.replace(".", "");
      else e = str2.length;
    }
    for (i = 0; str2.charCodeAt(i) === 48; i++) ;
    for (len = str2.length; str2.charCodeAt(--len) === 48; ) ;
    if (str2 = str2.slice(i, ++len)) {
      len -= i;
      if (isNum && BigNumber2.DEBUG && len > 15 && (v > MAX_SAFE_INTEGER || v !== mathfloor(v))) {
        throw Error(tooManyDigits + x.s * v);
      }
      if ((e = e - i - 1) > MAX_EXP) {
        x.c = x.e = null;
      } else if (e < MIN_EXP) {
        x.c = [x.e = 0];
      } else {
        x.e = e;
        x.c = [];
        i = (e + 1) % LOG_BASE;
        if (e < 0) i += LOG_BASE;
        if (i < len) {
          if (i) x.c.push(+str2.slice(0, i));
          for (len -= LOG_BASE; i < len; ) {
            x.c.push(+str2.slice(i, i += LOG_BASE));
          }
          i = LOG_BASE - (str2 = str2.slice(i)).length;
        } else {
          i -= len;
        }
        for (; i--; str2 += "0") ;
        x.c.push(+str2);
      }
    } else {
      x.c = [x.e = 0];
    }
  }
  BigNumber2.clone = clone;
  BigNumber2.ROUND_UP = 0;
  BigNumber2.ROUND_DOWN = 1;
  BigNumber2.ROUND_CEIL = 2;
  BigNumber2.ROUND_FLOOR = 3;
  BigNumber2.ROUND_HALF_UP = 4;
  BigNumber2.ROUND_HALF_DOWN = 5;
  BigNumber2.ROUND_HALF_EVEN = 6;
  BigNumber2.ROUND_HALF_CEIL = 7;
  BigNumber2.ROUND_HALF_FLOOR = 8;
  BigNumber2.EUCLID = 9;
  BigNumber2.config = BigNumber2.set = function(obj) {
    var p, v;
    if (obj != null) {
      if (typeof obj == "object") {
        if (obj.hasOwnProperty(p = "DECIMAL_PLACES")) {
          v = obj[p];
          intCheck(v, 0, MAX, p);
          DECIMAL_PLACES = v;
        }
        if (obj.hasOwnProperty(p = "ROUNDING_MODE")) {
          v = obj[p];
          intCheck(v, 0, 8, p);
          ROUNDING_MODE = v;
        }
        if (obj.hasOwnProperty(p = "EXPONENTIAL_AT")) {
          v = obj[p];
          if (v && v.pop) {
            intCheck(v[0], -MAX, 0, p);
            intCheck(v[1], 0, MAX, p);
            TO_EXP_NEG = v[0];
            TO_EXP_POS = v[1];
          } else {
            intCheck(v, -MAX, MAX, p);
            TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v);
          }
        }
        if (obj.hasOwnProperty(p = "RANGE")) {
          v = obj[p];
          if (v && v.pop) {
            intCheck(v[0], -MAX, -1, p);
            intCheck(v[1], 1, MAX, p);
            MIN_EXP = v[0];
            MAX_EXP = v[1];
          } else {
            intCheck(v, -MAX, MAX, p);
            if (v) {
              MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);
            } else {
              throw Error(bignumberError + p + " cannot be zero: " + v);
            }
          }
        }
        if (obj.hasOwnProperty(p = "CRYPTO")) {
          v = obj[p];
          if (v === !!v) {
            if (v) {
              if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
                CRYPTO = v;
              } else {
                CRYPTO = !v;
                throw Error(bignumberError + "crypto unavailable");
              }
            } else {
              CRYPTO = v;
            }
          } else {
            throw Error(bignumberError + p + " not true or false: " + v);
          }
        }
        if (obj.hasOwnProperty(p = "MODULO_MODE")) {
          v = obj[p];
          intCheck(v, 0, 9, p);
          MODULO_MODE = v;
        }
        if (obj.hasOwnProperty(p = "POW_PRECISION")) {
          v = obj[p];
          intCheck(v, 0, MAX, p);
          POW_PRECISION = v;
        }
        if (obj.hasOwnProperty(p = "FORMAT")) {
          v = obj[p];
          if (typeof v == "object") FORMAT = v;
          else throw Error(bignumberError + p + " not an object: " + v);
        }
        if (obj.hasOwnProperty(p = "ALPHABET")) {
          v = obj[p];
          if (typeof v == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(v)) {
            alphabetHasNormalDecimalDigits = v.slice(0, 10) == "0123456789";
            ALPHABET2 = v;
          } else {
            throw Error(bignumberError + p + " invalid: " + v);
          }
        }
      } else {
        throw Error(bignumberError + "Object expected: " + obj);
      }
    }
    return {
      DECIMAL_PLACES,
      ROUNDING_MODE,
      EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],
      RANGE: [MIN_EXP, MAX_EXP],
      CRYPTO,
      MODULO_MODE,
      POW_PRECISION,
      FORMAT,
      ALPHABET: ALPHABET2
    };
  };
  BigNumber2.isBigNumber = function(v) {
    if (!v || v._isBigNumber !== true) return false;
    if (!BigNumber2.DEBUG) return true;
    var i, n, c = v.c, e = v.e, s = v.s;
    out: if ({}.toString.call(c) == "[object Array]") {
      if ((s === 1 || s === -1) && e >= -MAX && e <= MAX && e === mathfloor(e)) {
        if (c[0] === 0) {
          if (e === 0 && c.length === 1) return true;
          break out;
        }
        i = (e + 1) % LOG_BASE;
        if (i < 1) i += LOG_BASE;
        if (String(c[0]).length == i) {
          for (i = 0; i < c.length; i++) {
            n = c[i];
            if (n < 0 || n >= BASE || n !== mathfloor(n)) break out;
          }
          if (n !== 0) return true;
        }
      }
    } else if (c === null && e === null && (s === null || s === 1 || s === -1)) {
      return true;
    }
    throw Error(bignumberError + "Invalid BigNumber: " + v);
  };
  BigNumber2.maximum = BigNumber2.max = function() {
    return maxOrMin(arguments, -1);
  };
  BigNumber2.minimum = BigNumber2.min = function() {
    return maxOrMin(arguments, 1);
  };
  BigNumber2.random = (function() {
    var pow2_53 = 9007199254740992;
    var random53bitInt = Math.random() * pow2_53 & 2097151 ? function() {
      return mathfloor(Math.random() * pow2_53);
    } : function() {
      return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
    };
    return function(dp) {
      var a, b, e, k, v, i = 0, c = [], rand = new BigNumber2(ONE);
      if (dp == null) dp = DECIMAL_PLACES;
      else intCheck(dp, 0, MAX);
      k = mathceil(dp / LOG_BASE);
      if (CRYPTO) {
        if (crypto.getRandomValues) {
          a = crypto.getRandomValues(new Uint32Array(k *= 2));
          for (; i < k; ) {
            v = a[i] * 131072 + (a[i + 1] >>> 11);
            if (v >= 9e15) {
              b = crypto.getRandomValues(new Uint32Array(2));
              a[i] = b[0];
              a[i + 1] = b[1];
            } else {
              c.push(v % 1e14);
              i += 2;
            }
          }
          i = k / 2;
        } else if (crypto.randomBytes) {
          a = crypto.randomBytes(k *= 7);
          for (; i < k; ) {
            v = (a[i] & 31) * 281474976710656 + a[i + 1] * 1099511627776 + a[i + 2] * 4294967296 + a[i + 3] * 16777216 + (a[i + 4] << 16) + (a[i + 5] << 8) + a[i + 6];
            if (v >= 9e15) {
              crypto.randomBytes(7).copy(a, i);
            } else {
              c.push(v % 1e14);
              i += 7;
            }
          }
          i = k / 7;
        } else {
          CRYPTO = false;
          throw Error(bignumberError + "crypto unavailable");
        }
      }
      if (!CRYPTO) {
        for (; i < k; ) {
          v = random53bitInt();
          if (v < 9e15) c[i++] = v % 1e14;
        }
      }
      k = c[--i];
      dp %= LOG_BASE;
      if (k && dp) {
        v = POWS_TEN[LOG_BASE - dp];
        c[i] = mathfloor(k / v) * v;
      }
      for (; c[i] === 0; c.pop(), i--) ;
      if (i < 0) {
        c = [e = 0];
      } else {
        for (e = -1; c[0] === 0; c.splice(0, 1), e -= LOG_BASE) ;
        for (i = 1, v = c[0]; v >= 10; v /= 10, i++) ;
        if (i < LOG_BASE) e -= LOG_BASE - i;
      }
      rand.e = e;
      rand.c = c;
      return rand;
    };
  })();
  BigNumber2.sum = function() {
    var i = 1, args = arguments, sum = new BigNumber2(args[0]);
    for (; i < args.length; ) sum = sum.plus(args[i++]);
    return sum;
  };
  convertBase = /* @__PURE__ */ (function() {
    var decimal = "0123456789";
    function toBaseOut(str2, baseIn, baseOut, alphabet2) {
      var j, arr = [0], arrL, i = 0, len = str2.length;
      for (; i < len; ) {
        for (arrL = arr.length; arrL--; arr[arrL] *= baseIn) ;
        arr[0] += alphabet2.indexOf(str2.charAt(i++));
        for (j = 0; j < arr.length; j++) {
          if (arr[j] > baseOut - 1) {
            if (arr[j + 1] == null) arr[j + 1] = 0;
            arr[j + 1] += arr[j] / baseOut | 0;
            arr[j] %= baseOut;
          }
        }
      }
      return arr.reverse();
    }
    return function(str2, baseIn, baseOut, sign4, callerIsToString) {
      var alphabet2, d, e, k, r, x, xc, y, i = str2.indexOf("."), dp = DECIMAL_PLACES, rm = ROUNDING_MODE;
      if (i >= 0) {
        k = POW_PRECISION;
        POW_PRECISION = 0;
        str2 = str2.replace(".", "");
        y = new BigNumber2(baseIn);
        x = y.pow(str2.length - i);
        POW_PRECISION = k;
        y.c = toBaseOut(
          toFixedPoint(coeffToString(x.c), x.e, "0"),
          10,
          baseOut,
          decimal
        );
        y.e = y.c.length;
      }
      xc = toBaseOut(str2, baseIn, baseOut, callerIsToString ? (alphabet2 = ALPHABET2, decimal) : (alphabet2 = decimal, ALPHABET2));
      e = k = xc.length;
      for (; xc[--k] == 0; xc.pop()) ;
      if (!xc[0]) return alphabet2.charAt(0);
      if (i < 0) {
        --e;
      } else {
        x.c = xc;
        x.e = e;
        x.s = sign4;
        x = div(x, y, dp, rm, baseOut);
        xc = x.c;
        r = x.r;
        e = x.e;
      }
      d = e + dp + 1;
      i = xc[d];
      k = baseOut / 2;
      r = r || d < 0 || xc[d + 1] != null;
      r = rm < 4 ? (i != null || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : i > k || i == k && (rm == 4 || r || rm == 6 && xc[d - 1] & 1 || rm == (x.s < 0 ? 8 : 7));
      if (d < 1 || !xc[0]) {
        str2 = r ? toFixedPoint(alphabet2.charAt(1), -dp, alphabet2.charAt(0)) : alphabet2.charAt(0);
      } else {
        xc.length = d;
        if (r) {
          for (--baseOut; ++xc[--d] > baseOut; ) {
            xc[d] = 0;
            if (!d) {
              ++e;
              xc = [1].concat(xc);
            }
          }
        }
        for (k = xc.length; !xc[--k]; ) ;
        for (i = 0, str2 = ""; i <= k; str2 += alphabet2.charAt(xc[i++])) ;
        str2 = toFixedPoint(str2, e, alphabet2.charAt(0));
      }
      return str2;
    };
  })();
  div = /* @__PURE__ */ (function() {
    function multiply(x, k, base3) {
      var m, temp, xlo, xhi, carry = 0, i = x.length, klo = k % SQRT_BASE, khi = k / SQRT_BASE | 0;
      for (x = x.slice(); i--; ) {
        xlo = x[i] % SQRT_BASE;
        xhi = x[i] / SQRT_BASE | 0;
        m = khi * xlo + xhi * klo;
        temp = klo * xlo + m % SQRT_BASE * SQRT_BASE + carry;
        carry = (temp / base3 | 0) + (m / SQRT_BASE | 0) + khi * xhi;
        x[i] = temp % base3;
      }
      if (carry) x = [carry].concat(x);
      return x;
    }
    function compare2(a, b, aL, bL) {
      var i, cmp;
      if (aL != bL) {
        cmp = aL > bL ? 1 : -1;
      } else {
        for (i = cmp = 0; i < aL; i++) {
          if (a[i] != b[i]) {
            cmp = a[i] > b[i] ? 1 : -1;
            break;
          }
        }
      }
      return cmp;
    }
    function subtract(a, b, aL, base3) {
      var i = 0;
      for (; aL--; ) {
        a[aL] -= i;
        i = a[aL] < b[aL] ? 1 : 0;
        a[aL] = i * base3 + a[aL] - b[aL];
      }
      for (; !a[0] && a.length > 1; a.splice(0, 1)) ;
    }
    return function(x, y, dp, rm, base3) {
      var cmp, e, i, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0, yL, yz, s = x.s == y.s ? 1 : -1, xc = x.c, yc = y.c;
      if (!xc || !xc[0] || !yc || !yc[0]) {
        return new BigNumber2(
          // Return NaN if either NaN, or both Infinity or 0.
          !x.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN : (
            // Return ±0 if x is ±0 or y is ±Infinity, or return ±Infinity as y is ±0.
            xc && xc[0] == 0 || !yc ? s * 0 : s / 0
          )
        );
      }
      q = new BigNumber2(s);
      qc = q.c = [];
      e = x.e - y.e;
      s = dp + e + 1;
      if (!base3) {
        base3 = BASE;
        e = bitFloor(x.e / LOG_BASE) - bitFloor(y.e / LOG_BASE);
        s = s / LOG_BASE | 0;
      }
      for (i = 0; yc[i] == (xc[i] || 0); i++) ;
      if (yc[i] > (xc[i] || 0)) e--;
      if (s < 0) {
        qc.push(1);
        more = true;
      } else {
        xL = xc.length;
        yL = yc.length;
        i = 0;
        s += 2;
        n = mathfloor(base3 / (yc[0] + 1));
        if (n > 1) {
          yc = multiply(yc, n, base3);
          xc = multiply(xc, n, base3);
          yL = yc.length;
          xL = xc.length;
        }
        xi = yL;
        rem = xc.slice(0, yL);
        remL = rem.length;
        for (; remL < yL; rem[remL++] = 0) ;
        yz = yc.slice();
        yz = [0].concat(yz);
        yc0 = yc[0];
        if (yc[1] >= base3 / 2) yc0++;
        do {
          n = 0;
          cmp = compare2(yc, rem, yL, remL);
          if (cmp < 0) {
            rem0 = rem[0];
            if (yL != remL) rem0 = rem0 * base3 + (rem[1] || 0);
            n = mathfloor(rem0 / yc0);
            if (n > 1) {
              if (n >= base3) n = base3 - 1;
              prod = multiply(yc, n, base3);
              prodL = prod.length;
              remL = rem.length;
              while (compare2(prod, rem, prodL, remL) == 1) {
                n--;
                subtract(prod, yL < prodL ? yz : yc, prodL, base3);
                prodL = prod.length;
                cmp = 1;
              }
            } else {
              if (n == 0) {
                cmp = n = 1;
              }
              prod = yc.slice();
              prodL = prod.length;
            }
            if (prodL < remL) prod = [0].concat(prod);
            subtract(rem, prod, remL, base3);
            remL = rem.length;
            if (cmp == -1) {
              while (compare2(yc, rem, yL, remL) < 1) {
                n++;
                subtract(rem, yL < remL ? yz : yc, remL, base3);
                remL = rem.length;
              }
            }
          } else if (cmp === 0) {
            n++;
            rem = [0];
          }
          qc[i++] = n;
          if (rem[0]) {
            rem[remL++] = xc[xi] || 0;
          } else {
            rem = [xc[xi]];
            remL = 1;
          }
        } while ((xi++ < xL || rem[0] != null) && s--);
        more = rem[0] != null;
        if (!qc[0]) qc.splice(0, 1);
      }
      if (base3 == BASE) {
        for (i = 1, s = qc[0]; s >= 10; s /= 10, i++) ;
        round(q, dp + (q.e = i + e * LOG_BASE - 1) + 1, rm, more);
      } else {
        q.e = e;
        q.r = +more;
      }
      return q;
    };
  })();
  function format2(n, i, rm, id) {
    var c0, e, ne, len, str2;
    if (rm == null) rm = ROUNDING_MODE;
    else intCheck(rm, 0, 8);
    if (!n.c) return n.toString();
    c0 = n.c[0];
    ne = n.e;
    if (i == null) {
      str2 = coeffToString(n.c);
      str2 = id == 1 || id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS) ? toExponential(str2, ne) : toFixedPoint(str2, ne, "0");
    } else {
      n = round(new BigNumber2(n), i, rm);
      e = n.e;
      str2 = coeffToString(n.c);
      len = str2.length;
      if (id == 1 || id == 2 && (i <= e || e <= TO_EXP_NEG)) {
        for (; len < i; str2 += "0", len++) ;
        str2 = toExponential(str2, e);
      } else {
        i -= ne + (id === 2 && e > ne);
        str2 = toFixedPoint(str2, e, "0");
        if (e + 1 > len) {
          if (--i > 0) for (str2 += "."; i--; str2 += "0") ;
        } else {
          i += e - len;
          if (i > 0) {
            if (e + 1 == len) str2 += ".";
            for (; i--; str2 += "0") ;
          }
        }
      }
    }
    return n.s < 0 && c0 ? "-" + str2 : str2;
  }
  function maxOrMin(args, n) {
    var k, y, i = 1, x = new BigNumber2(args[0]);
    for (; i < args.length; i++) {
      y = new BigNumber2(args[i]);
      if (!y.s || (k = compare(x, y)) === n || k === 0 && x.s === n) {
        x = y;
      }
    }
    return x;
  }
  function normalise(n, c, e) {
    var i = 1, j = c.length;
    for (; !c[--j]; c.pop()) ;
    for (j = c[0]; j >= 10; j /= 10, i++) ;
    if ((e = i + e * LOG_BASE - 1) > MAX_EXP) {
      n.c = n.e = null;
    } else if (e < MIN_EXP) {
      n.c = [n.e = 0];
    } else {
      n.e = e;
      n.c = c;
    }
    return n;
  }
  parseNumeric = /* @__PURE__ */ (function() {
    var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i, dotAfter = /^([^.]+)\.$/, dotBefore = /^\.([^.]+)$/, isInfinityOrNaN = /^-?(Infinity|NaN)$/, whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
    return function(x, str2, isNum, b) {
      var base3, s = isNum ? str2 : str2.replace(whitespaceOrPlus, "");
      if (isInfinityOrNaN.test(s)) {
        x.s = isNaN(s) ? null : s < 0 ? -1 : 1;
      } else {
        if (!isNum) {
          s = s.replace(basePrefix, function(m, p1, p2) {
            base3 = (p2 = p2.toLowerCase()) == "x" ? 16 : p2 == "b" ? 2 : 8;
            return !b || b == base3 ? p1 : m;
          });
          if (b) {
            base3 = b;
            s = s.replace(dotAfter, "$1").replace(dotBefore, "0.$1");
          }
          if (str2 != s) return new BigNumber2(s, base3);
        }
        if (BigNumber2.DEBUG) {
          throw Error(bignumberError + "Not a" + (b ? " base " + b : "") + " number: " + str2);
        }
        x.s = null;
      }
      x.c = x.e = null;
    };
  })();
  function round(x, sd, rm, r) {
    var d, i, j, k, n, ni, rd, xc = x.c, pows10 = POWS_TEN;
    if (xc) {
      out: {
        for (d = 1, k = xc[0]; k >= 10; k /= 10, d++) ;
        i = sd - d;
        if (i < 0) {
          i += LOG_BASE;
          j = sd;
          n = xc[ni = 0];
          rd = mathfloor(n / pows10[d - j - 1] % 10);
        } else {
          ni = mathceil((i + 1) / LOG_BASE);
          if (ni >= xc.length) {
            if (r) {
              for (; xc.length <= ni; xc.push(0)) ;
              n = rd = 0;
              d = 1;
              i %= LOG_BASE;
              j = i - LOG_BASE + 1;
            } else {
              break out;
            }
          } else {
            n = k = xc[ni];
            for (d = 1; k >= 10; k /= 10, d++) ;
            i %= LOG_BASE;
            j = i - LOG_BASE + d;
            rd = j < 0 ? 0 : mathfloor(n / pows10[d - j - 1] % 10);
          }
        }
        r = r || sd < 0 || // Are there any non-zero digits after the rounding digit?
        // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
        // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
        xc[ni + 1] != null || (j < 0 ? n : n % pows10[d - j - 1]);
        r = rm < 4 ? (rd || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || r || rm == 6 && // Check whether the digit to the left of the rounding digit is odd.
        (i > 0 ? j > 0 ? n / pows10[d - j] : 0 : xc[ni - 1]) % 10 & 1 || rm == (x.s < 0 ? 8 : 7));
        if (sd < 1 || !xc[0]) {
          xc.length = 0;
          if (r) {
            sd -= x.e + 1;
            xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];
            x.e = -sd || 0;
          } else {
            xc[0] = x.e = 0;
          }
          return x;
        }
        if (i == 0) {
          xc.length = ni;
          k = 1;
          ni--;
        } else {
          xc.length = ni + 1;
          k = pows10[LOG_BASE - i];
          xc[ni] = j > 0 ? mathfloor(n / pows10[d - j] % pows10[j]) * k : 0;
        }
        if (r) {
          for (; ; ) {
            if (ni == 0) {
              for (i = 1, j = xc[0]; j >= 10; j /= 10, i++) ;
              j = xc[0] += k;
              for (k = 1; j >= 10; j /= 10, k++) ;
              if (i != k) {
                x.e++;
                if (xc[0] == BASE) xc[0] = 1;
              }
              break;
            } else {
              xc[ni] += k;
              if (xc[ni] != BASE) break;
              xc[ni--] = 0;
              k = 1;
            }
          }
        }
        for (i = xc.length; xc[--i] === 0; xc.pop()) ;
      }
      if (x.e > MAX_EXP) {
        x.c = x.e = null;
      } else if (x.e < MIN_EXP) {
        x.c = [x.e = 0];
      }
    }
    return x;
  }
  function valueOf(n) {
    var str2, e = n.e;
    if (e === null) return n.toString();
    str2 = coeffToString(n.c);
    str2 = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(str2, e) : toFixedPoint(str2, e, "0");
    return n.s < 0 ? "-" + str2 : str2;
  }
  P.absoluteValue = P.abs = function() {
    var x = new BigNumber2(this);
    if (x.s < 0) x.s = 1;
    return x;
  };
  P.comparedTo = function(y, b) {
    return compare(this, new BigNumber2(y, b));
  };
  P.decimalPlaces = P.dp = function(dp, rm) {
    var c, n, v, x = this;
    if (dp != null) {
      intCheck(dp, 0, MAX);
      if (rm == null) rm = ROUNDING_MODE;
      else intCheck(rm, 0, 8);
      return round(new BigNumber2(x), dp + x.e + 1, rm);
    }
    if (!(c = x.c)) return null;
    n = ((v = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;
    if (v = c[v]) for (; v % 10 == 0; v /= 10, n--) ;
    if (n < 0) n = 0;
    return n;
  };
  P.dividedBy = P.div = function(y, b) {
    return div(this, new BigNumber2(y, b), DECIMAL_PLACES, ROUNDING_MODE);
  };
  P.dividedToIntegerBy = P.idiv = function(y, b) {
    return div(this, new BigNumber2(y, b), 0, 1);
  };
  P.exponentiatedBy = P.pow = function(n, m) {
    var half, isModExp, i, k, more, nIsBig, nIsNeg, nIsOdd, y, x = this;
    n = new BigNumber2(n);
    if (n.c && !n.isInteger()) {
      throw Error(bignumberError + "Exponent not an integer: " + valueOf(n));
    }
    if (m != null) m = new BigNumber2(m);
    nIsBig = n.e > 14;
    if (!x.c || !x.c[0] || x.c[0] == 1 && !x.e && x.c.length == 1 || !n.c || !n.c[0]) {
      y = new BigNumber2(Math.pow(+valueOf(x), nIsBig ? n.s * (2 - isOdd(n)) : +valueOf(n)));
      return m ? y.mod(m) : y;
    }
    nIsNeg = n.s < 0;
    if (m) {
      if (m.c ? !m.c[0] : !m.s) return new BigNumber2(NaN);
      isModExp = !nIsNeg && x.isInteger() && m.isInteger();
      if (isModExp) x = x.mod(m);
    } else if (n.e > 9 && (x.e > 0 || x.e < -1 || (x.e == 0 ? x.c[0] > 1 || nIsBig && x.c[1] >= 24e7 : x.c[0] < 8e13 || nIsBig && x.c[0] <= 9999975e7))) {
      k = x.s < 0 && isOdd(n) ? -0 : 0;
      if (x.e > -1) k = 1 / k;
      return new BigNumber2(nIsNeg ? 1 / k : k);
    } else if (POW_PRECISION) {
      k = mathceil(POW_PRECISION / LOG_BASE + 2);
    }
    if (nIsBig) {
      half = new BigNumber2(0.5);
      if (nIsNeg) n.s = 1;
      nIsOdd = isOdd(n);
    } else {
      i = Math.abs(+valueOf(n));
      nIsOdd = i % 2;
    }
    y = new BigNumber2(ONE);
    for (; ; ) {
      if (nIsOdd) {
        y = y.times(x);
        if (!y.c) break;
        if (k) {
          if (y.c.length > k) y.c.length = k;
        } else if (isModExp) {
          y = y.mod(m);
        }
      }
      if (i) {
        i = mathfloor(i / 2);
        if (i === 0) break;
        nIsOdd = i % 2;
      } else {
        n = n.times(half);
        round(n, n.e + 1, 1);
        if (n.e > 14) {
          nIsOdd = isOdd(n);
        } else {
          i = +valueOf(n);
          if (i === 0) break;
          nIsOdd = i % 2;
        }
      }
      x = x.times(x);
      if (k) {
        if (x.c && x.c.length > k) x.c.length = k;
      } else if (isModExp) {
        x = x.mod(m);
      }
    }
    if (isModExp) return y;
    if (nIsNeg) y = ONE.div(y);
    return m ? y.mod(m) : k ? round(y, POW_PRECISION, ROUNDING_MODE, more) : y;
  };
  P.integerValue = function(rm) {
    var n = new BigNumber2(this);
    if (rm == null) rm = ROUNDING_MODE;
    else intCheck(rm, 0, 8);
    return round(n, n.e + 1, rm);
  };
  P.isEqualTo = P.eq = function(y, b) {
    return compare(this, new BigNumber2(y, b)) === 0;
  };
  P.isFinite = function() {
    return !!this.c;
  };
  P.isGreaterThan = P.gt = function(y, b) {
    return compare(this, new BigNumber2(y, b)) > 0;
  };
  P.isGreaterThanOrEqualTo = P.gte = function(y, b) {
    return (b = compare(this, new BigNumber2(y, b))) === 1 || b === 0;
  };
  P.isInteger = function() {
    return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
  };
  P.isLessThan = P.lt = function(y, b) {
    return compare(this, new BigNumber2(y, b)) < 0;
  };
  P.isLessThanOrEqualTo = P.lte = function(y, b) {
    return (b = compare(this, new BigNumber2(y, b))) === -1 || b === 0;
  };
  P.isNaN = function() {
    return !this.s;
  };
  P.isNegative = function() {
    return this.s < 0;
  };
  P.isPositive = function() {
    return this.s > 0;
  };
  P.isZero = function() {
    return !!this.c && this.c[0] == 0;
  };
  P.minus = function(y, b) {
    var i, j, t, xLTy, x = this, a = x.s;
    y = new BigNumber2(y, b);
    b = y.s;
    if (!a || !b) return new BigNumber2(NaN);
    if (a != b) {
      y.s = -b;
      return x.plus(y);
    }
    var xe = x.e / LOG_BASE, ye = y.e / LOG_BASE, xc = x.c, yc = y.c;
    if (!xe || !ye) {
      if (!xc || !yc) return xc ? (y.s = -b, y) : new BigNumber2(yc ? x : NaN);
      if (!xc[0] || !yc[0]) {
        return yc[0] ? (y.s = -b, y) : new BigNumber2(xc[0] ? x : (
          // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
          ROUNDING_MODE == 3 ? -0 : 0
        ));
      }
    }
    xe = bitFloor(xe);
    ye = bitFloor(ye);
    xc = xc.slice();
    if (a = xe - ye) {
      if (xLTy = a < 0) {
        a = -a;
        t = xc;
      } else {
        ye = xe;
        t = yc;
      }
      t.reverse();
      for (b = a; b--; t.push(0)) ;
      t.reverse();
    } else {
      j = (xLTy = (a = xc.length) < (b = yc.length)) ? a : b;
      for (a = b = 0; b < j; b++) {
        if (xc[b] != yc[b]) {
          xLTy = xc[b] < yc[b];
          break;
        }
      }
    }
    if (xLTy) {
      t = xc;
      xc = yc;
      yc = t;
      y.s = -y.s;
    }
    b = (j = yc.length) - (i = xc.length);
    if (b > 0) for (; b--; xc[i++] = 0) ;
    b = BASE - 1;
    for (; j > a; ) {
      if (xc[--j] < yc[j]) {
        for (i = j; i && !xc[--i]; xc[i] = b) ;
        --xc[i];
        xc[j] += BASE;
      }
      xc[j] -= yc[j];
    }
    for (; xc[0] == 0; xc.splice(0, 1), --ye) ;
    if (!xc[0]) {
      y.s = ROUNDING_MODE == 3 ? -1 : 1;
      y.c = [y.e = 0];
      return y;
    }
    return normalise(y, xc, ye);
  };
  P.modulo = P.mod = function(y, b) {
    var q, s, x = this;
    y = new BigNumber2(y, b);
    if (!x.c || !y.s || y.c && !y.c[0]) {
      return new BigNumber2(NaN);
    } else if (!y.c || x.c && !x.c[0]) {
      return new BigNumber2(x);
    }
    if (MODULO_MODE == 9) {
      s = y.s;
      y.s = 1;
      q = div(x, y, 0, 3);
      y.s = s;
      q.s *= s;
    } else {
      q = div(x, y, 0, MODULO_MODE);
    }
    y = x.minus(q.times(y));
    if (!y.c[0] && MODULO_MODE == 1) y.s = x.s;
    return y;
  };
  P.multipliedBy = P.times = function(y, b) {
    var c, e, i, j, k, m, xcL, xlo, xhi, ycL, ylo, yhi, zc, base3, sqrtBase, x = this, xc = x.c, yc = (y = new BigNumber2(y, b)).c;
    if (!xc || !yc || !xc[0] || !yc[0]) {
      if (!x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {
        y.c = y.e = y.s = null;
      } else {
        y.s *= x.s;
        if (!xc || !yc) {
          y.c = y.e = null;
        } else {
          y.c = [0];
          y.e = 0;
        }
      }
      return y;
    }
    e = bitFloor(x.e / LOG_BASE) + bitFloor(y.e / LOG_BASE);
    y.s *= x.s;
    xcL = xc.length;
    ycL = yc.length;
    if (xcL < ycL) {
      zc = xc;
      xc = yc;
      yc = zc;
      i = xcL;
      xcL = ycL;
      ycL = i;
    }
    for (i = xcL + ycL, zc = []; i--; zc.push(0)) ;
    base3 = BASE;
    sqrtBase = SQRT_BASE;
    for (i = ycL; --i >= 0; ) {
      c = 0;
      ylo = yc[i] % sqrtBase;
      yhi = yc[i] / sqrtBase | 0;
      for (k = xcL, j = i + k; j > i; ) {
        xlo = xc[--k] % sqrtBase;
        xhi = xc[k] / sqrtBase | 0;
        m = yhi * xlo + xhi * ylo;
        xlo = ylo * xlo + m % sqrtBase * sqrtBase + zc[j] + c;
        c = (xlo / base3 | 0) + (m / sqrtBase | 0) + yhi * xhi;
        zc[j--] = xlo % base3;
      }
      zc[j] = c;
    }
    if (c) {
      ++e;
    } else {
      zc.splice(0, 1);
    }
    return normalise(y, zc, e);
  };
  P.negated = function() {
    var x = new BigNumber2(this);
    x.s = -x.s || null;
    return x;
  };
  P.plus = function(y, b) {
    var t, x = this, a = x.s;
    y = new BigNumber2(y, b);
    b = y.s;
    if (!a || !b) return new BigNumber2(NaN);
    if (a != b) {
      y.s = -b;
      return x.minus(y);
    }
    var xe = x.e / LOG_BASE, ye = y.e / LOG_BASE, xc = x.c, yc = y.c;
    if (!xe || !ye) {
      if (!xc || !yc) return new BigNumber2(a / 0);
      if (!xc[0] || !yc[0]) return yc[0] ? y : new BigNumber2(xc[0] ? x : a * 0);
    }
    xe = bitFloor(xe);
    ye = bitFloor(ye);
    xc = xc.slice();
    if (a = xe - ye) {
      if (a > 0) {
        ye = xe;
        t = yc;
      } else {
        a = -a;
        t = xc;
      }
      t.reverse();
      for (; a--; t.push(0)) ;
      t.reverse();
    }
    a = xc.length;
    b = yc.length;
    if (a - b < 0) {
      t = yc;
      yc = xc;
      xc = t;
      b = a;
    }
    for (a = 0; b; ) {
      a = (xc[--b] = xc[b] + yc[b] + a) / BASE | 0;
      xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE;
    }
    if (a) {
      xc = [a].concat(xc);
      ++ye;
    }
    return normalise(y, xc, ye);
  };
  P.precision = P.sd = function(sd, rm) {
    var c, n, v, x = this;
    if (sd != null && sd !== !!sd) {
      intCheck(sd, 1, MAX);
      if (rm == null) rm = ROUNDING_MODE;
      else intCheck(rm, 0, 8);
      return round(new BigNumber2(x), sd, rm);
    }
    if (!(c = x.c)) return null;
    v = c.length - 1;
    n = v * LOG_BASE + 1;
    if (v = c[v]) {
      for (; v % 10 == 0; v /= 10, n--) ;
      for (v = c[0]; v >= 10; v /= 10, n++) ;
    }
    if (sd && x.e + 1 > n) n = x.e + 1;
    return n;
  };
  P.shiftedBy = function(k) {
    intCheck(k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
    return this.times("1e" + k);
  };
  P.squareRoot = P.sqrt = function() {
    var m, n, r, rep, t, x = this, c = x.c, s = x.s, e = x.e, dp = DECIMAL_PLACES + 4, half = new BigNumber2("0.5");
    if (s !== 1 || !c || !c[0]) {
      return new BigNumber2(!s || s < 0 && (!c || c[0]) ? NaN : c ? x : 1 / 0);
    }
    s = Math.sqrt(+valueOf(x));
    if (s == 0 || s == 1 / 0) {
      n = coeffToString(c);
      if ((n.length + e) % 2 == 0) n += "0";
      s = Math.sqrt(+n);
      e = bitFloor((e + 1) / 2) - (e < 0 || e % 2);
      if (s == 1 / 0) {
        n = "5e" + e;
      } else {
        n = s.toExponential();
        n = n.slice(0, n.indexOf("e") + 1) + e;
      }
      r = new BigNumber2(n);
    } else {
      r = new BigNumber2(s + "");
    }
    if (r.c[0]) {
      e = r.e;
      s = e + dp;
      if (s < 3) s = 0;
      for (; ; ) {
        t = r;
        r = half.times(t.plus(div(x, t, dp, 1)));
        if (coeffToString(t.c).slice(0, s) === (n = coeffToString(r.c)).slice(0, s)) {
          if (r.e < e) --s;
          n = n.slice(s - 3, s + 1);
          if (n == "9999" || !rep && n == "4999") {
            if (!rep) {
              round(t, t.e + DECIMAL_PLACES + 2, 0);
              if (t.times(t).eq(x)) {
                r = t;
                break;
              }
            }
            dp += 4;
            s += 4;
            rep = 1;
          } else {
            if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
              round(r, r.e + DECIMAL_PLACES + 2, 1);
              m = !r.times(r).eq(x);
            }
            break;
          }
        }
      }
    }
    return round(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m);
  };
  P.toExponential = function(dp, rm) {
    if (dp != null) {
      intCheck(dp, 0, MAX);
      dp++;
    }
    return format2(this, dp, rm, 1);
  };
  P.toFixed = function(dp, rm) {
    if (dp != null) {
      intCheck(dp, 0, MAX);
      dp = dp + this.e + 1;
    }
    return format2(this, dp, rm);
  };
  P.toFormat = function(dp, rm, format3) {
    var str2, x = this;
    if (format3 == null) {
      if (dp != null && rm && typeof rm == "object") {
        format3 = rm;
        rm = null;
      } else if (dp && typeof dp == "object") {
        format3 = dp;
        dp = rm = null;
      } else {
        format3 = FORMAT;
      }
    } else if (typeof format3 != "object") {
      throw Error(bignumberError + "Argument not an object: " + format3);
    }
    str2 = x.toFixed(dp, rm);
    if (x.c) {
      var i, arr = str2.split("."), g1 = +format3.groupSize, g2 = +format3.secondaryGroupSize, groupSeparator = format3.groupSeparator || "", intPart = arr[0], fractionPart = arr[1], isNeg = x.s < 0, intDigits = isNeg ? intPart.slice(1) : intPart, len = intDigits.length;
      if (g2) {
        i = g1;
        g1 = g2;
        g2 = i;
        len -= i;
      }
      if (g1 > 0 && len > 0) {
        i = len % g1 || g1;
        intPart = intDigits.substr(0, i);
        for (; i < len; i += g1) intPart += groupSeparator + intDigits.substr(i, g1);
        if (g2 > 0) intPart += groupSeparator + intDigits.slice(i);
        if (isNeg) intPart = "-" + intPart;
      }
      str2 = fractionPart ? intPart + (format3.decimalSeparator || "") + ((g2 = +format3.fractionGroupSize) ? fractionPart.replace(
        new RegExp("\\d{" + g2 + "}\\B", "g"),
        "$&" + (format3.fractionGroupSeparator || "")
      ) : fractionPart) : intPart;
    }
    return (format3.prefix || "") + str2 + (format3.suffix || "");
  };
  P.toFraction = function(md) {
    var d, d0, d1, d2, e, exp, n, n0, n1, q, r, s, x = this, xc = x.c;
    if (md != null) {
      n = new BigNumber2(md);
      if (!n.isInteger() && (n.c || n.s !== 1) || n.lt(ONE)) {
        throw Error(bignumberError + "Argument " + (n.isInteger() ? "out of range: " : "not an integer: ") + valueOf(n));
      }
    }
    if (!xc) return new BigNumber2(x);
    d = new BigNumber2(ONE);
    n1 = d0 = new BigNumber2(ONE);
    d1 = n0 = new BigNumber2(ONE);
    s = coeffToString(xc);
    e = d.e = s.length - x.e - 1;
    d.c[0] = POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp];
    md = !md || n.comparedTo(d) > 0 ? e > 0 ? d : n1 : n;
    exp = MAX_EXP;
    MAX_EXP = 1 / 0;
    n = new BigNumber2(s);
    n0.c[0] = 0;
    for (; ; ) {
      q = div(n, d, 0, 1);
      d2 = d0.plus(q.times(d1));
      if (d2.comparedTo(md) == 1) break;
      d0 = d1;
      d1 = d2;
      n1 = n0.plus(q.times(d2 = n1));
      n0 = d2;
      d = n.minus(q.times(d2 = d));
      n = d2;
    }
    d2 = div(md.minus(d0), d1, 0, 1);
    n0 = n0.plus(d2.times(n1));
    d0 = d0.plus(d2.times(d1));
    n0.s = n1.s = x.s;
    e = e * 2;
    r = div(n1, d1, e, ROUNDING_MODE).minus(x).abs().comparedTo(
      div(n0, d0, e, ROUNDING_MODE).minus(x).abs()
    ) < 1 ? [n1, d1] : [n0, d0];
    MAX_EXP = exp;
    return r;
  };
  P.toNumber = function() {
    return +valueOf(this);
  };
  P.toPrecision = function(sd, rm) {
    if (sd != null) intCheck(sd, 1, MAX);
    return format2(this, sd, rm, 2);
  };
  P.toString = function(b) {
    var str2, n = this, s = n.s, e = n.e;
    if (e === null) {
      if (s) {
        str2 = "Infinity";
        if (s < 0) str2 = "-" + str2;
      } else {
        str2 = "NaN";
      }
    } else {
      if (b == null) {
        str2 = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(coeffToString(n.c), e) : toFixedPoint(coeffToString(n.c), e, "0");
      } else if (b === 10 && alphabetHasNormalDecimalDigits) {
        n = round(new BigNumber2(n), DECIMAL_PLACES + e + 1, ROUNDING_MODE);
        str2 = toFixedPoint(coeffToString(n.c), n.e, "0");
      } else {
        intCheck(b, 2, ALPHABET2.length, "Base");
        str2 = convertBase(toFixedPoint(coeffToString(n.c), e, "0"), 10, b, s, true);
      }
      if (s < 0 && n.c[0]) str2 = "-" + str2;
    }
    return str2;
  };
  P.valueOf = P.toJSON = function() {
    return valueOf(this);
  };
  P._isBigNumber = true;
  P[Symbol.toStringTag] = "BigNumber";
  P[Symbol.for("nodejs.util.inspect.custom")] = P.valueOf;
  if (configObject != null) BigNumber2.set(configObject);
  return BigNumber2;
}
function bitFloor(n) {
  var i = n | 0;
  return n > 0 || n === i ? i : i - 1;
}
function coeffToString(a) {
  var s, z2, i = 1, j = a.length, r = a[0] + "";
  for (; i < j; ) {
    s = a[i++] + "";
    z2 = LOG_BASE - s.length;
    for (; z2--; s = "0" + s) ;
    r += s;
  }
  for (j = r.length; r.charCodeAt(--j) === 48; ) ;
  return r.slice(0, j + 1 || 1);
}
function compare(x, y) {
  var a, b, xc = x.c, yc = y.c, i = x.s, j = y.s, k = x.e, l = y.e;
  if (!i || !j) return null;
  a = xc && !xc[0];
  b = yc && !yc[0];
  if (a || b) return a ? b ? 0 : -j : i;
  if (i != j) return i;
  a = i < 0;
  b = k == l;
  if (!xc || !yc) return b ? 0 : !xc ^ a ? 1 : -1;
  if (!b) return k > l ^ a ? 1 : -1;
  j = (k = xc.length) < (l = yc.length) ? k : l;
  for (i = 0; i < j; i++) if (xc[i] != yc[i]) return xc[i] > yc[i] ^ a ? 1 : -1;
  return k == l ? 0 : k > l ^ a ? 1 : -1;
}
function intCheck(n, min, max, name) {
  if (n < min || n > max || n !== mathfloor(n)) {
    throw Error(bignumberError + (name || "Argument") + (typeof n == "number" ? n < min || n > max ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(n));
  }
}
function isOdd(n) {
  var k = n.c.length - 1;
  return bitFloor(n.e / LOG_BASE) == k && n.c[k] % 2 != 0;
}
function toExponential(str2, e) {
  return (str2.length > 1 ? str2.charAt(0) + "." + str2.slice(1) : str2) + (e < 0 ? "e" : "e+") + e;
}
function toFixedPoint(str2, e, z2) {
  var len, zs;
  if (e < 0) {
    for (zs = z2 + "."; ++e; zs += z2) ;
    str2 = zs + str2;
  } else {
    len = str2.length;
    if (++e > len) {
      for (zs = z2, e -= len; --e; zs += z2) ;
      str2 += zs;
    } else if (e < len) {
      str2 = str2.slice(0, e) + "." + str2.slice(e);
    }
  }
  return str2;
}
var BigNumber = clone();
var bignumber_default = BigNumber;

// node_modules/@solana/buffer-layout-utils/lib/esm/decimal.mjs
var WAD = new bignumber_default("1e+18");

// node_modules/@solana/buffer-layout-utils/lib/esm/native.mjs
var import_buffer_layout3 = __toESM(require_Layout(), 1);
var bool = (property) => {
  const layout = (0, import_buffer_layout3.u8)(property);
  const { encode: encode4, decode: decode4 } = encodeDecode(layout);
  const boolLayout = layout;
  boolLayout.decode = (buffer3, offset3) => {
    const src2 = decode4(buffer3, offset3);
    return !!src2;
  };
  boolLayout.encode = (bool4, buffer3, offset3) => {
    const src2 = Number(bool4);
    return encode4(src2, buffer3, offset3);
  };
  return boolLayout;
};

// node_modules/@solana/buffer-layout-utils/lib/esm/web3.mjs
var import_buffer_layout4 = __toESM(require_Layout(), 1);
init_index_browser_esm();
var publicKey2 = (property) => {
  const layout = (0, import_buffer_layout4.blob)(32, property);
  const { encode: encode4, decode: decode4 } = encodeDecode(layout);
  const publicKeyLayout = layout;
  publicKeyLayout.decode = (buffer3, offset3) => {
    const src2 = decode4(buffer3, offset3);
    return new PublicKey(src2);
  };
  publicKeyLayout.encode = (publicKey5, buffer3, offset3) => {
    const src2 = publicKey5.toBuffer();
    return encode4(src2, buffer3, offset3);
  };
  return publicKeyLayout;
};

// node_modules/@solana/spl-token/lib/esm/actions/amountToUiAmount.js
init_index_browser_esm();

// node_modules/@solana/spl-token/lib/esm/constants.js
init_index_browser_esm();
var TOKEN_PROGRAM_ID = new PublicKey("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA");
var TOKEN_2022_PROGRAM_ID = new PublicKey("TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb");
var ASSOCIATED_TOKEN_PROGRAM_ID = new PublicKey("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL");
var NATIVE_MINT = new PublicKey("So11111111111111111111111111111111111111112");
var NATIVE_MINT_2022 = new PublicKey("9pan9bMn5HatX4EJdBwg9VgCa7Uz5HL8N1m5D3NdXejP");

// node_modules/@solana/spl-token/lib/esm/instructions/amountToUiAmount.js
var import_buffer_layout5 = __toESM(require_Layout(), 1);
init_index_browser_esm();

// node_modules/@solana/spl-token/lib/esm/errors.js
var TokenError = class extends Error {
  constructor(message) {
    super(message);
  }
};
var TokenAccountNotFoundError = class extends TokenError {
  constructor() {
    super(...arguments);
    this.name = "TokenAccountNotFoundError";
  }
};
var TokenInvalidAccountError = class extends TokenError {
  constructor() {
    super(...arguments);
    this.name = "TokenInvalidAccountError";
  }
};
var TokenInvalidAccountOwnerError = class extends TokenError {
  constructor() {
    super(...arguments);
    this.name = "TokenInvalidAccountOwnerError";
  }
};
var TokenInvalidAccountSizeError = class extends TokenError {
  constructor() {
    super(...arguments);
    this.name = "TokenInvalidAccountSizeError";
  }
};
var TokenInvalidMintError = class extends TokenError {
  constructor() {
    super(...arguments);
    this.name = "TokenInvalidMintError";
  }
};
var TokenInvalidOwnerError = class extends TokenError {
  constructor() {
    super(...arguments);
    this.name = "TokenInvalidOwnerError";
  }
};
var TokenOwnerOffCurveError = class extends TokenError {
  constructor() {
    super(...arguments);
    this.name = "TokenOwnerOffCurveError";
  }
};

// node_modules/@solana/spl-token/lib/esm/instructions/types.js
var TokenInstruction;
(function(TokenInstruction2) {
  TokenInstruction2[TokenInstruction2["InitializeMint"] = 0] = "InitializeMint";
  TokenInstruction2[TokenInstruction2["InitializeAccount"] = 1] = "InitializeAccount";
  TokenInstruction2[TokenInstruction2["InitializeMultisig"] = 2] = "InitializeMultisig";
  TokenInstruction2[TokenInstruction2["Transfer"] = 3] = "Transfer";
  TokenInstruction2[TokenInstruction2["Approve"] = 4] = "Approve";
  TokenInstruction2[TokenInstruction2["Revoke"] = 5] = "Revoke";
  TokenInstruction2[TokenInstruction2["SetAuthority"] = 6] = "SetAuthority";
  TokenInstruction2[TokenInstruction2["MintTo"] = 7] = "MintTo";
  TokenInstruction2[TokenInstruction2["Burn"] = 8] = "Burn";
  TokenInstruction2[TokenInstruction2["CloseAccount"] = 9] = "CloseAccount";
  TokenInstruction2[TokenInstruction2["FreezeAccount"] = 10] = "FreezeAccount";
  TokenInstruction2[TokenInstruction2["ThawAccount"] = 11] = "ThawAccount";
  TokenInstruction2[TokenInstruction2["TransferChecked"] = 12] = "TransferChecked";
  TokenInstruction2[TokenInstruction2["ApproveChecked"] = 13] = "ApproveChecked";
  TokenInstruction2[TokenInstruction2["MintToChecked"] = 14] = "MintToChecked";
  TokenInstruction2[TokenInstruction2["BurnChecked"] = 15] = "BurnChecked";
  TokenInstruction2[TokenInstruction2["InitializeAccount2"] = 16] = "InitializeAccount2";
  TokenInstruction2[TokenInstruction2["SyncNative"] = 17] = "SyncNative";
  TokenInstruction2[TokenInstruction2["InitializeAccount3"] = 18] = "InitializeAccount3";
  TokenInstruction2[TokenInstruction2["InitializeMultisig2"] = 19] = "InitializeMultisig2";
  TokenInstruction2[TokenInstruction2["InitializeMint2"] = 20] = "InitializeMint2";
  TokenInstruction2[TokenInstruction2["GetAccountDataSize"] = 21] = "GetAccountDataSize";
  TokenInstruction2[TokenInstruction2["InitializeImmutableOwner"] = 22] = "InitializeImmutableOwner";
  TokenInstruction2[TokenInstruction2["AmountToUiAmount"] = 23] = "AmountToUiAmount";
  TokenInstruction2[TokenInstruction2["UiAmountToAmount"] = 24] = "UiAmountToAmount";
  TokenInstruction2[TokenInstruction2["InitializeMintCloseAuthority"] = 25] = "InitializeMintCloseAuthority";
  TokenInstruction2[TokenInstruction2["TransferFeeExtension"] = 26] = "TransferFeeExtension";
  TokenInstruction2[TokenInstruction2["ConfidentialTransferExtension"] = 27] = "ConfidentialTransferExtension";
  TokenInstruction2[TokenInstruction2["DefaultAccountStateExtension"] = 28] = "DefaultAccountStateExtension";
  TokenInstruction2[TokenInstruction2["Reallocate"] = 29] = "Reallocate";
  TokenInstruction2[TokenInstruction2["MemoTransferExtension"] = 30] = "MemoTransferExtension";
  TokenInstruction2[TokenInstruction2["CreateNativeMint"] = 31] = "CreateNativeMint";
  TokenInstruction2[TokenInstruction2["InitializeNonTransferableMint"] = 32] = "InitializeNonTransferableMint";
  TokenInstruction2[TokenInstruction2["InterestBearingMintExtension"] = 33] = "InterestBearingMintExtension";
  TokenInstruction2[TokenInstruction2["CpiGuardExtension"] = 34] = "CpiGuardExtension";
  TokenInstruction2[TokenInstruction2["InitializePermanentDelegate"] = 35] = "InitializePermanentDelegate";
})(TokenInstruction || (TokenInstruction = {}));

// node_modules/@solana/spl-token/lib/esm/instructions/amountToUiAmount.js
var amountToUiAmountInstructionData = (0, import_buffer_layout5.struct)([
  (0, import_buffer_layout5.u8)("instruction"),
  u642("amount")
]);

// node_modules/@solana/spl-token/lib/esm/actions/approve.js
init_index_browser_esm();

// node_modules/@solana/spl-token/lib/esm/instructions/approve.js
var import_buffer_layout6 = __toESM(require_Layout(), 1);
init_index_browser_esm();

// node_modules/@solana/spl-token/lib/esm/instructions/internal.js
init_index_browser_esm();
function addSigners(keys, ownerOrAuthority, multiSigners) {
  if (multiSigners.length) {
    keys.push({ pubkey: ownerOrAuthority, isSigner: false, isWritable: false });
    for (const signer of multiSigners) {
      keys.push({
        pubkey: signer instanceof PublicKey ? signer : signer.publicKey,
        isSigner: true,
        isWritable: false
      });
    }
  } else {
    keys.push({ pubkey: ownerOrAuthority, isSigner: true, isWritable: false });
  }
  return keys;
}

// node_modules/@solana/spl-token/lib/esm/instructions/approve.js
var approveInstructionData = (0, import_buffer_layout6.struct)([(0, import_buffer_layout6.u8)("instruction"), u642("amount")]);

// node_modules/@solana/spl-token/lib/esm/actions/internal.js
init_index_browser_esm();

// node_modules/@solana/spl-token/lib/esm/actions/approveChecked.js
init_index_browser_esm();

// node_modules/@solana/spl-token/lib/esm/instructions/approveChecked.js
var import_buffer_layout7 = __toESM(require_Layout(), 1);
init_index_browser_esm();
var approveCheckedInstructionData = (0, import_buffer_layout7.struct)([
  (0, import_buffer_layout7.u8)("instruction"),
  u642("amount"),
  (0, import_buffer_layout7.u8)("decimals")
]);

// node_modules/@solana/spl-token/lib/esm/actions/burn.js
init_index_browser_esm();

// node_modules/@solana/spl-token/lib/esm/instructions/burn.js
var import_buffer_layout8 = __toESM(require_Layout(), 1);
init_index_browser_esm();
var burnInstructionData = (0, import_buffer_layout8.struct)([(0, import_buffer_layout8.u8)("instruction"), u642("amount")]);

// node_modules/@solana/spl-token/lib/esm/actions/burnChecked.js
init_index_browser_esm();

// node_modules/@solana/spl-token/lib/esm/instructions/burnChecked.js
var import_buffer_layout9 = __toESM(require_Layout(), 1);
init_index_browser_esm();
var burnCheckedInstructionData = (0, import_buffer_layout9.struct)([
  (0, import_buffer_layout9.u8)("instruction"),
  u642("amount"),
  (0, import_buffer_layout9.u8)("decimals")
]);

// node_modules/@solana/spl-token/lib/esm/actions/closeAccount.js
init_index_browser_esm();

// node_modules/@solana/spl-token/lib/esm/instructions/closeAccount.js
var import_buffer_layout10 = __toESM(require_Layout(), 1);
init_index_browser_esm();
var closeAccountInstructionData = (0, import_buffer_layout10.struct)([(0, import_buffer_layout10.u8)("instruction")]);

// node_modules/@solana/spl-token/lib/esm/actions/createAccount.js
init_index_browser_esm();

// node_modules/@solana/spl-token/lib/esm/state/account.js
var import_buffer_layout12 = __toESM(require_Layout(), 1);

// node_modules/@solana/spl-token/lib/esm/extensions/accountType.js
var AccountType;
(function(AccountType2) {
  AccountType2[AccountType2["Uninitialized"] = 0] = "Uninitialized";
  AccountType2[AccountType2["Mint"] = 1] = "Mint";
  AccountType2[AccountType2["Account"] = 2] = "Account";
})(AccountType || (AccountType = {}));
var ACCOUNT_TYPE_SIZE = 1;

// node_modules/@solana/spl-token/lib/esm/state/multisig.js
var import_buffer_layout11 = __toESM(require_Layout(), 1);
var MultisigLayout = (0, import_buffer_layout11.struct)([
  (0, import_buffer_layout11.u8)("m"),
  (0, import_buffer_layout11.u8)("n"),
  bool("isInitialized"),
  publicKey2("signer1"),
  publicKey2("signer2"),
  publicKey2("signer3"),
  publicKey2("signer4"),
  publicKey2("signer5"),
  publicKey2("signer6"),
  publicKey2("signer7"),
  publicKey2("signer8"),
  publicKey2("signer9"),
  publicKey2("signer10"),
  publicKey2("signer11")
]);
var MULTISIG_SIZE = MultisigLayout.span;

// node_modules/@solana/spl-token/lib/esm/state/account.js
var AccountState;
(function(AccountState2) {
  AccountState2[AccountState2["Uninitialized"] = 0] = "Uninitialized";
  AccountState2[AccountState2["Initialized"] = 1] = "Initialized";
  AccountState2[AccountState2["Frozen"] = 2] = "Frozen";
})(AccountState || (AccountState = {}));
var AccountLayout = (0, import_buffer_layout12.struct)([
  publicKey2("mint"),
  publicKey2("owner"),
  u642("amount"),
  (0, import_buffer_layout12.u32)("delegateOption"),
  publicKey2("delegate"),
  (0, import_buffer_layout12.u8)("state"),
  (0, import_buffer_layout12.u32)("isNativeOption"),
  u642("isNative"),
  u642("delegatedAmount"),
  (0, import_buffer_layout12.u32)("closeAuthorityOption"),
  publicKey2("closeAuthority")
]);
var ACCOUNT_SIZE = AccountLayout.span;
async function getAccount(connection, address, commitment, programId = TOKEN_PROGRAM_ID) {
  const info = await connection.getAccountInfo(address, commitment);
  return unpackAccount(address, info, programId);
}
function unpackAccount(address, info, programId = TOKEN_PROGRAM_ID) {
  if (!info)
    throw new TokenAccountNotFoundError();
  if (!info.owner.equals(programId))
    throw new TokenInvalidAccountOwnerError();
  if (info.data.length < ACCOUNT_SIZE)
    throw new TokenInvalidAccountSizeError();
  const rawAccount = AccountLayout.decode(info.data.slice(0, ACCOUNT_SIZE));
  let tlvData = Buffer.alloc(0);
  if (info.data.length > ACCOUNT_SIZE) {
    if (info.data.length === MULTISIG_SIZE)
      throw new TokenInvalidAccountSizeError();
    if (info.data[ACCOUNT_SIZE] != AccountType.Account)
      throw new TokenInvalidAccountError();
    tlvData = info.data.slice(ACCOUNT_SIZE + ACCOUNT_TYPE_SIZE);
  }
  return {
    address,
    mint: rawAccount.mint,
    owner: rawAccount.owner,
    amount: rawAccount.amount,
    delegate: rawAccount.delegateOption ? rawAccount.delegate : null,
    delegatedAmount: rawAccount.delegatedAmount,
    isInitialized: rawAccount.state !== AccountState.Uninitialized,
    isFrozen: rawAccount.state === AccountState.Frozen,
    isNative: !!rawAccount.isNativeOption,
    rentExemptReserve: rawAccount.isNativeOption ? rawAccount.isNative : null,
    closeAuthority: rawAccount.closeAuthorityOption ? rawAccount.closeAuthority : null,
    tlvData
  };
}

// node_modules/@solana/spl-token/lib/esm/state/mint.js
var import_buffer_layout13 = __toESM(require_Layout(), 1);
init_index_browser_esm();
var MintLayout = (0, import_buffer_layout13.struct)([
  (0, import_buffer_layout13.u32)("mintAuthorityOption"),
  publicKey2("mintAuthority"),
  u642("supply"),
  (0, import_buffer_layout13.u8)("decimals"),
  bool("isInitialized"),
  (0, import_buffer_layout13.u32)("freezeAuthorityOption"),
  publicKey2("freezeAuthority")
]);
var MINT_SIZE = MintLayout.span;
function getAssociatedTokenAddressSync(mint, owner, allowOwnerOffCurve = false, programId = TOKEN_PROGRAM_ID, associatedTokenProgramId = ASSOCIATED_TOKEN_PROGRAM_ID) {
  if (!allowOwnerOffCurve && !PublicKey.isOnCurve(owner.toBuffer()))
    throw new TokenOwnerOffCurveError();
  const [address] = PublicKey.findProgramAddressSync([owner.toBuffer(), programId.toBuffer(), mint.toBuffer()], associatedTokenProgramId);
  return address;
}

// node_modules/@solana/spl-token/lib/esm/extensions/cpiGuard/actions.js
init_index_browser_esm();

// node_modules/@solana/spl-token/lib/esm/extensions/cpiGuard/instructions.js
var import_buffer_layout14 = __toESM(require_Layout(), 1);
init_index_browser_esm();
var CpiGuardInstruction;
(function(CpiGuardInstruction2) {
  CpiGuardInstruction2[CpiGuardInstruction2["Enable"] = 0] = "Enable";
  CpiGuardInstruction2[CpiGuardInstruction2["Disable"] = 1] = "Disable";
})(CpiGuardInstruction || (CpiGuardInstruction = {}));
var cpiGuardInstructionData = (0, import_buffer_layout14.struct)([(0, import_buffer_layout14.u8)("instruction"), (0, import_buffer_layout14.u8)("cpiGuardInstruction")]);

// node_modules/@solana/spl-token/lib/esm/extensions/cpiGuard/state.js
var import_buffer_layout15 = __toESM(require_Layout(), 1);
var CpiGuardLayout = (0, import_buffer_layout15.struct)([bool("lockCpi")]);
var CPI_GUARD_SIZE = CpiGuardLayout.span;

// node_modules/@solana/spl-token/lib/esm/extensions/defaultAccountState/actions.js
init_index_browser_esm();

// node_modules/@solana/spl-token/lib/esm/extensions/defaultAccountState/instructions.js
var import_buffer_layout16 = __toESM(require_Layout(), 1);
init_index_browser_esm();
var DefaultAccountStateInstruction;
(function(DefaultAccountStateInstruction2) {
  DefaultAccountStateInstruction2[DefaultAccountStateInstruction2["Initialize"] = 0] = "Initialize";
  DefaultAccountStateInstruction2[DefaultAccountStateInstruction2["Update"] = 1] = "Update";
})(DefaultAccountStateInstruction || (DefaultAccountStateInstruction = {}));
var defaultAccountStateInstructionData = (0, import_buffer_layout16.struct)([
  (0, import_buffer_layout16.u8)("instruction"),
  (0, import_buffer_layout16.u8)("defaultAccountStateInstruction"),
  (0, import_buffer_layout16.u8)("accountState")
]);

// node_modules/@solana/spl-token/lib/esm/extensions/defaultAccountState/state.js
var import_buffer_layout17 = __toESM(require_Layout(), 1);
var DefaultAccountStateLayout = (0, import_buffer_layout17.struct)([(0, import_buffer_layout17.u8)("state")]);
var DEFAULT_ACCOUNT_STATE_SIZE = DefaultAccountStateLayout.span;

// node_modules/@solana/spl-token/lib/esm/extensions/immutableOwner.js
var import_buffer_layout18 = __toESM(require_Layout(), 1);
var ImmutableOwnerLayout = (0, import_buffer_layout18.struct)([]);
var IMMUTABLE_OWNER_SIZE = ImmutableOwnerLayout.span;

// node_modules/@solana/spl-token/lib/esm/extensions/interestBearingMint/state.js
var import_buffer_layout19 = __toESM(require_Layout(), 1);
var InterestBearingMintConfigStateLayout = (0, import_buffer_layout19.struct)([
  publicKey2("rateAuthority"),
  (0, import_buffer_layout19.ns64)("initializationTimestamp"),
  (0, import_buffer_layout19.s16)("preUpdateAverageRate"),
  (0, import_buffer_layout19.ns64)("lastUpdateTimestamp"),
  (0, import_buffer_layout19.s16)("currentRate")
]);
var INTEREST_BEARING_MINT_CONFIG_STATE_SIZE = InterestBearingMintConfigStateLayout.span;

// node_modules/@solana/spl-token/lib/esm/extensions/memoTransfer/actions.js
init_index_browser_esm();

// node_modules/@solana/spl-token/lib/esm/extensions/memoTransfer/instructions.js
var import_buffer_layout20 = __toESM(require_Layout(), 1);
init_index_browser_esm();
var MemoTransferInstruction;
(function(MemoTransferInstruction2) {
  MemoTransferInstruction2[MemoTransferInstruction2["Enable"] = 0] = "Enable";
  MemoTransferInstruction2[MemoTransferInstruction2["Disable"] = 1] = "Disable";
})(MemoTransferInstruction || (MemoTransferInstruction = {}));
var memoTransferInstructionData = (0, import_buffer_layout20.struct)([
  (0, import_buffer_layout20.u8)("instruction"),
  (0, import_buffer_layout20.u8)("memoTransferInstruction")
]);

// node_modules/@solana/spl-token/lib/esm/extensions/memoTransfer/state.js
var import_buffer_layout21 = __toESM(require_Layout(), 1);
var MemoTransferLayout = (0, import_buffer_layout21.struct)([bool("requireIncomingTransferMemos")]);
var MEMO_TRANSFER_SIZE = MemoTransferLayout.span;

// node_modules/@solana/spl-token/lib/esm/extensions/mintCloseAuthority.js
var import_buffer_layout22 = __toESM(require_Layout(), 1);
var MintCloseAuthorityLayout = (0, import_buffer_layout22.struct)([publicKey2("closeAuthority")]);
var MINT_CLOSE_AUTHORITY_SIZE = MintCloseAuthorityLayout.span;

// node_modules/@solana/spl-token/lib/esm/extensions/nonTransferable.js
var import_buffer_layout23 = __toESM(require_Layout(), 1);
var NonTransferableLayout = (0, import_buffer_layout23.struct)([]);
var NON_TRANSFERABLE_SIZE = NonTransferableLayout.span;
var NON_TRANSFERABLE_ACCOUNT_SIZE = NonTransferableLayout.span;

// node_modules/@solana/spl-token/lib/esm/extensions/permanentDelegate.js
var import_buffer_layout24 = __toESM(require_Layout(), 1);
var PermanentDelegateLayout = (0, import_buffer_layout24.struct)([publicKey2("delegate")]);
var PERMANENT_DELEGATE_SIZE = PermanentDelegateLayout.span;

// node_modules/@solana/spl-token/lib/esm/extensions/transferFee/actions.js
init_index_browser_esm();

// node_modules/@solana/spl-token/lib/esm/extensions/transferFee/instructions.js
var import_buffer_layout25 = __toESM(require_Layout(), 1);
init_index_browser_esm();
var TransferFeeInstruction;
(function(TransferFeeInstruction2) {
  TransferFeeInstruction2[TransferFeeInstruction2["InitializeTransferFeeConfig"] = 0] = "InitializeTransferFeeConfig";
  TransferFeeInstruction2[TransferFeeInstruction2["TransferCheckedWithFee"] = 1] = "TransferCheckedWithFee";
  TransferFeeInstruction2[TransferFeeInstruction2["WithdrawWithheldTokensFromMint"] = 2] = "WithdrawWithheldTokensFromMint";
  TransferFeeInstruction2[TransferFeeInstruction2["WithdrawWithheldTokensFromAccounts"] = 3] = "WithdrawWithheldTokensFromAccounts";
  TransferFeeInstruction2[TransferFeeInstruction2["HarvestWithheldTokensToMint"] = 4] = "HarvestWithheldTokensToMint";
  TransferFeeInstruction2[TransferFeeInstruction2["SetTransferFee"] = 5] = "SetTransferFee";
})(TransferFeeInstruction || (TransferFeeInstruction = {}));
var initializeTransferFeeConfigInstructionData = (0, import_buffer_layout25.struct)([
  (0, import_buffer_layout25.u8)("instruction"),
  (0, import_buffer_layout25.u8)("transferFeeInstruction"),
  (0, import_buffer_layout25.u8)("transferFeeConfigAuthorityOption"),
  publicKey2("transferFeeConfigAuthority"),
  (0, import_buffer_layout25.u8)("withdrawWithheldAuthorityOption"),
  publicKey2("withdrawWithheldAuthority"),
  (0, import_buffer_layout25.u16)("transferFeeBasisPoints"),
  u642("maximumFee")
]);
var transferCheckedWithFeeInstructionData = (0, import_buffer_layout25.struct)([
  (0, import_buffer_layout25.u8)("instruction"),
  (0, import_buffer_layout25.u8)("transferFeeInstruction"),
  u642("amount"),
  (0, import_buffer_layout25.u8)("decimals"),
  u642("fee")
]);
var withdrawWithheldTokensFromMintInstructionData = (0, import_buffer_layout25.struct)([
  (0, import_buffer_layout25.u8)("instruction"),
  (0, import_buffer_layout25.u8)("transferFeeInstruction")
]);
var withdrawWithheldTokensFromAccountsInstructionData = (0, import_buffer_layout25.struct)([
  (0, import_buffer_layout25.u8)("instruction"),
  (0, import_buffer_layout25.u8)("transferFeeInstruction"),
  (0, import_buffer_layout25.u8)("numTokenAccounts")
]);
var harvestWithheldTokensToMintInstructionData = (0, import_buffer_layout25.struct)([
  (0, import_buffer_layout25.u8)("instruction"),
  (0, import_buffer_layout25.u8)("transferFeeInstruction")
]);

// node_modules/@solana/spl-token/lib/esm/extensions/transferFee/state.js
var import_buffer_layout26 = __toESM(require_Layout(), 1);
function transferFeeLayout(property) {
  return (0, import_buffer_layout26.struct)([u642("epoch"), u642("maximumFee"), (0, import_buffer_layout26.u16)("transferFeeBasisPoints")], property);
}
var TransferFeeConfigLayout = (0, import_buffer_layout26.struct)([
  publicKey2("transferFeeConfigAuthority"),
  publicKey2("withdrawWithheldAuthority"),
  u642("withheldAmount"),
  transferFeeLayout("olderTransferFee"),
  transferFeeLayout("newerTransferFee")
]);
var TRANSFER_FEE_CONFIG_SIZE = TransferFeeConfigLayout.span;
var TransferFeeAmountLayout = (0, import_buffer_layout26.struct)([u642("withheldAmount")]);
var TRANSFER_FEE_AMOUNT_SIZE = TransferFeeAmountLayout.span;

// node_modules/@solana/spl-token/lib/esm/extensions/extensionType.js
var ExtensionType;
(function(ExtensionType2) {
  ExtensionType2[ExtensionType2["Uninitialized"] = 0] = "Uninitialized";
  ExtensionType2[ExtensionType2["TransferFeeConfig"] = 1] = "TransferFeeConfig";
  ExtensionType2[ExtensionType2["TransferFeeAmount"] = 2] = "TransferFeeAmount";
  ExtensionType2[ExtensionType2["MintCloseAuthority"] = 3] = "MintCloseAuthority";
  ExtensionType2[ExtensionType2["ConfidentialTransferMint"] = 4] = "ConfidentialTransferMint";
  ExtensionType2[ExtensionType2["ConfidentialTransferAccount"] = 5] = "ConfidentialTransferAccount";
  ExtensionType2[ExtensionType2["DefaultAccountState"] = 6] = "DefaultAccountState";
  ExtensionType2[ExtensionType2["ImmutableOwner"] = 7] = "ImmutableOwner";
  ExtensionType2[ExtensionType2["MemoTransfer"] = 8] = "MemoTransfer";
  ExtensionType2[ExtensionType2["NonTransferable"] = 9] = "NonTransferable";
  ExtensionType2[ExtensionType2["InterestBearingConfig"] = 10] = "InterestBearingConfig";
  ExtensionType2[ExtensionType2["CpiGuard"] = 11] = "CpiGuard";
  ExtensionType2[ExtensionType2["PermanentDelegate"] = 12] = "PermanentDelegate";
  ExtensionType2[ExtensionType2["NonTransferableAccount"] = 13] = "NonTransferableAccount";
})(ExtensionType || (ExtensionType = {}));

// node_modules/@solana/spl-token/lib/esm/instructions/initializeAccount.js
var import_buffer_layout27 = __toESM(require_Layout(), 1);
init_index_browser_esm();
var initializeAccountInstructionData = (0, import_buffer_layout27.struct)([(0, import_buffer_layout27.u8)("instruction")]);

// node_modules/@solana/spl-token/lib/esm/actions/createAssociatedTokenAccount.js
init_index_browser_esm();

// node_modules/@solana/spl-token/lib/esm/instructions/associatedTokenAccount.js
init_index_browser_esm();
function createAssociatedTokenAccountIdempotentInstruction(payer, associatedToken, owner, mint, programId = TOKEN_PROGRAM_ID, associatedTokenProgramId = ASSOCIATED_TOKEN_PROGRAM_ID) {
  return buildAssociatedTokenAccountInstruction(payer, associatedToken, owner, mint, Buffer.from([1]), programId, associatedTokenProgramId);
}
function buildAssociatedTokenAccountInstruction(payer, associatedToken, owner, mint, instructionData, programId = TOKEN_PROGRAM_ID, associatedTokenProgramId = ASSOCIATED_TOKEN_PROGRAM_ID) {
  const keys = [
    { pubkey: payer, isSigner: true, isWritable: true },
    { pubkey: associatedToken, isSigner: false, isWritable: true },
    { pubkey: owner, isSigner: false, isWritable: false },
    { pubkey: mint, isSigner: false, isWritable: false },
    { pubkey: SystemProgram.programId, isSigner: false, isWritable: false },
    { pubkey: programId, isSigner: false, isWritable: false }
  ];
  return new TransactionInstruction({
    keys,
    programId: associatedTokenProgramId,
    data: instructionData
  });
}

// node_modules/@solana/spl-token/lib/esm/actions/createAssociatedTokenAccountIdempotent.js
init_index_browser_esm();

// node_modules/@solana/spl-token/lib/esm/actions/createMint.js
init_index_browser_esm();

// node_modules/@solana/spl-token/lib/esm/instructions/initializeMint2.js
var import_buffer_layout28 = __toESM(require_Layout(), 1);
init_index_browser_esm();
var initializeMint2InstructionData = (0, import_buffer_layout28.struct)([
  (0, import_buffer_layout28.u8)("instruction"),
  (0, import_buffer_layout28.u8)("decimals"),
  publicKey2("mintAuthority"),
  (0, import_buffer_layout28.u8)("freezeAuthorityOption"),
  publicKey2("freezeAuthority")
]);

// node_modules/@solana/spl-token/lib/esm/actions/createMultisig.js
init_index_browser_esm();

// node_modules/@solana/spl-token/lib/esm/instructions/initializeMultisig.js
var import_buffer_layout29 = __toESM(require_Layout(), 1);
init_index_browser_esm();
var initializeMultisigInstructionData = (0, import_buffer_layout29.struct)([
  (0, import_buffer_layout29.u8)("instruction"),
  (0, import_buffer_layout29.u8)("m")
]);

// node_modules/@solana/spl-token/lib/esm/actions/createNativeMint.js
init_index_browser_esm();

// node_modules/@solana/spl-token/lib/esm/instructions/createNativeMint.js
var import_buffer_layout30 = __toESM(require_Layout(), 1);
init_index_browser_esm();
var createNativeMintInstructionData = (0, import_buffer_layout30.struct)([(0, import_buffer_layout30.u8)("instruction")]);

// node_modules/@solana/spl-token/lib/esm/actions/createWrappedNativeAccount.js
init_index_browser_esm();

// node_modules/@solana/spl-token/lib/esm/instructions/syncNative.js
var import_buffer_layout31 = __toESM(require_Layout(), 1);
init_index_browser_esm();
var syncNativeInstructionData = (0, import_buffer_layout31.struct)([(0, import_buffer_layout31.u8)("instruction")]);

// node_modules/@solana/spl-token/lib/esm/actions/freezeAccount.js
init_index_browser_esm();

// node_modules/@solana/spl-token/lib/esm/instructions/freezeAccount.js
var import_buffer_layout32 = __toESM(require_Layout(), 1);
init_index_browser_esm();
var freezeAccountInstructionData = (0, import_buffer_layout32.struct)([(0, import_buffer_layout32.u8)("instruction")]);

// node_modules/@solana/spl-token/lib/esm/actions/getOrCreateAssociatedTokenAccount.js
init_index_browser_esm();

// node_modules/@solana/spl-token/lib/esm/actions/mintTo.js
init_index_browser_esm();

// node_modules/@solana/spl-token/lib/esm/instructions/mintTo.js
var import_buffer_layout33 = __toESM(require_Layout(), 1);
init_index_browser_esm();
var mintToInstructionData = (0, import_buffer_layout33.struct)([(0, import_buffer_layout33.u8)("instruction"), u642("amount")]);

// node_modules/@solana/spl-token/lib/esm/actions/mintToChecked.js
init_index_browser_esm();

// node_modules/@solana/spl-token/lib/esm/instructions/mintToChecked.js
var import_buffer_layout34 = __toESM(require_Layout(), 1);
init_index_browser_esm();
var mintToCheckedInstructionData = (0, import_buffer_layout34.struct)([
  (0, import_buffer_layout34.u8)("instruction"),
  u642("amount"),
  (0, import_buffer_layout34.u8)("decimals")
]);

// node_modules/@solana/spl-token/lib/esm/actions/revoke.js
init_index_browser_esm();

// node_modules/@solana/spl-token/lib/esm/instructions/revoke.js
var import_buffer_layout35 = __toESM(require_Layout(), 1);
init_index_browser_esm();
var revokeInstructionData = (0, import_buffer_layout35.struct)([(0, import_buffer_layout35.u8)("instruction")]);

// node_modules/@solana/spl-token/lib/esm/actions/setAuthority.js
init_index_browser_esm();

// node_modules/@solana/spl-token/lib/esm/instructions/setAuthority.js
var import_buffer_layout36 = __toESM(require_Layout(), 1);
init_index_browser_esm();
var AuthorityType;
(function(AuthorityType2) {
  AuthorityType2[AuthorityType2["MintTokens"] = 0] = "MintTokens";
  AuthorityType2[AuthorityType2["FreezeAccount"] = 1] = "FreezeAccount";
  AuthorityType2[AuthorityType2["AccountOwner"] = 2] = "AccountOwner";
  AuthorityType2[AuthorityType2["CloseAccount"] = 3] = "CloseAccount";
})(AuthorityType || (AuthorityType = {}));
var setAuthorityInstructionData = (0, import_buffer_layout36.struct)([
  (0, import_buffer_layout36.u8)("instruction"),
  (0, import_buffer_layout36.u8)("authorityType"),
  (0, import_buffer_layout36.u8)("newAuthorityOption"),
  publicKey2("newAuthority")
]);

// node_modules/@solana/spl-token/lib/esm/actions/syncNative.js
init_index_browser_esm();

// node_modules/@solana/spl-token/lib/esm/actions/thawAccount.js
init_index_browser_esm();

// node_modules/@solana/spl-token/lib/esm/instructions/thawAccount.js
var import_buffer_layout37 = __toESM(require_Layout(), 1);
init_index_browser_esm();
var thawAccountInstructionData = (0, import_buffer_layout37.struct)([(0, import_buffer_layout37.u8)("instruction")]);

// node_modules/@solana/spl-token/lib/esm/actions/transfer.js
init_index_browser_esm();

// node_modules/@solana/spl-token/lib/esm/instructions/transfer.js
var import_buffer_layout38 = __toESM(require_Layout(), 1);
init_index_browser_esm();
var transferInstructionData = (0, import_buffer_layout38.struct)([(0, import_buffer_layout38.u8)("instruction"), u642("amount")]);
function createTransferInstruction(source, destination, owner, amount, multiSigners = [], programId = TOKEN_PROGRAM_ID) {
  const keys = addSigners([
    { pubkey: source, isSigner: false, isWritable: true },
    { pubkey: destination, isSigner: false, isWritable: true }
  ], owner, multiSigners);
  const data = Buffer.alloc(transferInstructionData.span);
  transferInstructionData.encode({
    instruction: TokenInstruction.Transfer,
    amount: BigInt(amount)
  }, data);
  return new TransactionInstruction({ keys, programId, data });
}

// node_modules/@solana/spl-token/lib/esm/actions/transferChecked.js
init_index_browser_esm();

// node_modules/@solana/spl-token/lib/esm/instructions/transferChecked.js
var import_buffer_layout39 = __toESM(require_Layout(), 1);
init_index_browser_esm();
var transferCheckedInstructionData = (0, import_buffer_layout39.struct)([
  (0, import_buffer_layout39.u8)("instruction"),
  u642("amount"),
  (0, import_buffer_layout39.u8)("decimals")
]);

// node_modules/@solana/spl-token/lib/esm/actions/uiAmountToAmount.js
init_index_browser_esm();

// node_modules/@solana/spl-token/lib/esm/instructions/uiAmountToAmount.js
var import_buffer_layout40 = __toESM(require_Layout(), 1);
init_index_browser_esm();

// node_modules/@solana/spl-token/lib/esm/extensions/interestBearingMint/actions.js
init_index_browser_esm();

// node_modules/@solana/spl-token/lib/esm/instructions/initializeMint.js
var import_buffer_layout41 = __toESM(require_Layout(), 1);
init_index_browser_esm();
var initializeMintInstructionData = (0, import_buffer_layout41.struct)([
  (0, import_buffer_layout41.u8)("instruction"),
  (0, import_buffer_layout41.u8)("decimals"),
  publicKey2("mintAuthority"),
  (0, import_buffer_layout41.u8)("freezeAuthorityOption"),
  publicKey2("freezeAuthority")
]);

// node_modules/@solana/spl-token/lib/esm/extensions/interestBearingMint/instructions.js
var import_buffer_layout42 = __toESM(require_Layout(), 1);
init_index_browser_esm();
var InterestBearingMintInstruction;
(function(InterestBearingMintInstruction2) {
  InterestBearingMintInstruction2[InterestBearingMintInstruction2["Initialize"] = 0] = "Initialize";
  InterestBearingMintInstruction2[InterestBearingMintInstruction2["UpdateRate"] = 1] = "UpdateRate";
})(InterestBearingMintInstruction || (InterestBearingMintInstruction = {}));
var interestBearingMintInitializeInstructionData = (0, import_buffer_layout42.struct)([
  (0, import_buffer_layout42.u8)("instruction"),
  (0, import_buffer_layout42.u8)("interestBearingMintInstruction"),
  // TODO: Make this an optional public key
  publicKey2("rateAuthority"),
  (0, import_buffer_layout42.s16)("rate")
]);
var interestBearingMintUpdateRateInstructionData = (0, import_buffer_layout42.struct)([
  (0, import_buffer_layout42.u8)("instruction"),
  (0, import_buffer_layout42.u8)("interestBearingMintInstruction"),
  (0, import_buffer_layout42.s16)("rate")
]);

// node_modules/@solana/spl-token/lib/esm/instructions/decode.js
var import_buffer_layout45 = __toESM(require_Layout(), 1);

// node_modules/@solana/spl-token/lib/esm/instructions/initializeAccount2.js
var import_buffer_layout43 = __toESM(require_Layout(), 1);
init_index_browser_esm();
var initializeAccount2InstructionData = (0, import_buffer_layout43.struct)([
  (0, import_buffer_layout43.u8)("instruction"),
  publicKey2("owner")
]);

// node_modules/@solana/spl-token/lib/esm/instructions/initializeAccount3.js
var import_buffer_layout44 = __toESM(require_Layout(), 1);
init_index_browser_esm();
var initializeAccount3InstructionData = (0, import_buffer_layout44.struct)([
  (0, import_buffer_layout44.u8)("instruction"),
  publicKey2("owner")
]);

// node_modules/@solana/spl-token/lib/esm/instructions/initializeImmutableOwner.js
var import_buffer_layout46 = __toESM(require_Layout(), 1);
init_index_browser_esm();
var initializeImmutableOwnerInstructionData = (0, import_buffer_layout46.struct)([
  (0, import_buffer_layout46.u8)("instruction")
]);

// node_modules/@solana/spl-token/lib/esm/instructions/initializeMintCloseAuthority.js
var import_buffer_layout47 = __toESM(require_Layout(), 1);
init_index_browser_esm();
var initializeMintCloseAuthorityInstructionData = (0, import_buffer_layout47.struct)([
  (0, import_buffer_layout47.u8)("instruction"),
  (0, import_buffer_layout47.u8)("closeAuthorityOption"),
  publicKey2("closeAuthority")
]);

// node_modules/@solana/spl-token/lib/esm/instructions/reallocate.js
var import_buffer_layout48 = __toESM(require_Layout(), 1);
init_index_browser_esm();

// node_modules/@solana/spl-token/lib/esm/instructions/initializeNonTransferableMint.js
var import_buffer_layout49 = __toESM(require_Layout(), 1);
init_index_browser_esm();
var initializeNonTransferableMintInstructionData = (0, import_buffer_layout49.struct)([
  (0, import_buffer_layout49.u8)("instruction")
]);

// node_modules/@solana/spl-token/lib/esm/instructions/initializePermanentDelegate.js
var import_buffer_layout50 = __toESM(require_Layout(), 1);
init_index_browser_esm();
init_index_browser_esm();
var initializePermanentDelegateInstructionData = (0, import_buffer_layout50.struct)([
  (0, import_buffer_layout50.u8)("instruction"),
  publicKey2("delegate")
]);

// node_modules/@audius/spl/dist/esm/claimable-tokens/ClaimableTokensProgram.js
init_index_browser_esm();

// node_modules/base-x/src/esm/index.js
function base(ALPHABET2) {
  if (ALPHABET2.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  const BASE_MAP = new Uint8Array(256);
  for (let j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (let i = 0; i < ALPHABET2.length; i++) {
    const x = ALPHABET2.charAt(i);
    const xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i;
  }
  const BASE2 = ALPHABET2.length;
  const LEADER = ALPHABET2.charAt(0);
  const FACTOR = Math.log(BASE2) / Math.log(256);
  const iFACTOR = Math.log(256) / Math.log(BASE2);
  function encode4(source) {
    if (source instanceof Uint8Array) {
    } else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    let zeroes = 0;
    let length2 = 0;
    let pbegin = 0;
    const pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    const size4 = (pend - pbegin) * iFACTOR + 1 >>> 0;
    const b58 = new Uint8Array(size4);
    while (pbegin !== pend) {
      let carry = source[pbegin];
      let i = 0;
      for (let it1 = size4 - 1; (carry !== 0 || i < length2) && it1 !== -1; it1--, i++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE2 >>> 0;
        carry = carry / BASE2 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length2 = i;
      pbegin++;
    }
    let it2 = size4 - length2;
    while (it2 !== size4 && b58[it2] === 0) {
      it2++;
    }
    let str2 = LEADER.repeat(zeroes);
    for (; it2 < size4; ++it2) {
      str2 += ALPHABET2.charAt(b58[it2]);
    }
    return str2;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    let psz = 0;
    let zeroes = 0;
    let length2 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    const size4 = (source.length - psz) * FACTOR + 1 >>> 0;
    const b256 = new Uint8Array(size4);
    while (psz < source.length) {
      const charCode = source.charCodeAt(psz);
      if (charCode > 255) {
        return;
      }
      let carry = BASE_MAP[charCode];
      if (carry === 255) {
        return;
      }
      let i = 0;
      for (let it3 = size4 - 1; (carry !== 0 || i < length2) && it3 !== -1; it3--, i++) {
        carry += BASE2 * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length2 = i;
      psz++;
    }
    let it4 = size4 - length2;
    while (it4 !== size4 && b256[it4] === 0) {
      it4++;
    }
    const vch = new Uint8Array(zeroes + (size4 - it4));
    let j = zeroes;
    while (it4 !== size4) {
      vch[j++] = b256[it4++];
    }
    return vch;
  }
  function decode4(string3) {
    const buffer3 = decodeUnsafe(string3);
    if (buffer3) {
      return buffer3;
    }
    throw new Error("Non-base" + BASE2 + " character");
  }
  return {
    encode: encode4,
    decodeUnsafe,
    decode: decode4
  };
}
var esm_default = base;

// node_modules/bs58/src/esm/index.js
var ALPHABET = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
var esm_default2 = esm_default(ALPHABET);

// node_modules/@audius/spl/dist/esm/layout-utils.js
var import_buffer_layout51 = __toESM(require_Layout());
var EthereumAddress = class extends import_buffer_layout51.Layout {
  constructor(property) {
    super(20, property);
    this.blob = (0, import_buffer_layout51.blob)(20, property);
  }
  /** @override */
  getSpan(b, offset3) {
    return this.blob.getSpan(b, offset3);
  }
  /**
   * Proxies the decoding to the underlying Blob, then
   * converts the buffer to hex and prepends '0x'.
   * @override
   * */
  decode(b, offset3 = 0) {
    const buffer3 = this.blob.decode(b, offset3);
    return "0x" + Buffer.from(buffer3).toString("hex");
  }
  /**
   * Strips the 0x and converts the address to a buffer, then
   * proxies the encoding to the underlying Blob.
   * @override
   * */
  encode(src2, b, offset3 = 0) {
    const strippedEthAddress = src2.replace("0x", "");
    const buf = Buffer.from(strippedEthAddress, "hex");
    const fixedBuf = Buffer.alloc(20, 0);
    buf.copy(fixedBuf, 20 - buf.length);
    return this.blob.encode(buf, b, offset3);
  }
};
var BorshString = class extends import_buffer_layout51.Layout {
  constructor(maxLength, property) {
    super(-1, property);
    this.maxLength = maxLength;
  }
  getSpan(b, offset3 = 0) {
    if (!b) {
      return (0, import_buffer_layout51.u32)().span + this.maxLength;
    }
    const length2 = (0, import_buffer_layout51.u32)().decode(b, offset3);
    return (0, import_buffer_layout51.u32)().span + length2;
  }
  decode(b, offset3 = 0) {
    const length2 = (0, import_buffer_layout51.u32)().decode(b, offset3);
    const value = (0, import_buffer_layout51.blob)(length2).decode(b, offset3 + (0, import_buffer_layout51.u32)().span);
    return (0, import_buffer_layout51.uint8ArrayToBuffer)(value).toString("utf-8");
  }
  encode(src2, b, offset3) {
    const srcb = Buffer.from(src2, "utf-8");
    if (srcb.length > this.maxLength) {
      throw new RangeError("text exceeds maxLength");
    }
    if (offset3 + srcb.length > b.length) {
      throw new RangeError("text length exceeds buffer");
    }
    return (0, import_buffer_layout51.u32)().encode(srcb.length, b, offset3) + (0, import_buffer_layout51.blob)(srcb.length).encode(srcb, b, offset3 + (0, import_buffer_layout51.u32)().span);
  }
};
var ethAddress = (property) => new EthereumAddress(property);
var borshString = (maxLength, property) => new BorshString(maxLength, property);

// node_modules/@audius/spl/dist/esm/claimable-tokens/constants.js
var ClaimableTokensInstruction;
(function(ClaimableTokensInstruction2) {
  ClaimableTokensInstruction2[ClaimableTokensInstruction2["Create"] = 0] = "Create";
  ClaimableTokensInstruction2[ClaimableTokensInstruction2["Transfer"] = 1] = "Transfer";
})(ClaimableTokensInstruction || (ClaimableTokensInstruction = {}));
var ClaimableTokensErrorCode;
(function(ClaimableTokensErrorCode2) {
  ClaimableTokensErrorCode2[ClaimableTokensErrorCode2["SignatureVerificationFailed"] = 0] = "SignatureVerificationFailed";
  ClaimableTokensErrorCode2[ClaimableTokensErrorCode2["Secp256InstructionLosing"] = 1] = "Secp256InstructionLosing";
  ClaimableTokensErrorCode2[ClaimableTokensErrorCode2["InstructionLoadError"] = 2] = "InstructionLoadError";
  ClaimableTokensErrorCode2[ClaimableTokensErrorCode2["NonceVerificationError"] = 3] = "NonceVerificationError";
})(ClaimableTokensErrorCode || (ClaimableTokensErrorCode = {}));
var ClaimableTokensErrorMessages = {
  [ClaimableTokensErrorCode.SignatureVerificationFailed]: "Signature verification failed",
  [ClaimableTokensErrorCode.Secp256InstructionLosing]: "Secp256 instruction losing",
  [ClaimableTokensErrorCode.InstructionLoadError]: "Instruction load error",
  [ClaimableTokensErrorCode.NonceVerificationError]: "Nonce verification failed"
};

// node_modules/@audius/spl/dist/esm/claimable-tokens/ClaimableTokensProgram.js
var TRANSFER_NONCE_PREFIX = "N_";
var TRANSFER_NONCE_PREFIX_BYTES = new TextEncoder().encode(TRANSFER_NONCE_PREFIX);
var SECP256K1_INSTRUCTION_MESSAGE_DATA_START = 97;
var ClaimableTokensProgram = class _ClaimableTokensProgram {
  static createAccountInstruction({ ethAddress: ethAddress2, payer, mint, authority, userBank, programId = _ClaimableTokensProgram.programId, tokenProgramId = TOKEN_PROGRAM_ID }) {
    const data = Buffer.alloc(_ClaimableTokensProgram.layouts.createAccountInstructionData.span);
    _ClaimableTokensProgram.layouts.createAccountInstructionData.encode({ instruction: ClaimableTokensInstruction.Create, ethAddress: ethAddress2 }, data);
    const keys = [
      { pubkey: payer, isSigner: true, isWritable: true },
      { pubkey: mint, isSigner: false, isWritable: false },
      { pubkey: authority, isSigner: false, isWritable: false },
      { pubkey: userBank, isSigner: false, isWritable: true },
      { pubkey: SYSVAR_RENT_PUBKEY, isSigner: false, isWritable: false },
      { pubkey: tokenProgramId, isSigner: false, isWritable: false },
      { pubkey: SystemProgram.programId, isSigner: false, isWritable: false }
    ];
    return new TransactionInstruction({ keys, programId, data });
  }
  static decodeCreateAccountInstruction({ programId, keys: [payer, mint, authority, userBank, rent, tokenProgramId, systemProgramId], data }) {
    return {
      programId,
      keys: {
        payer,
        mint,
        authority,
        userBank,
        rent,
        tokenProgramId,
        systemProgramId
      },
      data: _ClaimableTokensProgram.layouts.createAccountInstructionData.decode(data)
    };
  }
  static createTransferInstruction({ payer, sourceEthAddress, sourceUserBank, destination, nonceAccount, authority, programId = _ClaimableTokensProgram.programId, tokenProgramId = TOKEN_PROGRAM_ID }) {
    const data = Buffer.alloc(_ClaimableTokensProgram.layouts.unsignedTransferInstructionData.span);
    _ClaimableTokensProgram.layouts.unsignedTransferInstructionData.encode({
      instruction: ClaimableTokensInstruction.Transfer,
      sender: sourceEthAddress
    }, data);
    const keys = [
      { pubkey: payer, isSigner: true, isWritable: true },
      { pubkey: sourceUserBank, isSigner: false, isWritable: true },
      { pubkey: destination, isSigner: false, isWritable: true },
      { pubkey: nonceAccount, isSigner: false, isWritable: true },
      { pubkey: authority, isSigner: false, isWritable: false },
      { pubkey: SYSVAR_RENT_PUBKEY, isSigner: false, isWritable: false },
      {
        pubkey: SYSVAR_INSTRUCTIONS_PUBKEY,
        isSigner: false,
        isWritable: false
      },
      { pubkey: SystemProgram.programId, isSigner: false, isWritable: false },
      { pubkey: tokenProgramId, isSigner: false, isWritable: false }
    ];
    return new TransactionInstruction({ programId, keys, data });
  }
  static decodeTransferInstruction({ programId, keys: [payer, sourceUserBank, destination, nonceAccount, authority, rent, sysvarInstructions, systemProgramId, tokenProgramId], data }) {
    return {
      programId,
      keys: {
        payer,
        sourceUserBank,
        destination,
        nonceAccount,
        authority,
        rent,
        sysvarInstructions,
        systemProgramId,
        tokenProgramId
      },
      data: _ClaimableTokensProgram.layouts.unsignedTransferInstructionData.decode(data)
    };
  }
  static decodeInstruction(instruction) {
    switch (instruction.data[0]) {
      case ClaimableTokensInstruction.Create:
        return _ClaimableTokensProgram.decodeCreateAccountInstruction(instruction);
      case ClaimableTokensInstruction.Transfer:
        return _ClaimableTokensProgram.decodeTransferInstruction(instruction);
      default:
        throw new Error("Invalid Claimable Token Program Instruction");
    }
  }
  static isCreateAccountInstruction(decoded) {
    return decoded.data.instruction === ClaimableTokensInstruction.Create;
  }
  static isTransferInstruction(decoded) {
    return decoded.data.instruction === ClaimableTokensInstruction.Transfer;
  }
  static createSignedTransferInstructionData({ destination, amount, nonce }) {
    const data = Buffer.alloc(_ClaimableTokensProgram.layouts.signedTransferInstructionData.span);
    _ClaimableTokensProgram.layouts.signedTransferInstructionData.encode({
      destination,
      amount,
      nonce
    }, data);
    return data;
  }
  static decodeSignedTransferInstructionData(instruction) {
    return _ClaimableTokensProgram.layouts.signedTransferInstructionData.decode(Uint8Array.from(instruction.data).slice(SECP256K1_INSTRUCTION_MESSAGE_DATA_START));
  }
  static deriveNonce({ ethAddress: wallet, programId, authority }) {
    const ethAdddressData = ethAddress();
    const buffer3 = Buffer.alloc(ethAdddressData.span);
    ethAdddressData.encode(wallet, buffer3);
    const seed2 = Uint8Array.from([...TRANSFER_NONCE_PREFIX_BYTES, ...buffer3]);
    return PublicKey.findProgramAddressSync([authority.toBytes().slice(0, 32), seed2], programId)[0];
  }
  static async deriveUserBank({ ethAddress: wallet, claimableTokensPDA, tokenProgramId = TOKEN_PROGRAM_ID }) {
    const ethAddressData = ethAddress();
    const buffer3 = Buffer.alloc(ethAddressData.span);
    ethAddressData.encode(wallet, buffer3);
    const seed2 = esm_default2.encode(buffer3);
    return await PublicKey.createWithSeed(claimableTokensPDA, seed2, tokenProgramId);
  }
};
ClaimableTokensProgram.programId = new PublicKey("Ewkv3JahEFRKkcJmpoKB7pXbnUHwjAyXiwEo4ZY2rezQ");
ClaimableTokensProgram.layouts = {
  createAccountInstructionData: (0, import_buffer_layout52.struct)([
    (0, import_buffer_layout52.u8)("instruction"),
    ethAddress("ethAddress")
  ]),
  unsignedTransferInstructionData: (0, import_buffer_layout52.struct)([
    (0, import_buffer_layout52.u8)("instruction"),
    ethAddress("sender")
  ]),
  signedTransferInstructionData: (0, import_buffer_layout52.struct)([
    publicKey2("destination"),
    u642("amount"),
    u642("nonce")
  ]),
  nonceAccountData: (0, import_buffer_layout52.struct)([(0, import_buffer_layout52.u8)("version"), u642("nonce")])
};
ClaimableTokensProgram.deriveAuthority = ({ programId, mint }) => {
  return PublicKey.findProgramAddressSync([mint.toBytes().slice(0, 32)], programId)[0];
};

// node_modules/@audius/spl/dist/esm/reward-manager/RewardManagerProgram.js
var import_buffer_layout55 = __toESM(require_Layout());
init_index_browser_esm();

// node_modules/@audius/spl/dist/esm/reward-manager/AttestationLayout.js
var import_buffer_layout53 = __toESM(require_Layout());
var AttestationLayout = class extends import_buffer_layout53.Layout {
  constructor(property) {
    super(
      // ethAddress().span + 1 + u64().span + 1 + 32 + 1 + ethAddress().span,
      // 20 + 1 + 8 + 1 + 32 + 1 + 20 = 83
      83,
      property
    );
  }
  getSpan(b, offset3 = 0) {
    return this.span;
  }
  decode(b, offset3 = 0) {
    const delimiter = Buffer.from("_", "utf-8");
    const recipientEthAddress = ethAddress().decode(b, offset3);
    offset3 += ethAddress().span + 1;
    const amount = u642().decode(b, offset3);
    offset3 += u642().span + 1;
    const delimiterIndex = b.slice(offset3).findIndex((v) => v === delimiter[0] || v === 0);
    const disbursementSpan = delimiterIndex > -1 ? delimiterIndex : b.byteLength - offset3;
    const disbursementIdBlob = (0, import_buffer_layout53.blob)(disbursementSpan).decode(b, offset3);
    const disbursementId = Buffer.from(disbursementIdBlob).toString("utf-8");
    offset3 += disbursementSpan + 1;
    return {
      recipientEthAddress,
      amount,
      disbursementId,
      antiAbuseOracleEthAddress: offset3 < b.byteLength ? ethAddress().decode(b, offset3) : null
    };
  }
  encode(src2, b, offset3 = 0) {
    const delimiter = Buffer.from("_", "utf-8");
    let layoutOffset = offset3;
    layoutOffset += ethAddress().encode(src2.recipientEthAddress, b, layoutOffset);
    layoutOffset += (0, import_buffer_layout53.blob)(1).encode(delimiter, b, layoutOffset);
    layoutOffset += u642().encode(src2.amount, b, layoutOffset);
    layoutOffset += (0, import_buffer_layout53.blob)(1).encode(delimiter, b, layoutOffset);
    layoutOffset += (0, import_buffer_layout53.utf8)(32).encode(src2.disbursementId, b, layoutOffset);
    if (src2.antiAbuseOracleEthAddress) {
      layoutOffset += (0, import_buffer_layout53.blob)(1).encode(delimiter, b, layoutOffset);
      layoutOffset += ethAddress().encode(src2.antiAbuseOracleEthAddress, b, layoutOffset);
    }
    return layoutOffset - offset3;
  }
};
var attestationLayout = (property) => new AttestationLayout(property);

// node_modules/@audius/spl/dist/esm/reward-manager/SenderAttestationLayout.js
var import_buffer_layout54 = __toESM(require_Layout());
var encoder = new TextEncoder();
var SENDER_ATTESTATION_PREFIX = "add";
var SENDER_ATTESTATION_PREFIX_BYTES = encoder.encode(SENDER_ATTESTATION_PREFIX);
var SenderAttestationLayout = class extends import_buffer_layout54.Layout {
  constructor(property) {
    super(55, property);
  }
  decode(b, offset3) {
    throw new Error("Method not implemented.");
  }
  encode(src2, b, offset3 = 0) {
    offset3 += (0, import_buffer_layout54.blob)(3).encode(SENDER_ATTESTATION_PREFIX_BYTES, b, offset3);
    offset3 += publicKey2().encode(src2.rewardManagerState, b, offset3);
    offset3 += ethAddress().encode(src2.senderEthAddress, b, offset3);
    return offset3;
  }
};
var senderAttestationLayout = (property) => new SenderAttestationLayout(property);

// node_modules/@audius/spl/dist/esm/reward-manager/constants.js
var RewardManagerInstruction;
(function(RewardManagerInstruction2) {
  RewardManagerInstruction2[RewardManagerInstruction2["Init"] = 0] = "Init";
  RewardManagerInstruction2[RewardManagerInstruction2["ChangeManagerAccount"] = 1] = "ChangeManagerAccount";
  RewardManagerInstruction2[RewardManagerInstruction2["CreateSender"] = 2] = "CreateSender";
  RewardManagerInstruction2[RewardManagerInstruction2["DeleteSender"] = 3] = "DeleteSender";
  RewardManagerInstruction2[RewardManagerInstruction2["CreateSenderPublic"] = 4] = "CreateSenderPublic";
  RewardManagerInstruction2[RewardManagerInstruction2["DeleteSenderPublic"] = 5] = "DeleteSenderPublic";
  RewardManagerInstruction2[RewardManagerInstruction2["SubmitAttestation"] = 6] = "SubmitAttestation";
  RewardManagerInstruction2[RewardManagerInstruction2["EvaluateAttestations"] = 7] = "EvaluateAttestations";
})(RewardManagerInstruction || (RewardManagerInstruction = {}));
var RewardManagerErrorCode;
(function(RewardManagerErrorCode2) {
  RewardManagerErrorCode2[RewardManagerErrorCode2["IncorrectOwner"] = 0] = "IncorrectOwner";
  RewardManagerErrorCode2[RewardManagerErrorCode2["SignCollision"] = 1] = "SignCollision";
  RewardManagerErrorCode2[RewardManagerErrorCode2["WrongSigner"] = 2] = "WrongSigner";
  RewardManagerErrorCode2[RewardManagerErrorCode2["NotEnoughSigners"] = 3] = "NotEnoughSigners";
  RewardManagerErrorCode2[RewardManagerErrorCode2["Secp256InstructionMissing"] = 4] = "Secp256InstructionMissing";
  RewardManagerErrorCode2[RewardManagerErrorCode2["InstructionLoadError"] = 5] = "InstructionLoadError";
  RewardManagerErrorCode2[RewardManagerErrorCode2["RepeatedSenders"] = 6] = "RepeatedSenders";
  RewardManagerErrorCode2[RewardManagerErrorCode2["SignatureVerificationFailed"] = 7] = "SignatureVerificationFailed";
  RewardManagerErrorCode2[RewardManagerErrorCode2["OperatorCollision"] = 8] = "OperatorCollision";
  RewardManagerErrorCode2[RewardManagerErrorCode2["AlreadySent"] = 9] = "AlreadySent";
  RewardManagerErrorCode2[RewardManagerErrorCode2["IncorrectMessages"] = 10] = "IncorrectMessages";
  RewardManagerErrorCode2[RewardManagerErrorCode2["MessagesOverflow"] = 11] = "MessagesOverflow";
  RewardManagerErrorCode2[RewardManagerErrorCode2["MathOverflow"] = 12] = "MathOverflow";
  RewardManagerErrorCode2[RewardManagerErrorCode2["InvalidRecipient"] = 13] = "InvalidRecipient";
})(RewardManagerErrorCode || (RewardManagerErrorCode = {}));
var RewardManagerErrorMessages = {
  [RewardManagerErrorCode.IncorrectOwner]: "Input account owner is not the program address",
  [RewardManagerErrorCode.SignCollision]: "Signature with an already met principal",
  [RewardManagerErrorCode.WrongSigner]: "Unexpected signer met",
  [RewardManagerErrorCode.NotEnoughSigners]: "Isn't enough signers keys",
  [RewardManagerErrorCode.Secp256InstructionMissing]: "Secp256 instruction missing",
  [RewardManagerErrorCode.InstructionLoadError]: "Instruction load error",
  [RewardManagerErrorCode.RepeatedSenders]: "Repeated sender",
  [RewardManagerErrorCode.SignatureVerificationFailed]: "Signature verification failed",
  [RewardManagerErrorCode.OperatorCollision]: "Some signers have same operators",
  [RewardManagerErrorCode.AlreadySent]: "Funds already sent",
  [RewardManagerErrorCode.IncorrectMessages]: "Incorrect messages",
  [RewardManagerErrorCode.MessagesOverflow]: "Messages overflow",
  [RewardManagerErrorCode.MathOverflow]: "Math overflow",
  [RewardManagerErrorCode.InvalidRecipient]: "Invalid Recipient"
};

// node_modules/@audius/spl/dist/esm/reward-manager/RewardManagerProgram.js
var _a;
var encoder2 = new TextEncoder();
var SENDER_SEED_PREFIX = "S_";
var SENDER_SEED_PREFIX_BYTES = encoder2.encode(SENDER_SEED_PREFIX);
var ATTESTATIONS_SEED_PREFIX = "V_";
var ATTESTATIONS_SEED_PREFIX_BYTES = encoder2.encode(ATTESTATIONS_SEED_PREFIX);
var DISBURSEMENT_SEED_PREFIX = "T_";
var DISBURSEMENT_SEED_PREFIX_BYTES = encoder2.encode(DISBURSEMENT_SEED_PREFIX);
var RewardManagerProgram = class _RewardManagerProgram {
  static createSenderInstruction({ senderEthAddress, operatorEthAddress, rewardManagerState, manager, authority, payer, sender, rewardManagerProgramId = _RewardManagerProgram.programId }) {
    const data = Buffer.alloc(_RewardManagerProgram.layouts.createSenderInstructionData.span);
    _RewardManagerProgram.layouts.createSenderInstructionData.encode({
      instruction: RewardManagerInstruction.CreateSender,
      senderEthAddress,
      operatorEthAddress
    }, data);
    const keys = [
      { pubkey: rewardManagerState, isSigner: false, isWritable: false },
      { pubkey: manager, isSigner: true, isWritable: false },
      { pubkey: authority, isSigner: false, isWritable: false },
      { pubkey: payer, isSigner: true, isWritable: false },
      { pubkey: sender, isSigner: false, isWritable: true },
      { pubkey: SystemProgram.programId, isSigner: false, isWritable: false },
      { pubkey: SYSVAR_RENT_PUBKEY, isSigner: false, isWritable: false }
    ];
    return new TransactionInstruction({
      programId: rewardManagerProgramId,
      keys,
      data
    });
  }
  static decodeCreateSenderInstruction({ programId, keys: [rewardManagerState, manager, authority, payer, sender, systemProgramId, rent], data }) {
    return {
      programId,
      keys: {
        rewardManagerState,
        manager,
        authority,
        payer,
        sender,
        systemProgramId,
        rent
      },
      data: _RewardManagerProgram.layouts.createSenderInstructionData.decode(data)
    };
  }
  static createSenderPublicInstruction({ senderEthAddress, operatorEthAddress, rewardManagerState, authority, payer, sender, existingSenders, rewardManagerProgramId }) {
    const data = Buffer.alloc(_RewardManagerProgram.layouts.createSenderPublicInstructionData.span);
    _RewardManagerProgram.layouts.createSenderPublicInstructionData.encode({
      instruction: RewardManagerInstruction.CreateSenderPublic,
      senderEthAddress,
      operatorEthAddress
    }, data);
    const keys = [
      { pubkey: rewardManagerState, isSigner: false, isWritable: false },
      { pubkey: authority, isSigner: false, isWritable: false },
      { pubkey: payer, isSigner: true, isWritable: true },
      { pubkey: sender, isSigner: false, isWritable: true },
      {
        pubkey: SYSVAR_INSTRUCTIONS_PUBKEY,
        isSigner: false,
        isWritable: false
      },
      { pubkey: SYSVAR_RENT_PUBKEY, isSigner: false, isWritable: false },
      { pubkey: SystemProgram.programId, isSigner: false, isWritable: false },
      ...existingSenders.map((pubkey2) => ({
        pubkey: pubkey2,
        isSigner: false,
        isWritable: false
      }))
    ];
    return new TransactionInstruction({
      programId: rewardManagerProgramId,
      keys,
      data
    });
  }
  static decodeCreateSenderPublicInstruction({ programId, keys: [rewardManagerState, authority, payer, sender, sysvarInstructions, rent, systemProgramId, ...existingSenders], data }) {
    return {
      programId,
      keys: {
        rewardManagerState,
        authority,
        payer,
        sender,
        sysvarInstructions,
        rent,
        systemProgramId,
        existingSenders
      },
      data: _RewardManagerProgram.layouts.createSenderPublicInstructionData.decode(data)
    };
  }
  static decodeDeleteSenderPublicInstruction({ programId, keys: [rewardManagerState, sender, refunder, sysvarInstructions, ...existingSenders] }) {
    return {
      programId,
      keys: {
        rewardManagerState,
        sender,
        refunder,
        sysvarInstructions,
        existingSenders
      },
      data: {
        instruction: RewardManagerInstruction.DeleteSenderPublic
      }
    };
  }
  static decodeSubmitAttestationInstruction({ programId, keys: [attestations, rewardManagerState, authority, payer, sender, rent, sysvarInstructions, systemProgramId], data }) {
    return {
      programId,
      keys: {
        attestations,
        rewardManagerState,
        authority,
        payer,
        sender,
        rent,
        sysvarInstructions,
        systemProgramId
      },
      data: _RewardManagerProgram.layouts.submitAttestationInstructionData.decode(data)
    };
  }
  static decodeEvaluateAttestationsInstruction({ programId, keys: [attestations, rewardManagerState, authority, rewardManagerTokenSource, destinationUserbank, disbursementAccount, antiAbuseOracle, payer, rent, tokenProgramId, systemProgramId], data }) {
    return {
      programId,
      keys: {
        attestations,
        rewardManagerState,
        authority,
        rewardManagerTokenSource,
        destinationUserbank,
        disbursementAccount,
        antiAbuseOracle,
        payer,
        rent,
        tokenProgramId,
        systemProgramId
      },
      data: _RewardManagerProgram.layouts.evaluateAttestationsInstructionData.decode(data)
    };
  }
  static decodeInstruction(instruction) {
    switch (instruction.data[0]) {
      case RewardManagerInstruction.Init:
      case RewardManagerInstruction.ChangeManagerAccount:
        throw new Error("Not Implemented");
      case RewardManagerInstruction.CreateSender:
        return _RewardManagerProgram.decodeCreateSenderInstruction(instruction);
      case RewardManagerInstruction.DeleteSender:
        throw new Error("Not Implemented");
      case RewardManagerInstruction.CreateSenderPublic:
        return _RewardManagerProgram.decodeCreateSenderPublicInstruction(instruction);
      case RewardManagerInstruction.DeleteSenderPublic:
        return _RewardManagerProgram.decodeDeleteSenderPublicInstruction(instruction);
      case RewardManagerInstruction.SubmitAttestation:
        return _RewardManagerProgram.decodeSubmitAttestationInstruction(instruction);
      case RewardManagerInstruction.EvaluateAttestations:
        return _RewardManagerProgram.decodeEvaluateAttestationsInstruction(instruction);
      default:
        throw new Error("Invalid RewardManager Instruction");
    }
  }
  static isCreateSenderInstruction(decoded) {
    return decoded.data.instruction === RewardManagerInstruction.CreateSender;
  }
  static isCreateSenderPublicInstruction(decoded) {
    return decoded.data.instruction === RewardManagerInstruction.CreateSenderPublic;
  }
  static isDeleteSenderPublicInstruction(decoded) {
    return decoded.data.instruction === RewardManagerInstruction.DeleteSenderPublic;
  }
  static isSubmitAttestationInstruction(decoded) {
    return decoded.data.instruction === RewardManagerInstruction.SubmitAttestation;
  }
  static isEvaluateAttestationsInstruction(decoded) {
    return decoded.data.instruction === RewardManagerInstruction.EvaluateAttestations;
  }
  static encodeAttestation(attestation) {
    const data = Buffer.alloc(attestationLayout().span);
    const span = attestationLayout().encode(attestation, data);
    return data.subarray(0, span);
  }
  static decodeAttestation(data) {
    return attestationLayout().decode(data);
  }
  static decodeAttestationsAccountData(maxAttestations, data) {
    const decoded = this.layouts.attestationsAccountData(maxAttestations).decode(data);
    decoded.messages = decoded.messages.slice(0, decoded.count);
    for (let i = 0; i < decoded.messages.length; i++) {
      if (decoded.messages[i].attestation.antiAbuseOracleEthAddress === "0x0000000000000000000000000000000000000000") {
        decoded.messages[i].attestation.antiAbuseOracleEthAddress = null;
      }
    }
    return decoded;
  }
  static deriveAuthority({ programId, rewardManagerState }) {
    return PublicKey.findProgramAddressSync([rewardManagerState.toBytes().slice(0, 32)], programId)[0];
  }
  static deriveSender({ ethAddress: wallet, programId, authority }) {
    const ethAddressData = ethAddress(wallet);
    const buffer3 = Buffer.alloc(ethAddressData.span);
    ethAddressData.encode(wallet, buffer3);
    const seed2 = Uint8Array.from([...SENDER_SEED_PREFIX_BYTES, ...buffer3]);
    return PublicKey.findProgramAddressSync([authority.toBytes().slice(0, 32), seed2], programId)[0];
  }
  static deriveAttestations({ disbursementId, programId, authority }) {
    const encoder4 = new TextEncoder();
    const seed2 = Uint8Array.from([
      ...ATTESTATIONS_SEED_PREFIX_BYTES,
      ...encoder4.encode(disbursementId)
    ]);
    return PublicKey.findProgramAddressSync([authority.toBytes().slice(0, 32), seed2], programId)[0];
  }
  static deriveDisbursement({ disbursementId, programId, authority }) {
    const encoder4 = new TextEncoder();
    const seed2 = Uint8Array.from([
      ...DISBURSEMENT_SEED_PREFIX_BYTES,
      ...encoder4.encode(disbursementId)
    ]);
    return PublicKey.findProgramAddressSync([authority.toBytes().slice(0, 32), seed2], programId)[0];
  }
  static encodeSignature(signature2) {
    const recoveryIdString = signature2.slice(-2);
    const recoveryIdBuffer = Buffer.from(recoveryIdString, "hex");
    const strippedSignature = signature2.substring(0, signature2.length - 2).replace("0x", "").padStart(128, "0").substring(0, 128);
    const signatureBuffer = Buffer.from(strippedSignature, "hex");
    return {
      signature: signatureBuffer,
      recoveryId: recoveryIdBuffer.readInt8()
    };
  }
  static decodeRewardManagerState(accountData) {
    return _RewardManagerProgram.layouts.rewardManagerStateData.decode(accountData);
  }
  static encodeSenderAttestation(attestation) {
    const data = Buffer.alloc(senderAttestationLayout().span);
    const span = senderAttestationLayout().encode(attestation, data);
    return data.subarray(0, span);
  }
};
_a = RewardManagerProgram;
RewardManagerProgram.programId = new PublicKey("DDZDcYdQFEMwcu2Mwo75yGFjJ1mUQyyXLWzhZLEVFcei");
RewardManagerProgram.layouts = {
  createSenderInstructionData: (0, import_buffer_layout55.struct)([
    (0, import_buffer_layout55.u8)("instruction"),
    ethAddress("senderEthAddress"),
    ethAddress("operatorEthAddress")
  ]),
  createSenderPublicInstructionData: (0, import_buffer_layout55.struct)([
    (0, import_buffer_layout55.u8)("instruction"),
    ethAddress("senderEthAddress"),
    ethAddress("operatorEthAddress")
  ]),
  evaluateAttestationsInstructionData: (0, import_buffer_layout55.struct)([
    (0, import_buffer_layout55.u8)("instruction"),
    u642("amount"),
    borshString(32, "disbursementId"),
    ethAddress("recipientEthAddress")
  ]),
  submitAttestationInstructionData: (0, import_buffer_layout55.struct)([
    (0, import_buffer_layout55.u8)("instruction"),
    borshString(32, "disbursementId")
  ]),
  rewardManagerStateData: (0, import_buffer_layout55.struct)([
    (0, import_buffer_layout55.u8)("version"),
    publicKey2("tokenAccount"),
    publicKey2("manager"),
    (0, import_buffer_layout55.u8)("minVotes")
  ]),
  attestationsAccountData: (maxAttestations) => (0, import_buffer_layout55.struct)([
    (0, import_buffer_layout55.u8)("version"),
    publicKey2("rewardManagerState"),
    (0, import_buffer_layout55.u8)("count"),
    (0, import_buffer_layout55.seq)((0, import_buffer_layout55.struct)([
      ethAddress("senderEthAddress"),
      attestationLayout("attestation"),
      // Though the actual attestation message is only 83 bytes, we allocate
      // 128 bytes for each element of this array on the program side.
      // Thus we add 45 bytes of padding here to be consistent.
      // See: https://github.com/AudiusProject/audius-protocol/blob/dde78ad7e26d9f6fb358fef5d240c5c7e2d25c66/solana-programs/reward-manager/program/src/state/verified_messages.rs#L99
      (0, import_buffer_layout55.blob)(45),
      ethAddress("operator")
    ]), maxAttestations, "messages")
  ])
};
RewardManagerProgram.createSubmitAttestationInstruction = ({ disbursementId, attestations, rewardManagerState, authority, payer, sender, rewardManagerProgramId = RewardManagerProgram.programId }) => {
  const b = Buffer.alloc(_a.layouts.submitAttestationInstructionData.span);
  const length2 = _a.layouts.submitAttestationInstructionData.encode({
    instruction: RewardManagerInstruction.SubmitAttestation,
    disbursementId
  }, b);
  const data = b.subarray(0, length2);
  const keys = [
    { pubkey: attestations, isSigner: false, isWritable: true },
    { pubkey: rewardManagerState, isSigner: false, isWritable: false },
    { pubkey: authority, isSigner: false, isWritable: false },
    { pubkey: payer, isSigner: true, isWritable: true },
    { pubkey: sender, isSigner: false, isWritable: false },
    { pubkey: SYSVAR_RENT_PUBKEY, isSigner: false, isWritable: false },
    {
      pubkey: SYSVAR_INSTRUCTIONS_PUBKEY,
      isSigner: false,
      isWritable: false
    },
    { pubkey: SystemProgram.programId, isSigner: false, isWritable: false }
  ];
  return new TransactionInstruction({
    programId: rewardManagerProgramId,
    keys,
    data
  });
};
RewardManagerProgram.createEvaluateAttestationsInstruction = ({ disbursementId, recipientEthAddress, amount, attestations, rewardManagerState, authority, rewardManagerTokenSource, destinationUserBank, disbursementAccount, antiAbuseOracle, payer, tokenProgramId = TOKEN_PROGRAM_ID, rewardManagerProgramId = RewardManagerProgram.programId }) => {
  const b = Buffer.alloc(RewardManagerProgram.layouts.evaluateAttestationsInstructionData.span);
  const length2 = RewardManagerProgram.layouts.evaluateAttestationsInstructionData.encode({
    instruction: RewardManagerInstruction.EvaluateAttestations,
    disbursementId,
    amount,
    recipientEthAddress
  }, b);
  const data = b.subarray(0, length2);
  const keys = [
    { pubkey: attestations, isSigner: false, isWritable: true },
    { pubkey: rewardManagerState, isSigner: false, isWritable: false },
    { pubkey: authority, isSigner: false, isWritable: false },
    { pubkey: rewardManagerTokenSource, isSigner: false, isWritable: true },
    { pubkey: destinationUserBank, isSigner: false, isWritable: true },
    { pubkey: disbursementAccount, isSigner: false, isWritable: true },
    { pubkey: antiAbuseOracle, isSigner: false, isWritable: false },
    { pubkey: payer, isSigner: true, isWritable: true },
    { pubkey: SYSVAR_RENT_PUBKEY, isSigner: false, isWritable: false },
    { pubkey: tokenProgramId, isSigner: false, isWritable: false },
    { pubkey: SystemProgram.programId, isSigner: false, isWritable: false }
  ];
  return new TransactionInstruction({
    programId: rewardManagerProgramId,
    keys,
    data
  });
};

// node_modules/@audius/spl/node_modules/@noble/hashes/esm/_assert.js
function number2(n) {
  if (!Number.isSafeInteger(n) || n < 0)
    throw new Error(`positive integer expected, not ${n}`);
}
function isBytes4(a) {
  return a instanceof Uint8Array || a != null && typeof a === "object" && a.constructor.name === "Uint8Array";
}
function bytes(b, ...lengths) {
  if (!isBytes4(b))
    throw new Error("Uint8Array expected");
  if (lengths.length > 0 && !lengths.includes(b.length))
    throw new Error(`Uint8Array expected of length ${lengths}, not of length=${b.length}`);
}
function exists2(instance2, checkFinished = true) {
  if (instance2.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance2.finished)
    throw new Error("Hash#digest() has already been called");
}
function output2(out, instance2) {
  bytes(out);
  const min = instance2.outputLen;
  if (out.length < min) {
    throw new Error(`digestInto() expects output buffer of length at least ${min}`);
  }
}

// node_modules/@audius/spl/node_modules/@noble/hashes/esm/_u64.js
var U32_MASK643 = BigInt(2 ** 32 - 1);
var _32n3 = BigInt(32);
function fromBig3(n, le = false) {
  if (le)
    return { h: Number(n & U32_MASK643), l: Number(n >> _32n3 & U32_MASK643) };
  return { h: Number(n >> _32n3 & U32_MASK643) | 0, l: Number(n & U32_MASK643) | 0 };
}
function split3(lst, le = false) {
  let Ah = new Uint32Array(lst.length);
  let Al = new Uint32Array(lst.length);
  for (let i = 0; i < lst.length; i++) {
    const { h, l } = fromBig3(lst[i], le);
    [Ah[i], Al[i]] = [h, l];
  }
  return [Ah, Al];
}
var rotlSH2 = (h, l, s) => h << s | l >>> 32 - s;
var rotlSL2 = (h, l, s) => l << s | h >>> 32 - s;
var rotlBH2 = (h, l, s) => l << s - 32 | h >>> 64 - s;
var rotlBL2 = (h, l, s) => h << s - 32 | l >>> 64 - s;

// node_modules/@audius/spl/node_modules/@noble/hashes/esm/crypto.js
var crypto4 = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;

// node_modules/@audius/spl/node_modules/@noble/hashes/esm/utils.js
var u326 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
var isLE3 = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
var byteSwap2 = (word) => word << 24 & 4278190080 | word << 8 & 16711680 | word >>> 8 & 65280 | word >>> 24 & 255;
function byteSwap322(arr) {
  for (let i = 0; i < arr.length; i++) {
    arr[i] = byteSwap2(arr[i]);
  }
}
var hexes3 = Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
function utf8ToBytes3(str2) {
  if (typeof str2 !== "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof str2}`);
  return new Uint8Array(new TextEncoder().encode(str2));
}
function toBytes5(data) {
  if (typeof data === "string")
    data = utf8ToBytes3(data);
  bytes(data);
  return data;
}
var Hash4 = class {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
};
var toStr = {}.toString;
function wrapConstructor2(hashCons) {
  const hashC = (msg) => hashCons().update(toBytes5(msg)).digest();
  const tmp = hashCons();
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = () => hashCons();
  return hashC;
}
function wrapXOFConstructorWithOpts(hashCons) {
  const hashC = (msg, opts) => hashCons(opts).update(toBytes5(msg)).digest();
  const tmp = hashCons({});
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = (opts) => hashCons(opts);
  return hashC;
}

// node_modules/@audius/spl/node_modules/@noble/hashes/esm/sha3.js
var SHA3_PI2 = [];
var SHA3_ROTL2 = [];
var _SHA3_IOTA2 = [];
var _0n10 = BigInt(0);
var _1n10 = BigInt(1);
var _2n8 = BigInt(2);
var _7n3 = BigInt(7);
var _256n2 = BigInt(256);
var _0x71n2 = BigInt(113);
for (let round = 0, R = _1n10, x = 1, y = 0; round < 24; round++) {
  [x, y] = [y, (2 * x + 3 * y) % 5];
  SHA3_PI2.push(2 * (5 * y + x));
  SHA3_ROTL2.push((round + 1) * (round + 2) / 2 % 64);
  let t = _0n10;
  for (let j = 0; j < 7; j++) {
    R = (R << _1n10 ^ (R >> _7n3) * _0x71n2) % _256n2;
    if (R & _2n8)
      t ^= _1n10 << (_1n10 << BigInt(j)) - _1n10;
  }
  _SHA3_IOTA2.push(t);
}
var [SHA3_IOTA_H2, SHA3_IOTA_L2] = split3(_SHA3_IOTA2, true);
var rotlH2 = (h, l, s) => s > 32 ? rotlBH2(h, l, s) : rotlSH2(h, l, s);
var rotlL2 = (h, l, s) => s > 32 ? rotlBL2(h, l, s) : rotlSL2(h, l, s);
function keccakP2(s, rounds = 24) {
  const B = new Uint32Array(5 * 2);
  for (let round = 24 - rounds; round < 24; round++) {
    for (let x = 0; x < 10; x++)
      B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
    for (let x = 0; x < 10; x += 2) {
      const idx1 = (x + 8) % 10;
      const idx0 = (x + 2) % 10;
      const B0 = B[idx0];
      const B1 = B[idx0 + 1];
      const Th = rotlH2(B0, B1, 1) ^ B[idx1];
      const Tl = rotlL2(B0, B1, 1) ^ B[idx1 + 1];
      for (let y = 0; y < 50; y += 10) {
        s[x + y] ^= Th;
        s[x + y + 1] ^= Tl;
      }
    }
    let curH = s[2];
    let curL = s[3];
    for (let t = 0; t < 24; t++) {
      const shift = SHA3_ROTL2[t];
      const Th = rotlH2(curH, curL, shift);
      const Tl = rotlL2(curH, curL, shift);
      const PI = SHA3_PI2[t];
      curH = s[PI];
      curL = s[PI + 1];
      s[PI] = Th;
      s[PI + 1] = Tl;
    }
    for (let y = 0; y < 50; y += 10) {
      for (let x = 0; x < 10; x++)
        B[x] = s[y + x];
      for (let x = 0; x < 10; x++)
        s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
    }
    s[0] ^= SHA3_IOTA_H2[round];
    s[1] ^= SHA3_IOTA_L2[round];
  }
  B.fill(0);
}
var Keccak2 = class _Keccak extends Hash4 {
  // NOTE: we accept arguments in bytes instead of bits here.
  constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
    super();
    this.blockLen = blockLen;
    this.suffix = suffix;
    this.outputLen = outputLen;
    this.enableXOF = enableXOF;
    this.rounds = rounds;
    this.pos = 0;
    this.posOut = 0;
    this.finished = false;
    this.destroyed = false;
    number2(outputLen);
    if (0 >= this.blockLen || this.blockLen >= 200)
      throw new Error("Sha3 supports only keccak-f1600 function");
    this.state = new Uint8Array(200);
    this.state32 = u326(this.state);
  }
  keccak() {
    if (!isLE3)
      byteSwap322(this.state32);
    keccakP2(this.state32, this.rounds);
    if (!isLE3)
      byteSwap322(this.state32);
    this.posOut = 0;
    this.pos = 0;
  }
  update(data) {
    exists2(this);
    const { blockLen, state } = this;
    data = toBytes5(data);
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      for (let i = 0; i < take; i++)
        state[this.pos++] ^= data[pos++];
      if (this.pos === blockLen)
        this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished)
      return;
    this.finished = true;
    const { state, suffix, pos, blockLen } = this;
    state[pos] ^= suffix;
    if ((suffix & 128) !== 0 && pos === blockLen - 1)
      this.keccak();
    state[blockLen - 1] ^= 128;
    this.keccak();
  }
  writeInto(out) {
    exists2(this, false);
    bytes(out);
    this.finish();
    const bufferOut = this.state;
    const { blockLen } = this;
    for (let pos = 0, len = out.length; pos < len; ) {
      if (this.posOut >= blockLen)
        this.keccak();
      const take = Math.min(blockLen - this.posOut, len - pos);
      out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
      this.posOut += take;
      pos += take;
    }
    return out;
  }
  xofInto(out) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible for this instance");
    return this.writeInto(out);
  }
  xof(bytes3) {
    number2(bytes3);
    return this.xofInto(new Uint8Array(bytes3));
  }
  digestInto(out) {
    output2(out, this);
    if (this.finished)
      throw new Error("digest() was already called");
    this.writeInto(out);
    this.destroy();
    return out;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = true;
    this.state.fill(0);
  }
  _cloneInto(to) {
    const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
    to || (to = new _Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
    to.state32.set(this.state32);
    to.pos = this.pos;
    to.posOut = this.posOut;
    to.finished = this.finished;
    to.rounds = rounds;
    to.suffix = suffix;
    to.outputLen = outputLen;
    to.enableXOF = enableXOF;
    to.destroyed = this.destroyed;
    return to;
  }
};
var gen2 = (suffix, blockLen, outputLen) => wrapConstructor2(() => new Keccak2(blockLen, suffix, outputLen));
var sha3_2242 = gen2(6, 144, 224 / 8);
var sha3_2562 = gen2(6, 136, 256 / 8);
var sha3_3842 = gen2(6, 104, 384 / 8);
var sha3_5122 = gen2(6, 72, 512 / 8);
var keccak_2242 = gen2(1, 144, 224 / 8);
var keccak_2562 = gen2(1, 136, 256 / 8);
var keccak_3842 = gen2(1, 104, 384 / 8);
var keccak_5122 = gen2(1, 72, 512 / 8);
var genShake2 = (suffix, blockLen, outputLen) => wrapXOFConstructorWithOpts((opts = {}) => new Keccak2(blockLen, suffix, opts.dkLen === void 0 ? outputLen : opts.dkLen, true));
var shake1282 = genShake2(31, 168, 128 / 8);
var shake2562 = genShake2(31, 136, 256 / 8);

// node_modules/@noble/secp256k1/lib/esm/index.js
var nodeCrypto = __toESM(require_crypto());
var _0n11 = BigInt(0);
var _1n11 = BigInt(1);
var _2n9 = BigInt(2);
var _3n4 = BigInt(3);
var _8n4 = BigInt(8);
var CURVE = Object.freeze({
  a: _0n11,
  b: BigInt(7),
  P: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
  n: BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
  h: _1n11,
  Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
  Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
  beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee")
});
function weistrass(x) {
  const { a, b } = CURVE;
  const x2 = mod2(x * x);
  const x3 = mod2(x2 * x);
  return mod2(x3 + a * x + b);
}
var USE_ENDOMORPHISM = CURVE.a === _0n11;
var ShaError = class extends Error {
  constructor(message) {
    super(message);
  }
};
var JacobianPoint = class _JacobianPoint {
  constructor(x, y, z2) {
    this.x = x;
    this.y = y;
    this.z = z2;
  }
  static fromAffine(p) {
    if (!(p instanceof Point)) {
      throw new TypeError("JacobianPoint#fromAffine: expected Point");
    }
    return new _JacobianPoint(p.x, p.y, _1n11);
  }
  static toAffineBatch(points) {
    const toInv = invertBatch(points.map((p) => p.z));
    return points.map((p, i) => p.toAffine(toInv[i]));
  }
  static normalizeZ(points) {
    return _JacobianPoint.toAffineBatch(points).map(_JacobianPoint.fromAffine);
  }
  equals(other) {
    if (!(other instanceof _JacobianPoint))
      throw new TypeError("JacobianPoint expected");
    const { x: X1, y: Y1, z: Z1 } = this;
    const { x: X2, y: Y2, z: Z2 } = other;
    const Z1Z1 = mod2(Z1 * Z1);
    const Z2Z2 = mod2(Z2 * Z2);
    const U1 = mod2(X1 * Z2Z2);
    const U2 = mod2(X2 * Z1Z1);
    const S1 = mod2(mod2(Y1 * Z2) * Z2Z2);
    const S2 = mod2(mod2(Y2 * Z1) * Z1Z1);
    return U1 === U2 && S1 === S2;
  }
  negate() {
    return new _JacobianPoint(this.x, mod2(-this.y), this.z);
  }
  double() {
    const { x: X1, y: Y1, z: Z1 } = this;
    const A = mod2(X1 * X1);
    const B = mod2(Y1 * Y1);
    const C = mod2(B * B);
    const x1b = X1 + B;
    const D = mod2(_2n9 * (mod2(x1b * x1b) - A - C));
    const E = mod2(_3n4 * A);
    const F = mod2(E * E);
    const X3 = mod2(F - _2n9 * D);
    const Y3 = mod2(E * (D - X3) - _8n4 * C);
    const Z3 = mod2(_2n9 * Y1 * Z1);
    return new _JacobianPoint(X3, Y3, Z3);
  }
  add(other) {
    if (!(other instanceof _JacobianPoint))
      throw new TypeError("JacobianPoint expected");
    const { x: X1, y: Y1, z: Z1 } = this;
    const { x: X2, y: Y2, z: Z2 } = other;
    if (X2 === _0n11 || Y2 === _0n11)
      return this;
    if (X1 === _0n11 || Y1 === _0n11)
      return other;
    const Z1Z1 = mod2(Z1 * Z1);
    const Z2Z2 = mod2(Z2 * Z2);
    const U1 = mod2(X1 * Z2Z2);
    const U2 = mod2(X2 * Z1Z1);
    const S1 = mod2(mod2(Y1 * Z2) * Z2Z2);
    const S2 = mod2(mod2(Y2 * Z1) * Z1Z1);
    const H = mod2(U2 - U1);
    const r = mod2(S2 - S1);
    if (H === _0n11) {
      if (r === _0n11) {
        return this.double();
      } else {
        return _JacobianPoint.ZERO;
      }
    }
    const HH = mod2(H * H);
    const HHH = mod2(H * HH);
    const V = mod2(U1 * HH);
    const X3 = mod2(r * r - HHH - _2n9 * V);
    const Y3 = mod2(r * (V - X3) - S1 * HHH);
    const Z3 = mod2(Z1 * Z2 * H);
    return new _JacobianPoint(X3, Y3, Z3);
  }
  subtract(other) {
    return this.add(other.negate());
  }
  multiplyUnsafe(scalar) {
    const P0 = _JacobianPoint.ZERO;
    if (typeof scalar === "bigint" && scalar === _0n11)
      return P0;
    let n = normalizeScalar(scalar);
    if (n === _1n11)
      return this;
    if (!USE_ENDOMORPHISM) {
      let p = P0;
      let d2 = this;
      while (n > _0n11) {
        if (n & _1n11)
          p = p.add(d2);
        d2 = d2.double();
        n >>= _1n11;
      }
      return p;
    }
    let { k1neg, k1, k2neg, k2 } = splitScalarEndo(n);
    let k1p = P0;
    let k2p = P0;
    let d = this;
    while (k1 > _0n11 || k2 > _0n11) {
      if (k1 & _1n11)
        k1p = k1p.add(d);
      if (k2 & _1n11)
        k2p = k2p.add(d);
      d = d.double();
      k1 >>= _1n11;
      k2 >>= _1n11;
    }
    if (k1neg)
      k1p = k1p.negate();
    if (k2neg)
      k2p = k2p.negate();
    k2p = new _JacobianPoint(mod2(k2p.x * CURVE.beta), k2p.y, k2p.z);
    return k1p.add(k2p);
  }
  precomputeWindow(W) {
    const windows = USE_ENDOMORPHISM ? 128 / W + 1 : 256 / W + 1;
    const points = [];
    let p = this;
    let base3 = p;
    for (let window2 = 0; window2 < windows; window2++) {
      base3 = p;
      points.push(base3);
      for (let i = 1; i < 2 ** (W - 1); i++) {
        base3 = base3.add(p);
        points.push(base3);
      }
      p = base3.double();
    }
    return points;
  }
  wNAF(n, affinePoint) {
    if (!affinePoint && this.equals(_JacobianPoint.BASE))
      affinePoint = Point.BASE;
    const W = affinePoint && affinePoint._WINDOW_SIZE || 1;
    if (256 % W) {
      throw new Error("Point#wNAF: Invalid precomputation window, must be power of 2");
    }
    let precomputes = affinePoint && pointPrecomputes2.get(affinePoint);
    if (!precomputes) {
      precomputes = this.precomputeWindow(W);
      if (affinePoint && W !== 1) {
        precomputes = _JacobianPoint.normalizeZ(precomputes);
        pointPrecomputes2.set(affinePoint, precomputes);
      }
    }
    let p = _JacobianPoint.ZERO;
    let f3 = _JacobianPoint.ZERO;
    const windows = 1 + (USE_ENDOMORPHISM ? 128 / W : 256 / W);
    const windowSize = 2 ** (W - 1);
    const mask3 = BigInt(2 ** W - 1);
    const maxNumber = 2 ** W;
    const shiftBy = BigInt(W);
    for (let window2 = 0; window2 < windows; window2++) {
      const offset3 = window2 * windowSize;
      let wbits = Number(n & mask3);
      n >>= shiftBy;
      if (wbits > windowSize) {
        wbits -= maxNumber;
        n += _1n11;
      }
      if (wbits === 0) {
        let pr = precomputes[offset3];
        if (window2 % 2)
          pr = pr.negate();
        f3 = f3.add(pr);
      } else {
        let cached = precomputes[offset3 + Math.abs(wbits) - 1];
        if (wbits < 0)
          cached = cached.negate();
        p = p.add(cached);
      }
    }
    return { p, f: f3 };
  }
  multiply(scalar, affinePoint) {
    let n = normalizeScalar(scalar);
    let point;
    let fake;
    if (USE_ENDOMORPHISM) {
      const { k1neg, k1, k2neg, k2 } = splitScalarEndo(n);
      let { p: k1p, f: f1p } = this.wNAF(k1, affinePoint);
      let { p: k2p, f: f2p } = this.wNAF(k2, affinePoint);
      if (k1neg)
        k1p = k1p.negate();
      if (k2neg)
        k2p = k2p.negate();
      k2p = new _JacobianPoint(mod2(k2p.x * CURVE.beta), k2p.y, k2p.z);
      point = k1p.add(k2p);
      fake = f1p.add(f2p);
    } else {
      const { p, f: f3 } = this.wNAF(n, affinePoint);
      point = p;
      fake = f3;
    }
    return _JacobianPoint.normalizeZ([point, fake])[0];
  }
  toAffine(invZ = invert2(this.z)) {
    const { x, y, z: z2 } = this;
    const iz1 = invZ;
    const iz2 = mod2(iz1 * iz1);
    const iz3 = mod2(iz2 * iz1);
    const ax = mod2(x * iz2);
    const ay = mod2(y * iz3);
    const zz = mod2(z2 * iz1);
    if (zz !== _1n11)
      throw new Error("invZ was invalid");
    return new Point(ax, ay);
  }
};
JacobianPoint.BASE = new JacobianPoint(CURVE.Gx, CURVE.Gy, _1n11);
JacobianPoint.ZERO = new JacobianPoint(_0n11, _1n11, _0n11);
var pointPrecomputes2 = /* @__PURE__ */ new WeakMap();
var Point = class _Point {
  constructor(x, y) {
    this.x = x;
    this.y = y;
  }
  _setWindowSize(windowSize) {
    this._WINDOW_SIZE = windowSize;
    pointPrecomputes2.delete(this);
  }
  hasEvenY() {
    return this.y % _2n9 === _0n11;
  }
  static fromCompressedHex(bytes3) {
    const isShort = bytes3.length === 32;
    const x = bytesToNumber2(isShort ? bytes3 : bytes3.subarray(1));
    if (!isValidFieldElement(x))
      throw new Error("Point is not on curve");
    const y2 = weistrass(x);
    let y = sqrtMod2(y2);
    const isYOdd = (y & _1n11) === _1n11;
    if (isShort) {
      if (isYOdd)
        y = mod2(-y);
    } else {
      const isFirstByteOdd = (bytes3[0] & 1) === 1;
      if (isFirstByteOdd !== isYOdd)
        y = mod2(-y);
    }
    const point = new _Point(x, y);
    point.assertValidity();
    return point;
  }
  static fromUncompressedHex(bytes3) {
    const x = bytesToNumber2(bytes3.subarray(1, 33));
    const y = bytesToNumber2(bytes3.subarray(33, 65));
    const point = new _Point(x, y);
    point.assertValidity();
    return point;
  }
  static fromHex(hex3) {
    const bytes3 = ensureBytes2(hex3);
    const len = bytes3.length;
    const header = bytes3[0];
    if (len === 32 || len === 33 && (header === 2 || header === 3)) {
      return this.fromCompressedHex(bytes3);
    }
    if (len === 65 && header === 4)
      return this.fromUncompressedHex(bytes3);
    throw new Error(`Point.fromHex: received invalid point. Expected 32-33 compressed bytes or 65 uncompressed bytes, not ${len}`);
  }
  static fromPrivateKey(privateKey) {
    return _Point.BASE.multiply(normalizePrivateKey(privateKey));
  }
  static fromSignature(msgHash, signature2, recovery) {
    msgHash = ensureBytes2(msgHash);
    const h = truncateHash(msgHash);
    const { r, s } = normalizeSignature(signature2);
    if (recovery !== 0 && recovery !== 1) {
      throw new Error("Cannot recover signature: invalid recovery bit");
    }
    const prefix = recovery & 1 ? "03" : "02";
    const R = _Point.fromHex(prefix + numTo32bStr(r));
    const { n } = CURVE;
    const rinv = invert2(r, n);
    const u1 = mod2(-h * rinv, n);
    const u2 = mod2(s * rinv, n);
    const Q = _Point.BASE.multiplyAndAddUnsafe(R, u1, u2);
    if (!Q)
      throw new Error("Cannot recover signature: point at infinify");
    Q.assertValidity();
    return Q;
  }
  toRawBytes(isCompressed = false) {
    return hexToBytes3(this.toHex(isCompressed));
  }
  toHex(isCompressed = false) {
    const x = numTo32bStr(this.x);
    if (isCompressed) {
      const prefix = this.hasEvenY() ? "02" : "03";
      return `${prefix}${x}`;
    } else {
      return `04${x}${numTo32bStr(this.y)}`;
    }
  }
  toHexX() {
    return this.toHex(true).slice(2);
  }
  toRawX() {
    return this.toRawBytes(true).slice(1);
  }
  assertValidity() {
    const msg = "Point is not on elliptic curve";
    const { x, y } = this;
    if (!isValidFieldElement(x) || !isValidFieldElement(y))
      throw new Error(msg);
    const left = mod2(y * y);
    const right = weistrass(x);
    if (mod2(left - right) !== _0n11)
      throw new Error(msg);
  }
  equals(other) {
    return this.x === other.x && this.y === other.y;
  }
  negate() {
    return new _Point(this.x, mod2(-this.y));
  }
  double() {
    return JacobianPoint.fromAffine(this).double().toAffine();
  }
  add(other) {
    return JacobianPoint.fromAffine(this).add(JacobianPoint.fromAffine(other)).toAffine();
  }
  subtract(other) {
    return this.add(other.negate());
  }
  multiply(scalar) {
    return JacobianPoint.fromAffine(this).multiply(scalar, this).toAffine();
  }
  multiplyAndAddUnsafe(Q, a, b) {
    const P = JacobianPoint.fromAffine(this);
    const aP = a === _0n11 || a === _1n11 || this !== _Point.BASE ? P.multiplyUnsafe(a) : P.multiply(a);
    const bQ = JacobianPoint.fromAffine(Q).multiplyUnsafe(b);
    const sum = aP.add(bQ);
    return sum.equals(JacobianPoint.ZERO) ? void 0 : sum.toAffine();
  }
};
Point.BASE = new Point(CURVE.Gx, CURVE.Gy);
Point.ZERO = new Point(_0n11, _0n11);
function sliceDER(s) {
  return Number.parseInt(s[0], 16) >= 8 ? "00" + s : s;
}
function parseDERInt(data) {
  if (data.length < 2 || data[0] !== 2) {
    throw new Error(`Invalid signature integer tag: ${bytesToHex3(data)}`);
  }
  const len = data[1];
  const res = data.subarray(2, len + 2);
  if (!len || res.length !== len) {
    throw new Error(`Invalid signature integer: wrong length`);
  }
  if (res[0] === 0 && res[1] <= 127) {
    throw new Error("Invalid signature integer: trailing length");
  }
  return { data: bytesToNumber2(res), left: data.subarray(len + 2) };
}
function parseDERSignature(data) {
  if (data.length < 2 || data[0] != 48) {
    throw new Error(`Invalid signature tag: ${bytesToHex3(data)}`);
  }
  if (data[1] !== data.length - 2) {
    throw new Error("Invalid signature: incorrect length");
  }
  const { data: r, left: sBytes } = parseDERInt(data.subarray(2));
  const { data: s, left: rBytesLeft } = parseDERInt(sBytes);
  if (rBytesLeft.length) {
    throw new Error(`Invalid signature: left bytes after parsing: ${bytesToHex3(rBytesLeft)}`);
  }
  return { r, s };
}
var Signature = class _Signature {
  constructor(r, s) {
    this.r = r;
    this.s = s;
    this.assertValidity();
  }
  static fromCompact(hex3) {
    const arr = hex3 instanceof Uint8Array;
    const name = "Signature.fromCompact";
    if (typeof hex3 !== "string" && !arr)
      throw new TypeError(`${name}: Expected string or Uint8Array`);
    const str2 = arr ? bytesToHex3(hex3) : hex3;
    if (str2.length !== 128)
      throw new Error(`${name}: Expected 64-byte hex`);
    return new _Signature(hexToNumber3(str2.slice(0, 64)), hexToNumber3(str2.slice(64, 128)));
  }
  static fromDER(hex3) {
    const arr = hex3 instanceof Uint8Array;
    if (typeof hex3 !== "string" && !arr)
      throw new TypeError(`Signature.fromDER: Expected string or Uint8Array`);
    const { r, s } = parseDERSignature(arr ? hex3 : hexToBytes3(hex3));
    return new _Signature(r, s);
  }
  static fromHex(hex3) {
    return this.fromDER(hex3);
  }
  assertValidity() {
    const { r, s } = this;
    if (!isWithinCurveOrder(r))
      throw new Error("Invalid Signature: r must be 0 < r < n");
    if (!isWithinCurveOrder(s))
      throw new Error("Invalid Signature: s must be 0 < s < n");
  }
  hasHighS() {
    const HALF = CURVE.n >> _1n11;
    return this.s > HALF;
  }
  normalizeS() {
    return this.hasHighS() ? new _Signature(this.r, CURVE.n - this.s) : this;
  }
  toDERRawBytes(isCompressed = false) {
    return hexToBytes3(this.toDERHex(isCompressed));
  }
  toDERHex(isCompressed = false) {
    const sHex = sliceDER(numberToHexUnpadded2(this.s));
    if (isCompressed)
      return sHex;
    const rHex = sliceDER(numberToHexUnpadded2(this.r));
    const rLen = numberToHexUnpadded2(rHex.length / 2);
    const sLen = numberToHexUnpadded2(sHex.length / 2);
    const length2 = numberToHexUnpadded2(rHex.length / 2 + sHex.length / 2 + 4);
    return `30${length2}02${rLen}${rHex}02${sLen}${sHex}`;
  }
  toRawBytes() {
    return this.toDERRawBytes();
  }
  toHex() {
    return this.toDERHex();
  }
  toCompactRawBytes() {
    return hexToBytes3(this.toCompactHex());
  }
  toCompactHex() {
    return numTo32bStr(this.r) + numTo32bStr(this.s);
  }
};
function concatBytes3(...arrays) {
  if (!arrays.every((b) => b instanceof Uint8Array))
    throw new Error("Uint8Array list expected");
  if (arrays.length === 1)
    return arrays[0];
  const length2 = arrays.reduce((a, arr) => a + arr.length, 0);
  const result = new Uint8Array(length2);
  for (let i = 0, pad3 = 0; i < arrays.length; i++) {
    const arr = arrays[i];
    result.set(arr, pad3);
    pad3 += arr.length;
  }
  return result;
}
var hexes4 = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, "0"));
function bytesToHex3(uint8a) {
  if (!(uint8a instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  let hex3 = "";
  for (let i = 0; i < uint8a.length; i++) {
    hex3 += hexes4[uint8a[i]];
  }
  return hex3;
}
var POW_2_256 = BigInt("0x10000000000000000000000000000000000000000000000000000000000000000");
function numTo32bStr(num2) {
  if (typeof num2 !== "bigint")
    throw new Error("Expected bigint");
  if (!(_0n11 <= num2 && num2 < POW_2_256))
    throw new Error("Expected number < 2^256");
  return num2.toString(16).padStart(64, "0");
}
function numTo32b(num2) {
  const b = hexToBytes3(numTo32bStr(num2));
  if (b.length !== 32)
    throw new Error("Error: expected 32 bytes");
  return b;
}
function numberToHexUnpadded2(num2) {
  const hex3 = num2.toString(16);
  return hex3.length & 1 ? `0${hex3}` : hex3;
}
function hexToNumber3(hex3) {
  if (typeof hex3 !== "string") {
    throw new TypeError("hexToNumber: expected string, got " + typeof hex3);
  }
  return BigInt(`0x${hex3}`);
}
function hexToBytes3(hex3) {
  if (typeof hex3 !== "string") {
    throw new TypeError("hexToBytes: expected string, got " + typeof hex3);
  }
  if (hex3.length % 2)
    throw new Error("hexToBytes: received invalid unpadded hex" + hex3.length);
  const array4 = new Uint8Array(hex3.length / 2);
  for (let i = 0; i < array4.length; i++) {
    const j = i * 2;
    const hexByte = hex3.slice(j, j + 2);
    const byte = Number.parseInt(hexByte, 16);
    if (Number.isNaN(byte) || byte < 0)
      throw new Error("Invalid byte sequence");
    array4[i] = byte;
  }
  return array4;
}
function bytesToNumber2(bytes3) {
  return hexToNumber3(bytesToHex3(bytes3));
}
function ensureBytes2(hex3) {
  return hex3 instanceof Uint8Array ? Uint8Array.from(hex3) : hexToBytes3(hex3);
}
function normalizeScalar(num2) {
  if (typeof num2 === "number" && Number.isSafeInteger(num2) && num2 > 0)
    return BigInt(num2);
  if (typeof num2 === "bigint" && isWithinCurveOrder(num2))
    return num2;
  throw new TypeError("Expected valid private scalar: 0 < scalar < curve.n");
}
function mod2(a, b = CURVE.P) {
  const result = a % b;
  return result >= _0n11 ? result : b + result;
}
function pow22(x, power) {
  const { P } = CURVE;
  let res = x;
  while (power-- > _0n11) {
    res *= res;
    res %= P;
  }
  return res;
}
function sqrtMod2(x) {
  const { P } = CURVE;
  const _6n = BigInt(6);
  const _11n = BigInt(11);
  const _22n = BigInt(22);
  const _23n = BigInt(23);
  const _44n = BigInt(44);
  const _88n = BigInt(88);
  const b2 = x * x * x % P;
  const b3 = b2 * b2 * x % P;
  const b6 = pow22(b3, _3n4) * b3 % P;
  const b9 = pow22(b6, _3n4) * b3 % P;
  const b11 = pow22(b9, _2n9) * b2 % P;
  const b22 = pow22(b11, _11n) * b11 % P;
  const b44 = pow22(b22, _22n) * b22 % P;
  const b88 = pow22(b44, _44n) * b44 % P;
  const b176 = pow22(b88, _88n) * b88 % P;
  const b220 = pow22(b176, _44n) * b44 % P;
  const b223 = pow22(b220, _3n4) * b3 % P;
  const t1 = pow22(b223, _23n) * b22 % P;
  const t2 = pow22(t1, _6n) * b2 % P;
  return pow22(t2, _2n9);
}
function invert2(number5, modulo = CURVE.P) {
  if (number5 === _0n11 || modulo <= _0n11) {
    throw new Error(`invert: expected positive integers, got n=${number5} mod=${modulo}`);
  }
  let a = mod2(number5, modulo);
  let b = modulo;
  let x = _0n11, y = _1n11, u = _1n11, v = _0n11;
  while (a !== _0n11) {
    const q = b / a;
    const r = b % a;
    const m = x - u * q;
    const n = y - v * q;
    b = a, a = r, x = u, y = v, u = m, v = n;
  }
  const gcd2 = b;
  if (gcd2 !== _1n11)
    throw new Error("invert: does not exist");
  return mod2(x, modulo);
}
function invertBatch(nums, p = CURVE.P) {
  const scratch = new Array(nums.length);
  const lastMultiplied = nums.reduce((acc, num2, i) => {
    if (num2 === _0n11)
      return acc;
    scratch[i] = acc;
    return mod2(acc * num2, p);
  }, _1n11);
  const inverted = invert2(lastMultiplied, p);
  nums.reduceRight((acc, num2, i) => {
    if (num2 === _0n11)
      return acc;
    scratch[i] = mod2(acc * scratch[i], p);
    return mod2(acc * num2, p);
  }, inverted);
  return scratch;
}
var divNearest2 = (a, b) => (a + b / _2n9) / b;
var ENDO = {
  a1: BigInt("0x3086d221a7d46bcde86c90e49284eb15"),
  b1: -_1n11 * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),
  a2: BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),
  b2: BigInt("0x3086d221a7d46bcde86c90e49284eb15"),
  POW_2_128: BigInt("0x100000000000000000000000000000000")
};
function splitScalarEndo(k) {
  const { n } = CURVE;
  const { a1, b1, a2, b2, POW_2_128 } = ENDO;
  const c1 = divNearest2(b2 * k, n);
  const c2 = divNearest2(-b1 * k, n);
  let k1 = mod2(k - c1 * a1 - c2 * a2, n);
  let k2 = mod2(-c1 * b1 - c2 * b2, n);
  const k1neg = k1 > POW_2_128;
  const k2neg = k2 > POW_2_128;
  if (k1neg)
    k1 = n - k1;
  if (k2neg)
    k2 = n - k2;
  if (k1 > POW_2_128 || k2 > POW_2_128) {
    throw new Error("splitScalarEndo: Endomorphism failed, k=" + k);
  }
  return { k1neg, k1, k2neg, k2 };
}
function truncateHash(hash3) {
  const { n } = CURVE;
  const byteLength2 = hash3.length;
  const delta = byteLength2 * 8 - 256;
  let h = bytesToNumber2(hash3);
  if (delta > 0)
    h = h >> BigInt(delta);
  if (h >= n)
    h -= n;
  return h;
}
var _sha256Sync;
var _hmacSha256Sync;
var HmacDrbg = class {
  constructor() {
    this.v = new Uint8Array(32).fill(1);
    this.k = new Uint8Array(32).fill(0);
    this.counter = 0;
  }
  hmac(...values) {
    return utils.hmacSha256(this.k, ...values);
  }
  hmacSync(...values) {
    return _hmacSha256Sync(this.k, ...values);
  }
  checkSync() {
    if (typeof _hmacSha256Sync !== "function")
      throw new ShaError("hmacSha256Sync needs to be set");
  }
  incr() {
    if (this.counter >= 1e3)
      throw new Error("Tried 1,000 k values for sign(), all were invalid");
    this.counter += 1;
  }
  async reseed(seed2 = new Uint8Array()) {
    this.k = await this.hmac(this.v, Uint8Array.from([0]), seed2);
    this.v = await this.hmac(this.v);
    if (seed2.length === 0)
      return;
    this.k = await this.hmac(this.v, Uint8Array.from([1]), seed2);
    this.v = await this.hmac(this.v);
  }
  reseedSync(seed2 = new Uint8Array()) {
    this.checkSync();
    this.k = this.hmacSync(this.v, Uint8Array.from([0]), seed2);
    this.v = this.hmacSync(this.v);
    if (seed2.length === 0)
      return;
    this.k = this.hmacSync(this.v, Uint8Array.from([1]), seed2);
    this.v = this.hmacSync(this.v);
  }
  async generate() {
    this.incr();
    this.v = await this.hmac(this.v);
    return this.v;
  }
  generateSync() {
    this.checkSync();
    this.incr();
    this.v = this.hmacSync(this.v);
    return this.v;
  }
};
function isWithinCurveOrder(num2) {
  return _0n11 < num2 && num2 < CURVE.n;
}
function isValidFieldElement(num2) {
  return _0n11 < num2 && num2 < CURVE.P;
}
function kmdToSig(kBytes, m, d) {
  const k = bytesToNumber2(kBytes);
  if (!isWithinCurveOrder(k))
    return;
  const { n } = CURVE;
  const q = Point.BASE.multiply(k);
  const r = mod2(q.x, n);
  if (r === _0n11)
    return;
  const s = mod2(invert2(k, n) * mod2(m + d * r, n), n);
  if (s === _0n11)
    return;
  const sig = new Signature(r, s);
  const recovery = (q.x === sig.r ? 0 : 2) | Number(q.y & _1n11);
  return { sig, recovery };
}
function normalizePrivateKey(key) {
  let num2;
  if (typeof key === "bigint") {
    num2 = key;
  } else if (typeof key === "number" && Number.isSafeInteger(key) && key > 0) {
    num2 = BigInt(key);
  } else if (typeof key === "string") {
    if (key.length !== 64)
      throw new Error("Expected 32 bytes of private key");
    num2 = hexToNumber3(key);
  } else if (key instanceof Uint8Array) {
    if (key.length !== 32)
      throw new Error("Expected 32 bytes of private key");
    num2 = bytesToNumber2(key);
  } else {
    throw new TypeError("Expected valid private key");
  }
  if (!isWithinCurveOrder(num2))
    throw new Error("Expected private key: 0 < key < n");
  return num2;
}
function normalizePublicKey(publicKey5) {
  if (publicKey5 instanceof Point) {
    publicKey5.assertValidity();
    return publicKey5;
  } else {
    return Point.fromHex(publicKey5);
  }
}
function normalizeSignature(signature2) {
  if (signature2 instanceof Signature) {
    signature2.assertValidity();
    return signature2;
  }
  try {
    return Signature.fromDER(signature2);
  } catch (error) {
    return Signature.fromCompact(signature2);
  }
}
function isProbPub(item) {
  const arr = item instanceof Uint8Array;
  const str2 = typeof item === "string";
  const len = (arr || str2) && item.length;
  if (arr)
    return len === 33 || len === 65;
  if (str2)
    return len === 66 || len === 130;
  if (item instanceof Point)
    return true;
  return false;
}
function getSharedSecret(privateA, publicB, isCompressed = false) {
  if (isProbPub(privateA))
    throw new TypeError("getSharedSecret: first arg must be private key");
  if (!isProbPub(publicB))
    throw new TypeError("getSharedSecret: second arg must be public key");
  const b = normalizePublicKey(publicB);
  b.assertValidity();
  return b.multiply(normalizePrivateKey(privateA)).toRawBytes(isCompressed);
}
function bits2int(bytes3) {
  const slice3 = bytes3.length > 32 ? bytes3.slice(0, 32) : bytes3;
  return bytesToNumber2(slice3);
}
function bits2octets(bytes3) {
  const z1 = bits2int(bytes3);
  const z2 = mod2(z1, CURVE.n);
  return int2octets(z2 < _0n11 ? z1 : z2);
}
function int2octets(num2) {
  return numTo32b(num2);
}
function initSigArgs(msgHash, privateKey, extraEntropy) {
  if (msgHash == null)
    throw new Error(`sign: expected valid message hash, not "${msgHash}"`);
  const h1 = ensureBytes2(msgHash);
  const d = normalizePrivateKey(privateKey);
  const seedArgs = [int2octets(d), bits2octets(h1)];
  if (extraEntropy != null) {
    if (extraEntropy === true)
      extraEntropy = utils.randomBytes(32);
    const e = ensureBytes2(extraEntropy);
    if (e.length !== 32)
      throw new Error("sign: Expected 32 bytes of extra data");
    seedArgs.push(e);
  }
  const seed2 = concatBytes3(...seedArgs);
  const m = bits2int(h1);
  return { seed: seed2, m, d };
}
function finalizeSig(recSig, opts) {
  let { sig, recovery } = recSig;
  const { canonical, der, recovered } = Object.assign({ canonical: true, der: true }, opts);
  if (canonical && sig.hasHighS()) {
    sig = sig.normalizeS();
    recovery ^= 1;
  }
  const hashed = der ? sig.toDERRawBytes() : sig.toCompactRawBytes();
  return recovered ? [hashed, recovery] : hashed;
}
async function sign2(msgHash, privKey, opts = {}) {
  const { seed: seed2, m, d } = initSigArgs(msgHash, privKey, opts.extraEntropy);
  let sig;
  const drbg = new HmacDrbg();
  await drbg.reseed(seed2);
  while (!(sig = kmdToSig(await drbg.generate(), m, d)))
    await drbg.reseed();
  return finalizeSig(sig, opts);
}
Point.BASE._setWindowSize(8);
var crypto5 = {
  node: nodeCrypto,
  web: typeof self === "object" && "crypto" in self ? self.crypto : void 0
};
var TAGGED_HASH_PREFIXES2 = {};
var utils = {
  bytesToHex: bytesToHex3,
  hexToBytes: hexToBytes3,
  concatBytes: concatBytes3,
  mod: mod2,
  invert: invert2,
  isValidPrivateKey(privateKey) {
    try {
      normalizePrivateKey(privateKey);
      return true;
    } catch (error) {
      return false;
    }
  },
  _bigintTo32Bytes: numTo32b,
  _normalizePrivateKey: normalizePrivateKey,
  hashToPrivateKey: (hash3) => {
    hash3 = ensureBytes2(hash3);
    if (hash3.length < 40 || hash3.length > 1024)
      throw new Error("Expected 40-1024 bytes of private key as per FIPS 186");
    const num2 = mod2(bytesToNumber2(hash3), CURVE.n - _1n11) + _1n11;
    return numTo32b(num2);
  },
  randomBytes: (bytesLength = 32) => {
    if (crypto5.web) {
      return crypto5.web.getRandomValues(new Uint8Array(bytesLength));
    } else if (crypto5.node) {
      const { randomBytes: randomBytes3 } = crypto5.node;
      return Uint8Array.from(randomBytes3(bytesLength));
    } else {
      throw new Error("The environment doesn't have randomBytes function");
    }
  },
  randomPrivateKey: () => {
    return utils.hashToPrivateKey(utils.randomBytes(40));
  },
  sha256: async (...messages3) => {
    if (crypto5.web) {
      const buffer3 = await crypto5.web.subtle.digest("SHA-256", concatBytes3(...messages3));
      return new Uint8Array(buffer3);
    } else if (crypto5.node) {
      const { createHash } = crypto5.node;
      const hash3 = createHash("sha256");
      messages3.forEach((m) => hash3.update(m));
      return Uint8Array.from(hash3.digest());
    } else {
      throw new Error("The environment doesn't have sha256 function");
    }
  },
  hmacSha256: async (key, ...messages3) => {
    if (crypto5.web) {
      const ckey = await crypto5.web.subtle.importKey("raw", key, { name: "HMAC", hash: { name: "SHA-256" } }, false, ["sign"]);
      const message = concatBytes3(...messages3);
      const buffer3 = await crypto5.web.subtle.sign("HMAC", ckey, message);
      return new Uint8Array(buffer3);
    } else if (crypto5.node) {
      const { createHmac } = crypto5.node;
      const hash3 = createHmac("sha256", key);
      messages3.forEach((m) => hash3.update(m));
      return Uint8Array.from(hash3.digest());
    } else {
      throw new Error("The environment doesn't have hmac-sha256 function");
    }
  },
  sha256Sync: void 0,
  hmacSha256Sync: void 0,
  taggedHash: async (tag, ...messages3) => {
    let tagP = TAGGED_HASH_PREFIXES2[tag];
    if (tagP === void 0) {
      const tagH = await utils.sha256(Uint8Array.from(tag, (c) => c.charCodeAt(0)));
      tagP = concatBytes3(tagH, tagH);
      TAGGED_HASH_PREFIXES2[tag] = tagP;
    }
    return utils.sha256(tagP, ...messages3);
  },
  taggedHashSync: (tag, ...messages3) => {
    if (typeof _sha256Sync !== "function")
      throw new ShaError("sha256Sync is undefined, you need to set it");
    let tagP = TAGGED_HASH_PREFIXES2[tag];
    if (tagP === void 0) {
      const tagH = _sha256Sync(Uint8Array.from(tag, (c) => c.charCodeAt(0)));
      tagP = concatBytes3(tagH, tagH);
      TAGGED_HASH_PREFIXES2[tag] = tagP;
    }
    return _sha256Sync(tagP, ...messages3);
  },
  precompute(windowSize = 8, point = Point.BASE) {
    const cached = point === Point.BASE ? point : new Point(point.x, point.y);
    cached._setWindowSize(windowSize);
    cached.multiply(_3n4);
    return cached;
  }
};
Object.defineProperties(utils, {
  sha256Sync: {
    configurable: false,
    get() {
      return _sha256Sync;
    },
    set(val) {
      if (!_sha256Sync)
        _sha256Sync = val;
    }
  },
  hmacSha256Sync: {
    configurable: false,
    get() {
      return _hmacSha256Sync;
    },
    set(val) {
      if (!_hmacSha256Sync)
        _hmacSha256Sync = val;
    }
  }
});

// node_modules/@audius/spl/dist/esm/secp256k1/Secp256k1Program.js
var import_buffer_layout56 = __toESM(require_Layout());
init_index_browser_esm();
var SECP256K1_INSTRUCTION_LAYOUT2 = (0, import_buffer_layout56.struct)([
  (0, import_buffer_layout56.u8)("numSignatures"),
  (0, import_buffer_layout56.u16)("signatureOffset"),
  (0, import_buffer_layout56.u8)("signatureInstructionIndex"),
  (0, import_buffer_layout56.u16)("ethAddressOffset"),
  (0, import_buffer_layout56.u8)("ethAddressInstructionIndex"),
  (0, import_buffer_layout56.u16)("messageDataOffset"),
  (0, import_buffer_layout56.u16)("messageDataSize"),
  (0, import_buffer_layout56.u8)("messageInstructionIndex"),
  (0, import_buffer_layout56.blob)(20, "ethAddress"),
  (0, import_buffer_layout56.blob)(64, "signature"),
  (0, import_buffer_layout56.u8)("recoveryId")
]);

// node_modules/@audius/spl/dist/esm/associated-token/index.js
var AssociatedTokenInstruction;
(function(AssociatedTokenInstruction2) {
  AssociatedTokenInstruction2[AssociatedTokenInstruction2["Create"] = 0] = "Create";
  AssociatedTokenInstruction2[AssociatedTokenInstruction2["CreateIdempotent"] = 1] = "CreateIdempotent";
  AssociatedTokenInstruction2[AssociatedTokenInstruction2["RecoverNested"] = 2] = "RecoverNested";
})(AssociatedTokenInstruction || (AssociatedTokenInstruction = {}));

// node_modules/@audius/spl/dist/esm/payment-router/paymentRouter.js
var IDL = {
  version: "0.1.0",
  name: "payment_router",
  instructions: [
    {
      name: "createPaymentRouterBalancePda",
      accounts: [
        {
          name: "paymentRouterPda",
          isMut: true,
          isSigner: false,
          docs: [
            "before transferring them over to given recipients, all within the same transaction."
          ]
        },
        {
          name: "payer",
          isMut: true,
          isSigner: true
        },
        {
          name: "systemProgram",
          isMut: false,
          isSigner: false
        }
      ],
      args: []
    },
    {
      name: "route",
      accounts: [
        {
          name: "sender",
          isMut: true,
          isSigner: false
        },
        {
          name: "senderOwner",
          isMut: false,
          isSigner: false
        },
        {
          name: "splToken",
          isMut: false,
          isSigner: false
        }
      ],
      args: [
        {
          name: "paymentRouterPdaBump",
          type: "u8"
        },
        {
          name: "amounts",
          type: {
            vec: "u64"
          }
        },
        {
          name: "totalAmount",
          type: "u64"
        }
      ]
    }
  ],
  errors: [
    {
      code: 6e3,
      name: "SenderTokenAccountNotOwnedByPDA",
      msg: "Sender token account not owned by PDA."
    },
    {
      code: 6001,
      name: "RecipientAmountMismatch",
      msg: "Number of recipients does not match number of amounts."
    },
    {
      code: 6002,
      name: "TotalAmountMismatch",
      msg: "Total of individual amounts does not match total amount."
    }
  ]
};

// node_modules/@coral-xyz/anchor/dist/browser/index.js
var import_buffer3 = __toESM(require_buffer());
init_index_browser_esm();
init_index_browser_esm();
var import_bn2 = __toESM(require_bn());
var import_bn3 = __toESM(require_bn());
var import_bs583 = __toESM(require_bs582());
var import_camelcase = __toESM(require_camelcase());
var borsh = __toESM(require_dist());

// node_modules/@coral-xyz/anchor/node_modules/@noble/hashes/esm/crypto.js
var crypto6 = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;

// node_modules/@coral-xyz/anchor/node_modules/@noble/hashes/esm/utils.js
function isBytes5(a) {
  return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
}
function abytes3(b, ...lengths) {
  if (!isBytes5(b))
    throw new Error("Uint8Array expected");
  if (lengths.length > 0 && !lengths.includes(b.length))
    throw new Error("Uint8Array expected of length " + lengths + ", got length=" + b.length);
}
function aexists3(instance2, checkFinished = true) {
  if (instance2.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance2.finished)
    throw new Error("Hash#digest() has already been called");
}
function aoutput3(out, instance2) {
  abytes3(out);
  const min = instance2.outputLen;
  if (out.length < min) {
    throw new Error("digestInto() expects output buffer of length at least " + min);
  }
}
function clean3(...arrays) {
  for (let i = 0; i < arrays.length; i++) {
    arrays[i].fill(0);
  }
}
function createView4(arr) {
  return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
}
function rotr4(word, shift) {
  return word << 32 - shift | word >>> shift;
}
var isLE4 = (() => new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68)();
var hasHexBuiltin3 = (() => (
  // @ts-ignore
  typeof Uint8Array.from([]).toHex === "function" && typeof Uint8Array.fromHex === "function"
))();
var hexes5 = Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
function utf8ToBytes4(str2) {
  if (typeof str2 !== "string")
    throw new Error("string expected");
  return new Uint8Array(new TextEncoder().encode(str2));
}
function toBytes6(data) {
  if (typeof data === "string")
    data = utf8ToBytes4(data);
  abytes3(data);
  return data;
}
var Hash5 = class {
};
function createHasher4(hashCons) {
  const hashC = (msg) => hashCons().update(toBytes6(msg)).digest();
  const tmp = hashCons();
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = () => hashCons();
  return hashC;
}

// node_modules/@coral-xyz/anchor/node_modules/@noble/hashes/esm/_md.js
function setBigUint644(view, byteOffset, value, isLE6) {
  if (typeof view.setBigUint64 === "function")
    return view.setBigUint64(byteOffset, value, isLE6);
  const _32n6 = BigInt(32);
  const _u32_max = BigInt(4294967295);
  const wh = Number(value >> _32n6 & _u32_max);
  const wl = Number(value & _u32_max);
  const h = isLE6 ? 4 : 0;
  const l = isLE6 ? 0 : 4;
  view.setUint32(byteOffset + h, wh, isLE6);
  view.setUint32(byteOffset + l, wl, isLE6);
}
function Chi4(a, b, c) {
  return a & b ^ ~a & c;
}
function Maj4(a, b, c) {
  return a & b ^ a & c ^ b & c;
}
var HashMD4 = class extends Hash5 {
  constructor(blockLen, outputLen, padOffset, isLE6) {
    super();
    this.finished = false;
    this.length = 0;
    this.pos = 0;
    this.destroyed = false;
    this.blockLen = blockLen;
    this.outputLen = outputLen;
    this.padOffset = padOffset;
    this.isLE = isLE6;
    this.buffer = new Uint8Array(blockLen);
    this.view = createView4(this.buffer);
  }
  update(data) {
    aexists3(this);
    data = toBytes6(data);
    abytes3(data);
    const { view, buffer: buffer3, blockLen } = this;
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      if (take === blockLen) {
        const dataView = createView4(data);
        for (; blockLen <= len - pos; pos += blockLen)
          this.process(dataView, pos);
        continue;
      }
      buffer3.set(data.subarray(pos, pos + take), this.pos);
      this.pos += take;
      pos += take;
      if (this.pos === blockLen) {
        this.process(view, 0);
        this.pos = 0;
      }
    }
    this.length += data.length;
    this.roundClean();
    return this;
  }
  digestInto(out) {
    aexists3(this);
    aoutput3(out, this);
    this.finished = true;
    const { buffer: buffer3, view, blockLen, isLE: isLE6 } = this;
    let { pos } = this;
    buffer3[pos++] = 128;
    clean3(this.buffer.subarray(pos));
    if (this.padOffset > blockLen - pos) {
      this.process(view, 0);
      pos = 0;
    }
    for (let i = pos; i < blockLen; i++)
      buffer3[i] = 0;
    setBigUint644(view, blockLen - 8, BigInt(this.length * 8), isLE6);
    this.process(view, 0);
    const oview = createView4(out);
    const len = this.outputLen;
    if (len % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const outLen = len / 4;
    const state = this.get();
    if (outLen > state.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let i = 0; i < outLen; i++)
      oview.setUint32(4 * i, state[i], isLE6);
  }
  digest() {
    const { buffer: buffer3, outputLen } = this;
    this.digestInto(buffer3);
    const res = buffer3.slice(0, outputLen);
    this.destroy();
    return res;
  }
  _cloneInto(to) {
    to || (to = new this.constructor());
    to.set(...this.get());
    const { blockLen, buffer: buffer3, length: length2, finished: finished2, destroyed, pos } = this;
    to.destroyed = destroyed;
    to.finished = finished2;
    to.length = length2;
    to.pos = pos;
    if (length2 % blockLen)
      to.buffer.set(buffer3);
    return to;
  }
  clone() {
    return this._cloneInto();
  }
};
var SHA256_IV4 = Uint32Array.from([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
var SHA224_IV3 = Uint32Array.from([
  3238371032,
  914150663,
  812702999,
  4144912697,
  4290775857,
  1750603025,
  1694076839,
  3204075428
]);
var SHA384_IV3 = Uint32Array.from([
  3418070365,
  3238371032,
  1654270250,
  914150663,
  2438529370,
  812702999,
  355462360,
  4144912697,
  1731405415,
  4290775857,
  2394180231,
  1750603025,
  3675008525,
  1694076839,
  1203062813,
  3204075428
]);
var SHA512_IV3 = Uint32Array.from([
  1779033703,
  4089235720,
  3144134277,
  2227873595,
  1013904242,
  4271175723,
  2773480762,
  1595750129,
  1359893119,
  2917565137,
  2600822924,
  725511199,
  528734635,
  4215389547,
  1541459225,
  327033209
]);

// node_modules/@coral-xyz/anchor/node_modules/@noble/hashes/esm/_u64.js
var U32_MASK644 = BigInt(2 ** 32 - 1);
var _32n4 = BigInt(32);
function fromBig4(n, le = false) {
  if (le)
    return { h: Number(n & U32_MASK644), l: Number(n >> _32n4 & U32_MASK644) };
  return { h: Number(n >> _32n4 & U32_MASK644) | 0, l: Number(n & U32_MASK644) | 0 };
}
function split4(lst, le = false) {
  const len = lst.length;
  let Ah = new Uint32Array(len);
  let Al = new Uint32Array(len);
  for (let i = 0; i < len; i++) {
    const { h, l } = fromBig4(lst[i], le);
    [Ah[i], Al[i]] = [h, l];
  }
  return [Ah, Al];
}
var shrSH3 = (h, _l, s) => h >>> s;
var shrSL3 = (h, l, s) => h << 32 - s | l >>> s;
var rotrSH3 = (h, l, s) => h >>> s | l << 32 - s;
var rotrSL3 = (h, l, s) => h << 32 - s | l >>> s;
var rotrBH3 = (h, l, s) => h << 64 - s | l >>> s - 32;
var rotrBL3 = (h, l, s) => h >>> s - 32 | l << 64 - s;
function add3(Ah, Al, Bh, Bl) {
  const l = (Al >>> 0) + (Bl >>> 0);
  return { h: Ah + Bh + (l / 2 ** 32 | 0) | 0, l: l | 0 };
}
var add3L3 = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
var add3H3 = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
var add4L3 = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
var add4H3 = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
var add5L3 = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
var add5H3 = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;

// node_modules/@coral-xyz/anchor/node_modules/@noble/hashes/esm/sha2.js
var SHA256_K4 = Uint32Array.from([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
var SHA256_W4 = new Uint32Array(64);
var SHA2564 = class extends HashMD4 {
  constructor(outputLen = 32) {
    super(64, outputLen, 8, false);
    this.A = SHA256_IV4[0] | 0;
    this.B = SHA256_IV4[1] | 0;
    this.C = SHA256_IV4[2] | 0;
    this.D = SHA256_IV4[3] | 0;
    this.E = SHA256_IV4[4] | 0;
    this.F = SHA256_IV4[5] | 0;
    this.G = SHA256_IV4[6] | 0;
    this.H = SHA256_IV4[7] | 0;
  }
  get() {
    const { A, B, C, D, E, F, G, H } = this;
    return [A, B, C, D, E, F, G, H];
  }
  // prettier-ignore
  set(A, B, C, D, E, F, G, H) {
    this.A = A | 0;
    this.B = B | 0;
    this.C = C | 0;
    this.D = D | 0;
    this.E = E | 0;
    this.F = F | 0;
    this.G = G | 0;
    this.H = H | 0;
  }
  process(view, offset3) {
    for (let i = 0; i < 16; i++, offset3 += 4)
      SHA256_W4[i] = view.getUint32(offset3, false);
    for (let i = 16; i < 64; i++) {
      const W15 = SHA256_W4[i - 15];
      const W2 = SHA256_W4[i - 2];
      const s0 = rotr4(W15, 7) ^ rotr4(W15, 18) ^ W15 >>> 3;
      const s1 = rotr4(W2, 17) ^ rotr4(W2, 19) ^ W2 >>> 10;
      SHA256_W4[i] = s1 + SHA256_W4[i - 7] + s0 + SHA256_W4[i - 16] | 0;
    }
    let { A, B, C, D, E, F, G, H } = this;
    for (let i = 0; i < 64; i++) {
      const sigma1 = rotr4(E, 6) ^ rotr4(E, 11) ^ rotr4(E, 25);
      const T1 = H + sigma1 + Chi4(E, F, G) + SHA256_K4[i] + SHA256_W4[i] | 0;
      const sigma0 = rotr4(A, 2) ^ rotr4(A, 13) ^ rotr4(A, 22);
      const T2 = sigma0 + Maj4(A, B, C) | 0;
      H = G;
      G = F;
      F = E;
      E = D + T1 | 0;
      D = C;
      C = B;
      B = A;
      A = T1 + T2 | 0;
    }
    A = A + this.A | 0;
    B = B + this.B | 0;
    C = C + this.C | 0;
    D = D + this.D | 0;
    E = E + this.E | 0;
    F = F + this.F | 0;
    G = G + this.G | 0;
    H = H + this.H | 0;
    this.set(A, B, C, D, E, F, G, H);
  }
  roundClean() {
    clean3(SHA256_W4);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0);
    clean3(this.buffer);
  }
};
var SHA2244 = class extends SHA2564 {
  constructor() {
    super(28);
    this.A = SHA224_IV3[0] | 0;
    this.B = SHA224_IV3[1] | 0;
    this.C = SHA224_IV3[2] | 0;
    this.D = SHA224_IV3[3] | 0;
    this.E = SHA224_IV3[4] | 0;
    this.F = SHA224_IV3[5] | 0;
    this.G = SHA224_IV3[6] | 0;
    this.H = SHA224_IV3[7] | 0;
  }
};
var K5123 = (() => split4([
  "0x428a2f98d728ae22",
  "0x7137449123ef65cd",
  "0xb5c0fbcfec4d3b2f",
  "0xe9b5dba58189dbbc",
  "0x3956c25bf348b538",
  "0x59f111f1b605d019",
  "0x923f82a4af194f9b",
  "0xab1c5ed5da6d8118",
  "0xd807aa98a3030242",
  "0x12835b0145706fbe",
  "0x243185be4ee4b28c",
  "0x550c7dc3d5ffb4e2",
  "0x72be5d74f27b896f",
  "0x80deb1fe3b1696b1",
  "0x9bdc06a725c71235",
  "0xc19bf174cf692694",
  "0xe49b69c19ef14ad2",
  "0xefbe4786384f25e3",
  "0x0fc19dc68b8cd5b5",
  "0x240ca1cc77ac9c65",
  "0x2de92c6f592b0275",
  "0x4a7484aa6ea6e483",
  "0x5cb0a9dcbd41fbd4",
  "0x76f988da831153b5",
  "0x983e5152ee66dfab",
  "0xa831c66d2db43210",
  "0xb00327c898fb213f",
  "0xbf597fc7beef0ee4",
  "0xc6e00bf33da88fc2",
  "0xd5a79147930aa725",
  "0x06ca6351e003826f",
  "0x142929670a0e6e70",
  "0x27b70a8546d22ffc",
  "0x2e1b21385c26c926",
  "0x4d2c6dfc5ac42aed",
  "0x53380d139d95b3df",
  "0x650a73548baf63de",
  "0x766a0abb3c77b2a8",
  "0x81c2c92e47edaee6",
  "0x92722c851482353b",
  "0xa2bfe8a14cf10364",
  "0xa81a664bbc423001",
  "0xc24b8b70d0f89791",
  "0xc76c51a30654be30",
  "0xd192e819d6ef5218",
  "0xd69906245565a910",
  "0xf40e35855771202a",
  "0x106aa07032bbd1b8",
  "0x19a4c116b8d2d0c8",
  "0x1e376c085141ab53",
  "0x2748774cdf8eeb99",
  "0x34b0bcb5e19b48a8",
  "0x391c0cb3c5c95a63",
  "0x4ed8aa4ae3418acb",
  "0x5b9cca4f7763e373",
  "0x682e6ff3d6b2b8a3",
  "0x748f82ee5defb2fc",
  "0x78a5636f43172f60",
  "0x84c87814a1f0ab72",
  "0x8cc702081a6439ec",
  "0x90befffa23631e28",
  "0xa4506cebde82bde9",
  "0xbef9a3f7b2c67915",
  "0xc67178f2e372532b",
  "0xca273eceea26619c",
  "0xd186b8c721c0c207",
  "0xeada7dd6cde0eb1e",
  "0xf57d4f7fee6ed178",
  "0x06f067aa72176fba",
  "0x0a637dc5a2c898a6",
  "0x113f9804bef90dae",
  "0x1b710b35131c471b",
  "0x28db77f523047d84",
  "0x32caab7b40c72493",
  "0x3c9ebe0a15c9bebc",
  "0x431d67c49c100d4c",
  "0x4cc5d4becb3e42b6",
  "0x597f299cfc657e2a",
  "0x5fcb6fab3ad6faec",
  "0x6c44198c4a475817"
].map((n) => BigInt(n))))();
var SHA512_Kh3 = (() => K5123[0])();
var SHA512_Kl3 = (() => K5123[1])();
var SHA512_W_H3 = new Uint32Array(80);
var SHA512_W_L3 = new Uint32Array(80);
var SHA5123 = class extends HashMD4 {
  constructor(outputLen = 64) {
    super(128, outputLen, 16, false);
    this.Ah = SHA512_IV3[0] | 0;
    this.Al = SHA512_IV3[1] | 0;
    this.Bh = SHA512_IV3[2] | 0;
    this.Bl = SHA512_IV3[3] | 0;
    this.Ch = SHA512_IV3[4] | 0;
    this.Cl = SHA512_IV3[5] | 0;
    this.Dh = SHA512_IV3[6] | 0;
    this.Dl = SHA512_IV3[7] | 0;
    this.Eh = SHA512_IV3[8] | 0;
    this.El = SHA512_IV3[9] | 0;
    this.Fh = SHA512_IV3[10] | 0;
    this.Fl = SHA512_IV3[11] | 0;
    this.Gh = SHA512_IV3[12] | 0;
    this.Gl = SHA512_IV3[13] | 0;
    this.Hh = SHA512_IV3[14] | 0;
    this.Hl = SHA512_IV3[15] | 0;
  }
  // prettier-ignore
  get() {
    const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
    return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
  }
  // prettier-ignore
  set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
    this.Ah = Ah | 0;
    this.Al = Al | 0;
    this.Bh = Bh | 0;
    this.Bl = Bl | 0;
    this.Ch = Ch | 0;
    this.Cl = Cl | 0;
    this.Dh = Dh | 0;
    this.Dl = Dl | 0;
    this.Eh = Eh | 0;
    this.El = El | 0;
    this.Fh = Fh | 0;
    this.Fl = Fl | 0;
    this.Gh = Gh | 0;
    this.Gl = Gl | 0;
    this.Hh = Hh | 0;
    this.Hl = Hl | 0;
  }
  process(view, offset3) {
    for (let i = 0; i < 16; i++, offset3 += 4) {
      SHA512_W_H3[i] = view.getUint32(offset3);
      SHA512_W_L3[i] = view.getUint32(offset3 += 4);
    }
    for (let i = 16; i < 80; i++) {
      const W15h = SHA512_W_H3[i - 15] | 0;
      const W15l = SHA512_W_L3[i - 15] | 0;
      const s0h = rotrSH3(W15h, W15l, 1) ^ rotrSH3(W15h, W15l, 8) ^ shrSH3(W15h, W15l, 7);
      const s0l = rotrSL3(W15h, W15l, 1) ^ rotrSL3(W15h, W15l, 8) ^ shrSL3(W15h, W15l, 7);
      const W2h = SHA512_W_H3[i - 2] | 0;
      const W2l = SHA512_W_L3[i - 2] | 0;
      const s1h = rotrSH3(W2h, W2l, 19) ^ rotrBH3(W2h, W2l, 61) ^ shrSH3(W2h, W2l, 6);
      const s1l = rotrSL3(W2h, W2l, 19) ^ rotrBL3(W2h, W2l, 61) ^ shrSL3(W2h, W2l, 6);
      const SUMl = add4L3(s0l, s1l, SHA512_W_L3[i - 7], SHA512_W_L3[i - 16]);
      const SUMh = add4H3(SUMl, s0h, s1h, SHA512_W_H3[i - 7], SHA512_W_H3[i - 16]);
      SHA512_W_H3[i] = SUMh | 0;
      SHA512_W_L3[i] = SUMl | 0;
    }
    let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
    for (let i = 0; i < 80; i++) {
      const sigma1h = rotrSH3(Eh, El, 14) ^ rotrSH3(Eh, El, 18) ^ rotrBH3(Eh, El, 41);
      const sigma1l = rotrSL3(Eh, El, 14) ^ rotrSL3(Eh, El, 18) ^ rotrBL3(Eh, El, 41);
      const CHIh = Eh & Fh ^ ~Eh & Gh;
      const CHIl = El & Fl ^ ~El & Gl;
      const T1ll = add5L3(Hl, sigma1l, CHIl, SHA512_Kl3[i], SHA512_W_L3[i]);
      const T1h = add5H3(T1ll, Hh, sigma1h, CHIh, SHA512_Kh3[i], SHA512_W_H3[i]);
      const T1l = T1ll | 0;
      const sigma0h = rotrSH3(Ah, Al, 28) ^ rotrBH3(Ah, Al, 34) ^ rotrBH3(Ah, Al, 39);
      const sigma0l = rotrSL3(Ah, Al, 28) ^ rotrBL3(Ah, Al, 34) ^ rotrBL3(Ah, Al, 39);
      const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
      const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;
      Hh = Gh | 0;
      Hl = Gl | 0;
      Gh = Fh | 0;
      Gl = Fl | 0;
      Fh = Eh | 0;
      Fl = El | 0;
      ({ h: Eh, l: El } = add3(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
      Dh = Ch | 0;
      Dl = Cl | 0;
      Ch = Bh | 0;
      Cl = Bl | 0;
      Bh = Ah | 0;
      Bl = Al | 0;
      const All = add3L3(T1l, sigma0l, MAJl);
      Ah = add3H3(All, T1h, sigma0h, MAJh);
      Al = All | 0;
    }
    ({ h: Ah, l: Al } = add3(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
    ({ h: Bh, l: Bl } = add3(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
    ({ h: Ch, l: Cl } = add3(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
    ({ h: Dh, l: Dl } = add3(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
    ({ h: Eh, l: El } = add3(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
    ({ h: Fh, l: Fl } = add3(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
    ({ h: Gh, l: Gl } = add3(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
    ({ h: Hh, l: Hl } = add3(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
    this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
  }
  roundClean() {
    clean3(SHA512_W_H3, SHA512_W_L3);
  }
  destroy() {
    clean3(this.buffer);
    this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
};
var SHA3843 = class extends SHA5123 {
  constructor() {
    super(48);
    this.Ah = SHA384_IV3[0] | 0;
    this.Al = SHA384_IV3[1] | 0;
    this.Bh = SHA384_IV3[2] | 0;
    this.Bl = SHA384_IV3[3] | 0;
    this.Ch = SHA384_IV3[4] | 0;
    this.Cl = SHA384_IV3[5] | 0;
    this.Dh = SHA384_IV3[6] | 0;
    this.Dl = SHA384_IV3[7] | 0;
    this.Eh = SHA384_IV3[8] | 0;
    this.El = SHA384_IV3[9] | 0;
    this.Fh = SHA384_IV3[10] | 0;
    this.Fl = SHA384_IV3[11] | 0;
    this.Gh = SHA384_IV3[12] | 0;
    this.Gl = SHA384_IV3[13] | 0;
    this.Hh = SHA384_IV3[14] | 0;
    this.Hl = SHA384_IV3[15] | 0;
  }
};
var T224_IV3 = Uint32Array.from([
  2352822216,
  424955298,
  1944164710,
  2312950998,
  502970286,
  855612546,
  1738396948,
  1479516111,
  258812777,
  2077511080,
  2011393907,
  79989058,
  1067287976,
  1780299464,
  286451373,
  2446758561
]);
var T256_IV3 = Uint32Array.from([
  573645204,
  4230739756,
  2673172387,
  3360449730,
  596883563,
  1867755857,
  2520282905,
  1497426621,
  2519219938,
  2827943907,
  3193839141,
  1401305490,
  721525244,
  746961066,
  246885852,
  2177182882
]);
var SHA512_2243 = class extends SHA5123 {
  constructor() {
    super(28);
    this.Ah = T224_IV3[0] | 0;
    this.Al = T224_IV3[1] | 0;
    this.Bh = T224_IV3[2] | 0;
    this.Bl = T224_IV3[3] | 0;
    this.Ch = T224_IV3[4] | 0;
    this.Cl = T224_IV3[5] | 0;
    this.Dh = T224_IV3[6] | 0;
    this.Dl = T224_IV3[7] | 0;
    this.Eh = T224_IV3[8] | 0;
    this.El = T224_IV3[9] | 0;
    this.Fh = T224_IV3[10] | 0;
    this.Fl = T224_IV3[11] | 0;
    this.Gh = T224_IV3[12] | 0;
    this.Gl = T224_IV3[13] | 0;
    this.Hh = T224_IV3[14] | 0;
    this.Hl = T224_IV3[15] | 0;
  }
};
var SHA512_2563 = class extends SHA5123 {
  constructor() {
    super(32);
    this.Ah = T256_IV3[0] | 0;
    this.Al = T256_IV3[1] | 0;
    this.Bh = T256_IV3[2] | 0;
    this.Bl = T256_IV3[3] | 0;
    this.Ch = T256_IV3[4] | 0;
    this.Cl = T256_IV3[5] | 0;
    this.Dh = T256_IV3[6] | 0;
    this.Dl = T256_IV3[7] | 0;
    this.Eh = T256_IV3[8] | 0;
    this.El = T256_IV3[9] | 0;
    this.Fh = T256_IV3[10] | 0;
    this.Fl = T256_IV3[11] | 0;
    this.Gh = T256_IV3[12] | 0;
    this.Gl = T256_IV3[13] | 0;
    this.Hh = T256_IV3[14] | 0;
    this.Hl = T256_IV3[15] | 0;
  }
};
var sha2566 = createHasher4(() => new SHA2564());
var sha2244 = createHasher4(() => new SHA2244());
var sha5123 = createHasher4(() => new SHA5123());
var sha3843 = createHasher4(() => new SHA3843());
var sha512_2563 = createHasher4(() => new SHA512_2563());
var sha512_2243 = createHasher4(() => new SHA512_2243());

// node_modules/@coral-xyz/anchor/node_modules/@noble/hashes/esm/sha256.js
var sha2567 = sha2566;

// node_modules/pako/dist/pako.esm.mjs
var Z_FIXED$1 = 4;
var Z_BINARY = 0;
var Z_TEXT = 1;
var Z_UNKNOWN$1 = 2;
function zero$1(buf) {
  let len = buf.length;
  while (--len >= 0) {
    buf[len] = 0;
  }
}
var STORED_BLOCK = 0;
var STATIC_TREES = 1;
var DYN_TREES = 2;
var MIN_MATCH$1 = 3;
var MAX_MATCH$1 = 258;
var LENGTH_CODES$1 = 29;
var LITERALS$1 = 256;
var L_CODES$1 = LITERALS$1 + 1 + LENGTH_CODES$1;
var D_CODES$1 = 30;
var BL_CODES$1 = 19;
var HEAP_SIZE$1 = 2 * L_CODES$1 + 1;
var MAX_BITS$1 = 15;
var Buf_size = 16;
var MAX_BL_BITS = 7;
var END_BLOCK = 256;
var REP_3_6 = 16;
var REPZ_3_10 = 17;
var REPZ_11_138 = 18;
var extra_lbits = (
  /* extra bits for each length code */
  new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0])
);
var extra_dbits = (
  /* extra bits for each distance code */
  new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13])
);
var extra_blbits = (
  /* extra bits for each bit length code */
  new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7])
);
var bl_order = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
var DIST_CODE_LEN = 512;
var static_ltree = new Array((L_CODES$1 + 2) * 2);
zero$1(static_ltree);
var static_dtree = new Array(D_CODES$1 * 2);
zero$1(static_dtree);
var _dist_code = new Array(DIST_CODE_LEN);
zero$1(_dist_code);
var _length_code = new Array(MAX_MATCH$1 - MIN_MATCH$1 + 1);
zero$1(_length_code);
var base_length = new Array(LENGTH_CODES$1);
zero$1(base_length);
var base_dist = new Array(D_CODES$1);
zero$1(base_dist);
function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
  this.static_tree = static_tree;
  this.extra_bits = extra_bits;
  this.extra_base = extra_base;
  this.elems = elems;
  this.max_length = max_length;
  this.has_stree = static_tree && static_tree.length;
}
var static_l_desc;
var static_d_desc;
var static_bl_desc;
function TreeDesc(dyn_tree, stat_desc) {
  this.dyn_tree = dyn_tree;
  this.max_code = 0;
  this.stat_desc = stat_desc;
}
var d_code = (dist) => {
  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
};
var put_short = (s, w) => {
  s.pending_buf[s.pending++] = w & 255;
  s.pending_buf[s.pending++] = w >>> 8 & 255;
};
var send_bits = (s, value, length2) => {
  if (s.bi_valid > Buf_size - length2) {
    s.bi_buf |= value << s.bi_valid & 65535;
    put_short(s, s.bi_buf);
    s.bi_buf = value >> Buf_size - s.bi_valid;
    s.bi_valid += length2 - Buf_size;
  } else {
    s.bi_buf |= value << s.bi_valid & 65535;
    s.bi_valid += length2;
  }
};
var send_code = (s, c, tree) => {
  send_bits(
    s,
    tree[c * 2],
    tree[c * 2 + 1]
    /*.Len*/
  );
};
var bi_reverse = (code2, len) => {
  let res = 0;
  do {
    res |= code2 & 1;
    code2 >>>= 1;
    res <<= 1;
  } while (--len > 0);
  return res >>> 1;
};
var bi_flush = (s) => {
  if (s.bi_valid === 16) {
    put_short(s, s.bi_buf);
    s.bi_buf = 0;
    s.bi_valid = 0;
  } else if (s.bi_valid >= 8) {
    s.pending_buf[s.pending++] = s.bi_buf & 255;
    s.bi_buf >>= 8;
    s.bi_valid -= 8;
  }
};
var gen_bitlen = (s, desc) => {
  const tree = desc.dyn_tree;
  const max_code = desc.max_code;
  const stree = desc.stat_desc.static_tree;
  const has_stree = desc.stat_desc.has_stree;
  const extra = desc.stat_desc.extra_bits;
  const base3 = desc.stat_desc.extra_base;
  const max_length = desc.stat_desc.max_length;
  let h;
  let n, m;
  let bits;
  let xbits;
  let f3;
  let overflow = 0;
  for (bits = 0; bits <= MAX_BITS$1; bits++) {
    s.bl_count[bits] = 0;
  }
  tree[s.heap[s.heap_max] * 2 + 1] = 0;
  for (h = s.heap_max + 1; h < HEAP_SIZE$1; h++) {
    n = s.heap[h];
    bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
    if (bits > max_length) {
      bits = max_length;
      overflow++;
    }
    tree[n * 2 + 1] = bits;
    if (n > max_code) {
      continue;
    }
    s.bl_count[bits]++;
    xbits = 0;
    if (n >= base3) {
      xbits = extra[n - base3];
    }
    f3 = tree[n * 2];
    s.opt_len += f3 * (bits + xbits);
    if (has_stree) {
      s.static_len += f3 * (stree[n * 2 + 1] + xbits);
    }
  }
  if (overflow === 0) {
    return;
  }
  do {
    bits = max_length - 1;
    while (s.bl_count[bits] === 0) {
      bits--;
    }
    s.bl_count[bits]--;
    s.bl_count[bits + 1] += 2;
    s.bl_count[max_length]--;
    overflow -= 2;
  } while (overflow > 0);
  for (bits = max_length; bits !== 0; bits--) {
    n = s.bl_count[bits];
    while (n !== 0) {
      m = s.heap[--h];
      if (m > max_code) {
        continue;
      }
      if (tree[m * 2 + 1] !== bits) {
        s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
        tree[m * 2 + 1] = bits;
      }
      n--;
    }
  }
};
var gen_codes = (tree, max_code, bl_count) => {
  const next_code = new Array(MAX_BITS$1 + 1);
  let code2 = 0;
  let bits;
  let n;
  for (bits = 1; bits <= MAX_BITS$1; bits++) {
    code2 = code2 + bl_count[bits - 1] << 1;
    next_code[bits] = code2;
  }
  for (n = 0; n <= max_code; n++) {
    let len = tree[n * 2 + 1];
    if (len === 0) {
      continue;
    }
    tree[n * 2] = bi_reverse(next_code[len]++, len);
  }
};
var tr_static_init = () => {
  let n;
  let bits;
  let length2;
  let code2;
  let dist;
  const bl_count = new Array(MAX_BITS$1 + 1);
  length2 = 0;
  for (code2 = 0; code2 < LENGTH_CODES$1 - 1; code2++) {
    base_length[code2] = length2;
    for (n = 0; n < 1 << extra_lbits[code2]; n++) {
      _length_code[length2++] = code2;
    }
  }
  _length_code[length2 - 1] = code2;
  dist = 0;
  for (code2 = 0; code2 < 16; code2++) {
    base_dist[code2] = dist;
    for (n = 0; n < 1 << extra_dbits[code2]; n++) {
      _dist_code[dist++] = code2;
    }
  }
  dist >>= 7;
  for (; code2 < D_CODES$1; code2++) {
    base_dist[code2] = dist << 7;
    for (n = 0; n < 1 << extra_dbits[code2] - 7; n++) {
      _dist_code[256 + dist++] = code2;
    }
  }
  for (bits = 0; bits <= MAX_BITS$1; bits++) {
    bl_count[bits] = 0;
  }
  n = 0;
  while (n <= 143) {
    static_ltree[n * 2 + 1] = 8;
    n++;
    bl_count[8]++;
  }
  while (n <= 255) {
    static_ltree[n * 2 + 1] = 9;
    n++;
    bl_count[9]++;
  }
  while (n <= 279) {
    static_ltree[n * 2 + 1] = 7;
    n++;
    bl_count[7]++;
  }
  while (n <= 287) {
    static_ltree[n * 2 + 1] = 8;
    n++;
    bl_count[8]++;
  }
  gen_codes(static_ltree, L_CODES$1 + 1, bl_count);
  for (n = 0; n < D_CODES$1; n++) {
    static_dtree[n * 2 + 1] = 5;
    static_dtree[n * 2] = bi_reverse(n, 5);
  }
  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS$1 + 1, L_CODES$1, MAX_BITS$1);
  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES$1, MAX_BITS$1);
  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES$1, MAX_BL_BITS);
};
var init_block = (s) => {
  let n;
  for (n = 0; n < L_CODES$1; n++) {
    s.dyn_ltree[n * 2] = 0;
  }
  for (n = 0; n < D_CODES$1; n++) {
    s.dyn_dtree[n * 2] = 0;
  }
  for (n = 0; n < BL_CODES$1; n++) {
    s.bl_tree[n * 2] = 0;
  }
  s.dyn_ltree[END_BLOCK * 2] = 1;
  s.opt_len = s.static_len = 0;
  s.sym_next = s.matches = 0;
};
var bi_windup = (s) => {
  if (s.bi_valid > 8) {
    put_short(s, s.bi_buf);
  } else if (s.bi_valid > 0) {
    s.pending_buf[s.pending++] = s.bi_buf;
  }
  s.bi_buf = 0;
  s.bi_valid = 0;
};
var smaller = (tree, n, m, depth) => {
  const _n2 = n * 2;
  const _m2 = m * 2;
  return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m];
};
var pqdownheap = (s, tree, k) => {
  const v = s.heap[k];
  let j = k << 1;
  while (j <= s.heap_len) {
    if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
      j++;
    }
    if (smaller(tree, v, s.heap[j], s.depth)) {
      break;
    }
    s.heap[k] = s.heap[j];
    k = j;
    j <<= 1;
  }
  s.heap[k] = v;
};
var compress_block = (s, ltree, dtree) => {
  let dist;
  let lc;
  let sx = 0;
  let code2;
  let extra;
  if (s.sym_next !== 0) {
    do {
      dist = s.pending_buf[s.sym_buf + sx++] & 255;
      dist += (s.pending_buf[s.sym_buf + sx++] & 255) << 8;
      lc = s.pending_buf[s.sym_buf + sx++];
      if (dist === 0) {
        send_code(s, lc, ltree);
      } else {
        code2 = _length_code[lc];
        send_code(s, code2 + LITERALS$1 + 1, ltree);
        extra = extra_lbits[code2];
        if (extra !== 0) {
          lc -= base_length[code2];
          send_bits(s, lc, extra);
        }
        dist--;
        code2 = d_code(dist);
        send_code(s, code2, dtree);
        extra = extra_dbits[code2];
        if (extra !== 0) {
          dist -= base_dist[code2];
          send_bits(s, dist, extra);
        }
      }
    } while (sx < s.sym_next);
  }
  send_code(s, END_BLOCK, ltree);
};
var build_tree = (s, desc) => {
  const tree = desc.dyn_tree;
  const stree = desc.stat_desc.static_tree;
  const has_stree = desc.stat_desc.has_stree;
  const elems = desc.stat_desc.elems;
  let n, m;
  let max_code = -1;
  let node;
  s.heap_len = 0;
  s.heap_max = HEAP_SIZE$1;
  for (n = 0; n < elems; n++) {
    if (tree[n * 2] !== 0) {
      s.heap[++s.heap_len] = max_code = n;
      s.depth[n] = 0;
    } else {
      tree[n * 2 + 1] = 0;
    }
  }
  while (s.heap_len < 2) {
    node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
    tree[node * 2] = 1;
    s.depth[node] = 0;
    s.opt_len--;
    if (has_stree) {
      s.static_len -= stree[node * 2 + 1];
    }
  }
  desc.max_code = max_code;
  for (n = s.heap_len >> 1; n >= 1; n--) {
    pqdownheap(s, tree, n);
  }
  node = elems;
  do {
    n = s.heap[
      1
      /*SMALLEST*/
    ];
    s.heap[
      1
      /*SMALLEST*/
    ] = s.heap[s.heap_len--];
    pqdownheap(
      s,
      tree,
      1
      /*SMALLEST*/
    );
    m = s.heap[
      1
      /*SMALLEST*/
    ];
    s.heap[--s.heap_max] = n;
    s.heap[--s.heap_max] = m;
    tree[node * 2] = tree[n * 2] + tree[m * 2];
    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
    tree[n * 2 + 1] = tree[m * 2 + 1] = node;
    s.heap[
      1
      /*SMALLEST*/
    ] = node++;
    pqdownheap(
      s,
      tree,
      1
      /*SMALLEST*/
    );
  } while (s.heap_len >= 2);
  s.heap[--s.heap_max] = s.heap[
    1
    /*SMALLEST*/
  ];
  gen_bitlen(s, desc);
  gen_codes(tree, max_code, s.bl_count);
};
var scan_tree = (s, tree, max_code) => {
  let n;
  let prevlen = -1;
  let curlen;
  let nextlen = tree[0 * 2 + 1];
  let count = 0;
  let max_count = 7;
  let min_count = 4;
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  tree[(max_code + 1) * 2 + 1] = 65535;
  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1];
    if (++count < max_count && curlen === nextlen) {
      continue;
    } else if (count < min_count) {
      s.bl_tree[curlen * 2] += count;
    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        s.bl_tree[curlen * 2]++;
      }
      s.bl_tree[REP_3_6 * 2]++;
    } else if (count <= 10) {
      s.bl_tree[REPZ_3_10 * 2]++;
    } else {
      s.bl_tree[REPZ_11_138 * 2]++;
    }
    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;
    } else {
      max_count = 7;
      min_count = 4;
    }
  }
};
var send_tree = (s, tree, max_code) => {
  let n;
  let prevlen = -1;
  let curlen;
  let nextlen = tree[0 * 2 + 1];
  let count = 0;
  let max_count = 7;
  let min_count = 4;
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1];
    if (++count < max_count && curlen === nextlen) {
      continue;
    } else if (count < min_count) {
      do {
        send_code(s, curlen, s.bl_tree);
      } while (--count !== 0);
    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        send_code(s, curlen, s.bl_tree);
        count--;
      }
      send_code(s, REP_3_6, s.bl_tree);
      send_bits(s, count - 3, 2);
    } else if (count <= 10) {
      send_code(s, REPZ_3_10, s.bl_tree);
      send_bits(s, count - 3, 3);
    } else {
      send_code(s, REPZ_11_138, s.bl_tree);
      send_bits(s, count - 11, 7);
    }
    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;
    } else {
      max_count = 7;
      min_count = 4;
    }
  }
};
var build_bl_tree = (s) => {
  let max_blindex;
  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
  build_tree(s, s.bl_desc);
  for (max_blindex = BL_CODES$1 - 1; max_blindex >= 3; max_blindex--) {
    if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
      break;
    }
  }
  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
  return max_blindex;
};
var send_all_trees = (s, lcodes, dcodes, blcodes) => {
  let rank2;
  send_bits(s, lcodes - 257, 5);
  send_bits(s, dcodes - 1, 5);
  send_bits(s, blcodes - 4, 4);
  for (rank2 = 0; rank2 < blcodes; rank2++) {
    send_bits(s, s.bl_tree[bl_order[rank2] * 2 + 1], 3);
  }
  send_tree(s, s.dyn_ltree, lcodes - 1);
  send_tree(s, s.dyn_dtree, dcodes - 1);
};
var detect_data_type = (s) => {
  let block_mask = 4093624447;
  let n;
  for (n = 0; n <= 31; n++, block_mask >>>= 1) {
    if (block_mask & 1 && s.dyn_ltree[n * 2] !== 0) {
      return Z_BINARY;
    }
  }
  if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {
    return Z_TEXT;
  }
  for (n = 32; n < LITERALS$1; n++) {
    if (s.dyn_ltree[n * 2] !== 0) {
      return Z_TEXT;
    }
  }
  return Z_BINARY;
};
var static_init_done = false;
var _tr_init$1 = (s) => {
  if (!static_init_done) {
    tr_static_init();
    static_init_done = true;
  }
  s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
  s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
  s.bi_buf = 0;
  s.bi_valid = 0;
  init_block(s);
};
var _tr_stored_block$1 = (s, buf, stored_len, last) => {
  send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);
  bi_windup(s);
  put_short(s, stored_len);
  put_short(s, ~stored_len);
  if (stored_len) {
    s.pending_buf.set(s.window.subarray(buf, buf + stored_len), s.pending);
  }
  s.pending += stored_len;
};
var _tr_align$1 = (s) => {
  send_bits(s, STATIC_TREES << 1, 3);
  send_code(s, END_BLOCK, static_ltree);
  bi_flush(s);
};
var _tr_flush_block$1 = (s, buf, stored_len, last) => {
  let opt_lenb, static_lenb;
  let max_blindex = 0;
  if (s.level > 0) {
    if (s.strm.data_type === Z_UNKNOWN$1) {
      s.strm.data_type = detect_data_type(s);
    }
    build_tree(s, s.l_desc);
    build_tree(s, s.d_desc);
    max_blindex = build_bl_tree(s);
    opt_lenb = s.opt_len + 3 + 7 >>> 3;
    static_lenb = s.static_len + 3 + 7 >>> 3;
    if (static_lenb <= opt_lenb) {
      opt_lenb = static_lenb;
    }
  } else {
    opt_lenb = static_lenb = stored_len + 5;
  }
  if (stored_len + 4 <= opt_lenb && buf !== -1) {
    _tr_stored_block$1(s, buf, stored_len, last);
  } else if (s.strategy === Z_FIXED$1 || static_lenb === opt_lenb) {
    send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
    compress_block(s, static_ltree, static_dtree);
  } else {
    send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
    compress_block(s, s.dyn_ltree, s.dyn_dtree);
  }
  init_block(s);
  if (last) {
    bi_windup(s);
  }
};
var _tr_tally$1 = (s, dist, lc) => {
  s.pending_buf[s.sym_buf + s.sym_next++] = dist;
  s.pending_buf[s.sym_buf + s.sym_next++] = dist >> 8;
  s.pending_buf[s.sym_buf + s.sym_next++] = lc;
  if (dist === 0) {
    s.dyn_ltree[lc * 2]++;
  } else {
    s.matches++;
    dist--;
    s.dyn_ltree[(_length_code[lc] + LITERALS$1 + 1) * 2]++;
    s.dyn_dtree[d_code(dist) * 2]++;
  }
  return s.sym_next === s.sym_end;
};
var _tr_init_1 = _tr_init$1;
var _tr_stored_block_1 = _tr_stored_block$1;
var _tr_flush_block_1 = _tr_flush_block$1;
var _tr_tally_1 = _tr_tally$1;
var _tr_align_1 = _tr_align$1;
var trees = {
  _tr_init: _tr_init_1,
  _tr_stored_block: _tr_stored_block_1,
  _tr_flush_block: _tr_flush_block_1,
  _tr_tally: _tr_tally_1,
  _tr_align: _tr_align_1
};
var adler32 = (adler, buf, len, pos) => {
  let s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n = 0;
  while (len !== 0) {
    n = len > 2e3 ? 2e3 : len;
    len -= n;
    do {
      s1 = s1 + buf[pos++] | 0;
      s2 = s2 + s1 | 0;
    } while (--n);
    s1 %= 65521;
    s2 %= 65521;
  }
  return s1 | s2 << 16 | 0;
};
var adler32_1 = adler32;
var makeTable = () => {
  let c, table = [];
  for (var n = 0; n < 256; n++) {
    c = n;
    for (var k = 0; k < 8; k++) {
      c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
    }
    table[n] = c;
  }
  return table;
};
var crcTable = new Uint32Array(makeTable());
var crc32 = (crc, buf, len, pos) => {
  const t = crcTable;
  const end = pos + len;
  crc ^= -1;
  for (let i = pos; i < end; i++) {
    crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 255];
  }
  return crc ^ -1;
};
var crc32_1 = crc32;
var messages = {
  2: "need dictionary",
  /* Z_NEED_DICT       2  */
  1: "stream end",
  /* Z_STREAM_END      1  */
  0: "",
  /* Z_OK              0  */
  "-1": "file error",
  /* Z_ERRNO         (-1) */
  "-2": "stream error",
  /* Z_STREAM_ERROR  (-2) */
  "-3": "data error",
  /* Z_DATA_ERROR    (-3) */
  "-4": "insufficient memory",
  /* Z_MEM_ERROR     (-4) */
  "-5": "buffer error",
  /* Z_BUF_ERROR     (-5) */
  "-6": "incompatible version"
  /* Z_VERSION_ERROR (-6) */
};
var constants$2 = {
  /* Allowed flush values; see deflate() and inflate() below for details */
  Z_NO_FLUSH: 0,
  Z_PARTIAL_FLUSH: 1,
  Z_SYNC_FLUSH: 2,
  Z_FULL_FLUSH: 3,
  Z_FINISH: 4,
  Z_BLOCK: 5,
  Z_TREES: 6,
  /* Return codes for the compression/decompression functions. Negative values
  * are errors, positive values are used for special but normal events.
  */
  Z_OK: 0,
  Z_STREAM_END: 1,
  Z_NEED_DICT: 2,
  Z_ERRNO: -1,
  Z_STREAM_ERROR: -2,
  Z_DATA_ERROR: -3,
  Z_MEM_ERROR: -4,
  Z_BUF_ERROR: -5,
  //Z_VERSION_ERROR: -6,
  /* compression levels */
  Z_NO_COMPRESSION: 0,
  Z_BEST_SPEED: 1,
  Z_BEST_COMPRESSION: 9,
  Z_DEFAULT_COMPRESSION: -1,
  Z_FILTERED: 1,
  Z_HUFFMAN_ONLY: 2,
  Z_RLE: 3,
  Z_FIXED: 4,
  Z_DEFAULT_STRATEGY: 0,
  /* Possible values of the data_type field (though see inflate()) */
  Z_BINARY: 0,
  Z_TEXT: 1,
  //Z_ASCII:                1, // = Z_TEXT (deprecated)
  Z_UNKNOWN: 2,
  /* The deflate compression method */
  Z_DEFLATED: 8
  //Z_NULL:                 null // Use -1 or null inline, depending on var type
};
var { _tr_init, _tr_stored_block, _tr_flush_block, _tr_tally, _tr_align } = trees;
var {
  Z_NO_FLUSH: Z_NO_FLUSH$2,
  Z_PARTIAL_FLUSH,
  Z_FULL_FLUSH: Z_FULL_FLUSH$1,
  Z_FINISH: Z_FINISH$3,
  Z_BLOCK: Z_BLOCK$1,
  Z_OK: Z_OK$3,
  Z_STREAM_END: Z_STREAM_END$3,
  Z_STREAM_ERROR: Z_STREAM_ERROR$2,
  Z_DATA_ERROR: Z_DATA_ERROR$2,
  Z_BUF_ERROR: Z_BUF_ERROR$1,
  Z_DEFAULT_COMPRESSION: Z_DEFAULT_COMPRESSION$1,
  Z_FILTERED,
  Z_HUFFMAN_ONLY,
  Z_RLE,
  Z_FIXED,
  Z_DEFAULT_STRATEGY: Z_DEFAULT_STRATEGY$1,
  Z_UNKNOWN,
  Z_DEFLATED: Z_DEFLATED$2
} = constants$2;
var MAX_MEM_LEVEL = 9;
var MAX_WBITS$1 = 15;
var DEF_MEM_LEVEL = 8;
var LENGTH_CODES = 29;
var LITERALS = 256;
var L_CODES = LITERALS + 1 + LENGTH_CODES;
var D_CODES = 30;
var BL_CODES = 19;
var HEAP_SIZE = 2 * L_CODES + 1;
var MAX_BITS = 15;
var MIN_MATCH = 3;
var MAX_MATCH = 258;
var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
var PRESET_DICT = 32;
var INIT_STATE = 42;
var GZIP_STATE = 57;
var EXTRA_STATE = 69;
var NAME_STATE = 73;
var COMMENT_STATE = 91;
var HCRC_STATE = 103;
var BUSY_STATE = 113;
var FINISH_STATE = 666;
var BS_NEED_MORE = 1;
var BS_BLOCK_DONE = 2;
var BS_FINISH_STARTED = 3;
var BS_FINISH_DONE = 4;
var OS_CODE = 3;
var err = (strm, errorCode) => {
  strm.msg = messages[errorCode];
  return errorCode;
};
var rank = (f3) => {
  return f3 * 2 - (f3 > 4 ? 9 : 0);
};
var zero = (buf) => {
  let len = buf.length;
  while (--len >= 0) {
    buf[len] = 0;
  }
};
var slide_hash = (s) => {
  let n, m;
  let p;
  let wsize = s.w_size;
  n = s.hash_size;
  p = n;
  do {
    m = s.head[--p];
    s.head[p] = m >= wsize ? m - wsize : 0;
  } while (--n);
  n = wsize;
  p = n;
  do {
    m = s.prev[--p];
    s.prev[p] = m >= wsize ? m - wsize : 0;
  } while (--n);
};
var HASH_ZLIB = (s, prev, data) => (prev << s.hash_shift ^ data) & s.hash_mask;
var HASH = HASH_ZLIB;
var flush_pending = (strm) => {
  const s = strm.state;
  let len = s.pending;
  if (len > strm.avail_out) {
    len = strm.avail_out;
  }
  if (len === 0) {
    return;
  }
  strm.output.set(s.pending_buf.subarray(s.pending_out, s.pending_out + len), strm.next_out);
  strm.next_out += len;
  s.pending_out += len;
  strm.total_out += len;
  strm.avail_out -= len;
  s.pending -= len;
  if (s.pending === 0) {
    s.pending_out = 0;
  }
};
var flush_block_only = (s, last) => {
  _tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);
  s.block_start = s.strstart;
  flush_pending(s.strm);
};
var put_byte = (s, b) => {
  s.pending_buf[s.pending++] = b;
};
var putShortMSB = (s, b) => {
  s.pending_buf[s.pending++] = b >>> 8 & 255;
  s.pending_buf[s.pending++] = b & 255;
};
var read_buf = (strm, buf, start, size4) => {
  let len = strm.avail_in;
  if (len > size4) {
    len = size4;
  }
  if (len === 0) {
    return 0;
  }
  strm.avail_in -= len;
  buf.set(strm.input.subarray(strm.next_in, strm.next_in + len), start);
  if (strm.state.wrap === 1) {
    strm.adler = adler32_1(strm.adler, buf, len, start);
  } else if (strm.state.wrap === 2) {
    strm.adler = crc32_1(strm.adler, buf, len, start);
  }
  strm.next_in += len;
  strm.total_in += len;
  return len;
};
var longest_match = (s, cur_match) => {
  let chain_length = s.max_chain_length;
  let scan = s.strstart;
  let match;
  let len;
  let best_len = s.prev_length;
  let nice_match = s.nice_match;
  const limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0;
  const _win = s.window;
  const wmask = s.w_mask;
  const prev = s.prev;
  const strend = s.strstart + MAX_MATCH;
  let scan_end1 = _win[scan + best_len - 1];
  let scan_end = _win[scan + best_len];
  if (s.prev_length >= s.good_match) {
    chain_length >>= 2;
  }
  if (nice_match > s.lookahead) {
    nice_match = s.lookahead;
  }
  do {
    match = cur_match;
    if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
      continue;
    }
    scan += 2;
    match++;
    do {
    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
    len = MAX_MATCH - (strend - scan);
    scan = strend - MAX_MATCH;
    if (len > best_len) {
      s.match_start = cur_match;
      best_len = len;
      if (len >= nice_match) {
        break;
      }
      scan_end1 = _win[scan + best_len - 1];
      scan_end = _win[scan + best_len];
    }
  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
  if (best_len <= s.lookahead) {
    return best_len;
  }
  return s.lookahead;
};
var fill_window = (s) => {
  const _w_size = s.w_size;
  let n, more, str2;
  do {
    more = s.window_size - s.lookahead - s.strstart;
    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
      s.window.set(s.window.subarray(_w_size, _w_size + _w_size - more), 0);
      s.match_start -= _w_size;
      s.strstart -= _w_size;
      s.block_start -= _w_size;
      if (s.insert > s.strstart) {
        s.insert = s.strstart;
      }
      slide_hash(s);
      more += _w_size;
    }
    if (s.strm.avail_in === 0) {
      break;
    }
    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
    s.lookahead += n;
    if (s.lookahead + s.insert >= MIN_MATCH) {
      str2 = s.strstart - s.insert;
      s.ins_h = s.window[str2];
      s.ins_h = HASH(s, s.ins_h, s.window[str2 + 1]);
      while (s.insert) {
        s.ins_h = HASH(s, s.ins_h, s.window[str2 + MIN_MATCH - 1]);
        s.prev[str2 & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = str2;
        str2++;
        s.insert--;
        if (s.lookahead + s.insert < MIN_MATCH) {
          break;
        }
      }
    }
  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);
};
var deflate_stored = (s, flush) => {
  let min_block = s.pending_buf_size - 5 > s.w_size ? s.w_size : s.pending_buf_size - 5;
  let len, left, have, last = 0;
  let used = s.strm.avail_in;
  do {
    len = 65535;
    have = s.bi_valid + 42 >> 3;
    if (s.strm.avail_out < have) {
      break;
    }
    have = s.strm.avail_out - have;
    left = s.strstart - s.block_start;
    if (len > left + s.strm.avail_in) {
      len = left + s.strm.avail_in;
    }
    if (len > have) {
      len = have;
    }
    if (len < min_block && (len === 0 && flush !== Z_FINISH$3 || flush === Z_NO_FLUSH$2 || len !== left + s.strm.avail_in)) {
      break;
    }
    last = flush === Z_FINISH$3 && len === left + s.strm.avail_in ? 1 : 0;
    _tr_stored_block(s, 0, 0, last);
    s.pending_buf[s.pending - 4] = len;
    s.pending_buf[s.pending - 3] = len >> 8;
    s.pending_buf[s.pending - 2] = ~len;
    s.pending_buf[s.pending - 1] = ~len >> 8;
    flush_pending(s.strm);
    if (left) {
      if (left > len) {
        left = len;
      }
      s.strm.output.set(s.window.subarray(s.block_start, s.block_start + left), s.strm.next_out);
      s.strm.next_out += left;
      s.strm.avail_out -= left;
      s.strm.total_out += left;
      s.block_start += left;
      len -= left;
    }
    if (len) {
      read_buf(s.strm, s.strm.output, s.strm.next_out, len);
      s.strm.next_out += len;
      s.strm.avail_out -= len;
      s.strm.total_out += len;
    }
  } while (last === 0);
  used -= s.strm.avail_in;
  if (used) {
    if (used >= s.w_size) {
      s.matches = 2;
      s.window.set(s.strm.input.subarray(s.strm.next_in - s.w_size, s.strm.next_in), 0);
      s.strstart = s.w_size;
      s.insert = s.strstart;
    } else {
      if (s.window_size - s.strstart <= used) {
        s.strstart -= s.w_size;
        s.window.set(s.window.subarray(s.w_size, s.w_size + s.strstart), 0);
        if (s.matches < 2) {
          s.matches++;
        }
        if (s.insert > s.strstart) {
          s.insert = s.strstart;
        }
      }
      s.window.set(s.strm.input.subarray(s.strm.next_in - used, s.strm.next_in), s.strstart);
      s.strstart += used;
      s.insert += used > s.w_size - s.insert ? s.w_size - s.insert : used;
    }
    s.block_start = s.strstart;
  }
  if (s.high_water < s.strstart) {
    s.high_water = s.strstart;
  }
  if (last) {
    return BS_FINISH_DONE;
  }
  if (flush !== Z_NO_FLUSH$2 && flush !== Z_FINISH$3 && s.strm.avail_in === 0 && s.strstart === s.block_start) {
    return BS_BLOCK_DONE;
  }
  have = s.window_size - s.strstart;
  if (s.strm.avail_in > have && s.block_start >= s.w_size) {
    s.block_start -= s.w_size;
    s.strstart -= s.w_size;
    s.window.set(s.window.subarray(s.w_size, s.w_size + s.strstart), 0);
    if (s.matches < 2) {
      s.matches++;
    }
    have += s.w_size;
    if (s.insert > s.strstart) {
      s.insert = s.strstart;
    }
  }
  if (have > s.strm.avail_in) {
    have = s.strm.avail_in;
  }
  if (have) {
    read_buf(s.strm, s.window, s.strstart, have);
    s.strstart += have;
    s.insert += have > s.w_size - s.insert ? s.w_size - s.insert : have;
  }
  if (s.high_water < s.strstart) {
    s.high_water = s.strstart;
  }
  have = s.bi_valid + 42 >> 3;
  have = s.pending_buf_size - have > 65535 ? 65535 : s.pending_buf_size - have;
  min_block = have > s.w_size ? s.w_size : have;
  left = s.strstart - s.block_start;
  if (left >= min_block || (left || flush === Z_FINISH$3) && flush !== Z_NO_FLUSH$2 && s.strm.avail_in === 0 && left <= have) {
    len = left > have ? have : left;
    last = flush === Z_FINISH$3 && s.strm.avail_in === 0 && len === left ? 1 : 0;
    _tr_stored_block(s, s.block_start, len, last);
    s.block_start += len;
    flush_pending(s.strm);
  }
  return last ? BS_FINISH_STARTED : BS_NEED_MORE;
};
var deflate_fast = (s, flush) => {
  let hash_head;
  let bflush;
  for (; ; ) {
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    hash_head = 0;
    if (s.lookahead >= MIN_MATCH) {
      s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
    }
    if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
      s.match_length = longest_match(s, hash_head);
    }
    if (s.match_length >= MIN_MATCH) {
      bflush = _tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);
      s.lookahead -= s.match_length;
      if (s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH) {
        s.match_length--;
        do {
          s.strstart++;
          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        } while (--s.match_length !== 0);
        s.strstart++;
      } else {
        s.strstart += s.match_length;
        s.match_length = 0;
        s.ins_h = s.window[s.strstart];
        s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + 1]);
      }
    } else {
      bflush = _tr_tally(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
  if (flush === Z_FINISH$3) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.sym_next) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
var deflate_slow = (s, flush) => {
  let hash_head;
  let bflush;
  let max_insert;
  for (; ; ) {
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    hash_head = 0;
    if (s.lookahead >= MIN_MATCH) {
      s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
    }
    s.prev_length = s.match_length;
    s.prev_match = s.match_start;
    s.match_length = MIN_MATCH - 1;
    if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
      s.match_length = longest_match(s, hash_head);
      if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096)) {
        s.match_length = MIN_MATCH - 1;
      }
    }
    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
      max_insert = s.strstart + s.lookahead - MIN_MATCH;
      bflush = _tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
      s.lookahead -= s.prev_length - 1;
      s.prev_length -= 2;
      do {
        if (++s.strstart <= max_insert) {
          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        }
      } while (--s.prev_length !== 0);
      s.match_available = 0;
      s.match_length = MIN_MATCH - 1;
      s.strstart++;
      if (bflush) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
    } else if (s.match_available) {
      bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);
      if (bflush) {
        flush_block_only(s, false);
      }
      s.strstart++;
      s.lookahead--;
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    } else {
      s.match_available = 1;
      s.strstart++;
      s.lookahead--;
    }
  }
  if (s.match_available) {
    bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);
    s.match_available = 0;
  }
  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
  if (flush === Z_FINISH$3) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.sym_next) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
var deflate_rle = (s, flush) => {
  let bflush;
  let prev;
  let scan, strend;
  const _win = s.window;
  for (; ; ) {
    if (s.lookahead <= MAX_MATCH) {
      fill_window(s);
      if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    s.match_length = 0;
    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
      scan = s.strstart - 1;
      prev = _win[scan];
      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
        strend = s.strstart + MAX_MATCH;
        do {
        } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
        s.match_length = MAX_MATCH - (strend - scan);
        if (s.match_length > s.lookahead) {
          s.match_length = s.lookahead;
        }
      }
    }
    if (s.match_length >= MIN_MATCH) {
      bflush = _tr_tally(s, 1, s.match_length - MIN_MATCH);
      s.lookahead -= s.match_length;
      s.strstart += s.match_length;
      s.match_length = 0;
    } else {
      bflush = _tr_tally(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH$3) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.sym_next) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
var deflate_huff = (s, flush) => {
  let bflush;
  for (; ; ) {
    if (s.lookahead === 0) {
      fill_window(s);
      if (s.lookahead === 0) {
        if (flush === Z_NO_FLUSH$2) {
          return BS_NEED_MORE;
        }
        break;
      }
    }
    s.match_length = 0;
    bflush = _tr_tally(s, 0, s.window[s.strstart]);
    s.lookahead--;
    s.strstart++;
    if (bflush) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH$3) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.sym_next) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
function Config(good_length, max_lazy, nice_length, max_chain, func) {
  this.good_length = good_length;
  this.max_lazy = max_lazy;
  this.nice_length = nice_length;
  this.max_chain = max_chain;
  this.func = func;
}
var configuration_table = [
  /*      good lazy nice chain */
  new Config(0, 0, 0, 0, deflate_stored),
  /* 0 store only */
  new Config(4, 4, 8, 4, deflate_fast),
  /* 1 max speed, no lazy matches */
  new Config(4, 5, 16, 8, deflate_fast),
  /* 2 */
  new Config(4, 6, 32, 32, deflate_fast),
  /* 3 */
  new Config(4, 4, 16, 16, deflate_slow),
  /* 4 lazy matches */
  new Config(8, 16, 32, 32, deflate_slow),
  /* 5 */
  new Config(8, 16, 128, 128, deflate_slow),
  /* 6 */
  new Config(8, 32, 128, 256, deflate_slow),
  /* 7 */
  new Config(32, 128, 258, 1024, deflate_slow),
  /* 8 */
  new Config(32, 258, 258, 4096, deflate_slow)
  /* 9 max compression */
];
var lm_init = (s) => {
  s.window_size = 2 * s.w_size;
  zero(s.head);
  s.max_lazy_match = configuration_table[s.level].max_lazy;
  s.good_match = configuration_table[s.level].good_length;
  s.nice_match = configuration_table[s.level].nice_length;
  s.max_chain_length = configuration_table[s.level].max_chain;
  s.strstart = 0;
  s.block_start = 0;
  s.lookahead = 0;
  s.insert = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  s.ins_h = 0;
};
function DeflateState() {
  this.strm = null;
  this.status = 0;
  this.pending_buf = null;
  this.pending_buf_size = 0;
  this.pending_out = 0;
  this.pending = 0;
  this.wrap = 0;
  this.gzhead = null;
  this.gzindex = 0;
  this.method = Z_DEFLATED$2;
  this.last_flush = -1;
  this.w_size = 0;
  this.w_bits = 0;
  this.w_mask = 0;
  this.window = null;
  this.window_size = 0;
  this.prev = null;
  this.head = null;
  this.ins_h = 0;
  this.hash_size = 0;
  this.hash_bits = 0;
  this.hash_mask = 0;
  this.hash_shift = 0;
  this.block_start = 0;
  this.match_length = 0;
  this.prev_match = 0;
  this.match_available = 0;
  this.strstart = 0;
  this.match_start = 0;
  this.lookahead = 0;
  this.prev_length = 0;
  this.max_chain_length = 0;
  this.max_lazy_match = 0;
  this.level = 0;
  this.strategy = 0;
  this.good_match = 0;
  this.nice_match = 0;
  this.dyn_ltree = new Uint16Array(HEAP_SIZE * 2);
  this.dyn_dtree = new Uint16Array((2 * D_CODES + 1) * 2);
  this.bl_tree = new Uint16Array((2 * BL_CODES + 1) * 2);
  zero(this.dyn_ltree);
  zero(this.dyn_dtree);
  zero(this.bl_tree);
  this.l_desc = null;
  this.d_desc = null;
  this.bl_desc = null;
  this.bl_count = new Uint16Array(MAX_BITS + 1);
  this.heap = new Uint16Array(2 * L_CODES + 1);
  zero(this.heap);
  this.heap_len = 0;
  this.heap_max = 0;
  this.depth = new Uint16Array(2 * L_CODES + 1);
  zero(this.depth);
  this.sym_buf = 0;
  this.lit_bufsize = 0;
  this.sym_next = 0;
  this.sym_end = 0;
  this.opt_len = 0;
  this.static_len = 0;
  this.matches = 0;
  this.insert = 0;
  this.bi_buf = 0;
  this.bi_valid = 0;
}
var deflateStateCheck = (strm) => {
  if (!strm) {
    return 1;
  }
  const s = strm.state;
  if (!s || s.strm !== strm || s.status !== INIT_STATE && //#ifdef GZIP
  s.status !== GZIP_STATE && //#endif
  s.status !== EXTRA_STATE && s.status !== NAME_STATE && s.status !== COMMENT_STATE && s.status !== HCRC_STATE && s.status !== BUSY_STATE && s.status !== FINISH_STATE) {
    return 1;
  }
  return 0;
};
var deflateResetKeep = (strm) => {
  if (deflateStateCheck(strm)) {
    return err(strm, Z_STREAM_ERROR$2);
  }
  strm.total_in = strm.total_out = 0;
  strm.data_type = Z_UNKNOWN;
  const s = strm.state;
  s.pending = 0;
  s.pending_out = 0;
  if (s.wrap < 0) {
    s.wrap = -s.wrap;
  }
  s.status = //#ifdef GZIP
  s.wrap === 2 ? GZIP_STATE : (
    //#endif
    s.wrap ? INIT_STATE : BUSY_STATE
  );
  strm.adler = s.wrap === 2 ? 0 : 1;
  s.last_flush = -2;
  _tr_init(s);
  return Z_OK$3;
};
var deflateReset = (strm) => {
  const ret = deflateResetKeep(strm);
  if (ret === Z_OK$3) {
    lm_init(strm.state);
  }
  return ret;
};
var deflateSetHeader = (strm, head) => {
  if (deflateStateCheck(strm) || strm.state.wrap !== 2) {
    return Z_STREAM_ERROR$2;
  }
  strm.state.gzhead = head;
  return Z_OK$3;
};
var deflateInit2 = (strm, level, method, windowBits, memLevel, strategy) => {
  if (!strm) {
    return Z_STREAM_ERROR$2;
  }
  let wrap = 1;
  if (level === Z_DEFAULT_COMPRESSION$1) {
    level = 6;
  }
  if (windowBits < 0) {
    wrap = 0;
    windowBits = -windowBits;
  } else if (windowBits > 15) {
    wrap = 2;
    windowBits -= 16;
  }
  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED$2 || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED || windowBits === 8 && wrap !== 1) {
    return err(strm, Z_STREAM_ERROR$2);
  }
  if (windowBits === 8) {
    windowBits = 9;
  }
  const s = new DeflateState();
  strm.state = s;
  s.strm = strm;
  s.status = INIT_STATE;
  s.wrap = wrap;
  s.gzhead = null;
  s.w_bits = windowBits;
  s.w_size = 1 << s.w_bits;
  s.w_mask = s.w_size - 1;
  s.hash_bits = memLevel + 7;
  s.hash_size = 1 << s.hash_bits;
  s.hash_mask = s.hash_size - 1;
  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
  s.window = new Uint8Array(s.w_size * 2);
  s.head = new Uint16Array(s.hash_size);
  s.prev = new Uint16Array(s.w_size);
  s.lit_bufsize = 1 << memLevel + 6;
  s.pending_buf_size = s.lit_bufsize * 4;
  s.pending_buf = new Uint8Array(s.pending_buf_size);
  s.sym_buf = s.lit_bufsize;
  s.sym_end = (s.lit_bufsize - 1) * 3;
  s.level = level;
  s.strategy = strategy;
  s.method = method;
  return deflateReset(strm);
};
var deflateInit = (strm, level) => {
  return deflateInit2(strm, level, Z_DEFLATED$2, MAX_WBITS$1, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY$1);
};
var deflate$2 = (strm, flush) => {
  if (deflateStateCheck(strm) || flush > Z_BLOCK$1 || flush < 0) {
    return strm ? err(strm, Z_STREAM_ERROR$2) : Z_STREAM_ERROR$2;
  }
  const s = strm.state;
  if (!strm.output || strm.avail_in !== 0 && !strm.input || s.status === FINISH_STATE && flush !== Z_FINISH$3) {
    return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR$1 : Z_STREAM_ERROR$2);
  }
  const old_flush = s.last_flush;
  s.last_flush = flush;
  if (s.pending !== 0) {
    flush_pending(strm);
    if (strm.avail_out === 0) {
      s.last_flush = -1;
      return Z_OK$3;
    }
  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH$3) {
    return err(strm, Z_BUF_ERROR$1);
  }
  if (s.status === FINISH_STATE && strm.avail_in !== 0) {
    return err(strm, Z_BUF_ERROR$1);
  }
  if (s.status === INIT_STATE && s.wrap === 0) {
    s.status = BUSY_STATE;
  }
  if (s.status === INIT_STATE) {
    let header = Z_DEFLATED$2 + (s.w_bits - 8 << 4) << 8;
    let level_flags = -1;
    if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
      level_flags = 0;
    } else if (s.level < 6) {
      level_flags = 1;
    } else if (s.level === 6) {
      level_flags = 2;
    } else {
      level_flags = 3;
    }
    header |= level_flags << 6;
    if (s.strstart !== 0) {
      header |= PRESET_DICT;
    }
    header += 31 - header % 31;
    putShortMSB(s, header);
    if (s.strstart !== 0) {
      putShortMSB(s, strm.adler >>> 16);
      putShortMSB(s, strm.adler & 65535);
    }
    strm.adler = 1;
    s.status = BUSY_STATE;
    flush_pending(strm);
    if (s.pending !== 0) {
      s.last_flush = -1;
      return Z_OK$3;
    }
  }
  if (s.status === GZIP_STATE) {
    strm.adler = 0;
    put_byte(s, 31);
    put_byte(s, 139);
    put_byte(s, 8);
    if (!s.gzhead) {
      put_byte(s, 0);
      put_byte(s, 0);
      put_byte(s, 0);
      put_byte(s, 0);
      put_byte(s, 0);
      put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
      put_byte(s, OS_CODE);
      s.status = BUSY_STATE;
      flush_pending(strm);
      if (s.pending !== 0) {
        s.last_flush = -1;
        return Z_OK$3;
      }
    } else {
      put_byte(
        s,
        (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16)
      );
      put_byte(s, s.gzhead.time & 255);
      put_byte(s, s.gzhead.time >> 8 & 255);
      put_byte(s, s.gzhead.time >> 16 & 255);
      put_byte(s, s.gzhead.time >> 24 & 255);
      put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
      put_byte(s, s.gzhead.os & 255);
      if (s.gzhead.extra && s.gzhead.extra.length) {
        put_byte(s, s.gzhead.extra.length & 255);
        put_byte(s, s.gzhead.extra.length >> 8 & 255);
      }
      if (s.gzhead.hcrc) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending, 0);
      }
      s.gzindex = 0;
      s.status = EXTRA_STATE;
    }
  }
  if (s.status === EXTRA_STATE) {
    if (s.gzhead.extra) {
      let beg = s.pending;
      let left = (s.gzhead.extra.length & 65535) - s.gzindex;
      while (s.pending + left > s.pending_buf_size) {
        let copy = s.pending_buf_size - s.pending;
        s.pending_buf.set(s.gzhead.extra.subarray(s.gzindex, s.gzindex + copy), s.pending);
        s.pending = s.pending_buf_size;
        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
        }
        s.gzindex += copy;
        flush_pending(strm);
        if (s.pending !== 0) {
          s.last_flush = -1;
          return Z_OK$3;
        }
        beg = 0;
        left -= copy;
      }
      let gzhead_extra = new Uint8Array(s.gzhead.extra);
      s.pending_buf.set(gzhead_extra.subarray(s.gzindex, s.gzindex + left), s.pending);
      s.pending += left;
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      s.gzindex = 0;
    }
    s.status = NAME_STATE;
  }
  if (s.status === NAME_STATE) {
    if (s.gzhead.name) {
      let beg = s.pending;
      let val;
      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          if (s.pending !== 0) {
            s.last_flush = -1;
            return Z_OK$3;
          }
          beg = 0;
        }
        if (s.gzindex < s.gzhead.name.length) {
          val = s.gzhead.name.charCodeAt(s.gzindex++) & 255;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      s.gzindex = 0;
    }
    s.status = COMMENT_STATE;
  }
  if (s.status === COMMENT_STATE) {
    if (s.gzhead.comment) {
      let beg = s.pending;
      let val;
      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          if (s.pending !== 0) {
            s.last_flush = -1;
            return Z_OK$3;
          }
          beg = 0;
        }
        if (s.gzindex < s.gzhead.comment.length) {
          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 255;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
    }
    s.status = HCRC_STATE;
  }
  if (s.status === HCRC_STATE) {
    if (s.gzhead.hcrc) {
      if (s.pending + 2 > s.pending_buf_size) {
        flush_pending(strm);
        if (s.pending !== 0) {
          s.last_flush = -1;
          return Z_OK$3;
        }
      }
      put_byte(s, strm.adler & 255);
      put_byte(s, strm.adler >> 8 & 255);
      strm.adler = 0;
    }
    s.status = BUSY_STATE;
    flush_pending(strm);
    if (s.pending !== 0) {
      s.last_flush = -1;
      return Z_OK$3;
    }
  }
  if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH$2 && s.status !== FINISH_STATE) {
    let bstate = s.level === 0 ? deflate_stored(s, flush) : s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);
    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
      s.status = FINISH_STATE;
    }
    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
      if (strm.avail_out === 0) {
        s.last_flush = -1;
      }
      return Z_OK$3;
    }
    if (bstate === BS_BLOCK_DONE) {
      if (flush === Z_PARTIAL_FLUSH) {
        _tr_align(s);
      } else if (flush !== Z_BLOCK$1) {
        _tr_stored_block(s, 0, 0, false);
        if (flush === Z_FULL_FLUSH$1) {
          zero(s.head);
          if (s.lookahead === 0) {
            s.strstart = 0;
            s.block_start = 0;
            s.insert = 0;
          }
        }
      }
      flush_pending(strm);
      if (strm.avail_out === 0) {
        s.last_flush = -1;
        return Z_OK$3;
      }
    }
  }
  if (flush !== Z_FINISH$3) {
    return Z_OK$3;
  }
  if (s.wrap <= 0) {
    return Z_STREAM_END$3;
  }
  if (s.wrap === 2) {
    put_byte(s, strm.adler & 255);
    put_byte(s, strm.adler >> 8 & 255);
    put_byte(s, strm.adler >> 16 & 255);
    put_byte(s, strm.adler >> 24 & 255);
    put_byte(s, strm.total_in & 255);
    put_byte(s, strm.total_in >> 8 & 255);
    put_byte(s, strm.total_in >> 16 & 255);
    put_byte(s, strm.total_in >> 24 & 255);
  } else {
    putShortMSB(s, strm.adler >>> 16);
    putShortMSB(s, strm.adler & 65535);
  }
  flush_pending(strm);
  if (s.wrap > 0) {
    s.wrap = -s.wrap;
  }
  return s.pending !== 0 ? Z_OK$3 : Z_STREAM_END$3;
};
var deflateEnd = (strm) => {
  if (deflateStateCheck(strm)) {
    return Z_STREAM_ERROR$2;
  }
  const status = strm.state.status;
  strm.state = null;
  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR$2) : Z_OK$3;
};
var deflateSetDictionary = (strm, dictionary) => {
  let dictLength = dictionary.length;
  if (deflateStateCheck(strm)) {
    return Z_STREAM_ERROR$2;
  }
  const s = strm.state;
  const wrap = s.wrap;
  if (wrap === 2 || wrap === 1 && s.status !== INIT_STATE || s.lookahead) {
    return Z_STREAM_ERROR$2;
  }
  if (wrap === 1) {
    strm.adler = adler32_1(strm.adler, dictionary, dictLength, 0);
  }
  s.wrap = 0;
  if (dictLength >= s.w_size) {
    if (wrap === 0) {
      zero(s.head);
      s.strstart = 0;
      s.block_start = 0;
      s.insert = 0;
    }
    let tmpDict = new Uint8Array(s.w_size);
    tmpDict.set(dictionary.subarray(dictLength - s.w_size, dictLength), 0);
    dictionary = tmpDict;
    dictLength = s.w_size;
  }
  const avail = strm.avail_in;
  const next = strm.next_in;
  const input = strm.input;
  strm.avail_in = dictLength;
  strm.next_in = 0;
  strm.input = dictionary;
  fill_window(s);
  while (s.lookahead >= MIN_MATCH) {
    let str2 = s.strstart;
    let n = s.lookahead - (MIN_MATCH - 1);
    do {
      s.ins_h = HASH(s, s.ins_h, s.window[str2 + MIN_MATCH - 1]);
      s.prev[str2 & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = str2;
      str2++;
    } while (--n);
    s.strstart = str2;
    s.lookahead = MIN_MATCH - 1;
    fill_window(s);
  }
  s.strstart += s.lookahead;
  s.block_start = s.strstart;
  s.insert = s.lookahead;
  s.lookahead = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  strm.next_in = next;
  strm.input = input;
  strm.avail_in = avail;
  s.wrap = wrap;
  return Z_OK$3;
};
var deflateInit_1 = deflateInit;
var deflateInit2_1 = deflateInit2;
var deflateReset_1 = deflateReset;
var deflateResetKeep_1 = deflateResetKeep;
var deflateSetHeader_1 = deflateSetHeader;
var deflate_2$1 = deflate$2;
var deflateEnd_1 = deflateEnd;
var deflateSetDictionary_1 = deflateSetDictionary;
var deflateInfo = "pako deflate (from Nodeca project)";
var deflate_1$2 = {
  deflateInit: deflateInit_1,
  deflateInit2: deflateInit2_1,
  deflateReset: deflateReset_1,
  deflateResetKeep: deflateResetKeep_1,
  deflateSetHeader: deflateSetHeader_1,
  deflate: deflate_2$1,
  deflateEnd: deflateEnd_1,
  deflateSetDictionary: deflateSetDictionary_1,
  deflateInfo
};
var _has = (obj, key) => {
  return Object.prototype.hasOwnProperty.call(obj, key);
};
var assign = function(obj) {
  const sources = Array.prototype.slice.call(arguments, 1);
  while (sources.length) {
    const source = sources.shift();
    if (!source) {
      continue;
    }
    if (typeof source !== "object") {
      throw new TypeError(source + "must be non-object");
    }
    for (const p in source) {
      if (_has(source, p)) {
        obj[p] = source[p];
      }
    }
  }
  return obj;
};
var flattenChunks = (chunks2) => {
  let len = 0;
  for (let i = 0, l = chunks2.length; i < l; i++) {
    len += chunks2[i].length;
  }
  const result = new Uint8Array(len);
  for (let i = 0, pos = 0, l = chunks2.length; i < l; i++) {
    let chunk = chunks2[i];
    result.set(chunk, pos);
    pos += chunk.length;
  }
  return result;
};
var common = {
  assign,
  flattenChunks
};
var STR_APPLY_UIA_OK = true;
try {
  String.fromCharCode.apply(null, new Uint8Array(1));
} catch (__) {
  STR_APPLY_UIA_OK = false;
}
var _utf8len = new Uint8Array(256);
for (let q = 0; q < 256; q++) {
  _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
}
_utf8len[254] = _utf8len[254] = 1;
var string2buf = (str2) => {
  if (typeof TextEncoder === "function" && TextEncoder.prototype.encode) {
    return new TextEncoder().encode(str2);
  }
  let buf, c, c2, m_pos, i, str_len = str2.length, buf_len = 0;
  for (m_pos = 0; m_pos < str_len; m_pos++) {
    c = str2.charCodeAt(m_pos);
    if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
      c2 = str2.charCodeAt(m_pos + 1);
      if ((c2 & 64512) === 56320) {
        c = 65536 + (c - 55296 << 10) + (c2 - 56320);
        m_pos++;
      }
    }
    buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;
  }
  buf = new Uint8Array(buf_len);
  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
    c = str2.charCodeAt(m_pos);
    if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
      c2 = str2.charCodeAt(m_pos + 1);
      if ((c2 & 64512) === 56320) {
        c = 65536 + (c - 55296 << 10) + (c2 - 56320);
        m_pos++;
      }
    }
    if (c < 128) {
      buf[i++] = c;
    } else if (c < 2048) {
      buf[i++] = 192 | c >>> 6;
      buf[i++] = 128 | c & 63;
    } else if (c < 65536) {
      buf[i++] = 224 | c >>> 12;
      buf[i++] = 128 | c >>> 6 & 63;
      buf[i++] = 128 | c & 63;
    } else {
      buf[i++] = 240 | c >>> 18;
      buf[i++] = 128 | c >>> 12 & 63;
      buf[i++] = 128 | c >>> 6 & 63;
      buf[i++] = 128 | c & 63;
    }
  }
  return buf;
};
var buf2binstring = (buf, len) => {
  if (len < 65534) {
    if (buf.subarray && STR_APPLY_UIA_OK) {
      return String.fromCharCode.apply(null, buf.length === len ? buf : buf.subarray(0, len));
    }
  }
  let result = "";
  for (let i = 0; i < len; i++) {
    result += String.fromCharCode(buf[i]);
  }
  return result;
};
var buf2string = (buf, max) => {
  const len = max || buf.length;
  if (typeof TextDecoder === "function" && TextDecoder.prototype.decode) {
    return new TextDecoder().decode(buf.subarray(0, max));
  }
  let i, out;
  const utf16buf = new Array(len * 2);
  for (out = 0, i = 0; i < len; ) {
    let c = buf[i++];
    if (c < 128) {
      utf16buf[out++] = c;
      continue;
    }
    let c_len = _utf8len[c];
    if (c_len > 4) {
      utf16buf[out++] = 65533;
      i += c_len - 1;
      continue;
    }
    c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
    while (c_len > 1 && i < len) {
      c = c << 6 | buf[i++] & 63;
      c_len--;
    }
    if (c_len > 1) {
      utf16buf[out++] = 65533;
      continue;
    }
    if (c < 65536) {
      utf16buf[out++] = c;
    } else {
      c -= 65536;
      utf16buf[out++] = 55296 | c >> 10 & 1023;
      utf16buf[out++] = 56320 | c & 1023;
    }
  }
  return buf2binstring(utf16buf, out);
};
var utf8border = (buf, max) => {
  max = max || buf.length;
  if (max > buf.length) {
    max = buf.length;
  }
  let pos = max - 1;
  while (pos >= 0 && (buf[pos] & 192) === 128) {
    pos--;
  }
  if (pos < 0) {
    return max;
  }
  if (pos === 0) {
    return max;
  }
  return pos + _utf8len[buf[pos]] > max ? pos : max;
};
var strings = {
  string2buf,
  buf2string,
  utf8border
};
function ZStream() {
  this.input = null;
  this.next_in = 0;
  this.avail_in = 0;
  this.total_in = 0;
  this.output = null;
  this.next_out = 0;
  this.avail_out = 0;
  this.total_out = 0;
  this.msg = "";
  this.state = null;
  this.data_type = 2;
  this.adler = 0;
}
var zstream = ZStream;
var toString$1 = Object.prototype.toString;
var {
  Z_NO_FLUSH: Z_NO_FLUSH$1,
  Z_SYNC_FLUSH,
  Z_FULL_FLUSH,
  Z_FINISH: Z_FINISH$2,
  Z_OK: Z_OK$2,
  Z_STREAM_END: Z_STREAM_END$2,
  Z_DEFAULT_COMPRESSION,
  Z_DEFAULT_STRATEGY,
  Z_DEFLATED: Z_DEFLATED$1
} = constants$2;
function Deflate$1(options) {
  this.options = common.assign({
    level: Z_DEFAULT_COMPRESSION,
    method: Z_DEFLATED$1,
    chunkSize: 16384,
    windowBits: 15,
    memLevel: 8,
    strategy: Z_DEFAULT_STRATEGY
  }, options || {});
  let opt = this.options;
  if (opt.raw && opt.windowBits > 0) {
    opt.windowBits = -opt.windowBits;
  } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
    opt.windowBits += 16;
  }
  this.err = 0;
  this.msg = "";
  this.ended = false;
  this.chunks = [];
  this.strm = new zstream();
  this.strm.avail_out = 0;
  let status = deflate_1$2.deflateInit2(
    this.strm,
    opt.level,
    opt.method,
    opt.windowBits,
    opt.memLevel,
    opt.strategy
  );
  if (status !== Z_OK$2) {
    throw new Error(messages[status]);
  }
  if (opt.header) {
    deflate_1$2.deflateSetHeader(this.strm, opt.header);
  }
  if (opt.dictionary) {
    let dict;
    if (typeof opt.dictionary === "string") {
      dict = strings.string2buf(opt.dictionary);
    } else if (toString$1.call(opt.dictionary) === "[object ArrayBuffer]") {
      dict = new Uint8Array(opt.dictionary);
    } else {
      dict = opt.dictionary;
    }
    status = deflate_1$2.deflateSetDictionary(this.strm, dict);
    if (status !== Z_OK$2) {
      throw new Error(messages[status]);
    }
    this._dict_set = true;
  }
}
Deflate$1.prototype.push = function(data, flush_mode) {
  const strm = this.strm;
  const chunkSize = this.options.chunkSize;
  let status, _flush_mode;
  if (this.ended) {
    return false;
  }
  if (flush_mode === ~~flush_mode) _flush_mode = flush_mode;
  else _flush_mode = flush_mode === true ? Z_FINISH$2 : Z_NO_FLUSH$1;
  if (typeof data === "string") {
    strm.input = strings.string2buf(data);
  } else if (toString$1.call(data) === "[object ArrayBuffer]") {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }
  strm.next_in = 0;
  strm.avail_in = strm.input.length;
  for (; ; ) {
    if (strm.avail_out === 0) {
      strm.output = new Uint8Array(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }
    if ((_flush_mode === Z_SYNC_FLUSH || _flush_mode === Z_FULL_FLUSH) && strm.avail_out <= 6) {
      this.onData(strm.output.subarray(0, strm.next_out));
      strm.avail_out = 0;
      continue;
    }
    status = deflate_1$2.deflate(strm, _flush_mode);
    if (status === Z_STREAM_END$2) {
      if (strm.next_out > 0) {
        this.onData(strm.output.subarray(0, strm.next_out));
      }
      status = deflate_1$2.deflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return status === Z_OK$2;
    }
    if (strm.avail_out === 0) {
      this.onData(strm.output);
      continue;
    }
    if (_flush_mode > 0 && strm.next_out > 0) {
      this.onData(strm.output.subarray(0, strm.next_out));
      strm.avail_out = 0;
      continue;
    }
    if (strm.avail_in === 0) break;
  }
  return true;
};
Deflate$1.prototype.onData = function(chunk) {
  this.chunks.push(chunk);
};
Deflate$1.prototype.onEnd = function(status) {
  if (status === Z_OK$2) {
    this.result = common.flattenChunks(this.chunks);
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};
function deflate$1(input, options) {
  const deflator = new Deflate$1(options);
  deflator.push(input, true);
  if (deflator.err) {
    throw deflator.msg || messages[deflator.err];
  }
  return deflator.result;
}
function deflateRaw$1(input, options) {
  options = options || {};
  options.raw = true;
  return deflate$1(input, options);
}
function gzip$1(input, options) {
  options = options || {};
  options.gzip = true;
  return deflate$1(input, options);
}
var Deflate_1$1 = Deflate$1;
var deflate_2 = deflate$1;
var deflateRaw_1$1 = deflateRaw$1;
var gzip_1$1 = gzip$1;
var constants$1 = constants$2;
var deflate_1$1 = {
  Deflate: Deflate_1$1,
  deflate: deflate_2,
  deflateRaw: deflateRaw_1$1,
  gzip: gzip_1$1,
  constants: constants$1
};
var BAD$1 = 16209;
var TYPE$1 = 16191;
var inffast = function inflate_fast(strm, start) {
  let _in;
  let last;
  let _out;
  let beg;
  let end;
  let dmax;
  let wsize;
  let whave;
  let wnext;
  let s_window;
  let hold;
  let bits;
  let lcode;
  let dcode;
  let lmask;
  let dmask;
  let here;
  let op;
  let len;
  let dist;
  let from2;
  let from_source;
  let input, output4;
  const state = strm.state;
  _in = strm.next_in;
  input = strm.input;
  last = _in + (strm.avail_in - 5);
  _out = strm.next_out;
  output4 = strm.output;
  beg = _out - (start - strm.avail_out);
  end = _out + (strm.avail_out - 257);
  dmax = state.dmax;
  wsize = state.wsize;
  whave = state.whave;
  wnext = state.wnext;
  s_window = state.window;
  hold = state.hold;
  bits = state.bits;
  lcode = state.lencode;
  dcode = state.distcode;
  lmask = (1 << state.lenbits) - 1;
  dmask = (1 << state.distbits) - 1;
  top:
    do {
      if (bits < 15) {
        hold += input[_in++] << bits;
        bits += 8;
        hold += input[_in++] << bits;
        bits += 8;
      }
      here = lcode[hold & lmask];
      dolen:
        for (; ; ) {
          op = here >>> 24;
          hold >>>= op;
          bits -= op;
          op = here >>> 16 & 255;
          if (op === 0) {
            output4[_out++] = here & 65535;
          } else if (op & 16) {
            len = here & 65535;
            op &= 15;
            if (op) {
              if (bits < op) {
                hold += input[_in++] << bits;
                bits += 8;
              }
              len += hold & (1 << op) - 1;
              hold >>>= op;
              bits -= op;
            }
            if (bits < 15) {
              hold += input[_in++] << bits;
              bits += 8;
              hold += input[_in++] << bits;
              bits += 8;
            }
            here = dcode[hold & dmask];
            dodist:
              for (; ; ) {
                op = here >>> 24;
                hold >>>= op;
                bits -= op;
                op = here >>> 16 & 255;
                if (op & 16) {
                  dist = here & 65535;
                  op &= 15;
                  if (bits < op) {
                    hold += input[_in++] << bits;
                    bits += 8;
                    if (bits < op) {
                      hold += input[_in++] << bits;
                      bits += 8;
                    }
                  }
                  dist += hold & (1 << op) - 1;
                  if (dist > dmax) {
                    strm.msg = "invalid distance too far back";
                    state.mode = BAD$1;
                    break top;
                  }
                  hold >>>= op;
                  bits -= op;
                  op = _out - beg;
                  if (dist > op) {
                    op = dist - op;
                    if (op > whave) {
                      if (state.sane) {
                        strm.msg = "invalid distance too far back";
                        state.mode = BAD$1;
                        break top;
                      }
                    }
                    from2 = 0;
                    from_source = s_window;
                    if (wnext === 0) {
                      from2 += wsize - op;
                      if (op < len) {
                        len -= op;
                        do {
                          output4[_out++] = s_window[from2++];
                        } while (--op);
                        from2 = _out - dist;
                        from_source = output4;
                      }
                    } else if (wnext < op) {
                      from2 += wsize + wnext - op;
                      op -= wnext;
                      if (op < len) {
                        len -= op;
                        do {
                          output4[_out++] = s_window[from2++];
                        } while (--op);
                        from2 = 0;
                        if (wnext < len) {
                          op = wnext;
                          len -= op;
                          do {
                            output4[_out++] = s_window[from2++];
                          } while (--op);
                          from2 = _out - dist;
                          from_source = output4;
                        }
                      }
                    } else {
                      from2 += wnext - op;
                      if (op < len) {
                        len -= op;
                        do {
                          output4[_out++] = s_window[from2++];
                        } while (--op);
                        from2 = _out - dist;
                        from_source = output4;
                      }
                    }
                    while (len > 2) {
                      output4[_out++] = from_source[from2++];
                      output4[_out++] = from_source[from2++];
                      output4[_out++] = from_source[from2++];
                      len -= 3;
                    }
                    if (len) {
                      output4[_out++] = from_source[from2++];
                      if (len > 1) {
                        output4[_out++] = from_source[from2++];
                      }
                    }
                  } else {
                    from2 = _out - dist;
                    do {
                      output4[_out++] = output4[from2++];
                      output4[_out++] = output4[from2++];
                      output4[_out++] = output4[from2++];
                      len -= 3;
                    } while (len > 2);
                    if (len) {
                      output4[_out++] = output4[from2++];
                      if (len > 1) {
                        output4[_out++] = output4[from2++];
                      }
                    }
                  }
                } else if ((op & 64) === 0) {
                  here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                  continue dodist;
                } else {
                  strm.msg = "invalid distance code";
                  state.mode = BAD$1;
                  break top;
                }
                break;
              }
          } else if ((op & 64) === 0) {
            here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
            continue dolen;
          } else if (op & 32) {
            state.mode = TYPE$1;
            break top;
          } else {
            strm.msg = "invalid literal/length code";
            state.mode = BAD$1;
            break top;
          }
          break;
        }
    } while (_in < last && _out < end);
  len = bits >> 3;
  _in -= len;
  bits -= len << 3;
  hold &= (1 << bits) - 1;
  strm.next_in = _in;
  strm.next_out = _out;
  strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
  strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
  state.hold = hold;
  state.bits = bits;
  return;
};
var MAXBITS = 15;
var ENOUGH_LENS$1 = 852;
var ENOUGH_DISTS$1 = 592;
var CODES$1 = 0;
var LENS$1 = 1;
var DISTS$1 = 2;
var lbase = new Uint16Array([
  /* Length codes 257..285 base */
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  13,
  15,
  17,
  19,
  23,
  27,
  31,
  35,
  43,
  51,
  59,
  67,
  83,
  99,
  115,
  131,
  163,
  195,
  227,
  258,
  0,
  0
]);
var lext = new Uint8Array([
  /* Length codes 257..285 extra */
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  17,
  17,
  17,
  17,
  18,
  18,
  18,
  18,
  19,
  19,
  19,
  19,
  20,
  20,
  20,
  20,
  21,
  21,
  21,
  21,
  16,
  72,
  78
]);
var dbase = new Uint16Array([
  /* Distance codes 0..29 base */
  1,
  2,
  3,
  4,
  5,
  7,
  9,
  13,
  17,
  25,
  33,
  49,
  65,
  97,
  129,
  193,
  257,
  385,
  513,
  769,
  1025,
  1537,
  2049,
  3073,
  4097,
  6145,
  8193,
  12289,
  16385,
  24577,
  0,
  0
]);
var dext = new Uint8Array([
  /* Distance codes 0..29 extra */
  16,
  16,
  16,
  16,
  17,
  17,
  18,
  18,
  19,
  19,
  20,
  20,
  21,
  21,
  22,
  22,
  23,
  23,
  24,
  24,
  25,
  25,
  26,
  26,
  27,
  27,
  28,
  28,
  29,
  29,
  64,
  64
]);
var inflate_table = (type3, lens, lens_index, codes, table, table_index, work, opts) => {
  const bits = opts.bits;
  let len = 0;
  let sym = 0;
  let min = 0, max = 0;
  let root2 = 0;
  let curr = 0;
  let drop = 0;
  let left = 0;
  let used = 0;
  let huff = 0;
  let incr;
  let fill;
  let low;
  let mask3;
  let next;
  let base3 = null;
  let match;
  const count = new Uint16Array(MAXBITS + 1);
  const offs = new Uint16Array(MAXBITS + 1);
  let extra = null;
  let here_bits, here_op, here_val;
  for (len = 0; len <= MAXBITS; len++) {
    count[len] = 0;
  }
  for (sym = 0; sym < codes; sym++) {
    count[lens[lens_index + sym]]++;
  }
  root2 = bits;
  for (max = MAXBITS; max >= 1; max--) {
    if (count[max] !== 0) {
      break;
    }
  }
  if (root2 > max) {
    root2 = max;
  }
  if (max === 0) {
    table[table_index++] = 1 << 24 | 64 << 16 | 0;
    table[table_index++] = 1 << 24 | 64 << 16 | 0;
    opts.bits = 1;
    return 0;
  }
  for (min = 1; min < max; min++) {
    if (count[min] !== 0) {
      break;
    }
  }
  if (root2 < min) {
    root2 = min;
  }
  left = 1;
  for (len = 1; len <= MAXBITS; len++) {
    left <<= 1;
    left -= count[len];
    if (left < 0) {
      return -1;
    }
  }
  if (left > 0 && (type3 === CODES$1 || max !== 1)) {
    return -1;
  }
  offs[1] = 0;
  for (len = 1; len < MAXBITS; len++) {
    offs[len + 1] = offs[len] + count[len];
  }
  for (sym = 0; sym < codes; sym++) {
    if (lens[lens_index + sym] !== 0) {
      work[offs[lens[lens_index + sym]]++] = sym;
    }
  }
  if (type3 === CODES$1) {
    base3 = extra = work;
    match = 20;
  } else if (type3 === LENS$1) {
    base3 = lbase;
    extra = lext;
    match = 257;
  } else {
    base3 = dbase;
    extra = dext;
    match = 0;
  }
  huff = 0;
  sym = 0;
  len = min;
  next = table_index;
  curr = root2;
  drop = 0;
  low = -1;
  used = 1 << root2;
  mask3 = used - 1;
  if (type3 === LENS$1 && used > ENOUGH_LENS$1 || type3 === DISTS$1 && used > ENOUGH_DISTS$1) {
    return 1;
  }
  for (; ; ) {
    here_bits = len - drop;
    if (work[sym] + 1 < match) {
      here_op = 0;
      here_val = work[sym];
    } else if (work[sym] >= match) {
      here_op = extra[work[sym] - match];
      here_val = base3[work[sym] - match];
    } else {
      here_op = 32 + 64;
      here_val = 0;
    }
    incr = 1 << len - drop;
    fill = 1 << curr;
    min = fill;
    do {
      fill -= incr;
      table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
    } while (fill !== 0);
    incr = 1 << len - 1;
    while (huff & incr) {
      incr >>= 1;
    }
    if (incr !== 0) {
      huff &= incr - 1;
      huff += incr;
    } else {
      huff = 0;
    }
    sym++;
    if (--count[len] === 0) {
      if (len === max) {
        break;
      }
      len = lens[lens_index + work[sym]];
    }
    if (len > root2 && (huff & mask3) !== low) {
      if (drop === 0) {
        drop = root2;
      }
      next += min;
      curr = len - drop;
      left = 1 << curr;
      while (curr + drop < max) {
        left -= count[curr + drop];
        if (left <= 0) {
          break;
        }
        curr++;
        left <<= 1;
      }
      used += 1 << curr;
      if (type3 === LENS$1 && used > ENOUGH_LENS$1 || type3 === DISTS$1 && used > ENOUGH_DISTS$1) {
        return 1;
      }
      low = huff & mask3;
      table[low] = root2 << 24 | curr << 16 | next - table_index | 0;
    }
  }
  if (huff !== 0) {
    table[next + huff] = len - drop << 24 | 64 << 16 | 0;
  }
  opts.bits = root2;
  return 0;
};
var inftrees = inflate_table;
var CODES = 0;
var LENS = 1;
var DISTS = 2;
var {
  Z_FINISH: Z_FINISH$1,
  Z_BLOCK,
  Z_TREES,
  Z_OK: Z_OK$1,
  Z_STREAM_END: Z_STREAM_END$1,
  Z_NEED_DICT: Z_NEED_DICT$1,
  Z_STREAM_ERROR: Z_STREAM_ERROR$1,
  Z_DATA_ERROR: Z_DATA_ERROR$1,
  Z_MEM_ERROR: Z_MEM_ERROR$1,
  Z_BUF_ERROR,
  Z_DEFLATED
} = constants$2;
var HEAD = 16180;
var FLAGS = 16181;
var TIME = 16182;
var OS = 16183;
var EXLEN = 16184;
var EXTRA = 16185;
var NAME = 16186;
var COMMENT = 16187;
var HCRC = 16188;
var DICTID = 16189;
var DICT = 16190;
var TYPE2 = 16191;
var TYPEDO = 16192;
var STORED = 16193;
var COPY_ = 16194;
var COPY = 16195;
var TABLE = 16196;
var LENLENS = 16197;
var CODELENS = 16198;
var LEN_ = 16199;
var LEN = 16200;
var LENEXT = 16201;
var DIST = 16202;
var DISTEXT = 16203;
var MATCH = 16204;
var LIT = 16205;
var CHECK = 16206;
var LENGTH = 16207;
var DONE = 16208;
var BAD = 16209;
var MEM = 16210;
var SYNC = 16211;
var ENOUGH_LENS = 852;
var ENOUGH_DISTS = 592;
var MAX_WBITS = 15;
var DEF_WBITS = MAX_WBITS;
var zswap32 = (q) => {
  return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
};
function InflateState() {
  this.strm = null;
  this.mode = 0;
  this.last = false;
  this.wrap = 0;
  this.havedict = false;
  this.flags = 0;
  this.dmax = 0;
  this.check = 0;
  this.total = 0;
  this.head = null;
  this.wbits = 0;
  this.wsize = 0;
  this.whave = 0;
  this.wnext = 0;
  this.window = null;
  this.hold = 0;
  this.bits = 0;
  this.length = 0;
  this.offset = 0;
  this.extra = 0;
  this.lencode = null;
  this.distcode = null;
  this.lenbits = 0;
  this.distbits = 0;
  this.ncode = 0;
  this.nlen = 0;
  this.ndist = 0;
  this.have = 0;
  this.next = null;
  this.lens = new Uint16Array(320);
  this.work = new Uint16Array(288);
  this.lendyn = null;
  this.distdyn = null;
  this.sane = 0;
  this.back = 0;
  this.was = 0;
}
var inflateStateCheck = (strm) => {
  if (!strm) {
    return 1;
  }
  const state = strm.state;
  if (!state || state.strm !== strm || state.mode < HEAD || state.mode > SYNC) {
    return 1;
  }
  return 0;
};
var inflateResetKeep = (strm) => {
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  strm.total_in = strm.total_out = state.total = 0;
  strm.msg = "";
  if (state.wrap) {
    strm.adler = state.wrap & 1;
  }
  state.mode = HEAD;
  state.last = 0;
  state.havedict = 0;
  state.flags = -1;
  state.dmax = 32768;
  state.head = null;
  state.hold = 0;
  state.bits = 0;
  state.lencode = state.lendyn = new Int32Array(ENOUGH_LENS);
  state.distcode = state.distdyn = new Int32Array(ENOUGH_DISTS);
  state.sane = 1;
  state.back = -1;
  return Z_OK$1;
};
var inflateReset = (strm) => {
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  state.wsize = 0;
  state.whave = 0;
  state.wnext = 0;
  return inflateResetKeep(strm);
};
var inflateReset2 = (strm, windowBits) => {
  let wrap;
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  if (windowBits < 0) {
    wrap = 0;
    windowBits = -windowBits;
  } else {
    wrap = (windowBits >> 4) + 5;
    if (windowBits < 48) {
      windowBits &= 15;
    }
  }
  if (windowBits && (windowBits < 8 || windowBits > 15)) {
    return Z_STREAM_ERROR$1;
  }
  if (state.window !== null && state.wbits !== windowBits) {
    state.window = null;
  }
  state.wrap = wrap;
  state.wbits = windowBits;
  return inflateReset(strm);
};
var inflateInit2 = (strm, windowBits) => {
  if (!strm) {
    return Z_STREAM_ERROR$1;
  }
  const state = new InflateState();
  strm.state = state;
  state.strm = strm;
  state.window = null;
  state.mode = HEAD;
  const ret = inflateReset2(strm, windowBits);
  if (ret !== Z_OK$1) {
    strm.state = null;
  }
  return ret;
};
var inflateInit = (strm) => {
  return inflateInit2(strm, DEF_WBITS);
};
var virgin = true;
var lenfix;
var distfix;
var fixedtables = (state) => {
  if (virgin) {
    lenfix = new Int32Array(512);
    distfix = new Int32Array(32);
    let sym = 0;
    while (sym < 144) {
      state.lens[sym++] = 8;
    }
    while (sym < 256) {
      state.lens[sym++] = 9;
    }
    while (sym < 280) {
      state.lens[sym++] = 7;
    }
    while (sym < 288) {
      state.lens[sym++] = 8;
    }
    inftrees(LENS, state.lens, 0, 288, lenfix, 0, state.work, { bits: 9 });
    sym = 0;
    while (sym < 32) {
      state.lens[sym++] = 5;
    }
    inftrees(DISTS, state.lens, 0, 32, distfix, 0, state.work, { bits: 5 });
    virgin = false;
  }
  state.lencode = lenfix;
  state.lenbits = 9;
  state.distcode = distfix;
  state.distbits = 5;
};
var updatewindow = (strm, src2, end, copy) => {
  let dist;
  const state = strm.state;
  if (state.window === null) {
    state.wsize = 1 << state.wbits;
    state.wnext = 0;
    state.whave = 0;
    state.window = new Uint8Array(state.wsize);
  }
  if (copy >= state.wsize) {
    state.window.set(src2.subarray(end - state.wsize, end), 0);
    state.wnext = 0;
    state.whave = state.wsize;
  } else {
    dist = state.wsize - state.wnext;
    if (dist > copy) {
      dist = copy;
    }
    state.window.set(src2.subarray(end - copy, end - copy + dist), state.wnext);
    copy -= dist;
    if (copy) {
      state.window.set(src2.subarray(end - copy, end), 0);
      state.wnext = copy;
      state.whave = state.wsize;
    } else {
      state.wnext += dist;
      if (state.wnext === state.wsize) {
        state.wnext = 0;
      }
      if (state.whave < state.wsize) {
        state.whave += dist;
      }
    }
  }
  return 0;
};
var inflate$2 = (strm, flush) => {
  let state;
  let input, output4;
  let next;
  let put;
  let have, left;
  let hold;
  let bits;
  let _in, _out;
  let copy;
  let from2;
  let from_source;
  let here = 0;
  let here_bits, here_op, here_val;
  let last_bits, last_op, last_val;
  let len;
  let ret;
  const hbuf = new Uint8Array(4);
  let opts;
  let n;
  const order = (
    /* permutation of code lengths */
    new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15])
  );
  if (inflateStateCheck(strm) || !strm.output || !strm.input && strm.avail_in !== 0) {
    return Z_STREAM_ERROR$1;
  }
  state = strm.state;
  if (state.mode === TYPE2) {
    state.mode = TYPEDO;
  }
  put = strm.next_out;
  output4 = strm.output;
  left = strm.avail_out;
  next = strm.next_in;
  input = strm.input;
  have = strm.avail_in;
  hold = state.hold;
  bits = state.bits;
  _in = have;
  _out = left;
  ret = Z_OK$1;
  inf_leave:
    for (; ; ) {
      switch (state.mode) {
        case HEAD:
          if (state.wrap === 0) {
            state.mode = TYPEDO;
            break;
          }
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (state.wrap & 2 && hold === 35615) {
            if (state.wbits === 0) {
              state.wbits = 15;
            }
            state.check = 0;
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state.check = crc32_1(state.check, hbuf, 2, 0);
            hold = 0;
            bits = 0;
            state.mode = FLAGS;
            break;
          }
          if (state.head) {
            state.head.done = false;
          }
          if (!(state.wrap & 1) || /* check if zlib header allowed */
          (((hold & 255) << 8) + (hold >> 8)) % 31) {
            strm.msg = "incorrect header check";
            state.mode = BAD;
            break;
          }
          if ((hold & 15) !== Z_DEFLATED) {
            strm.msg = "unknown compression method";
            state.mode = BAD;
            break;
          }
          hold >>>= 4;
          bits -= 4;
          len = (hold & 15) + 8;
          if (state.wbits === 0) {
            state.wbits = len;
          }
          if (len > 15 || len > state.wbits) {
            strm.msg = "invalid window size";
            state.mode = BAD;
            break;
          }
          state.dmax = 1 << state.wbits;
          state.flags = 0;
          strm.adler = state.check = 1;
          state.mode = hold & 512 ? DICTID : TYPE2;
          hold = 0;
          bits = 0;
          break;
        case FLAGS:
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          state.flags = hold;
          if ((state.flags & 255) !== Z_DEFLATED) {
            strm.msg = "unknown compression method";
            state.mode = BAD;
            break;
          }
          if (state.flags & 57344) {
            strm.msg = "unknown header flags set";
            state.mode = BAD;
            break;
          }
          if (state.head) {
            state.head.text = hold >> 8 & 1;
          }
          if (state.flags & 512 && state.wrap & 4) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state.check = crc32_1(state.check, hbuf, 2, 0);
          }
          hold = 0;
          bits = 0;
          state.mode = TIME;
        /* falls through */
        case TIME:
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (state.head) {
            state.head.time = hold;
          }
          if (state.flags & 512 && state.wrap & 4) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            hbuf[2] = hold >>> 16 & 255;
            hbuf[3] = hold >>> 24 & 255;
            state.check = crc32_1(state.check, hbuf, 4, 0);
          }
          hold = 0;
          bits = 0;
          state.mode = OS;
        /* falls through */
        case OS:
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (state.head) {
            state.head.xflags = hold & 255;
            state.head.os = hold >> 8;
          }
          if (state.flags & 512 && state.wrap & 4) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state.check = crc32_1(state.check, hbuf, 2, 0);
          }
          hold = 0;
          bits = 0;
          state.mode = EXLEN;
        /* falls through */
        case EXLEN:
          if (state.flags & 1024) {
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.length = hold;
            if (state.head) {
              state.head.extra_len = hold;
            }
            if (state.flags & 512 && state.wrap & 4) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = crc32_1(state.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
          } else if (state.head) {
            state.head.extra = null;
          }
          state.mode = EXTRA;
        /* falls through */
        case EXTRA:
          if (state.flags & 1024) {
            copy = state.length;
            if (copy > have) {
              copy = have;
            }
            if (copy) {
              if (state.head) {
                len = state.head.extra_len - state.length;
                if (!state.head.extra) {
                  state.head.extra = new Uint8Array(state.head.extra_len);
                }
                state.head.extra.set(
                  input.subarray(
                    next,
                    // extra field is limited to 65536 bytes
                    // - no need for additional size check
                    next + copy
                  ),
                  /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                  len
                );
              }
              if (state.flags & 512 && state.wrap & 4) {
                state.check = crc32_1(state.check, input, copy, next);
              }
              have -= copy;
              next += copy;
              state.length -= copy;
            }
            if (state.length) {
              break inf_leave;
            }
          }
          state.length = 0;
          state.mode = NAME;
        /* falls through */
        case NAME:
          if (state.flags & 2048) {
            if (have === 0) {
              break inf_leave;
            }
            copy = 0;
            do {
              len = input[next + copy++];
              if (state.head && len && state.length < 65536) {
                state.head.name += String.fromCharCode(len);
              }
            } while (len && copy < have);
            if (state.flags & 512 && state.wrap & 4) {
              state.check = crc32_1(state.check, input, copy, next);
            }
            have -= copy;
            next += copy;
            if (len) {
              break inf_leave;
            }
          } else if (state.head) {
            state.head.name = null;
          }
          state.length = 0;
          state.mode = COMMENT;
        /* falls through */
        case COMMENT:
          if (state.flags & 4096) {
            if (have === 0) {
              break inf_leave;
            }
            copy = 0;
            do {
              len = input[next + copy++];
              if (state.head && len && state.length < 65536) {
                state.head.comment += String.fromCharCode(len);
              }
            } while (len && copy < have);
            if (state.flags & 512 && state.wrap & 4) {
              state.check = crc32_1(state.check, input, copy, next);
            }
            have -= copy;
            next += copy;
            if (len) {
              break inf_leave;
            }
          } else if (state.head) {
            state.head.comment = null;
          }
          state.mode = HCRC;
        /* falls through */
        case HCRC:
          if (state.flags & 512) {
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.wrap & 4 && hold !== (state.check & 65535)) {
              strm.msg = "header crc mismatch";
              state.mode = BAD;
              break;
            }
            hold = 0;
            bits = 0;
          }
          if (state.head) {
            state.head.hcrc = state.flags >> 9 & 1;
            state.head.done = true;
          }
          strm.adler = state.check = 0;
          state.mode = TYPE2;
          break;
        case DICTID:
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          strm.adler = state.check = zswap32(hold);
          hold = 0;
          bits = 0;
          state.mode = DICT;
        /* falls through */
        case DICT:
          if (state.havedict === 0) {
            strm.next_out = put;
            strm.avail_out = left;
            strm.next_in = next;
            strm.avail_in = have;
            state.hold = hold;
            state.bits = bits;
            return Z_NEED_DICT$1;
          }
          strm.adler = state.check = 1;
          state.mode = TYPE2;
        /* falls through */
        case TYPE2:
          if (flush === Z_BLOCK || flush === Z_TREES) {
            break inf_leave;
          }
        /* falls through */
        case TYPEDO:
          if (state.last) {
            hold >>>= bits & 7;
            bits -= bits & 7;
            state.mode = CHECK;
            break;
          }
          while (bits < 3) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          state.last = hold & 1;
          hold >>>= 1;
          bits -= 1;
          switch (hold & 3) {
            case 0:
              state.mode = STORED;
              break;
            case 1:
              fixedtables(state);
              state.mode = LEN_;
              if (flush === Z_TREES) {
                hold >>>= 2;
                bits -= 2;
                break inf_leave;
              }
              break;
            case 2:
              state.mode = TABLE;
              break;
            case 3:
              strm.msg = "invalid block type";
              state.mode = BAD;
          }
          hold >>>= 2;
          bits -= 2;
          break;
        case STORED:
          hold >>>= bits & 7;
          bits -= bits & 7;
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
            strm.msg = "invalid stored block lengths";
            state.mode = BAD;
            break;
          }
          state.length = hold & 65535;
          hold = 0;
          bits = 0;
          state.mode = COPY_;
          if (flush === Z_TREES) {
            break inf_leave;
          }
        /* falls through */
        case COPY_:
          state.mode = COPY;
        /* falls through */
        case COPY:
          copy = state.length;
          if (copy) {
            if (copy > have) {
              copy = have;
            }
            if (copy > left) {
              copy = left;
            }
            if (copy === 0) {
              break inf_leave;
            }
            output4.set(input.subarray(next, next + copy), put);
            have -= copy;
            next += copy;
            left -= copy;
            put += copy;
            state.length -= copy;
            break;
          }
          state.mode = TYPE2;
          break;
        case TABLE:
          while (bits < 14) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          state.nlen = (hold & 31) + 257;
          hold >>>= 5;
          bits -= 5;
          state.ndist = (hold & 31) + 1;
          hold >>>= 5;
          bits -= 5;
          state.ncode = (hold & 15) + 4;
          hold >>>= 4;
          bits -= 4;
          if (state.nlen > 286 || state.ndist > 30) {
            strm.msg = "too many length or distance symbols";
            state.mode = BAD;
            break;
          }
          state.have = 0;
          state.mode = LENLENS;
        /* falls through */
        case LENLENS:
          while (state.have < state.ncode) {
            while (bits < 3) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.lens[order[state.have++]] = hold & 7;
            hold >>>= 3;
            bits -= 3;
          }
          while (state.have < 19) {
            state.lens[order[state.have++]] = 0;
          }
          state.lencode = state.lendyn;
          state.lenbits = 7;
          opts = { bits: state.lenbits };
          ret = inftrees(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
          state.lenbits = opts.bits;
          if (ret) {
            strm.msg = "invalid code lengths set";
            state.mode = BAD;
            break;
          }
          state.have = 0;
          state.mode = CODELENS;
        /* falls through */
        case CODELENS:
          while (state.have < state.nlen + state.ndist) {
            for (; ; ) {
              here = state.lencode[hold & (1 << state.lenbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (here_val < 16) {
              hold >>>= here_bits;
              bits -= here_bits;
              state.lens[state.have++] = here_val;
            } else {
              if (here_val === 16) {
                n = here_bits + 2;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                if (state.have === 0) {
                  strm.msg = "invalid bit length repeat";
                  state.mode = BAD;
                  break;
                }
                len = state.lens[state.have - 1];
                copy = 3 + (hold & 3);
                hold >>>= 2;
                bits -= 2;
              } else if (here_val === 17) {
                n = here_bits + 3;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                len = 0;
                copy = 3 + (hold & 7);
                hold >>>= 3;
                bits -= 3;
              } else {
                n = here_bits + 7;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                len = 0;
                copy = 11 + (hold & 127);
                hold >>>= 7;
                bits -= 7;
              }
              if (state.have + copy > state.nlen + state.ndist) {
                strm.msg = "invalid bit length repeat";
                state.mode = BAD;
                break;
              }
              while (copy--) {
                state.lens[state.have++] = len;
              }
            }
          }
          if (state.mode === BAD) {
            break;
          }
          if (state.lens[256] === 0) {
            strm.msg = "invalid code -- missing end-of-block";
            state.mode = BAD;
            break;
          }
          state.lenbits = 9;
          opts = { bits: state.lenbits };
          ret = inftrees(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
          state.lenbits = opts.bits;
          if (ret) {
            strm.msg = "invalid literal/lengths set";
            state.mode = BAD;
            break;
          }
          state.distbits = 6;
          state.distcode = state.distdyn;
          opts = { bits: state.distbits };
          ret = inftrees(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
          state.distbits = opts.bits;
          if (ret) {
            strm.msg = "invalid distances set";
            state.mode = BAD;
            break;
          }
          state.mode = LEN_;
          if (flush === Z_TREES) {
            break inf_leave;
          }
        /* falls through */
        case LEN_:
          state.mode = LEN;
        /* falls through */
        case LEN:
          if (have >= 6 && left >= 258) {
            strm.next_out = put;
            strm.avail_out = left;
            strm.next_in = next;
            strm.avail_in = have;
            state.hold = hold;
            state.bits = bits;
            inffast(strm, _out);
            put = strm.next_out;
            output4 = strm.output;
            left = strm.avail_out;
            next = strm.next_in;
            input = strm.input;
            have = strm.avail_in;
            hold = state.hold;
            bits = state.bits;
            if (state.mode === TYPE2) {
              state.back = -1;
            }
            break;
          }
          state.back = 0;
          for (; ; ) {
            here = state.lencode[hold & (1 << state.lenbits) - 1];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 255;
            here_val = here & 65535;
            if (here_bits <= bits) {
              break;
            }
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (here_op && (here_op & 240) === 0) {
            last_bits = here_bits;
            last_op = here_op;
            last_val = here_val;
            for (; ; ) {
              here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (last_bits + here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            hold >>>= last_bits;
            bits -= last_bits;
            state.back += last_bits;
          }
          hold >>>= here_bits;
          bits -= here_bits;
          state.back += here_bits;
          state.length = here_val;
          if (here_op === 0) {
            state.mode = LIT;
            break;
          }
          if (here_op & 32) {
            state.back = -1;
            state.mode = TYPE2;
            break;
          }
          if (here_op & 64) {
            strm.msg = "invalid literal/length code";
            state.mode = BAD;
            break;
          }
          state.extra = here_op & 15;
          state.mode = LENEXT;
        /* falls through */
        case LENEXT:
          if (state.extra) {
            n = state.extra;
            while (bits < n) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.length += hold & (1 << state.extra) - 1;
            hold >>>= state.extra;
            bits -= state.extra;
            state.back += state.extra;
          }
          state.was = state.length;
          state.mode = DIST;
        /* falls through */
        case DIST:
          for (; ; ) {
            here = state.distcode[hold & (1 << state.distbits) - 1];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 255;
            here_val = here & 65535;
            if (here_bits <= bits) {
              break;
            }
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if ((here_op & 240) === 0) {
            last_bits = here_bits;
            last_op = here_op;
            last_val = here_val;
            for (; ; ) {
              here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (last_bits + here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            hold >>>= last_bits;
            bits -= last_bits;
            state.back += last_bits;
          }
          hold >>>= here_bits;
          bits -= here_bits;
          state.back += here_bits;
          if (here_op & 64) {
            strm.msg = "invalid distance code";
            state.mode = BAD;
            break;
          }
          state.offset = here_val;
          state.extra = here_op & 15;
          state.mode = DISTEXT;
        /* falls through */
        case DISTEXT:
          if (state.extra) {
            n = state.extra;
            while (bits < n) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.offset += hold & (1 << state.extra) - 1;
            hold >>>= state.extra;
            bits -= state.extra;
            state.back += state.extra;
          }
          if (state.offset > state.dmax) {
            strm.msg = "invalid distance too far back";
            state.mode = BAD;
            break;
          }
          state.mode = MATCH;
        /* falls through */
        case MATCH:
          if (left === 0) {
            break inf_leave;
          }
          copy = _out - left;
          if (state.offset > copy) {
            copy = state.offset - copy;
            if (copy > state.whave) {
              if (state.sane) {
                strm.msg = "invalid distance too far back";
                state.mode = BAD;
                break;
              }
            }
            if (copy > state.wnext) {
              copy -= state.wnext;
              from2 = state.wsize - copy;
            } else {
              from2 = state.wnext - copy;
            }
            if (copy > state.length) {
              copy = state.length;
            }
            from_source = state.window;
          } else {
            from_source = output4;
            from2 = put - state.offset;
            copy = state.length;
          }
          if (copy > left) {
            copy = left;
          }
          left -= copy;
          state.length -= copy;
          do {
            output4[put++] = from_source[from2++];
          } while (--copy);
          if (state.length === 0) {
            state.mode = LEN;
          }
          break;
        case LIT:
          if (left === 0) {
            break inf_leave;
          }
          output4[put++] = state.length;
          left--;
          state.mode = LEN;
          break;
        case CHECK:
          if (state.wrap) {
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold |= input[next++] << bits;
              bits += 8;
            }
            _out -= left;
            strm.total_out += _out;
            state.total += _out;
            if (state.wrap & 4 && _out) {
              strm.adler = state.check = /*UPDATE_CHECK(state.check, put - _out, _out);*/
              state.flags ? crc32_1(state.check, output4, _out, put - _out) : adler32_1(state.check, output4, _out, put - _out);
            }
            _out = left;
            if (state.wrap & 4 && (state.flags ? hold : zswap32(hold)) !== state.check) {
              strm.msg = "incorrect data check";
              state.mode = BAD;
              break;
            }
            hold = 0;
            bits = 0;
          }
          state.mode = LENGTH;
        /* falls through */
        case LENGTH:
          if (state.wrap && state.flags) {
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.wrap & 4 && hold !== (state.total & 4294967295)) {
              strm.msg = "incorrect length check";
              state.mode = BAD;
              break;
            }
            hold = 0;
            bits = 0;
          }
          state.mode = DONE;
        /* falls through */
        case DONE:
          ret = Z_STREAM_END$1;
          break inf_leave;
        case BAD:
          ret = Z_DATA_ERROR$1;
          break inf_leave;
        case MEM:
          return Z_MEM_ERROR$1;
        case SYNC:
        /* falls through */
        default:
          return Z_STREAM_ERROR$1;
      }
    }
  strm.next_out = put;
  strm.avail_out = left;
  strm.next_in = next;
  strm.avail_in = have;
  state.hold = hold;
  state.bits = bits;
  if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH$1)) {
    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) ;
  }
  _in -= strm.avail_in;
  _out -= strm.avail_out;
  strm.total_in += _in;
  strm.total_out += _out;
  state.total += _out;
  if (state.wrap & 4 && _out) {
    strm.adler = state.check = /*UPDATE_CHECK(state.check, strm.next_out - _out, _out);*/
    state.flags ? crc32_1(state.check, output4, _out, strm.next_out - _out) : adler32_1(state.check, output4, _out, strm.next_out - _out);
  }
  strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE2 ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
  if ((_in === 0 && _out === 0 || flush === Z_FINISH$1) && ret === Z_OK$1) {
    ret = Z_BUF_ERROR;
  }
  return ret;
};
var inflateEnd = (strm) => {
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  let state = strm.state;
  if (state.window) {
    state.window = null;
  }
  strm.state = null;
  return Z_OK$1;
};
var inflateGetHeader = (strm, head) => {
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  if ((state.wrap & 2) === 0) {
    return Z_STREAM_ERROR$1;
  }
  state.head = head;
  head.done = false;
  return Z_OK$1;
};
var inflateSetDictionary = (strm, dictionary) => {
  const dictLength = dictionary.length;
  let state;
  let dictid;
  let ret;
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  state = strm.state;
  if (state.wrap !== 0 && state.mode !== DICT) {
    return Z_STREAM_ERROR$1;
  }
  if (state.mode === DICT) {
    dictid = 1;
    dictid = adler32_1(dictid, dictionary, dictLength, 0);
    if (dictid !== state.check) {
      return Z_DATA_ERROR$1;
    }
  }
  ret = updatewindow(strm, dictionary, dictLength, dictLength);
  if (ret) {
    state.mode = MEM;
    return Z_MEM_ERROR$1;
  }
  state.havedict = 1;
  return Z_OK$1;
};
var inflateReset_1 = inflateReset;
var inflateReset2_1 = inflateReset2;
var inflateResetKeep_1 = inflateResetKeep;
var inflateInit_1 = inflateInit;
var inflateInit2_1 = inflateInit2;
var inflate_2$1 = inflate$2;
var inflateEnd_1 = inflateEnd;
var inflateGetHeader_1 = inflateGetHeader;
var inflateSetDictionary_1 = inflateSetDictionary;
var inflateInfo = "pako inflate (from Nodeca project)";
var inflate_1$2 = {
  inflateReset: inflateReset_1,
  inflateReset2: inflateReset2_1,
  inflateResetKeep: inflateResetKeep_1,
  inflateInit: inflateInit_1,
  inflateInit2: inflateInit2_1,
  inflate: inflate_2$1,
  inflateEnd: inflateEnd_1,
  inflateGetHeader: inflateGetHeader_1,
  inflateSetDictionary: inflateSetDictionary_1,
  inflateInfo
};
function GZheader() {
  this.text = 0;
  this.time = 0;
  this.xflags = 0;
  this.os = 0;
  this.extra = null;
  this.extra_len = 0;
  this.name = "";
  this.comment = "";
  this.hcrc = 0;
  this.done = false;
}
var gzheader = GZheader;
var toString = Object.prototype.toString;
var {
  Z_NO_FLUSH,
  Z_FINISH,
  Z_OK,
  Z_STREAM_END,
  Z_NEED_DICT,
  Z_STREAM_ERROR,
  Z_DATA_ERROR,
  Z_MEM_ERROR
} = constants$2;
function Inflate$1(options) {
  this.options = common.assign({
    chunkSize: 1024 * 64,
    windowBits: 15,
    to: ""
  }, options || {});
  const opt = this.options;
  if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
    opt.windowBits = -opt.windowBits;
    if (opt.windowBits === 0) {
      opt.windowBits = -15;
    }
  }
  if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
    opt.windowBits += 32;
  }
  if (opt.windowBits > 15 && opt.windowBits < 48) {
    if ((opt.windowBits & 15) === 0) {
      opt.windowBits |= 15;
    }
  }
  this.err = 0;
  this.msg = "";
  this.ended = false;
  this.chunks = [];
  this.strm = new zstream();
  this.strm.avail_out = 0;
  let status = inflate_1$2.inflateInit2(
    this.strm,
    opt.windowBits
  );
  if (status !== Z_OK) {
    throw new Error(messages[status]);
  }
  this.header = new gzheader();
  inflate_1$2.inflateGetHeader(this.strm, this.header);
  if (opt.dictionary) {
    if (typeof opt.dictionary === "string") {
      opt.dictionary = strings.string2buf(opt.dictionary);
    } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
      opt.dictionary = new Uint8Array(opt.dictionary);
    }
    if (opt.raw) {
      status = inflate_1$2.inflateSetDictionary(this.strm, opt.dictionary);
      if (status !== Z_OK) {
        throw new Error(messages[status]);
      }
    }
  }
}
Inflate$1.prototype.push = function(data, flush_mode) {
  const strm = this.strm;
  const chunkSize = this.options.chunkSize;
  const dictionary = this.options.dictionary;
  let status, _flush_mode, last_avail_out;
  if (this.ended) return false;
  if (flush_mode === ~~flush_mode) _flush_mode = flush_mode;
  else _flush_mode = flush_mode === true ? Z_FINISH : Z_NO_FLUSH;
  if (toString.call(data) === "[object ArrayBuffer]") {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }
  strm.next_in = 0;
  strm.avail_in = strm.input.length;
  for (; ; ) {
    if (strm.avail_out === 0) {
      strm.output = new Uint8Array(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }
    status = inflate_1$2.inflate(strm, _flush_mode);
    if (status === Z_NEED_DICT && dictionary) {
      status = inflate_1$2.inflateSetDictionary(strm, dictionary);
      if (status === Z_OK) {
        status = inflate_1$2.inflate(strm, _flush_mode);
      } else if (status === Z_DATA_ERROR) {
        status = Z_NEED_DICT;
      }
    }
    while (strm.avail_in > 0 && status === Z_STREAM_END && strm.state.wrap > 0 && data[strm.next_in] !== 0) {
      inflate_1$2.inflateReset(strm);
      status = inflate_1$2.inflate(strm, _flush_mode);
    }
    switch (status) {
      case Z_STREAM_ERROR:
      case Z_DATA_ERROR:
      case Z_NEED_DICT:
      case Z_MEM_ERROR:
        this.onEnd(status);
        this.ended = true;
        return false;
    }
    last_avail_out = strm.avail_out;
    if (strm.next_out) {
      if (strm.avail_out === 0 || status === Z_STREAM_END) {
        if (this.options.to === "string") {
          let next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
          let tail = strm.next_out - next_out_utf8;
          let utf8str = strings.buf2string(strm.output, next_out_utf8);
          strm.next_out = tail;
          strm.avail_out = chunkSize - tail;
          if (tail) strm.output.set(strm.output.subarray(next_out_utf8, next_out_utf8 + tail), 0);
          this.onData(utf8str);
        } else {
          this.onData(strm.output.length === strm.next_out ? strm.output : strm.output.subarray(0, strm.next_out));
        }
      }
    }
    if (status === Z_OK && last_avail_out === 0) continue;
    if (status === Z_STREAM_END) {
      status = inflate_1$2.inflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return true;
    }
    if (strm.avail_in === 0) break;
  }
  return true;
};
Inflate$1.prototype.onData = function(chunk) {
  this.chunks.push(chunk);
};
Inflate$1.prototype.onEnd = function(status) {
  if (status === Z_OK) {
    if (this.options.to === "string") {
      this.result = this.chunks.join("");
    } else {
      this.result = common.flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};
function inflate$1(input, options) {
  const inflator = new Inflate$1(options);
  inflator.push(input);
  if (inflator.err) throw inflator.msg || messages[inflator.err];
  return inflator.result;
}
function inflateRaw$1(input, options) {
  options = options || {};
  options.raw = true;
  return inflate$1(input, options);
}
var Inflate_1$1 = Inflate$1;
var inflate_2 = inflate$1;
var inflateRaw_1$1 = inflateRaw$1;
var ungzip$1 = inflate$1;
var constants = constants$2;
var inflate_1$1 = {
  Inflate: Inflate_1$1,
  inflate: inflate_2,
  inflateRaw: inflateRaw_1$1,
  ungzip: ungzip$1,
  constants
};
var { Deflate, deflate, deflateRaw, gzip } = deflate_1$1;
var { Inflate, inflate, inflateRaw, ungzip } = inflate_1$1;
var inflate_1 = inflate;

// node_modules/@coral-xyz/anchor/dist/browser/index.js
var import_eventemitter32 = __toESM(require_eventemitter32());
function chunks(array4, size4) {
  return Array.apply(0, new Array(Math.ceil(array4.length / size4))).map((_, index4) => array4.slice(index4 * size4, (index4 + 1) * size4));
}
var isVersionedTransaction = (tx) => {
  return "version" in tx;
};
function encode$3(data) {
  return data.reduce((str2, byte) => str2 + byte.toString(16).padStart(2, "0"), "0x");
}
function decode$3(data) {
  if (data.indexOf("0x") === 0) {
    data = data.substr(2);
  }
  if (data.length % 2 === 1) {
    data = "0" + data;
  }
  let key = data.match(/.{2}/g);
  if (key === null) {
    return import_buffer3.Buffer.from([]);
  }
  return import_buffer3.Buffer.from(key.map((byte) => parseInt(byte, 16)));
}
var hex = Object.freeze({
  __proto__: null,
  encode: encode$3,
  decode: decode$3
});
function decode$2(array4) {
  const decoder = new TextDecoder("utf-8");
  return decoder.decode(array4);
}
function encode$2(input) {
  const encoder4 = new TextEncoder();
  return encoder4.encode(input);
}
var utf82 = Object.freeze({
  __proto__: null,
  decode: decode$2,
  encode: encode$2
});
function encode$1(data) {
  return import_bs583.default.encode(data);
}
function decode$1(data) {
  return import_bs583.default.decode(data);
}
var bs582 = Object.freeze({
  __proto__: null,
  encode: encode$1,
  decode: decode$1
});
function encode2(data) {
  return data.toString("base64");
}
function decode2(data) {
  return import_buffer3.Buffer.from(data, "base64");
}
var base64 = Object.freeze({
  __proto__: null,
  encode: encode2,
  decode: decode2
});
var index$1 = Object.freeze({
  __proto__: null,
  hex,
  utf8: utf82,
  bs58: bs582,
  base64
});
function parseIdlErrors(idl) {
  const errors2 = /* @__PURE__ */ new Map();
  if (idl.errors) {
    idl.errors.forEach((e) => {
      var _a2;
      let msg = (_a2 = e.msg) !== null && _a2 !== void 0 ? _a2 : e.name;
      errors2.set(e.code, msg);
    });
  }
  return errors2;
}
function toInstruction(idlIx, ...args) {
  if (idlIx.args.length != args.length) {
    throw new Error("Invalid argument length");
  }
  const ix = {};
  let idx = 0;
  idlIx.args.forEach((ixArg) => {
    ix[ixArg.name] = args[idx];
    idx += 1;
  });
  return ix;
}
function validateAccounts(ixAccounts, accounts = {}) {
  ixAccounts.forEach((acc) => {
    if ("accounts" in acc) {
      validateAccounts(acc.accounts, accounts[acc.name]);
    } else {
      if (accounts[acc.name] === void 0) {
        throw new Error(`Invalid arguments: ${acc.name} not provided.`);
      }
    }
  });
}
function translateAddress(address) {
  return address instanceof PublicKey ? address : new PublicKey(address);
}
var StructError2 = class extends TypeError {
  constructor(failure, failures) {
    let cached;
    const {
      message,
      ...rest
    } = failure;
    const {
      path
    } = failure;
    const msg = path.length === 0 ? message : "At path: " + path.join(".") + " -- " + message;
    super(msg);
    this.value = void 0;
    this.key = void 0;
    this.type = void 0;
    this.refinement = void 0;
    this.path = void 0;
    this.branch = void 0;
    this.failures = void 0;
    Object.assign(this, rest);
    this.name = this.constructor.name;
    this.failures = () => {
      var _cached;
      return (_cached = cached) != null ? _cached : cached = [failure, ...failures()];
    };
  }
};
function isIterable2(x) {
  return isObject2(x) && typeof x[Symbol.iterator] === "function";
}
function isObject2(x) {
  return typeof x === "object" && x != null;
}
function print2(value) {
  return typeof value === "string" ? JSON.stringify(value) : "" + value;
}
function shiftIterator2(input) {
  const {
    done,
    value
  } = input.next();
  return done ? void 0 : value;
}
function toFailure2(result, context, struct52, value) {
  if (result === true) {
    return;
  } else if (result === false) {
    result = {};
  } else if (typeof result === "string") {
    result = {
      message: result
    };
  }
  const {
    path,
    branch
  } = context;
  const {
    type: type3
  } = struct52;
  const {
    refinement,
    message = "Expected a value of type `" + type3 + "`" + (refinement ? " with refinement `" + refinement + "`" : "") + ", but received: `" + print2(value) + "`"
  } = result;
  return {
    value,
    type: type3,
    refinement,
    key: path[path.length - 1],
    path,
    branch,
    ...result,
    message
  };
}
function* toFailures2(result, context, struct52, value) {
  if (!isIterable2(result)) {
    result = [result];
  }
  for (const r of result) {
    const failure = toFailure2(r, context, struct52, value);
    if (failure) {
      yield failure;
    }
  }
}
function* run2(value, struct52, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    path = [],
    branch = [value],
    coerce: coerce4 = false,
    mask: mask3 = false
  } = options;
  const ctx = {
    path,
    branch
  };
  if (coerce4) {
    value = struct52.coercer(value, ctx);
    if (mask3 && struct52.type !== "type" && isObject2(struct52.schema) && isObject2(value) && !Array.isArray(value)) {
      for (const key in value) {
        if (struct52.schema[key] === void 0) {
          delete value[key];
        }
      }
    }
  }
  let valid = true;
  for (const failure of struct52.validator(value, ctx)) {
    valid = false;
    yield [failure, void 0];
  }
  for (let [k, v, s] of struct52.entries(value, ctx)) {
    const ts = run2(v, s, {
      path: k === void 0 ? path : [...path, k],
      branch: k === void 0 ? branch : [...branch, v],
      coerce: coerce4,
      mask: mask3
    });
    for (const t of ts) {
      if (t[0]) {
        valid = false;
        yield [t[0], void 0];
      } else if (coerce4) {
        v = t[1];
        if (k === void 0) {
          value = v;
        } else if (value instanceof Map) {
          value.set(k, v);
        } else if (value instanceof Set) {
          value.add(v);
        } else if (isObject2(value)) {
          value[k] = v;
        }
      }
    }
  }
  if (valid) {
    for (const failure of struct52.refiner(value, ctx)) {
      valid = false;
      yield [failure, void 0];
    }
  }
  if (valid) {
    yield [void 0, value];
  }
}
var Struct3 = class {
  constructor(props) {
    this.TYPE = void 0;
    this.type = void 0;
    this.schema = void 0;
    this.coercer = void 0;
    this.validator = void 0;
    this.refiner = void 0;
    this.entries = void 0;
    const {
      type: type3,
      schema,
      validator,
      refiner,
      coercer = (value) => value,
      entries = function* () {
      }
    } = props;
    this.type = type3;
    this.schema = schema;
    this.entries = entries;
    this.coercer = coercer;
    if (validator) {
      this.validator = (value, context) => {
        const result = validator(value, context);
        return toFailures2(result, context, this, value);
      };
    } else {
      this.validator = () => [];
    }
    if (refiner) {
      this.refiner = (value, context) => {
        const result = refiner(value, context);
        return toFailures2(result, context, this, value);
      };
    } else {
      this.refiner = () => [];
    }
  }
  /**
   * Assert that a value passes the struct's validation, throwing if it doesn't.
   */
  assert(value) {
    return assert3(value, this);
  }
  /**
   * Create a value with the struct's coercion logic, then validate it.
   */
  create(value) {
    return create2(value, this);
  }
  /**
   * Check if a value passes the struct's validation.
   */
  is(value) {
    return is2(value, this);
  }
  /**
   * Mask a value, coercing and validating it, but returning only the subset of
   * properties defined by the struct's schema.
   */
  mask(value) {
    return mask2(value, this);
  }
  /**
   * Validate a value with the struct's validation logic, returning a tuple
   * representing the result.
   *
   * You may optionally pass `true` for the `withCoercion` argument to coerce
   * the value before attempting to validate it. If you do, the result will
   * contain the coerced result when successful.
   */
  validate(value, options) {
    if (options === void 0) {
      options = {};
    }
    return validate3(value, this, options);
  }
};
function assert3(value, struct52) {
  const result = validate3(value, struct52);
  if (result[0]) {
    throw result[0];
  }
}
function create2(value, struct52) {
  const result = validate3(value, struct52, {
    coerce: true
  });
  if (result[0]) {
    throw result[0];
  } else {
    return result[1];
  }
}
function mask2(value, struct52) {
  const result = validate3(value, struct52, {
    coerce: true,
    mask: true
  });
  if (result[0]) {
    throw result[0];
  } else {
    return result[1];
  }
}
function is2(value, struct52) {
  const result = validate3(value, struct52);
  return !result[0];
}
function validate3(value, struct52, options) {
  if (options === void 0) {
    options = {};
  }
  const tuples = run2(value, struct52, options);
  const tuple2 = shiftIterator2(tuples);
  if (tuple2[0]) {
    const error = new StructError2(tuple2[0], function* () {
      for (const t of tuples) {
        if (t[0]) {
          yield t[0];
        }
      }
    });
    return [error, void 0];
  } else {
    const v = tuple2[1];
    return [void 0, v];
  }
}
function define3(name, validator) {
  return new Struct3({
    type: name,
    schema: null,
    validator
  });
}
function any2() {
  return define3("any", () => true);
}
function array3(Element) {
  return new Struct3({
    type: "array",
    schema: Element,
    *entries(value) {
      if (Element && Array.isArray(value)) {
        for (const [i, v] of value.entries()) {
          yield [i, v, Element];
        }
      }
    },
    coercer(value) {
      return Array.isArray(value) ? value.slice() : value;
    },
    validator(value) {
      return Array.isArray(value) || "Expected an array value, but received: " + print2(value);
    }
  });
}
function boolean2() {
  return define3("boolean", (value) => {
    return typeof value === "boolean";
  });
}
function literal2(constant2) {
  const description = print2(constant2);
  const t = typeof constant2;
  return new Struct3({
    type: "literal",
    schema: t === "string" || t === "number" || t === "boolean" ? constant2 : null,
    validator(value) {
      return value === constant2 || "Expected the literal `" + description + "`, but received: " + print2(value);
    }
  });
}
function nullable2(struct52) {
  return new Struct3({
    ...struct52,
    validator: (value, ctx) => value === null || struct52.validator(value, ctx),
    refiner: (value, ctx) => value === null || struct52.refiner(value, ctx)
  });
}
function number3() {
  return define3("number", (value) => {
    return typeof value === "number" && !isNaN(value) || "Expected a number, but received: " + print2(value);
  });
}
function optional2(struct52) {
  return new Struct3({
    ...struct52,
    validator: (value, ctx) => value === void 0 || struct52.validator(value, ctx),
    refiner: (value, ctx) => value === void 0 || struct52.refiner(value, ctx)
  });
}
function string2() {
  return define3("string", (value) => {
    return typeof value === "string" || "Expected a string, but received: " + print2(value);
  });
}
function type2(schema) {
  const keys = Object.keys(schema);
  return new Struct3({
    type: "type",
    schema,
    *entries(value) {
      if (isObject2(value)) {
        for (const k of keys) {
          yield [k, value[k], schema[k]];
        }
      }
    },
    validator(value) {
      return isObject2(value) || "Expected an object, but received: " + print2(value);
    }
  });
}
function union$1(Structs) {
  const description = Structs.map((s) => s.type).join(" | ");
  return new Struct3({
    type: "union",
    schema: null,
    coercer(value, ctx) {
      const firstMatch = Structs.find((s) => {
        const [e] = s.validate(value, {
          coerce: true
        });
        return !e;
      }) || unknown2();
      return firstMatch.coercer(value, ctx);
    },
    validator(value, ctx) {
      const failures = [];
      for (const S of Structs) {
        const [...tuples] = run2(value, S, ctx);
        const [first] = tuples;
        if (!first[0]) {
          return [];
        } else {
          for (const [failure] of tuples) {
            if (failure) {
              failures.push(failure);
            }
          }
        }
      }
      return ["Expected the value to satisfy a union of `" + description + "`, but received: " + print2(value), ...failures];
    }
  });
}
function unknown2() {
  return define3("unknown", () => true);
}
function coerce2(struct52, condition, coercer) {
  return new Struct3({
    ...struct52,
    coercer: (value, ctx) => {
      return is2(value, condition) ? struct52.coercer(coercer(value, ctx), ctx) : struct52.coercer(value, ctx);
    }
  });
}
async function invoke(programId, accounts, data, provider) {
  programId = translateAddress(programId);
  if (!provider) {
    provider = getProvider();
  }
  const tx = new Transaction();
  tx.add(new TransactionInstruction({
    programId,
    keys: accounts !== null && accounts !== void 0 ? accounts : [],
    data
  }));
  if (provider.sendAndConfirm === void 0) {
    throw new Error("This function requires 'Provider.sendAndConfirm' to be implemented.");
  }
  return await provider.sendAndConfirm(tx, []);
}
var GET_MULTIPLE_ACCOUNTS_LIMIT = 99;
async function getMultipleAccounts(connection, publicKeys, commitment) {
  const results = await getMultipleAccountsAndContext(connection, publicKeys, commitment);
  return results.map((result) => {
    return result ? { publicKey: result.publicKey, account: result.account } : null;
  });
}
async function getMultipleAccountsAndContext(connection, publicKeys, commitment) {
  if (publicKeys.length <= GET_MULTIPLE_ACCOUNTS_LIMIT) {
    return await getMultipleAccountsAndContextCore(connection, publicKeys, commitment);
  } else {
    const batches = chunks(publicKeys, GET_MULTIPLE_ACCOUNTS_LIMIT);
    const results = await Promise.all(batches.map((batch) => getMultipleAccountsAndContextCore(connection, batch, commitment)));
    return results.flat();
  }
}
async function getMultipleAccountsAndContextCore(connection, publicKeys, commitmentOverride) {
  const commitment = commitmentOverride !== null && commitmentOverride !== void 0 ? commitmentOverride : connection.commitment;
  const { value: accountInfos, context } = await connection.getMultipleAccountsInfoAndContext(publicKeys, commitment);
  const accounts = accountInfos.map((account, idx) => {
    if (account === null) {
      return null;
    }
    return {
      publicKey: publicKeys[idx],
      account,
      context
    };
  });
  return accounts;
}
async function simulateTransaction(connection, transaction, signers, commitment, includeAccounts) {
  var _a2;
  if (signers && signers.length > 0) {
    transaction.sign(...signers);
  }
  const message = transaction._compile();
  const signData = message.serialize();
  const wireTransaction = transaction._serialize(signData);
  const encodedTransaction = wireTransaction.toString("base64");
  const config = {
    encoding: "base64",
    commitment: commitment !== null && commitment !== void 0 ? commitment : connection.commitment
  };
  if (includeAccounts) {
    const addresses = (Array.isArray(includeAccounts) ? includeAccounts : message.nonProgramIds()).map((key) => key.toBase58());
    config["accounts"] = {
      encoding: "base64",
      addresses
    };
  }
  if (signers) {
    config.sigVerify = true;
  }
  const args = [encodedTransaction, config];
  const unsafeRes = await connection._rpcRequest("simulateTransaction", args);
  const res = create2(unsafeRes, SimulatedTransactionResponseStruct2);
  if ("error" in res) {
    let logs;
    if ("data" in res.error) {
      logs = (_a2 = res.error.data) === null || _a2 === void 0 ? void 0 : _a2.logs;
      if (logs && Array.isArray(logs)) {
        const traceIndent = "\n    ";
        const logTrace = traceIndent + logs.join(traceIndent);
        console.error(res.error.message, logTrace);
      }
    }
    throw new SendTransactionError("failed to simulate transaction: " + res.error.message, logs);
  }
  return res.result;
}
function jsonRpcResult2(schema) {
  return coerce2(createRpcResult2(schema), UnknownRpcResult2, (value) => {
    if ("error" in value) {
      return value;
    } else {
      return {
        ...value,
        result: create2(value.result, schema)
      };
    }
  });
}
var UnknownRpcResult2 = createRpcResult2(unknown2());
function createRpcResult2(result) {
  return union$1([
    type2({
      jsonrpc: literal2("2.0"),
      id: string2(),
      result
    }),
    type2({
      jsonrpc: literal2("2.0"),
      id: string2(),
      error: type2({
        code: unknown2(),
        message: string2(),
        data: optional2(any2())
      })
    })
  ]);
}
function jsonRpcResultAndContext2(value) {
  return jsonRpcResult2(type2({
    context: type2({
      slot: number3()
    }),
    value
  }));
}
var SimulatedTransactionResponseStruct2 = jsonRpcResultAndContext2(type2({
  err: nullable2(union$1([type2({}), string2()])),
  logs: nullable2(array3(string2())),
  accounts: optional2(nullable2(array3(nullable2(type2({
    executable: boolean2(),
    owner: string2(),
    lamports: number3(),
    data: array3(string2()),
    rentEpoch: optional2(number3())
  }))))),
  unitsConsumed: optional2(number3())
}));
var rpc2 = Object.freeze({
  __proto__: null,
  invoke,
  getMultipleAccounts,
  getMultipleAccountsAndContext,
  simulateTransaction
});
var AnchorProvider = class {
  /**
   * @param connection The cluster connection where the program is deployed.
   * @param wallet     The wallet used to pay for and sign all transactions.
   * @param opts       Transaction confirmation options to use by default.
   */
  constructor(connection, wallet, opts) {
    this.connection = connection;
    this.wallet = wallet;
    this.opts = opts;
    this.publicKey = wallet === null || wallet === void 0 ? void 0 : wallet.publicKey;
  }
  static defaultOptions() {
    return {
      preflightCommitment: "processed",
      commitment: "processed"
    };
  }
  /**
   * Returns a `Provider` with a wallet read from the local filesystem.
   *
   * @param url  The network cluster url.
   * @param opts The default transaction confirmation options.
   *
   * (This api is for Node only.)
   */
  static local(url, opts) {
    {
      throw new Error(`Provider local is not available on browser.`);
    }
  }
  /**
   * Returns a `Provider` read from the `ANCHOR_PROVIDER_URL` environment
   * variable
   *
   * (This api is for Node only.)
   */
  static env() {
    {
      throw new Error(`Provider env is not available on browser.`);
    }
  }
  /**
   * Sends the given transaction, paid for and signed by the provider's wallet.
   *
   * @param tx      The transaction to send.
   * @param signers The signers of the transaction.
   * @param opts    Transaction confirmation options.
   */
  async sendAndConfirm(tx, signers, opts) {
    var _a2, _b, _c, _d;
    if (opts === void 0) {
      opts = this.opts;
    }
    if (isVersionedTransaction(tx)) {
      if (signers) {
        tx.sign(signers);
      }
    } else {
      tx.feePayer = (_a2 = tx.feePayer) !== null && _a2 !== void 0 ? _a2 : this.wallet.publicKey;
      tx.recentBlockhash = (await this.connection.getLatestBlockhash(opts.preflightCommitment)).blockhash;
      if (signers) {
        for (const signer of signers) {
          tx.partialSign(signer);
        }
      }
    }
    tx = await this.wallet.signTransaction(tx);
    const rawTx = tx.serialize();
    try {
      return await sendAndConfirmRawTransaction2(this.connection, rawTx, opts);
    } catch (err2) {
      if (err2 instanceof ConfirmError) {
        const txSig = encode$1(isVersionedTransaction(tx) ? ((_b = tx.signatures) === null || _b === void 0 ? void 0 : _b[0]) || new Uint8Array() : (_c = tx.signature) !== null && _c !== void 0 ? _c : new Uint8Array());
        const failedTx = await this.connection.getTransaction(txSig, {
          commitment: "confirmed"
        });
        if (!failedTx) {
          throw err2;
        } else {
          const logs = (_d = failedTx.meta) === null || _d === void 0 ? void 0 : _d.logMessages;
          throw !logs ? err2 : new SendTransactionError(err2.message, logs);
        }
      } else {
        throw err2;
      }
    }
  }
  /**
   * Similar to `send`, but for an array of transactions and signers.
   * All transactions need to be of the same type, it doesn't support a mix of `VersionedTransaction`s and `Transaction`s.
   *
   * @param txWithSigners Array of transactions and signers.
   * @param opts          Transaction confirmation options.
   */
  async sendAll(txWithSigners, opts) {
    var _a2, _b, _c;
    if (opts === void 0) {
      opts = this.opts;
    }
    const recentBlockhash = (await this.connection.getLatestBlockhash(opts.preflightCommitment)).blockhash;
    let txs = txWithSigners.map((r) => {
      var _a3, _b2;
      if (isVersionedTransaction(r.tx)) {
        let tx = r.tx;
        if (r.signers) {
          tx.sign(r.signers);
        }
        return tx;
      } else {
        let tx = r.tx;
        let signers = (_a3 = r.signers) !== null && _a3 !== void 0 ? _a3 : [];
        tx.feePayer = (_b2 = tx.feePayer) !== null && _b2 !== void 0 ? _b2 : this.wallet.publicKey;
        tx.recentBlockhash = recentBlockhash;
        signers.forEach((kp) => {
          tx.partialSign(kp);
        });
        return tx;
      }
    });
    const signedTxs = await this.wallet.signAllTransactions(txs);
    const sigs = [];
    for (let k = 0; k < txs.length; k += 1) {
      const tx = signedTxs[k];
      const rawTx = tx.serialize();
      try {
        sigs.push(await sendAndConfirmRawTransaction2(this.connection, rawTx, opts));
      } catch (err2) {
        if (err2 instanceof ConfirmError) {
          const txSig = encode$1(isVersionedTransaction(tx) ? ((_a2 = tx.signatures) === null || _a2 === void 0 ? void 0 : _a2[0]) || new Uint8Array() : (_b = tx.signature) !== null && _b !== void 0 ? _b : new Uint8Array());
          const failedTx = await this.connection.getTransaction(txSig, {
            commitment: "confirmed"
          });
          if (!failedTx) {
            throw err2;
          } else {
            const logs = (_c = failedTx.meta) === null || _c === void 0 ? void 0 : _c.logMessages;
            throw !logs ? err2 : new SendTransactionError(err2.message, logs);
          }
        } else {
          throw err2;
        }
      }
    }
    return sigs;
  }
  /**
   * Simulates the given transaction, returning emitted logs from execution.
   *
   * @param tx      The transaction to send.
   * @param signers The signers of the transaction. If unset, the transaction
   *                will be simulated with the "sigVerify: false" option. This
   *                allows for simulation of transactions without asking the
   *                wallet for a signature.
   * @param opts    Transaction confirmation options.
   */
  async simulate(tx, signers, commitment, includeAccounts) {
    let recentBlockhash = (await this.connection.getLatestBlockhash(commitment !== null && commitment !== void 0 ? commitment : this.connection.commitment)).blockhash;
    let result;
    if (isVersionedTransaction(tx)) {
      if (signers) {
        tx.sign(signers);
        tx = await this.wallet.signTransaction(tx);
      }
      result = await this.connection.simulateTransaction(tx, { commitment });
    } else {
      tx.feePayer = tx.feePayer || this.wallet.publicKey;
      tx.recentBlockhash = recentBlockhash;
      if (signers) {
        tx = await this.wallet.signTransaction(tx);
      }
      result = await simulateTransaction(this.connection, tx, signers, commitment, includeAccounts);
    }
    if (result.value.err) {
      throw new SimulateError(result.value);
    }
    return result.value;
  }
};
var SimulateError = class extends Error {
  constructor(simulationResponse, message) {
    super(message);
    this.simulationResponse = simulationResponse;
  }
};
async function sendAndConfirmRawTransaction2(connection, rawTransaction, options) {
  const sendOptions = options && {
    skipPreflight: options.skipPreflight,
    preflightCommitment: options.preflightCommitment || options.commitment
  };
  const signature2 = await connection.sendRawTransaction(rawTransaction, sendOptions);
  const status = (await connection.confirmTransaction(signature2, options && options.commitment)).value;
  if (status.err) {
    throw new ConfirmError(`Raw transaction ${signature2} failed (${JSON.stringify(status)})`);
  }
  return signature2;
}
var ConfirmError = class extends Error {
  constructor(message) {
    super(message);
  }
};
function getProvider() {
  if (_provider === null) {
    return AnchorProvider.local();
  }
  return _provider;
}
var _provider = null;
var _AVAILABLE_FEATURES = /* @__PURE__ */ new Set(["anchor-deprecated-state", "debug-logs"]);
var _FEATURES = /* @__PURE__ */ new Map();
function set(key) {
  if (!_AVAILABLE_FEATURES.has(key)) {
    throw new Error("Invalid feature");
  }
  _FEATURES.set(key, true);
}
function isSet(key) {
  return _FEATURES.get(key) !== void 0;
}
var features = Object.freeze({
  __proto__: null,
  set,
  isSet
});
var IdlError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "IdlError";
  }
};
var ProgramErrorStack = class _ProgramErrorStack {
  constructor(stack) {
    this.stack = stack;
  }
  static parse(logs) {
    var _a2;
    const programKeyRegex = /^Program (\w*) invoke/;
    const successRegex = /^Program \w* success/;
    const programStack = [];
    for (let i = 0; i < logs.length; i++) {
      if (successRegex.exec(logs[i])) {
        programStack.pop();
        continue;
      }
      const programKey = (_a2 = programKeyRegex.exec(logs[i])) === null || _a2 === void 0 ? void 0 : _a2[1];
      if (!programKey) {
        continue;
      }
      programStack.push(new PublicKey(programKey));
    }
    return new _ProgramErrorStack(programStack);
  }
};
var AnchorError = class _AnchorError extends Error {
  constructor(errorCode, errorMessage, errorLogs, logs, origin, comparedValues) {
    super(errorLogs.join("\n").replace("Program log: ", ""));
    this.errorLogs = errorLogs;
    this.logs = logs;
    this.error = { errorCode, errorMessage, comparedValues, origin };
    this._programErrorStack = ProgramErrorStack.parse(logs);
  }
  static parse(logs) {
    if (!logs) {
      return null;
    }
    const anchorErrorLogIndex = logs.findIndex((log) => log.startsWith("Program log: AnchorError"));
    if (anchorErrorLogIndex === -1) {
      return null;
    }
    const anchorErrorLog = logs[anchorErrorLogIndex];
    const errorLogs = [anchorErrorLog];
    let comparedValues;
    if (anchorErrorLogIndex + 1 < logs.length) {
      if (logs[anchorErrorLogIndex + 1] === "Program log: Left:") {
        const pubkeyRegex = /^Program log: (.*)$/;
        const leftPubkey = pubkeyRegex.exec(logs[anchorErrorLogIndex + 2])[1];
        const rightPubkey = pubkeyRegex.exec(logs[anchorErrorLogIndex + 4])[1];
        comparedValues = [
          new PublicKey(leftPubkey),
          new PublicKey(rightPubkey)
        ];
        errorLogs.push(...logs.slice(anchorErrorLogIndex + 1, anchorErrorLogIndex + 5));
      } else if (logs[anchorErrorLogIndex + 1].startsWith("Program log: Left:")) {
        const valueRegex = /^Program log: (Left|Right): (.*)$/;
        const leftValue = valueRegex.exec(logs[anchorErrorLogIndex + 1])[2];
        const rightValue = valueRegex.exec(logs[anchorErrorLogIndex + 2])[2];
        errorLogs.push(...logs.slice(anchorErrorLogIndex + 1, anchorErrorLogIndex + 3));
        comparedValues = [leftValue, rightValue];
      }
    }
    const regexNoInfo = /^Program log: AnchorError occurred\. Error Code: (.*)\. Error Number: (\d*)\. Error Message: (.*)\./;
    const noInfoAnchorErrorLog = regexNoInfo.exec(anchorErrorLog);
    const regexFileLine = /^Program log: AnchorError thrown in (.*):(\d*)\. Error Code: (.*)\. Error Number: (\d*)\. Error Message: (.*)\./;
    const fileLineAnchorErrorLog = regexFileLine.exec(anchorErrorLog);
    const regexAccountName = /^Program log: AnchorError caused by account: (.*)\. Error Code: (.*)\. Error Number: (\d*)\. Error Message: (.*)\./;
    const accountNameAnchorErrorLog = regexAccountName.exec(anchorErrorLog);
    if (noInfoAnchorErrorLog) {
      const [errorCodeString, errorNumber, errorMessage] = noInfoAnchorErrorLog.slice(1, 4);
      const errorCode = {
        code: errorCodeString,
        number: parseInt(errorNumber)
      };
      return new _AnchorError(errorCode, errorMessage, errorLogs, logs, void 0, comparedValues);
    } else if (fileLineAnchorErrorLog) {
      const [file, line, errorCodeString, errorNumber, errorMessage] = fileLineAnchorErrorLog.slice(1, 6);
      const errorCode = {
        code: errorCodeString,
        number: parseInt(errorNumber)
      };
      const fileLine = { file, line: parseInt(line) };
      return new _AnchorError(errorCode, errorMessage, errorLogs, logs, fileLine, comparedValues);
    } else if (accountNameAnchorErrorLog) {
      const [accountName, errorCodeString, errorNumber, errorMessage] = accountNameAnchorErrorLog.slice(1, 5);
      const origin = accountName;
      const errorCode = {
        code: errorCodeString,
        number: parseInt(errorNumber)
      };
      return new _AnchorError(errorCode, errorMessage, errorLogs, logs, origin, comparedValues);
    } else {
      return null;
    }
  }
  get program() {
    return this._programErrorStack.stack[this._programErrorStack.stack.length - 1];
  }
  get programErrorStack() {
    return this._programErrorStack.stack;
  }
  toString() {
    return this.message;
  }
};
var ProgramError = class _ProgramError extends Error {
  constructor(code2, msg, logs) {
    super();
    this.code = code2;
    this.msg = msg;
    this.logs = logs;
    if (logs) {
      this._programErrorStack = ProgramErrorStack.parse(logs);
    }
  }
  static parse(err2, idlErrors) {
    const errString = err2.toString();
    let unparsedErrorCode;
    if (errString.includes("custom program error:")) {
      let components = errString.split("custom program error: ");
      if (components.length !== 2) {
        return null;
      } else {
        unparsedErrorCode = components[1];
      }
    } else {
      const matches = errString.match(/"Custom":([0-9]+)}/g);
      if (!matches || matches.length > 1) {
        return null;
      }
      unparsedErrorCode = matches[0].match(/([0-9]+)/g)[0];
    }
    let errorCode;
    try {
      errorCode = parseInt(unparsedErrorCode);
    } catch (parseErr) {
      return null;
    }
    let errorMsg = idlErrors.get(errorCode);
    if (errorMsg !== void 0) {
      return new _ProgramError(errorCode, errorMsg, err2.logs);
    }
    errorMsg = LangErrorMessage.get(errorCode);
    if (errorMsg !== void 0) {
      return new _ProgramError(errorCode, errorMsg, err2.logs);
    }
    return null;
  }
  get program() {
    var _a2;
    return (_a2 = this._programErrorStack) === null || _a2 === void 0 ? void 0 : _a2.stack[this._programErrorStack.stack.length - 1];
  }
  get programErrorStack() {
    var _a2;
    return (_a2 = this._programErrorStack) === null || _a2 === void 0 ? void 0 : _a2.stack;
  }
  toString() {
    return this.msg;
  }
};
function translateError(err2, idlErrors) {
  if (isSet("debug-logs")) {
    console.log("Translating error:", err2);
  }
  const anchorError = AnchorError.parse(err2.logs);
  if (anchorError) {
    return anchorError;
  }
  const programError = ProgramError.parse(err2, idlErrors);
  if (programError) {
    return programError;
  }
  if (err2.logs) {
    const handler = {
      get: function(target, prop) {
        if (prop === "programErrorStack") {
          return target.programErrorStack.stack;
        } else if (prop === "program") {
          return target.programErrorStack.stack[err2.programErrorStack.stack.length - 1];
        } else {
          return Reflect.get(...arguments);
        }
      }
    };
    err2.programErrorStack = ProgramErrorStack.parse(err2.logs);
    return new Proxy(err2, handler);
  }
  return err2;
}
var LangErrorCode = {
  // Instructions.
  InstructionMissing: 100,
  InstructionFallbackNotFound: 101,
  InstructionDidNotDeserialize: 102,
  InstructionDidNotSerialize: 103,
  // IDL instructions.
  IdlInstructionStub: 1e3,
  IdlInstructionInvalidProgram: 1001,
  // Constraints.
  ConstraintMut: 2e3,
  ConstraintHasOne: 2001,
  ConstraintSigner: 2002,
  ConstraintRaw: 2003,
  ConstraintOwner: 2004,
  ConstraintRentExempt: 2005,
  ConstraintSeeds: 2006,
  ConstraintExecutable: 2007,
  ConstraintState: 2008,
  ConstraintAssociated: 2009,
  ConstraintAssociatedInit: 2010,
  ConstraintClose: 2011,
  ConstraintAddress: 2012,
  ConstraintZero: 2013,
  ConstraintTokenMint: 2014,
  ConstraintTokenOwner: 2015,
  ConstraintMintMintAuthority: 2016,
  ConstraintMintFreezeAuthority: 2017,
  ConstraintMintDecimals: 2018,
  ConstraintSpace: 2019,
  ConstraintAccountIsNone: 2020,
  // Require.
  RequireViolated: 2500,
  RequireEqViolated: 2501,
  RequireKeysEqViolated: 2502,
  RequireNeqViolated: 2503,
  RequireKeysNeqViolated: 2504,
  RequireGtViolated: 2505,
  RequireGteViolated: 2506,
  // Accounts.
  AccountDiscriminatorAlreadySet: 3e3,
  AccountDiscriminatorNotFound: 3001,
  AccountDiscriminatorMismatch: 3002,
  AccountDidNotDeserialize: 3003,
  AccountDidNotSerialize: 3004,
  AccountNotEnoughKeys: 3005,
  AccountNotMutable: 3006,
  AccountOwnedByWrongProgram: 3007,
  InvalidProgramId: 3008,
  InvalidProgramExecutable: 3009,
  AccountNotSigner: 3010,
  AccountNotSystemOwned: 3011,
  AccountNotInitialized: 3012,
  AccountNotProgramData: 3013,
  AccountNotAssociatedTokenAccount: 3014,
  AccountSysvarMismatch: 3015,
  AccountReallocExceedsLimit: 3016,
  AccountDuplicateReallocs: 3017,
  // Miscellaneous
  DeclaredProgramIdMismatch: 4100,
  // Used for APIs that shouldn't be used anymore.
  Deprecated: 5e3
};
var LangErrorMessage = /* @__PURE__ */ new Map([
  // Instructions.
  [
    LangErrorCode.InstructionMissing,
    "8 byte instruction identifier not provided"
  ],
  [
    LangErrorCode.InstructionFallbackNotFound,
    "Fallback functions are not supported"
  ],
  [
    LangErrorCode.InstructionDidNotDeserialize,
    "The program could not deserialize the given instruction"
  ],
  [
    LangErrorCode.InstructionDidNotSerialize,
    "The program could not serialize the given instruction"
  ],
  // Idl instructions.
  [
    LangErrorCode.IdlInstructionStub,
    "The program was compiled without idl instructions"
  ],
  [
    LangErrorCode.IdlInstructionInvalidProgram,
    "The transaction was given an invalid program for the IDL instruction"
  ],
  // Constraints.
  [LangErrorCode.ConstraintMut, "A mut constraint was violated"],
  [LangErrorCode.ConstraintHasOne, "A has one constraint was violated"],
  [LangErrorCode.ConstraintSigner, "A signer constraint was violated"],
  [LangErrorCode.ConstraintRaw, "A raw constraint was violated"],
  [LangErrorCode.ConstraintOwner, "An owner constraint was violated"],
  [
    LangErrorCode.ConstraintRentExempt,
    "A rent exemption constraint was violated"
  ],
  [LangErrorCode.ConstraintSeeds, "A seeds constraint was violated"],
  [LangErrorCode.ConstraintExecutable, "An executable constraint was violated"],
  [
    LangErrorCode.ConstraintState,
    "Deprecated Error, feel free to replace with something else"
  ],
  [LangErrorCode.ConstraintAssociated, "An associated constraint was violated"],
  [
    LangErrorCode.ConstraintAssociatedInit,
    "An associated init constraint was violated"
  ],
  [LangErrorCode.ConstraintClose, "A close constraint was violated"],
  [LangErrorCode.ConstraintAddress, "An address constraint was violated"],
  [LangErrorCode.ConstraintZero, "Expected zero account discriminant"],
  [LangErrorCode.ConstraintTokenMint, "A token mint constraint was violated"],
  [LangErrorCode.ConstraintTokenOwner, "A token owner constraint was violated"],
  [
    LangErrorCode.ConstraintMintMintAuthority,
    "A mint mint authority constraint was violated"
  ],
  [
    LangErrorCode.ConstraintMintFreezeAuthority,
    "A mint freeze authority constraint was violated"
  ],
  [
    LangErrorCode.ConstraintMintDecimals,
    "A mint decimals constraint was violated"
  ],
  [LangErrorCode.ConstraintSpace, "A space constraint was violated"],
  [
    LangErrorCode.ConstraintAccountIsNone,
    "A required account for the constraint is None"
  ],
  // Require.
  [LangErrorCode.RequireViolated, "A require expression was violated"],
  [LangErrorCode.RequireEqViolated, "A require_eq expression was violated"],
  [
    LangErrorCode.RequireKeysEqViolated,
    "A require_keys_eq expression was violated"
  ],
  [LangErrorCode.RequireNeqViolated, "A require_neq expression was violated"],
  [
    LangErrorCode.RequireKeysNeqViolated,
    "A require_keys_neq expression was violated"
  ],
  [LangErrorCode.RequireGtViolated, "A require_gt expression was violated"],
  [LangErrorCode.RequireGteViolated, "A require_gte expression was violated"],
  // Accounts.
  [
    LangErrorCode.AccountDiscriminatorAlreadySet,
    "The account discriminator was already set on this account"
  ],
  [
    LangErrorCode.AccountDiscriminatorNotFound,
    "No 8 byte discriminator was found on the account"
  ],
  [
    LangErrorCode.AccountDiscriminatorMismatch,
    "8 byte discriminator did not match what was expected"
  ],
  [LangErrorCode.AccountDidNotDeserialize, "Failed to deserialize the account"],
  [LangErrorCode.AccountDidNotSerialize, "Failed to serialize the account"],
  [
    LangErrorCode.AccountNotEnoughKeys,
    "Not enough account keys given to the instruction"
  ],
  [LangErrorCode.AccountNotMutable, "The given account is not mutable"],
  [
    LangErrorCode.AccountOwnedByWrongProgram,
    "The given account is owned by a different program than expected"
  ],
  [LangErrorCode.InvalidProgramId, "Program ID was not as expected"],
  [LangErrorCode.InvalidProgramExecutable, "Program account is not executable"],
  [LangErrorCode.AccountNotSigner, "The given account did not sign"],
  [
    LangErrorCode.AccountNotSystemOwned,
    "The given account is not owned by the system program"
  ],
  [
    LangErrorCode.AccountNotInitialized,
    "The program expected this account to be already initialized"
  ],
  [
    LangErrorCode.AccountNotProgramData,
    "The given account is not a program data account"
  ],
  [
    LangErrorCode.AccountNotAssociatedTokenAccount,
    "The given account is not the associated token account"
  ],
  [
    LangErrorCode.AccountSysvarMismatch,
    "The given public key does not match the required sysvar"
  ],
  [
    LangErrorCode.AccountReallocExceedsLimit,
    "The account reallocation exceeds the MAX_PERMITTED_DATA_INCREASE limit"
  ],
  [
    LangErrorCode.AccountDuplicateReallocs,
    "The account was duplicated for more than one reallocation"
  ],
  // Miscellaneous
  [
    LangErrorCode.DeclaredProgramIdMismatch,
    "The declared program id does not match the actual program id"
  ],
  // Deprecated
  [
    LangErrorCode.Deprecated,
    "The API being used is deprecated and should no longer be used"
  ]
]);
var __assign$1 = function() {
  __assign$1 = Object.assign || function __assign3(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }
    return t;
  };
  return __assign$1.apply(this, arguments);
};
var __assign2 = function() {
  __assign2 = Object.assign || function __assign3(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }
    return t;
  };
  return __assign2.apply(this, arguments);
};
function lowerCase2(str2) {
  return str2.toLowerCase();
}
var DEFAULT_SPLIT_REGEXP2 = [/([a-z0-9])([A-Z])/g, /([A-Z])([A-Z][a-z])/g];
var DEFAULT_STRIP_REGEXP2 = /[^A-Z0-9]+/gi;
function noCase2(input, options) {
  if (options === void 0) {
    options = {};
  }
  var _a2 = options.splitRegexp, splitRegexp = _a2 === void 0 ? DEFAULT_SPLIT_REGEXP2 : _a2, _b = options.stripRegexp, stripRegexp = _b === void 0 ? DEFAULT_STRIP_REGEXP2 : _b, _c = options.transform, transform = _c === void 0 ? lowerCase2 : _c, _d = options.delimiter, delimiter = _d === void 0 ? " " : _d;
  var result = replace2(replace2(input, splitRegexp, "$1\0$2"), stripRegexp, "\0");
  var start = 0;
  var end = result.length;
  while (result.charAt(start) === "\0")
    start++;
  while (result.charAt(end - 1) === "\0")
    end--;
  return result.slice(start, end).split("\0").map(transform).join(delimiter);
}
function replace2(input, re, value) {
  if (re instanceof RegExp)
    return input.replace(re, value);
  return re.reduce(function(input2, re2) {
    return input2.replace(re2, value);
  }, input);
}
function dotCase2(input, options) {
  if (options === void 0) {
    options = {};
  }
  return noCase2(input, __assign2({ delimiter: "." }, options));
}
function snakeCase2(input, options) {
  if (options === void 0) {
    options = {};
  }
  return dotCase2(input, __assign$1({ delimiter: "_" }, options));
}
var IdlCoder = class _IdlCoder {
  static fieldLayout(field, types) {
    const fieldName = field.name !== void 0 ? (0, import_camelcase.default)(field.name) : void 0;
    switch (field.type) {
      case "bool": {
        return borsh.bool(fieldName);
      }
      case "u8": {
        return borsh.u8(fieldName);
      }
      case "i8": {
        return borsh.i8(fieldName);
      }
      case "u16": {
        return borsh.u16(fieldName);
      }
      case "i16": {
        return borsh.i16(fieldName);
      }
      case "u32": {
        return borsh.u32(fieldName);
      }
      case "i32": {
        return borsh.i32(fieldName);
      }
      case "f32": {
        return borsh.f32(fieldName);
      }
      case "u64": {
        return borsh.u64(fieldName);
      }
      case "i64": {
        return borsh.i64(fieldName);
      }
      case "f64": {
        return borsh.f64(fieldName);
      }
      case "u128": {
        return borsh.u128(fieldName);
      }
      case "i128": {
        return borsh.i128(fieldName);
      }
      case "u256": {
        return borsh.u256(fieldName);
      }
      case "i256": {
        return borsh.i256(fieldName);
      }
      case "bytes": {
        return borsh.vecU8(fieldName);
      }
      case "string": {
        return borsh.str(fieldName);
      }
      case "publicKey": {
        return borsh.publicKey(fieldName);
      }
      default: {
        if ("vec" in field.type) {
          return borsh.vec(_IdlCoder.fieldLayout({
            name: void 0,
            type: field.type.vec
          }, types), fieldName);
        } else if ("option" in field.type) {
          return borsh.option(_IdlCoder.fieldLayout({
            name: void 0,
            type: field.type.option
          }, types), fieldName);
        } else if ("defined" in field.type) {
          if (!types) {
            throw new IdlError("User defined types not provided");
          }
          const defined = field.type.defined;
          const filtered = types.filter((t) => t.name === defined);
          if (filtered.length !== 1) {
            throw new IdlError(`Type not found: ${JSON.stringify(field)}`);
          }
          return _IdlCoder.typeDefLayout(filtered[0], types, fieldName);
        } else if ("array" in field.type) {
          let arrayTy = field.type.array[0];
          let arrayLen = field.type.array[1];
          let innerLayout = _IdlCoder.fieldLayout({
            name: void 0,
            type: arrayTy
          }, types);
          return borsh.array(innerLayout, arrayLen, fieldName);
        } else {
          throw new Error(`Not yet implemented: ${field}`);
        }
      }
    }
  }
  static typeDefLayout(typeDef, types = [], name) {
    switch (typeDef.type.kind) {
      case "struct": {
        const fieldLayouts = typeDef.type.fields.map((field) => {
          return _IdlCoder.fieldLayout(field, types);
        });
        return borsh.struct(fieldLayouts, name);
      }
      case "enum": {
        let variants = typeDef.type.variants.map((variant) => {
          const name2 = (0, import_camelcase.default)(variant.name);
          if (!variant.fields) {
            return borsh.struct([], name2);
          }
          const fieldLayouts = variant.fields.map((f3, i) => {
            if (f3 === null || f3 === void 0 ? void 0 : f3.name) {
              return _IdlCoder.fieldLayout(f3, types);
            }
            return _IdlCoder.fieldLayout({ type: f3, name: i.toString() }, types);
          });
          return borsh.struct(fieldLayouts, name2);
        });
        if (name !== void 0) {
          return borsh.rustEnum(variants).replicate(name);
        }
        return borsh.rustEnum(variants, name);
      }
      case "alias": {
        return _IdlCoder.fieldLayout({ type: typeDef.type.value, name: typeDef.name }, types);
      }
    }
  }
};
var SIGHASH_GLOBAL_NAMESPACE = "global";
var BorshInstructionCoder = class _BorshInstructionCoder {
  constructor(idl) {
    this.idl = idl;
    this.ixLayout = _BorshInstructionCoder.parseIxLayout(idl);
    const sighashLayouts = /* @__PURE__ */ new Map();
    idl.instructions.forEach((ix) => {
      const sh = sighash(SIGHASH_GLOBAL_NAMESPACE, ix.name);
      sighashLayouts.set(import_bs583.default.encode(sh), {
        layout: this.ixLayout.get(ix.name),
        name: ix.name
      });
    });
    this.sighashLayouts = sighashLayouts;
  }
  /**
   * Encodes a program instruction.
   */
  encode(ixName, ix) {
    return this._encode(SIGHASH_GLOBAL_NAMESPACE, ixName, ix);
  }
  _encode(nameSpace, ixName, ix) {
    const buffer3 = import_buffer3.Buffer.alloc(1e3);
    const methodName = (0, import_camelcase.default)(ixName);
    const layout = this.ixLayout.get(methodName);
    if (!layout) {
      throw new Error(`Unknown method: ${methodName}`);
    }
    const len = layout.encode(ix, buffer3);
    const data = buffer3.slice(0, len);
    return import_buffer3.Buffer.concat([sighash(nameSpace, ixName), data]);
  }
  static parseIxLayout(idl) {
    const ixLayouts = idl.instructions.map((ix) => {
      let fieldLayouts = ix.args.map((arg) => {
        var _a2, _b;
        return IdlCoder.fieldLayout(arg, Array.from([...(_a2 = idl.accounts) !== null && _a2 !== void 0 ? _a2 : [], ...(_b = idl.types) !== null && _b !== void 0 ? _b : []]));
      });
      const name = (0, import_camelcase.default)(ix.name);
      return [name, borsh.struct(fieldLayouts, name)];
    });
    return new Map(ixLayouts);
  }
  /**
   * Decodes a program instruction.
   */
  decode(ix, encoding = "hex") {
    if (typeof ix === "string") {
      ix = encoding === "hex" ? import_buffer3.Buffer.from(ix, "hex") : import_bs583.default.decode(ix);
    }
    let sighash2 = import_bs583.default.encode(ix.slice(0, 8));
    let data = ix.slice(8);
    const decoder = this.sighashLayouts.get(sighash2);
    if (!decoder) {
      return null;
    }
    return {
      data: decoder.layout.decode(data),
      name: decoder.name
    };
  }
  /**
   * Returns a formatted table of all the fields in the given instruction data.
   */
  format(ix, accountMetas) {
    return InstructionFormatter.format(ix, accountMetas, this.idl);
  }
};
var InstructionFormatter = class _InstructionFormatter {
  static format(ix, accountMetas, idl) {
    const idlIx = idl.instructions.filter((i) => ix.name === i.name)[0];
    if (idlIx === void 0) {
      console.error("Invalid instruction given");
      return null;
    }
    const args = idlIx.args.map((idlField) => {
      return {
        name: idlField.name,
        type: _InstructionFormatter.formatIdlType(idlField.type),
        data: _InstructionFormatter.formatIdlData(idlField, ix.data[idlField.name], idl.types)
      };
    });
    const flatIdlAccounts = _InstructionFormatter.flattenIdlAccounts(idlIx.accounts);
    const accounts = accountMetas.map((meta, idx) => {
      if (idx < flatIdlAccounts.length) {
        return {
          name: flatIdlAccounts[idx].name,
          ...meta
        };
      } else {
        return {
          name: void 0,
          ...meta
        };
      }
    });
    return {
      args,
      accounts
    };
  }
  static formatIdlType(idlType) {
    if (typeof idlType === "string") {
      return idlType;
    }
    if ("vec" in idlType) {
      return `Vec<${this.formatIdlType(idlType.vec)}>`;
    }
    if ("option" in idlType) {
      return `Option<${this.formatIdlType(idlType.option)}>`;
    }
    if ("defined" in idlType) {
      return idlType.defined;
    }
    if ("array" in idlType) {
      return `Array<${idlType.array[0]}; ${idlType.array[1]}>`;
    }
    throw new Error(`Unknown IDL type: ${idlType}`);
  }
  static formatIdlData(idlField, data, types) {
    if (typeof idlField.type === "string") {
      return data.toString();
    }
    if (idlField.type.hasOwnProperty("vec")) {
      return "[" + data.map((d) => this.formatIdlData({ name: "", type: idlField.type.vec }, d)).join(", ") + "]";
    }
    if (idlField.type.hasOwnProperty("option")) {
      return data === null ? "null" : this.formatIdlData({ name: "", type: idlField.type.option }, data, types);
    }
    if (idlField.type.hasOwnProperty("defined")) {
      if (types === void 0) {
        throw new Error("User defined types not provided");
      }
      const filtered = types.filter((t) => t.name === idlField.type.defined);
      if (filtered.length !== 1) {
        throw new Error(`Type not found: ${idlField.type.defined}`);
      }
      return _InstructionFormatter.formatIdlDataDefined(filtered[0], data, types);
    }
    return "unknown";
  }
  static formatIdlDataDefined(typeDef, data, types) {
    switch (typeDef.type.kind) {
      case "struct": {
        const struct52 = typeDef.type;
        const fields = Object.keys(data).map((k) => {
          const field = struct52.fields.find((f3) => f3.name === k);
          if (!field) {
            throw new Error("Unable to find type");
          }
          return k + ": " + _InstructionFormatter.formatIdlData(field, data[k], types);
        }).join(", ");
        return "{ " + fields + " }";
      }
      case "enum": {
        if (typeDef.type.variants.length === 0) {
          return "{}";
        }
        if (typeDef.type.variants[0].name) {
          const variants = typeDef.type.variants;
          const variant = Object.keys(data)[0];
          const enumType = data[variant];
          const namedFields = Object.keys(enumType).map((f3) => {
            var _a2;
            const fieldData = enumType[f3];
            const idlField = (_a2 = variants[variant]) === null || _a2 === void 0 ? void 0 : _a2.find((v) => v.name === f3);
            if (!idlField) {
              throw new Error("Unable to find variant");
            }
            return f3 + ": " + _InstructionFormatter.formatIdlData(idlField, fieldData, types);
          }).join(", ");
          const variantName = (0, import_camelcase.default)(variant, { pascalCase: true });
          if (namedFields.length === 0) {
            return variantName;
          }
          return `${variantName} { ${namedFields} }`;
        } else {
          return "Tuple formatting not yet implemented";
        }
      }
      case "alias": {
        return _InstructionFormatter.formatIdlType(typeDef.type.value);
      }
    }
  }
  static flattenIdlAccounts(accounts, prefix) {
    return accounts.map((account) => {
      const accName = sentenceCase(account.name);
      if (account.hasOwnProperty("accounts")) {
        const newPrefix = prefix ? `${prefix} > ${accName}` : accName;
        return _InstructionFormatter.flattenIdlAccounts(account.accounts, newPrefix);
      } else {
        return {
          ...account,
          name: prefix ? `${prefix} > ${accName}` : accName
        };
      }
    }).flat();
  }
};
function sentenceCase(field) {
  const result = field.replace(/([A-Z])/g, " $1");
  return result.charAt(0).toUpperCase() + result.slice(1);
}
function sighash(nameSpace, ixName) {
  let name = snakeCase2(ixName);
  let preimage = `${nameSpace}:${name}`;
  return import_buffer3.Buffer.from(sha2567(preimage).slice(0, 8));
}
function accountSize(idl, idlAccount) {
  switch (idlAccount.type.kind) {
    case "struct": {
      return idlAccount.type.fields.map((f3) => typeSize(idl, f3.type)).reduce((acc, size4) => acc + size4, 0);
    }
    case "enum": {
      const variantSizes = idlAccount.type.variants.map((variant) => {
        if (!variant.fields) {
          return 0;
        }
        return variant.fields.map((f3) => {
          if (!(typeof f3 === "object" && "name" in f3)) {
            return typeSize(idl, f3);
          }
          return typeSize(idl, f3.type);
        }).reduce((acc, size4) => acc + size4, 0);
      });
      return Math.max(...variantSizes) + 1;
    }
    case "alias": {
      return typeSize(idl, idlAccount.type.value);
    }
  }
}
function typeSize(idl, ty) {
  var _a2, _b;
  switch (ty) {
    case "bool":
      return 1;
    case "u8":
      return 1;
    case "i8":
      return 1;
    case "i16":
      return 2;
    case "u16":
      return 2;
    case "u32":
      return 4;
    case "i32":
      return 4;
    case "f32":
      return 4;
    case "u64":
      return 8;
    case "i64":
      return 8;
    case "f64":
      return 8;
    case "u128":
      return 16;
    case "i128":
      return 16;
    case "u256":
      return 32;
    case "i256":
      return 32;
    case "bytes":
      return 1;
    case "string":
      return 1;
    case "publicKey":
      return 32;
    default:
      if ("vec" in ty) {
        return 1;
      }
      if ("option" in ty) {
        return 1 + typeSize(idl, ty.option);
      }
      if ("coption" in ty) {
        return 4 + typeSize(idl, ty.coption);
      }
      if ("defined" in ty) {
        const filtered = (_b = (_a2 = idl.types) === null || _a2 === void 0 ? void 0 : _a2.filter((t) => t.name === ty.defined)) !== null && _b !== void 0 ? _b : [];
        if (filtered.length !== 1) {
          throw new IdlError(`Type not found: ${JSON.stringify(ty)}`);
        }
        let typeDef = filtered[0];
        return accountSize(idl, typeDef);
      }
      if ("array" in ty) {
        let arrayTy = ty.array[0];
        let arraySize = ty.array[1];
        return typeSize(idl, arrayTy) * arraySize;
      }
      throw new Error(`Invalid type ${JSON.stringify(ty)}`);
  }
}
var DISCRIMINATOR_SIZE = 8;
function discriminator(preimage) {
  return Buffer.from(sha2567(preimage).slice(0, DISCRIMINATOR_SIZE));
}
var BorshAccountsCoder = class _BorshAccountsCoder {
  constructor(idl) {
    if (idl.accounts === void 0) {
      this.accountLayouts = /* @__PURE__ */ new Map();
      return;
    }
    const layouts = idl.accounts.map((acc) => {
      return [acc.name, IdlCoder.typeDefLayout(acc, idl.types)];
    });
    this.accountLayouts = new Map(layouts);
    this.idl = idl;
  }
  async encode(accountName, account) {
    const buffer3 = import_buffer3.Buffer.alloc(1e3);
    const layout = this.accountLayouts.get(accountName);
    if (!layout) {
      throw new Error(`Unknown account: ${accountName}`);
    }
    const len = layout.encode(account, buffer3);
    let accountData = buffer3.slice(0, len);
    let discriminator2 = _BorshAccountsCoder.accountDiscriminator(accountName);
    return import_buffer3.Buffer.concat([discriminator2, accountData]);
  }
  decode(accountName, data) {
    const discriminator2 = _BorshAccountsCoder.accountDiscriminator(accountName);
    if (discriminator2.compare(data.slice(0, 8))) {
      throw new Error("Invalid account discriminator");
    }
    return this.decodeUnchecked(accountName, data);
  }
  decodeAny(data) {
    const accountDescriminator = data.slice(0, 8);
    const accountName = Array.from(this.accountLayouts.keys()).find((key) => _BorshAccountsCoder.accountDiscriminator(key).equals(accountDescriminator));
    if (!accountName) {
      throw new Error("Account descriminator not found");
    }
    return this.decodeUnchecked(accountName, data);
  }
  decodeUnchecked(accountName, ix) {
    const data = ix.subarray(DISCRIMINATOR_SIZE);
    const layout = this.accountLayouts.get(accountName);
    if (!layout) {
      throw new Error(`Unknown account: ${accountName}`);
    }
    return layout.decode(data);
  }
  memcmp(accountName, appendData) {
    const discriminator2 = _BorshAccountsCoder.accountDiscriminator(accountName);
    return {
      offset: 0,
      bytes: import_bs583.default.encode(appendData ? import_buffer3.Buffer.concat([discriminator2, appendData]) : discriminator2)
    };
  }
  size(idlAccount) {
    var _a2;
    return DISCRIMINATOR_SIZE + ((_a2 = accountSize(this.idl, idlAccount)) !== null && _a2 !== void 0 ? _a2 : 0);
  }
  /**
   * Calculates and returns a unique 8 byte discriminator prepended to all anchor accounts.
   *
   * @param name The name of the account to calculate the discriminator.
   */
  static accountDiscriminator(name) {
    const discriminatorPreimage = `account:${(0, import_camelcase.default)(name, {
      pascalCase: true,
      preserveConsecutiveUppercase: true
    })}`;
    return discriminator(discriminatorPreimage);
  }
};
var BorshEventCoder = class {
  constructor(idl) {
    if (idl.events === void 0) {
      this.layouts = /* @__PURE__ */ new Map();
      return;
    }
    const layouts = idl.events.map((event) => {
      let eventTypeDef = {
        name: event.name,
        type: {
          kind: "struct",
          fields: event.fields.map((f3) => {
            return { name: f3.name, type: f3.type };
          })
        }
      };
      return [event.name, IdlCoder.typeDefLayout(eventTypeDef, idl.types)];
    });
    this.layouts = new Map(layouts);
    this.discriminators = new Map(idl.events === void 0 ? [] : idl.events.map((e) => [
      encode2(eventDiscriminator(e.name)),
      e.name
    ]));
  }
  decode(log) {
    let logArr;
    try {
      logArr = decode2(log);
    } catch (e) {
      return null;
    }
    const disc = encode2(logArr.slice(0, 8));
    const eventName = this.discriminators.get(disc);
    if (eventName === void 0) {
      return null;
    }
    const layout = this.layouts.get(eventName);
    if (!layout) {
      throw new Error(`Unknown event: ${eventName}`);
    }
    const data = layout.decode(logArr.slice(8));
    return { data, name: eventName };
  }
};
function eventDiscriminator(name) {
  return discriminator(`event:${name}`);
}
var BorshTypesCoder = class {
  constructor(idl) {
    if (idl.types === void 0) {
      this.typeLayouts = /* @__PURE__ */ new Map();
      return;
    }
    const layouts = idl.types.map((acc) => {
      return [acc.name, IdlCoder.typeDefLayout(acc, idl.types)];
    });
    this.typeLayouts = new Map(layouts);
    this.idl = idl;
  }
  encode(typeName, type3) {
    const buffer3 = import_buffer3.Buffer.alloc(1e3);
    const layout = this.typeLayouts.get(typeName);
    if (!layout) {
      throw new Error(`Unknown type: ${typeName}`);
    }
    const len = layout.encode(type3, buffer3);
    return buffer3.slice(0, len);
  }
  decode(typeName, typeData) {
    const layout = this.typeLayouts.get(typeName);
    if (!layout) {
      throw new Error(`Unknown type: ${typeName}`);
    }
    return layout.decode(typeData);
  }
};
var BorshCoder = class {
  constructor(idl) {
    this.instruction = new BorshInstructionCoder(idl);
    this.accounts = new BorshAccountsCoder(idl);
    this.events = new BorshEventCoder(idl);
    this.types = new BorshTypesCoder(idl);
  }
};
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs2(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
var Layout4 = class {
  constructor(span, property) {
    if (!Number.isInteger(span)) {
      throw new TypeError("span must be an integer");
    }
    this.span = span;
    this.property = property;
  }
  /** Function to create an Object into which decoded properties will
   * be written.
   *
   * Used only for layouts that {@link Layout#decode|decode} to Object
   * instances, which means:
   * * {@link Structure}
   * * {@link Union}
   * * {@link VariantLayout}
   * * {@link BitStructure}
   *
   * If left undefined the JavaScript representation of these layouts
   * will be Object instances.
   *
   * See {@link bindConstructorLayout}.
   */
  makeDestinationObject() {
    return {};
  }
  /**
   * Decode from a Buffer into an JavaScript value.
   *
   * @param {Buffer} b - the buffer from which encoded data is read.
   *
   * @param {Number} [offset] - the offset at which the encoded data
   * starts.  If absent a zero offset is inferred.
   *
   * @returns {(Number|Array|Object)} - the value of the decoded data.
   *
   * @abstract
   */
  decode(b, offset3) {
    throw new Error("Layout is abstract");
  }
  /**
   * Encode a JavaScript value into a Buffer.
   *
   * @param {(Number|Array|Object)} src - the value to be encoded into
   * the buffer.  The type accepted depends on the (sub-)type of {@link
   * Layout}.
   *
   * @param {Buffer} b - the buffer into which encoded data will be
   * written.
   *
   * @param {Number} [offset] - the offset at which the encoded data
   * starts.  If absent a zero offset is inferred.
   *
   * @returns {Number} - the number of bytes encoded, including the
   * space skipped for internal padding, but excluding data such as
   * {@link Sequence#count|lengths} when stored {@link
   * ExternalLayout|externally}.  This is the adjustment to `offset`
   * producing the offset where data for the next layout would be
   * written.
   *
   * @abstract
   */
  encode(src2, b, offset3) {
    throw new Error("Layout is abstract");
  }
  /**
   * Calculate the span of a specific instance of a layout.
   *
   * @param {Buffer} b - the buffer that contains an encoded instance.
   *
   * @param {Number} [offset] - the offset at which the encoded instance
   * starts.  If absent a zero offset is inferred.
   *
   * @return {Number} - the number of bytes covered by the layout
   * instance.  If this method is not overridden in a subclass the
   * definition-time constant {@link Layout#span|span} will be
   * returned.
   *
   * @throws {RangeError} - if the length of the value cannot be
   * determined.
   */
  getSpan(b, offset3) {
    if (0 > this.span) {
      throw new RangeError("indeterminate span");
    }
    return this.span;
  }
  /**
   * Replicate the layout using a new property.
   *
   * This function must be used to get a structurally-equivalent layout
   * with a different name since all {@link Layout} instances are
   * immutable.
   *
   * **NOTE** This is a shallow copy.  All fields except {@link
   * Layout#property|property} are strictly equal to the origin layout.
   *
   * @param {String} property - the value for {@link
   * Layout#property|property} in the replica.
   *
   * @returns {Layout} - the copy with {@link Layout#property|property}
   * set to `property`.
   */
  replicate(property) {
    const rv = Object.create(this.constructor.prototype);
    Object.assign(rv, this);
    rv.property = property;
    return rv;
  }
  /**
   * Create an object from layout properties and an array of values.
   *
   * **NOTE** This function returns `undefined` if invoked on a layout
   * that does not return its value as an Object.  Objects are
   * returned for things that are a {@link Structure}, which includes
   * {@link VariantLayout|variant layouts} if they are structures, and
   * excludes {@link Union}s.  If you want this feature for a union
   * you must use {@link Union.getVariant|getVariant} to select the
   * desired layout.
   *
   * @param {Array} values - an array of values that correspond to the
   * default order for properties.  As with {@link Layout#decode|decode}
   * layout elements that have no property name are skipped when
   * iterating over the array values.  Only the top-level properties are
   * assigned; arguments are not assigned to properties of contained
   * layouts.  Any unused values are ignored.
   *
   * @return {(Object|undefined)}
   */
  fromArray(values) {
    return void 0;
  }
};
var Layout_2 = Layout4;
function nameWithProperty(name, lo) {
  if (lo.property) {
    return name + "[" + lo.property + "]";
  }
  return name;
}
var ExternalLayout = class extends Layout4 {
  /**
   * Return `true` iff the external layout decodes to an unsigned
   * integer layout.
   *
   * In that case it can be used as the source of {@link
   * Sequence#count|Sequence counts}, {@link Blob#length|Blob lengths},
   * or as {@link UnionLayoutDiscriminator#layout|external union
   * discriminators}.
   *
   * @abstract
   */
  isCount() {
    throw new Error("ExternalLayout is abstract");
  }
};
var OffsetLayout = class extends ExternalLayout {
  constructor(layout, offset3, property) {
    if (!(layout instanceof Layout4)) {
      throw new TypeError("layout must be a Layout");
    }
    if (void 0 === offset3) {
      offset3 = 0;
    } else if (!Number.isInteger(offset3)) {
      throw new TypeError("offset must be integer or undefined");
    }
    super(layout.span, property || layout.property);
    this.layout = layout;
    this.offset = offset3;
  }
  /** @override */
  isCount() {
    return this.layout instanceof UInt || this.layout instanceof UIntBE;
  }
  /** @override */
  decode(b, offset3) {
    if (void 0 === offset3) {
      offset3 = 0;
    }
    return this.layout.decode(b, offset3 + this.offset);
  }
  /** @override */
  encode(src2, b, offset3) {
    if (void 0 === offset3) {
      offset3 = 0;
    }
    return this.layout.encode(src2, b, offset3 + this.offset);
  }
};
var UInt = class extends Layout4 {
  constructor(span, property) {
    super(span, property);
    if (6 < this.span) {
      throw new RangeError("span must not exceed 6 bytes");
    }
  }
  /** @override */
  decode(b, offset3) {
    if (void 0 === offset3) {
      offset3 = 0;
    }
    return b.readUIntLE(offset3, this.span);
  }
  /** @override */
  encode(src2, b, offset3) {
    if (void 0 === offset3) {
      offset3 = 0;
    }
    b.writeUIntLE(src2, offset3, this.span);
    return this.span;
  }
};
var UIntBE = class extends Layout4 {
  constructor(span, property) {
    super(span, property);
    if (6 < this.span) {
      throw new RangeError("span must not exceed 6 bytes");
    }
  }
  /** @override */
  decode(b, offset3) {
    if (void 0 === offset3) {
      offset3 = 0;
    }
    return b.readUIntBE(offset3, this.span);
  }
  /** @override */
  encode(src2, b, offset3) {
    if (void 0 === offset3) {
      offset3 = 0;
    }
    b.writeUIntBE(src2, offset3, this.span);
    return this.span;
  }
};
var V2E32 = Math.pow(2, 32);
function divmodInt64(src2) {
  const hi32 = Math.floor(src2 / V2E32);
  const lo32 = src2 - hi32 * V2E32;
  return { hi32, lo32 };
}
function roundedInt64(hi32, lo32) {
  return hi32 * V2E32 + lo32;
}
var NearUInt64 = class extends Layout4 {
  constructor(property) {
    super(8, property);
  }
  /** @override */
  decode(b, offset3) {
    if (void 0 === offset3) {
      offset3 = 0;
    }
    const lo32 = b.readUInt32LE(offset3);
    const hi32 = b.readUInt32LE(offset3 + 4);
    return roundedInt64(hi32, lo32);
  }
  /** @override */
  encode(src2, b, offset3) {
    if (void 0 === offset3) {
      offset3 = 0;
    }
    const split6 = divmodInt64(src2);
    b.writeUInt32LE(split6.lo32, offset3);
    b.writeUInt32LE(split6.hi32, offset3 + 4);
    return 8;
  }
};
var NearInt64 = class extends Layout4 {
  constructor(property) {
    super(8, property);
  }
  /** @override */
  decode(b, offset3) {
    if (void 0 === offset3) {
      offset3 = 0;
    }
    const lo32 = b.readUInt32LE(offset3);
    const hi32 = b.readInt32LE(offset3 + 4);
    return roundedInt64(hi32, lo32);
  }
  /** @override */
  encode(src2, b, offset3) {
    if (void 0 === offset3) {
      offset3 = 0;
    }
    const split6 = divmodInt64(src2);
    b.writeUInt32LE(split6.lo32, offset3);
    b.writeInt32LE(split6.hi32, offset3 + 4);
    return 8;
  }
};
var Structure = class extends Layout4 {
  constructor(fields, property, decodePrefixes) {
    if (!(Array.isArray(fields) && fields.reduce((acc, v) => acc && v instanceof Layout4, true))) {
      throw new TypeError("fields must be array of Layout instances");
    }
    if ("boolean" === typeof property && void 0 === decodePrefixes) {
      decodePrefixes = property;
      property = void 0;
    }
    for (const fd of fields) {
      if (0 > fd.span && void 0 === fd.property) {
        throw new Error("fields cannot contain unnamed variable-length layout");
      }
    }
    let span = -1;
    try {
      span = fields.reduce((span2, fd) => span2 + fd.getSpan(), 0);
    } catch (e) {
    }
    super(span, property);
    this.fields = fields;
    this.decodePrefixes = !!decodePrefixes;
  }
  /** @override */
  getSpan(b, offset3) {
    if (0 <= this.span) {
      return this.span;
    }
    if (void 0 === offset3) {
      offset3 = 0;
    }
    let span = 0;
    try {
      span = this.fields.reduce((span2, fd) => {
        const fsp = fd.getSpan(b, offset3);
        offset3 += fsp;
        return span2 + fsp;
      }, 0);
    } catch (e) {
      throw new RangeError("indeterminate span");
    }
    return span;
  }
  /** @override */
  decode(b, offset3) {
    if (void 0 === offset3) {
      offset3 = 0;
    }
    const dest = this.makeDestinationObject();
    for (const fd of this.fields) {
      if (void 0 !== fd.property) {
        dest[fd.property] = fd.decode(b, offset3);
      }
      offset3 += fd.getSpan(b, offset3);
      if (this.decodePrefixes && b.length === offset3) {
        break;
      }
    }
    return dest;
  }
  /** Implement {@link Layout#encode|encode} for {@link Structure}.
   *
   * If `src` is missing a property for a member with a defined {@link
   * Layout#property|property} the corresponding region of the buffer is
   * left unmodified. */
  encode(src2, b, offset3) {
    if (void 0 === offset3) {
      offset3 = 0;
    }
    const firstOffset = offset3;
    let lastOffset = 0;
    let lastWrote = 0;
    for (const fd of this.fields) {
      let span = fd.span;
      lastWrote = 0 < span ? span : 0;
      if (void 0 !== fd.property) {
        const fv = src2[fd.property];
        if (void 0 !== fv) {
          lastWrote = fd.encode(fv, b, offset3);
          if (0 > span) {
            span = fd.getSpan(b, offset3);
          }
        }
      }
      lastOffset = offset3;
      offset3 += span;
    }
    return lastOffset + lastWrote - firstOffset;
  }
  /** @override */
  fromArray(values) {
    const dest = this.makeDestinationObject();
    for (const fd of this.fields) {
      if (void 0 !== fd.property && 0 < values.length) {
        dest[fd.property] = values.shift();
      }
    }
    return dest;
  }
  /**
   * Get access to the layout of a given property.
   *
   * @param {String} property - the structure member of interest.
   *
   * @return {Layout} - the layout associated with `property`, or
   * undefined if there is no such property.
   */
  layoutFor(property) {
    if ("string" !== typeof property) {
      throw new TypeError("property must be string");
    }
    for (const fd of this.fields) {
      if (fd.property === property) {
        return fd;
      }
    }
  }
  /**
   * Get the offset of a structure member.
   *
   * @param {String} property - the structure member of interest.
   *
   * @return {Number} - the offset in bytes to the start of `property`
   * within the structure, or undefined if `property` is not a field
   * within the structure.  If the property is a member but follows a
   * variable-length structure member a negative number will be
   * returned.
   */
  offsetOf(property) {
    if ("string" !== typeof property) {
      throw new TypeError("property must be string");
    }
    let offset3 = 0;
    for (const fd of this.fields) {
      if (fd.property === property) {
        return offset3;
      }
      if (0 > fd.span) {
        offset3 = -1;
      } else if (0 <= offset3) {
        offset3 += fd.span;
      }
    }
  }
};
var UnionDiscriminator = class {
  constructor(property) {
    this.property = property;
  }
  /** Analog to {@link Layout#decode|Layout decode} for union discriminators.
   *
   * The implementation of this method need not reference the buffer if
   * variant information is available through other means. */
  decode() {
    throw new Error("UnionDiscriminator is abstract");
  }
  /** Analog to {@link Layout#decode|Layout encode} for union discriminators.
   *
   * The implementation of this method need not store the value if
   * variant information is maintained through other means. */
  encode() {
    throw new Error("UnionDiscriminator is abstract");
  }
};
var UnionLayoutDiscriminator = class extends UnionDiscriminator {
  constructor(layout, property) {
    if (!(layout instanceof ExternalLayout && layout.isCount())) {
      throw new TypeError("layout must be an unsigned integer ExternalLayout");
    }
    super(property || layout.property || "variant");
    this.layout = layout;
  }
  /** Delegate decoding to {@link UnionLayoutDiscriminator#layout|layout}. */
  decode(b, offset3) {
    return this.layout.decode(b, offset3);
  }
  /** Delegate encoding to {@link UnionLayoutDiscriminator#layout|layout}. */
  encode(src2, b, offset3) {
    return this.layout.encode(src2, b, offset3);
  }
};
var Union = class extends Layout4 {
  constructor(discr, defaultLayout, property) {
    const upv = discr instanceof UInt || discr instanceof UIntBE;
    if (upv) {
      discr = new UnionLayoutDiscriminator(new OffsetLayout(discr));
    } else if (discr instanceof ExternalLayout && discr.isCount()) {
      discr = new UnionLayoutDiscriminator(discr);
    } else if (!(discr instanceof UnionDiscriminator)) {
      throw new TypeError("discr must be a UnionDiscriminator or an unsigned integer layout");
    }
    if (void 0 === defaultLayout) {
      defaultLayout = null;
    }
    if (!(null === defaultLayout || defaultLayout instanceof Layout4)) {
      throw new TypeError("defaultLayout must be null or a Layout");
    }
    if (null !== defaultLayout) {
      if (0 > defaultLayout.span) {
        throw new Error("defaultLayout must have constant span");
      }
      if (void 0 === defaultLayout.property) {
        defaultLayout = defaultLayout.replicate("content");
      }
    }
    let span = -1;
    if (defaultLayout) {
      span = defaultLayout.span;
      if (0 <= span && upv) {
        span += discr.layout.span;
      }
    }
    super(span, property);
    this.discriminator = discr;
    this.usesPrefixDiscriminator = upv;
    this.defaultLayout = defaultLayout;
    this.registry = {};
    let boundGetSourceVariant = this.defaultGetSourceVariant.bind(this);
    this.getSourceVariant = function(src2) {
      return boundGetSourceVariant(src2);
    };
    this.configGetSourceVariant = function(gsv) {
      boundGetSourceVariant = gsv.bind(this);
    };
  }
  /** @override */
  getSpan(b, offset3) {
    if (0 <= this.span) {
      return this.span;
    }
    if (void 0 === offset3) {
      offset3 = 0;
    }
    const vlo = this.getVariant(b, offset3);
    if (!vlo) {
      throw new Error("unable to determine span for unrecognized variant");
    }
    return vlo.getSpan(b, offset3);
  }
  /**
   * Method to infer a registered Union variant compatible with `src`.
   *
   * The first satisified rule in the following sequence defines the
   * return value:
   * * If `src` has properties matching the Union discriminator and
   *   the default layout, `undefined` is returned regardless of the
   *   value of the discriminator property (this ensures the default
   *   layout will be used);
   * * If `src` has a property matching the Union discriminator, the
   *   value of the discriminator identifies a registered variant, and
   *   either (a) the variant has no layout, or (b) `src` has the
   *   variant's property, then the variant is returned (because the
   *   source satisfies the constraints of the variant it identifies);
   * * If `src` does not have a property matching the Union
   *   discriminator, but does have a property matching a registered
   *   variant, then the variant is returned (because the source
   *   matches a variant without an explicit conflict);
   * * An error is thrown (because we either can't identify a variant,
   *   or we were explicitly told the variant but can't satisfy it).
   *
   * @param {Object} src - an object presumed to be compatible with
   * the content of the Union.
   *
   * @return {(undefined|VariantLayout)} - as described above.
   *
   * @throws {Error} - if `src` cannot be associated with a default or
   * registered variant.
   */
  defaultGetSourceVariant(src2) {
    if (src2.hasOwnProperty(this.discriminator.property)) {
      if (this.defaultLayout && src2.hasOwnProperty(this.defaultLayout.property)) {
        return void 0;
      }
      const vlo = this.registry[src2[this.discriminator.property]];
      if (vlo && (!vlo.layout || src2.hasOwnProperty(vlo.property))) {
        return vlo;
      }
    } else {
      for (const tag in this.registry) {
        const vlo = this.registry[tag];
        if (src2.hasOwnProperty(vlo.property)) {
          return vlo;
        }
      }
    }
    throw new Error("unable to infer src variant");
  }
  /** Implement {@link Layout#decode|decode} for {@link Union}.
   *
   * If the variant is {@link Union#addVariant|registered} the return
   * value is an instance of that variant, with no explicit
   * discriminator.  Otherwise the {@link Union#defaultLayout|default
   * layout} is used to decode the content. */
  decode(b, offset3) {
    if (void 0 === offset3) {
      offset3 = 0;
    }
    let dest;
    const dlo = this.discriminator;
    const discr = dlo.decode(b, offset3);
    let clo = this.registry[discr];
    if (void 0 === clo) {
      let contentOffset = 0;
      clo = this.defaultLayout;
      if (this.usesPrefixDiscriminator) {
        contentOffset = dlo.layout.span;
      }
      dest = this.makeDestinationObject();
      dest[dlo.property] = discr;
      dest[clo.property] = this.defaultLayout.decode(b, offset3 + contentOffset);
    } else {
      dest = clo.decode(b, offset3);
    }
    return dest;
  }
  /** Implement {@link Layout#encode|encode} for {@link Union}.
   *
   * This API assumes the `src` object is consistent with the union's
   * {@link Union#defaultLayout|default layout}.  To encode variants
   * use the appropriate variant-specific {@link VariantLayout#encode}
   * method. */
  encode(src2, b, offset3) {
    if (void 0 === offset3) {
      offset3 = 0;
    }
    const vlo = this.getSourceVariant(src2);
    if (void 0 === vlo) {
      const dlo = this.discriminator;
      const clo = this.defaultLayout;
      let contentOffset = 0;
      if (this.usesPrefixDiscriminator) {
        contentOffset = dlo.layout.span;
      }
      dlo.encode(src2[dlo.property], b, offset3);
      return contentOffset + clo.encode(
        src2[clo.property],
        b,
        offset3 + contentOffset
      );
    }
    return vlo.encode(src2, b, offset3);
  }
  /** Register a new variant structure within a union.  The newly
   * created variant is returned.
   *
   * @param {Number} variant - initializer for {@link
   * VariantLayout#variant|variant}.
   *
   * @param {Layout} layout - initializer for {@link
   * VariantLayout#layout|layout}.
   *
   * @param {String} property - initializer for {@link
   * Layout#property|property}.
   *
   * @return {VariantLayout} */
  addVariant(variant, layout, property) {
    const rv = new VariantLayout(this, variant, layout, property);
    this.registry[variant] = rv;
    return rv;
  }
  /**
   * Get the layout associated with a registered variant.
   *
   * If `vb` does not produce a registered variant the function returns
   * `undefined`.
   *
   * @param {(Number|Buffer)} vb - either the variant number, or a
   * buffer from which the discriminator is to be read.
   *
   * @param {Number} offset - offset into `vb` for the start of the
   * union.  Used only when `vb` is an instance of {Buffer}.
   *
   * @return {({VariantLayout}|undefined)}
   */
  getVariant(vb, offset3) {
    let variant = vb;
    if (Buffer.isBuffer(vb)) {
      if (void 0 === offset3) {
        offset3 = 0;
      }
      variant = this.discriminator.decode(vb, offset3);
    }
    return this.registry[variant];
  }
};
var VariantLayout = class extends Layout4 {
  constructor(union3, variant, layout, property) {
    if (!(union3 instanceof Union)) {
      throw new TypeError("union must be a Union");
    }
    if (!Number.isInteger(variant) || 0 > variant) {
      throw new TypeError("variant must be a (non-negative) integer");
    }
    if ("string" === typeof layout && void 0 === property) {
      property = layout;
      layout = null;
    }
    if (layout) {
      if (!(layout instanceof Layout4)) {
        throw new TypeError("layout must be a Layout");
      }
      if (null !== union3.defaultLayout && 0 <= layout.span && layout.span > union3.defaultLayout.span) {
        throw new Error("variant span exceeds span of containing union");
      }
      if ("string" !== typeof property) {
        throw new TypeError("variant must have a String property");
      }
    }
    let span = union3.span;
    if (0 > union3.span) {
      span = layout ? layout.span : 0;
      if (0 <= span && union3.usesPrefixDiscriminator) {
        span += union3.discriminator.layout.span;
      }
    }
    super(span, property);
    this.union = union3;
    this.variant = variant;
    this.layout = layout || null;
  }
  /** @override */
  getSpan(b, offset3) {
    if (0 <= this.span) {
      return this.span;
    }
    if (void 0 === offset3) {
      offset3 = 0;
    }
    let contentOffset = 0;
    if (this.union.usesPrefixDiscriminator) {
      contentOffset = this.union.discriminator.layout.span;
    }
    return contentOffset + this.layout.getSpan(b, offset3 + contentOffset);
  }
  /** @override */
  decode(b, offset3) {
    const dest = this.makeDestinationObject();
    if (void 0 === offset3) {
      offset3 = 0;
    }
    if (this !== this.union.getVariant(b, offset3)) {
      throw new Error("variant mismatch");
    }
    let contentOffset = 0;
    if (this.union.usesPrefixDiscriminator) {
      contentOffset = this.union.discriminator.layout.span;
    }
    if (this.layout) {
      dest[this.property] = this.layout.decode(b, offset3 + contentOffset);
    } else if (this.property) {
      dest[this.property] = true;
    } else if (this.union.usesPrefixDiscriminator) {
      dest[this.union.discriminator.property] = this.variant;
    }
    return dest;
  }
  /** @override */
  encode(src2, b, offset3) {
    if (void 0 === offset3) {
      offset3 = 0;
    }
    let contentOffset = 0;
    if (this.union.usesPrefixDiscriminator) {
      contentOffset = this.union.discriminator.layout.span;
    }
    if (this.layout && !src2.hasOwnProperty(this.property)) {
      throw new TypeError("variant lacks property " + this.property);
    }
    this.union.discriminator.encode(this.variant, b, offset3);
    let span = contentOffset;
    if (this.layout) {
      this.layout.encode(src2[this.property], b, offset3 + contentOffset);
      span += this.layout.getSpan(b, offset3 + contentOffset);
      if (0 <= this.union.span && span > this.union.span) {
        throw new Error("encoded variant overruns containing union");
      }
    }
    return span;
  }
  /** Delegate {@link Layout#fromArray|fromArray} to {@link
   * VariantLayout#layout|layout}. */
  fromArray(values) {
    if (this.layout) {
      return this.layout.fromArray(values);
    }
  }
};
var Blob$1 = class extends Layout4 {
  constructor(length2, property) {
    if (!(length2 instanceof ExternalLayout && length2.isCount() || Number.isInteger(length2) && 0 <= length2)) {
      throw new TypeError("length must be positive integer or an unsigned integer ExternalLayout");
    }
    let span = -1;
    if (!(length2 instanceof ExternalLayout)) {
      span = length2;
    }
    super(span, property);
    this.length = length2;
  }
  /** @override */
  getSpan(b, offset3) {
    let span = this.span;
    if (0 > span) {
      span = this.length.decode(b, offset3);
    }
    return span;
  }
  /** @override */
  decode(b, offset3) {
    if (void 0 === offset3) {
      offset3 = 0;
    }
    let span = this.span;
    if (0 > span) {
      span = this.length.decode(b, offset3);
    }
    return b.slice(offset3, offset3 + span);
  }
  /** Implement {@link Layout#encode|encode} for {@link Blob}.
   *
   * **NOTE** If {@link Layout#count|count} is an instance of {@link
   * ExternalLayout} then the length of `src` will be encoded as the
   * count after `src` is encoded. */
  encode(src2, b, offset3) {
    let span = this.length;
    if (this.length instanceof ExternalLayout) {
      span = src2.length;
    }
    if (!(Buffer.isBuffer(src2) && span === src2.length)) {
      throw new TypeError(nameWithProperty("Blob.encode", this) + " requires (length " + span + ") Buffer as src");
    }
    if (offset3 + span > b.length) {
      throw new RangeError("encoding overruns Buffer");
    }
    b.write(src2.toString("hex"), offset3, span, "hex");
    if (this.length instanceof ExternalLayout) {
      this.length.encode(span, b, offset3);
    }
    return span;
  }
};
var offset2 = ((layout, offset3, property) => new OffsetLayout(layout, offset3, property));
var u845 = ((property) => new UInt(1, property));
var u328 = ((property) => new UInt(4, property));
var nu642 = ((property) => new NearUInt64(property));
var ns643 = ((property) => new NearInt64(property));
var struct51 = ((fields, property, decodePrefixes) => new Structure(fields, property, decodePrefixes));
var union2 = ((discr, defaultLayout, property) => new Union(discr, defaultLayout, property));
var blob11 = ((length2, property) => new Blob$1(length2, property));
var RustStringLayout = class extends Layout_2 {
  constructor(property) {
    super(-1, property);
    this.property = property;
    this.layout = struct51([
      u328("length"),
      u328("lengthPadding"),
      blob11(offset2(u328(), -8), "chars")
    ], this.property);
  }
  encode(src2, b, offset3 = 0) {
    if (src2 === null || src2 === void 0) {
      return this.layout.span;
    }
    const data = {
      chars: Buffer.from(src2, "utf8")
    };
    return this.layout.encode(data, b, offset3);
  }
  decode(b, offset3 = 0) {
    const data = this.layout.decode(b, offset3);
    return data["chars"].toString();
  }
  getSpan(b, offset3 = 0) {
    return u328().span + u328().span + new import_bn2.default(new Uint8Array(b).slice(offset3, offset3 + 4), 10, "le").toNumber();
  }
};
function rustStringLayout(property) {
  return new RustStringLayout(property);
}
function publicKey$2(property) {
  return blob11(32, property);
}
var LAYOUT = union2(u328("instruction"));
LAYOUT.addVariant(0, struct51([
  ns643("lamports"),
  ns643("space"),
  publicKey$2("owner")
]), "createAccount");
LAYOUT.addVariant(1, struct51([publicKey$2("owner")]), "assign");
LAYOUT.addVariant(2, struct51([ns643("lamports")]), "transfer");
LAYOUT.addVariant(3, struct51([
  publicKey$2("base"),
  rustStringLayout("seed"),
  ns643("lamports"),
  ns643("space"),
  publicKey$2("owner")
]), "createAccountWithSeed");
LAYOUT.addVariant(4, struct51([publicKey$2("authorized")]), "advanceNonceAccount");
LAYOUT.addVariant(5, struct51([ns643("lamports")]), "withdrawNonceAccount");
LAYOUT.addVariant(6, struct51([publicKey$2("authorized")]), "initializeNonceAccount");
LAYOUT.addVariant(7, struct51([publicKey$2("authorized")]), "authorizeNonceAccount");
LAYOUT.addVariant(8, struct51([ns643("space")]), "allocate");
LAYOUT.addVariant(9, struct51([
  publicKey$2("base"),
  rustStringLayout("seed"),
  ns643("space"),
  publicKey$2("owner")
]), "allocateWithSeed");
LAYOUT.addVariant(10, struct51([
  publicKey$2("base"),
  rustStringLayout("seed"),
  publicKey$2("owner")
]), "assignWithSeed");
LAYOUT.addVariant(11, struct51([
  ns643("lamports"),
  rustStringLayout("seed"),
  publicKey$2("owner")
]), "transferWithSeed");
var instructionMaxSpan = Math.max(...Object.values(LAYOUT.registry).map((r) => r.span));
var WrappedLayout$1 = class extends Layout_2 {
  constructor(layout, decoder, encoder4, property) {
    super(layout.span, property);
    this.layout = layout;
    this.decoder = decoder;
    this.encoder = encoder4;
  }
  decode(b, offset3) {
    return this.decoder(this.layout.decode(b, offset3));
  }
  encode(src2, b, offset3) {
    return this.layout.encode(this.encoder(src2), b, offset3);
  }
  getSpan(b, offset3) {
    return this.layout.getSpan(b, offset3);
  }
};
function publicKey$1(property) {
  return new WrappedLayout$1(blob11(32), (b) => new PublicKey(b), (key) => key.toBuffer(), property);
}
var NONCE_ACCOUNT_LAYOUT = struct51([
  u328("version"),
  u328("state"),
  publicKey$1("authorizedPubkey"),
  publicKey$1("nonce"),
  struct51([nu642("lamportsPerSignature")], "feeCalculator")
]);
function hash(data) {
  return new TextDecoder().decode(sha2567(data));
}
var sha2568 = Object.freeze({
  __proto__: null,
  hash
});
function createWithSeedSync(fromPublicKey, seed2, programId) {
  const buffer3 = import_buffer3.Buffer.concat([
    fromPublicKey.toBuffer(),
    import_buffer3.Buffer.from(seed2),
    programId.toBuffer()
  ]);
  return new PublicKey(sha2567(buffer3));
}
function associated(programId, ...args) {
  let seeds = [import_buffer3.Buffer.from([97, 110, 99, 104, 111, 114])];
  args.forEach((arg) => {
    seeds.push(arg instanceof import_buffer3.Buffer ? arg : translateAddress(arg).toBuffer());
  });
  const [assoc] = PublicKey.findProgramAddressSync(seeds, translateAddress(programId));
  return assoc;
}
var pubkey = Object.freeze({
  __proto__: null,
  createWithSeedSync,
  associated
});
var TOKEN_PROGRAM_ID2 = new PublicKey("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA");
var ASSOCIATED_PROGRAM_ID = new PublicKey("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL");
function associatedAddress({ mint, owner }) {
  return PublicKey.findProgramAddressSync([owner.toBuffer(), TOKEN_PROGRAM_ID2.toBuffer(), mint.toBuffer()], ASSOCIATED_PROGRAM_ID)[0];
}
var token = Object.freeze({
  __proto__: null,
  TOKEN_PROGRAM_ID: TOKEN_PROGRAM_ID2,
  ASSOCIATED_PROGRAM_ID,
  associatedAddress
});
var browserPonyfill = { exports: {} };
(function(module2, exports2) {
  var global2 = typeof self !== "undefined" ? self : commonjsGlobal;
  var __self__ = (function() {
    function F() {
      this.fetch = false;
      this.DOMException = global2.DOMException;
    }
    F.prototype = global2;
    return new F();
  })();
  (function(self2) {
    (function(exports3) {
      var support = {
        searchParams: "URLSearchParams" in self2,
        iterable: "Symbol" in self2 && "iterator" in Symbol,
        blob: "FileReader" in self2 && "Blob" in self2 && (function() {
          try {
            new Blob();
            return true;
          } catch (e) {
            return false;
          }
        })(),
        formData: "FormData" in self2,
        arrayBuffer: "ArrayBuffer" in self2
      };
      function isDataView(obj) {
        return obj && DataView.prototype.isPrototypeOf(obj);
      }
      if (support.arrayBuffer) {
        var viewClasses = [
          "[object Int8Array]",
          "[object Uint8Array]",
          "[object Uint8ClampedArray]",
          "[object Int16Array]",
          "[object Uint16Array]",
          "[object Int32Array]",
          "[object Uint32Array]",
          "[object Float32Array]",
          "[object Float64Array]"
        ];
        var isArrayBufferView = ArrayBuffer.isView || function(obj) {
          return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
        };
      }
      function normalizeName(name) {
        if (typeof name !== "string") {
          name = String(name);
        }
        if (/[^a-z0-9\-#$%&'*+.^_`|~]/i.test(name)) {
          throw new TypeError("Invalid character in header field name");
        }
        return name.toLowerCase();
      }
      function normalizeValue(value) {
        if (typeof value !== "string") {
          value = String(value);
        }
        return value;
      }
      function iteratorFor(items) {
        var iterator = {
          next: function() {
            var value = items.shift();
            return { done: value === void 0, value };
          }
        };
        if (support.iterable) {
          iterator[Symbol.iterator] = function() {
            return iterator;
          };
        }
        return iterator;
      }
      function Headers2(headers) {
        this.map = {};
        if (headers instanceof Headers2) {
          headers.forEach(function(value, name) {
            this.append(name, value);
          }, this);
        } else if (Array.isArray(headers)) {
          headers.forEach(function(header) {
            this.append(header[0], header[1]);
          }, this);
        } else if (headers) {
          Object.getOwnPropertyNames(headers).forEach(function(name) {
            this.append(name, headers[name]);
          }, this);
        }
      }
      Headers2.prototype.append = function(name, value) {
        name = normalizeName(name);
        value = normalizeValue(value);
        var oldValue = this.map[name];
        this.map[name] = oldValue ? oldValue + ", " + value : value;
      };
      Headers2.prototype["delete"] = function(name) {
        delete this.map[normalizeName(name)];
      };
      Headers2.prototype.get = function(name) {
        name = normalizeName(name);
        return this.has(name) ? this.map[name] : null;
      };
      Headers2.prototype.has = function(name) {
        return this.map.hasOwnProperty(normalizeName(name));
      };
      Headers2.prototype.set = function(name, value) {
        this.map[normalizeName(name)] = normalizeValue(value);
      };
      Headers2.prototype.forEach = function(callback, thisArg) {
        for (var name in this.map) {
          if (this.map.hasOwnProperty(name)) {
            callback.call(thisArg, this.map[name], name, this);
          }
        }
      };
      Headers2.prototype.keys = function() {
        var items = [];
        this.forEach(function(value, name) {
          items.push(name);
        });
        return iteratorFor(items);
      };
      Headers2.prototype.values = function() {
        var items = [];
        this.forEach(function(value) {
          items.push(value);
        });
        return iteratorFor(items);
      };
      Headers2.prototype.entries = function() {
        var items = [];
        this.forEach(function(value, name) {
          items.push([name, value]);
        });
        return iteratorFor(items);
      };
      if (support.iterable) {
        Headers2.prototype[Symbol.iterator] = Headers2.prototype.entries;
      }
      function consumed(body) {
        if (body.bodyUsed) {
          return Promise.reject(new TypeError("Already read"));
        }
        body.bodyUsed = true;
      }
      function fileReaderReady(reader) {
        return new Promise(function(resolve2, reject2) {
          reader.onload = function() {
            resolve2(reader.result);
          };
          reader.onerror = function() {
            reject2(reader.error);
          };
        });
      }
      function readBlobAsArrayBuffer(blob12) {
        var reader = new FileReader();
        var promise = fileReaderReady(reader);
        reader.readAsArrayBuffer(blob12);
        return promise;
      }
      function readBlobAsText(blob12) {
        var reader = new FileReader();
        var promise = fileReaderReady(reader);
        reader.readAsText(blob12);
        return promise;
      }
      function readArrayBufferAsText(buf) {
        var view = new Uint8Array(buf);
        var chars = new Array(view.length);
        for (var i = 0; i < view.length; i++) {
          chars[i] = String.fromCharCode(view[i]);
        }
        return chars.join("");
      }
      function bufferClone(buf) {
        if (buf.slice) {
          return buf.slice(0);
        } else {
          var view = new Uint8Array(buf.byteLength);
          view.set(new Uint8Array(buf));
          return view.buffer;
        }
      }
      function Body() {
        this.bodyUsed = false;
        this._initBody = function(body) {
          this._bodyInit = body;
          if (!body) {
            this._bodyText = "";
          } else if (typeof body === "string") {
            this._bodyText = body;
          } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
            this._bodyBlob = body;
          } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
            this._bodyFormData = body;
          } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
            this._bodyText = body.toString();
          } else if (support.arrayBuffer && support.blob && isDataView(body)) {
            this._bodyArrayBuffer = bufferClone(body.buffer);
            this._bodyInit = new Blob([this._bodyArrayBuffer]);
          } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
            this._bodyArrayBuffer = bufferClone(body);
          } else {
            this._bodyText = body = Object.prototype.toString.call(body);
          }
          if (!this.headers.get("content-type")) {
            if (typeof body === "string") {
              this.headers.set("content-type", "text/plain;charset=UTF-8");
            } else if (this._bodyBlob && this._bodyBlob.type) {
              this.headers.set("content-type", this._bodyBlob.type);
            } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
              this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8");
            }
          }
        };
        if (support.blob) {
          this.blob = function() {
            var rejected = consumed(this);
            if (rejected) {
              return rejected;
            }
            if (this._bodyBlob) {
              return Promise.resolve(this._bodyBlob);
            } else if (this._bodyArrayBuffer) {
              return Promise.resolve(new Blob([this._bodyArrayBuffer]));
            } else if (this._bodyFormData) {
              throw new Error("could not read FormData body as blob");
            } else {
              return Promise.resolve(new Blob([this._bodyText]));
            }
          };
          this.arrayBuffer = function() {
            if (this._bodyArrayBuffer) {
              return consumed(this) || Promise.resolve(this._bodyArrayBuffer);
            } else {
              return this.blob().then(readBlobAsArrayBuffer);
            }
          };
        }
        this.text = function() {
          var rejected = consumed(this);
          if (rejected) {
            return rejected;
          }
          if (this._bodyBlob) {
            return readBlobAsText(this._bodyBlob);
          } else if (this._bodyArrayBuffer) {
            return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
          } else if (this._bodyFormData) {
            throw new Error("could not read FormData body as text");
          } else {
            return Promise.resolve(this._bodyText);
          }
        };
        if (support.formData) {
          this.formData = function() {
            return this.text().then(decode4);
          };
        }
        this.json = function() {
          return this.text().then(JSON.parse);
        };
        return this;
      }
      var methods = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];
      function normalizeMethod(method) {
        var upcased = method.toUpperCase();
        return methods.indexOf(upcased) > -1 ? upcased : method;
      }
      function Request2(input, options) {
        options = options || {};
        var body = options.body;
        if (input instanceof Request2) {
          if (input.bodyUsed) {
            throw new TypeError("Already read");
          }
          this.url = input.url;
          this.credentials = input.credentials;
          if (!options.headers) {
            this.headers = new Headers2(input.headers);
          }
          this.method = input.method;
          this.mode = input.mode;
          this.signal = input.signal;
          if (!body && input._bodyInit != null) {
            body = input._bodyInit;
            input.bodyUsed = true;
          }
        } else {
          this.url = String(input);
        }
        this.credentials = options.credentials || this.credentials || "same-origin";
        if (options.headers || !this.headers) {
          this.headers = new Headers2(options.headers);
        }
        this.method = normalizeMethod(options.method || this.method || "GET");
        this.mode = options.mode || this.mode || null;
        this.signal = options.signal || this.signal;
        this.referrer = null;
        if ((this.method === "GET" || this.method === "HEAD") && body) {
          throw new TypeError("Body not allowed for GET or HEAD requests");
        }
        this._initBody(body);
      }
      Request2.prototype.clone = function() {
        return new Request2(this, { body: this._bodyInit });
      };
      function decode4(body) {
        var form = new FormData();
        body.trim().split("&").forEach(function(bytes3) {
          if (bytes3) {
            var split6 = bytes3.split("=");
            var name = split6.shift().replace(/\+/g, " ");
            var value = split6.join("=").replace(/\+/g, " ");
            form.append(decodeURIComponent(name), decodeURIComponent(value));
          }
        });
        return form;
      }
      function parseHeaders(rawHeaders) {
        var headers = new Headers2();
        var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, " ");
        preProcessedHeaders.split(/\r?\n/).forEach(function(line) {
          var parts = line.split(":");
          var key = parts.shift().trim();
          if (key) {
            var value = parts.join(":").trim();
            headers.append(key, value);
          }
        });
        return headers;
      }
      Body.call(Request2.prototype);
      function Response(bodyInit, options) {
        if (!options) {
          options = {};
        }
        this.type = "default";
        this.status = options.status === void 0 ? 200 : options.status;
        this.ok = this.status >= 200 && this.status < 300;
        this.statusText = "statusText" in options ? options.statusText : "OK";
        this.headers = new Headers2(options.headers);
        this.url = options.url || "";
        this._initBody(bodyInit);
      }
      Body.call(Response.prototype);
      Response.prototype.clone = function() {
        return new Response(this._bodyInit, {
          status: this.status,
          statusText: this.statusText,
          headers: new Headers2(this.headers),
          url: this.url
        });
      };
      Response.error = function() {
        var response = new Response(null, { status: 0, statusText: "" });
        response.type = "error";
        return response;
      };
      var redirectStatuses = [301, 302, 303, 307, 308];
      Response.redirect = function(url, status) {
        if (redirectStatuses.indexOf(status) === -1) {
          throw new RangeError("Invalid status code");
        }
        return new Response(null, { status, headers: { location: url } });
      };
      exports3.DOMException = self2.DOMException;
      try {
        new exports3.DOMException();
      } catch (err2) {
        exports3.DOMException = function(message, name) {
          this.message = message;
          this.name = name;
          var error = Error(message);
          this.stack = error.stack;
        };
        exports3.DOMException.prototype = Object.create(Error.prototype);
        exports3.DOMException.prototype.constructor = exports3.DOMException;
      }
      function fetch3(input, init) {
        return new Promise(function(resolve2, reject2) {
          var request = new Request2(input, init);
          if (request.signal && request.signal.aborted) {
            return reject2(new exports3.DOMException("Aborted", "AbortError"));
          }
          var xhr = new XMLHttpRequest();
          function abortXhr() {
            xhr.abort();
          }
          xhr.onload = function() {
            var options = {
              status: xhr.status,
              statusText: xhr.statusText,
              headers: parseHeaders(xhr.getAllResponseHeaders() || "")
            };
            options.url = "responseURL" in xhr ? xhr.responseURL : options.headers.get("X-Request-URL");
            var body = "response" in xhr ? xhr.response : xhr.responseText;
            resolve2(new Response(body, options));
          };
          xhr.onerror = function() {
            reject2(new TypeError("Network request failed"));
          };
          xhr.ontimeout = function() {
            reject2(new TypeError("Network request failed"));
          };
          xhr.onabort = function() {
            reject2(new exports3.DOMException("Aborted", "AbortError"));
          };
          xhr.open(request.method, request.url, true);
          if (request.credentials === "include") {
            xhr.withCredentials = true;
          } else if (request.credentials === "omit") {
            xhr.withCredentials = false;
          }
          if ("responseType" in xhr && support.blob) {
            xhr.responseType = "blob";
          }
          request.headers.forEach(function(value, name) {
            xhr.setRequestHeader(name, value);
          });
          if (request.signal) {
            request.signal.addEventListener("abort", abortXhr);
            xhr.onreadystatechange = function() {
              if (xhr.readyState === 4) {
                request.signal.removeEventListener("abort", abortXhr);
              }
            };
          }
          xhr.send(typeof request._bodyInit === "undefined" ? null : request._bodyInit);
        });
      }
      fetch3.polyfill = true;
      if (!self2.fetch) {
        self2.fetch = fetch3;
        self2.Headers = Headers2;
        self2.Request = Request2;
        self2.Response = Response;
      }
      exports3.Headers = Headers2;
      exports3.Request = Request2;
      exports3.Response = Response;
      exports3.fetch = fetch3;
      Object.defineProperty(exports3, "__esModule", { value: true });
      return exports3;
    })({});
  })(__self__);
  __self__.fetch.ponyfill = true;
  delete __self__.fetch.polyfill;
  var ctx = __self__;
  exports2 = ctx.fetch;
  exports2.default = ctx.fetch;
  exports2.fetch = ctx.fetch;
  exports2.Headers = ctx.Headers;
  exports2.Request = ctx.Request;
  exports2.Response = ctx.Response;
  module2.exports = exports2;
})(browserPonyfill, browserPonyfill.exports);
var fetch2 = getDefaultExportFromCjs2(browserPonyfill.exports);
async function verifiedBuild(connection, programId, limit = 5) {
  const url = `https://api.apr.dev/api/v0/program/${programId.toString()}/latest?limit=${limit}`;
  const [programData, latestBuildsResp] = await Promise.all([
    fetchData(connection, programId),
    fetch2(url)
  ]);
  const latestBuilds = (await latestBuildsResp.json()).filter((b) => !b.aborted && b.state === "Built" && b.verified === "Verified");
  if (latestBuilds.length === 0) {
    return null;
  }
  const build = latestBuilds[0];
  if (programData.slot.toNumber() !== build.verified_slot) {
    return null;
  }
  return build;
}
async function fetchData(connection, programId) {
  const accountInfo = await connection.getAccountInfo(programId);
  if (accountInfo === null) {
    throw new Error("program account not found");
  }
  const { program } = decodeUpgradeableLoaderState(accountInfo.data);
  const programdataAccountInfo = await connection.getAccountInfo(program.programdataAddress);
  if (programdataAccountInfo === null) {
    throw new Error("program data account not found");
  }
  const { programData } = decodeUpgradeableLoaderState(programdataAccountInfo.data);
  return programData;
}
var UPGRADEABLE_LOADER_STATE_LAYOUT = borsh.rustEnum([
  borsh.struct([], "uninitialized"),
  borsh.struct([borsh.option(borsh.publicKey(), "authorityAddress")], "buffer"),
  borsh.struct([borsh.publicKey("programdataAddress")], "program"),
  borsh.struct([
    borsh.u64("slot"),
    borsh.option(borsh.publicKey(), "upgradeAuthorityAddress")
  ], "programData")
], void 0, borsh.u32());
function decodeUpgradeableLoaderState(data) {
  return UPGRADEABLE_LOADER_STATE_LAYOUT.decode(data);
}
var registry = Object.freeze({
  __proto__: null,
  verifiedBuild,
  fetchData,
  decodeUpgradeableLoaderState
});
var index2 = Object.freeze({
  __proto__: null,
  sha256: sha2568,
  rpc: rpc2,
  publicKey: pubkey,
  bytes: index$1,
  token,
  features,
  registry
});
function isIdlAccounts(accountItem) {
  return "accounts" in accountItem;
}
async function idlAddress(programId) {
  const base3 = (await PublicKey.findProgramAddress([], programId))[0];
  return await PublicKey.createWithSeed(base3, seed(), programId);
}
function seed() {
  return "anchor:idl";
}
var IDL_ACCOUNT_LAYOUT = borsh.struct([
  borsh.publicKey("authority"),
  borsh.vecU8("data")
]);
function decodeIdlAccount(data) {
  return IDL_ACCOUNT_LAYOUT.decode(data);
}
function splitArgsAndCtx(idlIx, args) {
  var _a2, _b;
  let options = {};
  const inputLen = idlIx.args ? idlIx.args.length : 0;
  if (args.length > inputLen) {
    if (args.length !== inputLen + 1) {
      throw new Error(`provided too many arguments ${args} to instruction ${idlIx === null || idlIx === void 0 ? void 0 : idlIx.name} expecting: ${(_b = (_a2 = idlIx.args) === null || _a2 === void 0 ? void 0 : _a2.map((a) => a.name)) !== null && _b !== void 0 ? _b : []}`);
    }
    options = args.pop();
  }
  return [args, options];
}
var InstructionNamespaceFactory = class _InstructionNamespaceFactory {
  static build(idlIx, encodeFn, programId) {
    if (idlIx.name === "_inner") {
      throw new IdlError("the _inner name is reserved");
    }
    const ix = (...args) => {
      const [ixArgs, ctx] = splitArgsAndCtx(idlIx, [...args]);
      validateAccounts(idlIx.accounts, ctx.accounts);
      validateInstruction(idlIx, ...args);
      const keys = ix.accounts(ctx.accounts);
      if (ctx.remainingAccounts !== void 0) {
        keys.push(...ctx.remainingAccounts);
      }
      if (isSet("debug-logs")) {
        console.log("Outgoing account metas:", keys);
      }
      return new TransactionInstruction({
        keys,
        programId,
        data: encodeFn(idlIx.name, toInstruction(idlIx, ...ixArgs))
      });
    };
    ix["accounts"] = (accs) => {
      return _InstructionNamespaceFactory.accountsArray(accs, idlIx.accounts, programId, idlIx.name);
    };
    return ix;
  }
  static accountsArray(ctx, accounts, programId, ixName) {
    if (!ctx) {
      return [];
    }
    return accounts.map((acc) => {
      const nestedAccounts = "accounts" in acc ? acc.accounts : void 0;
      if (nestedAccounts !== void 0) {
        const rpcAccs = ctx[acc.name];
        return _InstructionNamespaceFactory.accountsArray(rpcAccs, acc.accounts, programId, ixName).flat();
      } else {
        const account = acc;
        let pubkey2;
        try {
          pubkey2 = translateAddress(ctx[acc.name]);
        } catch (err2) {
          throw new Error(`Wrong input type for account "${acc.name}" in the instruction accounts object${ixName !== void 0 ? ' for instruction "' + ixName + '"' : ""}. Expected PublicKey or string.`);
        }
        const optional3 = account.isOptional && pubkey2.equals(programId);
        const isWritable = account.isMut && !optional3;
        const isSigner = account.isSigner && !optional3;
        return {
          pubkey: pubkey2,
          isWritable,
          isSigner
        };
      }
    }).flat();
  }
};
function validateInstruction(ix, ...args) {
}
var TransactionFactory = class {
  static build(idlIx, ixFn) {
    const txFn = (...args) => {
      var _a2, _b, _c;
      const [, ctx] = splitArgsAndCtx(idlIx, [...args]);
      const tx = new Transaction();
      if (ctx.preInstructions && ctx.instructions) {
        throw new Error("instructions is deprecated, use preInstructions");
      }
      (_a2 = ctx.preInstructions) === null || _a2 === void 0 ? void 0 : _a2.forEach((ix) => tx.add(ix));
      (_b = ctx.instructions) === null || _b === void 0 ? void 0 : _b.forEach((ix) => tx.add(ix));
      tx.add(ixFn(...args));
      (_c = ctx.postInstructions) === null || _c === void 0 ? void 0 : _c.forEach((ix) => tx.add(ix));
      return tx;
    };
    return txFn;
  }
};
var RpcFactory = class {
  static build(idlIx, txFn, idlErrors, provider) {
    const rpc3 = async (...args) => {
      var _a2;
      const tx = txFn(...args);
      const [, ctx] = splitArgsAndCtx(idlIx, [...args]);
      if (provider.sendAndConfirm === void 0) {
        throw new Error("This function requires 'Provider.sendAndConfirm' to be implemented.");
      }
      try {
        return await provider.sendAndConfirm(tx, (_a2 = ctx.signers) !== null && _a2 !== void 0 ? _a2 : [], ctx.options);
      } catch (err2) {
        throw translateError(err2, idlErrors);
      }
    };
    return rpc3;
  }
};
var AccountFactory = class {
  static build(idl, coder, programId, provider) {
    var _a2;
    const accountFns = {};
    (_a2 = idl.accounts) === null || _a2 === void 0 ? void 0 : _a2.forEach((idlAccount) => {
      const name = (0, import_camelcase.default)(idlAccount.name);
      accountFns[name] = new AccountClient(idl, idlAccount, programId, provider, coder);
    });
    return accountFns;
  }
};
var AccountClient = class {
  /**
   * Returns the number of bytes in this account.
   */
  get size() {
    return this._size;
  }
  /**
   * Returns the program ID owning all accounts.
   */
  get programId() {
    return this._programId;
  }
  /**
   * Returns the client's wallet and network provider.
   */
  get provider() {
    return this._provider;
  }
  /**
   * Returns the coder.
   */
  get coder() {
    return this._coder;
  }
  /**
   * Returns the idl account.
   */
  get idlAccount() {
    return this._idlAccount;
  }
  constructor(idl, idlAccount, programId, provider, coder) {
    this._idlAccount = idlAccount;
    this._programId = programId;
    this._provider = provider !== null && provider !== void 0 ? provider : getProvider();
    this._coder = coder !== null && coder !== void 0 ? coder : new BorshCoder(idl);
    this._size = this._coder.accounts.size(idlAccount);
  }
  /**
   * Returns a deserialized account, returning null if it doesn't exist.
   *
   * @param address The address of the account to fetch.
   */
  async fetchNullable(address, commitment) {
    const { data } = await this.fetchNullableAndContext(address, commitment);
    return data;
  }
  /**
   * Returns a deserialized account along with the associated rpc response context, returning null if it doesn't exist.
   *
   * @param address The address of the account to fetch.
   */
  async fetchNullableAndContext(address, commitment) {
    const accountInfo = await this.getAccountInfoAndContext(address, commitment);
    const { value, context } = accountInfo;
    return {
      data: value && value.data.length !== 0 ? this._coder.accounts.decode(this._idlAccount.name, value.data) : null,
      context
    };
  }
  /**
   * Returns a deserialized account.
   *
   * @param address The address of the account to fetch.
   */
  async fetch(address, commitment) {
    const { data } = await this.fetchNullableAndContext(address, commitment);
    if (data === null) {
      throw new Error(`Account does not exist or has no data ${address.toString()}`);
    }
    return data;
  }
  /**
   * Returns a deserialized account along with the associated rpc response context.
   *
   * @param address The address of the account to fetch.
   */
  async fetchAndContext(address, commitment) {
    const { data, context } = await this.fetchNullableAndContext(address, commitment);
    if (data === null) {
      throw new Error(`Account does not exist ${address.toString()}`);
    }
    return { data, context };
  }
  /**
   * Returns multiple deserialized accounts.
   * Accounts not found or with wrong discriminator are returned as null.
   *
   * @param addresses The addresses of the accounts to fetch.
   */
  async fetchMultiple(addresses, commitment) {
    const accounts = await this.fetchMultipleAndContext(addresses, commitment);
    return accounts.map((account) => account ? account.data : null);
  }
  /**
   * Returns multiple deserialized accounts.
   * Accounts not found or with wrong discriminator are returned as null.
   *
   * @param addresses The addresses of the accounts to fetch.
   */
  async fetchMultipleAndContext(addresses, commitment) {
    const accounts = await getMultipleAccountsAndContext(this._provider.connection, addresses.map((address) => translateAddress(address)), commitment);
    return accounts.map((result) => {
      if (result == null) {
        return null;
      }
      const { account, context } = result;
      return {
        data: this._coder.accounts.decode(this._idlAccount.name, account.data),
        context
      };
    });
  }
  /**
   * Returns all instances of this account type for the program.
   *
   * @param filters User-provided filters to narrow the results from `connection.getProgramAccounts`.
   *
   *                When filters are not defined this method returns all
   *                the account instances.
   *
   *                When filters are of type `Buffer`, the filters are appended
   *                after the discriminator.
   *
   *                When filters are of type `GetProgramAccountsFilter[]`,
   *                filters are appended after the discriminator filter.
   */
  async all(filters) {
    const filter = this.coder.accounts.memcmp(this._idlAccount.name, filters instanceof Buffer ? filters : void 0);
    const coderFilters = [];
    if ((filter === null || filter === void 0 ? void 0 : filter.offset) != void 0 && (filter === null || filter === void 0 ? void 0 : filter.bytes) != void 0) {
      coderFilters.push({
        memcmp: { offset: filter.offset, bytes: filter.bytes }
      });
    }
    if ((filter === null || filter === void 0 ? void 0 : filter.dataSize) != void 0) {
      coderFilters.push({ dataSize: filter.dataSize });
    }
    let resp = await this._provider.connection.getProgramAccounts(this._programId, {
      commitment: this._provider.connection.commitment,
      filters: [...coderFilters, ...Array.isArray(filters) ? filters : []]
    });
    return resp.map(({ pubkey: pubkey2, account }) => {
      return {
        publicKey: pubkey2,
        account: this._coder.accounts.decode(this._idlAccount.name, account.data)
      };
    });
  }
  /**
   * Returns an `EventEmitter` emitting a "change" event whenever the account
   * changes.
   */
  subscribe(address, commitment) {
    const sub = subscriptions.get(address.toString());
    if (sub) {
      return sub.ee;
    }
    const ee = new import_eventemitter32.default();
    address = translateAddress(address);
    const listener = this._provider.connection.onAccountChange(address, (acc) => {
      const account = this._coder.accounts.decode(this._idlAccount.name, acc.data);
      ee.emit("change", account);
    }, commitment);
    subscriptions.set(address.toString(), {
      ee,
      listener
    });
    return ee;
  }
  /**
   * Unsubscribes from the account at the given address.
   */
  async unsubscribe(address) {
    let sub = subscriptions.get(address.toString());
    if (!sub) {
      console.warn("Address is not subscribed");
      return;
    }
    if (subscriptions) {
      await this._provider.connection.removeAccountChangeListener(sub.listener).then(() => {
        subscriptions.delete(address.toString());
      }).catch(console.error);
    }
  }
  /**
   * Returns an instruction for creating this account.
   */
  async createInstruction(signer, sizeOverride) {
    const size4 = this.size;
    if (this._provider.publicKey === void 0) {
      throw new Error("This function requires the Provider interface implementor to have a 'publicKey' field.");
    }
    return SystemProgram.createAccount({
      fromPubkey: this._provider.publicKey,
      newAccountPubkey: signer.publicKey,
      space: sizeOverride !== null && sizeOverride !== void 0 ? sizeOverride : size4,
      lamports: await this._provider.connection.getMinimumBalanceForRentExemption(sizeOverride !== null && sizeOverride !== void 0 ? sizeOverride : size4),
      programId: this._programId
    });
  }
  /**
   * @deprecated since version 14.0.
   *
   * Function returning the associated account. Args are keys to associate.
   * Order matters.
   */
  async associated(...args) {
    const addr = await this.associatedAddress(...args);
    return await this.fetch(addr);
  }
  /**
   * @deprecated since version 14.0.
   *
   * Function returning the associated address. Args are keys to associate.
   * Order matters.
   */
  async associatedAddress(...args) {
    return await associated(this._programId, ...args);
  }
  async getAccountInfo(address, commitment) {
    return await this._provider.connection.getAccountInfo(translateAddress(address), commitment);
  }
  async getAccountInfoAndContext(address, commitment) {
    return await this._provider.connection.getAccountInfoAndContext(translateAddress(address), commitment);
  }
};
var subscriptions = /* @__PURE__ */ new Map();
var PROGRAM_LOG = "Program log: ";
var PROGRAM_DATA = "Program data: ";
var PROGRAM_LOG_START_INDEX = PROGRAM_LOG.length;
var PROGRAM_DATA_START_INDEX = PROGRAM_DATA.length;
var EventManager = class {
  constructor(programId, provider, coder) {
    this._programId = programId;
    this._provider = provider;
    this._eventParser = new EventParser(programId, coder);
    this._eventCallbacks = /* @__PURE__ */ new Map();
    this._eventListeners = /* @__PURE__ */ new Map();
    this._listenerIdCount = 0;
  }
  addEventListener(eventName, callback) {
    var _a2;
    let listener = this._listenerIdCount;
    this._listenerIdCount += 1;
    if (!this._eventListeners.has(eventName)) {
      this._eventListeners.set(eventName, []);
    }
    this._eventListeners.set(eventName, ((_a2 = this._eventListeners.get(eventName)) !== null && _a2 !== void 0 ? _a2 : []).concat(listener));
    this._eventCallbacks.set(listener, [eventName, callback]);
    if (this._onLogsSubscriptionId !== void 0) {
      return listener;
    }
    this._onLogsSubscriptionId = this._provider.connection.onLogs(this._programId, (logs, ctx) => {
      if (logs.err) {
        return;
      }
      for (const event of this._eventParser.parseLogs(logs.logs)) {
        const allListeners = this._eventListeners.get(event.name);
        if (allListeners) {
          allListeners.forEach((listener2) => {
            const listenerCb = this._eventCallbacks.get(listener2);
            if (listenerCb) {
              const [, callback2] = listenerCb;
              callback2(event.data, ctx.slot, logs.signature);
            }
          });
        }
      }
    });
    return listener;
  }
  async removeEventListener(listener) {
    const callback = this._eventCallbacks.get(listener);
    if (!callback) {
      throw new Error(`Event listener ${listener} doesn't exist!`);
    }
    const [eventName] = callback;
    let listeners = this._eventListeners.get(eventName);
    if (!listeners) {
      throw new Error(`Event listeners don't exist for ${eventName}!`);
    }
    this._eventCallbacks.delete(listener);
    listeners = listeners.filter((l) => l !== listener);
    this._eventListeners.set(eventName, listeners);
    if (listeners.length === 0) {
      this._eventListeners.delete(eventName);
    }
    if (this._eventCallbacks.size === 0) {
      if (this._eventListeners.size !== 0) {
        throw new Error(`Expected event listeners size to be 0 but got ${this._eventListeners.size}`);
      }
      if (this._onLogsSubscriptionId !== void 0) {
        await this._provider.connection.removeOnLogsListener(this._onLogsSubscriptionId);
        this._onLogsSubscriptionId = void 0;
      }
    }
  }
};
var EventParser = class {
  constructor(programId, coder) {
    this.coder = coder;
    this.programId = programId;
  }
  // Each log given, represents an array of messages emitted by
  // a single transaction, which can execute many different programs across
  // CPI boundaries. However, the subscription is only interested in the
  // events emitted by *this* program. In achieving this, we keep track of the
  // program execution context by parsing each log and looking for a CPI
  // `invoke` call. If one exists, we know a new program is executing. So we
  // push the programId onto a stack and switch the program context. This
  // allows us to track, for a given log, which program was executing during
  // its emission, thereby allowing us to know if a given log event was
  // emitted by *this* program. If it was, then we parse the raw string and
  // emit the event if the string matches the event being subscribed to.
  *parseLogs(logs, errorOnDecodeFailure = false) {
    const logScanner = new LogScanner(logs);
    const execution = new ExecutionContext();
    let log = logScanner.next();
    while (log !== null) {
      let [event, newProgram, didPop] = this.handleLog(execution, log, errorOnDecodeFailure);
      if (event) {
        yield event;
      }
      if (newProgram) {
        execution.push(newProgram);
      }
      if (didPop) {
        execution.pop();
      }
      log = logScanner.next();
    }
  }
  // Main log handler. Returns a three element array of the event, the
  // next program that was invoked for CPI, and a boolean indicating if
  // a program has completed execution (and thus should be popped off the
  // execution stack).
  handleLog(execution, log, errorOnDecodeFailure) {
    if (execution.stack.length > 0 && execution.program() === this.programId.toString()) {
      return this.handleProgramLog(log, errorOnDecodeFailure);
    } else {
      return [null, ...this.handleSystemLog(log)];
    }
  }
  // Handles logs from *this* program.
  handleProgramLog(log, errorOnDecodeFailure) {
    if (log.startsWith(PROGRAM_LOG) || log.startsWith(PROGRAM_DATA)) {
      const logStr = log.startsWith(PROGRAM_LOG) ? log.slice(PROGRAM_LOG_START_INDEX) : log.slice(PROGRAM_DATA_START_INDEX);
      const event = this.coder.events.decode(logStr);
      if (errorOnDecodeFailure && event === null) {
        throw new Error(`Unable to decode event ${logStr}`);
      }
      return [event, null, false];
    } else {
      return [null, ...this.handleSystemLog(log)];
    }
  }
  // Handles logs when the current program being executing is *not* this.
  handleSystemLog(log) {
    const logStart = log.split(":")[0];
    if (logStart.match(/^Program (.*) success/g) !== null) {
      return [null, true];
    } else if (logStart.startsWith(`Program ${this.programId.toString()} invoke`)) {
      return [this.programId.toString(), false];
    } else if (logStart.includes("invoke")) {
      return ["cpi", false];
    } else {
      return [null, false];
    }
  }
};
var ExecutionContext = class {
  constructor() {
    this.stack = [];
  }
  program() {
    if (!this.stack.length) {
      throw new Error("Expected the stack to have elements");
    }
    return this.stack[this.stack.length - 1];
  }
  push(newProgram) {
    this.stack.push(newProgram);
  }
  pop() {
    if (!this.stack.length) {
      throw new Error("Expected the stack to have elements");
    }
    this.stack.pop();
  }
};
var LogScanner = class {
  constructor(logs) {
    this.logs = logs;
  }
  next() {
    if (this.logs.length === 0) {
      return null;
    }
    let l = this.logs[0];
    this.logs = this.logs.slice(1);
    return l;
  }
};
var SimulateFactory = class {
  static build(idlIx, txFn, idlErrors, provider, coder, programId, idl) {
    const simulate = async (...args) => {
      var _a2;
      const tx = txFn(...args);
      const [, ctx] = splitArgsAndCtx(idlIx, [...args]);
      let resp = void 0;
      if (provider.simulate === void 0) {
        throw new Error("This function requires 'Provider.simulate' to be implemented.");
      }
      try {
        resp = await provider.simulate(tx, ctx.signers, (_a2 = ctx.options) === null || _a2 === void 0 ? void 0 : _a2.commitment);
      } catch (err2) {
        throw translateError(err2, idlErrors);
      }
      if (resp === void 0) {
        throw new Error("Unable to simulate transaction");
      }
      const logs = resp.logs;
      if (!logs) {
        throw new Error("Simulated logs not found");
      }
      const events2 = [];
      if (idl.events) {
        let parser = new EventParser(programId, coder);
        for (const event of parser.parseLogs(logs)) {
          events2.push(event);
        }
      }
      return { events: events2, raw: logs };
    };
    return simulate;
  }
};
function uint64(property) {
  return new WrappedLayout(blob11(8), (b) => u644.fromBuffer(b), (n) => n.toBuffer(), property);
}
function publicKey4(property) {
  return new WrappedLayout(blob11(32), (b) => new PublicKey(b), (key) => key.toBuffer(), property);
}
function coption(layout, property) {
  return new COptionLayout(layout, property);
}
var WrappedLayout = class extends Layout_2 {
  constructor(layout, decoder, encoder4, property) {
    super(layout.span, property);
    this.layout = layout;
    this.decoder = decoder;
    this.encoder = encoder4;
  }
  decode(b, offset3) {
    return this.decoder(this.layout.decode(b, offset3));
  }
  encode(src2, b, offset3) {
    return this.layout.encode(this.encoder(src2), b, offset3);
  }
  getSpan(b, offset3) {
    return this.layout.getSpan(b, offset3);
  }
};
var COptionLayout = class extends Layout_2 {
  constructor(layout, property) {
    super(-1, property);
    this.layout = layout;
    this.discriminator = u328();
  }
  encode(src2, b, offset3 = 0) {
    if (src2 === null || src2 === void 0) {
      return this.layout.span + this.discriminator.encode(0, b, offset3);
    }
    this.discriminator.encode(1, b, offset3);
    return this.layout.encode(src2, b, offset3 + 4) + 4;
  }
  decode(b, offset3 = 0) {
    const discriminator2 = this.discriminator.decode(b, offset3);
    if (discriminator2 === 0) {
      return null;
    } else if (discriminator2 === 1) {
      return this.layout.decode(b, offset3 + 4);
    }
    throw new Error("Invalid coption " + this.layout.property);
  }
  getSpan(b, offset3 = 0) {
    return this.layout.getSpan(b, offset3 + 4) + 4;
  }
};
var u644 = class _u64 extends import_bn2.default {
  /**
   * Convert to Buffer representation
   */
  toBuffer() {
    const a = super.toArray().reverse();
    const b = Buffer.from(a);
    if (b.length === 8) {
      return b;
    }
    if (b.length >= 8) {
      throw new Error("u64 too large");
    }
    const zeroPad = Buffer.alloc(8);
    b.copy(zeroPad);
    return zeroPad;
  }
  /**
   * Construct a u64 from Buffer representation
   */
  static fromBuffer(buffer3) {
    if (buffer3.length !== 8) {
      throw new Error(`Invalid buffer length: ${buffer3.length}`);
    }
    return new _u64([...buffer3].reverse().map((i) => `00${i.toString(16)}`.slice(-2)).join(""), 16);
  }
};
var TOKEN_ACCOUNT_LAYOUT = struct51([
  publicKey4("mint"),
  publicKey4("owner"),
  uint64("amount"),
  coption(publicKey4(), "delegate"),
  ((p) => {
    const U = union2(u845("discriminator"), null, p);
    U.addVariant(0, struct51([]), "uninitialized");
    U.addVariant(1, struct51([]), "initialized");
    U.addVariant(2, struct51([]), "frozen");
    return U;
  })("state"),
  coption(uint64(), "isNative"),
  uint64("delegatedAmount"),
  coption(publicKey4(), "closeAuthority")
]);
function decodeTokenAccount(b) {
  return TOKEN_ACCOUNT_LAYOUT.decode(b);
}
var AccountsResolver = class _AccountsResolver {
  constructor(_args, _accounts, _provider2, _programId, _idlIx, _accountNamespace, _idlTypes, _customResolver) {
    this._accounts = _accounts;
    this._provider = _provider2;
    this._programId = _programId;
    this._idlIx = _idlIx;
    this._idlTypes = _idlTypes;
    this._customResolver = _customResolver;
    this._args = _args;
    this._accountStore = new AccountStore(_provider2, _accountNamespace, this._programId);
  }
  args(_args) {
    this._args = _args;
  }
  // Note: We serially resolve PDAs one by one rather than doing them
  //       in parallel because there can be dependencies between
  //       addresses. That is, one PDA can be used as a seed in another.
  async resolve() {
    await this.resolveConst(this._idlIx.accounts);
    this._resolveEventCpi(this._idlIx.accounts);
    while (await this.resolvePdas(this._idlIx.accounts) + await this.resolveRelations(this._idlIx.accounts) + await this.resolveCustom() > 0) {
    }
  }
  async resolveCustom() {
    if (this._customResolver) {
      const { accounts, resolved } = await this._customResolver({
        args: this._args,
        accounts: this._accounts,
        provider: this._provider,
        programId: this._programId,
        idlIx: this._idlIx
      });
      this._accounts = accounts;
      return resolved;
    }
    return 0;
  }
  resolveOptionalsHelper(partialAccounts, accountItems) {
    const nestedAccountsGeneric = {};
    for (const accountItem of accountItems) {
      const accountName = accountItem.name;
      const partialAccount = partialAccounts[accountName];
      if (partialAccount === void 0)
        continue;
      if (isPartialAccounts(partialAccount)) {
        if (isIdlAccounts(accountItem)) {
          nestedAccountsGeneric[accountName] = this.resolveOptionalsHelper(partialAccount, accountItem["accounts"]);
        } else {
          nestedAccountsGeneric[accountName] = flattenPartialAccounts(partialAccount, true);
        }
      } else {
        if (partialAccount !== null) {
          nestedAccountsGeneric[accountName] = translateAddress(partialAccount);
        } else if (accountItem["isOptional"]) {
          nestedAccountsGeneric[accountName] = this._programId;
        }
      }
    }
    return nestedAccountsGeneric;
  }
  resolveOptionals(accounts) {
    Object.assign(this._accounts, this.resolveOptionalsHelper(accounts, this._idlIx.accounts));
  }
  get(path) {
    const ret = path.reduce((acc, subPath) => acc && acc[subPath], this._accounts);
    if (ret && ret.toBase58) {
      return ret;
    }
  }
  set(path, value) {
    let curr = this._accounts;
    path.forEach((p, idx) => {
      const isLast = idx == path.length - 1;
      if (isLast) {
        curr[p] = value;
      }
      curr[p] = curr[p] || {};
      curr = curr[p];
    });
  }
  async resolveConst(accounts, path = []) {
    for (let k = 0; k < accounts.length; k += 1) {
      const accountDescOrAccounts = accounts[k];
      const subAccounts = accountDescOrAccounts.accounts;
      if (subAccounts) {
        await this.resolveConst(subAccounts, [
          ...path,
          (0, import_camelcase.default)(accountDescOrAccounts.name)
        ]);
      }
      const accountDesc = accountDescOrAccounts;
      const accountDescName = (0, import_camelcase.default)(accountDescOrAccounts.name);
      if (accountDesc.isSigner && !this.get([...path, accountDescName])) {
        if (this._provider.wallet === void 0) {
          throw new Error("This function requires the Provider interface implementor to have a 'wallet' field.");
        }
        this.set([...path, accountDescName], this._provider.wallet.publicKey);
      }
      if (Reflect.has(_AccountsResolver.CONST_ACCOUNTS, accountDescName) && !this.get([...path, accountDescName])) {
        this.set([...path, accountDescName], _AccountsResolver.CONST_ACCOUNTS[accountDescName]);
      }
    }
  }
  /**
   * Resolve event CPI accounts `eventAuthority` and `program`.
   *
   * Accounts will only be resolved if they are declared next to each other to
   * reduce the chance of name collision.
   */
  _resolveEventCpi(accounts, path = []) {
    for (const i in accounts) {
      const accountDescOrAccounts = accounts[i];
      const subAccounts = accountDescOrAccounts.accounts;
      if (subAccounts) {
        this._resolveEventCpi(subAccounts, [
          ...path,
          (0, import_camelcase.default)(accountDescOrAccounts.name)
        ]);
      }
      const nextIndex = +i + 1;
      if (nextIndex === accounts.length)
        return;
      const currentName = (0, import_camelcase.default)(accounts[i].name);
      const nextName = (0, import_camelcase.default)(accounts[nextIndex].name);
      if (currentName === "eventAuthority" && nextName === "program") {
        const currentPath = [...path, currentName];
        const nextPath = [...path, nextName];
        if (!this.get(currentPath)) {
          this.set(currentPath, PublicKey.findProgramAddressSync([Buffer.from("__event_authority")], this._programId)[0]);
        }
        if (!this.get(nextPath)) {
          this.set(nextPath, this._programId);
        }
        return;
      }
    }
  }
  async resolvePdas(accounts, path = []) {
    let found = 0;
    for (let k = 0; k < accounts.length; k += 1) {
      const accountDesc = accounts[k];
      const subAccounts = accountDesc.accounts;
      if (subAccounts) {
        found += await this.resolvePdas(subAccounts, [
          ...path,
          (0, import_camelcase.default)(accountDesc.name)
        ]);
      }
      const accountDescCasted = accountDesc;
      const accountDescName = (0, import_camelcase.default)(accountDesc.name);
      if (accountDescCasted.pda && accountDescCasted.pda.seeds.length > 0 && !this.get([...path, accountDescName])) {
        if (Boolean(await this.autoPopulatePda(accountDescCasted, path))) {
          found += 1;
        }
      }
    }
    return found;
  }
  async resolveRelations(accounts, path = []) {
    let found = 0;
    for (let k = 0; k < accounts.length; k += 1) {
      const accountDesc = accounts[k];
      const subAccounts = accountDesc.accounts;
      if (subAccounts) {
        found += await this.resolveRelations(subAccounts, [
          ...path,
          (0, import_camelcase.default)(accountDesc.name)
        ]);
      }
      const relations = accountDesc.relations || [];
      const accountDescName = (0, import_camelcase.default)(accountDesc.name);
      const newPath = [...path, accountDescName];
      const accountKey = this.get(newPath);
      if (accountKey) {
        const matching = relations.filter((rel) => !this.get([...path, (0, import_camelcase.default)(rel)]));
        found += matching.length;
        if (matching.length > 0) {
          const account = await this._accountStore.fetchAccount({
            publicKey: accountKey
          });
          await Promise.all(matching.map(async (rel) => {
            const relName = (0, import_camelcase.default)(rel);
            this.set([...path, relName], account[relName]);
            return account[relName];
          }));
        }
      }
    }
    return found;
  }
  async autoPopulatePda(accountDesc, path = []) {
    if (!accountDesc.pda || !accountDesc.pda.seeds)
      throw new Error("Must have seeds");
    const seeds = await Promise.all(accountDesc.pda.seeds.map((seedDesc) => this.toBuffer(seedDesc, path)));
    if (seeds.some((seed2) => typeof seed2 == "undefined")) {
      return;
    }
    const programId = await this.parseProgramId(accountDesc, path);
    if (!programId) {
      return;
    }
    const [pubkey2] = await PublicKey.findProgramAddress(seeds, programId);
    this.set([...path, (0, import_camelcase.default)(accountDesc.name)], pubkey2);
  }
  async parseProgramId(accountDesc, path = []) {
    var _a2;
    if (!((_a2 = accountDesc.pda) === null || _a2 === void 0 ? void 0 : _a2.programId)) {
      return this._programId;
    }
    switch (accountDesc.pda.programId.kind) {
      case "const":
        return new PublicKey(this.toBufferConst(accountDesc.pda.programId.value));
      case "arg":
        return this.argValue(accountDesc.pda.programId);
      case "account":
        return await this.accountValue(accountDesc.pda.programId, path);
      default:
        throw new Error(`Unexpected program seed kind: ${accountDesc.pda.programId.kind}`);
    }
  }
  async toBuffer(seedDesc, path = []) {
    switch (seedDesc.kind) {
      case "const":
        return this.toBufferConst(seedDesc);
      case "arg":
        return await this.toBufferArg(seedDesc);
      case "account":
        return await this.toBufferAccount(seedDesc, path);
      default:
        throw new Error(`Unexpected seed kind: ${seedDesc.kind}`);
    }
  }
  /**
   * Recursively get the type at some path of either a primitive or a user defined struct.
   */
  getType(type3, path = []) {
    if (path.length > 0 && type3.defined) {
      const subType = this._idlTypes.find((t) => t.name === type3.defined);
      if (!subType) {
        throw new Error(`Cannot find type ${type3.defined}`);
      }
      const structType = subType.type;
      const field = structType.fields.find((field2) => field2.name === path[0]);
      return this.getType(field.type, path.slice(1));
    }
    return type3;
  }
  toBufferConst(seedDesc) {
    return this.toBufferValue(this.getType(seedDesc.type, (seedDesc.path || "").split(".").slice(1)), seedDesc.value);
  }
  async toBufferArg(seedDesc) {
    const argValue = this.argValue(seedDesc);
    if (typeof argValue === "undefined") {
      return;
    }
    return this.toBufferValue(this.getType(seedDesc.type, (seedDesc.path || "").split(".").slice(1)), argValue);
  }
  argValue(seedDesc) {
    const split6 = seedDesc.path.split(".");
    const seedArgName = (0, import_camelcase.default)(split6[0]);
    const idlArgPosition = this._idlIx.args.findIndex((argDesc) => argDesc.name === seedArgName);
    if (idlArgPosition === -1) {
      throw new Error(`Unable to find argument for seed: ${seedArgName}`);
    }
    return split6.slice(1).reduce((curr, path) => (curr || {})[path], this._args[idlArgPosition]);
  }
  async toBufferAccount(seedDesc, path = []) {
    const accountValue = await this.accountValue(seedDesc, path);
    if (!accountValue) {
      return;
    }
    return this.toBufferValue(seedDesc.type, accountValue);
  }
  async accountValue(seedDesc, path = []) {
    const pathComponents = seedDesc.path.split(".");
    const fieldName = pathComponents[0];
    const fieldPubkey = this.get([...path, (0, import_camelcase.default)(fieldName)]);
    if (fieldPubkey === null) {
      throw new Error(`fieldPubkey is null`);
    }
    if (pathComponents.length === 1) {
      return fieldPubkey;
    }
    const account = await this._accountStore.fetchAccount({
      publicKey: fieldPubkey,
      name: seedDesc.account
    });
    const fieldValue = this.parseAccountValue(account, pathComponents.slice(1));
    return fieldValue;
  }
  parseAccountValue(account, path) {
    let accountField;
    while (path.length > 0) {
      accountField = account[(0, import_camelcase.default)(path[0])];
      path = path.slice(1);
    }
    return accountField;
  }
  // Converts the given idl valaue into a Buffer. The values here must be
  // primitives. E.g. no structs.
  //
  // TODO: add more types here as needed.
  toBufferValue(type3, value) {
    switch (type3) {
      case "u8":
        return Buffer.from([value]);
      case "u16":
        let b = Buffer.alloc(2);
        b.writeUInt16LE(value);
        return b;
      case "u32":
        let buf = Buffer.alloc(4);
        buf.writeUInt32LE(value);
        return buf;
      case "u64":
        let bU64 = Buffer.alloc(8);
        bU64.writeBigUInt64LE(BigInt(value));
        return bU64;
      case "string":
        return Buffer.from(encode$2(value));
      case "publicKey":
        return value.toBuffer();
      default:
        if (type3.array) {
          return Buffer.from(value);
        }
        throw new Error(`Unexpected seed type: ${type3}`);
    }
  }
};
AccountsResolver.CONST_ACCOUNTS = {
  associatedTokenProgram: ASSOCIATED_PROGRAM_ID,
  rent: SYSVAR_RENT_PUBKEY,
  systemProgram: SystemProgram.programId,
  tokenProgram: TOKEN_PROGRAM_ID2,
  clock: SYSVAR_CLOCK_PUBKEY
};
var AccountStore = class {
  // todo: don't use the progrma use the account namespace.
  constructor(_provider2, _accounts, _programId) {
    this._provider = _provider2;
    this._programId = _programId;
    this._cache = /* @__PURE__ */ new Map();
    this._idls = {};
    this._idls[_programId.toBase58()] = _accounts;
  }
  async ensureIdl(programId) {
    if (!this._idls[programId.toBase58()]) {
      const idl = await Program.fetchIdl(programId, this._provider);
      if (idl) {
        const program = new Program(idl, programId, this._provider);
        this._idls[programId.toBase58()] = program.account;
      }
    }
    return this._idls[programId.toBase58()];
  }
  async fetchAccount({ publicKey: publicKey5, name, programId = this._programId }) {
    const address = publicKey5.toString();
    if (!this._cache.has(address)) {
      if (name === "TokenAccount") {
        const accountInfo = await this._provider.connection.getAccountInfo(publicKey5);
        if (accountInfo === null) {
          throw new Error(`invalid account info for ${address}`);
        }
        const data = decodeTokenAccount(accountInfo.data);
        this._cache.set(address, data);
      } else if (name) {
        const accounts = await this.ensureIdl(programId);
        if (accounts) {
          const accountFetcher = accounts[(0, import_camelcase.default)(name)];
          if (accountFetcher) {
            const account = await accountFetcher.fetch(publicKey5);
            this._cache.set(address, account);
          }
        }
      } else {
        const account = await this._provider.connection.getAccountInfo(publicKey5);
        if (account === null) {
          throw new Error(`invalid account info for ${address}`);
        }
        const data = account.data;
        const accounts = await this.ensureIdl(account.owner);
        if (accounts) {
          const firstAccountLayout = Object.values(accounts)[0];
          if (!firstAccountLayout) {
            throw new Error("No accounts for this program");
          }
          const result = firstAccountLayout.coder.accounts.decodeAny(data);
          this._cache.set(address, result);
        }
      }
    }
    return this._cache.get(address);
  }
};
var MethodsBuilderFactory = class {
  static build(provider, programId, idlIx, ixFn, txFn, rpcFn, simulateFn, viewFn, accountNamespace, idlTypes, customResolver) {
    return (...args) => new MethodsBuilder(args, ixFn, txFn, rpcFn, simulateFn, viewFn, provider, programId, idlIx, accountNamespace, idlTypes, customResolver);
  }
};
function isPartialAccounts(partialAccount) {
  return typeof partialAccount === "object" && partialAccount !== null && !("_bn" in partialAccount);
}
function flattenPartialAccounts(partialAccounts, throwOnNull) {
  const toReturn = {};
  for (const accountName in partialAccounts) {
    const account = partialAccounts[accountName];
    if (account === null) {
      if (throwOnNull)
        throw new Error("Failed to resolve optionals due to IDL type mismatch with input accounts!");
      continue;
    }
    toReturn[accountName] = isPartialAccounts(account) ? flattenPartialAccounts(account, true) : translateAddress(account);
  }
  return toReturn;
}
var MethodsBuilder = class {
  constructor(_args, _ixFn, _txFn, _rpcFn, _simulateFn, _viewFn, _provider2, _programId, _idlIx, _accountNamespace, _idlTypes, _customResolver) {
    this._ixFn = _ixFn;
    this._txFn = _txFn;
    this._rpcFn = _rpcFn;
    this._simulateFn = _simulateFn;
    this._viewFn = _viewFn;
    this._programId = _programId;
    this._accounts = {};
    this._remainingAccounts = [];
    this._signers = [];
    this._preInstructions = [];
    this._postInstructions = [];
    this._autoResolveAccounts = true;
    this._args = _args;
    this._accountsResolver = new AccountsResolver(_args, this._accounts, _provider2, _programId, _idlIx, _accountNamespace, _idlTypes, _customResolver);
  }
  args(_args) {
    this._args = _args;
    this._accountsResolver.args(_args);
  }
  async pubkeys() {
    if (this._autoResolveAccounts) {
      await this._accountsResolver.resolve();
    }
    return this._accounts;
  }
  accounts(accounts) {
    this._autoResolveAccounts = true;
    this._accountsResolver.resolveOptionals(accounts);
    return this;
  }
  accountsStrict(accounts) {
    this._autoResolveAccounts = false;
    this._accountsResolver.resolveOptionals(accounts);
    return this;
  }
  signers(signers) {
    this._signers = this._signers.concat(signers);
    return this;
  }
  remainingAccounts(accounts) {
    this._remainingAccounts = this._remainingAccounts.concat(accounts);
    return this;
  }
  preInstructions(ixs) {
    this._preInstructions = this._preInstructions.concat(ixs);
    return this;
  }
  postInstructions(ixs) {
    this._postInstructions = this._postInstructions.concat(ixs);
    return this;
  }
  async rpc(options) {
    if (this._autoResolveAccounts) {
      await this._accountsResolver.resolve();
    }
    return this._rpcFn(...this._args, {
      accounts: this._accounts,
      signers: this._signers,
      remainingAccounts: this._remainingAccounts,
      preInstructions: this._preInstructions,
      postInstructions: this._postInstructions,
      options
    });
  }
  async rpcAndKeys(options) {
    const pubkeys = await this.pubkeys();
    return {
      pubkeys,
      signature: await this.rpc(options)
    };
  }
  async view(options) {
    if (this._autoResolveAccounts) {
      await this._accountsResolver.resolve();
    }
    if (!this._viewFn) {
      throw new Error("Method does not support views");
    }
    return this._viewFn(...this._args, {
      accounts: this._accounts,
      signers: this._signers,
      remainingAccounts: this._remainingAccounts,
      preInstructions: this._preInstructions,
      postInstructions: this._postInstructions,
      options
    });
  }
  async simulate(options) {
    if (this._autoResolveAccounts) {
      await this._accountsResolver.resolve();
    }
    return this._simulateFn(...this._args, {
      accounts: this._accounts,
      signers: this._signers,
      remainingAccounts: this._remainingAccounts,
      preInstructions: this._preInstructions,
      postInstructions: this._postInstructions,
      options
    });
  }
  async instruction() {
    if (this._autoResolveAccounts) {
      await this._accountsResolver.resolve();
    }
    return this._ixFn(...this._args, {
      accounts: this._accounts,
      signers: this._signers,
      remainingAccounts: this._remainingAccounts,
      preInstructions: this._preInstructions,
      postInstructions: this._postInstructions
    });
  }
  /**
   * Convenient shortcut to get instructions and pubkeys via
   * const { pubkeys, instructions } = await prepare();
   */
  async prepare() {
    return {
      instruction: await this.instruction(),
      pubkeys: await this.pubkeys(),
      signers: await this._signers
    };
  }
  async transaction() {
    if (this._autoResolveAccounts) {
      await this._accountsResolver.resolve();
    }
    return this._txFn(...this._args, {
      accounts: this._accounts,
      signers: this._signers,
      remainingAccounts: this._remainingAccounts,
      preInstructions: this._preInstructions,
      postInstructions: this._postInstructions
    });
  }
};
var ViewFactory = class {
  static build(programId, idlIx, simulateFn, idl) {
    const isMut = idlIx.accounts.find((a) => a.isMut);
    const hasReturn = !!idlIx.returns;
    if (isMut || !hasReturn)
      return;
    const view = async (...args) => {
      var _a2, _b;
      let simulationResult = await simulateFn(...args);
      const returnPrefix = `Program return: ${programId} `;
      let returnLog = simulationResult.raw.find((l) => l.startsWith(returnPrefix));
      if (!returnLog) {
        throw new Error("View expected return log");
      }
      let returnData = decode2(returnLog.slice(returnPrefix.length));
      let returnType = idlIx.returns;
      if (!returnType) {
        throw new Error("View expected return type");
      }
      const coder = IdlCoder.fieldLayout({ type: returnType }, Array.from([...(_a2 = idl.accounts) !== null && _a2 !== void 0 ? _a2 : [], ...(_b = idl.types) !== null && _b !== void 0 ? _b : []]));
      return coder.decode(returnData);
    };
    return view;
  }
};
var NamespaceFactory = class {
  /**
   * Generates all namespaces for a given program.
   */
  static build(idl, coder, programId, provider, getCustomResolver) {
    const rpc3 = {};
    const instruction = {};
    const transaction = {};
    const simulate = {};
    const methods = {};
    const view = {};
    const idlErrors = parseIdlErrors(idl);
    const account = idl.accounts ? AccountFactory.build(idl, coder, programId, provider) : {};
    idl.instructions.forEach((idlIx) => {
      const ixItem = InstructionNamespaceFactory.build(idlIx, (ixName, ix) => coder.instruction.encode(ixName, ix), programId);
      const txItem = TransactionFactory.build(idlIx, ixItem);
      const rpcItem = RpcFactory.build(idlIx, txItem, idlErrors, provider);
      const simulateItem = SimulateFactory.build(idlIx, txItem, idlErrors, provider, coder, programId, idl);
      const viewItem = ViewFactory.build(programId, idlIx, simulateItem, idl);
      const methodItem = MethodsBuilderFactory.build(provider, programId, idlIx, ixItem, txItem, rpcItem, simulateItem, viewItem, account, idl.types || [], getCustomResolver && getCustomResolver(idlIx));
      const name = (0, import_camelcase.default)(idlIx.name);
      instruction[name] = ixItem;
      transaction[name] = txItem;
      rpc3[name] = rpcItem;
      simulate[name] = simulateItem;
      methods[name] = methodItem;
      if (viewItem) {
        view[name] = viewItem;
      }
    });
    return [
      rpc3,
      instruction,
      transaction,
      account,
      simulate,
      methods,
      view
    ];
  }
};
var Program = class _Program {
  /**
   * Address of the program.
   */
  get programId() {
    return this._programId;
  }
  /**
   * IDL defining the program's interface.
   */
  get idl() {
    return this._idl;
  }
  /**
   * Coder for serializing requests.
   */
  get coder() {
    return this._coder;
  }
  /**
   * Wallet and network provider.
   */
  get provider() {
    return this._provider;
  }
  /**
   * @param idl       The interface definition.
   * @param programId The on-chain address of the program.
   * @param provider  The network and wallet context to use. If not provided
   *                  then uses [[getProvider]].
   * @param getCustomResolver A function that returns a custom account resolver
   *                          for the given instruction. This is useful for resolving
   *                          public keys of missing accounts when building instructions
   */
  constructor(idl, programId, provider, coder, getCustomResolver) {
    programId = translateAddress(programId);
    if (!provider) {
      provider = getProvider();
    }
    this._idl = idl;
    this._provider = provider;
    this._programId = programId;
    this._coder = coder !== null && coder !== void 0 ? coder : new BorshCoder(idl);
    this._events = new EventManager(this._programId, provider, this._coder);
    const [rpc3, instruction, transaction, account, simulate, methods, views] = NamespaceFactory.build(idl, this._coder, programId, provider, getCustomResolver !== null && getCustomResolver !== void 0 ? getCustomResolver : (() => void 0));
    this.rpc = rpc3;
    this.instruction = instruction;
    this.transaction = transaction;
    this.account = account;
    this.simulate = simulate;
    this.methods = methods;
    this.views = views;
  }
  /**
   * Generates a Program client by fetching the IDL from the network.
   *
   * In order to use this method, an IDL must have been previously initialized
   * via the anchor CLI's `anchor idl init` command.
   *
   * @param programId The on-chain address of the program.
   * @param provider  The network and wallet context.
   */
  static async at(address, provider) {
    const programId = translateAddress(address);
    const idl = await _Program.fetchIdl(programId, provider);
    if (!idl) {
      throw new Error(`IDL not found for program: ${address.toString()}`);
    }
    return new _Program(idl, programId, provider);
  }
  /**
   * Fetches an idl from the blockchain.
   *
   * In order to use this method, an IDL must have been previously initialized
   * via the anchor CLI's `anchor idl init` command.
   *
   * @param programId The on-chain address of the program.
   * @param provider  The network and wallet context.
   */
  static async fetchIdl(address, provider) {
    provider = provider !== null && provider !== void 0 ? provider : getProvider();
    const programId = translateAddress(address);
    const idlAddr = await idlAddress(programId);
    const accountInfo = await provider.connection.getAccountInfo(idlAddr);
    if (!accountInfo) {
      return null;
    }
    let idlAccount = decodeIdlAccount(accountInfo.data.slice(8));
    const inflatedIdl = inflate_1(idlAccount.data);
    return JSON.parse(decode$2(inflatedIdl));
  }
  /**
   * Invokes the given callback every time the given event is emitted.
   *
   * @param eventName The PascalCase name of the event, provided by the IDL.
   * @param callback  The function to invoke whenever the event is emitted from
   *                  program logs.
   */
  addEventListener(eventName, callback) {
    return this._events.addEventListener(eventName, callback);
  }
  /**
   * Unsubscribes from the given eventName.
   */
  async removeEventListener(listener) {
    return await this._events.removeEventListener(listener);
  }
};
var SYSTEM_PROGRAM_ID = new PublicKey("11111111111111111111111111111111");

// node_modules/@audius/spl/dist/esm/payment-router/PaymentRouterProgram.js
init_index_browser_esm();
var PaymentRouterProgram = class _PaymentRouterProgram {
  static async createPaymentRouterBalancePdaInstruction(paymentRouterPda, payer, programId = _PaymentRouterProgram.programId) {
    const program = new Program(IDL, programId);
    return await program.methods.createPaymentRouterBalancePda().accounts({
      paymentRouterPda,
      payer,
      systemProgram: SystemProgram.programId
    }).instruction();
  }
  static async createRouteInstruction({ sender, senderOwner, paymentRouterPdaBump, recipients, amounts, totalAmount, tokenProgramId = TOKEN_PROGRAM_ID, programId = _PaymentRouterProgram.programId }) {
    const program = new Program(IDL, programId, {});
    return await program.methods.route(paymentRouterPdaBump, amounts.map((b) => new import_bn3.default(b.toString())), new import_bn3.default(totalAmount.toString())).accounts({
      sender,
      senderOwner,
      splToken: tokenProgramId
    }).remainingAccounts(recipients.map((recipient) => ({
      pubkey: recipient,
      isSigner: false,
      isWritable: true
    }))).instruction();
  }
};
PaymentRouterProgram.programId = new PublicKey("paytYpX3LPN98TAeen6bFFeraGSuWnomZmCXjAsoqPa");

// node_modules/ulid/dist/index.esm.js
function createError(message) {
  var err2 = new Error(message);
  err2.source = "ulid";
  return err2;
}
var ENCODING = "0123456789ABCDEFGHJKMNPQRSTVWXYZ";
var ENCODING_LEN = ENCODING.length;
var TIME_MAX = Math.pow(2, 48) - 1;
var TIME_LEN = 10;
var RANDOM_LEN = 16;
function randomChar(prng) {
  var rand = Math.floor(prng() * ENCODING_LEN);
  if (rand === ENCODING_LEN) {
    rand = ENCODING_LEN - 1;
  }
  return ENCODING.charAt(rand);
}
function encodeTime(now, len) {
  if (isNaN(now)) {
    throw new Error(now + " must be a number");
  }
  if (now > TIME_MAX) {
    throw createError("cannot encode time greater than " + TIME_MAX);
  }
  if (now < 0) {
    throw createError("time must be positive");
  }
  if (Number.isInteger(now) === false) {
    throw createError("time must be an integer");
  }
  var mod4 = void 0;
  var str2 = "";
  for (; len > 0; len--) {
    mod4 = now % ENCODING_LEN;
    str2 = ENCODING.charAt(mod4) + str2;
    now = (now - mod4) / ENCODING_LEN;
  }
  return str2;
}
function encodeRandom(len, prng) {
  var str2 = "";
  for (; len > 0; len--) {
    str2 = randomChar(prng) + str2;
  }
  return str2;
}
function detectPrng() {
  var allowInsecure = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
  var root2 = arguments[1];
  if (!root2) {
    root2 = typeof window !== "undefined" ? window : null;
  }
  var browserCrypto = root2 && (root2.crypto || root2.msCrypto);
  if (browserCrypto) {
    return function() {
      var buffer3 = new Uint8Array(1);
      browserCrypto.getRandomValues(buffer3);
      return buffer3[0] / 255;
    };
  } else {
    try {
      var nodeCrypto2 = require_crypto2();
      return function() {
        return nodeCrypto2.randomBytes(1).readUInt8() / 255;
      };
    } catch (e) {
    }
  }
  if (allowInsecure) {
    try {
      console.error("secure crypto unusable, falling back to insecure Math.random()!");
    } catch (e) {
    }
    return function() {
      return Math.random();
    };
  }
  throw createError("secure crypto unusable, insecure Math.random not allowed");
}
function factory(currPrng) {
  if (!currPrng) {
    currPrng = detectPrng();
  }
  return function ulid2(seedTime) {
    if (isNaN(seedTime)) {
      seedTime = Date.now();
    }
    return encodeTime(seedTime, TIME_LEN) + encodeRandom(RANDOM_LEN, currPrng);
  };
}
var ulid = factory();

// node_modules/micro-aes-gcm/index.js
var cr = () => typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
function concatBytes4(...arrays) {
  if (!arrays.every((arr) => arr instanceof Uint8Array))
    throw new Error("Uint8Array list expected");
  if (arrays.length === 1)
    return arrays[0];
  const length2 = arrays.reduce((a, arr) => a + arr.length, 0);
  const result = new Uint8Array(length2);
  for (let i = 0, pad3 = 0; i < arrays.length; i++) {
    const arr = arrays[i];
    result.set(arr, pad3);
    pad3 += arr.length;
  }
  return result;
}
var MD = { e: "AES-GCM", i: { name: "AES-GCM", length: 256 } };
function ensureBytes3(b, len) {
  if (!(b instanceof Uint8Array))
    throw new Error("Uint8Array expected");
  if (typeof len === "number") {
    if (b.length !== len)
      throw new Error(`Uint8Array length ${len} expected`);
  }
}
function ensureCrypto() {
  if (!cr())
    throw new Error("globalThis.crypto is not available: use nodejs 19+ or browser");
}
async function encrypt(sharedKey, plaintext) {
  ensureCrypto();
  ensureBytes3(sharedKey, 32);
  ensureBytes3(plaintext);
  const iv = utils2.randomBytes(12);
  const iKey = await cr().subtle.importKey("raw", sharedKey, MD.i, true, ["encrypt"]);
  const cipher = await cr().subtle.encrypt({ name: MD.e, iv }, iKey, plaintext);
  return concatBytes4(iv, new Uint8Array(cipher));
}
async function decrypt(sharedKey, ciphertext) {
  ensureCrypto();
  ensureBytes3(sharedKey, 32);
  ensureBytes3(ciphertext);
  const iv = ciphertext.slice(0, 12);
  const ciphertextWithTag = ciphertext.slice(12);
  const iKey = await cr().subtle.importKey("raw", sharedKey, MD.i, true, ["decrypt"]);
  const plaintext = await cr().subtle.decrypt({ name: MD.e, iv }, iKey, ciphertextWithTag);
  return new Uint8Array(plaintext);
}
var utils2 = {
  randomBytes: (bytesLength = 32) => {
    return cr().getRandomValues(new Uint8Array(bytesLength));
  },
  bytesToUtf8(bytes3) {
    return new TextDecoder().decode(bytes3);
  },
  utf8ToBytes(string3) {
    return new TextEncoder().encode(string3);
  },
  concatBytes: concatBytes4
};

// node_modules/@audius/sdk/dist/index.browser.esm.js
var import_cross_fetch = __toESM(require_browser_ponyfill());
var import_axios = __toESM(require_axios2());
var import_form_data = __toESM(require_browser3());

// node_modules/@audius/eth/dist/esm/audius-token/abi.js
var abi2 = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "spender",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "Approval",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "MinterAdded",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "MinterRemoved",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "Paused",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "PauserAdded",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "PauserRemoved",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "Transfer",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "Unpaused",
    type: "event"
  },
  {
    constant: true,
    inputs: [],
    name: "DOMAIN_SEPARATOR",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "PERMIT_TYPEHASH",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "addMinter",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "addPauser",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: true,
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        internalType: "address",
        name: "spender",
        type: "address"
      }
    ],
    name: "allowance",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "address",
        name: "spender",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "approve",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: true,
    inputs: [
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "balanceOf",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "burn",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "burnFrom",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "decimals",
    outputs: [
      {
        internalType: "uint8",
        name: "",
        type: "uint8"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "address",
        name: "spender",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "subtractedValue",
        type: "uint256"
      }
    ],
    name: "decreaseAllowance",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "address",
        name: "spender",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "addedValue",
        type: "uint256"
      }
    ],
    name: "increaseAllowance",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: true,
    inputs: [
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "isMinter",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "isPauser",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "mint",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "name",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    name: "nonces",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: false,
    inputs: [],
    name: "pause",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "paused",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: false,
    inputs: [],
    name: "renounceMinter",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [],
    name: "renouncePauser",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "symbol",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "totalSupply",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "transfer",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "transferFrom",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [],
    name: "unpause",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "string",
        name: "name",
        type: "string"
      },
      {
        internalType: "string",
        name: "symbol",
        type: "string"
      },
      {
        internalType: "uint8",
        name: "decimals",
        type: "uint8"
      }
    ],
    name: "initialize",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "address",
        name: "_owner",
        type: "address"
      },
      {
        internalType: "address",
        name: "governance",
        type: "address"
      }
    ],
    name: "initialize",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [],
    name: "initialize",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "address",
        name: "sender",
        type: "address"
      }
    ],
    name: "initialize",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        internalType: "address",
        name: "spender",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "deadline",
        type: "uint256"
      },
      {
        internalType: "uint8",
        name: "v",
        type: "uint8"
      },
      {
        internalType: "bytes32",
        name: "r",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "s",
        type: "bytes32"
      }
    ],
    name: "permit",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  }
];

// node_modules/@audius/eth/dist/esm/audius-token/audiusToken.js
var AudiusToken = class {
};
AudiusToken.abi = abi2;
AudiusToken.address = "0x18aAA7115705e8be94bfFEBDE57Af9BFc265B998";
AudiusToken.types = {
  EIP712Domain: [
    { name: "name", type: "string" },
    { name: "version", type: "string" },
    { name: "chainId", type: "uint256" },
    { name: "verifyingContract", type: "address" }
  ],
  Permit: [
    { name: "owner", type: "address" },
    { name: "spender", type: "address" },
    { name: "value", type: "uint256" },
    { name: "nonce", type: "uint256" },
    { name: "deadline", type: "uint256" }
  ]
};

// node_modules/@audius/eth/dist/esm/claims-manager/abi.js
var abi3 = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "_claimer",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "_rewards",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "_oldTotal",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "_newTotal",
        type: "uint256"
      }
    ],
    name: "ClaimProcessed",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "_newCommunityPoolAddress",
        type: "address"
      }
    ],
    name: "CommunityPoolAddressUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "_transferAddress",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "_amount",
        type: "uint256"
      }
    ],
    name: "CommunityRewardsTransferred",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "_newDelegateManagerAddress",
        type: "address"
      }
    ],
    name: "DelegateManagerAddressUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "_amount",
        type: "uint256"
      }
    ],
    name: "FundingAmountUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "_blockDifference",
        type: "uint256"
      }
    ],
    name: "FundingRoundBlockDiffUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "_newGovernanceAddress",
        type: "address"
      }
    ],
    name: "GovernanceAddressUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "_amount",
        type: "uint256"
      }
    ],
    name: "RecurringCommunityFundingAmountUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "_blockNumber",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "_roundNumber",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "_fundAmount",
        type: "uint256"
      }
    ],
    name: "RoundInitiated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "_newServiceProviderFactoryAddress",
        type: "address"
      }
    ],
    name: "ServiceProviderFactoryAddressUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "_newStakingAddress",
        type: "address"
      }
    ],
    name: "StakingAddressUpdated",
    type: "event"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "address",
        name: "_tokenAddress",
        type: "address"
      },
      {
        internalType: "address",
        name: "_governanceAddress",
        type: "address"
      }
    ],
    name: "initialize",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [],
    name: "initialize",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "getFundingRoundBlockDiff",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "getLastFundedBlock",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "getFundsPerRound",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "getTotalClaimedInRound",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "getGovernanceAddress",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "getServiceProviderFactoryAddress",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "getDelegateManagerAddress",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "getStakingAddress",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "getCommunityPoolAddress",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "getRecurringCommunityFundingAmount",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "address",
        name: "_governanceAddress",
        type: "address"
      }
    ],
    name: "setGovernanceAddress",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "address",
        name: "_stakingAddress",
        type: "address"
      }
    ],
    name: "setStakingAddress",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "address",
        name: "_serviceProviderFactoryAddress",
        type: "address"
      }
    ],
    name: "setServiceProviderFactoryAddress",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "address",
        name: "_delegateManagerAddress",
        type: "address"
      }
    ],
    name: "setDelegateManagerAddress",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [],
    name: "initiateRound",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "address",
        name: "_claimer",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "_totalLockedForSP",
        type: "uint256"
      }
    ],
    name: "processClaim",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "uint256",
        name: "_newAmount",
        type: "uint256"
      }
    ],
    name: "updateFundingAmount",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: true,
    inputs: [
      {
        internalType: "address",
        name: "_sp",
        type: "address"
      }
    ],
    name: "claimPending",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "uint256",
        name: "_newFundingRoundBlockDiff",
        type: "uint256"
      }
    ],
    name: "updateFundingRoundBlockDiff",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "uint256",
        name: "_newRecurringCommunityFundingAmount",
        type: "uint256"
      }
    ],
    name: "updateRecurringCommunityFundingAmount",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "address",
        name: "_newCommunityPoolAddress",
        type: "address"
      }
    ],
    name: "updateCommunityPoolAddress",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  }
];

// node_modules/@audius/eth/dist/esm/claims-manager/constants.js
var CLAIMS_MANAGER_CONTRACT_ADDRESS = "0x44617F9dCEd9787C3B06a05B35B4C779a2AA1334";

// node_modules/@audius/eth/dist/esm/claims-manager/claimsManager.js
var ClaimsManager = class {
  constructor(client, { address } = {}) {
    this.getFundingRoundBlockDiff = () => this.client.readContract({
      address: this.address,
      abi: abi3,
      functionName: "getFundingRoundBlockDiff"
    });
    this.getLastFundedBlock = () => this.client.readContract({
      address: this.address,
      abi: abi3,
      functionName: "getLastFundedBlock"
    });
    this.getFundsPerRound = () => this.client.readContract({
      address: this.address,
      abi: abi3,
      functionName: "getFundsPerRound"
    });
    this.getTotalClaimedInRound = () => this.client.readContract({
      address: this.address,
      abi: abi3,
      functionName: "getTotalClaimedInRound"
    });
    this.getGovernanceAddress = () => this.client.readContract({
      address: this.address,
      abi: abi3,
      functionName: "getGovernanceAddress"
    });
    this.getServiceProviderFactoryAddress = () => this.client.readContract({
      address: this.address,
      abi: abi3,
      functionName: "getServiceProviderFactoryAddress"
    });
    this.getDelegateManagerAddress = () => this.client.readContract({
      address: this.address,
      abi: abi3,
      functionName: "getDelegateManagerAddress"
    });
    this.getStakingAddress = () => this.client.readContract({
      address: this.address,
      abi: abi3,
      functionName: "getStakingAddress"
    });
    this.claimPending = ({ address: address2 }) => this.client.readContract({
      address: this.address,
      abi: abi3,
      functionName: "claimPending",
      args: [address2]
    });
    this.client = client;
    this.address = address ?? CLAIMS_MANAGER_CONTRACT_ADDRESS;
  }
};

// node_modules/@audius/eth/dist/esm/delegate-manager/abi.js
var abi4 = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "_claimer",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "_rewards",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "_newTotal",
        type: "uint256"
      }
    ],
    name: "Claim",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "_newClaimsManagerAddress",
        type: "address"
      }
    ],
    name: "ClaimsManagerAddressUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "_newGovernanceAddress",
        type: "address"
      }
    ],
    name: "GovernanceAddressUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "_delegator",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "_serviceProvider",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "_increaseAmount",
        type: "uint256"
      }
    ],
    name: "IncreaseDelegatedStake",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "_maxDelegators",
        type: "uint256"
      }
    ],
    name: "MaxDelegatorsUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "_minDelegationAmount",
        type: "uint256"
      }
    ],
    name: "MinDelegationUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "_removeDelegatorEvalDuration",
        type: "uint256"
      }
    ],
    name: "RemoveDelegatorEvalDurationUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "_removeDelegatorLockupDuration",
        type: "uint256"
      }
    ],
    name: "RemoveDelegatorLockupDurationUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "_serviceProvider",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "_delegator",
        type: "address"
      }
    ],
    name: "RemoveDelegatorRequestCancelled",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "_serviceProvider",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "_delegator",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "_unstakedAmount",
        type: "uint256"
      }
    ],
    name: "RemoveDelegatorRequestEvaluated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "_serviceProvider",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "_delegator",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "_lockupExpiryBlock",
        type: "uint256"
      }
    ],
    name: "RemoveDelegatorRequested",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "_serviceProvider",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "_spMinDelegationAmount",
        type: "uint256"
      }
    ],
    name: "SPMinDelegationAmountUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "_newServiceProviderFactoryAddress",
        type: "address"
      }
    ],
    name: "ServiceProviderFactoryAddressUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "_target",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "_amount",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "_newTotal",
        type: "uint256"
      }
    ],
    name: "Slash",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "_newStakingAddress",
        type: "address"
      }
    ],
    name: "StakingAddressUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "_undelegateLockupDuration",
        type: "uint256"
      }
    ],
    name: "UndelegateLockupDurationUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "_delegator",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "_serviceProvider",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "_amount",
        type: "uint256"
      }
    ],
    name: "UndelegateStakeRequestCancelled",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "_delegator",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "_serviceProvider",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "_amount",
        type: "uint256"
      }
    ],
    name: "UndelegateStakeRequestEvaluated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "_delegator",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "_serviceProvider",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "_amount",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "_lockupExpiryBlock",
        type: "uint256"
      }
    ],
    name: "UndelegateStakeRequested",
    type: "event"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "address",
        name: "_tokenAddress",
        type: "address"
      },
      {
        internalType: "address",
        name: "_governanceAddress",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "_undelegateLockupDuration",
        type: "uint256"
      }
    ],
    name: "initialize",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [],
    name: "initialize",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "address",
        name: "_targetSP",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "_amount",
        type: "uint256"
      }
    ],
    name: "delegateStake",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "address",
        name: "_target",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "_amount",
        type: "uint256"
      }
    ],
    name: "requestUndelegateStake",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [],
    name: "cancelUndelegateStakeRequest",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [],
    name: "undelegateStake",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "address",
        name: "_serviceProvider",
        type: "address"
      }
    ],
    name: "claimRewards",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "uint256",
        name: "_amount",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "_slashAddress",
        type: "address"
      }
    ],
    name: "slash",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "address",
        name: "_serviceProvider",
        type: "address"
      },
      {
        internalType: "address",
        name: "_delegator",
        type: "address"
      }
    ],
    name: "requestRemoveDelegator",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "address",
        name: "_serviceProvider",
        type: "address"
      },
      {
        internalType: "address",
        name: "_delegator",
        type: "address"
      }
    ],
    name: "cancelRemoveDelegatorRequest",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "address",
        name: "_serviceProvider",
        type: "address"
      },
      {
        internalType: "address",
        name: "_delegator",
        type: "address"
      }
    ],
    name: "removeDelegator",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "address",
        name: "_serviceProvider",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "_spMinDelegationAmount",
        type: "uint256"
      }
    ],
    name: "updateSPMinDelegationAmount",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "uint256",
        name: "_duration",
        type: "uint256"
      }
    ],
    name: "updateUndelegateLockupDuration",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "uint256",
        name: "_maxDelegators",
        type: "uint256"
      }
    ],
    name: "updateMaxDelegators",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "uint256",
        name: "_minDelegationAmount",
        type: "uint256"
      }
    ],
    name: "updateMinDelegationAmount",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "uint256",
        name: "_duration",
        type: "uint256"
      }
    ],
    name: "updateRemoveDelegatorLockupDuration",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "uint256",
        name: "_duration",
        type: "uint256"
      }
    ],
    name: "updateRemoveDelegatorEvalDuration",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "address",
        name: "_governanceAddress",
        type: "address"
      }
    ],
    name: "setGovernanceAddress",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "address",
        name: "_stakingAddress",
        type: "address"
      }
    ],
    name: "setStakingAddress",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "address",
        name: "_spFactory",
        type: "address"
      }
    ],
    name: "setServiceProviderFactoryAddress",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "address",
        name: "_claimsManagerAddress",
        type: "address"
      }
    ],
    name: "setClaimsManagerAddress",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: true,
    inputs: [
      {
        internalType: "address",
        name: "_sp",
        type: "address"
      }
    ],
    name: "getDelegatorsList",
    outputs: [
      {
        internalType: "address[]",
        name: "",
        type: "address[]"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [
      {
        internalType: "address",
        name: "_delegator",
        type: "address"
      }
    ],
    name: "getTotalDelegatorStake",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [
      {
        internalType: "address",
        name: "_sp",
        type: "address"
      }
    ],
    name: "getTotalDelegatedToServiceProvider",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [
      {
        internalType: "address",
        name: "_sp",
        type: "address"
      }
    ],
    name: "getTotalLockedDelegationForServiceProvider",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [
      {
        internalType: "address",
        name: "_delegator",
        type: "address"
      },
      {
        internalType: "address",
        name: "_serviceProvider",
        type: "address"
      }
    ],
    name: "getDelegatorStakeForServiceProvider",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [
      {
        internalType: "address",
        name: "_delegator",
        type: "address"
      }
    ],
    name: "getPendingUndelegateRequest",
    outputs: [
      {
        internalType: "address",
        name: "target",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "lockupExpiryBlock",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [
      {
        internalType: "address",
        name: "_serviceProvider",
        type: "address"
      },
      {
        internalType: "address",
        name: "_delegator",
        type: "address"
      }
    ],
    name: "getPendingRemoveDelegatorRequest",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [
      {
        internalType: "address",
        name: "_serviceProvider",
        type: "address"
      }
    ],
    name: "getSPMinDelegationAmount",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "getUndelegateLockupDuration",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "getMaxDelegators",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "getMinDelegationAmount",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "getRemoveDelegatorLockupDuration",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "getRemoveDelegatorEvalDuration",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "getGovernanceAddress",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "getServiceProviderFactoryAddress",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "getClaimsManagerAddress",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "getStakingAddress",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  }
];

// node_modules/@audius/eth/dist/esm/delegate-manager/constants.js
var DELEGATE_MANAGER_CONTRACT_ADDRESS = "0x4d7968ebfD390D5E7926Cb3587C39eFf2F9FB225";

// node_modules/@audius/eth/dist/esm/delegate-manager/delegateManager.js
var DelegateManager = class {
  constructor(client, { address } = {}) {
    this.getIncreaseDelegatedStakeEvents = ({ fromBlock = BigInt(0), delegator, serviceProvider, increaseAmount }) => {
      const args = {};
      if (delegator)
        args._delegator = delegator;
      if (serviceProvider)
        args._serviceProvider = serviceProvider;
      if (increaseAmount)
        args._increaseAmount = increaseAmount;
      return this.client.getContractEvents({
        address: this.address,
        abi: abi4,
        eventName: "IncreaseDelegatedStake",
        fromBlock,
        args
      });
    };
    this.getUndelegateStakeRequestedEvents = ({ fromBlock = BigInt(0), delegator, serviceProvider }) => {
      const args = {};
      if (delegator)
        args._delegator = delegator;
      if (serviceProvider)
        args._serviceProvider = serviceProvider;
      return this.client.getContractEvents({
        address: this.address,
        abi: abi4,
        eventName: "UndelegateStakeRequested",
        fromBlock,
        args
      });
    };
    this.getUndelegateStakeRequestEvaluatedEvents = ({ fromBlock = BigInt(0), delegator, serviceProvider }) => {
      const args = {};
      if (delegator)
        args._delegator = delegator;
      if (serviceProvider)
        args._serviceProvider = serviceProvider;
      return this.client.getContractEvents({
        address: this.address,
        abi: abi4,
        eventName: "UndelegateStakeRequestEvaluated",
        fromBlock,
        args
      });
    };
    this.getUndelegateStakeRequestCancelledEvents = ({ fromBlock = BigInt(0), delegator, serviceProvider }) => {
      const args = {};
      if (delegator)
        args._delegator = delegator;
      if (serviceProvider)
        args._serviceProvider = serviceProvider;
      return this.client.getContractEvents({
        address: this.address,
        abi: abi4,
        eventName: "UndelegateStakeRequestCancelled",
        fromBlock,
        args
      });
    };
    this.getRemoveDelegatorRequestedEvents = ({ fromBlock = BigInt(0), delegator, serviceProvider }) => {
      const args = {};
      if (delegator)
        args._delegator = delegator;
      if (serviceProvider)
        args._serviceProvider = serviceProvider;
      return this.client.getContractEvents({
        address: this.address,
        abi: abi4,
        eventName: "RemoveDelegatorRequested",
        fromBlock,
        args
      });
    };
    this.getRemoveDelegatorEvaluatedEvents = ({ fromBlock = BigInt(0), delegator, serviceProvider, unstakedAmount }) => {
      const args = {};
      if (delegator)
        args._delegator = delegator;
      if (serviceProvider)
        args._serviceProvider = serviceProvider;
      if (unstakedAmount)
        args._unstakedAmount = unstakedAmount;
      return this.client.getContractEvents({
        address: this.address,
        abi: abi4,
        eventName: "RemoveDelegatorRequestEvaluated",
        fromBlock,
        args
      });
    };
    this.getRemoveDelegatorCancelledEvents = ({ fromBlock = BigInt(0), delegator, serviceProvider }) => {
      const args = {};
      if (delegator)
        args._delegator = delegator;
      if (serviceProvider)
        args._serviceProvider = serviceProvider;
      return this.client.getContractEvents({
        address: this.address,
        abi: abi4,
        eventName: "RemoveDelegatorRequestCancelled",
        fromBlock,
        args
      });
    };
    this.getClaimEvents = ({ fromBlock = BigInt(0), claimer }) => {
      const args = {};
      if (claimer)
        args._claimer = claimer;
      return this.client.getContractEvents({
        address: this.address,
        abi: abi4,
        eventName: "Claim",
        fromBlock,
        args
      });
    };
    this.getSlashEvents = ({ fromBlock = BigInt(0), target }) => {
      const args = {};
      if (target)
        args._target = target;
      return this.client.getContractEvents({
        address: this.address,
        abi: abi4,
        eventName: "Slash",
        fromBlock,
        args
      });
    };
    this.getDelegatorsList = ({ serviceProviderAddress }) => this.client.readContract({
      address: this.address,
      abi: abi4,
      functionName: "getDelegatorsList",
      args: [serviceProviderAddress]
    });
    this.getTotalDelegatedToServiceProvider = ({ serviceProviderAddress }) => this.client.readContract({
      address: this.address,
      abi: abi4,
      functionName: "getTotalDelegatedToServiceProvider",
      args: [serviceProviderAddress]
    });
    this.getTotalLockedDelegationForServiceProvider = ({ serviceProviderAddress }) => this.client.readContract({
      address: this.address,
      abi: abi4,
      functionName: "getTotalLockedDelegationForServiceProvider",
      args: [serviceProviderAddress]
    });
    this.getTotalDelegatorStake = ({ delegatorAddress }) => this.client.readContract({
      address: this.address,
      abi: abi4,
      functionName: "getTotalDelegatorStake",
      args: [delegatorAddress]
    });
    this.getDelegatorStakeForServiceProvider = ({ delegatorAddress, serviceProviderAddress }) => this.client.readContract({
      address: this.address,
      abi: abi4,
      functionName: "getDelegatorStakeForServiceProvider",
      args: [delegatorAddress, serviceProviderAddress]
    });
    this.getPendingRemoveDelegatorRequest = ({ delegatorAddress, serviceProviderAddress }) => this.client.readContract({
      address: this.address,
      abi: abi4,
      functionName: "getPendingRemoveDelegatorRequest",
      args: [serviceProviderAddress, delegatorAddress]
    });
    this.getPendingUndelegateRequest = ({ delegatorAddress }) => this.client.readContract({
      address: this.address,
      abi: abi4,
      functionName: "getPendingUndelegateRequest",
      args: [delegatorAddress]
    });
    this.getUndelegateLockupDuration = () => this.client.readContract({
      address: this.address,
      abi: abi4,
      functionName: "getUndelegateLockupDuration"
    });
    this.getMaxDelegators = () => this.client.readContract({
      address: this.address,
      abi: abi4,
      functionName: "getMaxDelegators"
    });
    this.getMinDelegationAmount = () => this.client.readContract({
      address: this.address,
      abi: abi4,
      functionName: "getMinDelegationAmount"
    });
    this.getRemoveDelegatorLockupDuration = () => this.client.readContract({
      address: this.address,
      abi: abi4,
      functionName: "getRemoveDelegatorLockupDuration"
    });
    this.getRemoveDelegatorEvalDuration = () => this.client.readContract({
      address: this.address,
      abi: abi4,
      functionName: "getRemoveDelegatorEvalDuration"
    });
    this.getGovernanceAddress = () => this.client.readContract({
      address: this.address,
      abi: abi4,
      functionName: "getGovernanceAddress"
    });
    this.getServiceProviderFactoryAddress = () => this.client.readContract({
      address: this.address,
      abi: abi4,
      functionName: "getServiceProviderFactoryAddress"
    });
    this.getClaimsManagerAddress = () => this.client.readContract({
      address: this.address,
      abi: abi4,
      functionName: "getClaimsManagerAddress"
    });
    this.getStakingAddress = () => this.client.readContract({
      address: this.address,
      abi: abi4,
      functionName: "getStakingAddress"
    });
    this.getSPMinDelegationAmount = ({ serviceProviderAddress }) => this.client.readContract({
      address: this.address,
      abi: abi4,
      functionName: "getSPMinDelegationAmount",
      args: [serviceProviderAddress]
    });
    this.client = client;
    this.address = address ?? DELEGATE_MANAGER_CONTRACT_ADDRESS;
  }
};

// node_modules/@audius/eth/dist/esm/eth-rewards-manager/abi.js
var abi5 = [
  {
    constant: false,
    inputs: [],
    name: "initialize",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "address",
        name: "_tokenAddress",
        type: "address"
      },
      {
        internalType: "address",
        name: "_governanceAddress",
        type: "address"
      },
      {
        internalType: "address",
        name: "_wormholeAddress",
        type: "address"
      },
      {
        internalType: "bytes32",
        name: "_recipient",
        type: "bytes32"
      },
      {
        internalType: "address[]",
        name: "_antiAbuseOracleAddresses",
        type: "address[]"
      }
    ],
    name: "initialize",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "address",
        name: "_governanceAddress",
        type: "address"
      }
    ],
    name: "setGovernanceAddress",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "bytes32",
        name: "_recipient",
        type: "bytes32"
      }
    ],
    name: "setRecipientAddress",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "address[]",
        name: "_antiAbuseOracleAddresses",
        type: "address[]"
      }
    ],
    name: "setAntiAbuseOracleAddresses",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "uint256",
        name: "arbiterFee",
        type: "uint256"
      },
      {
        internalType: "uint32",
        name: "_nonce",
        type: "uint32"
      }
    ],
    name: "transferToSolana",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "token",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "getGovernanceAddress",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "getRecipientAddress",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "getAntiAbuseOracleAddresses",
    outputs: [
      {
        internalType: "address[]",
        name: "",
        type: "address[]"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  }
];

// node_modules/@audius/eth/dist/esm/eth-rewards-manager/constants.js
var ETH_REWARDS_MANAGER_CONTRACT_ADDRESS = "0x5aa6B99A2B461bA8E97207740f0A689C5C39C3b0";

// node_modules/@audius/eth/dist/esm/eth-rewards-manager/ethRewardsManager.js
var EthRewardsManager = class {
  constructor(client, { address } = {}) {
    this.getAntiAbuseOracleAddresses = () => this.client.readContract({
      address: this.address,
      abi: abi5,
      functionName: "getAntiAbuseOracleAddresses"
    });
    this.client = client;
    this.address = address ?? ETH_REWARDS_MANAGER_CONTRACT_ADDRESS;
  }
};

// node_modules/@audius/eth/dist/esm/governance/abi.js
var abi6 = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "_newExecutionDelay",
        type: "uint256"
      }
    ],
    name: "ExecutionDelayUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "_targetContractAddress",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "_callValue",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "string",
        name: "_functionSignature",
        type: "string"
      },
      {
        indexed: true,
        internalType: "bytes",
        name: "_callData",
        type: "bytes"
      },
      {
        indexed: false,
        internalType: "bytes",
        name: "_returnData",
        type: "bytes"
      }
    ],
    name: "GuardianTransactionExecuted",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "_newGuardianAddress",
        type: "address"
      }
    ],
    name: "GuardianshipTransferred",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "_newMaxInProgressProposals",
        type: "uint256"
      }
    ],
    name: "MaxInProgressProposalsUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "_proposalId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "enum Governance.Outcome",
        name: "_outcome",
        type: "uint8"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "_voteMagnitudeYes",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "_voteMagnitudeNo",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "_numVotes",
        type: "uint256"
      }
    ],
    name: "ProposalOutcomeEvaluated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "_proposalId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "_proposer",
        type: "address"
      },
      {
        indexed: false,
        internalType: "string",
        name: "_name",
        type: "string"
      },
      {
        indexed: false,
        internalType: "string",
        name: "_description",
        type: "string"
      }
    ],
    name: "ProposalSubmitted",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "_proposalId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "bool",
        name: "_success",
        type: "bool"
      },
      {
        indexed: false,
        internalType: "bytes",
        name: "_returnData",
        type: "bytes"
      }
    ],
    name: "ProposalTransactionExecuted",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "_proposalId",
        type: "uint256"
      }
    ],
    name: "ProposalVetoed",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "_proposalId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "_voter",
        type: "address"
      },
      {
        indexed: true,
        internalType: "enum Governance.Vote",
        name: "_vote",
        type: "uint8"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "_voterStake",
        type: "uint256"
      }
    ],
    name: "ProposalVoteSubmitted",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "_proposalId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "_voter",
        type: "address"
      },
      {
        indexed: true,
        internalType: "enum Governance.Vote",
        name: "_vote",
        type: "uint8"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "_voterStake",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "enum Governance.Vote",
        name: "_previousVote",
        type: "uint8"
      }
    ],
    name: "ProposalVoteUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "_newRegistryAddress",
        type: "address"
      }
    ],
    name: "RegistryAddressUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "_newVotingPeriod",
        type: "uint256"
      }
    ],
    name: "VotingPeriodUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "_newVotingQuorumPercent",
        type: "uint256"
      }
    ],
    name: "VotingQuorumPercentUpdated",
    type: "event"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "address",
        name: "_registryAddress",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "_votingPeriod",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "_executionDelay",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "_votingQuorumPercent",
        type: "uint256"
      },
      {
        internalType: "uint16",
        name: "_maxInProgressProposals",
        type: "uint16"
      },
      {
        internalType: "address",
        name: "_guardianAddress",
        type: "address"
      }
    ],
    name: "initialize",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [],
    name: "initialize",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "bytes32",
        name: "_targetContractRegistryKey",
        type: "bytes32"
      },
      {
        internalType: "uint256",
        name: "_callValue",
        type: "uint256"
      },
      {
        internalType: "string",
        name: "_functionSignature",
        type: "string"
      },
      {
        internalType: "bytes",
        name: "_callData",
        type: "bytes"
      },
      {
        internalType: "string",
        name: "_name",
        type: "string"
      },
      {
        internalType: "string",
        name: "_description",
        type: "string"
      }
    ],
    name: "submitProposal",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "uint256",
        name: "_proposalId",
        type: "uint256"
      },
      {
        internalType: "enum Governance.Vote",
        name: "_vote",
        type: "uint8"
      }
    ],
    name: "submitVote",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "uint256",
        name: "_proposalId",
        type: "uint256"
      },
      {
        internalType: "enum Governance.Vote",
        name: "_vote",
        type: "uint8"
      }
    ],
    name: "updateVote",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "uint256",
        name: "_proposalId",
        type: "uint256"
      }
    ],
    name: "evaluateProposalOutcome",
    outputs: [
      {
        internalType: "enum Governance.Outcome",
        name: "",
        type: "uint8"
      }
    ],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "uint256",
        name: "_proposalId",
        type: "uint256"
      }
    ],
    name: "vetoProposal",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "address",
        name: "_stakingAddress",
        type: "address"
      }
    ],
    name: "setStakingAddress",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "address",
        name: "_serviceProviderFactoryAddress",
        type: "address"
      }
    ],
    name: "setServiceProviderFactoryAddress",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "address",
        name: "_delegateManagerAddress",
        type: "address"
      }
    ],
    name: "setDelegateManagerAddress",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "uint256",
        name: "_votingPeriod",
        type: "uint256"
      }
    ],
    name: "setVotingPeriod",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "uint256",
        name: "_votingQuorumPercent",
        type: "uint256"
      }
    ],
    name: "setVotingQuorumPercent",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "address",
        name: "_registryAddress",
        type: "address"
      }
    ],
    name: "setRegistryAddress",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "uint16",
        name: "_newMaxInProgressProposals",
        type: "uint16"
      }
    ],
    name: "setMaxInProgressProposals",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "uint256",
        name: "_newExecutionDelay",
        type: "uint256"
      }
    ],
    name: "setExecutionDelay",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "bytes32",
        name: "_targetContractRegistryKey",
        type: "bytes32"
      },
      {
        internalType: "uint256",
        name: "_callValue",
        type: "uint256"
      },
      {
        internalType: "string",
        name: "_functionSignature",
        type: "string"
      },
      {
        internalType: "bytes",
        name: "_callData",
        type: "bytes"
      }
    ],
    name: "guardianExecuteTransaction",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "address",
        name: "_newGuardianAddress",
        type: "address"
      }
    ],
    name: "transferGuardianship",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: true,
    inputs: [
      {
        internalType: "uint256",
        name: "_proposalId",
        type: "uint256"
      }
    ],
    name: "getProposalById",
    outputs: [
      {
        internalType: "uint256",
        name: "proposalId",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "proposer",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "submissionBlockNumber",
        type: "uint256"
      },
      {
        internalType: "bytes32",
        name: "targetContractRegistryKey",
        type: "bytes32"
      },
      {
        internalType: "address",
        name: "targetContractAddress",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "callValue",
        type: "uint256"
      },
      {
        internalType: "string",
        name: "functionSignature",
        type: "string"
      },
      {
        internalType: "bytes",
        name: "callData",
        type: "bytes"
      },
      {
        internalType: "enum Governance.Outcome",
        name: "outcome",
        type: "uint8"
      },
      {
        internalType: "uint256",
        name: "voteMagnitudeYes",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "voteMagnitudeNo",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "numVotes",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [
      {
        internalType: "uint256",
        name: "_proposalId",
        type: "uint256"
      }
    ],
    name: "getProposalTargetContractHash",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [
      {
        internalType: "uint256",
        name: "_proposalId",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "_voter",
        type: "address"
      }
    ],
    name: "getVoteInfoByProposalAndVoter",
    outputs: [
      {
        internalType: "enum Governance.Vote",
        name: "vote",
        type: "uint8"
      },
      {
        internalType: "uint256",
        name: "voteMagnitude",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "getGuardianAddress",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "getStakingAddress",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "getServiceProviderFactoryAddress",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "getDelegateManagerAddress",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "getVotingPeriod",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "getVotingQuorumPercent",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "getRegistryAddress",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "isGovernanceAddress",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    payable: false,
    stateMutability: "pure",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "getMaxInProgressProposals",
    outputs: [
      {
        internalType: "uint16",
        name: "",
        type: "uint16"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "getExecutionDelay",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "getInProgressProposals",
    outputs: [
      {
        internalType: "uint256[]",
        name: "",
        type: "uint256[]"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "inProgressProposalsAreUpToDate",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  }
];

// node_modules/@audius/eth/dist/esm/governance/constants.js
var GOVERNANCE_CONTRACT_ADDRESS = "0x4DEcA517D6817B6510798b7328F2314d3003AbAC";

// node_modules/@audius/eth/dist/esm/governance/governance.js
var Governance = class {
  constructor(client, { address } = {}) {
    this.getVotingPeriod = () => this.client.readContract({
      address: this.address,
      abi: abi6,
      functionName: "getVotingPeriod"
    });
    this.getVotingQuorumPercent = () => this.client.readContract({
      address: this.address,
      abi: abi6,
      functionName: "getVotingQuorumPercent"
    });
    this.getExecutionDelay = () => this.client.readContract({
      address: this.address,
      abi: abi6,
      functionName: "getExecutionDelay"
    });
    this.getProposalById = ({ id }) => this.client.readContract({
      address: this.address,
      abi: abi6,
      functionName: "getProposalById",
      args: [id]
    });
    this.getProposalTargetContractHash = ({ id }) => this.client.readContract({
      address: this.address,
      abi: abi6,
      functionName: "getProposalTargetContractHash",
      args: [id]
    });
    this.getInProgressProposals = () => this.client.readContract({
      address: this.address,
      abi: abi6,
      functionName: "getInProgressProposals"
    });
    this.getVoteInfoByProposalAndVoter = ({ id, voterAddress }) => this.client.readContract({
      address: this.address,
      abi: abi6,
      functionName: "getVoteInfoByProposalAndVoter",
      args: [id, voterAddress]
    });
    this.getProposalSubmittedEvents = ({ fromBlock = BigInt(0), proposalId, proposer }) => {
      const args = {};
      if (proposalId)
        args._proposalId = proposalId;
      if (proposer)
        args._proposer = proposer;
      return this.client.getContractEvents({
        address: this.address,
        abi: abi6,
        eventName: "ProposalSubmitted",
        fromBlock,
        args
      });
    };
    this.getProposalOutcomeEvaluatedEvents = ({ fromBlock = BigInt(0), proposalId }) => {
      const args = {};
      if (proposalId)
        args._proposalId = proposalId;
      return this.client.getContractEvents({
        address: this.address,
        abi: abi6,
        eventName: "ProposalOutcomeEvaluated",
        fromBlock,
        args
      });
    };
    this.getProposalVoteSubmittedEvents = ({ fromBlock = BigInt(0), proposalId, voter }) => {
      const args = {};
      if (proposalId)
        args._proposalId = proposalId;
      if (voter)
        args._voter = voter;
      return this.client.getContractEvents({
        address: this.address,
        abi: abi6,
        eventName: "ProposalVoteSubmitted",
        fromBlock,
        args
      });
    };
    this.getProposalVoteUpdatedEvents = ({ fromBlock = BigInt(0), proposalId, voter }) => {
      const args = {};
      if (proposalId)
        args._proposalId = proposalId;
      if (voter)
        args._voter = voter;
      return this.client.getContractEvents({
        address: this.address,
        abi: abi6,
        eventName: "ProposalVoteUpdated",
        fromBlock,
        args
      });
    };
    this.client = client;
    this.address = address ?? GOVERNANCE_CONTRACT_ADDRESS;
  }
};

// node_modules/@audius/eth/dist/esm/registry/abi.js
var abi7 = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "_name",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "address",
        name: "_address",
        type: "address"
      }
    ],
    name: "ContractAdded",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "_name",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "address",
        name: "_address",
        type: "address"
      }
    ],
    name: "ContractRemoved",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "_name",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "address",
        name: "_oldAddress",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "_newAddress",
        type: "address"
      }
    ],
    name: "ContractUpgraded",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "previousOwner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "newOwner",
        type: "address"
      }
    ],
    name: "OwnershipTransferred",
    type: "event"
  },
  {
    constant: true,
    inputs: [],
    name: "isOwner",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "owner",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: false,
    inputs: [],
    name: "renounceOwnership",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "address",
        name: "newOwner",
        type: "address"
      }
    ],
    name: "transferOwnership",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [],
    name: "initialize",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "address",
        name: "sender",
        type: "address"
      }
    ],
    name: "initialize",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "bytes32",
        name: "_name",
        type: "bytes32"
      },
      {
        internalType: "address",
        name: "_address",
        type: "address"
      }
    ],
    name: "addContract",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "bytes32",
        name: "_name",
        type: "bytes32"
      }
    ],
    name: "removeContract",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "bytes32",
        name: "_name",
        type: "bytes32"
      },
      {
        internalType: "address",
        name: "_newAddress",
        type: "address"
      }
    ],
    name: "upgradeContract",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: true,
    inputs: [
      {
        internalType: "bytes32",
        name: "_name",
        type: "bytes32"
      },
      {
        internalType: "uint256",
        name: "_version",
        type: "uint256"
      }
    ],
    name: "getContract",
    outputs: [
      {
        internalType: "address",
        name: "contractAddr",
        type: "address"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [
      {
        internalType: "bytes32",
        name: "_name",
        type: "bytes32"
      }
    ],
    name: "getContract",
    outputs: [
      {
        internalType: "address",
        name: "contractAddr",
        type: "address"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [
      {
        internalType: "bytes32",
        name: "_name",
        type: "bytes32"
      }
    ],
    name: "getContractVersionCount",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  }
];

// node_modules/@audius/eth/dist/esm/registry/constants.js
var REGISTRY_CONTRACT_ADDRESS = "0xd976d3b4f4e22a238c1A736b6612D22f17b6f64C";

// node_modules/@audius/eth/dist/esm/registry/registry.js
var Registry = class {
  constructor(client, { address } = {}) {
    this.getContract = ({ registryKey }) => this.client.readContract({
      address: this.address,
      abi: abi7,
      functionName: "getContract",
      args: [registryKey]
    });
    this.client = client;
    this.address = address ?? REGISTRY_CONTRACT_ADDRESS;
  }
};

// node_modules/@audius/eth/dist/esm/service-provider-factory/abi.js
var abi8 = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "_newClaimsManagerAddress",
        type: "address"
      }
    ],
    name: "ClaimsManagerAddressUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "_lockupDuration",
        type: "uint256"
      }
    ],
    name: "DecreaseStakeLockupDurationUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "_owner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "_decreaseAmount",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "_lockupExpiryBlock",
        type: "uint256"
      }
    ],
    name: "DecreaseStakeRequestCancelled",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "_owner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "_decreaseAmount",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "_newStakeAmount",
        type: "uint256"
      }
    ],
    name: "DecreaseStakeRequestEvaluated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "_owner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "_decreaseAmount",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "_lockupExpiryBlock",
        type: "uint256"
      }
    ],
    name: "DecreaseStakeRequested",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "_newDelegateManagerAddress",
        type: "address"
      }
    ],
    name: "DelegateManagerAddressUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "_owner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "bytes32",
        name: "_serviceType",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "_spID",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "address",
        name: "_updatedWallet",
        type: "address"
      }
    ],
    name: "DelegateOwnerWalletUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "_owner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "_requestedCut",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "_finalCut",
        type: "uint256"
      }
    ],
    name: "DeployerCutUpdateRequestCancelled",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "_owner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "_updatedCut",
        type: "uint256"
      }
    ],
    name: "DeployerCutUpdateRequestEvaluated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "_owner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "_updatedCut",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "_lockupExpiryBlock",
        type: "uint256"
      }
    ],
    name: "DeployerCutUpdateRequested",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "_spID",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "bytes32",
        name: "_serviceType",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "address",
        name: "_owner",
        type: "address"
      },
      {
        indexed: false,
        internalType: "string",
        name: "_endpoint",
        type: "string"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "_unstakeAmount",
        type: "uint256"
      }
    ],
    name: "DeregisteredServiceProvider",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "_serviceType",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "address",
        name: "_owner",
        type: "address"
      },
      {
        indexed: false,
        internalType: "string",
        name: "_oldEndpoint",
        type: "string"
      },
      {
        indexed: false,
        internalType: "string",
        name: "_newEndpoint",
        type: "string"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "_spID",
        type: "uint256"
      }
    ],
    name: "EndpointUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "_newGovernanceAddress",
        type: "address"
      }
    ],
    name: "GovernanceAddressUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "_owner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "_increaseAmount",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "_newStakeAmount",
        type: "uint256"
      }
    ],
    name: "IncreasedStake",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "_spID",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "bytes32",
        name: "_serviceType",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "address",
        name: "_owner",
        type: "address"
      },
      {
        indexed: false,
        internalType: "string",
        name: "_endpoint",
        type: "string"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "_stakeAmount",
        type: "uint256"
      }
    ],
    name: "RegisteredServiceProvider",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "_newServiceTypeManagerAddress",
        type: "address"
      }
    ],
    name: "ServiceTypeManagerAddressUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "_newStakingAddress",
        type: "address"
      }
    ],
    name: "StakingAddressUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "_lockupDuration",
        type: "uint256"
      }
    ],
    name: "UpdateDeployerCutLockupDurationUpdated",
    type: "event"
  },
  {
    constant: false,
    inputs: [],
    name: "initialize",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "address",
        name: "_governanceAddress",
        type: "address"
      },
      {
        internalType: "address",
        name: "_claimsManagerAddress",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "_decreaseStakeLockupDuration",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "_deployerCutLockupDuration",
        type: "uint256"
      }
    ],
    name: "initialize",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "bytes32",
        name: "_serviceType",
        type: "bytes32"
      },
      {
        internalType: "string",
        name: "_endpoint",
        type: "string"
      },
      {
        internalType: "uint256",
        name: "_stakeAmount",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "_delegateOwnerWallet",
        type: "address"
      }
    ],
    name: "register",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "bytes32",
        name: "_serviceType",
        type: "bytes32"
      },
      {
        internalType: "string",
        name: "_endpoint",
        type: "string"
      }
    ],
    name: "deregister",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "uint256",
        name: "_increaseStakeAmount",
        type: "uint256"
      }
    ],
    name: "increaseStake",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "uint256",
        name: "_decreaseStakeAmount",
        type: "uint256"
      }
    ],
    name: "requestDecreaseStake",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "address",
        name: "_account",
        type: "address"
      }
    ],
    name: "cancelDecreaseStakeRequest",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [],
    name: "decreaseStake",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "bytes32",
        name: "_serviceType",
        type: "bytes32"
      },
      {
        internalType: "string",
        name: "_endpoint",
        type: "string"
      },
      {
        internalType: "address",
        name: "_updatedDelegateOwnerWallet",
        type: "address"
      }
    ],
    name: "updateDelegateOwnerWallet",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "bytes32",
        name: "_serviceType",
        type: "bytes32"
      },
      {
        internalType: "string",
        name: "_oldEndpoint",
        type: "string"
      },
      {
        internalType: "string",
        name: "_newEndpoint",
        type: "string"
      }
    ],
    name: "updateEndpoint",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "address",
        name: "_serviceProvider",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "_cut",
        type: "uint256"
      }
    ],
    name: "requestUpdateDeployerCut",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "address",
        name: "_serviceProvider",
        type: "address"
      }
    ],
    name: "cancelUpdateDeployerCut",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "address",
        name: "_serviceProvider",
        type: "address"
      }
    ],
    name: "updateDeployerCut",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "address",
        name: "_serviceProvider",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "_amount",
        type: "uint256"
      }
    ],
    name: "updateServiceProviderStake",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "uint256",
        name: "_duration",
        type: "uint256"
      }
    ],
    name: "updateDecreaseStakeLockupDuration",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "uint256",
        name: "_duration",
        type: "uint256"
      }
    ],
    name: "updateDeployerCutLockupDuration",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "getServiceProviderDeployerCutBase",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "getDeployerCutLockupDuration",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [
      {
        internalType: "bytes32",
        name: "_serviceType",
        type: "bytes32"
      }
    ],
    name: "getTotalServiceTypeProviders",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [
      {
        internalType: "string",
        name: "_endpoint",
        type: "string"
      }
    ],
    name: "getServiceProviderIdFromEndpoint",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [
      {
        internalType: "address",
        name: "_ownerAddress",
        type: "address"
      },
      {
        internalType: "bytes32",
        name: "_serviceType",
        type: "bytes32"
      }
    ],
    name: "getServiceProviderIdsFromAddress",
    outputs: [
      {
        internalType: "uint256[]",
        name: "",
        type: "uint256[]"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [
      {
        internalType: "bytes32",
        name: "_serviceType",
        type: "bytes32"
      },
      {
        internalType: "uint256",
        name: "_serviceId",
        type: "uint256"
      }
    ],
    name: "getServiceEndpointInfo",
    outputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        internalType: "string",
        name: "endpoint",
        type: "string"
      },
      {
        internalType: "uint256",
        name: "blockNumber",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "delegateOwnerWallet",
        type: "address"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [
      {
        internalType: "address",
        name: "_serviceProvider",
        type: "address"
      }
    ],
    name: "getServiceProviderDetails",
    outputs: [
      {
        internalType: "uint256",
        name: "deployerStake",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "deployerCut",
        type: "uint256"
      },
      {
        internalType: "bool",
        name: "validBounds",
        type: "bool"
      },
      {
        internalType: "uint256",
        name: "numberOfEndpoints",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "minAccountStake",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "maxAccountStake",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [
      {
        internalType: "address",
        name: "_serviceProvider",
        type: "address"
      }
    ],
    name: "getPendingDecreaseStakeRequest",
    outputs: [
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "lockupExpiryBlock",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [
      {
        internalType: "address",
        name: "_serviceProvider",
        type: "address"
      }
    ],
    name: "getPendingUpdateDeployerCutRequest",
    outputs: [
      {
        internalType: "uint256",
        name: "newDeployerCut",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "lockupExpiryBlock",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "getDecreaseStakeLockupDuration",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [
      {
        internalType: "address",
        name: "_serviceProvider",
        type: "address"
      }
    ],
    name: "validateAccountStakeBalance",
    outputs: [],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "getGovernanceAddress",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "getStakingAddress",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "getDelegateManagerAddress",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "getServiceTypeManagerAddress",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "getClaimsManagerAddress",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "address",
        name: "_governanceAddress",
        type: "address"
      }
    ],
    name: "setGovernanceAddress",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "address",
        name: "_address",
        type: "address"
      }
    ],
    name: "setStakingAddress",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "address",
        name: "_address",
        type: "address"
      }
    ],
    name: "setDelegateManagerAddress",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "address",
        name: "_address",
        type: "address"
      }
    ],
    name: "setServiceTypeManagerAddress",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "address",
        name: "_address",
        type: "address"
      }
    ],
    name: "setClaimsManagerAddress",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  }
];

// node_modules/@audius/eth/dist/esm/service-provider-factory/constants.js
var SERVICE_PROVIDER_FACTORY_CONTRACT_ADDRESS = "0xD17A9bc90c582249e211a4f4b16721e7f65156c8";

// node_modules/@audius/eth/dist/esm/service-provider-factory/serviceProviderFactory.js
var ServiceProviderFactory = class {
  constructor(client, { address } = {}) {
    this.getTotalServiceTypeProviders = ({ serviceType }) => this.client.readContract({
      address: this.address,
      abi: abi8,
      functionName: "getTotalServiceTypeProviders",
      args: [serviceType]
    });
    this.getServiceEndpointInfo = ({ serviceType, index: index4 }) => this.client.readContract({
      address: this.address,
      abi: abi8,
      functionName: "getServiceEndpointInfo",
      args: [serviceType, index4]
    });
    this.client = client;
    this.address = address ?? SERVICE_PROVIDER_FACTORY_CONTRACT_ADDRESS;
  }
};

// node_modules/@audius/eth/dist/esm/service-type-manager/abi.js
var abi9 = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "_serviceType",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "_serviceTypeMin",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "_serviceTypeMax",
        type: "uint256"
      }
    ],
    name: "ServiceTypeAdded",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "_serviceType",
        type: "bytes32"
      }
    ],
    name: "ServiceTypeRemoved",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "_serviceType",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "bytes32",
        name: "_serviceVersion",
        type: "bytes32"
      }
    ],
    name: "SetServiceVersion",
    type: "event"
  },
  {
    constant: false,
    inputs: [],
    name: "initialize",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "address",
        name: "_governanceAddress",
        type: "address"
      }
    ],
    name: "initialize",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "getGovernanceAddress",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "address",
        name: "_governanceAddress",
        type: "address"
      }
    ],
    name: "setGovernanceAddress",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "bytes32",
        name: "_serviceType",
        type: "bytes32"
      },
      {
        internalType: "uint256",
        name: "_serviceTypeMin",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "_serviceTypeMax",
        type: "uint256"
      }
    ],
    name: "addServiceType",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "bytes32",
        name: "_serviceType",
        type: "bytes32"
      }
    ],
    name: "removeServiceType",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: true,
    inputs: [
      {
        internalType: "bytes32",
        name: "_serviceType",
        type: "bytes32"
      }
    ],
    name: "getServiceTypeInfo",
    outputs: [
      {
        internalType: "bool",
        name: "isValid",
        type: "bool"
      },
      {
        internalType: "uint256",
        name: "minStake",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "maxStake",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "getValidServiceTypes",
    outputs: [
      {
        internalType: "bytes32[]",
        name: "",
        type: "bytes32[]"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [
      {
        internalType: "bytes32",
        name: "_serviceType",
        type: "bytes32"
      }
    ],
    name: "serviceTypeIsValid",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "bytes32",
        name: "_serviceType",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "_serviceVersion",
        type: "bytes32"
      }
    ],
    name: "setServiceVersion",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: true,
    inputs: [
      {
        internalType: "bytes32",
        name: "_serviceType",
        type: "bytes32"
      },
      {
        internalType: "uint256",
        name: "_versionIndex",
        type: "uint256"
      }
    ],
    name: "getVersion",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [
      {
        internalType: "bytes32",
        name: "_serviceType",
        type: "bytes32"
      }
    ],
    name: "getCurrentVersion",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [
      {
        internalType: "bytes32",
        name: "_serviceType",
        type: "bytes32"
      }
    ],
    name: "getNumberOfVersions",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [
      {
        internalType: "bytes32",
        name: "_serviceType",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "_serviceVersion",
        type: "bytes32"
      }
    ],
    name: "serviceVersionIsValid",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  }
];

// node_modules/@audius/eth/dist/esm/service-type-manager/constants.js
var SERVICE_TYPE_MANAGER_CONTRACT_ADDRESS = "0x9EfB0f4F38aFbb4b0984D00C126E97E21b8417C5";

// node_modules/@audius/eth/dist/esm/service-type-manager/serviceTypeManager.js
var ServiceTypeManager = class {
  constructor(client, { address } = {}) {
    this.getGovernanceAddress = () => this.client.readContract({
      address: this.address,
      abi: abi9,
      functionName: "getGovernanceAddress"
    });
    this.getServiceTypeInfo = ({ serviceType }) => this.client.readContract({
      address: this.address,
      abi: abi9,
      functionName: "getServiceTypeInfo",
      args: [serviceType]
    });
    this.getValidServiceTypes = () => this.client.readContract({
      address: this.address,
      abi: abi9,
      functionName: "getValidServiceTypes"
    });
    this.serviceTypeIsValid = ({ serviceType }) => this.client.readContract({
      address: this.address,
      abi: abi9,
      functionName: "serviceTypeIsValid",
      args: [serviceType]
    });
    this.getVersion = ({ serviceType, versionIndex }) => this.client.readContract({
      address: this.address,
      abi: abi9,
      functionName: "getVersion",
      args: [serviceType, versionIndex]
    });
    this.getCurrentVersion = ({ serviceType }) => this.client.readContract({
      address: this.address,
      abi: abi9,
      functionName: "getCurrentVersion",
      args: [serviceType]
    });
    this.getNumberOfVersions = ({ serviceType }) => this.client.readContract({
      address: this.address,
      abi: abi9,
      functionName: "getNumberOfVersions",
      args: [serviceType]
    });
    this.setGovernanceAddress = null;
    this.addServiceType = null;
    this.removeServiceType = null;
    this.setServiceVersion = null;
    this.serviceVersionIsValid = null;
    this.client = client;
    this.address = address ?? SERVICE_TYPE_MANAGER_CONTRACT_ADDRESS;
  }
};

// node_modules/@audius/eth/dist/esm/staking/abi.js
var abi10 = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "user",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "total",
        type: "uint256"
      }
    ],
    name: "Slashed",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "user",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "total",
        type: "uint256"
      }
    ],
    name: "Staked",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "user",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "total",
        type: "uint256"
      }
    ],
    name: "Unstaked",
    type: "event"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "address",
        name: "_tokenAddress",
        type: "address"
      },
      {
        internalType: "address",
        name: "_governanceAddress",
        type: "address"
      }
    ],
    name: "initialize",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [],
    name: "initialize",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "address",
        name: "_governanceAddress",
        type: "address"
      }
    ],
    name: "setGovernanceAddress",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "address",
        name: "_claimsManager",
        type: "address"
      }
    ],
    name: "setClaimsManagerAddress",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "address",
        name: "_spFactory",
        type: "address"
      }
    ],
    name: "setServiceProviderFactoryAddress",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "address",
        name: "_delegateManager",
        type: "address"
      }
    ],
    name: "setDelegateManagerAddress",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "uint256",
        name: "_amount",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "_stakerAccount",
        type: "address"
      }
    ],
    name: "stakeRewards",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "uint256",
        name: "_amount",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "_stakerAccount",
        type: "address"
      }
    ],
    name: "updateClaimHistory",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "uint256",
        name: "_amount",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "_slashAddress",
        type: "address"
      }
    ],
    name: "slash",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "address",
        name: "_accountAddress",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "_amount",
        type: "uint256"
      }
    ],
    name: "stakeFor",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "address",
        name: "_accountAddress",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "_amount",
        type: "uint256"
      }
    ],
    name: "unstakeFor",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "address",
        name: "_accountAddress",
        type: "address"
      },
      {
        internalType: "address",
        name: "_delegatorAddress",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "_amount",
        type: "uint256"
      }
    ],
    name: "delegateStakeFor",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "address",
        name: "_accountAddress",
        type: "address"
      },
      {
        internalType: "address",
        name: "_delegatorAddress",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "_amount",
        type: "uint256"
      }
    ],
    name: "undelegateStakeFor",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "token",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "supportsHistory",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [
      {
        internalType: "address",
        name: "_accountAddress",
        type: "address"
      }
    ],
    name: "lastStakedFor",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [
      {
        internalType: "address",
        name: "_accountAddress",
        type: "address"
      }
    ],
    name: "lastClaimedFor",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [
      {
        internalType: "address",
        name: "_accountAddress",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "_blockNumber",
        type: "uint256"
      }
    ],
    name: "totalStakedForAt",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [
      {
        internalType: "uint256",
        name: "_blockNumber",
        type: "uint256"
      }
    ],
    name: "totalStakedAt",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "getGovernanceAddress",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "getClaimsManagerAddress",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "getServiceProviderFactoryAddress",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "getDelegateManagerAddress",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [
      {
        internalType: "address",
        name: "_accountAddress",
        type: "address"
      }
    ],
    name: "isStaker",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [
      {
        internalType: "address",
        name: "_accountAddress",
        type: "address"
      }
    ],
    name: "totalStakedFor",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "totalStaked",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  }
];

// node_modules/@audius/eth/dist/esm/staking/constants.js
var STAKING_CONTRACT_ADDRESS = "0xe6D97B2099F142513be7A2a068bE040656Ae4591";

// node_modules/@audius/eth/dist/esm/staking/staking.js
var Staking = class {
  constructor(client, { address } = {}) {
    this.token = () => this.client.readContract({
      address: this.address,
      abi: abi10,
      functionName: "token"
    });
    this.totalStaked = () => this.client.readContract({
      address: this.address,
      abi: abi10,
      functionName: "totalStaked"
    });
    this.supportsHistory = () => this.client.readContract({
      address: this.address,
      abi: abi10,
      functionName: "supportsHistory"
    });
    this.totalStakedFor = ({ account }) => this.client.readContract({
      address: this.address,
      abi: abi10,
      functionName: "totalStakedFor",
      args: [account]
    });
    this.totalStakedAt = ({ blockNumber }) => this.client.readContract({
      address: this.address,
      abi: abi10,
      functionName: "totalStakedAt",
      args: [blockNumber]
    });
    this.totalStakedForAt = ({ account, blockNumber }) => this.client.readContract({
      address: this.address,
      abi: abi10,
      functionName: "totalStakedForAt",
      args: [account, blockNumber]
    });
    this.isStaker = ({ account }) => this.client.readContract({
      address: this.address,
      abi: abi10,
      functionName: "isStaker",
      args: [account]
    });
    this.lastClaimedFor = ({ account }) => this.client.readContract({
      address: this.address,
      abi: abi10,
      functionName: "lastClaimedFor",
      args: [account]
    });
    this.getDelegateManagerAddress = () => this.client.readContract({
      address: this.address,
      abi: abi10,
      functionName: "getDelegateManagerAddress"
    });
    this.getClaimsManagerAddress = () => this.client.readContract({
      address: this.address,
      abi: abi10,
      functionName: "getClaimsManagerAddress"
    });
    this.getServiceProviderFactoryAddress = () => this.client.readContract({
      address: this.address,
      abi: abi10,
      functionName: "getServiceProviderFactoryAddress"
    });
    this.getGovernanceAddress = () => this.client.readContract({
      address: this.address,
      abi: abi10,
      functionName: "getGovernanceAddress"
    });
    this.client = client;
    this.address = address ?? STAKING_CONTRACT_ADDRESS;
  }
};

// node_modules/@audius/eth/dist/esm/trusted-notifier-manager/abi.js
var abi11 = [
  {
    constant: false,
    inputs: [
      {
        internalType: "address",
        name: "_governanceAddress",
        type: "address"
      },
      {
        internalType: "address",
        name: "_initialNotifierWallet",
        type: "address"
      },
      {
        internalType: "string",
        name: "_initialNotiferEndpoint",
        type: "string"
      },
      {
        internalType: "string",
        name: "_initialNotiferEmail",
        type: "string"
      }
    ],
    name: "initialize",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [],
    name: "initialize",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "address",
        name: "_wallet",
        type: "address"
      },
      {
        internalType: "string",
        name: "_endpoint",
        type: "string"
      },
      {
        internalType: "string",
        name: "_email",
        type: "string"
      }
    ],
    name: "registerNotifier",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "address",
        name: "_wallet",
        type: "address"
      }
    ],
    name: "deregisterNotifier",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "getLatestNotifierID",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [
      {
        internalType: "uint256",
        name: "_ID",
        type: "uint256"
      }
    ],
    name: "getNotifierForID",
    outputs: [
      {
        internalType: "address",
        name: "wallet",
        type: "address"
      },
      {
        internalType: "string",
        name: "endpoint",
        type: "string"
      },
      {
        internalType: "string",
        name: "email",
        type: "string"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [
      {
        internalType: "address",
        name: "_wallet",
        type: "address"
      }
    ],
    name: "getNotifierForWallet",
    outputs: [
      {
        internalType: "uint256",
        name: "ID",
        type: "uint256"
      },
      {
        internalType: "string",
        name: "endpoint",
        type: "string"
      },
      {
        internalType: "string",
        name: "email",
        type: "string"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [
      {
        internalType: "string",
        name: "_endpoint",
        type: "string"
      }
    ],
    name: "getNotifierForEndpoint",
    outputs: [
      {
        internalType: "uint256",
        name: "ID",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "wallet",
        type: "address"
      },
      {
        internalType: "string",
        name: "email",
        type: "string"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [
      {
        internalType: "string",
        name: "_email",
        type: "string"
      }
    ],
    name: "getNotifierForEmail",
    outputs: [
      {
        internalType: "uint256",
        name: "ID",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "wallet",
        type: "address"
      },
      {
        internalType: "string",
        name: "endpoint",
        type: "string"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "getGovernanceAddress",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "address",
        name: "_governanceAddress",
        type: "address"
      }
    ],
    name: "setGovernanceAddress",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  }
];

// node_modules/@audius/eth/dist/esm/trusted-notifier-manager/constants.js
var TRUSTED_NOTIFIER_MANAGER_CONTRACT_ADDRESS = "0x6f08105c8CEef2BC5653640fcdbBE1e7bb519D39";

// node_modules/@audius/eth/dist/esm/trusted-notifier-manager/trustedNotifierManager.js
var TrustedNotifierManager = class {
  constructor(client, { address } = {}) {
    this.getLatestNotifierID = () => this.client.readContract({
      address: this.address,
      abi: abi11,
      functionName: "getLatestNotifierID"
    });
    this.getNotifierForID = ({ id }) => this.client.readContract({
      address: this.address,
      abi: abi11,
      functionName: "getNotifierForID",
      args: [id]
    });
    this.getNotifierForWallet = ({ address: address2 }) => this.client.readContract({
      address: this.address,
      abi: abi11,
      functionName: "getNotifierForWallet",
      args: [address2]
    });
    this.getNotifierForEndpoint = ({ endpoint: endpoint2 }) => this.client.readContract({
      address: this.address,
      abi: abi11,
      functionName: "getNotifierForEndpoint",
      args: [endpoint2]
    });
    this.getNotifierForEmail = ({ email }) => this.client.readContract({
      address: this.address,
      abi: abi11,
      functionName: "getNotifierForEmail",
      args: [email]
    });
    this.client = client;
    this.address = address ?? TRUSTED_NOTIFIER_MANAGER_CONTRACT_ADDRESS;
  }
};

// node_modules/@audius/eth/dist/esm/audius-wormhole/abi.js
var abi12 = [
  {
    constant: true,
    inputs: [],
    name: "DOMAIN_SEPARATOR",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "TRANSFER_TOKENS_TYPEHASH",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    name: "nonces",
    outputs: [
      {
        internalType: "uint32",
        name: "",
        type: "uint32"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "token",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "address",
        name: "_tokenAddress",
        type: "address"
      },
      {
        internalType: "address",
        name: "_wormholeAddress",
        type: "address"
      }
    ],
    name: "initialize",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [],
    name: "initialize",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      },
      {
        internalType: "uint16",
        name: "recipientChain",
        type: "uint16"
      },
      {
        internalType: "bytes32",
        name: "recipient",
        type: "bytes32"
      },
      {
        internalType: "uint256",
        name: "arbiterFee",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "deadline",
        type: "uint256"
      },
      {
        internalType: "uint8",
        name: "v",
        type: "uint8"
      },
      {
        internalType: "bytes32",
        name: "r",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "s",
        type: "bytes32"
      }
    ],
    name: "transferTokens",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  }
];

// node_modules/@audius/eth/dist/esm/audius-wormhole/audiusWormhole.js
var AudiusWormhole = class {
};
AudiusWormhole.abi = abi12;
AudiusWormhole.address = "0x6E7a1F7339bbB62b23D44797b63e4258d283E095";
AudiusWormhole.types = {
  EIP712Domain: [
    { name: "name", type: "string" },
    { name: "version", type: "string" },
    { name: "chainId", type: "uint256" },
    { name: "verifyingContract", type: "address" }
  ],
  TransferTokens: [
    { name: "from", type: "address" },
    { name: "amount", type: "uint256" },
    { name: "recipientChain", type: "uint16" },
    { name: "recipient", type: "bytes32" },
    { name: "artbiterFee", type: "uint256" },
    { name: "nonce", type: "uint32" },
    { name: "deadline", type: "uint256" }
  ]
};

// node_modules/async-mutex/index.mjs
var E_TIMEOUT = new Error("timeout while waiting for mutex to become available");
var E_ALREADY_LOCKED = new Error("mutex already locked");
var E_CANCELED = new Error("request for lock canceled");
var __awaiter$2 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P || (P = Promise))(function(resolve2, reject2) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject2(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject2(e);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Semaphore = class {
  constructor(_value, _cancelError = E_CANCELED) {
    this._value = _value;
    this._cancelError = _cancelError;
    this._queue = [];
    this._weightedWaiters = [];
  }
  acquire(weight = 1, priority = 0) {
    if (weight <= 0)
      throw new Error(`invalid weight ${weight}: must be positive`);
    return new Promise((resolve2, reject2) => {
      const task = { resolve: resolve2, reject: reject2, weight, priority };
      const i = findIndexFromEnd(this._queue, (other) => priority <= other.priority);
      if (i === -1 && weight <= this._value) {
        this._dispatchItem(task);
      } else {
        this._queue.splice(i + 1, 0, task);
      }
    });
  }
  runExclusive(callback_1) {
    return __awaiter$2(this, arguments, void 0, function* (callback, weight = 1, priority = 0) {
      const [value, release] = yield this.acquire(weight, priority);
      try {
        return yield callback(value);
      } finally {
        release();
      }
    });
  }
  waitForUnlock(weight = 1, priority = 0) {
    if (weight <= 0)
      throw new Error(`invalid weight ${weight}: must be positive`);
    if (this._couldLockImmediately(weight, priority)) {
      return Promise.resolve();
    } else {
      return new Promise((resolve2) => {
        if (!this._weightedWaiters[weight - 1])
          this._weightedWaiters[weight - 1] = [];
        insertSorted(this._weightedWaiters[weight - 1], { resolve: resolve2, priority });
      });
    }
  }
  isLocked() {
    return this._value <= 0;
  }
  getValue() {
    return this._value;
  }
  setValue(value) {
    this._value = value;
    this._dispatchQueue();
  }
  release(weight = 1) {
    if (weight <= 0)
      throw new Error(`invalid weight ${weight}: must be positive`);
    this._value += weight;
    this._dispatchQueue();
  }
  cancel() {
    this._queue.forEach((entry) => entry.reject(this._cancelError));
    this._queue = [];
  }
  _dispatchQueue() {
    this._drainUnlockWaiters();
    while (this._queue.length > 0 && this._queue[0].weight <= this._value) {
      this._dispatchItem(this._queue.shift());
      this._drainUnlockWaiters();
    }
  }
  _dispatchItem(item) {
    const previousValue = this._value;
    this._value -= item.weight;
    item.resolve([previousValue, this._newReleaser(item.weight)]);
  }
  _newReleaser(weight) {
    let called = false;
    return () => {
      if (called)
        return;
      called = true;
      this.release(weight);
    };
  }
  _drainUnlockWaiters() {
    if (this._queue.length === 0) {
      for (let weight = this._value; weight > 0; weight--) {
        const waiters = this._weightedWaiters[weight - 1];
        if (!waiters)
          continue;
        waiters.forEach((waiter) => waiter.resolve());
        this._weightedWaiters[weight - 1] = [];
      }
    } else {
      const queuedPriority = this._queue[0].priority;
      for (let weight = this._value; weight > 0; weight--) {
        const waiters = this._weightedWaiters[weight - 1];
        if (!waiters)
          continue;
        const i = waiters.findIndex((waiter) => waiter.priority <= queuedPriority);
        (i === -1 ? waiters : waiters.splice(0, i)).forEach(((waiter) => waiter.resolve()));
      }
    }
  }
  _couldLockImmediately(weight, priority) {
    return (this._queue.length === 0 || this._queue[0].priority < priority) && weight <= this._value;
  }
};
function insertSorted(a, v) {
  const i = findIndexFromEnd(a, (other) => v.priority <= other.priority);
  a.splice(i + 1, 0, v);
}
function findIndexFromEnd(a, predicate) {
  for (let i = a.length - 1; i >= 0; i--) {
    if (predicate(a[i])) {
      return i;
    }
  }
  return -1;
}
var __awaiter$1 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P || (P = Promise))(function(resolve2, reject2) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject2(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject2(e);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Mutex = class {
  constructor(cancelError) {
    this._semaphore = new Semaphore(1, cancelError);
  }
  acquire() {
    return __awaiter$1(this, arguments, void 0, function* (priority = 0) {
      const [, releaser] = yield this._semaphore.acquire(1, priority);
      return releaser;
    });
  }
  runExclusive(callback, priority = 0) {
    return this._semaphore.runExclusive(() => callback(), 1, priority);
  }
  isLocked() {
    return this._semaphore.isLocked();
  }
  waitForUnlock(priority = 0) {
    return this._semaphore.waitForUnlock(1, priority);
  }
  release() {
    if (this._semaphore.isLocked())
      this._semaphore.release();
  }
  cancel() {
    return this._semaphore.cancel();
  }
};

// node_modules/@audius/sdk/dist/index.browser.esm.js
function defineChain2(chain2) {
  return {
    formatters: void 0,
    fees: void 0,
    serializers: void 0,
    ...chain2
  };
}
var version2 = "2.21.21";
var errorConfig = {
  getDocsUrl: (_ref) => {
    let {
      docsBaseUrl,
      docsPath: docsPath3 = "",
      docsSlug
    } = _ref;
    return docsPath3 ? `${docsBaseUrl !== null && docsBaseUrl !== void 0 ? docsBaseUrl : "https://viem.sh"}${docsPath3}${docsSlug ? `#${docsSlug}` : ""}` : void 0;
  },
  version: version2
};
var BaseError2 = class _BaseError extends Error {
  constructor(shortMessage) {
    var _errorConfig$getDocsU, _errorConfig, _args$name;
    let args = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const details = ((_args$cause) => {
      if (args.cause instanceof _BaseError) return args.cause.details;
      if ((_args$cause = args.cause) !== null && _args$cause !== void 0 && _args$cause.message) return args.cause.message;
      return args.details;
    })();
    const docsPath3 = (() => {
      if (args.cause instanceof _BaseError) return args.cause.docsPath || args.docsPath;
      return args.docsPath;
    })();
    const docsUrl = (_errorConfig$getDocsU = (_errorConfig = errorConfig).getDocsUrl) === null || _errorConfig$getDocsU === void 0 ? void 0 : _errorConfig$getDocsU.call(_errorConfig, {
      ...args,
      docsPath: docsPath3
    });
    const message = [shortMessage || "An error occurred.", "", ...args.metaMessages ? [...args.metaMessages, ""] : [], ...docsUrl ? [`Docs: ${docsUrl}`] : [], ...details ? [`Details: ${details}`] : [], ...errorConfig.version ? [`Version: ${errorConfig.version}`] : []].join("\n");
    super(message, args.cause ? {
      cause: args.cause
    } : void 0);
    Object.defineProperty(this, "details", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "docsPath", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "metaMessages", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "shortMessage", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "version", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "BaseError"
    });
    this.details = details;
    this.docsPath = docsPath3;
    this.metaMessages = args.metaMessages;
    this.name = (_args$name = args.name) !== null && _args$name !== void 0 ? _args$name : this.name;
    this.shortMessage = shortMessage;
    this.version = version2;
  }
  walk(fn) {
    return walk(this, fn);
  }
};
function walk(err2, fn) {
  if (fn !== null && fn !== void 0 && fn(err2)) return err2;
  if (err2 && typeof err2 === "object" && "cause" in err2) return walk(err2.cause, fn);
  return fn ? null : err2;
}
var IntegerOutOfRangeError2 = class extends BaseError2 {
  constructor(_ref) {
    let {
      max,
      min,
      signed,
      size: size4,
      value
    } = _ref;
    super(`Number "${value}" is not in safe ${size4 ? `${size4 * 8}-bit ${signed ? "signed" : "unsigned"} ` : ""}integer range ${max ? `(${min} to ${max})` : `(above ${min})`}`, {
      name: "IntegerOutOfRangeError"
    });
  }
};
var SizeOverflowError2 = class extends BaseError2 {
  constructor(_ref2) {
    let {
      givenSize,
      maxSize
    } = _ref2;
    super(`Size cannot exceed ${maxSize} bytes. Given size: ${givenSize} bytes.`, {
      name: "SizeOverflowError"
    });
  }
};
function isHex2(value) {
  let {
    strict = true
  } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  if (!value) return false;
  if (typeof value !== "string") return false;
  return strict ? /^0x[0-9a-fA-F]*$/.test(value) : value.startsWith("0x");
}
function size3(value) {
  if (isHex2(value, {
    strict: false
  })) return Math.ceil((value.length - 2) / 2);
  return value.length;
}
function trim2(hexOrBytes) {
  let {
    dir = "left"
  } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  let data = typeof hexOrBytes === "string" ? hexOrBytes.replace("0x", "") : hexOrBytes;
  let sliceLength = 0;
  for (let i = 0; i < data.length - 1; i++) {
    if (data[dir === "left" ? i : data.length - i - 1].toString() === "0") sliceLength++;
    else break;
  }
  data = dir === "left" ? data.slice(sliceLength) : data.slice(0, data.length - sliceLength);
  if (typeof hexOrBytes === "string") {
    if (data.length === 1 && dir === "right") data = `${data}0`;
    return `0x${data.length % 2 === 1 ? `0${data}` : data}`;
  }
  return data;
}
var SliceOffsetOutOfBoundsError2 = class extends BaseError2 {
  constructor(_ref) {
    let {
      offset: offset3,
      position,
      size: size4
    } = _ref;
    super(`Slice ${position === "start" ? "starting" : "ending"} at offset "${offset3}" is out-of-bounds (size: ${size4}).`, {
      name: "SliceOffsetOutOfBoundsError"
    });
  }
};
var SizeExceedsPaddingSizeError2 = class extends BaseError2 {
  constructor(_ref2) {
    let {
      size: size4,
      targetSize,
      type: type3
    } = _ref2;
    super(`${type3.charAt(0).toUpperCase()}${type3.slice(1).toLowerCase()} size (${size4}) exceeds padding size (${targetSize}).`, {
      name: "SizeExceedsPaddingSizeError"
    });
  }
};
function pad2(hexOrBytes) {
  let {
    dir,
    size: size4 = 32
  } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  if (typeof hexOrBytes === "string") return padHex2(hexOrBytes, {
    dir,
    size: size4
  });
  return padBytes2(hexOrBytes, {
    dir,
    size: size4
  });
}
function padHex2(hex_) {
  let {
    dir,
    size: size4 = 32
  } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  if (size4 === null) return hex_;
  const hex3 = hex_.replace("0x", "");
  if (hex3.length > size4 * 2) throw new SizeExceedsPaddingSizeError2({
    size: Math.ceil(hex3.length / 2),
    targetSize: size4,
    type: "hex"
  });
  return `0x${hex3[dir === "right" ? "padEnd" : "padStart"](size4 * 2, "0")}`;
}
function padBytes2(bytes3) {
  let {
    dir,
    size: size4 = 32
  } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  if (size4 === null) return bytes3;
  if (bytes3.length > size4) throw new SizeExceedsPaddingSizeError2({
    size: bytes3.length,
    targetSize: size4,
    type: "bytes"
  });
  const paddedBytes = new Uint8Array(size4);
  for (let i = 0; i < size4; i++) {
    const padEnd = dir === "right";
    paddedBytes[padEnd ? i : size4 - i - 1] = bytes3[padEnd ? i : bytes3.length - i - 1];
  }
  return paddedBytes;
}
var hexes$2 = Array.from({
  length: 256
}, (_v, i) => i.toString(16).padStart(2, "0"));
function toHex2(value) {
  let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  if (typeof value === "number" || typeof value === "bigint") return numberToHex2(value, opts);
  if (typeof value === "string") {
    return stringToHex2(value, opts);
  }
  if (typeof value === "boolean") return boolToHex2(value, opts);
  return bytesToHex$2(value, opts);
}
function boolToHex2(value) {
  let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const hex3 = `0x${Number(value)}`;
  if (typeof opts.size === "number") {
    assertSize(hex3, {
      size: opts.size
    });
    return pad2(hex3, {
      size: opts.size
    });
  }
  return hex3;
}
function bytesToHex$2(value) {
  let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  let string3 = "";
  for (let i = 0; i < value.length; i++) {
    string3 += hexes$2[value[i]];
  }
  const hex3 = `0x${string3}`;
  if (typeof opts.size === "number") {
    assertSize(hex3, {
      size: opts.size
    });
    return pad2(hex3, {
      dir: "right",
      size: opts.size
    });
  }
  return hex3;
}
function numberToHex2(value_) {
  let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const {
    signed,
    size: size4
  } = opts;
  const value = BigInt(value_);
  let maxValue;
  if (size4) {
    if (signed) maxValue = (1n << BigInt(size4) * 8n - 1n) - 1n;
    else maxValue = 2n ** (BigInt(size4) * 8n) - 1n;
  } else if (typeof value_ === "number") {
    maxValue = BigInt(Number.MAX_SAFE_INTEGER);
  }
  const minValue = typeof maxValue === "bigint" && signed ? -maxValue - 1n : 0;
  if (maxValue && value > maxValue || value < minValue) {
    const suffix = typeof value_ === "bigint" ? "n" : "";
    throw new IntegerOutOfRangeError2({
      max: maxValue ? `${maxValue}${suffix}` : void 0,
      min: `${minValue}${suffix}`,
      signed,
      size: size4,
      value: `${value_}${suffix}`
    });
  }
  const hex3 = `0x${(signed && value < 0 ? (1n << BigInt(size4 * 8)) + BigInt(value) : value).toString(16)}`;
  if (size4) return pad2(hex3, {
    size: size4
  });
  return hex3;
}
var encoder$1 = new TextEncoder();
function stringToHex2(value_) {
  let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const value = encoder$1.encode(value_);
  return bytesToHex$2(value, opts);
}
var encoder3 = new TextEncoder();
function toBytes$2(value) {
  let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  if (typeof value === "number" || typeof value === "bigint") return numberToBytes2(value, opts);
  if (typeof value === "boolean") return boolToBytes2(value, opts);
  if (isHex2(value)) return hexToBytes$1(value, opts);
  return stringToBytes4(value, opts);
}
function boolToBytes2(value) {
  let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const bytes3 = new Uint8Array(1);
  bytes3[0] = Number(value);
  if (typeof opts.size === "number") {
    assertSize(bytes3, {
      size: opts.size
    });
    return pad2(bytes3, {
      size: opts.size
    });
  }
  return bytes3;
}
var charCodeMap = {
  zero: 48,
  nine: 57,
  A: 65,
  F: 70,
  a: 97,
  f: 102
};
function charCodeToBase16(char) {
  if (char >= charCodeMap.zero && char <= charCodeMap.nine) return char - charCodeMap.zero;
  if (char >= charCodeMap.A && char <= charCodeMap.F) return char - (charCodeMap.A - 10);
  if (char >= charCodeMap.a && char <= charCodeMap.f) return char - (charCodeMap.a - 10);
  return void 0;
}
function hexToBytes$1(hex_) {
  let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  let hex3 = hex_;
  if (opts.size) {
    assertSize(hex3, {
      size: opts.size
    });
    hex3 = pad2(hex3, {
      dir: "right",
      size: opts.size
    });
  }
  let hexString = hex3.slice(2);
  if (hexString.length % 2) hexString = `0${hexString}`;
  const length2 = hexString.length / 2;
  const bytes3 = new Uint8Array(length2);
  for (let index4 = 0, j = 0; index4 < length2; index4++) {
    const nibbleLeft = charCodeToBase16(hexString.charCodeAt(j++));
    const nibbleRight = charCodeToBase16(hexString.charCodeAt(j++));
    if (nibbleLeft === void 0 || nibbleRight === void 0) {
      throw new BaseError2(`Invalid byte sequence ("${hexString[j - 2]}${hexString[j - 1]}" in "${hexString}").`);
    }
    bytes3[index4] = nibbleLeft * 16 + nibbleRight;
  }
  return bytes3;
}
function numberToBytes2(value, opts) {
  const hex3 = numberToHex2(value, opts);
  return hexToBytes$1(hex3);
}
function stringToBytes4(value) {
  let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const bytes3 = encoder3.encode(value);
  if (typeof opts.size === "number") {
    assertSize(bytes3, {
      size: opts.size
    });
    return pad2(bytes3, {
      dir: "right",
      size: opts.size
    });
  }
  return bytes3;
}
function assertSize(hexOrBytes, _ref) {
  let {
    size: size$1
  } = _ref;
  if (size3(hexOrBytes) > size$1) throw new SizeOverflowError2({
    givenSize: size3(hexOrBytes),
    maxSize: size$1
  });
}
function hexToBigInt2(hex3) {
  let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const {
    signed
  } = opts;
  if (opts.size) assertSize(hex3, {
    size: opts.size
  });
  const value = BigInt(hex3);
  if (!signed) return value;
  const size4 = (hex3.length - 2) / 2;
  const max = (1n << BigInt(size4) * 8n - 1n) - 1n;
  if (value <= max) return value;
  return value - BigInt(`0x${"f".padStart(size4 * 2, "f")}`) - 1n;
}
function hexToNumber$1(hex3) {
  let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return Number(hexToBigInt2(hex3, opts));
}
var maxUint2562 = 2n ** 256n - 1n;
function concat2(values) {
  if (typeof values[0] === "string") return concatHex2(values);
  return concatBytes$2(values);
}
function concatBytes$2(values) {
  let length2 = 0;
  for (const arr of values) {
    length2 += arr.length;
  }
  const result = new Uint8Array(length2);
  let offset3 = 0;
  for (const arr of values) {
    result.set(arr, offset3);
    offset3 += arr.length;
  }
  return result;
}
function concatHex2(values) {
  return `0x${values.reduce((acc, x) => acc + x.replace("0x", ""), "")}`;
}
var NegativeOffsetError = class extends BaseError2 {
  constructor(_ref) {
    let {
      offset: offset3
    } = _ref;
    super(`Offset \`${offset3}\` cannot be negative.`, {
      name: "NegativeOffsetError"
    });
  }
};
var PositionOutOfBoundsError2 = class extends BaseError2 {
  constructor(_ref2) {
    let {
      length: length2,
      position
    } = _ref2;
    super(`Position \`${position}\` is out of bounds (\`0 < position < ${length2}\`).`, {
      name: "PositionOutOfBoundsError"
    });
  }
};
var RecursiveReadLimitExceededError = class extends BaseError2 {
  constructor(_ref3) {
    let {
      count,
      limit
    } = _ref3;
    super(`Recursive read limit of \`${limit}\` exceeded (recursive read count: \`${count}\`).`, {
      name: "RecursiveReadLimitExceededError"
    });
  }
};
var staticCursor = {
  bytes: new Uint8Array(),
  dataView: new DataView(new ArrayBuffer(0)),
  position: 0,
  positionReadCount: /* @__PURE__ */ new Map(),
  recursiveReadCount: 0,
  recursiveReadLimit: Number.POSITIVE_INFINITY,
  assertReadLimit() {
    if (this.recursiveReadCount >= this.recursiveReadLimit) throw new RecursiveReadLimitExceededError({
      count: this.recursiveReadCount + 1,
      limit: this.recursiveReadLimit
    });
  },
  assertPosition(position) {
    if (position < 0 || position > this.bytes.length - 1) throw new PositionOutOfBoundsError2({
      length: this.bytes.length,
      position
    });
  },
  decrementPosition(offset3) {
    if (offset3 < 0) throw new NegativeOffsetError({
      offset: offset3
    });
    const position = this.position - offset3;
    this.assertPosition(position);
    this.position = position;
  },
  getReadCount(position) {
    return this.positionReadCount.get(position || this.position) || 0;
  },
  incrementPosition(offset3) {
    if (offset3 < 0) throw new NegativeOffsetError({
      offset: offset3
    });
    const position = this.position + offset3;
    this.assertPosition(position);
    this.position = position;
  },
  inspectByte(position_) {
    const position = position_ !== null && position_ !== void 0 ? position_ : this.position;
    this.assertPosition(position);
    return this.bytes[position];
  },
  inspectBytes(length2, position_) {
    const position = position_ !== null && position_ !== void 0 ? position_ : this.position;
    this.assertPosition(position + length2 - 1);
    return this.bytes.subarray(position, position + length2);
  },
  inspectUint8(position_) {
    const position = position_ !== null && position_ !== void 0 ? position_ : this.position;
    this.assertPosition(position);
    return this.bytes[position];
  },
  inspectUint16(position_) {
    const position = position_ !== null && position_ !== void 0 ? position_ : this.position;
    this.assertPosition(position + 1);
    return this.dataView.getUint16(position);
  },
  inspectUint24(position_) {
    const position = position_ !== null && position_ !== void 0 ? position_ : this.position;
    this.assertPosition(position + 2);
    return (this.dataView.getUint16(position) << 8) + this.dataView.getUint8(position + 2);
  },
  inspectUint32(position_) {
    const position = position_ !== null && position_ !== void 0 ? position_ : this.position;
    this.assertPosition(position + 3);
    return this.dataView.getUint32(position);
  },
  pushByte(byte) {
    this.assertPosition(this.position);
    this.bytes[this.position] = byte;
    this.position++;
  },
  pushBytes(bytes3) {
    this.assertPosition(this.position + bytes3.length - 1);
    this.bytes.set(bytes3, this.position);
    this.position += bytes3.length;
  },
  pushUint8(value) {
    this.assertPosition(this.position);
    this.bytes[this.position] = value;
    this.position++;
  },
  pushUint16(value) {
    this.assertPosition(this.position + 1);
    this.dataView.setUint16(this.position, value);
    this.position += 2;
  },
  pushUint24(value) {
    this.assertPosition(this.position + 2);
    this.dataView.setUint16(this.position, value >> 8);
    this.dataView.setUint8(this.position + 2, value & ~4294967040);
    this.position += 3;
  },
  pushUint32(value) {
    this.assertPosition(this.position + 3);
    this.dataView.setUint32(this.position, value);
    this.position += 4;
  },
  readByte() {
    this.assertReadLimit();
    this._touch();
    const value = this.inspectByte();
    this.position++;
    return value;
  },
  readBytes(length2, size4) {
    this.assertReadLimit();
    this._touch();
    const value = this.inspectBytes(length2);
    this.position += size4 !== null && size4 !== void 0 ? size4 : length2;
    return value;
  },
  readUint8() {
    this.assertReadLimit();
    this._touch();
    const value = this.inspectUint8();
    this.position += 1;
    return value;
  },
  readUint16() {
    this.assertReadLimit();
    this._touch();
    const value = this.inspectUint16();
    this.position += 2;
    return value;
  },
  readUint24() {
    this.assertReadLimit();
    this._touch();
    const value = this.inspectUint24();
    this.position += 3;
    return value;
  },
  readUint32() {
    this.assertReadLimit();
    this._touch();
    const value = this.inspectUint32();
    this.position += 4;
    return value;
  },
  get remaining() {
    return this.bytes.length - this.position;
  },
  setPosition(position) {
    const oldPosition = this.position;
    this.assertPosition(position);
    this.position = position;
    return () => this.position = oldPosition;
  },
  _touch() {
    if (this.recursiveReadLimit === Number.POSITIVE_INFINITY) return;
    const count = this.getReadCount();
    this.positionReadCount.set(this.position, count + 1);
    if (count > 0) this.recursiveReadCount++;
  }
};
function createCursor2(bytes3) {
  let {
    recursiveReadLimit = 8192
  } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const cursor = Object.create(staticCursor);
  cursor.bytes = bytes3;
  cursor.dataView = new DataView(bytes3.buffer, bytes3.byteOffset, bytes3.byteLength);
  cursor.positionReadCount = /* @__PURE__ */ new Map();
  cursor.recursiveReadLimit = recursiveReadLimit;
  return cursor;
}
function toRlp2(bytes3) {
  let to = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "hex";
  const encodable = getEncodable2(bytes3);
  const cursor = createCursor2(new Uint8Array(encodable.length));
  encodable.encode(cursor);
  if (to === "hex") return bytesToHex$2(cursor.bytes);
  return cursor.bytes;
}
function getEncodable2(bytes3) {
  if (Array.isArray(bytes3)) return getEncodableList2(bytes3.map((x) => getEncodable2(x)));
  return getEncodableBytes2(bytes3);
}
function getEncodableList2(list) {
  const bodyLength = list.reduce((acc, x) => acc + x.length, 0);
  const sizeOfBodyLength = getSizeOfLength2(bodyLength);
  const length2 = (() => {
    if (bodyLength <= 55) return 1 + bodyLength;
    return 1 + sizeOfBodyLength + bodyLength;
  })();
  return {
    length: length2,
    encode(cursor) {
      if (bodyLength <= 55) {
        cursor.pushByte(192 + bodyLength);
      } else {
        cursor.pushByte(192 + 55 + sizeOfBodyLength);
        if (sizeOfBodyLength === 1) cursor.pushUint8(bodyLength);
        else if (sizeOfBodyLength === 2) cursor.pushUint16(bodyLength);
        else if (sizeOfBodyLength === 3) cursor.pushUint24(bodyLength);
        else cursor.pushUint32(bodyLength);
      }
      for (const {
        encode: encode4
      } of list) {
        encode4(cursor);
      }
    }
  };
}
function getEncodableBytes2(bytesOrHex) {
  const bytes3 = typeof bytesOrHex === "string" ? hexToBytes$1(bytesOrHex) : bytesOrHex;
  const sizeOfBytesLength = getSizeOfLength2(bytes3.length);
  const length2 = (() => {
    if (bytes3.length === 1 && bytes3[0] < 128) return 1;
    if (bytes3.length <= 55) return 1 + bytes3.length;
    return 1 + sizeOfBytesLength + bytes3.length;
  })();
  return {
    length: length2,
    encode(cursor) {
      if (bytes3.length === 1 && bytes3[0] < 128) {
        cursor.pushBytes(bytes3);
      } else if (bytes3.length <= 55) {
        cursor.pushByte(128 + bytes3.length);
        cursor.pushBytes(bytes3);
      } else {
        cursor.pushByte(128 + 55 + sizeOfBytesLength);
        if (sizeOfBytesLength === 1) cursor.pushUint8(bytes3.length);
        else if (sizeOfBytesLength === 2) cursor.pushUint16(bytes3.length);
        else if (sizeOfBytesLength === 3) cursor.pushUint24(bytes3.length);
        else cursor.pushUint32(bytes3.length);
        cursor.pushBytes(bytes3);
      }
    }
  };
}
function getSizeOfLength2(length2) {
  if (length2 < 2 ** 8) return 1;
  if (length2 < 2 ** 16) return 2;
  if (length2 < 2 ** 24) return 3;
  if (length2 < 2 ** 32) return 4;
  throw new BaseError2("Length is too large.");
}
var gweiUnits2 = {
  ether: -9,
  wei: 9
};
function formatUnits2(value, decimals) {
  let display = value.toString();
  const negative = display.startsWith("-");
  if (negative) display = display.slice(1);
  display = display.padStart(decimals, "0");
  let [integer, fraction] = [display.slice(0, display.length - decimals), display.slice(display.length - decimals)];
  fraction = fraction.replace(/(0+)$/, "");
  return `${negative ? "-" : ""}${integer || "0"}${fraction ? `.${fraction}` : ""}`;
}
function formatGwei2(wei) {
  let unit = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "wei";
  return formatUnits2(wei, gweiUnits2[unit]);
}
function prettyPrint2(args) {
  const entries = Object.entries(args).map((_ref) => {
    let [key, value] = _ref;
    if (value === void 0 || value === false) return null;
    return [key, value];
  }).filter(Boolean);
  const maxLength = entries.reduce((acc, _ref2) => {
    let [key] = _ref2;
    return Math.max(acc, key.length);
  }, 0);
  return entries.map((_ref3) => {
    let [key, value] = _ref3;
    return `  ${`${key}:`.padEnd(maxLength + 1)}  ${value}`;
  }).join("\n");
}
var InvalidLegacyVError2 = class extends BaseError2 {
  constructor(_ref4) {
    let {
      v
    } = _ref4;
    super(`Invalid \`v\` value "${v}". Expected 27 or 28.`, {
      name: "InvalidLegacyVError"
    });
  }
};
var InvalidSerializableTransactionError2 = class extends BaseError2 {
  constructor(_ref5) {
    let {
      transaction
    } = _ref5;
    super("Cannot infer a transaction type from provided transaction.", {
      metaMessages: ["Provided Transaction:", "{", prettyPrint2(transaction), "}", "", "To infer the type, either provide:", "- a `type` to the Transaction, or", "- an EIP-1559 Transaction with `maxFeePerGas`, or", "- an EIP-2930 Transaction with `gasPrice` & `accessList`, or", "- an EIP-4844 Transaction with `blobs`, `blobVersionedHashes`, `sidecars`, or", "- an EIP-7702 Transaction with `authorizationList`, or", "- a Legacy Transaction with `gasPrice`"],
      name: "InvalidSerializableTransactionError"
    });
  }
};
var InvalidStorageKeySizeError2 = class extends BaseError2 {
  constructor(_ref9) {
    let {
      storageKey
    } = _ref9;
    super(`Size for storage key "${storageKey}" is invalid. Expected 32 bytes. Got ${Math.floor((storageKey.length - 2) / 2)} bytes.`, {
      name: "InvalidStorageKeySizeError"
    });
  }
};
function blobsToCommitments2(parameters) {
  var _parameters$to;
  const {
    kzg
  } = parameters;
  const to = (_parameters$to = parameters.to) !== null && _parameters$to !== void 0 ? _parameters$to : typeof parameters.blobs[0] === "string" ? "hex" : "bytes";
  const blobs = typeof parameters.blobs[0] === "string" ? parameters.blobs.map((x) => hexToBytes$1(x)) : parameters.blobs;
  const commitments = [];
  for (const blob12 of blobs) commitments.push(Uint8Array.from(kzg.blobToKzgCommitment(blob12)));
  return to === "bytes" ? commitments : commitments.map((x) => bytesToHex$2(x));
}
function blobsToProofs2(parameters) {
  var _parameters$to;
  const {
    kzg
  } = parameters;
  const to = (_parameters$to = parameters.to) !== null && _parameters$to !== void 0 ? _parameters$to : typeof parameters.blobs[0] === "string" ? "hex" : "bytes";
  const blobs = typeof parameters.blobs[0] === "string" ? parameters.blobs.map((x) => hexToBytes$1(x)) : parameters.blobs;
  const commitments = typeof parameters.commitments[0] === "string" ? parameters.commitments.map((x) => hexToBytes$1(x)) : parameters.commitments;
  const proofs = [];
  for (let i = 0; i < blobs.length; i++) {
    const blob12 = blobs[i];
    const commitment = commitments[i];
    proofs.push(Uint8Array.from(kzg.computeBlobKzgProof(blob12, commitment)));
  }
  return to === "bytes" ? proofs : proofs.map((x) => bytesToHex$2(x));
}
function number$1(n) {
  if (!Number.isSafeInteger(n) || n < 0) throw new Error(`positive integer expected, not ${n}`);
}
function isBytes$1(a) {
  return a instanceof Uint8Array || a != null && typeof a === "object" && a.constructor.name === "Uint8Array";
}
function bytes$1(b) {
  if (!isBytes$1(b)) throw new Error("Uint8Array expected");
  for (var _len = arguments.length, lengths = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    lengths[_key - 1] = arguments[_key];
  }
  if (lengths.length > 0 && !lengths.includes(b.length)) throw new Error(`Uint8Array expected of length ${lengths}, not of length=${b.length}`);
}
function hash$1(h) {
  if (typeof h !== "function" || typeof h.create !== "function") throw new Error("Hash should be wrapped by utils.wrapConstructor");
  number$1(h.outputLen);
  number$1(h.blockLen);
}
function exists$3(instance2) {
  let checkFinished = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
  if (instance2.destroyed) throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance2.finished) throw new Error("Hash#digest() has already been called");
}
function output$1(out, instance2) {
  bytes$1(out);
  const min = instance2.outputLen;
  if (out.length < min) {
    throw new Error(`digestInto() expects output buffer of length at least ${min}`);
  }
}
var crypto$2 = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
var u32$1 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
var createView$1 = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
var rotr$1 = (word, shift) => word << 32 - shift | word >>> shift;
var isLE$1 = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
var byteSwap3 = (word) => word << 24 & 4278190080 | word << 8 & 16711680 | word >>> 8 & 65280 | word >>> 24 & 255;
function byteSwap323(arr) {
  for (let i = 0; i < arr.length; i++) {
    arr[i] = byteSwap3(arr[i]);
  }
}
function utf8ToBytes$2(str2) {
  if (typeof str2 !== "string") throw new Error(`utf8ToBytes expected string, got ${typeof str2}`);
  return new Uint8Array(new TextEncoder().encode(str2));
}
function toBytes$1(data) {
  if (typeof data === "string") data = utf8ToBytes$2(data);
  bytes$1(data);
  return data;
}
function concatBytes$1() {
  let sum = 0;
  for (let i = 0; i < arguments.length; i++) {
    const a = i < 0 || arguments.length <= i ? void 0 : arguments[i];
    bytes$1(a);
    sum += a.length;
  }
  const res = new Uint8Array(sum);
  for (let i = 0, pad3 = 0; i < arguments.length; i++) {
    const a = i < 0 || arguments.length <= i ? void 0 : arguments[i];
    res.set(a, pad3);
    pad3 += a.length;
  }
  return res;
}
var Hash$3 = class {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
};
function wrapConstructor$1(hashCons) {
  const hashC = (msg) => hashCons().update(toBytes$1(msg)).digest();
  const tmp = hashCons();
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = () => hashCons();
  return hashC;
}
function randomBytes$1() {
  let bytesLength = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 32;
  if (crypto$2 && typeof crypto$2.getRandomValues === "function") {
    return crypto$2.getRandomValues(new Uint8Array(bytesLength));
  }
  if (crypto$2 && typeof crypto$2.randomBytes === "function") {
    return crypto$2.randomBytes(bytesLength);
  }
  throw new Error("crypto.getRandomValues must be defined");
}
function setBigUint64$1(view, byteOffset, value, isLE6) {
  if (typeof view.setBigUint64 === "function") return view.setBigUint64(byteOffset, value, isLE6);
  const _32n6 = BigInt(32);
  const _u32_max = BigInt(4294967295);
  const wh = Number(value >> _32n6 & _u32_max);
  const wl = Number(value & _u32_max);
  const h = isLE6 ? 4 : 0;
  const l = isLE6 ? 0 : 4;
  view.setUint32(byteOffset + h, wh, isLE6);
  view.setUint32(byteOffset + l, wl, isLE6);
}
var Chi$1 = (a, b, c) => a & b ^ ~a & c;
var Maj$1 = (a, b, c) => a & b ^ a & c ^ b & c;
var HashMD5 = class extends Hash$3 {
  constructor(blockLen, outputLen, padOffset, isLE6) {
    super();
    this.blockLen = blockLen;
    this.outputLen = outputLen;
    this.padOffset = padOffset;
    this.isLE = isLE6;
    this.finished = false;
    this.length = 0;
    this.pos = 0;
    this.destroyed = false;
    this.buffer = new Uint8Array(blockLen);
    this.view = createView$1(this.buffer);
  }
  update(data) {
    exists$3(this);
    const {
      view,
      buffer: buffer3,
      blockLen
    } = this;
    data = toBytes$1(data);
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      if (take === blockLen) {
        const dataView = createView$1(data);
        for (; blockLen <= len - pos; pos += blockLen) this.process(dataView, pos);
        continue;
      }
      buffer3.set(data.subarray(pos, pos + take), this.pos);
      this.pos += take;
      pos += take;
      if (this.pos === blockLen) {
        this.process(view, 0);
        this.pos = 0;
      }
    }
    this.length += data.length;
    this.roundClean();
    return this;
  }
  digestInto(out) {
    exists$3(this);
    output$1(out, this);
    this.finished = true;
    const {
      buffer: buffer3,
      view,
      blockLen,
      isLE: isLE6
    } = this;
    let {
      pos
    } = this;
    buffer3[pos++] = 128;
    this.buffer.subarray(pos).fill(0);
    if (this.padOffset > blockLen - pos) {
      this.process(view, 0);
      pos = 0;
    }
    for (let i = pos; i < blockLen; i++) buffer3[i] = 0;
    setBigUint64$1(view, blockLen - 8, BigInt(this.length * 8), isLE6);
    this.process(view, 0);
    const oview = createView$1(out);
    const len = this.outputLen;
    if (len % 4) throw new Error("_sha2: outputLen should be aligned to 32bit");
    const outLen = len / 4;
    const state = this.get();
    if (outLen > state.length) throw new Error("_sha2: outputLen bigger than state");
    for (let i = 0; i < outLen; i++) oview.setUint32(4 * i, state[i], isLE6);
  }
  digest() {
    const {
      buffer: buffer3,
      outputLen
    } = this;
    this.digestInto(buffer3);
    const res = buffer3.slice(0, outputLen);
    this.destroy();
    return res;
  }
  _cloneInto(to) {
    to || (to = new this.constructor());
    to.set(...this.get());
    const {
      blockLen,
      buffer: buffer3,
      length: length2,
      finished: finished2,
      destroyed,
      pos
    } = this;
    to.length = length2;
    to.pos = pos;
    to.finished = finished2;
    to.destroyed = destroyed;
    if (length2 % blockLen) to.buffer.set(buffer3);
    return to;
  }
};
var SHA256_K$1 = new Uint32Array([1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298]);
var SHA256_IV5 = new Uint32Array([1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225]);
var SHA256_W$1 = new Uint32Array(64);
var SHA256$1 = class extends HashMD5 {
  constructor() {
    super(64, 32, 8, false);
    this.A = SHA256_IV5[0] | 0;
    this.B = SHA256_IV5[1] | 0;
    this.C = SHA256_IV5[2] | 0;
    this.D = SHA256_IV5[3] | 0;
    this.E = SHA256_IV5[4] | 0;
    this.F = SHA256_IV5[5] | 0;
    this.G = SHA256_IV5[6] | 0;
    this.H = SHA256_IV5[7] | 0;
  }
  get() {
    const {
      A,
      B,
      C,
      D,
      E,
      F,
      G,
      H
    } = this;
    return [A, B, C, D, E, F, G, H];
  }
  // prettier-ignore
  set(A, B, C, D, E, F, G, H) {
    this.A = A | 0;
    this.B = B | 0;
    this.C = C | 0;
    this.D = D | 0;
    this.E = E | 0;
    this.F = F | 0;
    this.G = G | 0;
    this.H = H | 0;
  }
  process(view, offset3) {
    for (let i = 0; i < 16; i++, offset3 += 4) SHA256_W$1[i] = view.getUint32(offset3, false);
    for (let i = 16; i < 64; i++) {
      const W15 = SHA256_W$1[i - 15];
      const W2 = SHA256_W$1[i - 2];
      const s0 = rotr$1(W15, 7) ^ rotr$1(W15, 18) ^ W15 >>> 3;
      const s1 = rotr$1(W2, 17) ^ rotr$1(W2, 19) ^ W2 >>> 10;
      SHA256_W$1[i] = s1 + SHA256_W$1[i - 7] + s0 + SHA256_W$1[i - 16] | 0;
    }
    let {
      A,
      B,
      C,
      D,
      E,
      F,
      G,
      H
    } = this;
    for (let i = 0; i < 64; i++) {
      const sigma1 = rotr$1(E, 6) ^ rotr$1(E, 11) ^ rotr$1(E, 25);
      const T1 = H + sigma1 + Chi$1(E, F, G) + SHA256_K$1[i] + SHA256_W$1[i] | 0;
      const sigma0 = rotr$1(A, 2) ^ rotr$1(A, 13) ^ rotr$1(A, 22);
      const T2 = sigma0 + Maj$1(A, B, C) | 0;
      H = G;
      G = F;
      F = E;
      E = D + T1 | 0;
      D = C;
      C = B;
      B = A;
      A = T1 + T2 | 0;
    }
    A = A + this.A | 0;
    B = B + this.B | 0;
    C = C + this.C | 0;
    D = D + this.D | 0;
    E = E + this.E | 0;
    F = F + this.F | 0;
    G = G + this.G | 0;
    H = H + this.H | 0;
    this.set(A, B, C, D, E, F, G, H);
  }
  roundClean() {
    SHA256_W$1.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0);
    this.buffer.fill(0);
  }
};
var sha256$3 = wrapConstructor$1(() => new SHA256$1());
function sha256$2(value, to_) {
  const to = to_ || "hex";
  const bytes3 = sha256$3(isHex2(value, {
    strict: false
  }) ? toBytes$2(value) : value);
  if (to === "bytes") return bytes3;
  return toHex2(bytes3);
}
function commitmentToVersionedHash2(parameters) {
  var _parameters$to;
  const {
    commitment,
    version: version3 = 1
  } = parameters;
  const to = (_parameters$to = parameters.to) !== null && _parameters$to !== void 0 ? _parameters$to : typeof commitment === "string" ? "hex" : "bytes";
  const versionedHash = sha256$2(commitment, "bytes");
  versionedHash.set([version3], 0);
  return to === "bytes" ? versionedHash : bytesToHex$2(versionedHash);
}
function commitmentsToVersionedHashes2(parameters) {
  var _parameters$to;
  const {
    commitments,
    version: version3
  } = parameters;
  const to = (_parameters$to = parameters.to) !== null && _parameters$to !== void 0 ? _parameters$to : typeof commitments[0] === "string" ? "hex" : "bytes";
  const hashes = [];
  for (const commitment of commitments) {
    hashes.push(commitmentToVersionedHash2({
      commitment,
      to,
      version: version3
    }));
  }
  return hashes;
}
var blobsPerTransaction2 = 6;
var bytesPerFieldElement2 = 32;
var fieldElementsPerBlob2 = 4096;
var bytesPerBlob2 = bytesPerFieldElement2 * fieldElementsPerBlob2;
var maxBytesPerTransaction2 = bytesPerBlob2 * blobsPerTransaction2 - // terminator byte (0x80).
1 - // zero byte (0x00) appended to each field element.
1 * fieldElementsPerBlob2 * blobsPerTransaction2;
var versionedHashVersionKzg2 = 1;
var BlobSizeTooLargeError2 = class extends BaseError2 {
  constructor(_ref) {
    let {
      maxSize,
      size: size4
    } = _ref;
    super("Blob size is too large.", {
      metaMessages: [`Max: ${maxSize} bytes`, `Given: ${size4} bytes`],
      name: "BlobSizeTooLargeError"
    });
  }
};
var EmptyBlobError2 = class extends BaseError2 {
  constructor() {
    super("Blob data must not be empty.", {
      name: "EmptyBlobError"
    });
  }
};
var InvalidVersionedHashSizeError2 = class extends BaseError2 {
  constructor(_ref2) {
    let {
      hash: hash3,
      size: size4
    } = _ref2;
    super(`Versioned hash "${hash3}" size is invalid.`, {
      metaMessages: ["Expected: 32", `Received: ${size4}`],
      name: "InvalidVersionedHashSizeError"
    });
  }
};
var InvalidVersionedHashVersionError2 = class extends BaseError2 {
  constructor(_ref3) {
    let {
      hash: hash3,
      version: version3
    } = _ref3;
    super(`Versioned hash "${hash3}" version is invalid.`, {
      metaMessages: [`Expected: ${versionedHashVersionKzg2}`, `Received: ${version3}`],
      name: "InvalidVersionedHashVersionError"
    });
  }
};
function toBlobs2(parameters) {
  var _parameters$to;
  const to = (_parameters$to = parameters.to) !== null && _parameters$to !== void 0 ? _parameters$to : typeof parameters.data === "string" ? "hex" : "bytes";
  const data = typeof parameters.data === "string" ? hexToBytes$1(parameters.data) : parameters.data;
  const size_ = size3(data);
  if (!size_) throw new EmptyBlobError2();
  if (size_ > maxBytesPerTransaction2) throw new BlobSizeTooLargeError2({
    maxSize: maxBytesPerTransaction2,
    size: size_
  });
  const blobs = [];
  let active = true;
  let position = 0;
  while (active) {
    const blob12 = createCursor2(new Uint8Array(bytesPerBlob2));
    let size4 = 0;
    while (size4 < fieldElementsPerBlob2) {
      const bytes3 = data.slice(position, position + (bytesPerFieldElement2 - 1));
      blob12.pushByte(0);
      blob12.pushBytes(bytes3);
      if (bytes3.length < 31) {
        blob12.pushByte(128);
        active = false;
        break;
      }
      size4++;
      position += 31;
    }
    blobs.push(blob12);
  }
  return to === "bytes" ? blobs.map((x) => x.bytes) : blobs.map((x) => bytesToHex$2(x.bytes));
}
function toBlobSidecars2(parameters) {
  var _parameters$blobs, _parameters$commitmen, _parameters$proofs;
  const {
    data,
    kzg,
    to
  } = parameters;
  const blobs = (_parameters$blobs = parameters.blobs) !== null && _parameters$blobs !== void 0 ? _parameters$blobs : toBlobs2({
    data,
    to
  });
  const commitments = (_parameters$commitmen = parameters.commitments) !== null && _parameters$commitmen !== void 0 ? _parameters$commitmen : blobsToCommitments2({
    blobs,
    kzg,
    to
  });
  const proofs = (_parameters$proofs = parameters.proofs) !== null && _parameters$proofs !== void 0 ? _parameters$proofs : blobsToProofs2({
    blobs,
    commitments,
    kzg,
    to
  });
  const sidecars = [];
  for (let i = 0; i < blobs.length; i++) sidecars.push({
    blob: blobs[i],
    commitment: commitments[i],
    proof: proofs[i]
  });
  return sidecars;
}
function serializeAuthorizationList2(authorizationList) {
  if (!authorizationList || authorizationList.length === 0) return [];
  const serializedAuthorizationList = [];
  for (const authorization of authorizationList) {
    const {
      contractAddress,
      chainId,
      nonce,
      ...signature2
    } = authorization;
    serializedAuthorizationList.push([toHex2(chainId), contractAddress, nonce ? toHex2(nonce) : "0x", ...toYParitySignatureArray2({}, signature2)]);
  }
  return serializedAuthorizationList;
}
var InvalidAddressError2 = class extends BaseError2 {
  constructor(_ref) {
    let {
      address
    } = _ref;
    super(`Address "${address}" is invalid.`, {
      metaMessages: ["- Address must be a hex value of 20 bytes (40 hex characters).", "- Address must match its checksum counterpart."],
      name: "InvalidAddressError"
    });
  }
};
var InvalidChainIdError2 = class extends BaseError2 {
  constructor(_ref3) {
    let {
      chainId
    } = _ref3;
    super(typeof chainId === "number" ? `Chain ID "${chainId}" is invalid.` : "Chain ID is invalid.", {
      name: "InvalidChainIdError"
    });
  }
};
var ExecutionRevertedError2 = class extends BaseError2 {
  constructor() {
    var _message$replace;
    let {
      cause,
      message
    } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const reason = message === null || message === void 0 ? void 0 : (_message$replace = message.replace("execution reverted: ", "")) === null || _message$replace === void 0 ? void 0 : _message$replace.replace("execution reverted", "");
    super(`Execution reverted ${reason ? `with reason: ${reason}` : "for an unknown reason"}.`, {
      cause,
      name: "ExecutionRevertedError"
    });
  }
};
Object.defineProperty(ExecutionRevertedError2, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: 3
});
Object.defineProperty(ExecutionRevertedError2, "nodeMessage", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /execution reverted/
});
var FeeCapTooHighError2 = class extends BaseError2 {
  constructor() {
    let {
      cause,
      maxFeePerGas
    } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    super(`The fee cap (\`maxFeePerGas\`${maxFeePerGas ? ` = ${formatGwei2(maxFeePerGas)} gwei` : ""}) cannot be higher than the maximum allowed value (2^256-1).`, {
      cause,
      name: "FeeCapTooHighError"
    });
  }
};
Object.defineProperty(FeeCapTooHighError2, "nodeMessage", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /max fee per gas higher than 2\^256-1|fee cap higher than 2\^256-1/
});
var FeeCapTooLowError2 = class extends BaseError2 {
  constructor() {
    let {
      cause,
      maxFeePerGas
    } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    super(`The fee cap (\`maxFeePerGas\`${maxFeePerGas ? ` = ${formatGwei2(maxFeePerGas)}` : ""} gwei) cannot be lower than the block base fee.`, {
      cause,
      name: "FeeCapTooLowError"
    });
  }
};
Object.defineProperty(FeeCapTooLowError2, "nodeMessage", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /max fee per gas less than block base fee|fee cap less than block base fee|transaction is outdated/
});
var NonceTooHighError2 = class extends BaseError2 {
  constructor() {
    let {
      cause,
      nonce
    } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    super(`Nonce provided for the transaction ${nonce ? `(${nonce}) ` : ""}is higher than the next one expected.`, {
      cause,
      name: "NonceTooHighError"
    });
  }
};
Object.defineProperty(NonceTooHighError2, "nodeMessage", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /nonce too high/
});
var NonceTooLowError2 = class extends BaseError2 {
  constructor() {
    let {
      cause,
      nonce
    } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    super([`Nonce provided for the transaction ${nonce ? `(${nonce}) ` : ""}is lower than the current nonce of the account.`, "Try increasing the nonce or find the latest nonce with `getTransactionCount`."].join("\n"), {
      cause,
      name: "NonceTooLowError"
    });
  }
};
Object.defineProperty(NonceTooLowError2, "nodeMessage", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /nonce too low|transaction already imported|already known/
});
var NonceMaxValueError2 = class extends BaseError2 {
  constructor() {
    let {
      cause,
      nonce
    } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    super(`Nonce provided for the transaction ${nonce ? `(${nonce}) ` : ""}exceeds the maximum allowed nonce.`, {
      cause,
      name: "NonceMaxValueError"
    });
  }
};
Object.defineProperty(NonceMaxValueError2, "nodeMessage", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /nonce has max value/
});
var InsufficientFundsError2 = class extends BaseError2 {
  constructor() {
    let {
      cause
    } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    super(["The total cost (gas * gas fee + value) of executing this transaction exceeds the balance of the account."].join("\n"), {
      cause,
      metaMessages: ["This error could arise when the account does not have enough funds to:", " - pay for the total gas fee,", " - pay for the value to send.", " ", "The cost of the transaction is calculated as `gas * gas fee + value`, where:", " - `gas` is the amount of gas needed for transaction to execute,", " - `gas fee` is the gas fee,", " - `value` is the amount of ether to send to the recipient."],
      name: "InsufficientFundsError"
    });
  }
};
Object.defineProperty(InsufficientFundsError2, "nodeMessage", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /insufficient funds|exceeds transaction sender account balance/
});
var IntrinsicGasTooHighError2 = class extends BaseError2 {
  constructor() {
    let {
      cause,
      gas
    } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    super(`The amount of gas ${gas ? `(${gas}) ` : ""}provided for the transaction exceeds the limit allowed for the block.`, {
      cause,
      name: "IntrinsicGasTooHighError"
    });
  }
};
Object.defineProperty(IntrinsicGasTooHighError2, "nodeMessage", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /intrinsic gas too high|gas limit reached/
});
var IntrinsicGasTooLowError2 = class extends BaseError2 {
  constructor() {
    let {
      cause,
      gas
    } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    super(`The amount of gas ${gas ? `(${gas}) ` : ""}provided for the transaction is too low.`, {
      cause,
      name: "IntrinsicGasTooLowError"
    });
  }
};
Object.defineProperty(IntrinsicGasTooLowError2, "nodeMessage", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /intrinsic gas too low/
});
var TransactionTypeNotSupportedError2 = class extends BaseError2 {
  constructor(_ref) {
    let {
      cause
    } = _ref;
    super("The transaction type is not supported for this chain.", {
      cause,
      name: "TransactionTypeNotSupportedError"
    });
  }
};
Object.defineProperty(TransactionTypeNotSupportedError2, "nodeMessage", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /transaction type not valid/
});
var TipAboveFeeCapError2 = class extends BaseError2 {
  constructor() {
    let {
      cause,
      maxPriorityFeePerGas,
      maxFeePerGas
    } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    super([`The provided tip (\`maxPriorityFeePerGas\`${maxPriorityFeePerGas ? ` = ${formatGwei2(maxPriorityFeePerGas)} gwei` : ""}) cannot be higher than the fee cap (\`maxFeePerGas\`${maxFeePerGas ? ` = ${formatGwei2(maxFeePerGas)} gwei` : ""}).`].join("\n"), {
      cause,
      name: "TipAboveFeeCapError"
    });
  }
};
Object.defineProperty(TipAboveFeeCapError2, "nodeMessage", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /max priority fee per gas higher than max fee per gas|tip higher than fee cap/
});
var LruMap2 = class extends Map {
  constructor(size4) {
    super();
    Object.defineProperty(this, "maxSize", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.maxSize = size4;
  }
  get(key) {
    const value = super.get(key);
    if (super.has(key) && value !== void 0) {
      this.delete(key);
      super.set(key, value);
    }
    return value;
  }
  set(key, value) {
    super.set(key, value);
    if (this.maxSize && this.size > this.maxSize) {
      const firstKey = this.keys().next().value;
      if (firstKey) this.delete(firstKey);
    }
    return this;
  }
};
var U32_MASK64$1 = BigInt(2 ** 32 - 1);
var _32n$1 = BigInt(32);
function fromBig$1(n) {
  let le = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  if (le) return {
    h: Number(n & U32_MASK64$1),
    l: Number(n >> _32n$1 & U32_MASK64$1)
  };
  return {
    h: Number(n >> _32n$1 & U32_MASK64$1) | 0,
    l: Number(n & U32_MASK64$1) | 0
  };
}
function split$1(lst) {
  let le = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  let Ah = new Uint32Array(lst.length);
  let Al = new Uint32Array(lst.length);
  for (let i = 0; i < lst.length; i++) {
    const {
      h,
      l
    } = fromBig$1(lst[i], le);
    [Ah[i], Al[i]] = [h, l];
  }
  return [Ah, Al];
}
var rotlSH$1 = (h, l, s) => h << s | l >>> 32 - s;
var rotlSL$1 = (h, l, s) => l << s | h >>> 32 - s;
var rotlBH$1 = (h, l, s) => l << s - 32 | h >>> 64 - s;
var rotlBL$1 = (h, l, s) => h << s - 32 | l >>> 64 - s;
var SHA3_PI$1 = [];
var SHA3_ROTL$1 = [];
var _SHA3_IOTA$1 = [];
var _0n$5 = BigInt(0);
var _1n$6 = BigInt(1);
var _2n$4 = BigInt(2);
var _7n$1 = BigInt(7);
var _256n$1 = BigInt(256);
var _0x71n$1 = BigInt(113);
for (let round = 0, R = _1n$6, x = 1, y = 0; round < 24; round++) {
  [x, y] = [y, (2 * x + 3 * y) % 5];
  SHA3_PI$1.push(2 * (5 * y + x));
  SHA3_ROTL$1.push((round + 1) * (round + 2) / 2 % 64);
  let t = _0n$5;
  for (let j = 0; j < 7; j++) {
    R = (R << _1n$6 ^ (R >> _7n$1) * _0x71n$1) % _256n$1;
    if (R & _2n$4) t ^= _1n$6 << (_1n$6 << BigInt(j)) - _1n$6;
  }
  _SHA3_IOTA$1.push(t);
}
var [SHA3_IOTA_H$1, SHA3_IOTA_L$1] = split$1(_SHA3_IOTA$1, true);
var rotlH$1 = (h, l, s) => s > 32 ? rotlBH$1(h, l, s) : rotlSH$1(h, l, s);
var rotlL$1 = (h, l, s) => s > 32 ? rotlBL$1(h, l, s) : rotlSL$1(h, l, s);
function keccakP$1(s) {
  let rounds = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 24;
  const B = new Uint32Array(5 * 2);
  for (let round = 24 - rounds; round < 24; round++) {
    for (let x = 0; x < 10; x++) B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
    for (let x = 0; x < 10; x += 2) {
      const idx1 = (x + 8) % 10;
      const idx0 = (x + 2) % 10;
      const B0 = B[idx0];
      const B1 = B[idx0 + 1];
      const Th = rotlH$1(B0, B1, 1) ^ B[idx1];
      const Tl = rotlL$1(B0, B1, 1) ^ B[idx1 + 1];
      for (let y = 0; y < 50; y += 10) {
        s[x + y] ^= Th;
        s[x + y + 1] ^= Tl;
      }
    }
    let curH = s[2];
    let curL = s[3];
    for (let t = 0; t < 24; t++) {
      const shift = SHA3_ROTL$1[t];
      const Th = rotlH$1(curH, curL, shift);
      const Tl = rotlL$1(curH, curL, shift);
      const PI = SHA3_PI$1[t];
      curH = s[PI];
      curL = s[PI + 1];
      s[PI] = Th;
      s[PI + 1] = Tl;
    }
    for (let y = 0; y < 50; y += 10) {
      for (let x = 0; x < 10; x++) B[x] = s[y + x];
      for (let x = 0; x < 10; x++) s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
    }
    s[0] ^= SHA3_IOTA_H$1[round];
    s[1] ^= SHA3_IOTA_L$1[round];
  }
  B.fill(0);
}
var Keccak$1 = class _Keccak$1 extends Hash$3 {
  // NOTE: we accept arguments in bytes instead of bits here.
  constructor(blockLen, suffix, outputLen) {
    let enableXOF = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
    let rounds = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 24;
    super();
    this.blockLen = blockLen;
    this.suffix = suffix;
    this.outputLen = outputLen;
    this.enableXOF = enableXOF;
    this.rounds = rounds;
    this.pos = 0;
    this.posOut = 0;
    this.finished = false;
    this.destroyed = false;
    number$1(outputLen);
    if (0 >= this.blockLen || this.blockLen >= 200) throw new Error("Sha3 supports only keccak-f1600 function");
    this.state = new Uint8Array(200);
    this.state32 = u32$1(this.state);
  }
  keccak() {
    if (!isLE$1) byteSwap323(this.state32);
    keccakP$1(this.state32, this.rounds);
    if (!isLE$1) byteSwap323(this.state32);
    this.posOut = 0;
    this.pos = 0;
  }
  update(data) {
    exists$3(this);
    const {
      blockLen,
      state
    } = this;
    data = toBytes$1(data);
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      for (let i = 0; i < take; i++) state[this.pos++] ^= data[pos++];
      if (this.pos === blockLen) this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished) return;
    this.finished = true;
    const {
      state,
      suffix,
      pos,
      blockLen
    } = this;
    state[pos] ^= suffix;
    if ((suffix & 128) !== 0 && pos === blockLen - 1) this.keccak();
    state[blockLen - 1] ^= 128;
    this.keccak();
  }
  writeInto(out) {
    exists$3(this, false);
    bytes$1(out);
    this.finish();
    const bufferOut = this.state;
    const {
      blockLen
    } = this;
    for (let pos = 0, len = out.length; pos < len; ) {
      if (this.posOut >= blockLen) this.keccak();
      const take = Math.min(blockLen - this.posOut, len - pos);
      out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
      this.posOut += take;
      pos += take;
    }
    return out;
  }
  xofInto(out) {
    if (!this.enableXOF) throw new Error("XOF is not possible for this instance");
    return this.writeInto(out);
  }
  xof(bytes3) {
    number$1(bytes3);
    return this.xofInto(new Uint8Array(bytes3));
  }
  digestInto(out) {
    output$1(out, this);
    if (this.finished) throw new Error("digest() was already called");
    this.writeInto(out);
    this.destroy();
    return out;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = true;
    this.state.fill(0);
  }
  _cloneInto(to) {
    const {
      blockLen,
      suffix,
      outputLen,
      rounds,
      enableXOF
    } = this;
    to || (to = new _Keccak$1(blockLen, suffix, outputLen, enableXOF, rounds));
    to.state32.set(this.state32);
    to.pos = this.pos;
    to.posOut = this.posOut;
    to.finished = this.finished;
    to.rounds = rounds;
    to.suffix = suffix;
    to.outputLen = outputLen;
    to.enableXOF = enableXOF;
    to.destroyed = this.destroyed;
    return to;
  }
};
var gen$1 = (suffix, blockLen, outputLen) => wrapConstructor$1(() => new Keccak$1(blockLen, suffix, outputLen));
var keccak_256$1 = gen$1(1, 136, 256 / 8);
function keccak2562(value, to_) {
  const to = to_ || "hex";
  const bytes3 = keccak_256$1(isHex2(value, {
    strict: false
  }) ? toBytes$2(value) : value);
  if (to === "bytes") return bytes3;
  return toHex2(bytes3);
}
var checksumAddressCache = new LruMap2(8192);
function checksumAddress2(address_, chainId) {
  if (checksumAddressCache.has(`${address_}.${chainId}`)) return checksumAddressCache.get(`${address_}.${chainId}`);
  const hexAddress = chainId ? `${chainId}${address_.toLowerCase()}` : address_.substring(2).toLowerCase();
  const hash3 = keccak2562(stringToBytes4(hexAddress), "bytes");
  const address = (chainId ? hexAddress.substring(`${chainId}0x`.length) : hexAddress).split("");
  for (let i = 0; i < 40; i += 2) {
    if (hash3[i >> 1] >> 4 >= 8 && address[i]) {
      address[i] = address[i].toUpperCase();
    }
    if ((hash3[i >> 1] & 15) >= 8 && address[i + 1]) {
      address[i + 1] = address[i + 1].toUpperCase();
    }
  }
  const result = `0x${address.join("")}`;
  checksumAddressCache.set(`${address_}.${chainId}`, result);
  return result;
}
var addressRegex = /^0x[a-fA-F0-9]{40}$/;
var isAddressCache = new LruMap2(8192);
function isAddress2(address, options) {
  const {
    strict = true
  } = options !== null && options !== void 0 ? options : {};
  const cacheKey2 = `${address}.${strict}`;
  if (isAddressCache.has(cacheKey2)) return isAddressCache.get(cacheKey2);
  const result = (() => {
    if (!addressRegex.test(address)) return false;
    if (address.toLowerCase() === address) return true;
    if (strict) return checksumAddress2(address) === address;
    return true;
  })();
  isAddressCache.set(cacheKey2, result);
  return result;
}
function slice2(value, start, end) {
  let {
    strict
  } = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
  if (isHex2(value, {
    strict: false
  })) return sliceHex2(value, start, end, {
    strict
  });
  return sliceBytes2(value, start, end, {
    strict
  });
}
function assertStartOffset(value, start) {
  if (typeof start === "number" && start > 0 && start > size3(value) - 1) throw new SliceOffsetOutOfBoundsError2({
    offset: start,
    position: "start",
    size: size3(value)
  });
}
function assertEndOffset(value, start, end) {
  if (typeof start === "number" && typeof end === "number" && size3(value) !== end - start) {
    throw new SliceOffsetOutOfBoundsError2({
      offset: end,
      position: "end",
      size: size3(value)
    });
  }
}
function sliceBytes2(value_, start, end) {
  let {
    strict
  } = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
  assertStartOffset(value_, start);
  const value = value_.slice(start, end);
  if (strict) assertEndOffset(value, start, end);
  return value;
}
function sliceHex2(value_, start, end) {
  let {
    strict
  } = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
  assertStartOffset(value_, start);
  const value = `0x${value_.replace("0x", "").slice((start !== null && start !== void 0 ? start : 0) * 2, (end !== null && end !== void 0 ? end : value_.length) * 2)}`;
  if (strict) assertEndOffset(value, start, end);
  return value;
}
function assertTransactionEIP77022(transaction) {
  const {
    authorizationList
  } = transaction;
  if (authorizationList) {
    for (const authorization of authorizationList) {
      const {
        contractAddress,
        chainId
      } = authorization;
      if (!isAddress2(contractAddress)) throw new InvalidAddressError2({
        address: contractAddress
      });
      if (chainId <= 0) throw new InvalidChainIdError2({
        chainId
      });
    }
  }
  assertTransactionEIP15592(transaction);
}
function assertTransactionEIP48442(transaction) {
  const {
    blobVersionedHashes
  } = transaction;
  if (blobVersionedHashes) {
    if (blobVersionedHashes.length === 0) throw new EmptyBlobError2();
    for (const hash3 of blobVersionedHashes) {
      const size_ = size3(hash3);
      const version3 = hexToNumber$1(slice2(hash3, 0, 1));
      if (size_ !== 32) throw new InvalidVersionedHashSizeError2({
        hash: hash3,
        size: size_
      });
      if (version3 !== versionedHashVersionKzg2) throw new InvalidVersionedHashVersionError2({
        hash: hash3,
        version: version3
      });
    }
  }
  assertTransactionEIP15592(transaction);
}
function assertTransactionEIP15592(transaction) {
  const {
    chainId,
    maxPriorityFeePerGas,
    maxFeePerGas,
    to
  } = transaction;
  if (chainId <= 0) throw new InvalidChainIdError2({
    chainId
  });
  if (to && !isAddress2(to)) throw new InvalidAddressError2({
    address: to
  });
  if (maxFeePerGas && maxFeePerGas > maxUint2562) throw new FeeCapTooHighError2({
    maxFeePerGas
  });
  if (maxPriorityFeePerGas && maxFeePerGas && maxPriorityFeePerGas > maxFeePerGas) throw new TipAboveFeeCapError2({
    maxFeePerGas,
    maxPriorityFeePerGas
  });
}
function assertTransactionEIP29302(transaction) {
  const {
    chainId,
    maxPriorityFeePerGas,
    gasPrice,
    maxFeePerGas,
    to
  } = transaction;
  if (chainId <= 0) throw new InvalidChainIdError2({
    chainId
  });
  if (to && !isAddress2(to)) throw new InvalidAddressError2({
    address: to
  });
  if (maxPriorityFeePerGas || maxFeePerGas) throw new BaseError2("`maxFeePerGas`/`maxPriorityFeePerGas` is not a valid EIP-2930 Transaction attribute.");
  if (gasPrice && gasPrice > maxUint2562) throw new FeeCapTooHighError2({
    maxFeePerGas: gasPrice
  });
}
function assertTransactionLegacy2(transaction) {
  const {
    chainId,
    maxPriorityFeePerGas,
    gasPrice,
    maxFeePerGas,
    to
  } = transaction;
  if (to && !isAddress2(to)) throw new InvalidAddressError2({
    address: to
  });
  if (typeof chainId !== "undefined" && chainId <= 0) throw new InvalidChainIdError2({
    chainId
  });
  if (maxPriorityFeePerGas || maxFeePerGas) throw new BaseError2("`maxFeePerGas`/`maxPriorityFeePerGas` is not a valid Legacy Transaction attribute.");
  if (gasPrice && gasPrice > maxUint2562) throw new FeeCapTooHighError2({
    maxFeePerGas: gasPrice
  });
}
function getTransactionType2(transaction) {
  if (transaction.type) return transaction.type;
  if (typeof transaction.authorizationList !== "undefined") return "eip7702";
  if (typeof transaction.blobs !== "undefined" || typeof transaction.blobVersionedHashes !== "undefined" || typeof transaction.maxFeePerBlobGas !== "undefined" || typeof transaction.sidecars !== "undefined") return "eip4844";
  if (typeof transaction.maxFeePerGas !== "undefined" || typeof transaction.maxPriorityFeePerGas !== "undefined") {
    return "eip1559";
  }
  if (typeof transaction.gasPrice !== "undefined") {
    if (typeof transaction.accessList !== "undefined") return "eip2930";
    return "legacy";
  }
  throw new InvalidSerializableTransactionError2({
    transaction
  });
}
function serializeAccessList2(accessList) {
  if (!accessList || accessList.length === 0) return [];
  const serializedAccessList = [];
  for (let i = 0; i < accessList.length; i++) {
    const {
      address,
      storageKeys
    } = accessList[i];
    for (let j = 0; j < storageKeys.length; j++) {
      if (storageKeys[j].length - 2 !== 64) {
        throw new InvalidStorageKeySizeError2({
          storageKey: storageKeys[j]
        });
      }
    }
    if (!isAddress2(address, {
      strict: false
    })) {
      throw new InvalidAddressError2({
        address
      });
    }
    serializedAccessList.push([address, storageKeys]);
  }
  return serializedAccessList;
}
function serializeTransaction2(transaction, signature2) {
  const type3 = getTransactionType2(transaction);
  if (type3 === "eip1559") return serializeTransactionEIP1559(transaction, signature2);
  if (type3 === "eip2930") return serializeTransactionEIP2930(transaction, signature2);
  if (type3 === "eip4844") return serializeTransactionEIP4844(transaction, signature2);
  if (type3 === "eip7702") return serializeTransactionEIP7702(transaction, signature2);
  return serializeTransactionLegacy(transaction, signature2);
}
function serializeTransactionEIP7702(transaction, signature2) {
  const {
    authorizationList,
    chainId,
    gas,
    nonce,
    to,
    value,
    maxFeePerGas,
    maxPriorityFeePerGas,
    accessList,
    data
  } = transaction;
  assertTransactionEIP77022(transaction);
  const serializedAccessList = serializeAccessList2(accessList);
  const serializedAuthorizationList = serializeAuthorizationList2(authorizationList);
  return concatHex2(["0x04", toRlp2([toHex2(chainId), nonce ? toHex2(nonce) : "0x", maxPriorityFeePerGas ? toHex2(maxPriorityFeePerGas) : "0x", maxFeePerGas ? toHex2(maxFeePerGas) : "0x", gas ? toHex2(gas) : "0x", to !== null && to !== void 0 ? to : "0x", value ? toHex2(value) : "0x", data !== null && data !== void 0 ? data : "0x", serializedAccessList, serializedAuthorizationList, ...toYParitySignatureArray2(transaction, signature2)])]);
}
function serializeTransactionEIP4844(transaction, signature2) {
  var _blobVersionedHashes;
  const {
    chainId,
    gas,
    nonce,
    to,
    value,
    maxFeePerBlobGas,
    maxFeePerGas,
    maxPriorityFeePerGas,
    accessList,
    data
  } = transaction;
  assertTransactionEIP48442(transaction);
  let blobVersionedHashes = transaction.blobVersionedHashes;
  let sidecars = transaction.sidecars;
  if (transaction.blobs && (typeof blobVersionedHashes === "undefined" || typeof sidecars === "undefined")) {
    const blobs2 = typeof transaction.blobs[0] === "string" ? transaction.blobs : transaction.blobs.map((x) => bytesToHex$2(x));
    const kzg = transaction.kzg;
    const commitments2 = blobsToCommitments2({
      blobs: blobs2,
      kzg
    });
    if (typeof blobVersionedHashes === "undefined") blobVersionedHashes = commitmentsToVersionedHashes2({
      commitments: commitments2
    });
    if (typeof sidecars === "undefined") {
      const proofs2 = blobsToProofs2({
        blobs: blobs2,
        commitments: commitments2,
        kzg
      });
      sidecars = toBlobSidecars2({
        blobs: blobs2,
        commitments: commitments2,
        proofs: proofs2
      });
    }
  }
  const serializedAccessList = serializeAccessList2(accessList);
  const serializedTransaction = [toHex2(chainId), nonce ? toHex2(nonce) : "0x", maxPriorityFeePerGas ? toHex2(maxPriorityFeePerGas) : "0x", maxFeePerGas ? toHex2(maxFeePerGas) : "0x", gas ? toHex2(gas) : "0x", to !== null && to !== void 0 ? to : "0x", value ? toHex2(value) : "0x", data !== null && data !== void 0 ? data : "0x", serializedAccessList, maxFeePerBlobGas ? toHex2(maxFeePerBlobGas) : "0x", (_blobVersionedHashes = blobVersionedHashes) !== null && _blobVersionedHashes !== void 0 ? _blobVersionedHashes : [], ...toYParitySignatureArray2(transaction, signature2)];
  const blobs = [];
  const commitments = [];
  const proofs = [];
  if (sidecars) for (let i = 0; i < sidecars.length; i++) {
    const {
      blob: blob12,
      commitment,
      proof
    } = sidecars[i];
    blobs.push(blob12);
    commitments.push(commitment);
    proofs.push(proof);
  }
  return concatHex2(["0x03", sidecars ? (
    // If sidecars are enabled, envelope turns into a "wrapper":
    toRlp2([serializedTransaction, blobs, commitments, proofs])
  ) : (
    // If sidecars are disabled, standard envelope is used:
    toRlp2(serializedTransaction)
  )]);
}
function serializeTransactionEIP1559(transaction, signature2) {
  const {
    chainId,
    gas,
    nonce,
    to,
    value,
    maxFeePerGas,
    maxPriorityFeePerGas,
    accessList,
    data
  } = transaction;
  assertTransactionEIP15592(transaction);
  const serializedAccessList = serializeAccessList2(accessList);
  const serializedTransaction = [toHex2(chainId), nonce ? toHex2(nonce) : "0x", maxPriorityFeePerGas ? toHex2(maxPriorityFeePerGas) : "0x", maxFeePerGas ? toHex2(maxFeePerGas) : "0x", gas ? toHex2(gas) : "0x", to !== null && to !== void 0 ? to : "0x", value ? toHex2(value) : "0x", data !== null && data !== void 0 ? data : "0x", serializedAccessList, ...toYParitySignatureArray2(transaction, signature2)];
  return concatHex2(["0x02", toRlp2(serializedTransaction)]);
}
function serializeTransactionEIP2930(transaction, signature2) {
  const {
    chainId,
    gas,
    data,
    nonce,
    to,
    value,
    accessList,
    gasPrice
  } = transaction;
  assertTransactionEIP29302(transaction);
  const serializedAccessList = serializeAccessList2(accessList);
  const serializedTransaction = [toHex2(chainId), nonce ? toHex2(nonce) : "0x", gasPrice ? toHex2(gasPrice) : "0x", gas ? toHex2(gas) : "0x", to !== null && to !== void 0 ? to : "0x", value ? toHex2(value) : "0x", data !== null && data !== void 0 ? data : "0x", serializedAccessList, ...toYParitySignatureArray2(transaction, signature2)];
  return concatHex2(["0x01", toRlp2(serializedTransaction)]);
}
function serializeTransactionLegacy(transaction, signature2) {
  const {
    chainId = 0,
    gas,
    data,
    nonce,
    to,
    value,
    gasPrice
  } = transaction;
  assertTransactionLegacy2(transaction);
  let serializedTransaction = [nonce ? toHex2(nonce) : "0x", gasPrice ? toHex2(gasPrice) : "0x", gas ? toHex2(gas) : "0x", to !== null && to !== void 0 ? to : "0x", value ? toHex2(value) : "0x", data !== null && data !== void 0 ? data : "0x"];
  if (signature2) {
    const v = (() => {
      if (signature2.v >= 35n) {
        const inferredChainId = (signature2.v - 35n) / 2n;
        if (inferredChainId > 0) return signature2.v;
        return 27n + (signature2.v === 35n ? 0n : 1n);
      }
      if (chainId > 0) return BigInt(chainId * 2) + BigInt(35n + signature2.v - 27n);
      const v2 = 27n + (signature2.v === 27n ? 0n : 1n);
      if (signature2.v !== v2) throw new InvalidLegacyVError2({
        v: signature2.v
      });
      return v2;
    })();
    const r = trim2(signature2.r);
    const s = trim2(signature2.s);
    serializedTransaction = [...serializedTransaction, toHex2(v), r === "0x00" ? "0x" : r, s === "0x00" ? "0x" : s];
  } else if (chainId > 0) {
    serializedTransaction = [...serializedTransaction, toHex2(chainId), "0x", "0x"];
  }
  return toRlp2(serializedTransaction);
}
function toYParitySignatureArray2(transaction, signature_) {
  const signature2 = signature_ !== null && signature_ !== void 0 ? signature_ : transaction;
  const {
    v,
    yParity
  } = signature2;
  if (typeof signature2.r === "undefined") return [];
  if (typeof signature2.s === "undefined") return [];
  if (typeof v === "undefined" && typeof yParity === "undefined") return [];
  const r = trim2(signature2.r);
  const s = trim2(signature2.s);
  const yParity_ = (() => {
    if (typeof yParity === "number") return yParity ? toHex2(1) : "0x";
    if (v === 0n) return "0x";
    if (v === 1n) return toHex2(1);
    return v === 27n ? "0x" : toHex2(1);
  })();
  return [yParity_, r === "0x00" ? "0x" : r, s === "0x00" ? "0x" : s];
}
function parseAccount2(account) {
  if (typeof account === "string") return {
    address: account,
    type: "json-rpc"
  };
  return account;
}
function publicKeyToAddress2(publicKey5) {
  const address = keccak2562(`0x${publicKey5.substring(4)}`).substring(26);
  return checksumAddress2(`0x${address}`);
}
function hashAuthorization2(parameters) {
  const {
    chainId,
    contractAddress,
    nonce,
    to
  } = parameters;
  const hash3 = keccak2562(concatHex2(["0x05", toRlp2([numberToHex2(chainId), contractAddress, nonce ? numberToHex2(nonce) : "0x"])]));
  if (to === "bytes") return hexToBytes$1(hash3);
  return hash3;
}
var stringify3 = (value, replacer, space) => JSON.stringify(value, (key, value_) => {
  const value2 = typeof value_ === "bigint" ? value_.toString() : value_;
  return typeof replacer === "function" ? replacer(key, value2) : value2;
}, space);
var AccountNotFoundError2 = class extends BaseError2 {
  constructor() {
    let {
      docsPath: docsPath3
    } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    super(["Could not find an Account to execute with this Action.", "Please provide an Account with the `account` argument on the Action, or by supplying an `account` to the Client."].join("\n"), {
      docsPath: docsPath3,
      docsSlug: "account",
      name: "AccountNotFoundError"
    });
  }
};
var AbiEncodingArrayLengthMismatchError2 = class extends BaseError2 {
  constructor(_ref5) {
    let {
      expectedLength,
      givenLength,
      type: type3
    } = _ref5;
    super([`ABI encoding array length mismatch for type ${type3}.`, `Expected length: ${expectedLength}`, `Given length: ${givenLength}`].join("\n"), {
      name: "AbiEncodingArrayLengthMismatchError"
    });
  }
};
var AbiEncodingBytesSizeMismatchError2 = class extends BaseError2 {
  constructor(_ref6) {
    let {
      expectedSize,
      value
    } = _ref6;
    super(`Size of bytes "${value}" (bytes${size3(value)}) does not match expected size (bytes${expectedSize}).`, {
      name: "AbiEncodingBytesSizeMismatchError"
    });
  }
};
var AbiEncodingLengthMismatchError2 = class extends BaseError2 {
  constructor(_ref7) {
    let {
      expectedLength,
      givenLength
    } = _ref7;
    super(["ABI encoding params/values length mismatch.", `Expected length (params): ${expectedLength}`, `Given length (values): ${givenLength}`].join("\n"), {
      name: "AbiEncodingLengthMismatchError"
    });
  }
};
var BytesSizeMismatchError2 = class extends BaseError2 {
  constructor(_ref12) {
    let {
      expectedSize,
      givenSize
    } = _ref12;
    super(`Expected bytes${expectedSize}, got bytes${givenSize}.`, {
      name: "BytesSizeMismatchError"
    });
  }
};
var InvalidAbiEncodingTypeError2 = class extends BaseError2 {
  constructor(type3, _ref15) {
    let {
      docsPath: docsPath3
    } = _ref15;
    super([`Type "${type3}" is not a valid encoding type.`, "Please provide a valid ABI type."].join("\n"), {
      docsPath: docsPath3,
      name: "InvalidAbiEncodingType"
    });
  }
};
var InvalidArrayError2 = class extends BaseError2 {
  constructor(value) {
    super([`Value "${value}" is not a valid array.`].join("\n"), {
      name: "InvalidArrayError"
    });
  }
};
function _defineProperty$1(e, r, t) {
  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
    value: t,
    enumerable: true,
    configurable: true,
    writable: true
  }) : e[r] = t, e;
}
function _toPrimitive(t, r) {
  if ("object" != typeof t || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r || "default");
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
function _toPropertyKey(t) {
  var i = _toPrimitive(t, "string");
  return "symbol" == typeof i ? i : i + "";
}
function encodeAbiParameters2(params, values) {
  if (params.length !== values.length) throw new AbiEncodingLengthMismatchError2({
    expectedLength: params.length,
    givenLength: values.length
  });
  const preparedParams = prepareParams({
    params,
    values
  });
  const data = encodeParams(preparedParams);
  if (data.length === 0) return "0x";
  return data;
}
function prepareParams(_ref) {
  let {
    params,
    values
  } = _ref;
  const preparedParams = [];
  for (let i = 0; i < params.length; i++) {
    preparedParams.push(prepareParam({
      param: params[i],
      value: values[i]
    }));
  }
  return preparedParams;
}
function prepareParam(_ref2) {
  let {
    param,
    value
  } = _ref2;
  const arrayComponents = getArrayComponents(param.type);
  if (arrayComponents) {
    const [length2, type3] = arrayComponents;
    return encodeArray(value, {
      length: length2,
      param: {
        ...param,
        type: type3
      }
    });
  }
  if (param.type === "tuple") {
    return encodeTuple(value, {
      param
    });
  }
  if (param.type === "address") {
    return encodeAddress(value);
  }
  if (param.type === "bool") {
    return encodeBool(value);
  }
  if (param.type.startsWith("uint") || param.type.startsWith("int")) {
    const signed = param.type.startsWith("int");
    return encodeNumber(value, {
      signed
    });
  }
  if (param.type.startsWith("bytes")) {
    return encodeBytes(value, {
      param
    });
  }
  if (param.type === "string") {
    return encodeString(value);
  }
  throw new InvalidAbiEncodingTypeError2(param.type, {
    docsPath: "/docs/contract/encodeAbiParameters"
  });
}
function encodeParams(preparedParams) {
  let staticSize = 0;
  for (let i = 0; i < preparedParams.length; i++) {
    const {
      dynamic,
      encoded
    } = preparedParams[i];
    if (dynamic) staticSize += 32;
    else staticSize += size3(encoded);
  }
  const staticParams = [];
  const dynamicParams = [];
  let dynamicSize = 0;
  for (let i = 0; i < preparedParams.length; i++) {
    const {
      dynamic,
      encoded
    } = preparedParams[i];
    if (dynamic) {
      staticParams.push(numberToHex2(staticSize + dynamicSize, {
        size: 32
      }));
      dynamicParams.push(encoded);
      dynamicSize += size3(encoded);
    } else {
      staticParams.push(encoded);
    }
  }
  return concat2([...staticParams, ...dynamicParams]);
}
function encodeAddress(value) {
  if (!isAddress2(value)) throw new InvalidAddressError2({
    address: value
  });
  return {
    dynamic: false,
    encoded: padHex2(value.toLowerCase())
  };
}
function encodeArray(value, _ref3) {
  let {
    length: length2,
    param
  } = _ref3;
  const dynamic = length2 === null;
  if (!Array.isArray(value)) throw new InvalidArrayError2(value);
  if (!dynamic && value.length !== length2) throw new AbiEncodingArrayLengthMismatchError2({
    expectedLength: length2,
    givenLength: value.length,
    type: `${param.type}[${length2}]`
  });
  let dynamicChild = false;
  const preparedParams = [];
  for (let i = 0; i < value.length; i++) {
    const preparedParam = prepareParam({
      param,
      value: value[i]
    });
    if (preparedParam.dynamic) dynamicChild = true;
    preparedParams.push(preparedParam);
  }
  if (dynamic || dynamicChild) {
    const data = encodeParams(preparedParams);
    if (dynamic) {
      const length3 = numberToHex2(preparedParams.length, {
        size: 32
      });
      return {
        dynamic: true,
        encoded: preparedParams.length > 0 ? concat2([length3, data]) : length3
      };
    }
    if (dynamicChild) return {
      dynamic: true,
      encoded: data
    };
  }
  return {
    dynamic: false,
    encoded: concat2(preparedParams.map((_ref4) => {
      let {
        encoded
      } = _ref4;
      return encoded;
    }))
  };
}
function encodeBytes(value, _ref5) {
  let {
    param
  } = _ref5;
  const [, paramSize] = param.type.split("bytes");
  const bytesSize = size3(value);
  if (!paramSize) {
    let value_ = value;
    if (bytesSize % 32 !== 0) value_ = padHex2(value_, {
      dir: "right",
      size: Math.ceil((value.length - 2) / 2 / 32) * 32
    });
    return {
      dynamic: true,
      encoded: concat2([padHex2(numberToHex2(bytesSize, {
        size: 32
      })), value_])
    };
  }
  if (bytesSize !== Number.parseInt(paramSize)) throw new AbiEncodingBytesSizeMismatchError2({
    expectedSize: Number.parseInt(paramSize),
    value
  });
  return {
    dynamic: false,
    encoded: padHex2(value, {
      dir: "right"
    })
  };
}
function encodeBool(value) {
  if (typeof value !== "boolean") throw new BaseError2(`Invalid boolean value: "${value}" (type: ${typeof value}). Expected: \`true\` or \`false\`.`);
  return {
    dynamic: false,
    encoded: padHex2(boolToHex2(value))
  };
}
function encodeNumber(value, _ref6) {
  let {
    signed
  } = _ref6;
  return {
    dynamic: false,
    encoded: numberToHex2(value, {
      size: 32,
      signed
    })
  };
}
function encodeString(value) {
  const hexValue = stringToHex2(value);
  const partsLength = Math.ceil(size3(hexValue) / 32);
  const parts = [];
  for (let i = 0; i < partsLength; i++) {
    parts.push(padHex2(slice2(hexValue, i * 32, (i + 1) * 32), {
      dir: "right"
    }));
  }
  return {
    dynamic: true,
    encoded: concat2([padHex2(numberToHex2(size3(hexValue), {
      size: 32
    })), ...parts])
  };
}
function encodeTuple(value, _ref7) {
  let {
    param
  } = _ref7;
  let dynamic = false;
  const preparedParams = [];
  for (let i = 0; i < param.components.length; i++) {
    const param_ = param.components[i];
    const index4 = Array.isArray(value) ? i : param_.name;
    const preparedParam = prepareParam({
      param: param_,
      value: value[index4]
    });
    preparedParams.push(preparedParam);
    if (preparedParam.dynamic) dynamic = true;
  }
  return {
    dynamic,
    encoded: dynamic ? encodeParams(preparedParams) : concat2(preparedParams.map((_ref8) => {
      let {
        encoded
      } = _ref8;
      return encoded;
    }))
  };
}
function getArrayComponents(type3) {
  const matches = type3.match(/^(.*)\[(\d+)?\]$/);
  return matches ? (
    // Return `null` if the array is dynamic.
    [matches[2] ? Number(matches[2]) : null, matches[1]]
  ) : void 0;
}
var mainnet = defineChain2({
  id: 1,
  name: "Ethereum",
  nativeCurrency: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://cloudflare-eth.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Etherscan",
      url: "https://etherscan.io",
      apiUrl: "https://api.etherscan.io/api"
    }
  },
  contracts: {
    ensRegistry: {
      address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e"
    },
    ensUniversalResolver: {
      address: "0xce01f8eee7E479C928F8919abD53E553a36CeF67",
      blockCreated: 19258213
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 14353601
    }
  }
});
var BASE_PATH$1 = "/v1".replace(/\/+$/, "");
var Configuration$1 = class {
  constructor() {
    let configuration = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    _defineProperty$1(this, "configuration", void 0);
    this.configuration = configuration;
  }
  set config(configuration) {
    this.configuration = configuration;
  }
  get basePath() {
    return this.configuration.basePath != null ? this.configuration.basePath : BASE_PATH$1;
  }
  get fetchApi() {
    return this.configuration.fetchApi;
  }
  get middleware() {
    return this.configuration.middleware || [];
  }
  get queryParamsStringify() {
    return this.configuration.queryParamsStringify || querystring$1;
  }
  get username() {
    return this.configuration.username;
  }
  get password() {
    return this.configuration.password;
  }
  get apiKey() {
    const apiKey2 = this.configuration.apiKey;
    if (apiKey2) {
      return typeof apiKey2 === "function" ? apiKey2 : () => apiKey2;
    }
    return void 0;
  }
  get accessToken() {
    const accessToken = this.configuration.accessToken;
    if (accessToken) {
      return typeof accessToken === "function" ? accessToken : async () => accessToken;
    }
    return void 0;
  }
  get headers() {
    return this.configuration.headers;
  }
  get credentials() {
    return this.configuration.credentials;
  }
};
var DefaultConfig$1 = new Configuration$1();
var BaseAPI$1 = class {
  constructor() {
    let configuration = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : DefaultConfig$1;
    _defineProperty$1(this, "configuration", void 0);
    _defineProperty$1(this, "middleware", void 0);
    _defineProperty$1(this, "fetchApi", async (url, init) => {
      let fetchParams = {
        url,
        init
      };
      for (const middleware of this.middleware) {
        if (middleware.pre) {
          fetchParams = await middleware.pre({
            fetch: this.fetchApi,
            ...fetchParams
          }) || fetchParams;
        }
      }
      let response = void 0;
      try {
        response = await (this.configuration.fetchApi || fetch)(fetchParams.url, fetchParams.init);
      } catch (e) {
        for (const middleware of this.middleware) {
          if (middleware.onError) {
            response = await middleware.onError({
              fetch: this.fetchApi,
              url: fetchParams.url,
              init: fetchParams.init,
              error: e,
              response: response ? response.clone() : void 0
            }) || response;
          }
        }
        if (response === void 0) {
          if (e instanceof Error) {
            throw new FetchError$1(e, "The request failed and the interceptors did not return an alternative response");
          } else {
            throw e;
          }
        }
      }
      for (const middleware of this.middleware) {
        if (middleware.post) {
          response = await middleware.post({
            fetch: this.fetchApi,
            url: fetchParams.url,
            init: fetchParams.init,
            response: response.clone()
          }) || response;
        }
      }
      return response;
    });
    this.configuration = configuration;
    this.middleware = configuration.middleware;
  }
  /** @hidden */
  withMiddleware() {
    const next = this.clone();
    next.middleware = next.middleware.concat(...arguments);
    return next;
  }
  /** @hidden */
  withPreMiddleware() {
    for (var _len = arguments.length, preMiddlewares = new Array(_len), _key = 0; _key < _len; _key++) {
      preMiddlewares[_key] = arguments[_key];
    }
    const middlewares = preMiddlewares.map((pre) => ({
      pre
    }));
    return this.withMiddleware(...middlewares);
  }
  /** @hidden */
  withPostMiddleware() {
    for (var _len2 = arguments.length, postMiddlewares = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      postMiddlewares[_key2] = arguments[_key2];
    }
    const middlewares = postMiddlewares.map((post) => ({
      post
    }));
    return this.withMiddleware(...middlewares);
  }
  /** @hidden */
  async request(context, initOverrides) {
    const {
      url,
      init
    } = await this.createFetchParams(context, initOverrides);
    const response = await this.fetchApi(url, init);
    if (response && response.status >= 200 && response.status < 300) {
      return response;
    }
    throw new ResponseError$1(response, "Response returned an error code");
  }
  async createFetchParams(context, initOverrides) {
    let url = this.configuration.basePath + context.path;
    if (context.query !== void 0 && Object.keys(context.query).length !== 0) {
      url += "?" + this.configuration.queryParamsStringify(context.query);
    }
    const headers = Object.assign({}, this.configuration.headers, context.headers);
    Object.keys(headers).forEach((key) => headers[key] === void 0 ? delete headers[key] : {});
    const initOverrideFn = typeof initOverrides === "function" ? initOverrides : async () => initOverrides;
    const initParams = {
      method: context.method,
      headers,
      body: context.body,
      credentials: this.configuration.credentials
    };
    const overriddenInit = {
      ...initParams,
      ...await initOverrideFn({
        init: initParams,
        context
      })
    };
    const init = {
      ...overriddenInit,
      body: isFormData$1(overriddenInit.body) || overriddenInit.body instanceof URLSearchParams || isBlob$1(overriddenInit.body) || isString$1(overriddenInit.body) ? overriddenInit.body : JSON.stringify(overriddenInit.body)
    };
    return {
      url,
      init
    };
  }
  /**
   * Create a shallow clone of `this` by constructing a new instance
   * and then shallow cloning data members.
   */
  clone() {
    const constructor = this.constructor;
    const next = new constructor(this.configuration);
    next.middleware = this.middleware.slice();
    return next;
  }
};
function isBlob$1(value) {
  return typeof Blob !== "undefined" && value instanceof Blob;
}
function isFormData$1(value) {
  return typeof FormData !== "undefined" && value instanceof FormData;
}
function isString$1(value) {
  return typeof value === "string";
}
var ResponseError$1 = class extends Error {
  constructor(response, msg) {
    super(msg);
    _defineProperty$1(this, "response", void 0);
    _defineProperty$1(this, "name", "ResponseError");
    this.response = response;
  }
};
var FetchError$1 = class extends Error {
  constructor(cause, msg) {
    super(msg, {
      cause
    });
    _defineProperty$1(this, "name", "FetchError");
  }
};
var RequiredError$1 = class extends Error {
  constructor(field, msg) {
    super(msg);
    _defineProperty$1(this, "field", void 0);
    _defineProperty$1(this, "name", "RequiredError");
    this.field = field;
  }
};
var COLLECTION_FORMATS$1 = {
  csv: ",",
  ssv: " ",
  tsv: "	",
  pipes: "|"
};
function exists$2(json, key) {
  const value = json[key];
  return value !== null && value !== void 0;
}
function querystring$1(params) {
  let prefix = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
  return Object.keys(params).sort().map((key) => querystringSingleKey$1(key, params[key], prefix)).filter((part) => part.length > 0).join("&");
}
function querystringSingleKey$1(key, value) {
  let keyPrefix = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "";
  const fullKey = keyPrefix + (keyPrefix.length ? `[${key}]` : key);
  if (value instanceof Array) {
    const multiValue = value.map((singleValue) => encodeURIComponent(String(singleValue))).join(`&${encodeURIComponent(fullKey)}=`);
    return `${encodeURIComponent(fullKey)}=${multiValue}`;
  }
  if (value instanceof Set) {
    const valueAsArray = Array.from(value);
    return querystringSingleKey$1(key, valueAsArray, keyPrefix);
  }
  if (value instanceof Date) {
    return `${encodeURIComponent(fullKey)}=${encodeURIComponent(value.toISOString())}`;
  }
  if (value instanceof Object) {
    return querystring$1(value, fullKey);
  }
  return `${encodeURIComponent(fullKey)}=${encodeURIComponent(String(value))}`;
}
function mapValues$1(data, fn) {
  return Object.keys(data).reduce((acc, key) => ({
    ...acc,
    [key]: fn(data[key])
  }), {});
}
function canConsumeForm$1(consumes) {
  for (const consume of consumes) {
    if ("multipart/form-data" === consume.contentType) {
      return true;
    }
  }
  return false;
}
var JSONApiResponse$1 = class {
  constructor(raw) {
    let transformer = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : (jsonValue) => jsonValue;
    _defineProperty$1(this, "raw", void 0);
    _defineProperty$1(this, "transformer", void 0);
    this.raw = raw;
    this.transformer = transformer;
  }
  async value() {
    return this.transformer(await this.raw.json());
  }
};
var VoidApiResponse$1 = class {
  constructor(raw) {
    _defineProperty$1(this, "raw", void 0);
    this.raw = raw;
  }
  async value() {
    return void 0;
  }
};
var BlobApiResponse$1 = class {
  constructor(raw) {
    _defineProperty$1(this, "raw", void 0);
    this.raw = raw;
  }
  async value() {
    return await this.raw.blob();
  }
};
var TextApiResponse$1 = class {
  constructor(raw) {
    _defineProperty$1(this, "raw", void 0);
    this.raw = raw;
  }
  async value() {
    return await this.raw.text();
  }
};
function instanceOfAccess$1(value) {
  let isInstance = true;
  isInstance = isInstance && "stream" in value && value["stream"] !== void 0;
  isInstance = isInstance && "download" in value && value["download"] !== void 0;
  return isInstance;
}
function AccessFromJSON$1(json) {
  return AccessFromJSONTyped$1(json);
}
function AccessFromJSONTyped$1(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "stream": json["stream"],
    "download": json["download"]
  };
}
function AccessToJSON$1(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "stream": value.stream,
    "download": value.download
  };
}
function instanceOfExtendedPaymentSplit(value) {
  let isInstance = true;
  isInstance = isInstance && "percentage" in value && value["percentage"] !== void 0;
  isInstance = isInstance && "payoutWallet" in value && value["payoutWallet"] !== void 0;
  isInstance = isInstance && "amount" in value && value["amount"] !== void 0;
  return isInstance;
}
function ExtendedPaymentSplitFromJSON(json) {
  return ExtendedPaymentSplitFromJSONTyped(json);
}
function ExtendedPaymentSplitFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "userId": !exists$2(json, "user_id") ? void 0 : json["user_id"],
    "percentage": json["percentage"],
    "ethWallet": !exists$2(json, "eth_wallet") ? void 0 : json["eth_wallet"],
    "payoutWallet": json["payout_wallet"],
    "amount": json["amount"]
  };
}
function ExtendedPaymentSplitToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "user_id": value.userId,
    "percentage": value.percentage,
    "eth_wallet": value.ethWallet,
    "payout_wallet": value.payoutWallet,
    "amount": value.amount
  };
}
function instanceOfExtendedUsdcGate(value) {
  let isInstance = true;
  isInstance = isInstance && "price" in value && value["price"] !== void 0;
  isInstance = isInstance && "splits" in value && value["splits"] !== void 0;
  return isInstance;
}
function ExtendedUsdcGateFromJSON(json) {
  return ExtendedUsdcGateFromJSONTyped(json);
}
function ExtendedUsdcGateFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "price": json["price"],
    "splits": json["splits"].map(ExtendedPaymentSplitFromJSON)
  };
}
function ExtendedUsdcGateToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "price": value.price,
    "splits": value.splits.map(ExtendedPaymentSplitToJSON)
  };
}
function instanceOfExtendedPurchaseGate(value) {
  let isInstance = true;
  isInstance = isInstance && "usdcPurchase" in value && value["usdcPurchase"] !== void 0;
  return isInstance;
}
function ExtendedPurchaseGateFromJSON(json) {
  return ExtendedPurchaseGateFromJSONTyped(json);
}
function ExtendedPurchaseGateFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "usdcPurchase": ExtendedUsdcGateFromJSON(json["usdc_purchase"])
  };
}
function ExtendedPurchaseGateToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "usdc_purchase": ExtendedUsdcGateToJSON(value.usdcPurchase)
  };
}
function instanceOfFollowGate$1(value) {
  let isInstance = true;
  isInstance = isInstance && "followUserId" in value && value["followUserId"] !== void 0;
  return isInstance;
}
function FollowGateFromJSON$1(json) {
  return FollowGateFromJSONTyped$1(json);
}
function FollowGateFromJSONTyped$1(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "followUserId": json["follow_user_id"]
  };
}
function FollowGateToJSON$1(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "follow_user_id": value.followUserId
  };
}
var NftCollectionChainEnum$1 = {
  Eth: "eth",
  Sol: "sol"
};
var NftCollectionStandardEnum$1 = {
  Erc721: "ERC721",
  Erc1155: "ERC1155"
};
function instanceOfNftCollection$1(value) {
  let isInstance = true;
  isInstance = isInstance && "chain" in value && value["chain"] !== void 0;
  isInstance = isInstance && "address" in value && value["address"] !== void 0;
  isInstance = isInstance && "name" in value && value["name"] !== void 0;
  return isInstance;
}
function NftCollectionFromJSON$1(json) {
  return NftCollectionFromJSONTyped$1(json);
}
function NftCollectionFromJSONTyped$1(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "chain": json["chain"],
    "standard": !exists$2(json, "standard") ? void 0 : json["standard"],
    "address": json["address"],
    "name": json["name"],
    "imageUrl": !exists$2(json, "imageUrl") ? void 0 : json["imageUrl"],
    "externalLink": !exists$2(json, "externalLink") ? void 0 : json["externalLink"]
  };
}
function NftCollectionToJSON$1(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "chain": value.chain,
    "standard": value.standard,
    "address": value.address,
    "name": value.name,
    "imageUrl": value.imageUrl,
    "externalLink": value.externalLink
  };
}
function instanceOfNftGate$1(value) {
  let isInstance = true;
  isInstance = isInstance && "nftCollection" in value && value["nftCollection"] !== void 0;
  return isInstance;
}
function NftGateFromJSON$1(json) {
  return NftGateFromJSONTyped$1(json);
}
function NftGateFromJSONTyped$1(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "nftCollection": NftCollectionFromJSON$1(json["nft_collection"])
  };
}
function NftGateToJSON$1(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "nft_collection": NftCollectionToJSON$1(value.nftCollection)
  };
}
function instanceOfTipGate$1(value) {
  let isInstance = true;
  isInstance = isInstance && "tipUserId" in value && value["tipUserId"] !== void 0;
  return isInstance;
}
function TipGateFromJSON$1(json) {
  return TipGateFromJSONTyped$1(json);
}
function TipGateFromJSONTyped$1(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "tipUserId": json["tip_user_id"]
  };
}
function TipGateToJSON$1(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "tip_user_id": value.tipUserId
  };
}
function instanceOfExtendedTokenGate$1(value) {
  let isInstance = true;
  isInstance = isInstance && "tokenMint" in value && value["tokenMint"] !== void 0;
  isInstance = isInstance && "tokenAmount" in value && value["tokenAmount"] !== void 0;
  return isInstance;
}
function ExtendedTokenGateFromJSON$1(json) {
  return ExtendedTokenGateFromJSONTyped$1(json);
}
function ExtendedTokenGateFromJSONTyped$1(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "tokenMint": json["token_mint"],
    "tokenAmount": json["token_amount"]
  };
}
function ExtendedTokenGateToJSON$1(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "token_mint": value.tokenMint,
    "token_amount": value.tokenAmount
  };
}
function instanceOfTokenGate$1(value) {
  let isInstance = true;
  isInstance = isInstance && "tokenGate" in value && value["tokenGate"] !== void 0;
  return isInstance;
}
function TokenGateFromJSON$1(json) {
  return TokenGateFromJSONTyped$1(json);
}
function TokenGateFromJSONTyped$1(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "tokenGate": ExtendedTokenGateFromJSON$1(json["token_gate"])
  };
}
function TokenGateToJSON$1(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "token_gate": ExtendedTokenGateToJSON$1(value.tokenGate)
  };
}
function ExtendedAccessGateFromJSON(json) {
  return ExtendedAccessGateFromJSONTyped(json);
}
function ExtendedAccessGateFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    ...ExtendedPurchaseGateFromJSONTyped(json),
    ...FollowGateFromJSONTyped$1(json),
    ...NftGateFromJSONTyped$1(json),
    ...TipGateFromJSONTyped$1(json),
    ...TokenGateFromJSONTyped$1(json)
  };
}
function ExtendedAccessGateToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  if (instanceOfExtendedPurchaseGate(value)) {
    return ExtendedPurchaseGateToJSON(value);
  }
  if (instanceOfFollowGate$1(value)) {
    return FollowGateToJSON$1(value);
  }
  if (instanceOfNftGate$1(value)) {
    return NftGateToJSON$1(value);
  }
  if (instanceOfTipGate$1(value)) {
    return TipGateToJSON$1(value);
  }
  if (instanceOfTokenGate$1(value)) {
    return TokenGateToJSON$1(value);
  }
  return {};
}
function instanceOfTrackAccessInfo(value) {
  let isInstance = true;
  isInstance = isInstance && "userId" in value && value["userId"] !== void 0;
  isInstance = isInstance && "blocknumber" in value && value["blocknumber"] !== void 0;
  return isInstance;
}
function TrackAccessInfoFromJSON(json) {
  return TrackAccessInfoFromJSONTyped(json);
}
function TrackAccessInfoFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "access": !exists$2(json, "access") ? void 0 : AccessFromJSON$1(json["access"]),
    "userId": json["user_id"],
    "blocknumber": json["blocknumber"],
    "isStreamGated": !exists$2(json, "is_stream_gated") ? void 0 : json["is_stream_gated"],
    "streamConditions": !exists$2(json, "stream_conditions") ? void 0 : ExtendedAccessGateFromJSON(json["stream_conditions"]),
    "isDownloadGated": !exists$2(json, "is_download_gated") ? void 0 : json["is_download_gated"],
    "downloadConditions": !exists$2(json, "download_conditions") ? void 0 : ExtendedAccessGateFromJSON(json["download_conditions"])
  };
}
function TrackAccessInfoToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "access": AccessToJSON$1(value.access),
    "user_id": value.userId,
    "blocknumber": value.blocknumber,
    "is_stream_gated": value.isStreamGated,
    "stream_conditions": ExtendedAccessGateToJSON(value.streamConditions),
    "is_download_gated": value.isDownloadGated,
    "download_conditions": ExtendedAccessGateToJSON(value.downloadConditions)
  };
}
function instanceOfAccessInfoResponse(value) {
  let isInstance = true;
  return isInstance;
}
function AccessInfoResponseFromJSON(json) {
  return AccessInfoResponseFromJSONTyped(json);
}
function AccessInfoResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "data": !exists$2(json, "data") ? void 0 : TrackAccessInfoFromJSON(json["data"])
  };
}
function AccessInfoResponseToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "data": TrackAccessInfoToJSON(value.data)
  };
}
var ActivityItemTypeEnum = {
  Track: "track",
  Playlist: "playlist"
};
function instanceOfActivity(value) {
  let isInstance = true;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== void 0;
  isInstance = isInstance && "itemType" in value && value["itemType"] !== void 0;
  isInstance = isInstance && "item" in value && value["item"] !== void 0;
  isInstance = isInstance && "_class" in value && value["_class"] !== void 0;
  return isInstance;
}
function ActivityFromJSON(json) {
  return ActivityFromJSONTyped(json, false);
}
function ActivityFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  if (!ignoreDiscriminator) {
    if (json["_class"] === "collection_activity") {
      return CollectionActivityFromJSONTyped(json, true);
    }
    if (json["_class"] === "track_activity") {
      return TrackActivityFromJSONTyped(json, true);
    }
  }
  return {
    "timestamp": json["timestamp"],
    "itemType": json["item_type"],
    "item": json["item"],
    "_class": json["class"]
  };
}
function ActivityToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "timestamp": value.timestamp,
    "item_type": value.itemType,
    "item": value.item,
    "class": value._class
  };
}
function instanceOfAlbumBacklink$1(value) {
  let isInstance = true;
  isInstance = isInstance && "playlistId" in value && value["playlistId"] !== void 0;
  isInstance = isInstance && "playlistName" in value && value["playlistName"] !== void 0;
  isInstance = isInstance && "permalink" in value && value["permalink"] !== void 0;
  return isInstance;
}
function AlbumBacklinkFromJSON$1(json) {
  return AlbumBacklinkFromJSONTyped$1(json);
}
function AlbumBacklinkFromJSONTyped$1(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "playlistId": json["playlist_id"],
    "playlistName": json["playlist_name"],
    "permalink": json["permalink"]
  };
}
function AlbumBacklinkToJSON$1(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "playlist_id": value.playlistId,
    "playlist_name": value.playlistName,
    "permalink": value.permalink
  };
}
function instanceOfPlaylistAddedTimestamp$1(value) {
  let isInstance = true;
  isInstance = isInstance && "metadataTimestamp" in value && value["metadataTimestamp"] !== void 0;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== void 0;
  isInstance = isInstance && "trackId" in value && value["trackId"] !== void 0;
  return isInstance;
}
function PlaylistAddedTimestampFromJSON$1(json) {
  return PlaylistAddedTimestampFromJSONTyped$1(json);
}
function PlaylistAddedTimestampFromJSONTyped$1(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "metadataTimestamp": json["metadata_timestamp"],
    "timestamp": json["timestamp"],
    "trackId": json["track_id"]
  };
}
function PlaylistAddedTimestampToJSON$1(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "metadata_timestamp": value.metadataTimestamp,
    "timestamp": value.timestamp,
    "track_id": value.trackId
  };
}
function instanceOfPlaylistArtwork$1(value) {
  let isInstance = true;
  return isInstance;
}
function PlaylistArtworkFromJSON$1(json) {
  return PlaylistArtworkFromJSONTyped$1(json);
}
function PlaylistArtworkFromJSONTyped$1(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "_150x150": !exists$2(json, "150x150") ? void 0 : json["150x150"],
    "_480x480": !exists$2(json, "480x480") ? void 0 : json["480x480"],
    "_1000x1000": !exists$2(json, "1000x1000") ? void 0 : json["1000x1000"]
  };
}
function PlaylistArtworkToJSON$1(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "150x150": value._150x150,
    "480x480": value._480x480,
    "1000x1000": value._1000x1000
  };
}
function instanceOfCoverPhoto$1(value) {
  let isInstance = true;
  return isInstance;
}
function CoverPhotoFromJSON$1(json) {
  return CoverPhotoFromJSONTyped$1(json);
}
function CoverPhotoFromJSONTyped$1(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "_640x": !exists$2(json, "640x") ? void 0 : json["640x"],
    "_2000x": !exists$2(json, "2000x") ? void 0 : json["2000x"]
  };
}
function CoverPhotoToJSON$1(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "640x": value._640x,
    "2000x": value._2000x
  };
}
function instanceOfProfilePicture$1(value) {
  let isInstance = true;
  return isInstance;
}
function ProfilePictureFromJSON$1(json) {
  return ProfilePictureFromJSONTyped$1(json);
}
function ProfilePictureFromJSONTyped$1(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "_150x150": !exists$2(json, "150x150") ? void 0 : json["150x150"],
    "_480x480": !exists$2(json, "480x480") ? void 0 : json["480x480"],
    "_1000x1000": !exists$2(json, "1000x1000") ? void 0 : json["1000x1000"]
  };
}
function ProfilePictureToJSON$1(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "150x150": value._150x150,
    "480x480": value._480x480,
    "1000x1000": value._1000x1000
  };
}
function instanceOfUser(value) {
  let isInstance = true;
  isInstance = isInstance && "albumCount" in value && value["albumCount"] !== void 0;
  isInstance = isInstance && "followeeCount" in value && value["followeeCount"] !== void 0;
  isInstance = isInstance && "followerCount" in value && value["followerCount"] !== void 0;
  isInstance = isInstance && "handle" in value && value["handle"] !== void 0;
  isInstance = isInstance && "id" in value && value["id"] !== void 0;
  isInstance = isInstance && "isVerified" in value && value["isVerified"] !== void 0;
  isInstance = isInstance && "verifiedWithTwitter" in value && value["verifiedWithTwitter"] !== void 0;
  isInstance = isInstance && "verifiedWithInstagram" in value && value["verifiedWithInstagram"] !== void 0;
  isInstance = isInstance && "verifiedWithTiktok" in value && value["verifiedWithTiktok"] !== void 0;
  isInstance = isInstance && "name" in value && value["name"] !== void 0;
  isInstance = isInstance && "playlistCount" in value && value["playlistCount"] !== void 0;
  isInstance = isInstance && "repostCount" in value && value["repostCount"] !== void 0;
  isInstance = isInstance && "trackCount" in value && value["trackCount"] !== void 0;
  isInstance = isInstance && "isDeactivated" in value && value["isDeactivated"] !== void 0;
  isInstance = isInstance && "isAvailable" in value && value["isAvailable"] !== void 0;
  isInstance = isInstance && "ercWallet" in value && value["ercWallet"] !== void 0;
  isInstance = isInstance && "splWallet" in value && value["splWallet"] !== void 0;
  isInstance = isInstance && "splUsdcWallet" in value && value["splUsdcWallet"] !== void 0;
  isInstance = isInstance && "supporterCount" in value && value["supporterCount"] !== void 0;
  isInstance = isInstance && "supportingCount" in value && value["supportingCount"] !== void 0;
  isInstance = isInstance && "totalAudioBalance" in value && value["totalAudioBalance"] !== void 0;
  isInstance = isInstance && "wallet" in value && value["wallet"] !== void 0;
  return isInstance;
}
function UserFromJSON(json) {
  return UserFromJSONTyped(json);
}
function UserFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "albumCount": json["album_count"],
    "artistPickTrackId": !exists$2(json, "artist_pick_track_id") ? void 0 : json["artist_pick_track_id"],
    "bio": !exists$2(json, "bio") ? void 0 : json["bio"],
    "coverPhoto": !exists$2(json, "cover_photo") ? void 0 : CoverPhotoFromJSON$1(json["cover_photo"]),
    "followeeCount": json["followee_count"],
    "followerCount": json["follower_count"],
    "handle": json["handle"],
    "id": json["id"],
    "isVerified": json["is_verified"],
    "twitterHandle": !exists$2(json, "twitter_handle") ? void 0 : json["twitter_handle"],
    "instagramHandle": !exists$2(json, "instagram_handle") ? void 0 : json["instagram_handle"],
    "tiktokHandle": !exists$2(json, "tiktok_handle") ? void 0 : json["tiktok_handle"],
    "verifiedWithTwitter": json["verified_with_twitter"],
    "verifiedWithInstagram": json["verified_with_instagram"],
    "verifiedWithTiktok": json["verified_with_tiktok"],
    "website": !exists$2(json, "website") ? void 0 : json["website"],
    "donation": !exists$2(json, "donation") ? void 0 : json["donation"],
    "location": !exists$2(json, "location") ? void 0 : json["location"],
    "name": json["name"],
    "playlistCount": json["playlist_count"],
    "profilePicture": !exists$2(json, "profile_picture") ? void 0 : ProfilePictureFromJSON$1(json["profile_picture"]),
    "repostCount": json["repost_count"],
    "trackCount": json["track_count"],
    "isDeactivated": json["is_deactivated"],
    "isAvailable": json["is_available"],
    "ercWallet": json["erc_wallet"],
    "splWallet": json["spl_wallet"],
    "splUsdcWallet": json["spl_usdc_wallet"],
    "splUsdcPayoutWallet": !exists$2(json, "spl_usdc_payout_wallet") ? void 0 : json["spl_usdc_payout_wallet"],
    "supporterCount": json["supporter_count"],
    "supportingCount": json["supporting_count"],
    "totalAudioBalance": json["total_audio_balance"],
    "wallet": json["wallet"]
  };
}
function UserToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "album_count": value.albumCount,
    "artist_pick_track_id": value.artistPickTrackId,
    "bio": value.bio,
    "cover_photo": CoverPhotoToJSON$1(value.coverPhoto),
    "followee_count": value.followeeCount,
    "follower_count": value.followerCount,
    "handle": value.handle,
    "id": value.id,
    "is_verified": value.isVerified,
    "twitter_handle": value.twitterHandle,
    "instagram_handle": value.instagramHandle,
    "tiktok_handle": value.tiktokHandle,
    "verified_with_twitter": value.verifiedWithTwitter,
    "verified_with_instagram": value.verifiedWithInstagram,
    "verified_with_tiktok": value.verifiedWithTiktok,
    "website": value.website,
    "donation": value.donation,
    "location": value.location,
    "name": value.name,
    "playlist_count": value.playlistCount,
    "profile_picture": ProfilePictureToJSON$1(value.profilePicture),
    "repost_count": value.repostCount,
    "track_count": value.trackCount,
    "is_deactivated": value.isDeactivated,
    "is_available": value.isAvailable,
    "erc_wallet": value.ercWallet,
    "spl_wallet": value.splWallet,
    "spl_usdc_wallet": value.splUsdcWallet,
    "spl_usdc_payout_wallet": value.splUsdcPayoutWallet,
    "supporter_count": value.supporterCount,
    "supporting_count": value.supportingCount,
    "total_audio_balance": value.totalAudioBalance,
    "wallet": value.wallet
  };
}
function instanceOfPlaylist(value) {
  let isInstance = true;
  isInstance = isInstance && "permalink" in value && value["permalink"] !== void 0;
  isInstance = isInstance && "id" in value && value["id"] !== void 0;
  isInstance = isInstance && "isAlbum" in value && value["isAlbum"] !== void 0;
  isInstance = isInstance && "isImageAutogenerated" in value && value["isImageAutogenerated"] !== void 0;
  isInstance = isInstance && "playlistName" in value && value["playlistName"] !== void 0;
  isInstance = isInstance && "playlistContents" in value && value["playlistContents"] !== void 0;
  isInstance = isInstance && "repostCount" in value && value["repostCount"] !== void 0;
  isInstance = isInstance && "favoriteCount" in value && value["favoriteCount"] !== void 0;
  isInstance = isInstance && "totalPlayCount" in value && value["totalPlayCount"] !== void 0;
  isInstance = isInstance && "user" in value && value["user"] !== void 0;
  isInstance = isInstance && "access" in value && value["access"] !== void 0;
  isInstance = isInstance && "trackCount" in value && value["trackCount"] !== void 0;
  return isInstance;
}
function PlaylistFromJSON(json) {
  return PlaylistFromJSONTyped(json);
}
function PlaylistFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "artwork": !exists$2(json, "artwork") ? void 0 : PlaylistArtworkFromJSON$1(json["artwork"]),
    "description": !exists$2(json, "description") ? void 0 : json["description"],
    "permalink": json["permalink"],
    "id": json["id"],
    "isAlbum": json["is_album"],
    "isImageAutogenerated": json["is_image_autogenerated"],
    "playlistName": json["playlist_name"],
    "playlistContents": json["playlist_contents"].map(PlaylistAddedTimestampFromJSON$1),
    "repostCount": json["repost_count"],
    "favoriteCount": json["favorite_count"],
    "totalPlayCount": json["total_play_count"],
    "user": UserFromJSON(json["user"]),
    "ddexApp": !exists$2(json, "ddex_app") ? void 0 : json["ddex_app"],
    "access": AccessFromJSON$1(json["access"]),
    "upc": !exists$2(json, "upc") ? void 0 : json["upc"],
    "trackCount": json["track_count"]
  };
}
function PlaylistToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "artwork": PlaylistArtworkToJSON$1(value.artwork),
    "description": value.description,
    "permalink": value.permalink,
    "id": value.id,
    "is_album": value.isAlbum,
    "is_image_autogenerated": value.isImageAutogenerated,
    "playlist_name": value.playlistName,
    "playlist_contents": value.playlistContents.map(PlaylistAddedTimestampToJSON$1),
    "repost_count": value.repostCount,
    "favorite_count": value.favoriteCount,
    "total_play_count": value.totalPlayCount,
    "user": UserToJSON(value.user),
    "ddex_app": value.ddexApp,
    "access": AccessToJSON$1(value.access),
    "upc": value.upc,
    "track_count": value.trackCount
  };
}
function instanceOfAlbumsResponse(value) {
  let isInstance = true;
  return isInstance;
}
function AlbumsResponseFromJSON(json) {
  return AlbumsResponseFromJSONTyped(json);
}
function AlbumsResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "data": !exists$2(json, "data") ? void 0 : json["data"].map(PlaylistFromJSON)
  };
}
function AlbumsResponseToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "data": value.data === void 0 ? void 0 : value.data.map(PlaylistToJSON)
  };
}
function instanceOfAuthorizedApp(value) {
  let isInstance = true;
  isInstance = isInstance && "address" in value && value["address"] !== void 0;
  isInstance = isInstance && "name" in value && value["name"] !== void 0;
  isInstance = isInstance && "grantorUserId" in value && value["grantorUserId"] !== void 0;
  isInstance = isInstance && "grantCreatedAt" in value && value["grantCreatedAt"] !== void 0;
  isInstance = isInstance && "grantUpdatedAt" in value && value["grantUpdatedAt"] !== void 0;
  return isInstance;
}
function AuthorizedAppFromJSON(json) {
  return AuthorizedAppFromJSONTyped(json);
}
function AuthorizedAppFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "address": json["address"],
    "name": json["name"],
    "description": !exists$2(json, "description") ? void 0 : json["description"],
    "imageUrl": !exists$2(json, "image_url") ? void 0 : json["image_url"],
    "grantorUserId": json["grantor_user_id"],
    "grantCreatedAt": json["grant_created_at"],
    "grantUpdatedAt": json["grant_updated_at"]
  };
}
function AuthorizedAppToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "address": value.address,
    "name": value.name,
    "description": value.description,
    "image_url": value.imageUrl,
    "grantor_user_id": value.grantorUserId,
    "grant_created_at": value.grantCreatedAt,
    "grant_updated_at": value.grantUpdatedAt
  };
}
function instanceOfAuthorizedApps(value) {
  let isInstance = true;
  return isInstance;
}
function AuthorizedAppsFromJSON(json) {
  return AuthorizedAppsFromJSONTyped(json);
}
function AuthorizedAppsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "data": !exists$2(json, "data") ? void 0 : json["data"].map(AuthorizedAppFromJSON)
  };
}
function AuthorizedAppsToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "data": value.data === void 0 ? void 0 : value.data.map(AuthorizedAppToJSON)
  };
}
var BestSellingItemContentTypeEnum$1 = {
  Track: "track",
  Album: "album"
};
function instanceOfBestSellingItem$1(value) {
  let isInstance = true;
  isInstance = isInstance && "contentId" in value && value["contentId"] !== void 0;
  isInstance = isInstance && "title" in value && value["title"] !== void 0;
  isInstance = isInstance && "ownerId" in value && value["ownerId"] !== void 0;
  return isInstance;
}
function BestSellingItemFromJSON$1(json) {
  return BestSellingItemFromJSONTyped$1(json);
}
function BestSellingItemFromJSONTyped$1(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "contentId": json["content_id"],
    "contentType": !exists$2(json, "content_type") ? void 0 : json["content_type"],
    "title": json["title"],
    "ownerId": json["owner_id"]
  };
}
function BestSellingItemToJSON$1(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "content_id": value.contentId,
    "content_type": value.contentType,
    "title": value.title,
    "owner_id": value.ownerId
  };
}
function instanceOfBestSellingResponse(value) {
  let isInstance = true;
  return isInstance;
}
function BestSellingResponseFromJSON(json) {
  return BestSellingResponseFromJSONTyped(json);
}
function BestSellingResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "data": !exists$2(json, "data") ? void 0 : json["data"].map(BestSellingItemFromJSON$1)
  };
}
function BestSellingResponseToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "data": value.data === void 0 ? void 0 : value.data.map(BestSellingItemToJSON$1)
  };
}
function instanceOfBlobInfo(value) {
  let isInstance = true;
  isInstance = isInstance && "size" in value && value["size"] !== void 0;
  isInstance = isInstance && "contentType" in value && value["contentType"] !== void 0;
  return isInstance;
}
function BlobInfoFromJSON(json) {
  return BlobInfoFromJSONTyped(json);
}
function BlobInfoFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "size": json["size"],
    "contentType": json["content_type"]
  };
}
function BlobInfoToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "size": value.size,
    "content_type": value.contentType
  };
}
function instanceOfChallengeResponse(value) {
  let isInstance = true;
  isInstance = isInstance && "challengeId" in value && value["challengeId"] !== void 0;
  isInstance = isInstance && "userId" in value && value["userId"] !== void 0;
  isInstance = isInstance && "isComplete" in value && value["isComplete"] !== void 0;
  isInstance = isInstance && "isActive" in value && value["isActive"] !== void 0;
  isInstance = isInstance && "isDisbursed" in value && value["isDisbursed"] !== void 0;
  isInstance = isInstance && "challengeType" in value && value["challengeType"] !== void 0;
  isInstance = isInstance && "amount" in value && value["amount"] !== void 0;
  isInstance = isInstance && "disbursedAmount" in value && value["disbursedAmount"] !== void 0;
  isInstance = isInstance && "metadata" in value && value["metadata"] !== void 0;
  return isInstance;
}
function ChallengeResponseFromJSON(json) {
  return ChallengeResponseFromJSONTyped(json);
}
function ChallengeResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "challengeId": json["challenge_id"],
    "userId": json["user_id"],
    "specifier": !exists$2(json, "specifier") ? void 0 : json["specifier"],
    "isComplete": json["is_complete"],
    "isActive": json["is_active"],
    "isDisbursed": json["is_disbursed"],
    "currentStepCount": !exists$2(json, "current_step_count") ? void 0 : json["current_step_count"],
    "maxSteps": !exists$2(json, "max_steps") ? void 0 : json["max_steps"],
    "challengeType": json["challenge_type"],
    "amount": json["amount"],
    "disbursedAmount": json["disbursed_amount"],
    "cooldownDays": !exists$2(json, "cooldown_days") ? void 0 : json["cooldown_days"],
    "metadata": json["metadata"]
  };
}
function ChallengeResponseToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "challenge_id": value.challengeId,
    "user_id": value.userId,
    "specifier": value.specifier,
    "is_complete": value.isComplete,
    "is_active": value.isActive,
    "is_disbursed": value.isDisbursed,
    "current_step_count": value.currentStepCount,
    "max_steps": value.maxSteps,
    "challenge_type": value.challengeType,
    "amount": value.amount,
    "disbursed_amount": value.disbursedAmount,
    "cooldown_days": value.cooldownDays,
    "metadata": value.metadata
  };
}
function instanceOfClaimRewardsRequest(value) {
  let isInstance = true;
  isInstance = isInstance && "userId" in value && value["userId"] !== void 0;
  return isInstance;
}
function ClaimRewardsRequestFromJSON(json) {
  return ClaimRewardsRequestFromJSONTyped(json);
}
function ClaimRewardsRequestFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "challengeId": !exists$2(json, "challengeId") ? void 0 : json["challengeId"],
    "specifier": !exists$2(json, "specifier") ? void 0 : json["specifier"],
    "userId": json["userId"]
  };
}
function ClaimRewardsRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "challengeId": value.challengeId,
    "specifier": value.specifier,
    "userId": value.userId
  };
}
function instanceOfClaimRewardsResponseDataInner(value) {
  let isInstance = true;
  isInstance = isInstance && "challengeId" in value && value["challengeId"] !== void 0;
  isInstance = isInstance && "specifier" in value && value["specifier"] !== void 0;
  return isInstance;
}
function ClaimRewardsResponseDataInnerFromJSON(json) {
  return ClaimRewardsResponseDataInnerFromJSONTyped(json);
}
function ClaimRewardsResponseDataInnerFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "challengeId": json["challengeId"],
    "specifier": json["specifier"],
    "amount": !exists$2(json, "amount") ? void 0 : json["amount"],
    "signatures": !exists$2(json, "signatures") ? void 0 : json["signatures"],
    "error": !exists$2(json, "error") ? void 0 : json["error"]
  };
}
function ClaimRewardsResponseDataInnerToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "challengeId": value.challengeId,
    "specifier": value.specifier,
    "amount": value.amount,
    "signatures": value.signatures,
    "error": value.error
  };
}
function instanceOfClaimRewardsResponse(value) {
  let isInstance = true;
  isInstance = isInstance && "data" in value && value["data"] !== void 0;
  return isInstance;
}
function ClaimRewardsResponseFromJSON(json) {
  return ClaimRewardsResponseFromJSONTyped(json);
}
function ClaimRewardsResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "data": json["data"].map(ClaimRewardsResponseDataInnerFromJSON)
  };
}
function ClaimRewardsResponseToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "data": value.data.map(ClaimRewardsResponseDataInnerToJSON)
  };
}
function instanceOfCoinDynamicBondingCurve(value) {
  let isInstance = true;
  isInstance = isInstance && "address" in value && value["address"] !== void 0;
  isInstance = isInstance && "price" in value && value["price"] !== void 0;
  isInstance = isInstance && "priceUSD" in value && value["priceUSD"] !== void 0;
  isInstance = isInstance && "curveProgress" in value && value["curveProgress"] !== void 0;
  isInstance = isInstance && "creatorQuoteFee" in value && value["creatorQuoteFee"] !== void 0;
  isInstance = isInstance && "totalTradingQuoteFee" in value && value["totalTradingQuoteFee"] !== void 0;
  return isInstance;
}
function CoinDynamicBondingCurveFromJSON(json) {
  return CoinDynamicBondingCurveFromJSONTyped(json);
}
function CoinDynamicBondingCurveFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "address": json["address"],
    "price": json["price"],
    "priceUSD": json["priceUSD"],
    "curveProgress": json["curveProgress"],
    "isMigrated": !exists$2(json, "isMigrated") ? void 0 : json["isMigrated"],
    "creatorQuoteFee": json["creatorQuoteFee"],
    "totalTradingQuoteFee": json["totalTradingQuoteFee"]
  };
}
function CoinDynamicBondingCurveToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "address": value.address,
    "price": value.price,
    "priceUSD": value.priceUSD,
    "curveProgress": value.curveProgress,
    "isMigrated": value.isMigrated,
    "creatorQuoteFee": value.creatorQuoteFee,
    "totalTradingQuoteFee": value.totalTradingQuoteFee
  };
}
function instanceOfCoinExtensions(value) {
  let isInstance = true;
  return isInstance;
}
function CoinExtensionsFromJSON(json) {
  return CoinExtensionsFromJSONTyped(json);
}
function CoinExtensionsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "coingeckoId": !exists$2(json, "coingeckoId") ? void 0 : json["coingeckoId"],
    "description": !exists$2(json, "description") ? void 0 : json["description"],
    "twitter": !exists$2(json, "twitter") ? void 0 : json["twitter"],
    "website": !exists$2(json, "website") ? void 0 : json["website"],
    "discord": !exists$2(json, "discord") ? void 0 : json["discord"]
  };
}
function CoinExtensionsToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "coingeckoId": value.coingeckoId,
    "description": value.description,
    "twitter": value.twitter,
    "website": value.website,
    "discord": value.discord
  };
}
function instanceOfCoin$1(value) {
  let isInstance = true;
  isInstance = isInstance && "name" in value && value["name"] !== void 0;
  isInstance = isInstance && "mint" in value && value["mint"] !== void 0;
  isInstance = isInstance && "decimals" in value && value["decimals"] !== void 0;
  isInstance = isInstance && "ownerId" in value && value["ownerId"] !== void 0;
  isInstance = isInstance && "hasDiscord" in value && value["hasDiscord"] !== void 0;
  isInstance = isInstance && "createdAt" in value && value["createdAt"] !== void 0;
  isInstance = isInstance && "marketCap" in value && value["marketCap"] !== void 0;
  isInstance = isInstance && "fdv" in value && value["fdv"] !== void 0;
  isInstance = isInstance && "liquidity" in value && value["liquidity"] !== void 0;
  isInstance = isInstance && "lastTradeUnixTime" in value && value["lastTradeUnixTime"] !== void 0;
  isInstance = isInstance && "lastTradeHumanTime" in value && value["lastTradeHumanTime"] !== void 0;
  isInstance = isInstance && "price" in value && value["price"] !== void 0;
  isInstance = isInstance && "history24hPrice" in value && value["history24hPrice"] !== void 0;
  isInstance = isInstance && "priceChange24hPercent" in value && value["priceChange24hPercent"] !== void 0;
  isInstance = isInstance && "uniqueWallet24h" in value && value["uniqueWallet24h"] !== void 0;
  isInstance = isInstance && "uniqueWalletHistory24h" in value && value["uniqueWalletHistory24h"] !== void 0;
  isInstance = isInstance && "uniqueWallet24hChangePercent" in value && value["uniqueWallet24hChangePercent"] !== void 0;
  isInstance = isInstance && "totalSupply" in value && value["totalSupply"] !== void 0;
  isInstance = isInstance && "circulatingSupply" in value && value["circulatingSupply"] !== void 0;
  isInstance = isInstance && "holder" in value && value["holder"] !== void 0;
  isInstance = isInstance && "trade24h" in value && value["trade24h"] !== void 0;
  isInstance = isInstance && "tradeHistory24h" in value && value["tradeHistory24h"] !== void 0;
  isInstance = isInstance && "trade24hChangePercent" in value && value["trade24hChangePercent"] !== void 0;
  isInstance = isInstance && "sell24h" in value && value["sell24h"] !== void 0;
  isInstance = isInstance && "sellHistory24h" in value && value["sellHistory24h"] !== void 0;
  isInstance = isInstance && "sell24hChangePercent" in value && value["sell24hChangePercent"] !== void 0;
  isInstance = isInstance && "buy24h" in value && value["buy24h"] !== void 0;
  isInstance = isInstance && "buyHistory24h" in value && value["buyHistory24h"] !== void 0;
  isInstance = isInstance && "buy24hChangePercent" in value && value["buy24hChangePercent"] !== void 0;
  isInstance = isInstance && "v24h" in value && value["v24h"] !== void 0;
  isInstance = isInstance && "v24hUSD" in value && value["v24hUSD"] !== void 0;
  isInstance = isInstance && "vHistory24h" in value && value["vHistory24h"] !== void 0;
  isInstance = isInstance && "dynamicBondingCurve" in value && value["dynamicBondingCurve"] !== void 0;
  return isInstance;
}
function CoinFromJSON$1(json) {
  return CoinFromJSONTyped$1(json);
}
function CoinFromJSONTyped$1(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "name": json["name"],
    "ticker": !exists$2(json, "ticker") ? void 0 : json["ticker"],
    "mint": json["mint"],
    "decimals": json["decimals"],
    "ownerId": json["owner_id"],
    "logoUri": !exists$2(json, "logo_uri") ? void 0 : json["logo_uri"],
    "description": !exists$2(json, "description") ? void 0 : json["description"],
    "website": !exists$2(json, "website") ? void 0 : json["website"],
    "link1": !exists$2(json, "link_1") ? void 0 : json["link_1"],
    "link2": !exists$2(json, "link_2") ? void 0 : json["link_2"],
    "link3": !exists$2(json, "link_3") ? void 0 : json["link_3"],
    "link4": !exists$2(json, "link_4") ? void 0 : json["link_4"],
    "hasDiscord": json["has_discord"],
    "createdAt": json["created_at"],
    "address": !exists$2(json, "address") ? void 0 : json["address"],
    "symbol": !exists$2(json, "symbol") ? void 0 : json["symbol"],
    "marketCap": json["marketCap"],
    "fdv": json["fdv"],
    "extensions": !exists$2(json, "extensions") ? void 0 : CoinExtensionsFromJSON(json["extensions"]),
    "liquidity": json["liquidity"],
    "lastTradeUnixTime": json["lastTradeUnixTime"],
    "lastTradeHumanTime": json["lastTradeHumanTime"],
    "price": json["price"],
    "history24hPrice": json["history24hPrice"],
    "priceChange24hPercent": json["priceChange24hPercent"],
    "uniqueWallet24h": json["uniqueWallet24h"],
    "uniqueWalletHistory24h": json["uniqueWalletHistory24h"],
    "uniqueWallet24hChangePercent": json["uniqueWallet24hChangePercent"],
    "totalSupply": json["totalSupply"],
    "circulatingSupply": json["circulatingSupply"],
    "holder": json["holder"],
    "trade24h": json["trade24h"],
    "tradeHistory24h": json["tradeHistory24h"],
    "trade24hChangePercent": json["trade24hChangePercent"],
    "sell24h": json["sell24h"],
    "sellHistory24h": json["sellHistory24h"],
    "sell24hChangePercent": json["sell24hChangePercent"],
    "buy24h": json["buy24h"],
    "buyHistory24h": json["buyHistory24h"],
    "buy24hChangePercent": json["buy24hChangePercent"],
    "v24h": json["v24h"],
    "v24hUSD": json["v24hUSD"],
    "vHistory24h": json["vHistory24h"],
    "vHistory24hUSD": !exists$2(json, "vHistory24hUSD") ? void 0 : json["vHistory24hUSD"],
    "v24hChangePercent": !exists$2(json, "v24hChangePercent") ? void 0 : json["v24hChangePercent"],
    "vBuy24h": !exists$2(json, "vBuy24h") ? void 0 : json["vBuy24h"],
    "vBuy24hUSD": !exists$2(json, "vBuy24hUSD") ? void 0 : json["vBuy24hUSD"],
    "vBuyHistory24h": !exists$2(json, "vBuyHistory24h") ? void 0 : json["vBuyHistory24h"],
    "vBuyHistory24hUSD": !exists$2(json, "vBuyHistory24hUSD") ? void 0 : json["vBuyHistory24hUSD"],
    "vBuy24hChangePercent": !exists$2(json, "vBuy24hChangePercent") ? void 0 : json["vBuy24hChangePercent"],
    "vSell24h": !exists$2(json, "vSell24h") ? void 0 : json["vSell24h"],
    "vSell24hUSD": !exists$2(json, "vSell24hUSD") ? void 0 : json["vSell24hUSD"],
    "vSellHistory24h": !exists$2(json, "vSellHistory24h") ? void 0 : json["vSellHistory24h"],
    "vSellHistory24hUSD": !exists$2(json, "vSellHistory24hUSD") ? void 0 : json["vSellHistory24hUSD"],
    "vSell24hChangePercent": !exists$2(json, "vSell24hChangePercent") ? void 0 : json["vSell24hChangePercent"],
    "numberMarkets": !exists$2(json, "numberMarkets") ? void 0 : json["numberMarkets"],
    "dynamicBondingCurve": CoinDynamicBondingCurveFromJSON(json["dynamicBondingCurve"])
  };
}
function CoinToJSON$1(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "name": value.name,
    "ticker": value.ticker,
    "mint": value.mint,
    "decimals": value.decimals,
    "owner_id": value.ownerId,
    "logo_uri": value.logoUri,
    "description": value.description,
    "website": value.website,
    "link_1": value.link1,
    "link_2": value.link2,
    "link_3": value.link3,
    "link_4": value.link4,
    "has_discord": value.hasDiscord,
    "created_at": value.createdAt,
    "address": value.address,
    "symbol": value.symbol,
    "marketCap": value.marketCap,
    "fdv": value.fdv,
    "extensions": CoinExtensionsToJSON(value.extensions),
    "liquidity": value.liquidity,
    "lastTradeUnixTime": value.lastTradeUnixTime,
    "lastTradeHumanTime": value.lastTradeHumanTime,
    "price": value.price,
    "history24hPrice": value.history24hPrice,
    "priceChange24hPercent": value.priceChange24hPercent,
    "uniqueWallet24h": value.uniqueWallet24h,
    "uniqueWalletHistory24h": value.uniqueWalletHistory24h,
    "uniqueWallet24hChangePercent": value.uniqueWallet24hChangePercent,
    "totalSupply": value.totalSupply,
    "circulatingSupply": value.circulatingSupply,
    "holder": value.holder,
    "trade24h": value.trade24h,
    "tradeHistory24h": value.tradeHistory24h,
    "trade24hChangePercent": value.trade24hChangePercent,
    "sell24h": value.sell24h,
    "sellHistory24h": value.sellHistory24h,
    "sell24hChangePercent": value.sell24hChangePercent,
    "buy24h": value.buy24h,
    "buyHistory24h": value.buyHistory24h,
    "buy24hChangePercent": value.buy24hChangePercent,
    "v24h": value.v24h,
    "v24hUSD": value.v24hUSD,
    "vHistory24h": value.vHistory24h,
    "vHistory24hUSD": value.vHistory24hUSD,
    "v24hChangePercent": value.v24hChangePercent,
    "vBuy24h": value.vBuy24h,
    "vBuy24hUSD": value.vBuy24hUSD,
    "vBuyHistory24h": value.vBuyHistory24h,
    "vBuyHistory24hUSD": value.vBuyHistory24hUSD,
    "vBuy24hChangePercent": value.vBuy24hChangePercent,
    "vSell24h": value.vSell24h,
    "vSell24hUSD": value.vSell24hUSD,
    "vSellHistory24h": value.vSellHistory24h,
    "vSellHistory24hUSD": value.vSellHistory24hUSD,
    "vSell24hChangePercent": value.vSell24hChangePercent,
    "numberMarkets": value.numberMarkets,
    "dynamicBondingCurve": CoinDynamicBondingCurveToJSON(value.dynamicBondingCurve)
  };
}
function instanceOfCoinInsights(value) {
  let isInstance = true;
  isInstance = isInstance && "marketCap" in value && value["marketCap"] !== void 0;
  isInstance = isInstance && "fdv" in value && value["fdv"] !== void 0;
  isInstance = isInstance && "liquidity" in value && value["liquidity"] !== void 0;
  isInstance = isInstance && "lastTradeUnixTime" in value && value["lastTradeUnixTime"] !== void 0;
  isInstance = isInstance && "lastTradeHumanTime" in value && value["lastTradeHumanTime"] !== void 0;
  isInstance = isInstance && "price" in value && value["price"] !== void 0;
  isInstance = isInstance && "history24hPrice" in value && value["history24hPrice"] !== void 0;
  isInstance = isInstance && "priceChange24hPercent" in value && value["priceChange24hPercent"] !== void 0;
  isInstance = isInstance && "uniqueWallet24h" in value && value["uniqueWallet24h"] !== void 0;
  isInstance = isInstance && "uniqueWalletHistory24h" in value && value["uniqueWalletHistory24h"] !== void 0;
  isInstance = isInstance && "uniqueWallet24hChangePercent" in value && value["uniqueWallet24hChangePercent"] !== void 0;
  isInstance = isInstance && "totalSupply" in value && value["totalSupply"] !== void 0;
  isInstance = isInstance && "circulatingSupply" in value && value["circulatingSupply"] !== void 0;
  isInstance = isInstance && "holder" in value && value["holder"] !== void 0;
  isInstance = isInstance && "trade24h" in value && value["trade24h"] !== void 0;
  isInstance = isInstance && "tradeHistory24h" in value && value["tradeHistory24h"] !== void 0;
  isInstance = isInstance && "trade24hChangePercent" in value && value["trade24hChangePercent"] !== void 0;
  isInstance = isInstance && "sell24h" in value && value["sell24h"] !== void 0;
  isInstance = isInstance && "sellHistory24h" in value && value["sellHistory24h"] !== void 0;
  isInstance = isInstance && "sell24hChangePercent" in value && value["sell24hChangePercent"] !== void 0;
  isInstance = isInstance && "buy24h" in value && value["buy24h"] !== void 0;
  isInstance = isInstance && "buyHistory24h" in value && value["buyHistory24h"] !== void 0;
  isInstance = isInstance && "buy24hChangePercent" in value && value["buy24hChangePercent"] !== void 0;
  isInstance = isInstance && "v24h" in value && value["v24h"] !== void 0;
  isInstance = isInstance && "v24hUSD" in value && value["v24hUSD"] !== void 0;
  isInstance = isInstance && "vHistory24h" in value && value["vHistory24h"] !== void 0;
  isInstance = isInstance && "dynamicBondingCurve" in value && value["dynamicBondingCurve"] !== void 0;
  return isInstance;
}
function CoinInsightsFromJSON(json) {
  return CoinInsightsFromJSONTyped(json);
}
function CoinInsightsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "address": !exists$2(json, "address") ? void 0 : json["address"],
    "decimals": !exists$2(json, "decimals") ? void 0 : json["decimals"],
    "symbol": !exists$2(json, "symbol") ? void 0 : json["symbol"],
    "name": !exists$2(json, "name") ? void 0 : json["name"],
    "marketCap": json["marketCap"],
    "fdv": json["fdv"],
    "extensions": !exists$2(json, "extensions") ? void 0 : CoinExtensionsFromJSON(json["extensions"]),
    "liquidity": json["liquidity"],
    "lastTradeUnixTime": json["lastTradeUnixTime"],
    "lastTradeHumanTime": json["lastTradeHumanTime"],
    "price": json["price"],
    "history24hPrice": json["history24hPrice"],
    "priceChange24hPercent": json["priceChange24hPercent"],
    "uniqueWallet24h": json["uniqueWallet24h"],
    "uniqueWalletHistory24h": json["uniqueWalletHistory24h"],
    "uniqueWallet24hChangePercent": json["uniqueWallet24hChangePercent"],
    "totalSupply": json["totalSupply"],
    "circulatingSupply": json["circulatingSupply"],
    "holder": json["holder"],
    "trade24h": json["trade24h"],
    "tradeHistory24h": json["tradeHistory24h"],
    "trade24hChangePercent": json["trade24hChangePercent"],
    "sell24h": json["sell24h"],
    "sellHistory24h": json["sellHistory24h"],
    "sell24hChangePercent": json["sell24hChangePercent"],
    "buy24h": json["buy24h"],
    "buyHistory24h": json["buyHistory24h"],
    "buy24hChangePercent": json["buy24hChangePercent"],
    "v24h": json["v24h"],
    "v24hUSD": json["v24hUSD"],
    "vHistory24h": json["vHistory24h"],
    "vHistory24hUSD": !exists$2(json, "vHistory24hUSD") ? void 0 : json["vHistory24hUSD"],
    "v24hChangePercent": !exists$2(json, "v24hChangePercent") ? void 0 : json["v24hChangePercent"],
    "vBuy24h": !exists$2(json, "vBuy24h") ? void 0 : json["vBuy24h"],
    "vBuy24hUSD": !exists$2(json, "vBuy24hUSD") ? void 0 : json["vBuy24hUSD"],
    "vBuyHistory24h": !exists$2(json, "vBuyHistory24h") ? void 0 : json["vBuyHistory24h"],
    "vBuyHistory24hUSD": !exists$2(json, "vBuyHistory24hUSD") ? void 0 : json["vBuyHistory24hUSD"],
    "vBuy24hChangePercent": !exists$2(json, "vBuy24hChangePercent") ? void 0 : json["vBuy24hChangePercent"],
    "vSell24h": !exists$2(json, "vSell24h") ? void 0 : json["vSell24h"],
    "vSell24hUSD": !exists$2(json, "vSell24hUSD") ? void 0 : json["vSell24hUSD"],
    "vSellHistory24h": !exists$2(json, "vSellHistory24h") ? void 0 : json["vSellHistory24h"],
    "vSellHistory24hUSD": !exists$2(json, "vSellHistory24hUSD") ? void 0 : json["vSellHistory24hUSD"],
    "vSell24hChangePercent": !exists$2(json, "vSell24hChangePercent") ? void 0 : json["vSell24hChangePercent"],
    "numberMarkets": !exists$2(json, "numberMarkets") ? void 0 : json["numberMarkets"],
    "dynamicBondingCurve": CoinDynamicBondingCurveFromJSON(json["dynamicBondingCurve"])
  };
}
function CoinInsightsToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "address": value.address,
    "decimals": value.decimals,
    "symbol": value.symbol,
    "name": value.name,
    "marketCap": value.marketCap,
    "fdv": value.fdv,
    "extensions": CoinExtensionsToJSON(value.extensions),
    "liquidity": value.liquidity,
    "lastTradeUnixTime": value.lastTradeUnixTime,
    "lastTradeHumanTime": value.lastTradeHumanTime,
    "price": value.price,
    "history24hPrice": value.history24hPrice,
    "priceChange24hPercent": value.priceChange24hPercent,
    "uniqueWallet24h": value.uniqueWallet24h,
    "uniqueWalletHistory24h": value.uniqueWalletHistory24h,
    "uniqueWallet24hChangePercent": value.uniqueWallet24hChangePercent,
    "totalSupply": value.totalSupply,
    "circulatingSupply": value.circulatingSupply,
    "holder": value.holder,
    "trade24h": value.trade24h,
    "tradeHistory24h": value.tradeHistory24h,
    "trade24hChangePercent": value.trade24hChangePercent,
    "sell24h": value.sell24h,
    "sellHistory24h": value.sellHistory24h,
    "sell24hChangePercent": value.sell24hChangePercent,
    "buy24h": value.buy24h,
    "buyHistory24h": value.buyHistory24h,
    "buy24hChangePercent": value.buy24hChangePercent,
    "v24h": value.v24h,
    "v24hUSD": value.v24hUSD,
    "vHistory24h": value.vHistory24h,
    "vHistory24hUSD": value.vHistory24hUSD,
    "v24hChangePercent": value.v24hChangePercent,
    "vBuy24h": value.vBuy24h,
    "vBuy24hUSD": value.vBuy24hUSD,
    "vBuyHistory24h": value.vBuyHistory24h,
    "vBuyHistory24hUSD": value.vBuyHistory24hUSD,
    "vBuy24hChangePercent": value.vBuy24hChangePercent,
    "vSell24h": value.vSell24h,
    "vSell24hUSD": value.vSell24hUSD,
    "vSellHistory24h": value.vSellHistory24h,
    "vSellHistory24hUSD": value.vSellHistory24hUSD,
    "vSell24hChangePercent": value.vSell24hChangePercent,
    "numberMarkets": value.numberMarkets,
    "dynamicBondingCurve": CoinDynamicBondingCurveToJSON(value.dynamicBondingCurve)
  };
}
function instanceOfCoinInsightsResponse(value) {
  let isInstance = true;
  return isInstance;
}
function CoinInsightsResponseFromJSON(json) {
  return CoinInsightsResponseFromJSONTyped(json);
}
function CoinInsightsResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "data": !exists$2(json, "data") ? void 0 : CoinInsightsFromJSON(json["data"])
  };
}
function CoinInsightsResponseToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "data": CoinInsightsToJSON(value.data)
  };
}
function instanceOfCoinMember(value) {
  let isInstance = true;
  isInstance = isInstance && "balance" in value && value["balance"] !== void 0;
  isInstance = isInstance && "userId" in value && value["userId"] !== void 0;
  return isInstance;
}
function CoinMemberFromJSON(json) {
  return CoinMemberFromJSONTyped(json);
}
function CoinMemberFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "balance": json["balance"],
    "userId": json["user_id"]
  };
}
function CoinMemberToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "balance": value.balance,
    "user_id": value.userId
  };
}
function instanceOfCoinMembersResponse(value) {
  let isInstance = true;
  isInstance = isInstance && "data" in value && value["data"] !== void 0;
  return isInstance;
}
function CoinMembersResponseFromJSON(json) {
  return CoinMembersResponseFromJSONTyped(json);
}
function CoinMembersResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "data": json["data"].map(CoinMemberFromJSON)
  };
}
function CoinMembersResponseToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "data": value.data.map(CoinMemberToJSON)
  };
}
function instanceOfCoinResponse$1(value) {
  let isInstance = true;
  return isInstance;
}
function CoinResponseFromJSON$1(json) {
  return CoinResponseFromJSONTyped$1(json);
}
function CoinResponseFromJSONTyped$1(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "data": !exists$2(json, "data") ? void 0 : CoinFromJSON$1(json["data"])
  };
}
function CoinResponseToJSON$1(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "data": CoinToJSON$1(value.data)
  };
}
function instanceOfCoinsResponse$1(value) {
  let isInstance = true;
  isInstance = isInstance && "data" in value && value["data"] !== void 0;
  return isInstance;
}
function CoinsResponseFromJSON$1(json) {
  return CoinsResponseFromJSONTyped$1(json);
}
function CoinsResponseFromJSONTyped$1(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "data": json["data"].map(CoinFromJSON$1)
  };
}
function CoinsResponseToJSON$1(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "data": value.data.map(CoinToJSON$1)
  };
}
function instanceOfCollectibles(value) {
  let isInstance = true;
  return isInstance;
}
function CollectiblesFromJSON(json) {
  return CollectiblesFromJSONTyped(json);
}
function CollectiblesFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "data": !exists$2(json, "data") ? void 0 : json["data"]
  };
}
function CollectiblesToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "data": value.data
  };
}
function instanceOfCollectiblesResponse(value) {
  let isInstance = true;
  return isInstance;
}
function CollectiblesResponseFromJSON(json) {
  return CollectiblesResponseFromJSONTyped(json);
}
function CollectiblesResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "data": !exists$2(json, "data") ? void 0 : CollectiblesFromJSON(json["data"])
  };
}
function CollectiblesResponseToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "data": CollectiblesToJSON(value.data)
  };
}
var CollectionActivityItemTypeEnum = {
  Playlist: "playlist"
};
function instanceOfCollectionActivity(value) {
  let isInstance = true;
  isInstance = isInstance && "itemType" in value && value["itemType"] !== void 0;
  isInstance = isInstance && "item" in value && value["item"] !== void 0;
  return isInstance;
}
function CollectionActivityFromJSON(json) {
  return CollectionActivityFromJSONTyped(json, false);
}
function CollectionActivityFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    ...ActivityFromJSONTyped(json, ignoreDiscriminator),
    "timestamp": !exists$2(json, "timestamp") ? void 0 : json["timestamp"],
    "itemType": json["item_type"],
    "item": PlaylistFromJSON(json["item"])
  };
}
function CollectionActivityToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    ...ActivityToJSON(value),
    "timestamp": value.timestamp,
    "item_type": value.itemType,
    "item": PlaylistToJSON(value.item)
  };
}
function instanceOfCommentMention$1(value) {
  let isInstance = true;
  isInstance = isInstance && "userId" in value && value["userId"] !== void 0;
  isInstance = isInstance && "handle" in value && value["handle"] !== void 0;
  return isInstance;
}
function CommentMentionFromJSON$1(json) {
  return CommentMentionFromJSONTyped$1(json);
}
function CommentMentionFromJSONTyped$1(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "userId": json["user_id"],
    "handle": json["handle"]
  };
}
function CommentMentionToJSON$1(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "user_id": value.userId,
    "handle": value.handle
  };
}
function instanceOfReplyComment$1(value) {
  let isInstance = true;
  isInstance = isInstance && "id" in value && value["id"] !== void 0;
  isInstance = isInstance && "entityId" in value && value["entityId"] !== void 0;
  isInstance = isInstance && "entityType" in value && value["entityType"] !== void 0;
  isInstance = isInstance && "userId" in value && value["userId"] !== void 0;
  isInstance = isInstance && "message" in value && value["message"] !== void 0;
  isInstance = isInstance && "reactCount" in value && value["reactCount"] !== void 0;
  isInstance = isInstance && "isEdited" in value && value["isEdited"] !== void 0;
  isInstance = isInstance && "createdAt" in value && value["createdAt"] !== void 0;
  return isInstance;
}
function ReplyCommentFromJSON$1(json) {
  return ReplyCommentFromJSONTyped$1(json);
}
function ReplyCommentFromJSONTyped$1(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "id": json["id"],
    "entityId": json["entity_id"],
    "entityType": json["entity_type"],
    "userId": json["user_id"],
    "message": json["message"],
    "mentions": !exists$2(json, "mentions") ? void 0 : json["mentions"].map(CommentMentionFromJSON$1),
    "trackTimestampS": !exists$2(json, "track_timestamp_s") ? void 0 : json["track_timestamp_s"],
    "reactCount": json["react_count"],
    "isEdited": json["is_edited"],
    "isCurrentUserReacted": !exists$2(json, "is_current_user_reacted") ? void 0 : json["is_current_user_reacted"],
    "isArtistReacted": !exists$2(json, "is_artist_reacted") ? void 0 : json["is_artist_reacted"],
    "createdAt": json["created_at"],
    "updatedAt": !exists$2(json, "updated_at") ? void 0 : json["updated_at"],
    "parentCommentId": !exists$2(json, "parent_comment_id") ? void 0 : json["parent_comment_id"]
  };
}
function ReplyCommentToJSON$1(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "id": value.id,
    "entity_id": value.entityId,
    "entity_type": value.entityType,
    "user_id": value.userId,
    "message": value.message,
    "mentions": value.mentions === void 0 ? void 0 : value.mentions.map(CommentMentionToJSON$1),
    "track_timestamp_s": value.trackTimestampS,
    "react_count": value.reactCount,
    "is_edited": value.isEdited,
    "is_current_user_reacted": value.isCurrentUserReacted,
    "is_artist_reacted": value.isArtistReacted,
    "created_at": value.createdAt,
    "updated_at": value.updatedAt,
    "parent_comment_id": value.parentCommentId
  };
}
function instanceOfComment$1(value) {
  let isInstance = true;
  isInstance = isInstance && "id" in value && value["id"] !== void 0;
  isInstance = isInstance && "entityId" in value && value["entityId"] !== void 0;
  isInstance = isInstance && "entityType" in value && value["entityType"] !== void 0;
  isInstance = isInstance && "message" in value && value["message"] !== void 0;
  isInstance = isInstance && "reactCount" in value && value["reactCount"] !== void 0;
  isInstance = isInstance && "replyCount" in value && value["replyCount"] !== void 0;
  isInstance = isInstance && "isEdited" in value && value["isEdited"] !== void 0;
  isInstance = isInstance && "createdAt" in value && value["createdAt"] !== void 0;
  return isInstance;
}
function CommentFromJSON$1(json) {
  return CommentFromJSONTyped$1(json);
}
function CommentFromJSONTyped$1(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "id": json["id"],
    "entityId": json["entity_id"],
    "entityType": json["entity_type"],
    "userId": !exists$2(json, "user_id") ? void 0 : json["user_id"],
    "message": json["message"],
    "mentions": !exists$2(json, "mentions") ? void 0 : json["mentions"].map(CommentMentionFromJSON$1),
    "trackTimestampS": !exists$2(json, "track_timestamp_s") ? void 0 : json["track_timestamp_s"],
    "reactCount": json["react_count"],
    "replyCount": json["reply_count"],
    "isEdited": json["is_edited"],
    "isCurrentUserReacted": !exists$2(json, "is_current_user_reacted") ? void 0 : json["is_current_user_reacted"],
    "isArtistReacted": !exists$2(json, "is_artist_reacted") ? void 0 : json["is_artist_reacted"],
    "isTombstone": !exists$2(json, "is_tombstone") ? void 0 : json["is_tombstone"],
    "isMuted": !exists$2(json, "is_muted") ? void 0 : json["is_muted"],
    "createdAt": json["created_at"],
    "updatedAt": !exists$2(json, "updated_at") ? void 0 : json["updated_at"],
    "replies": !exists$2(json, "replies") ? void 0 : json["replies"].map(ReplyCommentFromJSON$1),
    "parentCommentId": !exists$2(json, "parent_comment_id") ? void 0 : json["parent_comment_id"]
  };
}
function CommentToJSON$1(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "id": value.id,
    "entity_id": value.entityId,
    "entity_type": value.entityType,
    "user_id": value.userId,
    "message": value.message,
    "mentions": value.mentions === void 0 ? void 0 : value.mentions.map(CommentMentionToJSON$1),
    "track_timestamp_s": value.trackTimestampS,
    "react_count": value.reactCount,
    "reply_count": value.replyCount,
    "is_edited": value.isEdited,
    "is_current_user_reacted": value.isCurrentUserReacted,
    "is_artist_reacted": value.isArtistReacted,
    "is_tombstone": value.isTombstone,
    "is_muted": value.isMuted,
    "created_at": value.createdAt,
    "updated_at": value.updatedAt,
    "replies": value.replies === void 0 ? void 0 : value.replies.map(ReplyCommentToJSON$1),
    "parent_comment_id": value.parentCommentId
  };
}
function instanceOfCommentNotificationSetting(value) {
  let isInstance = true;
  isInstance = isInstance && "isMuted" in value && value["isMuted"] !== void 0;
  return isInstance;
}
function CommentNotificationSettingFromJSON(json) {
  return CommentNotificationSettingFromJSONTyped(json);
}
function CommentNotificationSettingFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "isMuted": json["is_muted"]
  };
}
function CommentNotificationSettingToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "is_muted": value.isMuted
  };
}
function instanceOfCommentRepliesResponse$1(value) {
  let isInstance = true;
  return isInstance;
}
function CommentRepliesResponseFromJSON$1(json) {
  return CommentRepliesResponseFromJSONTyped$1(json);
}
function CommentRepliesResponseFromJSONTyped$1(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "data": !exists$2(json, "data") ? void 0 : json["data"].map(ReplyCommentFromJSON$1)
  };
}
function CommentRepliesResponseToJSON$1(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "data": value.data === void 0 ? void 0 : value.data.map(ReplyCommentToJSON$1)
  };
}
function instanceOfCommentResponse$1(value) {
  let isInstance = true;
  return isInstance;
}
function CommentResponseFromJSON$1(json) {
  return CommentResponseFromJSONTyped$1(json);
}
function CommentResponseFromJSONTyped$1(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "data": !exists$2(json, "data") ? void 0 : json["data"].map(CommentFromJSON$1)
  };
}
function CommentResponseToJSON$1(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "data": value.data === void 0 ? void 0 : value.data.map(CommentToJSON$1)
  };
}
function instanceOfConnectedWallets(value) {
  let isInstance = true;
  isInstance = isInstance && "ercWallets" in value && value["ercWallets"] !== void 0;
  isInstance = isInstance && "splWallets" in value && value["splWallets"] !== void 0;
  return isInstance;
}
function ConnectedWalletsFromJSON(json) {
  return ConnectedWalletsFromJSONTyped(json);
}
function ConnectedWalletsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "ercWallets": json["erc_wallets"],
    "splWallets": json["spl_wallets"]
  };
}
function ConnectedWalletsToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "erc_wallets": value.ercWallets,
    "spl_wallets": value.splWallets
  };
}
function instanceOfConnectedWalletsResponse(value) {
  let isInstance = true;
  return isInstance;
}
function ConnectedWalletsResponseFromJSON(json) {
  return ConnectedWalletsResponseFromJSONTyped(json);
}
function ConnectedWalletsResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "data": !exists$2(json, "data") ? void 0 : ConnectedWalletsFromJSON(json["data"])
  };
}
function ConnectedWalletsResponseToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "data": ConnectedWalletsToJSON(value.data)
  };
}
function instanceOfCreateCoinRequest$1(value) {
  let isInstance = true;
  isInstance = isInstance && "mint" in value && value["mint"] !== void 0;
  isInstance = isInstance && "ticker" in value && value["ticker"] !== void 0;
  isInstance = isInstance && "decimals" in value && value["decimals"] !== void 0;
  isInstance = isInstance && "name" in value && value["name"] !== void 0;
  return isInstance;
}
function CreateCoinRequestFromJSON$1(json) {
  return CreateCoinRequestFromJSONTyped$1(json);
}
function CreateCoinRequestFromJSONTyped$1(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "mint": json["mint"],
    "ticker": json["ticker"],
    "decimals": json["decimals"],
    "name": json["name"],
    "logoUri": !exists$2(json, "logo_uri") ? void 0 : json["logo_uri"],
    "description": !exists$2(json, "description") ? void 0 : json["description"]
  };
}
function CreateCoinRequestToJSON$1(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "mint": value.mint,
    "ticker": value.ticker,
    "decimals": value.decimals,
    "name": value.name,
    "logo_uri": value.logoUri,
    "description": value.description
  };
}
function instanceOfCreateCoinResponseData$1(value) {
  let isInstance = true;
  isInstance = isInstance && "mint" in value && value["mint"] !== void 0;
  isInstance = isInstance && "ticker" in value && value["ticker"] !== void 0;
  isInstance = isInstance && "userId" in value && value["userId"] !== void 0;
  isInstance = isInstance && "decimals" in value && value["decimals"] !== void 0;
  isInstance = isInstance && "name" in value && value["name"] !== void 0;
  isInstance = isInstance && "createdAt" in value && value["createdAt"] !== void 0;
  return isInstance;
}
function CreateCoinResponseDataFromJSON$1(json) {
  return CreateCoinResponseDataFromJSONTyped$1(json);
}
function CreateCoinResponseDataFromJSONTyped$1(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "mint": json["mint"],
    "ticker": json["ticker"],
    "userId": json["user_id"],
    "decimals": json["decimals"],
    "name": json["name"],
    "logoUri": !exists$2(json, "logo_uri") ? void 0 : json["logo_uri"],
    "createdAt": new Date(json["created_at"])
  };
}
function CreateCoinResponseDataToJSON$1(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "mint": value.mint,
    "ticker": value.ticker,
    "user_id": value.userId,
    "decimals": value.decimals,
    "name": value.name,
    "logo_uri": value.logoUri,
    "created_at": value.createdAt.toISOString()
  };
}
function instanceOfCreateCoinResponse$1(value) {
  let isInstance = true;
  return isInstance;
}
function CreateCoinResponseFromJSON$1(json) {
  return CreateCoinResponseFromJSONTyped$1(json);
}
function CreateCoinResponseFromJSONTyped$1(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "data": !exists$2(json, "data") ? void 0 : CreateCoinResponseDataFromJSON$1(json["data"])
  };
}
function CreateCoinResponseToJSON$1(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "data": CreateCoinResponseDataToJSON$1(value.data)
  };
}
function instanceOfDashboardWalletUser(value) {
  let isInstance = true;
  isInstance = isInstance && "wallet" in value && value["wallet"] !== void 0;
  isInstance = isInstance && "user" in value && value["user"] !== void 0;
  return isInstance;
}
function DashboardWalletUserFromJSON(json) {
  return DashboardWalletUserFromJSONTyped(json);
}
function DashboardWalletUserFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "wallet": json["wallet"],
    "user": UserFromJSON(json["user"])
  };
}
function DashboardWalletUserToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "wallet": value.wallet,
    "user": UserToJSON(value.user)
  };
}
function instanceOfDashboardWalletUsersResponse(value) {
  let isInstance = true;
  return isInstance;
}
function DashboardWalletUsersResponseFromJSON(json) {
  return DashboardWalletUsersResponseFromJSONTyped(json);
}
function DashboardWalletUsersResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "data": !exists$2(json, "data") ? void 0 : json["data"].map(DashboardWalletUserFromJSON)
  };
}
function DashboardWalletUsersResponseToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "data": value.data === void 0 ? void 0 : value.data.map(DashboardWalletUserToJSON)
  };
}
function instanceOfDecodedUserToken(value) {
  let isInstance = true;
  isInstance = isInstance && "apiKey" in value && value["apiKey"] !== void 0;
  isInstance = isInstance && "userId" in value && value["userId"] !== void 0;
  isInstance = isInstance && "email" in value && value["email"] !== void 0;
  isInstance = isInstance && "name" in value && value["name"] !== void 0;
  isInstance = isInstance && "handle" in value && value["handle"] !== void 0;
  isInstance = isInstance && "verified" in value && value["verified"] !== void 0;
  isInstance = isInstance && "sub" in value && value["sub"] !== void 0;
  isInstance = isInstance && "iat" in value && value["iat"] !== void 0;
  return isInstance;
}
function DecodedUserTokenFromJSON(json) {
  return DecodedUserTokenFromJSONTyped(json);
}
function DecodedUserTokenFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "apiKey": json["apiKey"],
    "userId": json["userId"],
    "email": json["email"],
    "name": json["name"],
    "handle": json["handle"],
    "verified": json["verified"],
    "profilePicture": !exists$2(json, "profilePicture") ? void 0 : ProfilePictureFromJSON$1(json["profilePicture"]),
    "sub": json["sub"],
    "iat": json["iat"]
  };
}
function DecodedUserTokenToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "apiKey": value.apiKey,
    "userId": value.userId,
    "email": value.email,
    "name": value.name,
    "handle": value.handle,
    "verified": value.verified,
    "profilePicture": ProfilePictureToJSON$1(value.profilePicture),
    "sub": value.sub,
    "iat": value.iat
  };
}
function instanceOfDeveloperApp(value) {
  let isInstance = true;
  isInstance = isInstance && "address" in value && value["address"] !== void 0;
  isInstance = isInstance && "userId" in value && value["userId"] !== void 0;
  isInstance = isInstance && "name" in value && value["name"] !== void 0;
  return isInstance;
}
function DeveloperAppFromJSON(json) {
  return DeveloperAppFromJSONTyped(json);
}
function DeveloperAppFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "address": json["address"],
    "userId": json["user_id"],
    "name": json["name"],
    "description": !exists$2(json, "description") ? void 0 : json["description"],
    "imageUrl": !exists$2(json, "image_url") ? void 0 : json["image_url"]
  };
}
function DeveloperAppToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "address": value.address,
    "user_id": value.userId,
    "name": value.name,
    "description": value.description,
    "image_url": value.imageUrl
  };
}
function instanceOfDeveloperAppResponse(value) {
  let isInstance = true;
  return isInstance;
}
function DeveloperAppResponseFromJSON(json) {
  return DeveloperAppResponseFromJSONTyped(json);
}
function DeveloperAppResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "data": !exists$2(json, "data") ? void 0 : DeveloperAppFromJSON(json["data"])
  };
}
function DeveloperAppResponseToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "data": DeveloperAppToJSON(value.data)
  };
}
function instanceOfDeveloperApps(value) {
  let isInstance = true;
  return isInstance;
}
function DeveloperAppsFromJSON(json) {
  return DeveloperAppsFromJSONTyped(json);
}
function DeveloperAppsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "data": !exists$2(json, "data") ? void 0 : json["data"].map(DeveloperAppFromJSON)
  };
}
function DeveloperAppsToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "data": value.data === void 0 ? void 0 : value.data.map(DeveloperAppToJSON)
  };
}
function instanceOfEmailAccess(value) {
  let isInstance = true;
  isInstance = isInstance && "id" in value && value["id"] !== void 0;
  isInstance = isInstance && "emailOwnerUserId" in value && value["emailOwnerUserId"] !== void 0;
  isInstance = isInstance && "receivingUserId" in value && value["receivingUserId"] !== void 0;
  isInstance = isInstance && "grantorUserId" in value && value["grantorUserId"] !== void 0;
  isInstance = isInstance && "encryptedKey" in value && value["encryptedKey"] !== void 0;
  isInstance = isInstance && "isInitial" in value && value["isInitial"] !== void 0;
  isInstance = isInstance && "createdAt" in value && value["createdAt"] !== void 0;
  isInstance = isInstance && "updatedAt" in value && value["updatedAt"] !== void 0;
  return isInstance;
}
function EmailAccessFromJSON(json) {
  return EmailAccessFromJSONTyped(json);
}
function EmailAccessFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "id": json["id"],
    "emailOwnerUserId": json["email_owner_user_id"],
    "receivingUserId": json["receiving_user_id"],
    "grantorUserId": json["grantor_user_id"],
    "encryptedKey": json["encrypted_key"],
    "isInitial": json["is_initial"],
    "createdAt": json["created_at"],
    "updatedAt": json["updated_at"]
  };
}
function EmailAccessToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "id": value.id,
    "email_owner_user_id": value.emailOwnerUserId,
    "receiving_user_id": value.receivingUserId,
    "grantor_user_id": value.grantorUserId,
    "encrypted_key": value.encryptedKey,
    "is_initial": value.isInitial,
    "created_at": value.createdAt,
    "updated_at": value.updatedAt
  };
}
function instanceOfEmailAccessResponse(value) {
  let isInstance = true;
  return isInstance;
}
function EmailAccessResponseFromJSON(json) {
  return EmailAccessResponseFromJSONTyped(json);
}
function EmailAccessResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "data": !exists$2(json, "data") ? void 0 : EmailAccessFromJSON(json["data"])
  };
}
function EmailAccessResponseToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "data": EmailAccessToJSON(value.data)
  };
}
var EventEventTypeEnum = {
  RemixContest: "remix_contest",
  LiveEvent: "live_event",
  NewRelease: "new_release"
};
var EventEntityTypeEnum = {
  Track: "track",
  Collection: "collection",
  User: "user"
};
function instanceOfEvent(value) {
  let isInstance = true;
  isInstance = isInstance && "eventId" in value && value["eventId"] !== void 0;
  isInstance = isInstance && "eventType" in value && value["eventType"] !== void 0;
  isInstance = isInstance && "userId" in value && value["userId"] !== void 0;
  isInstance = isInstance && "createdAt" in value && value["createdAt"] !== void 0;
  isInstance = isInstance && "updatedAt" in value && value["updatedAt"] !== void 0;
  isInstance = isInstance && "eventData" in value && value["eventData"] !== void 0;
  return isInstance;
}
function EventFromJSON(json) {
  return EventFromJSONTyped(json);
}
function EventFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "eventId": json["event_id"],
    "eventType": json["event_type"],
    "userId": json["user_id"],
    "entityType": !exists$2(json, "entity_type") ? void 0 : json["entity_type"],
    "entityId": !exists$2(json, "entity_id") ? void 0 : json["entity_id"],
    "endDate": !exists$2(json, "end_date") ? void 0 : json["end_date"],
    "isDeleted": !exists$2(json, "is_deleted") ? void 0 : json["is_deleted"],
    "createdAt": json["created_at"],
    "updatedAt": json["updated_at"],
    "eventData": json["event_data"]
  };
}
function EventToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "event_id": value.eventId,
    "event_type": value.eventType,
    "user_id": value.userId,
    "entity_type": value.entityType,
    "entity_id": value.entityId,
    "end_date": value.endDate,
    "is_deleted": value.isDeleted,
    "created_at": value.createdAt,
    "updated_at": value.updatedAt,
    "event_data": value.eventData
  };
}
function instanceOfEventsResponse(value) {
  let isInstance = true;
  return isInstance;
}
function EventsResponseFromJSON(json) {
  return EventsResponseFromJSONTyped(json);
}
function EventsResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "data": !exists$2(json, "data") ? void 0 : json["data"].map(EventFromJSON)
  };
}
function EventsResponseToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "data": value.data === void 0 ? void 0 : value.data.map(EventToJSON)
  };
}
function instanceOfFavorite$1(value) {
  let isInstance = true;
  isInstance = isInstance && "favoriteItemId" in value && value["favoriteItemId"] !== void 0;
  isInstance = isInstance && "favoriteType" in value && value["favoriteType"] !== void 0;
  isInstance = isInstance && "userId" in value && value["userId"] !== void 0;
  isInstance = isInstance && "createdAt" in value && value["createdAt"] !== void 0;
  return isInstance;
}
function FavoriteFromJSON$1(json) {
  return FavoriteFromJSONTyped$1(json);
}
function FavoriteFromJSONTyped$1(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "favoriteItemId": json["favorite_item_id"],
    "favoriteType": json["favorite_type"],
    "userId": json["user_id"],
    "createdAt": json["created_at"]
  };
}
function FavoriteToJSON$1(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "favorite_item_id": value.favoriteItemId,
    "favorite_type": value.favoriteType,
    "user_id": value.userId,
    "created_at": value.createdAt
  };
}
function instanceOfFavoritesResponse(value) {
  let isInstance = true;
  return isInstance;
}
function FavoritesResponseFromJSON(json) {
  return FavoritesResponseFromJSONTyped(json);
}
function FavoritesResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "data": !exists$2(json, "data") ? void 0 : json["data"].map(FavoriteFromJSON$1)
  };
}
function FavoritesResponseToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "data": value.data === void 0 ? void 0 : value.data.map(FavoriteToJSON$1)
  };
}
function instanceOfFollowersResponse(value) {
  let isInstance = true;
  return isInstance;
}
function FollowersResponseFromJSON(json) {
  return FollowersResponseFromJSONTyped(json);
}
function FollowersResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "data": !exists$2(json, "data") ? void 0 : json["data"].map(UserFromJSON)
  };
}
function FollowersResponseToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "data": value.data === void 0 ? void 0 : value.data.map(UserToJSON)
  };
}
function instanceOfFollowingResponse$1(value) {
  let isInstance = true;
  return isInstance;
}
function FollowingResponseFromJSON$1(json) {
  return FollowingResponseFromJSONTyped$1(json);
}
function FollowingResponseFromJSONTyped$1(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "data": !exists$2(json, "data") ? void 0 : json["data"].map(UserFromJSON)
  };
}
function FollowingResponseToJSON$1(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "data": value.data === void 0 ? void 0 : value.data.map(UserToJSON)
  };
}
function instanceOfGetChallenges(value) {
  let isInstance = true;
  return isInstance;
}
function GetChallengesFromJSON(json) {
  return GetChallengesFromJSONTyped(json);
}
function GetChallengesFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "data": !exists$2(json, "data") ? void 0 : json["data"].map(ChallengeResponseFromJSON)
  };
}
function GetChallengesToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "data": value.data === void 0 ? void 0 : value.data.map(ChallengeResponseToJSON)
  };
}
function instanceOfSupporting(value) {
  let isInstance = true;
  isInstance = isInstance && "rank" in value && value["rank"] !== void 0;
  isInstance = isInstance && "amount" in value && value["amount"] !== void 0;
  isInstance = isInstance && "receiver" in value && value["receiver"] !== void 0;
  return isInstance;
}
function SupportingFromJSON(json) {
  return SupportingFromJSONTyped(json);
}
function SupportingFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "rank": json["rank"],
    "amount": json["amount"],
    "receiver": UserFromJSON(json["receiver"])
  };
}
function SupportingToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "rank": value.rank,
    "amount": value.amount,
    "receiver": UserToJSON(value.receiver)
  };
}
function instanceOfGetSupportedUsers(value) {
  let isInstance = true;
  return isInstance;
}
function GetSupportedUsersFromJSON(json) {
  return GetSupportedUsersFromJSONTyped(json);
}
function GetSupportedUsersFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "data": !exists$2(json, "data") ? void 0 : json["data"].map(SupportingFromJSON)
  };
}
function GetSupportedUsersToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "data": value.data === void 0 ? void 0 : value.data.map(SupportingToJSON)
  };
}
function instanceOfSupporter(value) {
  let isInstance = true;
  isInstance = isInstance && "rank" in value && value["rank"] !== void 0;
  isInstance = isInstance && "amount" in value && value["amount"] !== void 0;
  isInstance = isInstance && "sender" in value && value["sender"] !== void 0;
  return isInstance;
}
function SupporterFromJSON(json) {
  return SupporterFromJSONTyped(json);
}
function SupporterFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "rank": json["rank"],
    "amount": json["amount"],
    "sender": UserFromJSON(json["sender"])
  };
}
function SupporterToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "rank": value.rank,
    "amount": value.amount,
    "sender": UserToJSON(value.sender)
  };
}
function instanceOfGetSupporters(value) {
  let isInstance = true;
  return isInstance;
}
function GetSupportersFromJSON(json) {
  return GetSupportersFromJSONTyped(json);
}
function GetSupportersFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "data": !exists$2(json, "data") ? void 0 : json["data"].map(SupporterFromJSON)
  };
}
function GetSupportersToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "data": value.data === void 0 ? void 0 : value.data.map(SupporterToJSON)
  };
}
function instanceOfTip(value) {
  let isInstance = true;
  isInstance = isInstance && "amount" in value && value["amount"] !== void 0;
  isInstance = isInstance && "createdAt" in value && value["createdAt"] !== void 0;
  return isInstance;
}
function TipFromJSON(json) {
  return TipFromJSONTyped(json);
}
function TipFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "amount": json["amount"],
    "sender": !exists$2(json, "sender") ? void 0 : UserFromJSON(json["sender"]),
    "receiver": !exists$2(json, "receiver") ? void 0 : UserFromJSON(json["receiver"]),
    "createdAt": json["created_at"]
  };
}
function TipToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "amount": value.amount,
    "sender": UserToJSON(value.sender),
    "receiver": UserToJSON(value.receiver),
    "created_at": value.createdAt
  };
}
function instanceOfGetTipsResponse$1(value) {
  let isInstance = true;
  return isInstance;
}
function GetTipsResponseFromJSON$1(json) {
  return GetTipsResponseFromJSONTyped$1(json);
}
function GetTipsResponseFromJSONTyped$1(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "data": !exists$2(json, "data") ? void 0 : json["data"].map(TipFromJSON)
  };
}
function GetTipsResponseToJSON$1(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "data": value.data === void 0 ? void 0 : value.data.map(TipToJSON)
  };
}
function instanceOfTrackElement(value) {
  let isInstance = true;
  isInstance = isInstance && "parentTrackId" in value && value["parentTrackId"] !== void 0;
  return isInstance;
}
function TrackElementFromJSON(json) {
  return TrackElementFromJSONTyped(json);
}
function TrackElementFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "parentTrackId": json["parent_track_id"]
  };
}
function TrackElementToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "parent_track_id": value.parentTrackId
  };
}
function instanceOfRemixParent(value) {
  let isInstance = true;
  return isInstance;
}
function RemixParentFromJSON(json) {
  return RemixParentFromJSONTyped(json);
}
function RemixParentFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "tracks": !exists$2(json, "tracks") ? void 0 : json["tracks"].map(TrackElementFromJSON)
  };
}
function RemixParentToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "tracks": value.tracks === void 0 ? void 0 : value.tracks.map(TrackElementToJSON)
  };
}
function instanceOfTrackArtwork(value) {
  let isInstance = true;
  return isInstance;
}
function TrackArtworkFromJSON(json) {
  return TrackArtworkFromJSONTyped(json);
}
function TrackArtworkFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "_150x150": !exists$2(json, "150x150") ? void 0 : json["150x150"],
    "_480x480": !exists$2(json, "480x480") ? void 0 : json["480x480"],
    "_1000x1000": !exists$2(json, "1000x1000") ? void 0 : json["1000x1000"]
  };
}
function TrackArtworkToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "150x150": value._150x150,
    "480x480": value._480x480,
    "1000x1000": value._1000x1000
  };
}
function instanceOfTrack(value) {
  let isInstance = true;
  isInstance = isInstance && "artwork" in value && value["artwork"] !== void 0;
  isInstance = isInstance && "genre" in value && value["genre"] !== void 0;
  isInstance = isInstance && "id" in value && value["id"] !== void 0;
  isInstance = isInstance && "isOriginalAvailable" in value && value["isOriginalAvailable"] !== void 0;
  isInstance = isInstance && "repostCount" in value && value["repostCount"] !== void 0;
  isInstance = isInstance && "favoriteCount" in value && value["favoriteCount"] !== void 0;
  isInstance = isInstance && "commentCount" in value && value["commentCount"] !== void 0;
  isInstance = isInstance && "title" in value && value["title"] !== void 0;
  isInstance = isInstance && "user" in value && value["user"] !== void 0;
  isInstance = isInstance && "duration" in value && value["duration"] !== void 0;
  isInstance = isInstance && "isDownloadable" in value && value["isDownloadable"] !== void 0;
  isInstance = isInstance && "playCount" in value && value["playCount"] !== void 0;
  isInstance = isInstance && "permalink" in value && value["permalink"] !== void 0;
  return isInstance;
}
function TrackFromJSON(json) {
  return TrackFromJSONTyped(json);
}
function TrackFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "artwork": TrackArtworkFromJSON(json["artwork"]),
    "description": !exists$2(json, "description") ? void 0 : json["description"],
    "genre": json["genre"],
    "id": json["id"],
    "trackCid": !exists$2(json, "track_cid") ? void 0 : json["track_cid"],
    "previewCid": !exists$2(json, "preview_cid") ? void 0 : json["preview_cid"],
    "origFileCid": !exists$2(json, "orig_file_cid") ? void 0 : json["orig_file_cid"],
    "origFilename": !exists$2(json, "orig_filename") ? void 0 : json["orig_filename"],
    "isOriginalAvailable": json["is_original_available"],
    "mood": !exists$2(json, "mood") ? void 0 : json["mood"],
    "releaseDate": !exists$2(json, "release_date") ? void 0 : json["release_date"],
    "isrc": !exists$2(json, "isrc") ? void 0 : json["isrc"],
    "remixOf": !exists$2(json, "remix_of") ? void 0 : RemixParentFromJSON(json["remix_of"]),
    "repostCount": json["repost_count"],
    "favoriteCount": json["favorite_count"],
    "commentCount": json["comment_count"],
    "tags": !exists$2(json, "tags") ? void 0 : json["tags"],
    "title": json["title"],
    "user": UserFromJSON(json["user"]),
    "duration": json["duration"],
    "isDownloadable": json["is_downloadable"],
    "playCount": json["play_count"],
    "permalink": json["permalink"],
    "isStreamable": !exists$2(json, "is_streamable") ? void 0 : json["is_streamable"],
    "ddexApp": !exists$2(json, "ddex_app") ? void 0 : json["ddex_app"],
    "playlistsContainingTrack": !exists$2(json, "playlists_containing_track") ? void 0 : json["playlists_containing_track"],
    "pinnedCommentId": !exists$2(json, "pinned_comment_id") ? void 0 : json["pinned_comment_id"],
    "albumBacklink": !exists$2(json, "album_backlink") ? void 0 : AlbumBacklinkFromJSON$1(json["album_backlink"])
  };
}
function TrackToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "artwork": TrackArtworkToJSON(value.artwork),
    "description": value.description,
    "genre": value.genre,
    "id": value.id,
    "track_cid": value.trackCid,
    "preview_cid": value.previewCid,
    "orig_file_cid": value.origFileCid,
    "orig_filename": value.origFilename,
    "is_original_available": value.isOriginalAvailable,
    "mood": value.mood,
    "release_date": value.releaseDate,
    "isrc": value.isrc,
    "remix_of": RemixParentToJSON(value.remixOf),
    "repost_count": value.repostCount,
    "favorite_count": value.favoriteCount,
    "comment_count": value.commentCount,
    "tags": value.tags,
    "title": value.title,
    "user": UserToJSON(value.user),
    "duration": value.duration,
    "is_downloadable": value.isDownloadable,
    "play_count": value.playCount,
    "permalink": value.permalink,
    "is_streamable": value.isStreamable,
    "ddex_app": value.ddexApp,
    "playlists_containing_track": value.playlistsContainingTrack,
    "pinned_comment_id": value.pinnedCommentId,
    "album_backlink": AlbumBacklinkToJSON$1(value.albumBacklink)
  };
}
var TrackActivityItemTypeEnum = {
  Track: "track"
};
function instanceOfTrackActivity(value) {
  let isInstance = true;
  isInstance = isInstance && "itemType" in value && value["itemType"] !== void 0;
  isInstance = isInstance && "item" in value && value["item"] !== void 0;
  return isInstance;
}
function TrackActivityFromJSON(json) {
  return TrackActivityFromJSONTyped(json, false);
}
function TrackActivityFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    ...ActivityFromJSONTyped(json, ignoreDiscriminator),
    "itemType": json["item_type"],
    "item": TrackFromJSON(json["item"])
  };
}
function TrackActivityToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    ...ActivityToJSON(value),
    "item_type": value.itemType,
    "item": TrackToJSON(value.item)
  };
}
function instanceOfHistoryResponse(value) {
  let isInstance = true;
  return isInstance;
}
function HistoryResponseFromJSON(json) {
  return HistoryResponseFromJSONTyped(json);
}
function HistoryResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "data": !exists$2(json, "data") ? void 0 : json["data"].map(TrackActivityFromJSON)
  };
}
function HistoryResponseToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "data": value.data === void 0 ? void 0 : value.data.map(TrackActivityToJSON)
  };
}
function instanceOfListenCount(value) {
  let isInstance = true;
  return isInstance;
}
function ListenCountFromJSON(json) {
  return ListenCountFromJSONTyped(json);
}
function ListenCountFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "trackId": !exists$2(json, "trackId") ? void 0 : json["trackId"],
    "date": !exists$2(json, "date") ? void 0 : json["date"],
    "listens": !exists$2(json, "listens") ? void 0 : json["listens"]
  };
}
function ListenCountToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "trackId": value.trackId,
    "date": value.date,
    "listens": value.listens
  };
}
function instanceOfMonthlyAggregatePlay(value) {
  let isInstance = true;
  return isInstance;
}
function MonthlyAggregatePlayFromJSON(json) {
  return MonthlyAggregatePlayFromJSONTyped(json);
}
function MonthlyAggregatePlayFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "totalListens": !exists$2(json, "totalListens") ? void 0 : json["totalListens"],
    "trackIds": !exists$2(json, "trackIds") ? void 0 : json["trackIds"],
    "listenCounts": !exists$2(json, "listenCounts") ? void 0 : json["listenCounts"].map(ListenCountFromJSON)
  };
}
function MonthlyAggregatePlayToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "totalListens": value.totalListens,
    "trackIds": value.trackIds,
    "listenCounts": value.listenCounts === void 0 ? void 0 : value.listenCounts.map(ListenCountToJSON)
  };
}
function instanceOfMutualFollowersResponse(value) {
  let isInstance = true;
  return isInstance;
}
function MutualFollowersResponseFromJSON(json) {
  return MutualFollowersResponseFromJSONTyped(json);
}
function MutualFollowersResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "data": !exists$2(json, "data") ? void 0 : json["data"].map(UserFromJSON)
  };
}
function MutualFollowersResponseToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "data": value.data === void 0 ? void 0 : value.data.map(UserToJSON)
  };
}
function instanceOfPlaylistResponse(value) {
  let isInstance = true;
  return isInstance;
}
function PlaylistResponseFromJSON(json) {
  return PlaylistResponseFromJSONTyped(json);
}
function PlaylistResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "data": !exists$2(json, "data") ? void 0 : json["data"].map(PlaylistFromJSON)
  };
}
function PlaylistResponseToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "data": value.data === void 0 ? void 0 : value.data.map(PlaylistToJSON)
  };
}
function instanceOfPlaylistSearchResult(value) {
  let isInstance = true;
  return isInstance;
}
function PlaylistSearchResultFromJSON(json) {
  return PlaylistSearchResultFromJSONTyped(json);
}
function PlaylistSearchResultFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "data": !exists$2(json, "data") ? void 0 : json["data"].map(PlaylistFromJSON)
  };
}
function PlaylistSearchResultToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "data": value.data === void 0 ? void 0 : value.data.map(PlaylistToJSON)
  };
}
function instanceOfPlaylistTracksResponse(value) {
  let isInstance = true;
  return isInstance;
}
function PlaylistTracksResponseFromJSON(json) {
  return PlaylistTracksResponseFromJSONTyped(json);
}
function PlaylistTracksResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "data": !exists$2(json, "data") ? void 0 : json["data"].map(TrackFromJSON)
  };
}
function PlaylistTracksResponseToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "data": value.data === void 0 ? void 0 : value.data.map(TrackToJSON)
  };
}
function instanceOfPlaylistsResponse(value) {
  let isInstance = true;
  return isInstance;
}
function PlaylistsResponseFromJSON(json) {
  return PlaylistsResponseFromJSONTyped(json);
}
function PlaylistsResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "data": !exists$2(json, "data") ? void 0 : json["data"].map(PlaylistFromJSON)
  };
}
function PlaylistsResponseToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "data": value.data === void 0 ? void 0 : value.data.map(PlaylistToJSON)
  };
}
function instanceOfPurchasersResponse(value) {
  let isInstance = true;
  return isInstance;
}
function PurchasersResponseFromJSON(json) {
  return PurchasersResponseFromJSONTyped(json);
}
function PurchasersResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "data": !exists$2(json, "data") ? void 0 : json["data"].map(UserFromJSON)
  };
}
function PurchasersResponseToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "data": value.data === void 0 ? void 0 : value.data.map(UserToJSON)
  };
}
function instanceOfRelatedArtistResponse(value) {
  let isInstance = true;
  return isInstance;
}
function RelatedArtistResponseFromJSON(json) {
  return RelatedArtistResponseFromJSONTyped(json);
}
function RelatedArtistResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "data": !exists$2(json, "data") ? void 0 : json["data"].map(UserFromJSON)
  };
}
function RelatedArtistResponseToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "data": value.data === void 0 ? void 0 : value.data.map(UserToJSON)
  };
}
function instanceOfRemixedTrackAggregate(value) {
  let isInstance = true;
  isInstance = isInstance && "trackId" in value && value["trackId"] !== void 0;
  isInstance = isInstance && "title" in value && value["title"] !== void 0;
  isInstance = isInstance && "remixCount" in value && value["remixCount"] !== void 0;
  return isInstance;
}
function RemixedTrackAggregateFromJSON(json) {
  return RemixedTrackAggregateFromJSONTyped(json);
}
function RemixedTrackAggregateFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "trackId": json["track_id"],
    "title": json["title"],
    "remixCount": json["remix_count"]
  };
}
function RemixedTrackAggregateToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "track_id": value.trackId,
    "title": value.title,
    "remix_count": value.remixCount
  };
}
function instanceOfRemixersResponse(value) {
  let isInstance = true;
  return isInstance;
}
function RemixersResponseFromJSON(json) {
  return RemixersResponseFromJSONTyped(json);
}
function RemixersResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "data": !exists$2(json, "data") ? void 0 : json["data"].map(UserFromJSON)
  };
}
function RemixersResponseToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "data": value.data === void 0 ? void 0 : value.data.map(UserToJSON)
  };
}
function instanceOfReposts(value) {
  let isInstance = true;
  return isInstance;
}
function RepostsFromJSON(json) {
  return RepostsFromJSONTyped(json);
}
function RepostsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "data": !exists$2(json, "data") ? void 0 : json["data"].map(ActivityFromJSON)
  };
}
function RepostsToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "data": value.data === void 0 ? void 0 : value.data.map(ActivityToJSON)
  };
}
function instanceOfSaleJson(value) {
  let isInstance = true;
  return isInstance;
}
function SaleJsonFromJSON(json) {
  return SaleJsonFromJSONTyped(json);
}
function SaleJsonFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "title": !exists$2(json, "title") ? void 0 : json["title"],
    "link": !exists$2(json, "link") ? void 0 : json["link"],
    "purchasedBy": !exists$2(json, "purchased_by") ? void 0 : json["purchased_by"],
    "buyerUserId": !exists$2(json, "buyer_user_id") ? void 0 : json["buyer_user_id"],
    "date": !exists$2(json, "date") ? void 0 : json["date"],
    "salePrice": !exists$2(json, "sale_price") ? void 0 : json["sale_price"],
    "networkFee": !exists$2(json, "network_fee") ? void 0 : json["network_fee"],
    "payExtra": !exists$2(json, "pay_extra") ? void 0 : json["pay_extra"],
    "total": !exists$2(json, "total") ? void 0 : json["total"],
    "country": !exists$2(json, "country") ? void 0 : json["country"],
    "encryptedEmail": !exists$2(json, "encrypted_email") ? void 0 : json["encrypted_email"],
    "encryptedKey": !exists$2(json, "encrypted_key") ? void 0 : json["encrypted_key"],
    "isInitial": !exists$2(json, "is_initial") ? void 0 : json["is_initial"],
    "pubkeyBase64": !exists$2(json, "pubkey_base64") ? void 0 : json["pubkey_base64"]
  };
}
function SaleJsonToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "title": value.title,
    "link": value.link,
    "purchased_by": value.purchasedBy,
    "buyer_user_id": value.buyerUserId,
    "date": value.date,
    "sale_price": value.salePrice,
    "network_fee": value.networkFee,
    "pay_extra": value.payExtra,
    "total": value.total,
    "country": value.country,
    "encrypted_email": value.encryptedEmail,
    "encrypted_key": value.encryptedKey,
    "is_initial": value.isInitial,
    "pubkey_base64": value.pubkeyBase64
  };
}
function instanceOfSalesAggregate(value) {
  let isInstance = true;
  isInstance = isInstance && "contentType" in value && value["contentType"] !== void 0;
  isInstance = isInstance && "contentId" in value && value["contentId"] !== void 0;
  isInstance = isInstance && "purchaseCount" in value && value["purchaseCount"] !== void 0;
  return isInstance;
}
function SalesAggregateFromJSON(json) {
  return SalesAggregateFromJSONTyped(json);
}
function SalesAggregateFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "contentType": json["content_type"],
    "contentId": json["content_id"],
    "purchaseCount": json["purchase_count"]
  };
}
function SalesAggregateToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "content_type": value.contentType,
    "content_id": value.contentId,
    "purchase_count": value.purchaseCount
  };
}
function instanceOfSalesAggregateResponse(value) {
  let isInstance = true;
  return isInstance;
}
function SalesAggregateResponseFromJSON(json) {
  return SalesAggregateResponseFromJSONTyped(json);
}
function SalesAggregateResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "data": !exists$2(json, "data") ? void 0 : json["data"].map(SalesAggregateFromJSON)
  };
}
function SalesAggregateResponseToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "data": value.data === void 0 ? void 0 : value.data.map(SalesAggregateToJSON)
  };
}
function instanceOfSalesJsonContent(value) {
  let isInstance = true;
  return isInstance;
}
function SalesJsonContentFromJSON(json) {
  return SalesJsonContentFromJSONTyped(json);
}
function SalesJsonContentFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "sales": !exists$2(json, "sales") ? void 0 : json["sales"].map(SaleJsonFromJSON)
  };
}
function SalesJsonContentToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "sales": value.sales === void 0 ? void 0 : value.sales.map(SaleJsonToJSON)
  };
}
function instanceOfSalesJsonResponse(value) {
  let isInstance = true;
  return isInstance;
}
function SalesJsonResponseFromJSON(json) {
  return SalesJsonResponseFromJSONTyped(json);
}
function SalesJsonResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "data": !exists$2(json, "data") ? void 0 : SalesJsonContentFromJSON(json["data"])
  };
}
function SalesJsonResponseToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "data": SalesJsonContentToJSON(value.data)
  };
}
function instanceOfStem(value) {
  let isInstance = true;
  isInstance = isInstance && "id" in value && value["id"] !== void 0;
  isInstance = isInstance && "parentId" in value && value["parentId"] !== void 0;
  isInstance = isInstance && "category" in value && value["category"] !== void 0;
  isInstance = isInstance && "cid" in value && value["cid"] !== void 0;
  isInstance = isInstance && "userId" in value && value["userId"] !== void 0;
  isInstance = isInstance && "blocknumber" in value && value["blocknumber"] !== void 0;
  isInstance = isInstance && "origFilename" in value && value["origFilename"] !== void 0;
  return isInstance;
}
function StemFromJSON(json) {
  return StemFromJSONTyped(json);
}
function StemFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "id": json["id"],
    "parentId": json["parent_id"],
    "category": json["category"],
    "cid": json["cid"],
    "userId": json["user_id"],
    "blocknumber": json["blocknumber"],
    "origFilename": json["orig_filename"]
  };
}
function StemToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "id": value.id,
    "parent_id": value.parentId,
    "category": value.category,
    "cid": value.cid,
    "user_id": value.userId,
    "blocknumber": value.blocknumber,
    "orig_filename": value.origFilename
  };
}
function instanceOfStemsResponse$1(value) {
  let isInstance = true;
  return isInstance;
}
function StemsResponseFromJSON$1(json) {
  return StemsResponseFromJSONTyped$1(json);
}
function StemsResponseFromJSONTyped$1(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "data": !exists$2(json, "data") ? void 0 : json["data"].map(StemFromJSON)
  };
}
function StemsResponseToJSON$1(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "data": value.data === void 0 ? void 0 : value.data.map(StemToJSON)
  };
}
function instanceOfStreamUrlResponse(value) {
  let isInstance = true;
  isInstance = isInstance && "data" in value && value["data"] !== void 0;
  return isInstance;
}
function StreamUrlResponseFromJSON(json) {
  return StreamUrlResponseFromJSONTyped(json);
}
function StreamUrlResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "data": json["data"]
  };
}
function StreamUrlResponseToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "data": value.data
  };
}
function instanceOfSubscribersResponse(value) {
  let isInstance = true;
  return isInstance;
}
function SubscribersResponseFromJSON(json) {
  return SubscribersResponseFromJSONTyped(json);
}
function SubscribersResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "data": !exists$2(json, "data") ? void 0 : json["data"].map(UserFromJSON)
  };
}
function SubscribersResponseToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "data": value.data === void 0 ? void 0 : value.data.map(UserToJSON)
  };
}
function instanceOfTagsResponse(value) {
  let isInstance = true;
  return isInstance;
}
function TagsResponseFromJSON(json) {
  return TagsResponseFromJSONTyped(json);
}
function TagsResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "data": !exists$2(json, "data") ? void 0 : json["data"]
  };
}
function TagsResponseToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "data": value.data
  };
}
function instanceOfTopListener(value) {
  let isInstance = true;
  return isInstance;
}
function TopListenerFromJSON(json) {
  return TopListenerFromJSONTyped(json);
}
function TopListenerFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "data": !exists$2(json, "data") ? void 0 : json["data"].map(TopListenerFromJSON)
  };
}
function TopListenerToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "data": value.data === void 0 ? void 0 : value.data.map(TopListenerToJSON)
  };
}
function instanceOfTrackCommentCountResponse(value) {
  let isInstance = true;
  return isInstance;
}
function TrackCommentCountResponseFromJSON(json) {
  return TrackCommentCountResponseFromJSONTyped(json);
}
function TrackCommentCountResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "data": !exists$2(json, "data") ? void 0 : json["data"]
  };
}
function TrackCommentCountResponseToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "data": value.data
  };
}
function instanceOfTrackCommentNotificationResponse(value) {
  let isInstance = true;
  return isInstance;
}
function TrackCommentNotificationResponseFromJSON(json) {
  return TrackCommentNotificationResponseFromJSONTyped(json);
}
function TrackCommentNotificationResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "data": !exists$2(json, "data") ? void 0 : CommentNotificationSettingFromJSON(json["data"])
  };
}
function TrackCommentNotificationResponseToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "data": CommentNotificationSettingToJSON(value.data)
  };
}
function instanceOfTrackCommentsResponse(value) {
  let isInstance = true;
  return isInstance;
}
function TrackCommentsResponseFromJSON(json) {
  return TrackCommentsResponseFromJSONTyped(json);
}
function TrackCommentsResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "data": !exists$2(json, "data") ? void 0 : json["data"].map(CommentFromJSON$1)
  };
}
function TrackCommentsResponseToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "data": value.data === void 0 ? void 0 : value.data.map(CommentToJSON$1)
  };
}
function instanceOfTrackInspect(value) {
  let isInstance = true;
  return isInstance;
}
function TrackInspectFromJSON(json) {
  return TrackInspectFromJSONTyped(json);
}
function TrackInspectFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "data": !exists$2(json, "data") ? void 0 : BlobInfoFromJSON(json["data"])
  };
}
function TrackInspectToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "data": BlobInfoToJSON(value.data)
  };
}
function instanceOfTrackInspectList(value) {
  let isInstance = true;
  return isInstance;
}
function TrackInspectListFromJSON(json) {
  return TrackInspectListFromJSONTyped(json);
}
function TrackInspectListFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "data": !exists$2(json, "data") ? void 0 : json["data"].map(BlobInfoFromJSON)
  };
}
function TrackInspectListToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "data": value.data === void 0 ? void 0 : value.data.map(BlobInfoToJSON)
  };
}
function instanceOfTrackResponse(value) {
  let isInstance = true;
  return isInstance;
}
function TrackResponseFromJSON(json) {
  return TrackResponseFromJSONTyped(json);
}
function TrackResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "data": !exists$2(json, "data") ? void 0 : TrackFromJSON(json["data"])
  };
}
function TrackResponseToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "data": TrackToJSON(value.data)
  };
}
function instanceOfTrackSearch(value) {
  let isInstance = true;
  return isInstance;
}
function TrackSearchFromJSON(json) {
  return TrackSearchFromJSONTyped(json);
}
function TrackSearchFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "data": !exists$2(json, "data") ? void 0 : json["data"].map(TrackFromJSON)
  };
}
function TrackSearchToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "data": value.data === void 0 ? void 0 : value.data.map(TrackToJSON)
  };
}
function instanceOfTracksResponse(value) {
  let isInstance = true;
  return isInstance;
}
function TracksResponseFromJSON(json) {
  return TracksResponseFromJSONTyped(json);
}
function TracksResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "data": !exists$2(json, "data") ? void 0 : json["data"].map(TrackFromJSON)
  };
}
function TracksResponseToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "data": value.data === void 0 ? void 0 : value.data.map(TrackToJSON)
  };
}
function instanceOfTrendingPlaylistsResponse(value) {
  let isInstance = true;
  return isInstance;
}
function TrendingPlaylistsResponseFromJSON(json) {
  return TrendingPlaylistsResponseFromJSONTyped(json);
}
function TrendingPlaylistsResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "data": !exists$2(json, "data") ? void 0 : json["data"].map(PlaylistFromJSON)
  };
}
function TrendingPlaylistsResponseToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "data": value.data === void 0 ? void 0 : value.data.map(PlaylistToJSON)
  };
}
function instanceOfUnclaimedIdResponse(value) {
  let isInstance = true;
  return isInstance;
}
function UnclaimedIdResponseFromJSON(json) {
  return UnclaimedIdResponseFromJSONTyped(json);
}
function UnclaimedIdResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "data": !exists$2(json, "data") ? void 0 : json["data"]
  };
}
function UnclaimedIdResponseToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "data": value.data
  };
}
function instanceOfUndisbursedChallenge(value) {
  let isInstance = true;
  isInstance = isInstance && "challengeId" in value && value["challengeId"] !== void 0;
  isInstance = isInstance && "userId" in value && value["userId"] !== void 0;
  isInstance = isInstance && "specifier" in value && value["specifier"] !== void 0;
  isInstance = isInstance && "amount" in value && value["amount"] !== void 0;
  isInstance = isInstance && "completedBlocknumber" in value && value["completedBlocknumber"] !== void 0;
  isInstance = isInstance && "handle" in value && value["handle"] !== void 0;
  isInstance = isInstance && "wallet" in value && value["wallet"] !== void 0;
  isInstance = isInstance && "createdAt" in value && value["createdAt"] !== void 0;
  isInstance = isInstance && "completedAt" in value && value["completedAt"] !== void 0;
  return isInstance;
}
function UndisbursedChallengeFromJSON(json) {
  return UndisbursedChallengeFromJSONTyped(json);
}
function UndisbursedChallengeFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "challengeId": json["challenge_id"],
    "userId": json["user_id"],
    "specifier": json["specifier"],
    "amount": json["amount"],
    "completedBlocknumber": json["completed_blocknumber"],
    "handle": json["handle"],
    "wallet": json["wallet"],
    "createdAt": json["created_at"],
    "completedAt": json["completed_at"],
    "cooldownDays": !exists$2(json, "cooldown_days") ? void 0 : json["cooldown_days"]
  };
}
function UndisbursedChallengeToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "challenge_id": value.challengeId,
    "user_id": value.userId,
    "specifier": value.specifier,
    "amount": value.amount,
    "completed_blocknumber": value.completedBlocknumber,
    "handle": value.handle,
    "wallet": value.wallet,
    "created_at": value.createdAt,
    "completed_at": value.completedAt,
    "cooldown_days": value.cooldownDays
  };
}
function instanceOfUndisbursedChallenges(value) {
  let isInstance = true;
  return isInstance;
}
function UndisbursedChallengesFromJSON(json) {
  return UndisbursedChallengesFromJSONTyped(json);
}
function UndisbursedChallengesFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "data": !exists$2(json, "data") ? void 0 : json["data"].map(UndisbursedChallengeFromJSON)
  };
}
function UndisbursedChallengesToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "data": value.data === void 0 ? void 0 : value.data.map(UndisbursedChallengeToJSON)
  };
}
function instanceOfUpdateCoinRequest$1(value) {
  let isInstance = true;
  return isInstance;
}
function UpdateCoinRequestFromJSON$1(json) {
  return UpdateCoinRequestFromJSONTyped$1(json);
}
function UpdateCoinRequestFromJSONTyped$1(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "description": !exists$2(json, "description") ? void 0 : json["description"],
    "link1": !exists$2(json, "link_1") ? void 0 : json["link_1"],
    "link2": !exists$2(json, "link_2") ? void 0 : json["link_2"],
    "link3": !exists$2(json, "link_3") ? void 0 : json["link_3"],
    "link4": !exists$2(json, "link_4") ? void 0 : json["link_4"]
  };
}
function UpdateCoinRequestToJSON$1(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "description": value.description,
    "link_1": value.link1,
    "link_2": value.link2,
    "link_3": value.link3,
    "link_4": value.link4
  };
}
function instanceOfUpdateCoinResponse$1(value) {
  let isInstance = true;
  return isInstance;
}
function UpdateCoinResponseFromJSON$1(json) {
  return UpdateCoinResponseFromJSONTyped$1(json);
}
function UpdateCoinResponseFromJSONTyped$1(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "success": !exists$2(json, "success") ? void 0 : json["success"]
  };
}
function UpdateCoinResponseToJSON$1(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "success": value.success
  };
}
function instanceOfUserCoin(value) {
  let isInstance = true;
  isInstance = isInstance && "mint" in value && value["mint"] !== void 0;
  isInstance = isInstance && "ticker" in value && value["ticker"] !== void 0;
  isInstance = isInstance && "decimals" in value && value["decimals"] !== void 0;
  isInstance = isInstance && "ownerId" in value && value["ownerId"] !== void 0;
  isInstance = isInstance && "hasDiscord" in value && value["hasDiscord"] !== void 0;
  isInstance = isInstance && "balance" in value && value["balance"] !== void 0;
  isInstance = isInstance && "balanceUsd" in value && value["balanceUsd"] !== void 0;
  return isInstance;
}
function UserCoinFromJSON(json) {
  return UserCoinFromJSONTyped(json);
}
function UserCoinFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "mint": json["mint"],
    "ticker": json["ticker"],
    "decimals": json["decimals"],
    "ownerId": json["owner_id"],
    "hasDiscord": json["has_discord"],
    "balance": json["balance"],
    "balanceUsd": json["balance_usd"]
  };
}
function UserCoinToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "mint": value.mint,
    "ticker": value.ticker,
    "decimals": value.decimals,
    "owner_id": value.ownerId,
    "has_discord": value.hasDiscord,
    "balance": value.balance,
    "balance_usd": value.balanceUsd
  };
}
function instanceOfUserCoinAccount(value) {
  let isInstance = true;
  isInstance = isInstance && "account" in value && value["account"] !== void 0;
  isInstance = isInstance && "owner" in value && value["owner"] !== void 0;
  isInstance = isInstance && "balance" in value && value["balance"] !== void 0;
  isInstance = isInstance && "balanceUsd" in value && value["balanceUsd"] !== void 0;
  isInstance = isInstance && "isInAppWallet" in value && value["isInAppWallet"] !== void 0;
  return isInstance;
}
function UserCoinAccountFromJSON(json) {
  return UserCoinAccountFromJSONTyped(json);
}
function UserCoinAccountFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "account": json["account"],
    "owner": json["owner"],
    "balance": json["balance"],
    "balanceUsd": json["balance_usd"],
    "isInAppWallet": json["is_in_app_wallet"]
  };
}
function UserCoinAccountToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "account": value.account,
    "owner": value.owner,
    "balance": value.balance,
    "balance_usd": value.balanceUsd,
    "is_in_app_wallet": value.isInAppWallet
  };
}
function instanceOfUserCoinWithAccounts(value) {
  let isInstance = true;
  isInstance = isInstance && "mint" in value && value["mint"] !== void 0;
  isInstance = isInstance && "ticker" in value && value["ticker"] !== void 0;
  isInstance = isInstance && "decimals" in value && value["decimals"] !== void 0;
  isInstance = isInstance && "balance" in value && value["balance"] !== void 0;
  isInstance = isInstance && "balanceUsd" in value && value["balanceUsd"] !== void 0;
  isInstance = isInstance && "accounts" in value && value["accounts"] !== void 0;
  return isInstance;
}
function UserCoinWithAccountsFromJSON(json) {
  return UserCoinWithAccountsFromJSONTyped(json);
}
function UserCoinWithAccountsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "mint": json["mint"],
    "ticker": json["ticker"],
    "decimals": json["decimals"],
    "balance": json["balance"],
    "balanceUsd": json["balance_usd"],
    "accounts": json["accounts"].map(UserCoinAccountFromJSON)
  };
}
function UserCoinWithAccountsToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "mint": value.mint,
    "ticker": value.ticker,
    "decimals": value.decimals,
    "balance": value.balance,
    "balance_usd": value.balanceUsd,
    "accounts": value.accounts.map(UserCoinAccountToJSON)
  };
}
function instanceOfUserCoinResponse(value) {
  let isInstance = true;
  return isInstance;
}
function UserCoinResponseFromJSON(json) {
  return UserCoinResponseFromJSONTyped(json);
}
function UserCoinResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "data": !exists$2(json, "data") ? void 0 : UserCoinWithAccountsFromJSON(json["data"])
  };
}
function UserCoinResponseToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "data": UserCoinWithAccountsToJSON(value.data)
  };
}
function instanceOfUserCoinsResponse(value) {
  let isInstance = true;
  isInstance = isInstance && "data" in value && value["data"] !== void 0;
  return isInstance;
}
function UserCoinsResponseFromJSON(json) {
  return UserCoinsResponseFromJSONTyped(json);
}
function UserCoinsResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "data": json["data"].map(UserCoinFromJSON)
  };
}
function UserCoinsResponseToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "data": value.data.map(UserCoinToJSON)
  };
}
function instanceOfUserCommentsResponse(value) {
  let isInstance = true;
  return isInstance;
}
function UserCommentsResponseFromJSON(json) {
  return UserCommentsResponseFromJSONTyped(json);
}
function UserCommentsResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "data": !exists$2(json, "data") ? void 0 : json["data"].map(CommentFromJSON$1)
  };
}
function UserCommentsResponseToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "data": value.data === void 0 ? void 0 : value.data.map(CommentToJSON$1)
  };
}
function instanceOfUserIdAddress(value) {
  let isInstance = true;
  isInstance = isInstance && "userId" in value && value["userId"] !== void 0;
  isInstance = isInstance && "address" in value && value["address"] !== void 0;
  return isInstance;
}
function UserIdAddressFromJSON(json) {
  return UserIdAddressFromJSONTyped(json);
}
function UserIdAddressFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "userId": json["user_id"],
    "address": json["address"]
  };
}
function UserIdAddressToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "user_id": value.userId,
    "address": value.address
  };
}
function instanceOfUserIdsAddressesResponse(value) {
  let isInstance = true;
  return isInstance;
}
function UserIdsAddressesResponseFromJSON(json) {
  return UserIdsAddressesResponseFromJSONTyped(json);
}
function UserIdsAddressesResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "data": !exists$2(json, "data") ? void 0 : json["data"].map(UserIdAddressFromJSON)
  };
}
function UserIdsAddressesResponseToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "data": value.data === void 0 ? void 0 : value.data.map(UserIdAddressToJSON)
  };
}
function instanceOfUserResponse(value) {
  let isInstance = true;
  return isInstance;
}
function UserResponseFromJSON(json) {
  return UserResponseFromJSONTyped(json);
}
function UserResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "data": !exists$2(json, "data") ? void 0 : UserFromJSON(json["data"])
  };
}
function UserResponseToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "data": UserToJSON(value.data)
  };
}
function instanceOfUserSearch(value) {
  let isInstance = true;
  return isInstance;
}
function UserSearchFromJSON(json) {
  return UserSearchFromJSONTyped(json);
}
function UserSearchFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "data": !exists$2(json, "data") ? void 0 : json["data"].map(UserFromJSON)
  };
}
function UserSearchToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "data": value.data === void 0 ? void 0 : value.data.map(UserToJSON)
  };
}
function instanceOfUserTrackListenCountsResponse(value) {
  let isInstance = true;
  return isInstance;
}
function UserTrackListenCountsResponseFromJSON(json) {
  return UserTrackListenCountsResponseFromJSONTyped(json);
}
function UserTrackListenCountsResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "data": !exists$2(json, "data") ? void 0 : mapValues$1(json["data"], MonthlyAggregatePlayFromJSON)
  };
}
function UserTrackListenCountsResponseToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "data": value.data === void 0 ? void 0 : mapValues$1(value.data, MonthlyAggregatePlayToJSON)
  };
}
function instanceOfUserTracksRemixedResponse(value) {
  let isInstance = true;
  return isInstance;
}
function UserTracksRemixedResponseFromJSON(json) {
  return UserTracksRemixedResponseFromJSONTyped(json);
}
function UserTracksRemixedResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "data": !exists$2(json, "data") ? void 0 : json["data"].map(RemixedTrackAggregateFromJSON)
  };
}
function UserTracksRemixedResponseToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "data": value.data === void 0 ? void 0 : value.data.map(RemixedTrackAggregateToJSON)
  };
}
function instanceOfUsersResponse(value) {
  let isInstance = true;
  return isInstance;
}
function UsersResponseFromJSON(json) {
  return UsersResponseFromJSONTyped(json);
}
function UsersResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "data": !exists$2(json, "data") ? void 0 : json["data"].map(UserFromJSON)
  };
}
function UsersResponseToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "data": value.data === void 0 ? void 0 : value.data.map(UserToJSON)
  };
}
function instanceOfVerifyToken(value) {
  let isInstance = true;
  return isInstance;
}
function VerifyTokenFromJSON(json) {
  return VerifyTokenFromJSONTyped(json);
}
function VerifyTokenFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "data": !exists$2(json, "data") ? void 0 : DecodedUserTokenFromJSON(json["data"])
  };
}
function VerifyTokenToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "data": DecodedUserTokenToJSON(value.data)
  };
}
var ChallengesApi$1 = class extends BaseAPI$1 {
  /**
   * @hidden
   * Get all undisbursed challenges
   */
  async getUndisbursedChallengesRaw(params, initOverrides) {
    const queryParameters = {};
    if (params.offset !== void 0) {
      queryParameters["offset"] = params.offset;
    }
    if (params.limit !== void 0) {
      queryParameters["limit"] = params.limit;
    }
    if (params.userId !== void 0) {
      queryParameters["user_id"] = params.userId;
    }
    if (params.completedBlocknumber !== void 0) {
      queryParameters["completed_blocknumber"] = params.completedBlocknumber;
    }
    if (params.challengeId !== void 0) {
      queryParameters["challenge_id"] = params.challengeId;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/challenges/undisbursed`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, (jsonValue) => UndisbursedChallengesFromJSON(jsonValue));
  }
  /**
   * Get all undisbursed challenges
   */
  async getUndisbursedChallenges() {
    let params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let initOverrides = arguments.length > 1 ? arguments[1] : void 0;
    const response = await this.getUndisbursedChallengesRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Get all undisbursed challenges for a user
   */
  async getUndisbursedChallengesForUserRaw(params, initOverrides) {
    if (params.userId === null || params.userId === void 0) {
      throw new RequiredError$1("userId", "Required parameter params.userId was null or undefined when calling getUndisbursedChallengesForUser.");
    }
    const queryParameters = {};
    if (params.offset !== void 0) {
      queryParameters["offset"] = params.offset;
    }
    if (params.limit !== void 0) {
      queryParameters["limit"] = params.limit;
    }
    if (params.completedBlocknumber !== void 0) {
      queryParameters["completed_blocknumber"] = params.completedBlocknumber;
    }
    if (params.challengeId !== void 0) {
      queryParameters["challenge_id"] = params.challengeId;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/challenges/undisbursed/{user_id}`.replace(`{${"user_id"}}`, encodeURIComponent(String(params.userId))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, (jsonValue) => UndisbursedChallengesFromJSON(jsonValue));
  }
  /**
   * Get all undisbursed challenges for a user
   */
  async getUndisbursedChallengesForUser(params, initOverrides) {
    const response = await this.getUndisbursedChallengesForUserRaw(params, initOverrides);
    return await response.value();
  }
};
var CoinsApi$1 = class extends BaseAPI$1 {
  /**
   * @hidden
   * Creates a new artist coin
   */
  async createCoinRaw(params, initOverrides) {
    if (params.userId === null || params.userId === void 0) {
      throw new RequiredError$1("userId", "Required parameter params.userId was null or undefined when calling createCoin.");
    }
    if (params.createCoinRequest === null || params.createCoinRequest === void 0) {
      throw new RequiredError$1("createCoinRequest", "Required parameter params.createCoinRequest was null or undefined when calling createCoin.");
    }
    const queryParameters = {};
    if (params.userId !== void 0) {
      queryParameters["user_id"] = params.userId;
    }
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/coins`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: CreateCoinRequestToJSON$1(params.createCoinRequest)
    }, initOverrides);
    return new JSONApiResponse$1(response, (jsonValue) => CreateCoinResponseFromJSON$1(jsonValue));
  }
  /**
   * Creates a new artist coin
   */
  async createCoin(params, initOverrides) {
    const response = await this.createCoinRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets information about a specific coin by its mint address
   */
  async getCoinRaw(params, initOverrides) {
    if (params.mint === null || params.mint === void 0) {
      throw new RequiredError$1("mint", "Required parameter params.mint was null or undefined when calling getCoin.");
    }
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/coins/{mint}`.replace(`{${"mint"}}`, encodeURIComponent(String(params.mint))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, (jsonValue) => CoinResponseFromJSON$1(jsonValue));
  }
  /**
   * Gets information about a specific coin by its mint address
   */
  async getCoin(params, initOverrides) {
    const response = await this.getCoinRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets information about a specific coin by its ticker
   */
  async getCoinByTickerRaw(params, initOverrides) {
    if (params.ticker === null || params.ticker === void 0) {
      throw new RequiredError$1("ticker", "Required parameter params.ticker was null or undefined when calling getCoinByTicker.");
    }
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/coins/ticker/{ticker}`.replace(`{${"ticker"}}`, encodeURIComponent(String(params.ticker))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, (jsonValue) => CoinResponseFromJSON$1(jsonValue));
  }
  /**
   * Gets information about a specific coin by its ticker
   */
  async getCoinByTicker(params, initOverrides) {
    const response = await this.getCoinByTickerRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets insights about a specific coin by its mint address
   */
  async getCoinInsightsRaw(params, initOverrides) {
    if (params.mint === null || params.mint === void 0) {
      throw new RequiredError$1("mint", "Required parameter params.mint was null or undefined when calling getCoinInsights.");
    }
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/coins/{mint}/insights`.replace(`{${"mint"}}`, encodeURIComponent(String(params.mint))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, (jsonValue) => CoinInsightsResponseFromJSON(jsonValue));
  }
  /**
   * Gets insights about a specific coin by its mint address
   */
  async getCoinInsights(params, initOverrides) {
    const response = await this.getCoinInsightsRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets a list of Audius users with a non-zero balance of a specific coin
   */
  async getCoinMembersRaw(params, initOverrides) {
    if (params.mint === null || params.mint === void 0) {
      throw new RequiredError$1("mint", "Required parameter params.mint was null or undefined when calling getCoinMembers.");
    }
    const queryParameters = {};
    if (params.offset !== void 0) {
      queryParameters["offset"] = params.offset;
    }
    if (params.limit !== void 0) {
      queryParameters["limit"] = params.limit;
    }
    if (params.sortDirection !== void 0) {
      queryParameters["sort_direction"] = params.sortDirection;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/coins/{mint}/members`.replace(`{${"mint"}}`, encodeURIComponent(String(params.mint))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, (jsonValue) => CoinMembersResponseFromJSON(jsonValue));
  }
  /**
   * Gets a list of Audius users with a non-zero balance of a specific coin
   */
  async getCoinMembers(params, initOverrides) {
    const response = await this.getCoinMembersRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets information about coins
   */
  async getCoinsRaw(params, initOverrides) {
    const queryParameters = {};
    if (params.mint) {
      queryParameters["mint"] = params.mint;
    }
    if (params.ownerId) {
      queryParameters["owner_id"] = params.ownerId;
    }
    if (params.ticker) {
      queryParameters["ticker"] = params.ticker;
    }
    if (params.query !== void 0) {
      queryParameters["query"] = params.query;
    }
    if (params.offset !== void 0) {
      queryParameters["offset"] = params.offset;
    }
    if (params.limit !== void 0) {
      queryParameters["limit"] = params.limit;
    }
    if (params.sortMethod !== void 0) {
      queryParameters["sort_method"] = params.sortMethod;
    }
    if (params.sortDirection !== void 0) {
      queryParameters["sort_direction"] = params.sortDirection;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/coins`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, (jsonValue) => CoinsResponseFromJSON$1(jsonValue));
  }
  /**
   * Gets information about coins
   */
  async getCoins() {
    let params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let initOverrides = arguments.length > 1 ? arguments[1] : void 0;
    const response = await this.getCoinsRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Updates information about a specific coin by its mint address
   */
  async updateCoinRaw(params, initOverrides) {
    if (params.mint === null || params.mint === void 0) {
      throw new RequiredError$1("mint", "Required parameter params.mint was null or undefined when calling updateCoin.");
    }
    if (params.userId === null || params.userId === void 0) {
      throw new RequiredError$1("userId", "Required parameter params.userId was null or undefined when calling updateCoin.");
    }
    if (params.updateCoinRequest === null || params.updateCoinRequest === void 0) {
      throw new RequiredError$1("updateCoinRequest", "Required parameter params.updateCoinRequest was null or undefined when calling updateCoin.");
    }
    const queryParameters = {};
    if (params.userId !== void 0) {
      queryParameters["user_id"] = params.userId;
    }
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/coins/{mint}`.replace(`{${"mint"}}`, encodeURIComponent(String(params.mint))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: UpdateCoinRequestToJSON$1(params.updateCoinRequest)
    }, initOverrides);
    return new JSONApiResponse$1(response, (jsonValue) => UpdateCoinResponseFromJSON$1(jsonValue));
  }
  /**
   * Updates information about a specific coin by its mint address
   */
  async updateCoin(params, initOverrides) {
    const response = await this.updateCoinRaw(params, initOverrides);
    return await response.value();
  }
};
var GetCoinMembersSortDirectionEnum = {
  Asc: "asc",
  Desc: "desc"
};
var GetCoinsSortMethodEnum$1 = {
  MarketCap: "market_cap",
  Volume: "volume",
  Price: "price",
  CreatedAt: "created_at",
  Holder: "holder"
};
var GetCoinsSortDirectionEnum$1 = {
  Asc: "asc",
  Desc: "desc"
};
var CommentsApi$2 = class extends BaseAPI$1 {
  /**
   * @hidden
   * Gets a comment by ID
   */
  async getCommentRaw(params, initOverrides) {
    if (params.commentId === null || params.commentId === void 0) {
      throw new RequiredError$1("commentId", "Required parameter params.commentId was null or undefined when calling getComment.");
    }
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/comments/{comment_id}`.replace(`{${"comment_id"}}`, encodeURIComponent(String(params.commentId))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, (jsonValue) => CommentResponseFromJSON$1(jsonValue));
  }
  /**
   * Gets a comment by ID
   */
  async getComment(params, initOverrides) {
    const response = await this.getCommentRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets replies to a parent comment
   */
  async getCommentRepliesRaw(params, initOverrides) {
    if (params.commentId === null || params.commentId === void 0) {
      throw new RequiredError$1("commentId", "Required parameter params.commentId was null or undefined when calling getCommentReplies.");
    }
    const queryParameters = {};
    if (params.offset !== void 0) {
      queryParameters["offset"] = params.offset;
    }
    if (params.limit !== void 0) {
      queryParameters["limit"] = params.limit;
    }
    if (params.userId !== void 0) {
      queryParameters["user_id"] = params.userId;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/comments/{comment_id}/replies`.replace(`{${"comment_id"}}`, encodeURIComponent(String(params.commentId))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, (jsonValue) => CommentRepliesResponseFromJSON$1(jsonValue));
  }
  /**
   * Gets replies to a parent comment
   */
  async getCommentReplies(params, initOverrides) {
    const response = await this.getCommentRepliesRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets an unclaimed blockchain comment ID
   */
  async getUnclaimedCommentIDRaw(initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/comments/unclaimed_id`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, (jsonValue) => UnclaimedIdResponseFromJSON(jsonValue));
  }
  /**
   * Gets an unclaimed blockchain comment ID
   */
  async getUnclaimedCommentID(initOverrides) {
    const response = await this.getUnclaimedCommentIDRaw(initOverrides);
    return await response.value();
  }
};
var DashboardWalletUsersApi$1 = class extends BaseAPI$1 {
  /**
   * @hidden
   * Gets Audius user profiles connected to given dashboard wallet addresses
   */
  async bulkGetDashboardWalletUsersRaw(params, initOverrides) {
    if (params.wallets === null || params.wallets === void 0) {
      throw new RequiredError$1("wallets", "Required parameter params.wallets was null or undefined when calling bulkGetDashboardWalletUsers.");
    }
    const queryParameters = {};
    if (params.wallets) {
      queryParameters["wallets"] = params.wallets.join(COLLECTION_FORMATS$1["csv"]);
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/dashboard_wallet_users`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, (jsonValue) => DashboardWalletUsersResponseFromJSON(jsonValue));
  }
  /**
   * Gets Audius user profiles connected to given dashboard wallet addresses
   */
  async bulkGetDashboardWalletUsers(params, initOverrides) {
    const response = await this.bulkGetDashboardWalletUsersRaw(params, initOverrides);
    return await response.value();
  }
};
var DeveloperAppsApi$1 = class extends BaseAPI$1 {
  /**
   * @hidden
   * Gets developer app matching given address (API key)
   */
  async getDeveloperAppRaw(params, initOverrides) {
    if (params.address === null || params.address === void 0) {
      throw new RequiredError$1("address", "Required parameter params.address was null or undefined when calling getDeveloperApp.");
    }
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/developer_apps/{address}`.replace(`{${"address"}}`, encodeURIComponent(String(params.address))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, (jsonValue) => DeveloperAppResponseFromJSON(jsonValue));
  }
  /**
   * Gets developer app matching given address (API key)
   */
  async getDeveloperApp(params, initOverrides) {
    const response = await this.getDeveloperAppRaw(params, initOverrides);
    return await response.value();
  }
};
var EventsApi$1 = class extends BaseAPI$1 {
  /**
   * @hidden
   * Get all events
   * Get all events
   */
  async getAllEventsRaw(params, initOverrides) {
    const queryParameters = {};
    if (params.offset !== void 0) {
      queryParameters["offset"] = params.offset;
    }
    if (params.limit !== void 0) {
      queryParameters["limit"] = params.limit;
    }
    if (params.userId !== void 0) {
      queryParameters["user_id"] = params.userId;
    }
    if (params.sortMethod !== void 0) {
      queryParameters["sort_method"] = params.sortMethod;
    }
    if (params.eventType !== void 0) {
      queryParameters["event_type"] = params.eventType;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/events/all`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, (jsonValue) => EventsResponseFromJSON(jsonValue));
  }
  /**
   * Get all events
   * Get all events
   */
  async getAllEvents() {
    let params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let initOverrides = arguments.length > 1 ? arguments[1] : void 0;
    const response = await this.getAllEventsRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Get a list of events by ID
   */
  async getBulkEventsRaw(params, initOverrides) {
    const queryParameters = {};
    if (params.userId !== void 0) {
      queryParameters["user_id"] = params.userId;
    }
    if (params.id) {
      queryParameters["id"] = params.id;
    }
    if (params.eventType !== void 0) {
      queryParameters["event_type"] = params.eventType;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/events`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, (jsonValue) => EventsResponseFromJSON(jsonValue));
  }
  /**
   * Get a list of events by ID
   */
  async getBulkEvents() {
    let params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let initOverrides = arguments.length > 1 ? arguments[1] : void 0;
    const response = await this.getBulkEventsRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Get events for a specific entity
   * Get events for a specific entity
   */
  async getEntityEventsRaw(params, initOverrides) {
    if (params.entityId === null || params.entityId === void 0) {
      throw new RequiredError$1("entityId", "Required parameter params.entityId was null or undefined when calling getEntityEvents.");
    }
    const queryParameters = {};
    if (params.offset !== void 0) {
      queryParameters["offset"] = params.offset;
    }
    if (params.limit !== void 0) {
      queryParameters["limit"] = params.limit;
    }
    if (params.userId !== void 0) {
      queryParameters["user_id"] = params.userId;
    }
    if (params.entityId) {
      queryParameters["entity_id"] = params.entityId;
    }
    if (params.entityType !== void 0) {
      queryParameters["entity_type"] = params.entityType;
    }
    if (params.filterDeleted !== void 0) {
      queryParameters["filter_deleted"] = params.filterDeleted;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/events/entity`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, (jsonValue) => EventsResponseFromJSON(jsonValue));
  }
  /**
   * Get events for a specific entity
   * Get events for a specific entity
   */
  async getEntityEvents(params, initOverrides) {
    const response = await this.getEntityEventsRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets an unclaimed blockchain event ID
   */
  async getUnclaimedEventIDRaw(initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/events/unclaimed_id`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, (jsonValue) => UnclaimedIdResponseFromJSON(jsonValue));
  }
  /**
   * Gets an unclaimed blockchain event ID
   */
  async getUnclaimedEventID(initOverrides) {
    const response = await this.getUnclaimedEventIDRaw(initOverrides);
    return await response.value();
  }
};
var GetAllEventsSortMethodEnum = {
  Newest: "newest",
  Timestamp: "timestamp"
};
var GetAllEventsEventTypeEnum = {
  RemixContest: "remix_contest",
  LiveEvent: "live_event",
  NewRelease: "new_release"
};
var GetBulkEventsEventTypeEnum = {
  RemixContest: "remix_contest",
  LiveEvent: "live_event",
  NewRelease: "new_release"
};
var GetEntityEventsEntityTypeEnum = {
  Track: "track",
  Collection: "collection",
  User: "user"
};
var ExploreApi$1 = class extends BaseAPI$1 {
  /**
   * @hidden
   * Get best selling tracks and playlists
   * Get best selling tracks and/or albums
   */
  async getBestSellingRaw(params, initOverrides) {
    const queryParameters = {};
    if (params.offset !== void 0) {
      queryParameters["offset"] = params.offset;
    }
    if (params.limit !== void 0) {
      queryParameters["limit"] = params.limit;
    }
    if (params.userId !== void 0) {
      queryParameters["user_id"] = params.userId;
    }
    if (params.type !== void 0) {
      queryParameters["type"] = params.type;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/explore/best-selling`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, (jsonValue) => BestSellingResponseFromJSON(jsonValue));
  }
  /**
   * Get best selling tracks and playlists
   * Get best selling tracks and/or albums
   */
  async getBestSelling() {
    let params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let initOverrides = arguments.length > 1 ? arguments[1] : void 0;
    const response = await this.getBestSellingRaw(params, initOverrides);
    return await response.value();
  }
};
var GetBestSellingTypeEnum = {
  All: "all",
  Track: "track",
  Album: "album"
};
var PlaylistsApi$2 = class extends BaseAPI$1 {
  /**
   * @hidden
   * Gets a list of playlists by ID
   */
  async getBulkPlaylistsRaw(params, initOverrides) {
    const queryParameters = {};
    if (params.userId !== void 0) {
      queryParameters["user_id"] = params.userId;
    }
    if (params.id) {
      queryParameters["id"] = params.id;
    }
    if (params.upc) {
      queryParameters["upc"] = params.upc;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/playlists`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, (jsonValue) => PlaylistResponseFromJSON(jsonValue));
  }
  /**
   * Gets a list of playlists by ID
   */
  async getBulkPlaylists() {
    let params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let initOverrides = arguments.length > 1 ? arguments[1] : void 0;
    const response = await this.getBulkPlaylistsRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Get a playlist by ID
   */
  async getPlaylistRaw(params, initOverrides) {
    if (params.playlistId === null || params.playlistId === void 0) {
      throw new RequiredError$1("playlistId", "Required parameter params.playlistId was null or undefined when calling getPlaylist.");
    }
    const queryParameters = {};
    if (params.userId !== void 0) {
      queryParameters["user_id"] = params.userId;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/playlists/{playlist_id}`.replace(`{${"playlist_id"}}`, encodeURIComponent(String(params.playlistId))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, (jsonValue) => PlaylistResponseFromJSON(jsonValue));
  }
  /**
   * Get a playlist by ID
   */
  async getPlaylist(params, initOverrides) {
    const response = await this.getPlaylistRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets the information necessary to access the playlist and what access the given user has.
   */
  async getPlaylistAccessInfoRaw(params, initOverrides) {
    if (params.playlistId === null || params.playlistId === void 0) {
      throw new RequiredError$1("playlistId", "Required parameter params.playlistId was null or undefined when calling getPlaylistAccessInfo.");
    }
    const queryParameters = {};
    if (params.userId !== void 0) {
      queryParameters["user_id"] = params.userId;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/playlists/{playlist_id}/access-info`.replace(`{${"playlist_id"}}`, encodeURIComponent(String(params.playlistId))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, (jsonValue) => AccessInfoResponseFromJSON(jsonValue));
  }
  /**
   * Gets the information necessary to access the playlist and what access the given user has.
   */
  async getPlaylistAccessInfo(params, initOverrides) {
    const response = await this.getPlaylistAccessInfoRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Get a playlist by handle and slug
   */
  async getPlaylistByHandleAndSlugRaw(params, initOverrides) {
    if (params.handle === null || params.handle === void 0) {
      throw new RequiredError$1("handle", "Required parameter params.handle was null or undefined when calling getPlaylistByHandleAndSlug.");
    }
    if (params.slug === null || params.slug === void 0) {
      throw new RequiredError$1("slug", "Required parameter params.slug was null or undefined when calling getPlaylistByHandleAndSlug.");
    }
    const queryParameters = {};
    if (params.userId !== void 0) {
      queryParameters["user_id"] = params.userId;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/playlists/by_permalink/{handle}/{slug}`.replace(`{${"handle"}}`, encodeURIComponent(String(params.handle))).replace(`{${"slug"}}`, encodeURIComponent(String(params.slug))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, (jsonValue) => PlaylistResponseFromJSON(jsonValue));
  }
  /**
   * Get a playlist by handle and slug
   */
  async getPlaylistByHandleAndSlug(params, initOverrides) {
    const response = await this.getPlaylistByHandleAndSlugRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Fetch tracks within a playlist.
   */
  async getPlaylistTracksRaw(params, initOverrides) {
    if (params.playlistId === null || params.playlistId === void 0) {
      throw new RequiredError$1("playlistId", "Required parameter params.playlistId was null or undefined when calling getPlaylistTracks.");
    }
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/playlists/{playlist_id}/tracks`.replace(`{${"playlist_id"}}`, encodeURIComponent(String(params.playlistId))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, (jsonValue) => PlaylistTracksResponseFromJSON(jsonValue));
  }
  /**
   * Fetch tracks within a playlist.
   */
  async getPlaylistTracks(params, initOverrides) {
    const response = await this.getPlaylistTracksRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets trending playlists for a time period
   */
  async getTrendingPlaylistsRaw(params, initOverrides) {
    const queryParameters = {};
    if (params.offset !== void 0) {
      queryParameters["offset"] = params.offset;
    }
    if (params.limit !== void 0) {
      queryParameters["limit"] = params.limit;
    }
    if (params.time !== void 0) {
      queryParameters["time"] = params.time;
    }
    if (params.type !== void 0) {
      queryParameters["type"] = params.type;
    }
    if (params.omitTracks !== void 0) {
      queryParameters["omit_tracks"] = params.omitTracks;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/playlists/trending`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, (jsonValue) => TrendingPlaylistsResponseFromJSON(jsonValue));
  }
  /**
   * Gets trending playlists for a time period
   */
  async getTrendingPlaylists() {
    let params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let initOverrides = arguments.length > 1 ? arguments[1] : void 0;
    const response = await this.getTrendingPlaylistsRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Search for a playlist
   */
  async searchPlaylistsRaw(params, initOverrides) {
    const queryParameters = {};
    if (params.offset !== void 0) {
      queryParameters["offset"] = params.offset;
    }
    if (params.limit !== void 0) {
      queryParameters["limit"] = params.limit;
    }
    if (params.query !== void 0) {
      queryParameters["query"] = params.query;
    }
    if (params.genre) {
      queryParameters["genre"] = params.genre;
    }
    if (params.sortMethod !== void 0) {
      queryParameters["sort_method"] = params.sortMethod;
    }
    if (params.mood) {
      queryParameters["mood"] = params.mood;
    }
    if (params.includePurchaseable !== void 0) {
      queryParameters["includePurchaseable"] = params.includePurchaseable;
    }
    if (params.hasDownloads !== void 0) {
      queryParameters["has_downloads"] = params.hasDownloads;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/playlists/search`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, (jsonValue) => PlaylistSearchResultFromJSON(jsonValue));
  }
  /**
   * Search for a playlist
   */
  async searchPlaylists() {
    let params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let initOverrides = arguments.length > 1 ? arguments[1] : void 0;
    const response = await this.searchPlaylistsRaw(params, initOverrides);
    return await response.value();
  }
};
var GetTrendingPlaylistsTimeEnum$1 = {
  Week: "week",
  Month: "month",
  Year: "year",
  AllTime: "allTime"
};
var GetTrendingPlaylistsTypeEnum$1 = {
  Playlist: "playlist",
  Album: "album"
};
var SearchPlaylistsSortMethodEnum = {
  Relevant: "relevant",
  Popular: "popular",
  Recent: "recent"
};
var RewardsApi = class extends BaseAPI$1 {
  /**
   * @hidden
   * Claims all the filtered undisbursed rewards for a user
   */
  async claimRewardsRaw(params, initOverrides) {
    if (params.claimRewardsRequest === null || params.claimRewardsRequest === void 0) {
      throw new RequiredError$1("claimRewardsRequest", "Required parameter params.claimRewardsRequest was null or undefined when calling claimRewards.");
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/rewards/claim`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: ClaimRewardsRequestToJSON(params.claimRewardsRequest)
    }, initOverrides);
    return new JSONApiResponse$1(response, (jsonValue) => ClaimRewardsResponseFromJSON(jsonValue));
  }
  /**
   * Claims all the filtered undisbursed rewards for a user
   */
  async claimRewards(params, initOverrides) {
    const response = await this.claimRewardsRaw(params, initOverrides);
    return await response.value();
  }
};
var TipsApi$1 = class extends BaseAPI$1 {
  /**
   * @hidden
   * Gets the most recent tips on the network
   */
  async getTipsRaw(params, initOverrides) {
    const queryParameters = {};
    if (params.offset !== void 0) {
      queryParameters["offset"] = params.offset;
    }
    if (params.limit !== void 0) {
      queryParameters["limit"] = params.limit;
    }
    if (params.userId !== void 0) {
      queryParameters["user_id"] = params.userId;
    }
    if (params.receiverMinFollowers !== void 0) {
      queryParameters["receiver_min_followers"] = params.receiverMinFollowers;
    }
    if (params.receiverIsVerified !== void 0) {
      queryParameters["receiver_is_verified"] = params.receiverIsVerified;
    }
    if (params.currentUserFollows !== void 0) {
      queryParameters["current_user_follows"] = params.currentUserFollows;
    }
    if (params.uniqueBy !== void 0) {
      queryParameters["unique_by"] = params.uniqueBy;
    }
    if (params.minSlot !== void 0) {
      queryParameters["min_slot"] = params.minSlot;
    }
    if (params.maxSlot !== void 0) {
      queryParameters["max_slot"] = params.maxSlot;
    }
    if (params.txSignatures) {
      queryParameters["tx_signatures"] = params.txSignatures.join(COLLECTION_FORMATS$1["csv"]);
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/tips`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, (jsonValue) => GetTipsResponseFromJSON$1(jsonValue));
  }
  /**
   * Gets the most recent tips on the network
   */
  async getTips() {
    let params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let initOverrides = arguments.length > 1 ? arguments[1] : void 0;
    const response = await this.getTipsRaw(params, initOverrides);
    return await response.value();
  }
};
var GetTipsCurrentUserFollowsEnum$1 = {
  Sender: "sender",
  Receiver: "receiver",
  SenderOrReceiver: "sender_or_receiver"
};
var GetTipsUniqueByEnum$1 = {
  Sender: "sender",
  Receiver: "receiver"
};
var TracksApi$2 = class extends BaseAPI$1 {
  /**
   * @hidden
   * Download an original or mp3 track
   * Download the original or MP3 file of a track
   */
  async downloadTrackRaw(params, initOverrides) {
    if (params.trackId === null || params.trackId === void 0) {
      throw new RequiredError$1("trackId", "Required parameter params.trackId was null or undefined when calling downloadTrack.");
    }
    const queryParameters = {};
    if (params.userId !== void 0) {
      queryParameters["user_id"] = params.userId;
    }
    if (params.userSignature !== void 0) {
      queryParameters["user_signature"] = params.userSignature;
    }
    if (params.userData !== void 0) {
      queryParameters["user_data"] = params.userData;
    }
    if (params.nftAccessSignature !== void 0) {
      queryParameters["nft_access_signature"] = params.nftAccessSignature;
    }
    if (params.filename !== void 0) {
      queryParameters["filename"] = params.filename;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/tracks/{track_id}/download`.replace(`{${"track_id"}}`, encodeURIComponent(String(params.trackId))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new VoidApiResponse$1(response);
  }
  /**
   * Download an original or mp3 track
   * Download the original or MP3 file of a track
   */
  async downloadTrack(params, initOverrides) {
    await this.downloadTrackRaw(params, initOverrides);
  }
  /**
   * @hidden
   * Gets a list of tracks using their IDs or permalinks
   */
  async getBulkTracksRaw(params, initOverrides) {
    const queryParameters = {};
    if (params.permalink) {
      queryParameters["permalink"] = params.permalink;
    }
    if (params.id) {
      queryParameters["id"] = params.id;
    }
    if (params.isrc) {
      queryParameters["isrc"] = params.isrc;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/tracks`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, (jsonValue) => TracksResponseFromJSON(jsonValue));
  }
  /**
   * Gets a list of tracks using their IDs or permalinks
   */
  async getBulkTracks() {
    let params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let initOverrides = arguments.length > 1 ? arguments[1] : void 0;
    const response = await this.getBulkTracksRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets random tracks found on the \"Feeling Lucky\" smart playlist
   */
  async getFeelingLuckyTracksRaw(params, initOverrides) {
    const queryParameters = {};
    if (params.userId !== void 0) {
      queryParameters["user_id"] = params.userId;
    }
    if (params.limit !== void 0) {
      queryParameters["limit"] = params.limit;
    }
    if (params.minFollowers !== void 0) {
      queryParameters["min_followers"] = params.minFollowers;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/tracks/feeling-lucky`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, (jsonValue) => TracksResponseFromJSON(jsonValue));
  }
  /**
   * Gets random tracks found on the \"Feeling Lucky\" smart playlist
   */
  async getFeelingLuckyTracks() {
    let params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let initOverrides = arguments.length > 1 ? arguments[1] : void 0;
    const response = await this.getFeelingLuckyTracksRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets the most shared tracks for a given time range
   */
  async getMostSharedTracksRaw(params, initOverrides) {
    const queryParameters = {};
    if (params.userId !== void 0) {
      queryParameters["user_id"] = params.userId;
    }
    if (params.limit !== void 0) {
      queryParameters["limit"] = params.limit;
    }
    if (params.offset !== void 0) {
      queryParameters["offset"] = params.offset;
    }
    if (params.timeRange !== void 0) {
      queryParameters["time_range"] = params.timeRange;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/tracks/most-shared`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, (jsonValue) => TracksResponseFromJSON(jsonValue));
  }
  /**
   * Gets the most shared tracks for a given time range
   */
  async getMostSharedTracks() {
    let params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let initOverrides = arguments.length > 1 ? arguments[1] : void 0;
    const response = await this.getMostSharedTracksRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets the most recently listed premium tracks
   */
  async getRecentPremiumTracksRaw(params, initOverrides) {
    const queryParameters = {};
    if (params.offset !== void 0) {
      queryParameters["offset"] = params.offset;
    }
    if (params.limit !== void 0) {
      queryParameters["limit"] = params.limit;
    }
    if (params.userId !== void 0) {
      queryParameters["user_id"] = params.userId;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/tracks/recent-premium`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, (jsonValue) => TracksResponseFromJSON(jsonValue));
  }
  /**
   * Gets the most recently listed premium tracks
   */
  async getRecentPremiumTracks() {
    let params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let initOverrides = arguments.length > 1 ? arguments[1] : void 0;
    const response = await this.getRecentPremiumTracksRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets a track by ID
   */
  async getTrackRaw(params, initOverrides) {
    if (params.trackId === null || params.trackId === void 0) {
      throw new RequiredError$1("trackId", "Required parameter params.trackId was null or undefined when calling getTrack.");
    }
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/tracks/{track_id}`.replace(`{${"track_id"}}`, encodeURIComponent(String(params.trackId))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, (jsonValue) => TrackResponseFromJSON(jsonValue));
  }
  /**
   * Gets a track by ID
   */
  async getTrack(params, initOverrides) {
    const response = await this.getTrackRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets the information necessary to access the track and what access the given user has.
   */
  async getTrackAccessInfoRaw(params, initOverrides) {
    if (params.trackId === null || params.trackId === void 0) {
      throw new RequiredError$1("trackId", "Required parameter params.trackId was null or undefined when calling getTrackAccessInfo.");
    }
    const queryParameters = {};
    if (params.userId !== void 0) {
      queryParameters["user_id"] = params.userId;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/tracks/{track_id}/access-info`.replace(`{${"track_id"}}`, encodeURIComponent(String(params.trackId))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, (jsonValue) => AccessInfoResponseFromJSON(jsonValue));
  }
  /**
   * Gets the information necessary to access the track and what access the given user has.
   */
  async getTrackAccessInfo(params, initOverrides) {
    const response = await this.getTrackAccessInfoRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Get the comment count for a track
   */
  async getTrackCommentCountRaw(params, initOverrides) {
    if (params.trackId === null || params.trackId === void 0) {
      throw new RequiredError$1("trackId", "Required parameter params.trackId was null or undefined when calling getTrackCommentCount.");
    }
    const queryParameters = {};
    if (params.userId !== void 0) {
      queryParameters["user_id"] = params.userId;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/tracks/{track_id}/comment_count`.replace(`{${"track_id"}}`, encodeURIComponent(String(params.trackId))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, (jsonValue) => TrackCommentCountResponseFromJSON(jsonValue));
  }
  /**
   * Get the comment count for a track
   */
  async getTrackCommentCount(params, initOverrides) {
    const response = await this.getTrackCommentCountRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Get the comment notification setting for a track
   */
  async getTrackCommentNotificationSettingRaw(params, initOverrides) {
    if (params.trackId === null || params.trackId === void 0) {
      throw new RequiredError$1("trackId", "Required parameter params.trackId was null or undefined when calling getTrackCommentNotificationSetting.");
    }
    const queryParameters = {};
    if (params.userId !== void 0) {
      queryParameters["user_id"] = params.userId;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/tracks/{track_id}/comment_notification_setting`.replace(`{${"track_id"}}`, encodeURIComponent(String(params.trackId))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, (jsonValue) => TrackCommentNotificationResponseFromJSON(jsonValue));
  }
  /**
   * Get the comment notification setting for a track
   */
  async getTrackCommentNotificationSetting(params, initOverrides) {
    const response = await this.getTrackCommentNotificationSettingRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Get a list of comments for a track
   */
  async getTrackCommentsRaw(params, initOverrides) {
    if (params.trackId === null || params.trackId === void 0) {
      throw new RequiredError$1("trackId", "Required parameter params.trackId was null or undefined when calling getTrackComments.");
    }
    const queryParameters = {};
    if (params.offset !== void 0) {
      queryParameters["offset"] = params.offset;
    }
    if (params.limit !== void 0) {
      queryParameters["limit"] = params.limit;
    }
    if (params.userId !== void 0) {
      queryParameters["user_id"] = params.userId;
    }
    if (params.sortMethod !== void 0) {
      queryParameters["sort_method"] = params.sortMethod;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/tracks/{track_id}/comments`.replace(`{${"track_id"}}`, encodeURIComponent(String(params.trackId))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, (jsonValue) => TrackCommentsResponseFromJSON(jsonValue));
  }
  /**
   * Get a list of comments for a track
   */
  async getTrackComments(params, initOverrides) {
    const response = await this.getTrackCommentsRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Get the remixable stems of a track
   */
  async getTrackStemsRaw(params, initOverrides) {
    if (params.trackId === null || params.trackId === void 0) {
      throw new RequiredError$1("trackId", "Required parameter params.trackId was null or undefined when calling getTrackStems.");
    }
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/tracks/{track_id}/stems`.replace(`{${"track_id"}}`, encodeURIComponent(String(params.trackId))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, (jsonValue) => StemsResponseFromJSON$1(jsonValue));
  }
  /**
   * Get the remixable stems of a track
   */
  async getTrackStems(params, initOverrides) {
    const response = await this.getTrackStemsRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Get the users that have listened to a track the most
   */
  async getTrackTopListenersRaw(params, initOverrides) {
    if (params.trackId === null || params.trackId === void 0) {
      throw new RequiredError$1("trackId", "Required parameter params.trackId was null or undefined when calling getTrackTopListeners.");
    }
    const queryParameters = {};
    if (params.offset !== void 0) {
      queryParameters["offset"] = params.offset;
    }
    if (params.limit !== void 0) {
      queryParameters["limit"] = params.limit;
    }
    if (params.userId !== void 0) {
      queryParameters["user_id"] = params.userId;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/tracks/{track_id}/top_listeners`.replace(`{${"track_id"}}`, encodeURIComponent(String(params.trackId))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, (jsonValue) => TopListenerFromJSON(jsonValue));
  }
  /**
   * Get the users that have listened to a track the most
   */
  async getTrackTopListeners(params, initOverrides) {
    const response = await this.getTrackTopListenersRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets the most recent tracks with active discussion
   */
  async getTracksWithRecentCommentsRaw(params, initOverrides) {
    const queryParameters = {};
    if (params.userId !== void 0) {
      queryParameters["user_id"] = params.userId;
    }
    if (params.limit !== void 0) {
      queryParameters["limit"] = params.limit;
    }
    if (params.offset !== void 0) {
      queryParameters["offset"] = params.offset;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/tracks/recent-comments`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, (jsonValue) => TracksResponseFromJSON(jsonValue));
  }
  /**
   * Gets the most recent tracks with active discussion
   */
  async getTracksWithRecentComments() {
    let params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let initOverrides = arguments.length > 1 ? arguments[1] : void 0;
    const response = await this.getTracksWithRecentCommentsRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets the top 100 trending (most popular) tracks on Audius
   */
  async getTrendingTracksRaw(params, initOverrides) {
    const queryParameters = {};
    if (params.offset !== void 0) {
      queryParameters["offset"] = params.offset;
    }
    if (params.limit !== void 0) {
      queryParameters["limit"] = params.limit;
    }
    if (params.genre !== void 0) {
      queryParameters["genre"] = params.genre;
    }
    if (params.time !== void 0) {
      queryParameters["time"] = params.time;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/tracks/trending`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, (jsonValue) => TracksResponseFromJSON(jsonValue));
  }
  /**
   * Gets the top 100 trending (most popular) tracks on Audius
   */
  async getTrendingTracks() {
    let params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let initOverrides = arguments.length > 1 ? arguments[1] : void 0;
    const response = await this.getTrendingTracksRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets the top 100 trending underground tracks on Audius
   */
  async getUndergroundTrendingTracksRaw(params, initOverrides) {
    const queryParameters = {};
    if (params.offset !== void 0) {
      queryParameters["offset"] = params.offset;
    }
    if (params.limit !== void 0) {
      queryParameters["limit"] = params.limit;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/tracks/trending/underground`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, (jsonValue) => TracksResponseFromJSON(jsonValue));
  }
  /**
   * Gets the top 100 trending underground tracks on Audius
   */
  async getUndergroundTrendingTracks() {
    let params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let initOverrides = arguments.length > 1 ? arguments[1] : void 0;
    const response = await this.getUndergroundTrendingTracksRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Inspect a track
   * Inspects the details of the file for a track
   */
  async inspectTrackRaw(params, initOverrides) {
    if (params.trackId === null || params.trackId === void 0) {
      throw new RequiredError$1("trackId", "Required parameter params.trackId was null or undefined when calling inspectTrack.");
    }
    const queryParameters = {};
    if (params.original !== void 0) {
      queryParameters["original"] = params.original;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/tracks/{track_id}/inspect`.replace(`{${"track_id"}}`, encodeURIComponent(String(params.trackId))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, (jsonValue) => TrackInspectFromJSON(jsonValue));
  }
  /**
   * Inspect a track
   * Inspects the details of the file for a track
   */
  async inspectTrack(params, initOverrides) {
    const response = await this.inspectTrackRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Inspect multiple tracks
   * Inspects the details of the files for multiple tracks
   */
  async inspectTracksRaw(params, initOverrides) {
    if (params.id === null || params.id === void 0) {
      throw new RequiredError$1("id", "Required parameter params.id was null or undefined when calling inspectTracks.");
    }
    const queryParameters = {};
    if (params.id) {
      queryParameters["id"] = params.id;
    }
    if (params.original !== void 0) {
      queryParameters["original"] = params.original;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/tracks/inspect`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, (jsonValue) => TrackInspectListFromJSON(jsonValue));
  }
  /**
   * Inspect multiple tracks
   * Inspects the details of the files for multiple tracks
   */
  async inspectTracks(params, initOverrides) {
    const response = await this.inspectTracksRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Search for a track or tracks
   */
  async searchTracksRaw(params, initOverrides) {
    const queryParameters = {};
    if (params.offset !== void 0) {
      queryParameters["offset"] = params.offset;
    }
    if (params.limit !== void 0) {
      queryParameters["limit"] = params.limit;
    }
    if (params.query !== void 0) {
      queryParameters["query"] = params.query;
    }
    if (params.genre) {
      queryParameters["genre"] = params.genre;
    }
    if (params.sortMethod !== void 0) {
      queryParameters["sort_method"] = params.sortMethod;
    }
    if (params.mood) {
      queryParameters["mood"] = params.mood;
    }
    if (params.onlyDownloadable !== void 0) {
      queryParameters["only_downloadable"] = params.onlyDownloadable;
    }
    if (params.includePurchaseable !== void 0) {
      queryParameters["includePurchaseable"] = params.includePurchaseable;
    }
    if (params.isPurchaseable !== void 0) {
      queryParameters["is_purchaseable"] = params.isPurchaseable;
    }
    if (params.hasDownloads !== void 0) {
      queryParameters["has_downloads"] = params.hasDownloads;
    }
    if (params.key) {
      queryParameters["key"] = params.key;
    }
    if (params.bpmMin !== void 0) {
      queryParameters["bpm_min"] = params.bpmMin;
    }
    if (params.bpmMax !== void 0) {
      queryParameters["bpm_max"] = params.bpmMax;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/tracks/search`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, (jsonValue) => TrackSearchFromJSON(jsonValue));
  }
  /**
   * Search for a track or tracks
   */
  async searchTracks() {
    let params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let initOverrides = arguments.length > 1 ? arguments[1] : void 0;
    const response = await this.searchTracksRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Stream an mp3 track This endpoint accepts the Range header for streaming. https://developer.mozilla.org/en-US/docs/Web/HTTP/Range_requests
   * Get the streamable MP3 file of a track
   */
  async streamTrackRaw(params, initOverrides) {
    if (params.trackId === null || params.trackId === void 0) {
      throw new RequiredError$1("trackId", "Required parameter params.trackId was null or undefined when calling streamTrack.");
    }
    const queryParameters = {};
    if (params.userId !== void 0) {
      queryParameters["user_id"] = params.userId;
    }
    if (params.preview !== void 0) {
      queryParameters["preview"] = params.preview;
    }
    if (params.userSignature !== void 0) {
      queryParameters["user_signature"] = params.userSignature;
    }
    if (params.userData !== void 0) {
      queryParameters["user_data"] = params.userData;
    }
    if (params.nftAccessSignature !== void 0) {
      queryParameters["nft_access_signature"] = params.nftAccessSignature;
    }
    if (params.skipPlayCount !== void 0) {
      queryParameters["skip_play_count"] = params.skipPlayCount;
    }
    if (params.apiKey !== void 0) {
      queryParameters["api_key"] = params.apiKey;
    }
    if (params.skipCheck !== void 0) {
      queryParameters["skip_check"] = params.skipCheck;
    }
    if (params.noRedirect !== void 0) {
      queryParameters["no_redirect"] = params.noRedirect;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/tracks/{track_id}/stream`.replace(`{${"track_id"}}`, encodeURIComponent(String(params.trackId))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, (jsonValue) => StreamUrlResponseFromJSON(jsonValue));
  }
  /**
   * Stream an mp3 track This endpoint accepts the Range header for streaming. https://developer.mozilla.org/en-US/docs/Web/HTTP/Range_requests
   * Get the streamable MP3 file of a track
   */
  async streamTrack(params, initOverrides) {
    const response = await this.streamTrackRaw(params, initOverrides);
    return await response.value();
  }
};
var GetMostSharedTracksTimeRangeEnum$1 = {
  Week: "week",
  Month: "month",
  AllTime: "allTime"
};
var GetTrackCommentsSortMethodEnum$1 = {
  Top: "top",
  Newest: "newest",
  Timestamp: "timestamp"
};
var GetTrendingTracksTimeEnum$1 = {
  Week: "week",
  Month: "month",
  Year: "year",
  AllTime: "allTime"
};
var SearchTracksSortMethodEnum = {
  Relevant: "relevant",
  Popular: "popular",
  Recent: "recent"
};
var UsersApi$2 = class extends BaseAPI$1 {
  /**
   * @hidden
   * Downloads the purchases the user has made as a CSV file
   */
  async downloadPurchasesAsCSVRaw(params, initOverrides) {
    if (params.id === null || params.id === void 0) {
      throw new RequiredError$1("id", "Required parameter params.id was null or undefined when calling downloadPurchasesAsCSV.");
    }
    const queryParameters = {};
    if (params.userId !== void 0) {
      queryParameters["user_id"] = params.userId;
    }
    const headerParameters = {};
    if (params.encodedDataMessage !== void 0 && params.encodedDataMessage !== null) {
      headerParameters["Encoded-Data-Message"] = String(params.encodedDataMessage);
    }
    if (params.encodedDataSignature !== void 0 && params.encodedDataSignature !== null) {
      headerParameters["Encoded-Data-Signature"] = String(params.encodedDataSignature);
    }
    const response = await this.request({
      path: `/users/{id}/purchases/download`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new VoidApiResponse$1(response);
  }
  /**
   * Downloads the purchases the user has made as a CSV file
   */
  async downloadPurchasesAsCSV(params, initOverrides) {
    await this.downloadPurchasesAsCSVRaw(params, initOverrides);
  }
  /**
   * @hidden
   * Downloads the sales the user has made as a CSV file
   */
  async downloadSalesAsCSVRaw(params, initOverrides) {
    if (params.id === null || params.id === void 0) {
      throw new RequiredError$1("id", "Required parameter params.id was null or undefined when calling downloadSalesAsCSV.");
    }
    const queryParameters = {};
    if (params.userId !== void 0) {
      queryParameters["user_id"] = params.userId;
    }
    const headerParameters = {};
    if (params.encodedDataMessage !== void 0 && params.encodedDataMessage !== null) {
      headerParameters["Encoded-Data-Message"] = String(params.encodedDataMessage);
    }
    if (params.encodedDataSignature !== void 0 && params.encodedDataSignature !== null) {
      headerParameters["Encoded-Data-Signature"] = String(params.encodedDataSignature);
    }
    const response = await this.request({
      path: `/users/{id}/sales/download`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new VoidApiResponse$1(response);
  }
  /**
   * Downloads the sales the user has made as a CSV file
   */
  async downloadSalesAsCSV(params, initOverrides) {
    await this.downloadSalesAsCSVRaw(params, initOverrides);
  }
  /**
   * @hidden
   * Gets the sales data for the user in JSON format
   */
  async downloadSalesAsJSONRaw(params, initOverrides) {
    if (params.id === null || params.id === void 0) {
      throw new RequiredError$1("id", "Required parameter params.id was null or undefined when calling downloadSalesAsJSON.");
    }
    const queryParameters = {};
    if (params.userId !== void 0) {
      queryParameters["user_id"] = params.userId;
    }
    if (params.granteeUserId !== void 0) {
      queryParameters["grantee_user_id"] = params.granteeUserId;
    }
    const headerParameters = {};
    if (params.encodedDataMessage !== void 0 && params.encodedDataMessage !== null) {
      headerParameters["Encoded-Data-Message"] = String(params.encodedDataMessage);
    }
    if (params.encodedDataSignature !== void 0 && params.encodedDataSignature !== null) {
      headerParameters["Encoded-Data-Signature"] = String(params.encodedDataSignature);
    }
    const response = await this.request({
      path: `/users/{id}/sales/download/json`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, (jsonValue) => SalesJsonResponseFromJSON(jsonValue));
  }
  /**
   * Gets the sales data for the user in JSON format
   */
  async downloadSalesAsJSON(params, initOverrides) {
    const response = await this.downloadSalesAsJSONRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Downloads the USDC withdrawals the user has made as a CSV file
   */
  async downloadUSDCWithdrawalsAsCSVRaw(params, initOverrides) {
    if (params.id === null || params.id === void 0) {
      throw new RequiredError$1("id", "Required parameter params.id was null or undefined when calling downloadUSDCWithdrawalsAsCSV.");
    }
    const queryParameters = {};
    if (params.userId !== void 0) {
      queryParameters["user_id"] = params.userId;
    }
    const headerParameters = {};
    if (params.encodedDataMessage !== void 0 && params.encodedDataMessage !== null) {
      headerParameters["Encoded-Data-Message"] = String(params.encodedDataMessage);
    }
    if (params.encodedDataSignature !== void 0 && params.encodedDataSignature !== null) {
      headerParameters["Encoded-Data-Signature"] = String(params.encodedDataSignature);
    }
    const response = await this.request({
      path: `/users/{id}/withdrawals/download`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new VoidApiResponse$1(response);
  }
  /**
   * Downloads the USDC withdrawals the user has made as a CSV file
   */
  async downloadUSDCWithdrawalsAsCSV(params, initOverrides) {
    await this.downloadUSDCWithdrawalsAsCSVRaw(params, initOverrides);
  }
  /**
   * @hidden
   * Gets the AI generated tracks attributed to a user using the user\'s handle
   */
  async getAIAttributedTracksByUserHandleRaw(params, initOverrides) {
    if (params.handle === null || params.handle === void 0) {
      throw new RequiredError$1("handle", "Required parameter params.handle was null or undefined when calling getAIAttributedTracksByUserHandle.");
    }
    const queryParameters = {};
    if (params.offset !== void 0) {
      queryParameters["offset"] = params.offset;
    }
    if (params.limit !== void 0) {
      queryParameters["limit"] = params.limit;
    }
    if (params.userId !== void 0) {
      queryParameters["user_id"] = params.userId;
    }
    if (params.sort !== void 0) {
      queryParameters["sort"] = params.sort;
    }
    if (params.query !== void 0) {
      queryParameters["query"] = params.query;
    }
    if (params.sortMethod !== void 0) {
      queryParameters["sort_method"] = params.sortMethod;
    }
    if (params.sortDirection !== void 0) {
      queryParameters["sort_direction"] = params.sortDirection;
    }
    if (params.filterTracks !== void 0) {
      queryParameters["filter_tracks"] = params.filterTracks;
    }
    const headerParameters = {};
    if (params.encodedDataMessage !== void 0 && params.encodedDataMessage !== null) {
      headerParameters["Encoded-Data-Message"] = String(params.encodedDataMessage);
    }
    if (params.encodedDataSignature !== void 0 && params.encodedDataSignature !== null) {
      headerParameters["Encoded-Data-Signature"] = String(params.encodedDataSignature);
    }
    const response = await this.request({
      path: `/users/handle/{handle}/tracks/ai_attributed`.replace(`{${"handle"}}`, encodeURIComponent(String(params.handle))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, (jsonValue) => TracksResponseFromJSON(jsonValue));
  }
  /**
   * Gets the AI generated tracks attributed to a user using the user\'s handle
   */
  async getAIAttributedTracksByUserHandle(params, initOverrides) {
    const response = await this.getAIAttributedTracksByUserHandleRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets the albums created by a user using their user ID
   */
  async getAlbumsByUserRaw(params, initOverrides) {
    if (params.id === null || params.id === void 0) {
      throw new RequiredError$1("id", "Required parameter params.id was null or undefined when calling getAlbumsByUser.");
    }
    const queryParameters = {};
    if (params.offset !== void 0) {
      queryParameters["offset"] = params.offset;
    }
    if (params.limit !== void 0) {
      queryParameters["limit"] = params.limit;
    }
    if (params.userId !== void 0) {
      queryParameters["user_id"] = params.userId;
    }
    if (params.sortMethod !== void 0) {
      queryParameters["sort_method"] = params.sortMethod;
    }
    if (params.query !== void 0) {
      queryParameters["query"] = params.query;
    }
    const headerParameters = {};
    if (params.encodedDataMessage !== void 0 && params.encodedDataMessage !== null) {
      headerParameters["Encoded-Data-Message"] = String(params.encodedDataMessage);
    }
    if (params.encodedDataSignature !== void 0 && params.encodedDataSignature !== null) {
      headerParameters["Encoded-Data-Signature"] = String(params.encodedDataSignature);
    }
    const response = await this.request({
      path: `/users/{id}/albums`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, (jsonValue) => AlbumsResponseFromJSON(jsonValue));
  }
  /**
   * Gets the albums created by a user using their user ID
   */
  async getAlbumsByUser(params, initOverrides) {
    const response = await this.getAlbumsByUserRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Get the apps that user has authorized to write to their account
   */
  async getAuthorizedAppsRaw(params, initOverrides) {
    if (params.id === null || params.id === void 0) {
      throw new RequiredError$1("id", "Required parameter params.id was null or undefined when calling getAuthorizedApps.");
    }
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/users/{id}/authorized_apps`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, (jsonValue) => AuthorizedAppsFromJSON(jsonValue));
  }
  /**
   * Get the apps that user has authorized to write to their account
   */
  async getAuthorizedApps(params, initOverrides) {
    const response = await this.getAuthorizedAppsRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets a list of users by ID
   */
  async getBulkUsersRaw(params, initOverrides) {
    const queryParameters = {};
    if (params.userId !== void 0) {
      queryParameters["user_id"] = params.userId;
    }
    if (params.id) {
      queryParameters["id"] = params.id;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/users`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, (jsonValue) => UsersResponseFromJSON(jsonValue));
  }
  /**
   * Gets a list of users by ID
   */
  async getBulkUsers() {
    let params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let initOverrides = arguments.length > 1 ? arguments[1] : void 0;
    const response = await this.getBulkUsersRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Get the User\'s ERC and SPL connected wallets
   */
  async getConnectedWalletsRaw(params, initOverrides) {
    if (params.id === null || params.id === void 0) {
      throw new RequiredError$1("id", "Required parameter params.id was null or undefined when calling getConnectedWallets.");
    }
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/users/{id}/connected_wallets`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, (jsonValue) => ConnectedWalletsResponseFromJSON(jsonValue));
  }
  /**
   * Get the User\'s ERC and SPL connected wallets
   */
  async getConnectedWallets(params, initOverrides) {
    const response = await this.getConnectedWalletsRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets the developer apps that the user owns
   */
  async getDeveloperAppsRaw(params, initOverrides) {
    if (params.id === null || params.id === void 0) {
      throw new RequiredError$1("id", "Required parameter params.id was null or undefined when calling getDeveloperApps.");
    }
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/users/{id}/developer_apps`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, (jsonValue) => DeveloperAppsFromJSON(jsonValue));
  }
  /**
   * Gets the developer apps that the user owns
   */
  async getDeveloperApps(params, initOverrides) {
    const response = await this.getDeveloperAppsRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets a user\'s favorite tracks
   */
  async getFavoritesRaw(params, initOverrides) {
    if (params.id === null || params.id === void 0) {
      throw new RequiredError$1("id", "Required parameter params.id was null or undefined when calling getFavorites.");
    }
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/users/{id}/favorites`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, (jsonValue) => FavoritesResponseFromJSON(jsonValue));
  }
  /**
   * Gets a user\'s favorite tracks
   */
  async getFavorites(params, initOverrides) {
    const response = await this.getFavoritesRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * All users that follow the provided user
   */
  async getFollowersRaw(params, initOverrides) {
    if (params.id === null || params.id === void 0) {
      throw new RequiredError$1("id", "Required parameter params.id was null or undefined when calling getFollowers.");
    }
    const queryParameters = {};
    if (params.offset !== void 0) {
      queryParameters["offset"] = params.offset;
    }
    if (params.limit !== void 0) {
      queryParameters["limit"] = params.limit;
    }
    if (params.userId !== void 0) {
      queryParameters["user_id"] = params.userId;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/users/{id}/followers`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, (jsonValue) => FollowersResponseFromJSON(jsonValue));
  }
  /**
   * All users that follow the provided user
   */
  async getFollowers(params, initOverrides) {
    const response = await this.getFollowersRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * All users that the provided user follows
   */
  async getFollowingRaw(params, initOverrides) {
    if (params.id === null || params.id === void 0) {
      throw new RequiredError$1("id", "Required parameter params.id was null or undefined when calling getFollowing.");
    }
    const queryParameters = {};
    if (params.offset !== void 0) {
      queryParameters["offset"] = params.offset;
    }
    if (params.limit !== void 0) {
      queryParameters["limit"] = params.limit;
    }
    if (params.userId !== void 0) {
      queryParameters["user_id"] = params.userId;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/users/{id}/following`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, (jsonValue) => FollowingResponseFromJSON$1(jsonValue));
  }
  /**
   * All users that the provided user follows
   */
  async getFollowing(params, initOverrides) {
    const response = await this.getFollowingRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets users muted by the given user
   */
  async getMutedUsersRaw(params, initOverrides) {
    if (params.id === null || params.id === void 0) {
      throw new RequiredError$1("id", "Required parameter params.id was null or undefined when calling getMutedUsers.");
    }
    const queryParameters = {};
    const headerParameters = {};
    if (params.encodedDataMessage !== void 0 && params.encodedDataMessage !== null) {
      headerParameters["Encoded-Data-Message"] = String(params.encodedDataMessage);
    }
    if (params.encodedDataSignature !== void 0 && params.encodedDataSignature !== null) {
      headerParameters["Encoded-Data-Signature"] = String(params.encodedDataSignature);
    }
    const response = await this.request({
      path: `/users/{id}/muted`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, (jsonValue) => UsersResponseFromJSON(jsonValue));
  }
  /**
   * Gets users muted by the given user
   */
  async getMutedUsers(params, initOverrides) {
    const response = await this.getMutedUsersRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Get intersection of users that follow followeeUserId and users that are followed by followerUserId
   */
  async getMutualFollowersRaw(params, initOverrides) {
    if (params.id === null || params.id === void 0) {
      throw new RequiredError$1("id", "Required parameter params.id was null or undefined when calling getMutualFollowers.");
    }
    const queryParameters = {};
    if (params.offset !== void 0) {
      queryParameters["offset"] = params.offset;
    }
    if (params.limit !== void 0) {
      queryParameters["limit"] = params.limit;
    }
    if (params.userId !== void 0) {
      queryParameters["user_id"] = params.userId;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/users/{id}/mutuals`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, (jsonValue) => MutualFollowersResponseFromJSON(jsonValue));
  }
  /**
   * Get intersection of users that follow followeeUserId and users that are followed by followerUserId
   */
  async getMutualFollowers(params, initOverrides) {
    const response = await this.getMutualFollowersRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets the playlists created by a user using their user ID
   */
  async getPlaylistsByUserRaw(params, initOverrides) {
    if (params.id === null || params.id === void 0) {
      throw new RequiredError$1("id", "Required parameter params.id was null or undefined when calling getPlaylistsByUser.");
    }
    const queryParameters = {};
    if (params.offset !== void 0) {
      queryParameters["offset"] = params.offset;
    }
    if (params.limit !== void 0) {
      queryParameters["limit"] = params.limit;
    }
    if (params.userId !== void 0) {
      queryParameters["user_id"] = params.userId;
    }
    if (params.sortMethod !== void 0) {
      queryParameters["sort_method"] = params.sortMethod;
    }
    if (params.query !== void 0) {
      queryParameters["query"] = params.query;
    }
    const headerParameters = {};
    if (params.encodedDataMessage !== void 0 && params.encodedDataMessage !== null) {
      headerParameters["Encoded-Data-Message"] = String(params.encodedDataMessage);
    }
    if (params.encodedDataSignature !== void 0 && params.encodedDataSignature !== null) {
      headerParameters["Encoded-Data-Signature"] = String(params.encodedDataSignature);
    }
    const response = await this.request({
      path: `/users/{id}/playlists`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, (jsonValue) => PlaylistsResponseFromJSON(jsonValue));
  }
  /**
   * Gets the playlists created by a user using their user ID
   */
  async getPlaylistsByUser(params, initOverrides) {
    const response = await this.getPlaylistsByUserRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets the list of unique users who have purchased content by the given user
   */
  async getPurchasersRaw(params, initOverrides) {
    if (params.id === null || params.id === void 0) {
      throw new RequiredError$1("id", "Required parameter params.id was null or undefined when calling getPurchasers.");
    }
    const queryParameters = {};
    if (params.offset !== void 0) {
      queryParameters["offset"] = params.offset;
    }
    if (params.limit !== void 0) {
      queryParameters["limit"] = params.limit;
    }
    if (params.userId !== void 0) {
      queryParameters["user_id"] = params.userId;
    }
    if (params.contentType !== void 0) {
      queryParameters["content_type"] = params.contentType;
    }
    if (params.contentId !== void 0) {
      queryParameters["content_id"] = params.contentId;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/users/{id}/purchasers`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, (jsonValue) => PurchasersResponseFromJSON(jsonValue));
  }
  /**
   * Gets the list of unique users who have purchased content by the given user
   */
  async getPurchasers(params, initOverrides) {
    const response = await this.getPurchasersRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets a list of users that might be of interest to followers of this user.
   */
  async getRelatedUsersRaw(params, initOverrides) {
    if (params.id === null || params.id === void 0) {
      throw new RequiredError$1("id", "Required parameter params.id was null or undefined when calling getRelatedUsers.");
    }
    const queryParameters = {};
    if (params.offset !== void 0) {
      queryParameters["offset"] = params.offset;
    }
    if (params.limit !== void 0) {
      queryParameters["limit"] = params.limit;
    }
    if (params.userId !== void 0) {
      queryParameters["user_id"] = params.userId;
    }
    if (params.filterFollowed !== void 0) {
      queryParameters["filter_followed"] = params.filterFollowed;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/users/{id}/related`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, (jsonValue) => RelatedArtistResponseFromJSON(jsonValue));
  }
  /**
   * Gets a list of users that might be of interest to followers of this user.
   */
  async getRelatedUsers(params, initOverrides) {
    const response = await this.getRelatedUsersRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets the list of unique users who have remixed tracks by the given user, or a specific track by that user if provided
   */
  async getRemixersRaw(params, initOverrides) {
    if (params.id === null || params.id === void 0) {
      throw new RequiredError$1("id", "Required parameter params.id was null or undefined when calling getRemixers.");
    }
    const queryParameters = {};
    if (params.offset !== void 0) {
      queryParameters["offset"] = params.offset;
    }
    if (params.limit !== void 0) {
      queryParameters["limit"] = params.limit;
    }
    if (params.userId !== void 0) {
      queryParameters["user_id"] = params.userId;
    }
    if (params.trackId !== void 0) {
      queryParameters["track_id"] = params.trackId;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/users/{id}/remixers`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, (jsonValue) => RemixersResponseFromJSON(jsonValue));
  }
  /**
   * Gets the list of unique users who have remixed tracks by the given user, or a specific track by that user if provided
   */
  async getRemixers(params, initOverrides) {
    const response = await this.getRemixersRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets the given user\'s reposts
   */
  async getRepostsRaw(params, initOverrides) {
    if (params.id === null || params.id === void 0) {
      throw new RequiredError$1("id", "Required parameter params.id was null or undefined when calling getReposts.");
    }
    const queryParameters = {};
    if (params.offset !== void 0) {
      queryParameters["offset"] = params.offset;
    }
    if (params.limit !== void 0) {
      queryParameters["limit"] = params.limit;
    }
    if (params.userId !== void 0) {
      queryParameters["user_id"] = params.userId;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/users/{id}/reposts`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, (jsonValue) => RepostsFromJSON(jsonValue));
  }
  /**
   * Gets the given user\'s reposts
   */
  async getReposts(params, initOverrides) {
    const response = await this.getRepostsRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets the aggregated sales data for the user
   */
  async getSalesAggregateRaw(params, initOverrides) {
    if (params.id === null || params.id === void 0) {
      throw new RequiredError$1("id", "Required parameter params.id was null or undefined when calling getSalesAggregate.");
    }
    const queryParameters = {};
    if (params.offset !== void 0) {
      queryParameters["offset"] = params.offset;
    }
    if (params.limit !== void 0) {
      queryParameters["limit"] = params.limit;
    }
    if (params.userId !== void 0) {
      queryParameters["user_id"] = params.userId;
    }
    const headerParameters = {};
    if (params.encodedDataMessage !== void 0 && params.encodedDataMessage !== null) {
      headerParameters["Encoded-Data-Message"] = String(params.encodedDataMessage);
    }
    if (params.encodedDataSignature !== void 0 && params.encodedDataSignature !== null) {
      headerParameters["Encoded-Data-Signature"] = String(params.encodedDataSignature);
    }
    const response = await this.request({
      path: `/users/{id}/sales/aggregate`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, (jsonValue) => SalesAggregateResponseFromJSON(jsonValue));
  }
  /**
   * Gets the aggregated sales data for the user
   */
  async getSalesAggregate(params, initOverrides) {
    const response = await this.getSalesAggregateRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * All users that subscribe to the provided user
   */
  async getSubscribersRaw(params, initOverrides) {
    if (params.id === null || params.id === void 0) {
      throw new RequiredError$1("id", "Required parameter params.id was null or undefined when calling getSubscribers.");
    }
    const queryParameters = {};
    if (params.offset !== void 0) {
      queryParameters["offset"] = params.offset;
    }
    if (params.limit !== void 0) {
      queryParameters["limit"] = params.limit;
    }
    if (params.userId !== void 0) {
      queryParameters["user_id"] = params.userId;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/users/{id}/subscribers`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, (jsonValue) => SubscribersResponseFromJSON(jsonValue));
  }
  /**
   * All users that subscribe to the provided user
   */
  async getSubscribers(params, initOverrides) {
    const response = await this.getSubscribersRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets the users that the given user supports
   */
  async getSupportedUsersRaw(params, initOverrides) {
    if (params.id === null || params.id === void 0) {
      throw new RequiredError$1("id", "Required parameter params.id was null or undefined when calling getSupportedUsers.");
    }
    const queryParameters = {};
    if (params.offset !== void 0) {
      queryParameters["offset"] = params.offset;
    }
    if (params.limit !== void 0) {
      queryParameters["limit"] = params.limit;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/users/{id}/supporting`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, (jsonValue) => GetSupportedUsersFromJSON(jsonValue));
  }
  /**
   * Gets the users that the given user supports
   */
  async getSupportedUsers(params, initOverrides) {
    const response = await this.getSupportedUsersRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets the supporters of the given user
   */
  async getSupportersRaw(params, initOverrides) {
    if (params.id === null || params.id === void 0) {
      throw new RequiredError$1("id", "Required parameter params.id was null or undefined when calling getSupporters.");
    }
    const queryParameters = {};
    if (params.offset !== void 0) {
      queryParameters["offset"] = params.offset;
    }
    if (params.limit !== void 0) {
      queryParameters["limit"] = params.limit;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/users/{id}/supporters`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, (jsonValue) => GetSupportersFromJSON(jsonValue));
  }
  /**
   * Gets the supporters of the given user
   */
  async getSupporters(params, initOverrides) {
    const response = await this.getSupportersRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets the most used track tags by a user.
   * Fetch most used tags in a user\'s tracks
   */
  async getTopTrackTagsRaw(params, initOverrides) {
    if (params.id === null || params.id === void 0) {
      throw new RequiredError$1("id", "Required parameter params.id was null or undefined when calling getTopTrackTags.");
    }
    const queryParameters = {};
    if (params.limit !== void 0) {
      queryParameters["limit"] = params.limit;
    }
    if (params.userId !== void 0) {
      queryParameters["user_id"] = params.userId;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/users/{id}/tags`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, (jsonValue) => TagsResponseFromJSON(jsonValue));
  }
  /**
   * Gets the most used track tags by a user.
   * Fetch most used tags in a user\'s tracks
   */
  async getTopTrackTags(params, initOverrides) {
    const response = await this.getTopTrackTagsRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets the tracks created by a user using their user ID
   */
  async getTracksByUserRaw(params, initOverrides) {
    if (params.id === null || params.id === void 0) {
      throw new RequiredError$1("id", "Required parameter params.id was null or undefined when calling getTracksByUser.");
    }
    const queryParameters = {};
    if (params.offset !== void 0) {
      queryParameters["offset"] = params.offset;
    }
    if (params.limit !== void 0) {
      queryParameters["limit"] = params.limit;
    }
    if (params.userId !== void 0) {
      queryParameters["user_id"] = params.userId;
    }
    if (params.sort !== void 0) {
      queryParameters["sort"] = params.sort;
    }
    if (params.query !== void 0) {
      queryParameters["query"] = params.query;
    }
    if (params.sortMethod !== void 0) {
      queryParameters["sort_method"] = params.sortMethod;
    }
    if (params.sortDirection !== void 0) {
      queryParameters["sort_direction"] = params.sortDirection;
    }
    if (params.filterTracks !== void 0) {
      queryParameters["filter_tracks"] = params.filterTracks;
    }
    const headerParameters = {};
    if (params.encodedDataMessage !== void 0 && params.encodedDataMessage !== null) {
      headerParameters["Encoded-Data-Message"] = String(params.encodedDataMessage);
    }
    if (params.encodedDataSignature !== void 0 && params.encodedDataSignature !== null) {
      headerParameters["Encoded-Data-Signature"] = String(params.encodedDataSignature);
    }
    const response = await this.request({
      path: `/users/{id}/tracks`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, (jsonValue) => TracksResponseFromJSON(jsonValue));
  }
  /**
   * Gets the tracks created by a user using their user ID
   */
  async getTracksByUser(params, initOverrides) {
    const response = await this.getTracksByUserRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets a single user by their user ID
   */
  async getUserRaw(params, initOverrides) {
    if (params.id === null || params.id === void 0) {
      throw new RequiredError$1("id", "Required parameter params.id was null or undefined when calling getUser.");
    }
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/users/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, (jsonValue) => UserResponseFromJSON(jsonValue));
  }
  /**
   * Gets a single user by their user ID
   */
  async getUser(params, initOverrides) {
    const response = await this.getUserRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets a single user by their handle
   */
  async getUserByHandleRaw(params, initOverrides) {
    if (params.handle === null || params.handle === void 0) {
      throw new RequiredError$1("handle", "Required parameter params.handle was null or undefined when calling getUserByHandle.");
    }
    const queryParameters = {};
    if (params.userId !== void 0) {
      queryParameters["user_id"] = params.userId;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/users/handle/{handle}`.replace(`{${"handle"}}`, encodeURIComponent(String(params.handle))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, (jsonValue) => UserResponseFromJSON(jsonValue));
  }
  /**
   * Gets a single user by their handle
   */
  async getUserByHandle(params, initOverrides) {
    const response = await this.getUserByHandleRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets all challenges for the given user
   */
  async getUserChallengesRaw(params, initOverrides) {
    if (params.id === null || params.id === void 0) {
      throw new RequiredError$1("id", "Required parameter params.id was null or undefined when calling getUserChallenges.");
    }
    const queryParameters = {};
    if (params.showHistorical !== void 0) {
      queryParameters["show_historical"] = params.showHistorical;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/users/{id}/challenges`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, (jsonValue) => GetChallengesFromJSON(jsonValue));
  }
  /**
   * Gets all challenges for the given user
   */
  async getUserChallenges(params, initOverrides) {
    const response = await this.getUserChallengesRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets information about a specific coin owned by the user and their wallets
   */
  async getUserCoinRaw(params, initOverrides) {
    if (params.id === null || params.id === void 0) {
      throw new RequiredError$1("id", "Required parameter params.id was null or undefined when calling getUserCoin.");
    }
    if (params.mint === null || params.mint === void 0) {
      throw new RequiredError$1("mint", "Required parameter params.mint was null or undefined when calling getUserCoin.");
    }
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/users/{id}/coins/{mint}`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))).replace(`{${"mint"}}`, encodeURIComponent(String(params.mint))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, (jsonValue) => UserCoinResponseFromJSON(jsonValue));
  }
  /**
   * Gets information about a specific coin owned by the user and their wallets
   */
  async getUserCoin(params, initOverrides) {
    const response = await this.getUserCoinRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets a list of the coins owned by the user and their balances
   */
  async getUserCoinsRaw(params, initOverrides) {
    if (params.id === null || params.id === void 0) {
      throw new RequiredError$1("id", "Required parameter params.id was null or undefined when calling getUserCoins.");
    }
    const queryParameters = {};
    if (params.offset !== void 0) {
      queryParameters["offset"] = params.offset;
    }
    if (params.limit !== void 0) {
      queryParameters["limit"] = params.limit;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/users/{id}/coins`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, (jsonValue) => UserCoinsResponseFromJSON(jsonValue));
  }
  /**
   * Gets a list of the coins owned by the user and their balances
   */
  async getUserCoins(params, initOverrides) {
    const response = await this.getUserCoinsRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Get the User\'s indexed collectibles data
   */
  async getUserCollectiblesRaw(params, initOverrides) {
    if (params.id === null || params.id === void 0) {
      throw new RequiredError$1("id", "Required parameter params.id was null or undefined when calling getUserCollectibles.");
    }
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/users/{id}/collectibles`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, (jsonValue) => CollectiblesResponseFromJSON(jsonValue));
  }
  /**
   * Get the User\'s indexed collectibles data
   */
  async getUserCollectibles(params, initOverrides) {
    const response = await this.getUserCollectiblesRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Get user comment history
   */
  async getUserCommentsRaw(params, initOverrides) {
    if (params.id === null || params.id === void 0) {
      throw new RequiredError$1("id", "Required parameter params.id was null or undefined when calling getUserComments.");
    }
    const queryParameters = {};
    if (params.offset !== void 0) {
      queryParameters["offset"] = params.offset;
    }
    if (params.limit !== void 0) {
      queryParameters["limit"] = params.limit;
    }
    if (params.userId !== void 0) {
      queryParameters["user_id"] = params.userId;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/users/{id}/comments`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, (jsonValue) => UserCommentsResponseFromJSON(jsonValue));
  }
  /**
   * Get user comment history
   */
  async getUserComments(params, initOverrides) {
    const response = await this.getUserCommentsRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets the encrypted key for email access between the receiving user and granting user.
   */
  async getUserEmailKeyRaw(params, initOverrides) {
    if (params.receivingUserId === null || params.receivingUserId === void 0) {
      throw new RequiredError$1("receivingUserId", "Required parameter params.receivingUserId was null or undefined when calling getUserEmailKey.");
    }
    if (params.grantorUserId === null || params.grantorUserId === void 0) {
      throw new RequiredError$1("grantorUserId", "Required parameter params.grantorUserId was null or undefined when calling getUserEmailKey.");
    }
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/users/{receiving_user_id}/emails/{grantor_user_id}/key`.replace(`{${"receiving_user_id"}}`, encodeURIComponent(String(params.receivingUserId))).replace(`{${"grantor_user_id"}}`, encodeURIComponent(String(params.grantorUserId))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, (jsonValue) => EmailAccessResponseFromJSON(jsonValue));
  }
  /**
   * Gets the encrypted key for email access between the receiving user and granting user.
   */
  async getUserEmailKey(params, initOverrides) {
    const response = await this.getUserEmailKeyRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets User IDs from any Ethereum wallet address or Solana account address associated with their Audius account.
   */
  async getUserIDsByAddressesRaw(params, initOverrides) {
    if (params.address === null || params.address === void 0) {
      throw new RequiredError$1("address", "Required parameter params.address was null or undefined when calling getUserIDsByAddresses.");
    }
    const queryParameters = {};
    if (params.address) {
      queryParameters["address"] = params.address;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/users/address`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, (jsonValue) => UserIdsAddressesResponseFromJSON(jsonValue));
  }
  /**
   * Gets User IDs from any Ethereum wallet address or Solana account address associated with their Audius account.
   */
  async getUserIDsByAddresses(params, initOverrides) {
    const response = await this.getUserIDsByAddressesRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets the listen data for a user by month and track within a given time frame.
   */
  async getUserMonthlyTrackListensRaw(params, initOverrides) {
    if (params.id === null || params.id === void 0) {
      throw new RequiredError$1("id", "Required parameter params.id was null or undefined when calling getUserMonthlyTrackListens.");
    }
    if (params.startTime === null || params.startTime === void 0) {
      throw new RequiredError$1("startTime", "Required parameter params.startTime was null or undefined when calling getUserMonthlyTrackListens.");
    }
    if (params.endTime === null || params.endTime === void 0) {
      throw new RequiredError$1("endTime", "Required parameter params.endTime was null or undefined when calling getUserMonthlyTrackListens.");
    }
    const queryParameters = {};
    if (params.startTime !== void 0) {
      queryParameters["start_time"] = params.startTime;
    }
    if (params.endTime !== void 0) {
      queryParameters["end_time"] = params.endTime;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/users/{id}/listen_counts_monthly`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, (jsonValue) => UserTrackListenCountsResponseFromJSON(jsonValue));
  }
  /**
   * Gets the listen data for a user by month and track within a given time frame.
   */
  async getUserMonthlyTrackListens(params, initOverrides) {
    const response = await this.getUserMonthlyTrackListensRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets the recommended tracks for the user
   */
  async getUserRecommendedTracksRaw(params, initOverrides) {
    if (params.id === null || params.id === void 0) {
      throw new RequiredError$1("id", "Required parameter params.id was null or undefined when calling getUserRecommendedTracks.");
    }
    const queryParameters = {};
    if (params.offset !== void 0) {
      queryParameters["offset"] = params.offset;
    }
    if (params.limit !== void 0) {
      queryParameters["limit"] = params.limit;
    }
    if (params.userId !== void 0) {
      queryParameters["user_id"] = params.userId;
    }
    if (params.timeRange !== void 0) {
      queryParameters["time_range"] = params.timeRange;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/users/{id}/recommended-tracks`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, (jsonValue) => TracksResponseFromJSON(jsonValue));
  }
  /**
   * Gets the recommended tracks for the user
   */
  async getUserRecommendedTracks(params, initOverrides) {
    const response = await this.getUserRecommendedTracksRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets tracks owned by the user which have been remixed by another track
   */
  async getUserTracksRemixedRaw(params, initOverrides) {
    if (params.id === null || params.id === void 0) {
      throw new RequiredError$1("id", "Required parameter params.id was null or undefined when calling getUserTracksRemixed.");
    }
    const queryParameters = {};
    if (params.offset !== void 0) {
      queryParameters["offset"] = params.offset;
    }
    if (params.limit !== void 0) {
      queryParameters["limit"] = params.limit;
    }
    if (params.userId !== void 0) {
      queryParameters["user_id"] = params.userId;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/users/{id}/tracks/remixed`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, (jsonValue) => UserTracksRemixedResponseFromJSON(jsonValue));
  }
  /**
   * Gets tracks owned by the user which have been remixed by another track
   */
  async getUserTracksRemixed(params, initOverrides) {
    const response = await this.getUserTracksRemixedRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Get the tracks the user recently listened to.
   */
  async getUsersTrackHistoryRaw(params, initOverrides) {
    if (params.id === null || params.id === void 0) {
      throw new RequiredError$1("id", "Required parameter params.id was null or undefined when calling getUsersTrackHistory.");
    }
    const queryParameters = {};
    if (params.offset !== void 0) {
      queryParameters["offset"] = params.offset;
    }
    if (params.limit !== void 0) {
      queryParameters["limit"] = params.limit;
    }
    if (params.query !== void 0) {
      queryParameters["query"] = params.query;
    }
    if (params.sortMethod !== void 0) {
      queryParameters["sort_method"] = params.sortMethod;
    }
    if (params.sortDirection !== void 0) {
      queryParameters["sort_direction"] = params.sortDirection;
    }
    if (params.userId !== void 0) {
      queryParameters["user_id"] = params.userId;
    }
    const headerParameters = {};
    if (params.encodedDataMessage !== void 0 && params.encodedDataMessage !== null) {
      headerParameters["Encoded-Data-Message"] = String(params.encodedDataMessage);
    }
    if (params.encodedDataSignature !== void 0 && params.encodedDataSignature !== null) {
      headerParameters["Encoded-Data-Signature"] = String(params.encodedDataSignature);
    }
    const response = await this.request({
      path: `/users/{id}/history/tracks`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, (jsonValue) => HistoryResponseFromJSON(jsonValue));
  }
  /**
   * Get the tracks the user recently listened to.
   */
  async getUsersTrackHistory(params, initOverrides) {
    const response = await this.getUsersTrackHistoryRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Search for users that match the given query
   */
  async searchUsersRaw(params, initOverrides) {
    const queryParameters = {};
    if (params.offset !== void 0) {
      queryParameters["offset"] = params.offset;
    }
    if (params.limit !== void 0) {
      queryParameters["limit"] = params.limit;
    }
    if (params.query !== void 0) {
      queryParameters["query"] = params.query;
    }
    if (params.genre) {
      queryParameters["genre"] = params.genre;
    }
    if (params.sortMethod !== void 0) {
      queryParameters["sort_method"] = params.sortMethod;
    }
    if (params.isVerified !== void 0) {
      queryParameters["is_verified"] = params.isVerified;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/users/search`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, (jsonValue) => UserSearchFromJSON(jsonValue));
  }
  /**
   * Search for users that match the given query
   */
  async searchUsers() {
    let params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let initOverrides = arguments.length > 1 ? arguments[1] : void 0;
    const response = await this.searchUsersRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Verify if the given jwt ID token was signed by the subject (user) in the payload
   */
  async verifyIDTokenRaw(params, initOverrides) {
    if (params.token === null || params.token === void 0) {
      throw new RequiredError$1("token", "Required parameter params.token was null or undefined when calling verifyIDToken.");
    }
    const queryParameters = {};
    if (params.token !== void 0) {
      queryParameters["token"] = params.token;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/users/verify_token`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, (jsonValue) => VerifyTokenFromJSON(jsonValue));
  }
  /**
   * Verify if the given jwt ID token was signed by the subject (user) in the payload
   */
  async verifyIDToken(params, initOverrides) {
    const response = await this.verifyIDTokenRaw(params, initOverrides);
    return await response.value();
  }
};
var GetAIAttributedTracksByUserHandleSortEnum$1 = {
  Date: "date",
  Plays: "plays"
};
var GetAIAttributedTracksByUserHandleSortMethodEnum$1 = {
  Title: "title",
  ArtistName: "artist_name",
  ReleaseDate: "release_date",
  LastListenDate: "last_listen_date",
  AddedDate: "added_date",
  Plays: "plays",
  Reposts: "reposts",
  Saves: "saves",
  MostListensByUser: "most_listens_by_user"
};
var GetAIAttributedTracksByUserHandleSortDirectionEnum$1 = {
  Asc: "asc",
  Desc: "desc"
};
var GetAIAttributedTracksByUserHandleFilterTracksEnum$1 = {
  All: "all",
  Public: "public",
  Unlisted: "unlisted"
};
var GetAlbumsByUserSortMethodEnum$1 = {
  Recent: "recent",
  Popular: "popular"
};
var GetPlaylistsByUserSortMethodEnum$1 = {
  Recent: "recent",
  Popular: "popular"
};
var GetTracksByUserSortEnum$1 = {
  Date: "date",
  Plays: "plays"
};
var GetTracksByUserSortMethodEnum$1 = {
  Title: "title",
  ArtistName: "artist_name",
  ReleaseDate: "release_date",
  LastListenDate: "last_listen_date",
  AddedDate: "added_date",
  Plays: "plays",
  Reposts: "reposts",
  Saves: "saves",
  MostListensByUser: "most_listens_by_user"
};
var GetTracksByUserSortDirectionEnum$1 = {
  Asc: "asc",
  Desc: "desc"
};
var GetTracksByUserFilterTracksEnum$1 = {
  All: "all",
  Public: "public",
  Unlisted: "unlisted"
};
var GetUserRecommendedTracksTimeRangeEnum$1 = {
  Week: "week",
  Month: "month",
  AllTime: "allTime"
};
var GetUsersTrackHistorySortMethodEnum$1 = {
  Title: "title",
  ArtistName: "artist_name",
  ReleaseDate: "release_date",
  LastListenDate: "last_listen_date",
  AddedDate: "added_date",
  Plays: "plays",
  Reposts: "reposts",
  Saves: "saves",
  MostListensByUser: "most_listens_by_user"
};
var GetUsersTrackHistorySortDirectionEnum$1 = {
  Asc: "asc",
  Desc: "desc"
};
var SearchUsersSortMethodEnum = {
  Relevant: "relevant",
  Popular: "popular",
  Recent: "recent"
};
var ResolveApi = class extends BaseAPI$1 {
  /**
   * Resolves a provided Audius app URL to the API resource it represents
   */
  async resolveRaw(params) {
    if (params.url === null || params.url === void 0) {
      throw new RequiredError$1("url", "Required parameter params.url was null or undefined when calling resolve.");
    }
    const queryParameters = {};
    if (params.url !== void 0) {
      queryParameters.url = params.url;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/resolve`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    });
    return new JSONApiResponse$1(response, (json) => {
      var _json$data;
      const data = (_json$data = json === null || json === void 0 ? void 0 : json.data) !== null && _json$data !== void 0 ? _json$data : {};
      if (instanceOfTrack(TrackFromJSONTyped(data))) {
        return TrackResponseFromJSON(json);
      } else if (Array.isArray(data) && data.length > 0 && instanceOfPlaylist(PlaylistFromJSONTyped(data[0]))) {
        return PlaylistResponseFromJSON(json);
      } else if (instanceOfUser(UserFromJSONTyped(data))) {
        return UserResponseFromJSON(json);
      } else {
        throw new ResponseError$1(response, "Invalid response type");
      }
    });
  }
  /**
   * Resolves a provided Audius app URL to the API resource it represents
   */
  async resolve(params) {
    return await (await this.resolveRaw(params)).value();
  }
  /**
   * Typeguard to check if a resolve response is a track
   */
  static instanceOfTrackResponse(response) {
    return !!response.data && instanceOfTrack(response.data);
  }
  /**
   * Typeguard to check if a resolve response is a playlist
   */
  static instanceOfPlaylistResponse(response) {
    return !!response.data && Array.isArray(response.data) && !!response.data[0] && instanceOfPlaylist(response.data[0]);
  }
  /**
   * Typeguard to check if a resolve response is a user
   */
  static instanceOfUserResponse(response) {
    return !!response.data && instanceOfUser(response.data);
  }
};
var ParseRequestError = class extends Error {
  constructor(method, innerError) {
    super(`'${method}' => ${innerError.message}`);
    _defineProperty$1(this, "method", void 0);
    _defineProperty$1(this, "innerError", void 0);
    _defineProperty$1(this, "name", "ParseRequestError");
    this.method = method;
    this.innerError = innerError;
  }
};
var parseParams = (name, schema) => async (params) => {
  const result = await schema.safeParseAsync(params);
  if (!result.success) {
    throw new ParseRequestError(name, result.error);
  }
  return result.data;
};
var prepareSplits = async (_ref) => {
  let {
    splits,
    extraAmount,
    claimableTokensClient,
    logger
  } = _ref;
  const userSplits = splits.filter((s) => !!s.userId);
  const userSplitCount = userSplits.length;
  const networkSplit = splits.filter((s) => !s.userId);
  logger.debug(`Splitting the extra ${extraAmount} between ${userSplitCount} user(s)...`);
  let amountSplits = userSplits.map((split6, index4) => {
    const amountToAdd = extraAmount / BigInt(userSplitCount - index4);
    extraAmount = USDC(extraAmount - amountToAdd).value;
    return {
      ...split6,
      amount: BigInt(split6.amount) + amountToAdd
    };
  });
  amountSplits = amountSplits.concat(networkSplit.map((split6) => ({
    ...split6,
    amount: BigInt(split6.amount)
  })));
  if (extraAmount > 0) {
    logger.debug("Calculated splits after extra amount:", amountSplits);
  }
  amountSplits = await Promise.all(amountSplits.map(async (split6) => {
    if (!split6.payoutWallet && split6.ethWallet) {
      logger.debug("Deriving user bank for user...", {
        userId: split6.userId
      });
      const {
        userBank,
        didExist
      } = await claimableTokensClient.getOrCreateUserBank({
        ethWallet: split6.ethWallet,
        mint: "USDC"
      });
      if (!didExist) {
        logger.debug("Created user bank", {
          userId: split6.userId,
          userBank: userBank.toBase58()
        });
      }
      split6.payoutWallet = userBank.toBase58();
    }
    return split6;
  }));
  return amountSplits.map((split6) => ({
    wallet: split6.payoutWallet,
    amount: split6.amount
  }));
};
var Action;
(function(Action2) {
  Action2["CREATE"] = "Create";
  Action2["UPDATE"] = "Update";
  Action2["DELETE"] = "Delete";
  Action2["VERIFY"] = "Verify";
  Action2["FOLLOW"] = "Follow";
  Action2["UNFOLLOW"] = "Unfollow";
  Action2["SAVE"] = "Save";
  Action2["SHARE"] = "Share";
  Action2["UNSAVE"] = "Unsave";
  Action2["REPOST"] = "Repost";
  Action2["UNREPOST"] = "Unrepost";
  Action2["SUBSCRIBE"] = "Subscribe";
  Action2["UNSUBSCRIBE"] = "Unsubscribe";
  Action2["VIEW"] = "View";
  Action2["VIEW_PLAYLIST"] = "ViewPlaylist";
  Action2["APPROVE"] = "Approve";
  Action2["REJECT"] = "Reject";
  Action2["DOWNLOAD"] = "Download";
  Action2["REACT"] = "React";
  Action2["UNREACT"] = "Unreact";
  Action2["REPORT"] = "Report";
  Action2["PIN"] = "Pin";
  Action2["UNPIN"] = "Unpin";
  Action2["MUTE"] = "Mute";
  Action2["UNMUTE"] = "Unmute";
  Action2["ADD_EMAIL"] = "AddEmail";
  Action2["GRANT_ACCESS"] = "GrantAccess";
})(Action || (Action = {}));
var EntityType;
(function(EntityType2) {
  EntityType2["PLAYLIST"] = "Playlist";
  EntityType2["TRACK"] = "Track";
  EntityType2["USER"] = "User";
  EntityType2["USER_REPLICA_SET"] = "UserReplicaSet";
  EntityType2["NOTIFICATION"] = "Notification";
  EntityType2["DEVELOPER_APP"] = "DeveloperApp";
  EntityType2["GRANT"] = "Grant";
  EntityType2["DASHBOARD_WALLET_USER"] = "DashboardWalletUser";
  EntityType2["TIP"] = "Tip";
  EntityType2["COMMENT"] = "Comment";
  EntityType2["ENCRYPTED_EMAIL"] = "EncryptedEmail";
  EntityType2["EMAIL_ACCESS"] = "EmailAccess";
  EntityType2["ASSOCIATED_WALLET"] = "AssociatedWallet";
  EntityType2["COLLECTIBLES"] = "Collectibles";
  EntityType2["EVENT"] = "Event";
})(EntityType || (EntityType = {}));
var BlockConfirmation;
(function(BlockConfirmation2) {
  BlockConfirmation2["CONFIRMED"] = "CONFIRMED";
  BlockConfirmation2["DENIED"] = "DENIED";
  BlockConfirmation2["UNKNOWN"] = "UNKNOWN";
})(BlockConfirmation || (BlockConfirmation = {}));
var HASH_SALT = "azowernasdfoia";
var MIN_LENGTH = 5;
var hashids = new Hashids(HASH_SALT, MIN_LENGTH);
var decodeHashId = (id) => {
  try {
    const ids = hashids.decode(id);
    if (!ids.length) return null;
    const num2 = Number(ids[0]);
    if (isNaN(num2)) return null;
    return num2;
  } catch (e) {
    return null;
  }
};
var encodeHashId = (id) => {
  try {
    if (id === null) return null;
    const encodedId = hashids.encode(id);
    return encodedId;
  } catch (e) {
    return null;
  }
};
var retry3 = async function(fn) {
  let onRetry = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : (_err) => {
  };
  return await (0, import_async_retry.default)(fn, {
    minTimeout: 500,
    maxTimeout: 4e3,
    factor: 3,
    retries: 3,
    onRetry
  });
};
var TrackUploadHelper = class extends BaseAPI$1 {
  async generateId(type3) {
    const response = await this.request({
      path: `/${type3}s/unclaimed_id`,
      method: "GET",
      headers: {},
      query: {
        noCache: Math.floor(Math.random() * 1e3).toString()
      }
    });
    const {
      data
    } = await response.json();
    const id = decodeHashId(data);
    if (id === null) {
      throw new Error(`Could not generate ${type3} id`);
    }
    return id;
  }
  transformTrackUploadMetadata(inputMetadata, userId) {
    var _metadata$streamCondi;
    const metadata = {
      ...inputMetadata,
      ownerId: userId
    };
    const isStreamGated = metadata.isStreamGated;
    const isUsdcGated = "usdc_purchase" in ((_metadata$streamCondi = metadata.streamConditions) !== null && _metadata$streamCondi !== void 0 ? _metadata$streamCondi : {});
    const isUnlisted = metadata.isUnlisted;
    if (isStreamGated && !isUsdcGated && metadata.fieldVisibility) {
      metadata.fieldVisibility.remixes = false;
    }
    if (!isUnlisted) {
      metadata.fieldVisibility = {
        ...metadata.fieldVisibility,
        genre: true,
        mood: true,
        tags: true,
        share: true,
        playCount: true
      };
    }
    return metadata;
  }
  populateTrackMetadataWithUploadResponse(trackMetadata, audioResponse, coverArtResponse) {
    var _audioResponse$audio_, _audioResponse$audio_2;
    return {
      ...trackMetadata,
      trackSegments: [],
      trackCid: audioResponse.results["320"],
      previewCid: trackMetadata.previewStartSeconds !== void 0 && trackMetadata.previewStartSeconds !== null ? audioResponse.results[`320_preview|${trackMetadata.previewStartSeconds}`] : trackMetadata.previewCid,
      origFileCid: audioResponse.orig_file_cid,
      origFilename: audioResponse.orig_filename || trackMetadata.origFilename,
      audioUploadId: audioResponse.id,
      coverArtSizes: coverArtResponse === null || coverArtResponse === void 0 ? void 0 : coverArtResponse.id,
      duration: parseInt(audioResponse.probe.format.duration, 10),
      bpm: (_audioResponse$audio_ = audioResponse.audio_analysis_results) !== null && _audioResponse$audio_ !== void 0 && _audioResponse$audio_.bpm ? audioResponse.audio_analysis_results.bpm : trackMetadata.bpm,
      musicalKey: (_audioResponse$audio_2 = audioResponse.audio_analysis_results) !== null && _audioResponse$audio_2 !== void 0 && _audioResponse$audio_2.key ? audioResponse.audio_analysis_results.key : trackMetadata.musicalKey,
      audioAnalysisErrorCount: audioResponse.audio_analysis_error_count || 0
    };
  }
  extractMediorumUploadOptions(metadata) {
    const uploadOptions = {};
    if (metadata.previewStartSeconds !== void 0 && metadata.previewStartSeconds !== null) {
      uploadOptions.previewStartSeconds = metadata.previewStartSeconds.toString();
    }
    if (metadata.placementHosts) {
      uploadOptions.placement_hosts = metadata.placementHosts;
    }
    return uploadOptions;
  }
};
var DDEXResourceContributor = z.object({
  name: z.string(),
  roles: z.array(z.string()),
  sequence_number: z.optional(z.number())
}).strict();
var DDEXCopyright = z.object({
  year: z.string(),
  text: z.string()
}).strict();
var DDEXRightsController = z.object({
  name: z.string(),
  roles: z.array(z.string()),
  rights_share_unknown: z.optional(z.string())
}).strict();
var NodeFileSchema = z.object({
  buffer: z.custom((data) => data),
  name: z.optional(z.string()),
  type: z.optional(z.string())
});
var BrowserFileSchema = z.custom((data) => data);
var NativeFileSchema = z.object({
  uri: z.string(),
  name: z.string().nullable(),
  type: z.string().nullable(),
  copyError: z.optional(z.string()),
  fileCopyUri: z.optional(z.string()).nullable(),
  size: z.optional(z.number()).nullable()
});
var CrossPlatformFileSchema = z.union([NodeFileSchema, BrowserFileSchema, NativeFileSchema]);
var isNodeFile = (file) => {
  if (file && file.buffer) {
    return true;
  }
  return false;
};
var isNativeFile = (file) => {
  if (file && file.uri) {
    return true;
  }
  return false;
};
var ALLOWED_IMAGE_MIME_TYPES = ["image/jpeg", "image/png", "image/bmp", "image/tiff", "image/gif", "image/webp"];
var ALLOWED_AUDIO_MIME_TYPES_REGEX = /audio\/.+/;
var getFileType = async (file) => {
  if (isNativeFile(file)) {
    return {
      mime: file.type
    };
  }
  let fileTypeBrowser;
  if (typeof window !== "undefined" && window) {
    fileTypeBrowser = await import("./browser-15461226-ZYCT7NUC.js").then(function(n) {
      return n.b;
    });
  }
  if (isNodeFile(file)) {
    return file.type ? {
      mime: file.type
    } : await fileType2.fromBuffer(file.buffer);
  } else {
    return await fileTypeBrowser.fromBlob(file);
  }
};
var ImageFile = CrossPlatformFileSchema.refine(async (file) => {
  const fileType3 = await getFileType(file);
  return fileType3 && ALLOWED_IMAGE_MIME_TYPES.includes(fileType3.mime);
}, `Image file has invalid file type. Supported file types are: ${ALLOWED_IMAGE_MIME_TYPES.join(", ")}`);
var AudioFile = CrossPlatformFileSchema.refine(async (file) => {
  const fileType3 = await getFileType(file);
  return fileType3 && ALLOWED_AUDIO_MIME_TYPES_REGEX.test(fileType3.mime);
}, `Audio file has invalid file type. Supported file types are: audio/*`);
var Genre;
(function(Genre2) {
  Genre2["ALL"] = "All Genres";
  Genre2["ELECTRONIC"] = "Electronic";
  Genre2["ROCK"] = "Rock";
  Genre2["METAL"] = "Metal";
  Genre2["ALTERNATIVE"] = "Alternative";
  Genre2["HIP_HOP_RAP"] = "Hip-Hop/Rap";
  Genre2["EXPERIMENTAL"] = "Experimental";
  Genre2["PUNK"] = "Punk";
  Genre2["FOLK"] = "Folk";
  Genre2["POP"] = "Pop";
  Genre2["AMBIENT"] = "Ambient";
  Genre2["SOUNDTRACK"] = "Soundtrack";
  Genre2["WORLD"] = "World";
  Genre2["JAZZ"] = "Jazz";
  Genre2["ACOUSTIC"] = "Acoustic";
  Genre2["FUNK"] = "Funk";
  Genre2["R_AND_B_SOUL"] = "R&B/Soul";
  Genre2["DEVOTIONAL"] = "Devotional";
  Genre2["CLASSICAL"] = "Classical";
  Genre2["REGGAE"] = "Reggae";
  Genre2["PODCASTS"] = "Podcasts";
  Genre2["COUNTRY"] = "Country";
  Genre2["SPOKEN_WORK"] = "Spoken Word";
  Genre2["COMEDY"] = "Comedy";
  Genre2["BLUES"] = "Blues";
  Genre2["KIDS"] = "Kids";
  Genre2["AUDIOBOOKS"] = "Audiobooks";
  Genre2["LATIN"] = "Latin";
  Genre2["LOFI"] = "Lo-Fi";
  Genre2["HYPERPOP"] = "Hyperpop";
  Genre2["DANCEHALL"] = "Dancehall";
  Genre2["TECHNO"] = "Techno";
  Genre2["TRAP"] = "Trap";
  Genre2["HOUSE"] = "House";
  Genre2["TECH_HOUSE"] = "Tech House";
  Genre2["DEEP_HOUSE"] = "Deep House";
  Genre2["DISCO"] = "Disco";
  Genre2["ELECTRO"] = "Electro";
  Genre2["JUNGLE"] = "Jungle";
  Genre2["PROGRESSIVE_HOUSE"] = "Progressive House";
  Genre2["HARDSTYLE"] = "Hardstyle";
  Genre2["GLITCH_HOP"] = "Glitch Hop";
  Genre2["TRANCE"] = "Trance";
  Genre2["FUTURE_BASS"] = "Future Bass";
  Genre2["FUTURE_HOUSE"] = "Future House";
  Genre2["TROPICAL_HOUSE"] = "Tropical House";
  Genre2["DOWNTEMPO"] = "Downtempo";
  Genre2["DRUM_AND_BASS"] = "Drum & Bass";
  Genre2["DUBSTEP"] = "Dubstep";
  Genre2["JERSEY_CLUB"] = "Jersey Club";
  Genre2["VAPORWAVE"] = "Vaporwave";
  Genre2["MOOMBAHTON"] = "Moombahton";
})(Genre || (Genre = {}));
var OptionalHashId = z.string().nullable().optional().transform((data) => {
  var _decodeHashId;
  return data ? (_decodeHashId = decodeHashId(data)) !== null && _decodeHashId !== void 0 ? _decodeHashId : void 0 : void 0;
});
var HashId = z.string().transform((data, context) => {
  const id = decodeHashId(data);
  if (id === null) {
    context.addIssue({
      code: z.ZodIssueCode.custom,
      message: "Hash id is invalid"
    });
    return z.NEVER;
  }
  return id;
});
var OptionalId = z.number().nullable().optional().transform((data) => {
  var _encodeHashId;
  return data ? (_encodeHashId = encodeHashId(data)) !== null && _encodeHashId !== void 0 ? _encodeHashId : void 0 : void 0;
});
var Id2 = z.number().transform((data, context) => {
  const id = encodeHashId(data);
  if (id === null) {
    context.addIssue({
      code: z.ZodIssueCode.custom,
      message: "Hash id is invalid"
    });
    return z.NEVER;
  }
  return id;
});
var Mood;
(function(Mood2) {
  Mood2["PEACEFUL"] = "Peaceful";
  Mood2["ROMANTIC"] = "Romantic";
  Mood2["SENTIMENTAL"] = "Sentimental";
  Mood2["TENDER"] = "Tender";
  Mood2["EASYGOING"] = "Easygoing";
  Mood2["YEARNING"] = "Yearning";
  Mood2["SOPHISTICATED"] = "Sophisticated";
  Mood2["SENSUAL"] = "Sensual";
  Mood2["COOL"] = "Cool";
  Mood2["GRITTY"] = "Gritty";
  Mood2["MELANCHOLY"] = "Melancholy";
  Mood2["SERIOUS"] = "Serious";
  Mood2["BROODING"] = "Brooding";
  Mood2["FIERY"] = "Fiery";
  Mood2["DEFIANT"] = "Defiant";
  Mood2["AGGRESSIVE"] = "Aggressive";
  Mood2["ROWDY"] = "Rowdy";
  Mood2["EXCITED"] = "Excited";
  Mood2["ENERGIZING"] = "Energizing";
  Mood2["EMPOWERING"] = "Empowering";
  Mood2["STIRRING"] = "Stirring";
  Mood2["UPBEAT"] = "Upbeat";
  Mood2["OTHER"] = "Other";
})(Mood || (Mood = {}));
var PublicKeySchema = z.union([z.string().transform((data, ctx) => {
  try {
    return new PublicKey(data);
  } catch (e) {
    ctx.addIssue({
      code: z.ZodIssueCode.custom,
      message: e instanceof Error ? e.message : "Invalid PublicKey input"
    });
  }
  return z.NEVER;
}), z.custom((data) => {
  return data instanceof PublicKey;
})]);
var TokenNameSchema = z.enum(["wAUDIO", "USDC", "BONK"]);
var MintSchema = z.union([TokenNameSchema, PublicKeySchema]);
var RelaySchema = z.object({
  transaction: z.custom(),
  /**
   * Confirmation options used when sending the transaction on the server.
   * @see {@link https://solana-labs.github.io/solana-web3.js/classes/Connection.html#confirmTransaction confirmTransaction}
   */
  confirmationOptions: z.object({
    /**
     * The confirmation strategy to use when confirming.
     * @see {@link https://solana-labs.github.io/solana-web3.js/types/TransactionConfirmationStrategy.html ConfirmationStrategy}
     * @see {@link https://solana-labs.github.io/solana-web3.js/types/DurableNonceTransactionConfirmationStrategy.html DurableNonceTransactionConfirmationStrategy}
     * @see {@link https://solana-labs.github.io/solana-web3.js/types/BlockheightBasedTransactionConfirmationStrategy.html BlockhashBasedTransactionConfirmationStrategy}
     */
    strategy: z.union([z.object({
      blockhash: z.string(),
      lastValidBlockHeight: z.number()
    }), z.object({
      minContextSlot: z.number(),
      nonceAccountPubkey: PublicKeySchema,
      nonceValue: z.string()
    })]).optional(),
    /**
     * The commitment the server should confirm before responding.
     * Leave unset to have the server respond immediately after sending.
     * @see {@link https://solana-labs.github.io/solana-web3.js/types/Commitment.html Commitment}
     */
    commitment: z.enum(["processed", "confirmed", "finalized", "recent", "single", "singleGossip", "root", "max"]).optional()
  }).optional(),
  /**
   * Custom send options used when sending the transaction on the relay.
   * @see {@link https://solana-labs.github.io/solana-web3.js/types/SendOptions.html SendOptions}
   */
  sendOptions: z.custom().optional()
}).strict();
var LaunchCoinSchema = z.object({
  name: z.string().min(1, "Name is required"),
  symbol: z.string().min(1, "Symbol is required"),
  description: z.string().min(1, "Description is required"),
  walletPublicKey: PublicKeySchema,
  initialBuyAmountAudio: z.string().optional(),
  image: z.custom((data) => {
    return data instanceof Blob;
  }, "Image file is required")
}).strict();
var SolanaRelay = class extends BaseAPI$1 {
  constructor() {
    super(...arguments);
    _defineProperty$1(this, "feePayer", null);
  }
  /**
   * Gets a random fee payer public key from the selected discovery node's
   * Solana relay plugin.
   *
   * Used when relay transactions don't specify a fee payer override.
   */
  async getFeePayer(initOverrides) {
    if (this.feePayer !== null) {
      return this.feePayer;
    }
    const headerParameters = {
      "Content-Type": "application/json"
    };
    const response = await this.request({
      path: "/feePayer",
      method: "GET",
      headers: headerParameters
    }, initOverrides);
    const {
      feePayer
    } = await new JSONApiResponse$1(response, (json) => ({
      feePayer: !exists$2(json, "feePayer") ? void 0 : new PublicKey(json.feePayer)
    })).value();
    if (!feePayer) {
      throw new Error("Failed to get fee payer!");
    }
    this.feePayer = feePayer;
    return this.feePayer;
  }
  /**
   * Gets a location instruction to be sent along with a transaction.
   */
  async getLocationInstruction(initOverrides) {
    const headerParameters = {
      "Content-Type": "application/json"
    };
    const response = await this.request({
      path: "/instruction/location",
      method: "GET",
      headers: headerParameters
    }, initOverrides);
    const {
      instruction
    } = await new JSONApiResponse$1(response, (json) => ({
      instruction: new TransactionInstruction({
        keys: json.instruction.keys,
        programId: new PublicKey(json.instruction.programId),
        data: Buffer.from(json.instruction.data)
      })
    })).value();
    if (!instruction) {
      throw new Error("Failed to get instruction!");
    }
    return instruction;
  }
  /**
   * Relays a transaction to the selected discovery node's Solana relay plugin.
   */
  async relay(params, initOverrides) {
    const {
      transaction,
      confirmationOptions,
      sendOptions
    } = await parseParams("relay", RelaySchema)(params);
    const headerParameters = {
      "Content-Type": "application/json"
    };
    const body = {
      transaction: Buffer.from(transaction.serialize()).toString("base64"),
      confirmationOptions,
      sendOptions
    };
    let response;
    try {
      response = await this.request({
        path: "/relay",
        method: "POST",
        headers: headerParameters,
        body
      }, initOverrides);
    } catch (e) {
      if (e instanceof Error && e.name === "ResponseError") {
        const resp = e.response.clone();
        const body2 = await resp.json();
        if ("error" in body2 && "transactionMessage" in body2 && "signature" in body2) {
          throw new SendTransactionError({
            action: body2.error.indexOf("Simulation") > -1 ? "simulate" : "send",
            signature: body2.signature,
            transactionMessage: body2.transactionMessage,
            logs: body2.transactionLogs
          });
        }
      }
      throw e;
    }
    return await new JSONApiResponse$1(response, (json) => {
      if (!exists$2(json, "signature")) {
        throw new Error("Signature missing");
      }
      return {
        signature: json.signature
      };
    }).value();
  }
  /**
   * Launches a new artist coin on the launchpad with bonding curve.
   */
  async launchCoin(params) {
    const {
      name,
      symbol,
      description,
      walletPublicKey,
      initialBuyAmountAudio,
      image
    } = await parseParams("launchCoin", LaunchCoinSchema)(params);
    const headerParameters = {};
    const formData = new FormData();
    formData.append("name", name);
    formData.append("symbol", symbol);
    formData.append("description", description);
    formData.append("walletPublicKey", walletPublicKey.toBase58());
    if (initialBuyAmountAudio) {
      formData.append("initialBuyAmountAudio", initialBuyAmountAudio.toString());
    }
    formData.append("image", image);
    const response = await this.request({
      path: "/launchpad/launch_coin",
      method: "POST",
      headers: headerParameters,
      body: formData
    });
    return await new JSONApiResponse$1(response, (json) => {
      if (!exists$2(json, "mintPublicKey")) {
        throw new Error("mintPublicKey missing from response");
      }
      if (!exists$2(json, "createPoolTx")) {
        throw new Error("createPoolTx missing from response");
      }
      if (!exists$2(json, "imageUri")) {
        throw new Error("imageUri missing from response");
      }
      return json;
    }).value();
  }
  /**
   * Gets a quote for the first buy transaction on the launchpad.
   * Returns quotes for SOL to AUDIO, SOL to USDC, and the bonding curve quote.
   */
  async getFirstBuyQuote(params, requestInitOverrides) {
    const audioInputAmount = "audioInputAmount" in params ? params.audioInputAmount : void 0;
    const tokenOutputAmount = "tokenOutputAmount" in params ? params.tokenOutputAmount : void 0;
    const noAudioInput = !audioInputAmount;
    const noTokenInput = !tokenOutputAmount;
    if (noAudioInput && noTokenInput) {
      throw new Error("Invalid arguments. Either solInputAmount or tokenOutputAmount must be provided");
    }
    const headerParameters = {};
    const queryParameters = audioInputAmount ? {
      audioInputAmount
    } : {
      tokenOutputAmount
    };
    const response = await this.request({
      path: "/launchpad/first_buy_quote",
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, requestInitOverrides);
    return await new JSONApiResponse$1(response, (json) => {
      if (!exists$2(json, "audioInputAmount")) {
        throw new Error("audioInputAmount missing from response");
      }
      if (!exists$2(json, "usdcValue")) {
        throw new Error("usdcValue missing from response");
      }
      if (!exists$2(json, "tokenOutputAmount")) {
        throw new Error("tokenOutputAmount missing from response");
      }
      return {
        usdcValue: json.usdcValue,
        tokenOutputAmount: json.tokenOutputAmount,
        audioInputAmount: json.audioInputAmount,
        maxAudioInputAmount: json.maxAudioInputAmount,
        maxTokenOutputAmount: json.maxTokenOutputAmount
      };
    }).value();
  }
  /**
   * Gets launchpad config details such as max input/outut amounts & starting price.
   * These values only change if we decide to change our launchpad coin launch params.
   * We pull them from the server just to avoid having to hardcode values in the UI.
   */
  async getLaunchpadConfig(requestInitOverrides) {
    const headerParameters = {
      "Content-Type": "application/json"
    };
    const queryParameters = {};
    const response = await this.request({
      path: "/launchpad/config",
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, requestInitOverrides);
    return await new JSONApiResponse$1(response, (json) => {
      return json;
    }).value();
  }
  /**
   * Claims creator trading fees from a dynamic bonding curve pool.
   */
  async claimFees(params, initOverrides) {
    const headerParameters = {
      "Content-Type": "application/json"
    };
    const queryParameters = {
      tokenMint: params.tokenMint,
      ownerWalletAddress: params.ownerWalletAddress,
      receiverWalletAddress: params.receiverWalletAddress
    };
    const response = await this.request({
      path: "/launchpad/claim_fees",
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return await new JSONApiResponse$1(response, (json) => {
      return json;
    }).value();
  }
};
var SolanaRelayWalletAdapter = class {
  constructor(_ref) {
    let {
      solanaRelay
    } = _ref;
    _defineProperty$1(this, "name", "AudiusSolanaWallet");
    _defineProperty$1(this, "url", "");
    _defineProperty$1(this, "icon", "");
    _defineProperty$1(this, "readyState", "Loadable");
    _defineProperty$1(this, "supportedTransactionVersions", void 0);
    _defineProperty$1(this, "solanaRelay", void 0);
    _defineProperty$1(this, "_publicKey", null);
    _defineProperty$1(this, "_connecting", false);
    _defineProperty$1(this, "_connected", false);
    this.solanaRelay = solanaRelay;
  }
  get publicKey() {
    return this._publicKey;
  }
  get connecting() {
    return this._connecting;
  }
  get connected() {
    return this._connected;
  }
  async autoConnect() {
    await this.connect();
  }
  /**
   * On connection, grabs the fee payer from the Discovery Node plugin.
   */
  async connect() {
    this._connecting = true;
    this._publicKey = await this.solanaRelay.getFeePayer();
    if (!this._publicKey) {
      throw new Error("Failed to connect SolanaRelayWalletAdapter: Failed to get fee payer.");
    }
    this._connecting = false;
    this._connected = true;
  }
  async disconnect() {
    this._connected = false;
    this._publicKey = null;
  }
  /**
   * Sends a transaction using the relay to Discovery Node.
   * @param transaction the transaction to send.
   */
  async sendTransaction(transaction, _connection, sendOptions) {
    const {
      signature: signature2
    } = await this.solanaRelay.relay({
      transaction,
      sendOptions
    });
    return signature2;
  }
};
var productionConfig = {
  network: {
    minVersion: "0.7.0",
    apiEndpoint: "https://api.audius.co",
    storageNodes: [{
      endpoint: "https://creatornode.audius.co",
      delegateOwnerWallet: "0xc8d0C29B6d540295e8fc8ac72456F2f4D41088c8"
    }, {
      endpoint: "https://creatornode2.audius.co",
      delegateOwnerWallet: "0xf686647E3737d595C60c6DE2f5F90463542FE439"
    }, {
      endpoint: "https://creatornode3.audius.co",
      delegateOwnerWallet: "0x0C32BE6328578E99b6F06E0e7A6B385EB8FC13d1"
    }, {
      endpoint: "https://audius-content-1.figment.io",
      delegateOwnerWallet: "0xBfdE9a7DD3620CB6428463E9A9e9932B4d10fdc5"
    }, {
      endpoint: "https://creatornode.audius.prod-eks-ap-northeast-1.staked.cloud",
      delegateOwnerWallet: "0x675086B880260D217963cF14F503272AEb44b2E9"
    }, {
      endpoint: "https://audius-content-2.figment.io",
      delegateOwnerWallet: "0x6444212FFc23a4CcF7460f8Fe6D0e6074db59036"
    }, {
      endpoint: "https://audius-content-3.figment.io",
      delegateOwnerWallet: "0xECEDCaABecb40ef4bE733BA47FaD612aeA1F396F"
    }, {
      endpoint: "https://audius-content-4.figment.io",
      delegateOwnerWallet: "0x08fEF3884Db16E2E6211272cdC9Eee68E8b63b09"
    }, {
      endpoint: "https://audius-content-5.figment.io",
      delegateOwnerWallet: "0x10fF8197f2e94eF880d940D2414E0A14983c3bFE"
    }, {
      endpoint: "https://creatornode.audius1.prod-eks-ap-northeast-1.staked.cloud",
      delegateOwnerWallet: "0xC23Ee959E0B22a9B0F5dF18D7e7875cA4B6c4236"
    }, {
      endpoint: "https://creatornode.audius2.prod-eks-ap-northeast-1.staked.cloud",
      delegateOwnerWallet: "0x51a5575dc04c1f5f2e39390d090aaf78554F5f7B"
    }, {
      endpoint: "https://creatornode.audius3.prod-eks-ap-northeast-1.staked.cloud",
      delegateOwnerWallet: "0xe0b56BAe2276E016d3DB314Dd7374e596B0457ac"
    }, {
      endpoint: "https://audius-content-6.figment.io",
      delegateOwnerWallet: "0x68a4Bd6b4177ffB025AF9844cBE4Fe31348AEE1D"
    }, {
      endpoint: "https://audius-content-7.figment.io",
      delegateOwnerWallet: "0xf45a6DBf3ce0201F4012a19b1fB04D4f05B53a37"
    }, {
      endpoint: "https://audius-content-8.figment.io",
      delegateOwnerWallet: "0x9708Fb04DeA029212126255B311a21F1F884cCB4"
    }, {
      endpoint: "https://audius-content-9.figment.io",
      delegateOwnerWallet: "0x7c34c9709ed69513D55dF2020e799DA44fC52E6e"
    }, {
      endpoint: "https://audius-content-10.figment.io",
      delegateOwnerWallet: "0xff753331CEa586DD5B23bd21222a3c902909F2dd"
    }, {
      endpoint: "https://audius-content-11.figment.io",
      delegateOwnerWallet: "0xC9721F892BcC8822eb34237E875BE93904f11073"
    }, {
      endpoint: "https://content.grassfed.network",
      delegateOwnerWallet: "0x33Ab85445c8A2690B9488e9fB5E6A9849d3a18d3"
    }, {
      endpoint: "https://blockdaemon-audius-content-01.bdnodes.net",
      delegateOwnerWallet: "0x807C0fba7405aeb8b6a37A974df6259C6aB9bB1e"
    }, {
      endpoint: "https://audius-content-1.cultur3stake.com",
      delegateOwnerWallet: "0xCEb6a23d6132Cfe329b3c8E3c45f9DDc28A62Bd4"
    }, {
      endpoint: "https://audius-content-2.cultur3stake.com",
      delegateOwnerWallet: "0x2e9e7A4e35C3136fB651a0dBF8f91c9f5C27BBf7"
    }, {
      endpoint: "https://audius-content-3.cultur3stake.com",
      delegateOwnerWallet: "0x742da6cAc2782FeA961bB7B9150a048F5167D1e1"
    }, {
      endpoint: "https://audius-content-4.cultur3stake.com",
      delegateOwnerWallet: "0xcbb0cE7481685587b0988195Ff0cD6AA1A701657"
    }, {
      endpoint: "https://audius-content-5.cultur3stake.com",
      delegateOwnerWallet: "0xFec4708155277D35d568aD6Ca322262577683584"
    }, {
      endpoint: "https://audius-content-6.cultur3stake.com",
      delegateOwnerWallet: "0x3Db0E61591063310eEd22fd57E6f7F1ab2Bb538E"
    }, {
      endpoint: "https://audius-content-7.cultur3stake.com",
      delegateOwnerWallet: "0xE6C00e7E8d582fD2856718a5439f1aeEB68e27E5"
    }, {
      endpoint: "https://blockdaemon-audius-content-02.bdnodes.net",
      delegateOwnerWallet: "0x4Ad694B3fC34b3cC245aF6AA7B43C52ddD0d7AAE"
    }, {
      endpoint: "https://blockdaemon-audius-content-03.bdnodes.net",
      delegateOwnerWallet: "0x8ea81225013719950E968DE0602c4Eca458fA9f4"
    }, {
      endpoint: "https://blockdaemon-audius-content-04.bdnodes.net",
      delegateOwnerWallet: "0xcfFA8ACF0b04d9278eEE13928be264b2E9aaab97"
    }, {
      endpoint: "https://blockdaemon-audius-content-05.bdnodes.net",
      delegateOwnerWallet: "0xB4Ff0cab630FB05a7fcEfec9E979a968b8f4fE55"
    }, {
      endpoint: "https://blockdaemon-audius-content-06.bdnodes.net",
      delegateOwnerWallet: "0x7449da7d1548C11c481b87667EC9b2A8F20C13A0"
    }, {
      endpoint: "https://blockdaemon-audius-content-07.bdnodes.net",
      delegateOwnerWallet: "0x00B1CA1A34257860f66e742eF163Ad30bF42d075"
    }, {
      endpoint: "https://blockdaemon-audius-content-08.bdnodes.net",
      delegateOwnerWallet: "0x16650eDB44C720ea627d5a59ff0b4f74c37fe419"
    }, {
      endpoint: "https://blockdaemon-audius-content-09.bdnodes.net",
      delegateOwnerWallet: "0xD5Cfcf4149c683516239fc653D5a470F3F4A606D"
    }, {
      endpoint: "https://audius-content-8.cultur3stake.com",
      delegateOwnerWallet: "0xff432F81D0eb77DA5973Cf55e24A897882fdd3E6"
    }, {
      endpoint: "https://blockchange-audius-content-01.bdnodes.net",
      delegateOwnerWallet: "0x8464c88502925a0076c381962F8B70b6EC892861"
    }, {
      endpoint: "https://blockchange-audius-content-02.bdnodes.net",
      delegateOwnerWallet: "0x5e0D0BeDC11F0B512457f6f707A35703b1447Fb5"
    }, {
      endpoint: "https://blockchange-audius-content-03.bdnodes.net",
      delegateOwnerWallet: "0xe3F1c416c3919bB2ffD78F1e38b9E81E8c80815F"
    }, {
      endpoint: "https://audius-content-9.cultur3stake.com",
      delegateOwnerWallet: "0xB6f506557B2e9026743FeA6157e52F204D26690F"
    }, {
      endpoint: "https://audius-content-10.cultur3stake.com",
      delegateOwnerWallet: "0x2AF4598D3CF95D8e76987c02BC8A8D71F58d49d5"
    }, {
      endpoint: "https://audius-content-11.cultur3stake.com",
      delegateOwnerWallet: "0xB2684Cca5281d2bA6D9Ce66Cca215635FF2Ba466"
    }, {
      endpoint: "https://audius-content-12.cultur3stake.com",
      delegateOwnerWallet: "0x28924C99822eA08bFCeDdE3a411308633948b349"
    }, {
      endpoint: "https://audius-content-13.cultur3stake.com",
      delegateOwnerWallet: "0xcb23908aa0dCDef762ebEaA38391D8fFC69E6e8F"
    }, {
      endpoint: "https://audius-content-14.cultur3stake.com",
      delegateOwnerWallet: "0xCbDa351492e52fdb2f0E7FBc440cA2047738b71C"
    }, {
      endpoint: "https://audius-content-15.cultur3stake.com",
      delegateOwnerWallet: "0x2fE2652296c40BB22D33C6379558Bf63A25b4f9a"
    }, {
      endpoint: "https://audius-content-16.cultur3stake.com",
      delegateOwnerWallet: "0x47367ED3Db5D9691d866cb09545DE7cccD571579"
    }, {
      endpoint: "https://audius-content-17.cultur3stake.com",
      delegateOwnerWallet: "0xb472c555Ab9eA1D33543383d6d1F8885c97eF83A"
    }, {
      endpoint: "https://audius-content-18.cultur3stake.com",
      delegateOwnerWallet: "0x4F62C17Dc54E58289354847974E1F246c8EAcf11"
    }, {
      endpoint: "https://audius-content-12.figment.io",
      delegateOwnerWallet: "0x780641e157621621658F118375dc1B36Ea514d46"
    }, {
      endpoint: "https://cn0.mainnet.audiusindex.org",
      delegateOwnerWallet: "0xf9b373E223b73473C59034072263f52aEF60133B"
    }, {
      endpoint: "https://cn1.mainnet.audiusindex.org",
      delegateOwnerWallet: "0x9b0D01bd7F01BD6916Ba139743Ce9C524B9375Dd"
    }, {
      endpoint: "https://cn2.mainnet.audiusindex.org",
      delegateOwnerWallet: "0xf6e297203c0086dc229DAE17F5b61a15F42A1A00"
    }, {
      endpoint: "https://cn3.mainnet.audiusindex.org",
      delegateOwnerWallet: "0x24C4b2cb6eC4c87a03F66723d8750dbe98Fa3e4f"
    }, {
      endpoint: "https://audius-content-13.figment.io",
      delegateOwnerWallet: "0x33a2da466B14990E0124383204b06F9196f62d8e"
    }, {
      endpoint: "https://audius-content-14.figment.io",
      delegateOwnerWallet: "0x817c513C1B702eA0BdD4F8C1204C60372f715006"
    }, {
      endpoint: "https://cn4.mainnet.audiusindex.org",
      delegateOwnerWallet: "0x69e749266C59757dA81F8C659Be6B07ce5Bac6C9"
    }, {
      endpoint: "https://audius-creator-1.theblueprint.xyz",
      delegateOwnerWallet: "0x0E0aF7035581C615d07372be16D99A9B64E5B2e9"
    }, {
      endpoint: "https://audius-creator-2.theblueprint.xyz",
      delegateOwnerWallet: "0x3D0dD2Cd46c2658d228769f4a394662946A28987"
    }, {
      endpoint: "https://audius-creator-3.theblueprint.xyz",
      delegateOwnerWallet: "0x292B0d5987a7DE879909C48a54f0853C211da5f3"
    }, {
      endpoint: "https://audius-creator-4.theblueprint.xyz",
      delegateOwnerWallet: "0xA815f8108C2772D24D7DCB866c861148f043224D"
    }, {
      endpoint: "https://audius-creator-5.theblueprint.xyz",
      delegateOwnerWallet: "0x65Fe5BEf65A0E0b0520d6beE7767ea6Da7f792f6"
    }, {
      endpoint: "https://audius-creator-6.theblueprint.xyz",
      delegateOwnerWallet: "0x19B026B0f0Dbf619DBf8C4Efb0190308ace56366"
    }, {
      endpoint: "https://creatornode.audius8.prod-eks-ap-northeast-1.staked.cloud",
      delegateOwnerWallet: "0xc69F344FCDbc9D747559c968562f682ABfBa442C"
    }, {
      endpoint: "https://cn1.stuffisup.com",
      delegateOwnerWallet: "0x0D16f8bBfFF114B1a525Bf8b8d98ED177FA74AD3"
    }, {
      endpoint: "https://audius-cn1.tikilabs.com",
      delegateOwnerWallet: "0x159200F84c2cF000b3A014cD4D8244500CCc36ca"
    }, {
      endpoint: "https://audius-creator-7.theblueprint.xyz",
      delegateOwnerWallet: "0x720758adEa33433833c14e2516fA421261D0875e"
    }, {
      endpoint: "https://cn1.shakespearetech.com",
      delegateOwnerWallet: "0x44955AD360652c302644F564B42D1458C584A4ec"
    }, {
      endpoint: "https://cn2.shakespearetech.com",
      delegateOwnerWallet: "0x68835714d9c208f9d6F4953F0555507e492fd898"
    }, {
      endpoint: "https://cn3.shakespearetech.com",
      delegateOwnerWallet: "0x7162Ee2b7F0cB9651fd2FA2838B0CAF225B2a8D3"
    }, {
      endpoint: "https://audius-creator-8.theblueprint.xyz",
      delegateOwnerWallet: "0x078842E88B82e6a69549043269AE3aADD5581105"
    }, {
      endpoint: "https://audius-creator-9.theblueprint.xyz",
      delegateOwnerWallet: "0x2DfC8152eF49e91b83638ad2bd0D2F9efC6f65b5"
    }, {
      endpoint: "https://audius-creator-10.theblueprint.xyz",
      delegateOwnerWallet: "0x97BcBFA8289731d694440795094E831599Ab7A11"
    }, {
      endpoint: "https://audius-creator-11.theblueprint.xyz",
      delegateOwnerWallet: "0xfe38c5Ea3579c9333fE302414fe1895F7a320beF"
    }, {
      endpoint: "https://audius-creator-12.theblueprint.xyz",
      delegateOwnerWallet: "0x8C78ef541135e2cb037f91109fb8EE780fa4709d"
    }, {
      endpoint: "https://audius-creator-13.theblueprint.xyz",
      delegateOwnerWallet: "0x75D2269D18C59CC2ED00a63a40367AC495E3F330"
    }],
    antiAbuseOracleNodes: {
      endpoints: ["https://discoveryprovider.audius.co", "https://audius-oracle.creatorseed.com", "https://oracle.audius.endl.net"],
      registeredAddresses: ["0x9811BA3eAB1F2Cd9A2dFeDB19e8c2a69729DC8b6", "0xe60d50356cd891f56B744165fcc1D8B352201A76", "0x7A03cFAE79266683D9706731D6E187868E939c9C"]
    },
    identityService: "https://identityservice.audius.co"
  },
  acdc: {
    entityManagerContractAddress: "0x1Cd8a543596D499B9b6E7a6eC15ECd2B7857Fd64",
    chainId: 31524
  },
  solana: {
    claimableTokensProgramAddress: "Ewkv3JahEFRKkcJmpoKB7pXbnUHwjAyXiwEo4ZY2rezQ",
    rewardManagerProgramAddress: "DDZDcYdQFEMwcu2Mwo75yGFjJ1mUQyyXLWzhZLEVFcei",
    rewardManagerStateAddress: "71hWFVYokLaN1PNYzTAWi13EfJ7Xt9VbSWUKsXUT8mxE",
    paymentRouterProgramAddress: "paytYpX3LPN98TAeen6bFFeraGSuWnomZmCXjAsoqPa",
    stakingBridgeProgramAddress: "stkB5DZziVJT1C1VmzvDdRtdWxfs5nwcHViiaNBDK31",
    rpcEndpoint: "https://audius-fe.rpcpool.com",
    usdcTokenMint: "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v",
    wAudioTokenMint: "9LzCMqDgTKYz9Drzqnpgee3SGa89up3a247ypMj2xrqM",
    bonkTokenMint: "DezXAZ8z7PnrnRJjz3wXBoRgixCa6xjnB7YaB1pPB263",
    rewardManagerLookupTableAddress: "4UQwpGupH66RgQrWRqmPM9Two6VJEE68VZ7GeqZ3mvVv"
  },
  ethereum: {
    rpcEndpoint: "https://eth-client.audius.co",
    addresses: {
      ethRewardsManagerAddress: "0x5aa6B99A2B461bA8E97207740f0A689C5C39C3b0",
      serviceProviderFactoryAddress: "0xD17A9bc90c582249e211a4f4b16721e7f65156c8",
      serviceTypeManagerAddress: "0x9EfB0f4F38aFbb4b0984D00C126E97E21b8417C5",
      audiusTokenAddress: "0x18aAA7115705e8be94bfFEBDE57Af9BFc265B998",
      audiusWormholeAddress: "0x6E7a1F7339bbB62b23D44797b63e4258d283E095",
      delegateManagerAddress: "0x4d7968ebfD390D5E7926Cb3587C39eFf2F9FB225",
      stakingAddress: "0xe6D97B2099F142513be7A2a068bE040656Ae4591"
    }
  }
};
var commonjsGlobal2 = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function listCacheClear$1() {
  this.__data__ = [];
  this.size = 0;
}
var _listCacheClear = listCacheClear$1;
function eq$4(value, other) {
  return value === other || value !== value && other !== other;
}
var eq_1 = eq$4;
var eq$3 = eq_1;
function assocIndexOf$4(array4, key) {
  var length2 = array4.length;
  while (length2--) {
    if (eq$3(array4[length2][0], key)) {
      return length2;
    }
  }
  return -1;
}
var _assocIndexOf = assocIndexOf$4;
var assocIndexOf$3 = _assocIndexOf;
var arrayProto = Array.prototype;
var splice = arrayProto.splice;
function listCacheDelete$1(key) {
  var data = this.__data__, index4 = assocIndexOf$3(data, key);
  if (index4 < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index4 == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index4, 1);
  }
  --this.size;
  return true;
}
var _listCacheDelete = listCacheDelete$1;
var assocIndexOf$2 = _assocIndexOf;
function listCacheGet$1(key) {
  var data = this.__data__, index4 = assocIndexOf$2(data, key);
  return index4 < 0 ? void 0 : data[index4][1];
}
var _listCacheGet = listCacheGet$1;
var assocIndexOf$1 = _assocIndexOf;
function listCacheHas$1(key) {
  return assocIndexOf$1(this.__data__, key) > -1;
}
var _listCacheHas = listCacheHas$1;
var assocIndexOf = _assocIndexOf;
function listCacheSet$1(key, value) {
  var data = this.__data__, index4 = assocIndexOf(data, key);
  if (index4 < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index4][1] = value;
  }
  return this;
}
var _listCacheSet = listCacheSet$1;
var listCacheClear = _listCacheClear;
var listCacheDelete = _listCacheDelete;
var listCacheGet = _listCacheGet;
var listCacheHas = _listCacheHas;
var listCacheSet = _listCacheSet;
function ListCache$4(entries) {
  var index4 = -1, length2 = entries == null ? 0 : entries.length;
  this.clear();
  while (++index4 < length2) {
    var entry = entries[index4];
    this.set(entry[0], entry[1]);
  }
}
ListCache$4.prototype.clear = listCacheClear;
ListCache$4.prototype["delete"] = listCacheDelete;
ListCache$4.prototype.get = listCacheGet;
ListCache$4.prototype.has = listCacheHas;
ListCache$4.prototype.set = listCacheSet;
var _ListCache = ListCache$4;
var ListCache$3 = _ListCache;
function stackClear$1() {
  this.__data__ = new ListCache$3();
  this.size = 0;
}
var _stackClear = stackClear$1;
function stackDelete$1(key) {
  var data = this.__data__, result = data["delete"](key);
  this.size = data.size;
  return result;
}
var _stackDelete = stackDelete$1;
function stackGet$1(key) {
  return this.__data__.get(key);
}
var _stackGet = stackGet$1;
function stackHas$1(key) {
  return this.__data__.has(key);
}
var _stackHas = stackHas$1;
var freeGlobal$1 = typeof commonjsGlobal2 == "object" && commonjsGlobal2 && commonjsGlobal2.Object === Object && commonjsGlobal2;
var _freeGlobal = freeGlobal$1;
var freeGlobal = _freeGlobal;
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root$4 = freeGlobal || freeSelf || Function("return this")();
var _root = root$4;
var root$3 = _root;
var Symbol$3 = root$3.Symbol;
var _Symbol = Symbol$3;
var Symbol$2 = _Symbol;
var objectProto$a = Object.prototype;
var hasOwnProperty$8 = objectProto$a.hasOwnProperty;
var nativeObjectToString$1 = objectProto$a.toString;
var symToStringTag$1 = Symbol$2 ? Symbol$2.toStringTag : void 0;
function getRawTag$1(value) {
  var isOwn = hasOwnProperty$8.call(value, symToStringTag$1), tag = value[symToStringTag$1];
  try {
    value[symToStringTag$1] = void 0;
    var unmasked = true;
  } catch (e) {
  }
  var result = nativeObjectToString$1.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag$1] = tag;
    } else {
      delete value[symToStringTag$1];
    }
  }
  return result;
}
var _getRawTag = getRawTag$1;
var objectProto$9 = Object.prototype;
var nativeObjectToString = objectProto$9.toString;
function objectToString$1(value) {
  return nativeObjectToString.call(value);
}
var _objectToString = objectToString$1;
var Symbol$1 = _Symbol;
var getRawTag = _getRawTag;
var objectToString = _objectToString;
var nullTag = "[object Null]";
var undefinedTag = "[object Undefined]";
var symToStringTag = Symbol$1 ? Symbol$1.toStringTag : void 0;
function baseGetTag$4(value) {
  if (value == null) {
    return value === void 0 ? undefinedTag : nullTag;
  }
  return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
}
var _baseGetTag = baseGetTag$4;
function isObject$8(value) {
  var type3 = typeof value;
  return value != null && (type3 == "object" || type3 == "function");
}
var isObject_1 = isObject$8;
var baseGetTag$3 = _baseGetTag;
var isObject$7 = isObject_1;
var asyncTag = "[object AsyncFunction]";
var funcTag$1 = "[object Function]";
var genTag = "[object GeneratorFunction]";
var proxyTag = "[object Proxy]";
function isFunction$4(value) {
  if (!isObject$7(value)) {
    return false;
  }
  var tag = baseGetTag$3(value);
  return tag == funcTag$1 || tag == genTag || tag == asyncTag || tag == proxyTag;
}
var isFunction_1 = isFunction$4;
var root$2 = _root;
var coreJsData$1 = root$2["__core-js_shared__"];
var _coreJsData = coreJsData$1;
var coreJsData = _coreJsData;
var maskSrcKey = (function() {
  var uid2 = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
  return uid2 ? "Symbol(src)_1." + uid2 : "";
})();
function isMasked$1(func) {
  return !!maskSrcKey && maskSrcKey in func;
}
var _isMasked = isMasked$1;
var funcProto$2 = Function.prototype;
var funcToString$2 = funcProto$2.toString;
function toSource$1(func) {
  if (func != null) {
    try {
      return funcToString$2.call(func);
    } catch (e) {
    }
    try {
      return func + "";
    } catch (e) {
    }
  }
  return "";
}
var _toSource = toSource$1;
var isFunction$3 = isFunction_1;
var isMasked = _isMasked;
var isObject$6 = isObject_1;
var toSource = _toSource;
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor = /^\[object .+?Constructor\]$/;
var funcProto$1 = Function.prototype;
var objectProto$8 = Object.prototype;
var funcToString$1 = funcProto$1.toString;
var hasOwnProperty$7 = objectProto$8.hasOwnProperty;
var reIsNative = RegExp("^" + funcToString$1.call(hasOwnProperty$7).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
function baseIsNative$1(value) {
  if (!isObject$6(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction$3(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}
var _baseIsNative = baseIsNative$1;
function getValue$1(object, key) {
  return object == null ? void 0 : object[key];
}
var _getValue = getValue$1;
var baseIsNative = _baseIsNative;
var getValue = _getValue;
function getNative$3(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : void 0;
}
var _getNative = getNative$3;
var getNative$2 = _getNative;
var root$1 = _root;
var Map$3 = getNative$2(root$1, "Map");
var _Map = Map$3;
var getNative$1 = _getNative;
var nativeCreate$4 = getNative$1(Object, "create");
var _nativeCreate = nativeCreate$4;
var nativeCreate$3 = _nativeCreate;
function hashClear$1() {
  this.__data__ = nativeCreate$3 ? nativeCreate$3(null) : {};
  this.size = 0;
}
var _hashClear = hashClear$1;
function hashDelete$1(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}
var _hashDelete = hashDelete$1;
var nativeCreate$2 = _nativeCreate;
var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
var objectProto$7 = Object.prototype;
var hasOwnProperty$6 = objectProto$7.hasOwnProperty;
function hashGet$1(key) {
  var data = this.__data__;
  if (nativeCreate$2) {
    var result = data[key];
    return result === HASH_UNDEFINED$1 ? void 0 : result;
  }
  return hasOwnProperty$6.call(data, key) ? data[key] : void 0;
}
var _hashGet = hashGet$1;
var nativeCreate$1 = _nativeCreate;
var objectProto$6 = Object.prototype;
var hasOwnProperty$5 = objectProto$6.hasOwnProperty;
function hashHas$1(key) {
  var data = this.__data__;
  return nativeCreate$1 ? data[key] !== void 0 : hasOwnProperty$5.call(data, key);
}
var _hashHas = hashHas$1;
var nativeCreate = _nativeCreate;
var HASH_UNDEFINED = "__lodash_hash_undefined__";
function hashSet$1(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
  return this;
}
var _hashSet = hashSet$1;
var hashClear = _hashClear;
var hashDelete = _hashDelete;
var hashGet = _hashGet;
var hashHas = _hashHas;
var hashSet = _hashSet;
function Hash$2(entries) {
  var index4 = -1, length2 = entries == null ? 0 : entries.length;
  this.clear();
  while (++index4 < length2) {
    var entry = entries[index4];
    this.set(entry[0], entry[1]);
  }
}
Hash$2.prototype.clear = hashClear;
Hash$2.prototype["delete"] = hashDelete;
Hash$2.prototype.get = hashGet;
Hash$2.prototype.has = hashHas;
Hash$2.prototype.set = hashSet;
var _Hash = Hash$2;
var Hash$1 = _Hash;
var ListCache$2 = _ListCache;
var Map$2 = _Map;
function mapCacheClear$1() {
  this.size = 0;
  this.__data__ = {
    "hash": new Hash$1(),
    "map": new (Map$2 || ListCache$2)(),
    "string": new Hash$1()
  };
}
var _mapCacheClear = mapCacheClear$1;
function isKeyable$1(value) {
  var type3 = typeof value;
  return type3 == "string" || type3 == "number" || type3 == "symbol" || type3 == "boolean" ? value !== "__proto__" : value === null;
}
var _isKeyable = isKeyable$1;
var isKeyable = _isKeyable;
function getMapData$4(map, key) {
  var data = map.__data__;
  return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
}
var _getMapData = getMapData$4;
var getMapData$3 = _getMapData;
function mapCacheDelete$1(key) {
  var result = getMapData$3(this, key)["delete"](key);
  this.size -= result ? 1 : 0;
  return result;
}
var _mapCacheDelete = mapCacheDelete$1;
var getMapData$2 = _getMapData;
function mapCacheGet$1(key) {
  return getMapData$2(this, key).get(key);
}
var _mapCacheGet = mapCacheGet$1;
var getMapData$1 = _getMapData;
function mapCacheHas$1(key) {
  return getMapData$1(this, key).has(key);
}
var _mapCacheHas = mapCacheHas$1;
var getMapData = _getMapData;
function mapCacheSet$1(key, value) {
  var data = getMapData(this, key), size4 = data.size;
  data.set(key, value);
  this.size += data.size == size4 ? 0 : 1;
  return this;
}
var _mapCacheSet = mapCacheSet$1;
var mapCacheClear = _mapCacheClear;
var mapCacheDelete = _mapCacheDelete;
var mapCacheGet = _mapCacheGet;
var mapCacheHas = _mapCacheHas;
var mapCacheSet = _mapCacheSet;
function MapCache$1(entries) {
  var index4 = -1, length2 = entries == null ? 0 : entries.length;
  this.clear();
  while (++index4 < length2) {
    var entry = entries[index4];
    this.set(entry[0], entry[1]);
  }
}
MapCache$1.prototype.clear = mapCacheClear;
MapCache$1.prototype["delete"] = mapCacheDelete;
MapCache$1.prototype.get = mapCacheGet;
MapCache$1.prototype.has = mapCacheHas;
MapCache$1.prototype.set = mapCacheSet;
var _MapCache = MapCache$1;
var ListCache$1 = _ListCache;
var Map$1 = _Map;
var MapCache = _MapCache;
var LARGE_ARRAY_SIZE = 200;
function stackSet$1(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache$1) {
    var pairs = data.__data__;
    if (!Map$1 || pairs.length < LARGE_ARRAY_SIZE - 1) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}
var _stackSet = stackSet$1;
var ListCache = _ListCache;
var stackClear = _stackClear;
var stackDelete = _stackDelete;
var stackGet = _stackGet;
var stackHas = _stackHas;
var stackSet = _stackSet;
function Stack$1(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}
Stack$1.prototype.clear = stackClear;
Stack$1.prototype["delete"] = stackDelete;
Stack$1.prototype.get = stackGet;
Stack$1.prototype.has = stackHas;
Stack$1.prototype.set = stackSet;
var _Stack = Stack$1;
var getNative = _getNative;
var defineProperty$2 = (function() {
  try {
    var func = getNative(Object, "defineProperty");
    func({}, "", {});
    return func;
  } catch (e) {
  }
})();
var _defineProperty = defineProperty$2;
var defineProperty$1 = _defineProperty;
function baseAssignValue$3(object, key, value) {
  if (key == "__proto__" && defineProperty$1) {
    defineProperty$1(object, key, {
      "configurable": true,
      "enumerable": true,
      "value": value,
      "writable": true
    });
  } else {
    object[key] = value;
  }
}
var _baseAssignValue = baseAssignValue$3;
var baseAssignValue$2 = _baseAssignValue;
var eq$2 = eq_1;
function assignMergeValue$2(object, key, value) {
  if (value !== void 0 && !eq$2(object[key], value) || value === void 0 && !(key in object)) {
    baseAssignValue$2(object, key, value);
  }
}
var _assignMergeValue = assignMergeValue$2;
function createBaseFor$1(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index4 = -1, iterable = Object(object), props = keysFunc(object), length2 = props.length;
    while (length2--) {
      var key = props[fromRight ? length2 : ++index4];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}
var _createBaseFor = createBaseFor$1;
var createBaseFor = _createBaseFor;
var baseFor$1 = createBaseFor();
var _baseFor = baseFor$1;
var _cloneBuffer = { exports: {} };
(function(module2, exports2) {
  var root2 = _root;
  var freeExports = exports2 && !exports2.nodeType && exports2;
  var freeModule = freeExports && true && module2 && !module2.nodeType && module2;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var Buffer4 = moduleExports ? root2.Buffer : void 0, allocUnsafe = Buffer4 ? Buffer4.allocUnsafe : void 0;
  function cloneBuffer2(buffer3, isDeep) {
    if (isDeep) {
      return buffer3.slice();
    }
    var length2 = buffer3.length, result = allocUnsafe ? allocUnsafe(length2) : new buffer3.constructor(length2);
    buffer3.copy(result);
    return result;
  }
  module2.exports = cloneBuffer2;
})(_cloneBuffer, _cloneBuffer.exports);
var root = _root;
var Uint8Array$2 = root.Uint8Array;
var _Uint8Array = Uint8Array$2;
var Uint8Array$1 = _Uint8Array;
function cloneArrayBuffer$1(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array$1(result).set(new Uint8Array$1(arrayBuffer));
  return result;
}
var _cloneArrayBuffer = cloneArrayBuffer$1;
var cloneArrayBuffer = _cloneArrayBuffer;
function cloneTypedArray$1(typedArray, isDeep) {
  var buffer3 = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer3, typedArray.byteOffset, typedArray.length);
}
var _cloneTypedArray = cloneTypedArray$1;
function copyArray$1(source, array4) {
  var index4 = -1, length2 = source.length;
  array4 || (array4 = Array(length2));
  while (++index4 < length2) {
    array4[index4] = source[index4];
  }
  return array4;
}
var _copyArray = copyArray$1;
var isObject$5 = isObject_1;
var objectCreate = Object.create;
var baseCreate$1 = /* @__PURE__ */ (function() {
  function object() {
  }
  return function(proto) {
    if (!isObject$5(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object.prototype = proto;
    var result = new object();
    object.prototype = void 0;
    return result;
  };
})();
var _baseCreate = baseCreate$1;
function overArg$1(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}
var _overArg = overArg$1;
var overArg = _overArg;
var getPrototype$2 = overArg(Object.getPrototypeOf, Object);
var _getPrototype = getPrototype$2;
var objectProto$5 = Object.prototype;
function isPrototype$2(value) {
  var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto$5;
  return value === proto;
}
var _isPrototype = isPrototype$2;
var baseCreate = _baseCreate;
var getPrototype$1 = _getPrototype;
var isPrototype$1 = _isPrototype;
function initCloneObject$1(object) {
  return typeof object.constructor == "function" && !isPrototype$1(object) ? baseCreate(getPrototype$1(object)) : {};
}
var _initCloneObject = initCloneObject$1;
function isObjectLike$5(value) {
  return value != null && typeof value == "object";
}
var isObjectLike_1 = isObjectLike$5;
var baseGetTag$2 = _baseGetTag;
var isObjectLike$4 = isObjectLike_1;
var argsTag$1 = "[object Arguments]";
function baseIsArguments$1(value) {
  return isObjectLike$4(value) && baseGetTag$2(value) == argsTag$1;
}
var _baseIsArguments = baseIsArguments$1;
var baseIsArguments = _baseIsArguments;
var isObjectLike$3 = isObjectLike_1;
var objectProto$4 = Object.prototype;
var hasOwnProperty$4 = objectProto$4.hasOwnProperty;
var propertyIsEnumerable = objectProto$4.propertyIsEnumerable;
var isArguments$2 = baseIsArguments(/* @__PURE__ */ (function() {
  return arguments;
})()) ? baseIsArguments : function(value) {
  return isObjectLike$3(value) && hasOwnProperty$4.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
};
var isArguments_1 = isArguments$2;
var isArray$2 = Array.isArray;
var isArray_1 = isArray$2;
var MAX_SAFE_INTEGER$1 = 9007199254740991;
function isLength$2(value) {
  return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER$1;
}
var isLength_1 = isLength$2;
var isFunction$2 = isFunction_1;
var isLength$1 = isLength_1;
function isArrayLike$3(value) {
  return value != null && isLength$1(value.length) && !isFunction$2(value);
}
var isArrayLike_1 = isArrayLike$3;
var isArrayLike$2 = isArrayLike_1;
var isObjectLike$2 = isObjectLike_1;
function isArrayLikeObject$1(value) {
  return isObjectLike$2(value) && isArrayLike$2(value);
}
var isArrayLikeObject_1 = isArrayLikeObject$1;
var isBuffer$2 = { exports: {} };
function stubFalse() {
  return false;
}
var stubFalse_1 = stubFalse;
(function(module2, exports2) {
  var root2 = _root, stubFalse2 = stubFalse_1;
  var freeExports = exports2 && !exports2.nodeType && exports2;
  var freeModule = freeExports && true && module2 && !module2.nodeType && module2;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var Buffer4 = moduleExports ? root2.Buffer : void 0;
  var nativeIsBuffer = Buffer4 ? Buffer4.isBuffer : void 0;
  var isBuffer2 = nativeIsBuffer || stubFalse2;
  module2.exports = isBuffer2;
})(isBuffer$2, isBuffer$2.exports);
var baseGetTag$1 = _baseGetTag;
var getPrototype = _getPrototype;
var isObjectLike$1 = isObjectLike_1;
var objectTag$1 = "[object Object]";
var funcProto = Function.prototype;
var objectProto$3 = Object.prototype;
var funcToString = funcProto.toString;
var hasOwnProperty$3 = objectProto$3.hasOwnProperty;
var objectCtorString = funcToString.call(Object);
function isPlainObject$1(value) {
  if (!isObjectLike$1(value) || baseGetTag$1(value) != objectTag$1) {
    return false;
  }
  var proto = getPrototype(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty$3.call(proto, "constructor") && proto.constructor;
  return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
}
var isPlainObject_1 = isPlainObject$1;
var baseGetTag = _baseGetTag;
var isLength = isLength_1;
var isObjectLike = isObjectLike_1;
var argsTag = "[object Arguments]";
var arrayTag = "[object Array]";
var boolTag = "[object Boolean]";
var dateTag = "[object Date]";
var errorTag = "[object Error]";
var funcTag = "[object Function]";
var mapTag = "[object Map]";
var numberTag = "[object Number]";
var objectTag = "[object Object]";
var regexpTag = "[object RegExp]";
var setTag = "[object Set]";
var stringTag = "[object String]";
var weakMapTag = "[object WeakMap]";
var arrayBufferTag = "[object ArrayBuffer]";
var dataViewTag = "[object DataView]";
var float32Tag = "[object Float32Array]";
var float64Tag = "[object Float64Array]";
var int8Tag = "[object Int8Array]";
var int16Tag = "[object Int16Array]";
var int32Tag = "[object Int32Array]";
var uint8Tag = "[object Uint8Array]";
var uint8ClampedTag = "[object Uint8ClampedArray]";
var uint16Tag = "[object Uint16Array]";
var uint32Tag = "[object Uint32Array]";
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
function baseIsTypedArray$1(value) {
  return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}
var _baseIsTypedArray = baseIsTypedArray$1;
function baseUnary$1(func) {
  return function(value) {
    return func(value);
  };
}
var _baseUnary = baseUnary$1;
var _nodeUtil = { exports: {} };
(function(module2, exports2) {
  var freeGlobal2 = _freeGlobal;
  var freeExports = exports2 && !exports2.nodeType && exports2;
  var freeModule = freeExports && true && module2 && !module2.nodeType && module2;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var freeProcess = moduleExports && freeGlobal2.process;
  var nodeUtil2 = (function() {
    try {
      var types = freeModule && freeModule.require && freeModule.require("util").types;
      if (types) {
        return types;
      }
      return freeProcess && freeProcess.binding && freeProcess.binding("util");
    } catch (e) {
    }
  })();
  module2.exports = nodeUtil2;
})(_nodeUtil, _nodeUtil.exports);
var baseIsTypedArray = _baseIsTypedArray;
var baseUnary = _baseUnary;
var nodeUtil = _nodeUtil.exports;
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
var isTypedArray$2 = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
var isTypedArray_1 = isTypedArray$2;
function safeGet$2(object, key) {
  if (key === "constructor" && typeof object[key] === "function") {
    return;
  }
  if (key == "__proto__") {
    return;
  }
  return object[key];
}
var _safeGet = safeGet$2;
var baseAssignValue$1 = _baseAssignValue;
var eq$1 = eq_1;
var objectProto$2 = Object.prototype;
var hasOwnProperty$2 = objectProto$2.hasOwnProperty;
function assignValue$1(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty$2.call(object, key) && eq$1(objValue, value)) || value === void 0 && !(key in object)) {
    baseAssignValue$1(object, key, value);
  }
}
var _assignValue = assignValue$1;
var assignValue = _assignValue;
var baseAssignValue = _baseAssignValue;
function copyObject$1(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});
  var index4 = -1, length2 = props.length;
  while (++index4 < length2) {
    var key = props[index4];
    var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
    if (newValue === void 0) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue(object, key, newValue);
    } else {
      assignValue(object, key, newValue);
    }
  }
  return object;
}
var _copyObject = copyObject$1;
function baseTimes$1(n, iteratee) {
  var index4 = -1, result = Array(n);
  while (++index4 < n) {
    result[index4] = iteratee(index4);
  }
  return result;
}
var _baseTimes = baseTimes$1;
var MAX_SAFE_INTEGER2 = 9007199254740991;
var reIsUint = /^(?:0|[1-9]\d*)$/;
function isIndex$2(value, length2) {
  var type3 = typeof value;
  length2 = length2 == null ? MAX_SAFE_INTEGER2 : length2;
  return !!length2 && (type3 == "number" || type3 != "symbol" && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length2;
}
var _isIndex = isIndex$2;
var baseTimes = _baseTimes;
var isArguments$1 = isArguments_1;
var isArray$1 = isArray_1;
var isBuffer$1 = isBuffer$2.exports;
var isIndex$1 = _isIndex;
var isTypedArray$1 = isTypedArray_1;
var objectProto$1 = Object.prototype;
var hasOwnProperty$1 = objectProto$1.hasOwnProperty;
function arrayLikeKeys$1(value, inherited) {
  var isArr = isArray$1(value), isArg = !isArr && isArguments$1(value), isBuff = !isArr && !isArg && isBuffer$1(value), isType = !isArr && !isArg && !isBuff && isTypedArray$1(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length2 = result.length;
  for (var key in value) {
    if ((inherited || hasOwnProperty$1.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
    (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
    isIndex$1(key, length2)))) {
      result.push(key);
    }
  }
  return result;
}
var _arrayLikeKeys = arrayLikeKeys$1;
function nativeKeysIn$1(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}
var _nativeKeysIn = nativeKeysIn$1;
var isObject$4 = isObject_1;
var isPrototype = _isPrototype;
var nativeKeysIn = _nativeKeysIn;
var objectProto = Object.prototype;
var hasOwnProperty = objectProto.hasOwnProperty;
function baseKeysIn$1(object) {
  if (!isObject$4(object)) {
    return nativeKeysIn(object);
  }
  var isProto = isPrototype(object), result = [];
  for (var key in object) {
    if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}
var _baseKeysIn = baseKeysIn$1;
var arrayLikeKeys = _arrayLikeKeys;
var baseKeysIn = _baseKeysIn;
var isArrayLike$1 = isArrayLike_1;
function keysIn$2(object) {
  return isArrayLike$1(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}
var keysIn_1 = keysIn$2;
var copyObject = _copyObject;
var keysIn$1 = keysIn_1;
function toPlainObject$1(value) {
  return copyObject(value, keysIn$1(value));
}
var toPlainObject_1 = toPlainObject$1;
var assignMergeValue$1 = _assignMergeValue;
var cloneBuffer = _cloneBuffer.exports;
var cloneTypedArray = _cloneTypedArray;
var copyArray = _copyArray;
var initCloneObject = _initCloneObject;
var isArguments = isArguments_1;
var isArray = isArray_1;
var isArrayLikeObject = isArrayLikeObject_1;
var isBuffer = isBuffer$2.exports;
var isFunction$1 = isFunction_1;
var isObject$3 = isObject_1;
var isPlainObject = isPlainObject_1;
var isTypedArray = isTypedArray_1;
var safeGet$1 = _safeGet;
var toPlainObject = toPlainObject_1;
function baseMergeDeep$1(object, source, key, srcIndex, mergeFunc, customizer, stack) {
  var objValue = safeGet$1(object, key), srcValue = safeGet$1(source, key), stacked = stack.get(srcValue);
  if (stacked) {
    assignMergeValue$1(object, key, stacked);
    return;
  }
  var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : void 0;
  var isCommon = newValue === void 0;
  if (isCommon) {
    var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
    newValue = srcValue;
    if (isArr || isBuff || isTyped) {
      if (isArray(objValue)) {
        newValue = objValue;
      } else if (isArrayLikeObject(objValue)) {
        newValue = copyArray(objValue);
      } else if (isBuff) {
        isCommon = false;
        newValue = cloneBuffer(srcValue, true);
      } else if (isTyped) {
        isCommon = false;
        newValue = cloneTypedArray(srcValue, true);
      } else {
        newValue = [];
      }
    } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
      newValue = objValue;
      if (isArguments(objValue)) {
        newValue = toPlainObject(objValue);
      } else if (!isObject$3(objValue) || isFunction$1(objValue)) {
        newValue = initCloneObject(srcValue);
      }
    } else {
      isCommon = false;
    }
  }
  if (isCommon) {
    stack.set(srcValue, newValue);
    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
    stack["delete"](srcValue);
  }
  assignMergeValue$1(object, key, newValue);
}
var _baseMergeDeep = baseMergeDeep$1;
var Stack = _Stack;
var assignMergeValue = _assignMergeValue;
var baseFor = _baseFor;
var baseMergeDeep = _baseMergeDeep;
var isObject$2 = isObject_1;
var keysIn = keysIn_1;
var safeGet = _safeGet;
function baseMerge$1(object, source, srcIndex, customizer, stack) {
  if (object === source) {
    return;
  }
  baseFor(source, function(srcValue, key) {
    stack || (stack = new Stack());
    if (isObject$2(srcValue)) {
      baseMergeDeep(object, source, key, srcIndex, baseMerge$1, customizer, stack);
    } else {
      var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : void 0;
      if (newValue === void 0) {
        newValue = srcValue;
      }
      assignMergeValue(object, key, newValue);
    }
  }, keysIn);
}
var _baseMerge = baseMerge$1;
function identity$2(value) {
  return value;
}
var identity_1 = identity$2;
function apply$1(func, thisArg, args) {
  switch (args.length) {
    case 0:
      return func.call(thisArg);
    case 1:
      return func.call(thisArg, args[0]);
    case 2:
      return func.call(thisArg, args[0], args[1]);
    case 3:
      return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}
var _apply = apply$1;
var apply = _apply;
var nativeMax = Math.max;
function overRest$1(func, start, transform) {
  start = nativeMax(start === void 0 ? func.length - 1 : start, 0);
  return function() {
    var args = arguments, index4 = -1, length2 = nativeMax(args.length - start, 0), array4 = Array(length2);
    while (++index4 < length2) {
      array4[index4] = args[start + index4];
    }
    index4 = -1;
    var otherArgs = Array(start + 1);
    while (++index4 < start) {
      otherArgs[index4] = args[index4];
    }
    otherArgs[start] = transform(array4);
    return apply(func, this, otherArgs);
  };
}
var _overRest = overRest$1;
function constant$1(value) {
  return function() {
    return value;
  };
}
var constant_1 = constant$1;
var constant = constant_1;
var defineProperty = _defineProperty;
var identity$1 = identity_1;
var baseSetToString$1 = !defineProperty ? identity$1 : function(func, string3) {
  return defineProperty(func, "toString", {
    "configurable": true,
    "enumerable": false,
    "value": constant(string3),
    "writable": true
  });
};
var _baseSetToString = baseSetToString$1;
var HOT_COUNT = 800;
var HOT_SPAN = 16;
var nativeNow = Date.now;
function shortOut$1(func) {
  var count = 0, lastCalled = 0;
  return function() {
    var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(void 0, arguments);
  };
}
var _shortOut = shortOut$1;
var baseSetToString = _baseSetToString;
var shortOut = _shortOut;
var setToString$1 = shortOut(baseSetToString);
var _setToString = setToString$1;
var identity = identity_1;
var overRest = _overRest;
var setToString = _setToString;
function baseRest$1(func, start) {
  return setToString(overRest(func, start, identity), func + "");
}
var _baseRest = baseRest$1;
var eq = eq_1;
var isArrayLike = isArrayLike_1;
var isIndex = _isIndex;
var isObject$1 = isObject_1;
function isIterateeCall$1(value, index4, object) {
  if (!isObject$1(object)) {
    return false;
  }
  var type3 = typeof index4;
  if (type3 == "number" ? isArrayLike(object) && isIndex(index4, object.length) : type3 == "string" && index4 in object) {
    return eq(object[index4], value);
  }
  return false;
}
var _isIterateeCall = isIterateeCall$1;
var baseRest = _baseRest;
var isIterateeCall = _isIterateeCall;
function createAssigner$1(assigner) {
  return baseRest(function(object, sources) {
    var index4 = -1, length2 = sources.length, customizer = length2 > 1 ? sources[length2 - 1] : void 0, guard = length2 > 2 ? sources[2] : void 0;
    customizer = assigner.length > 3 && typeof customizer == "function" ? (length2--, customizer) : void 0;
    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length2 < 3 ? void 0 : customizer;
      length2 = 1;
    }
    object = Object(object);
    while (++index4 < length2) {
      var source = sources[index4];
      if (source) {
        assigner(object, source, index4, customizer);
      }
    }
    return object;
  });
}
var _createAssigner = createAssigner$1;
var baseMerge = _baseMerge;
var createAssigner = _createAssigner;
var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
  baseMerge(object, source, srcIndex, customizer);
});
var mergeWith_1 = mergeWith;
var mergeConfigWithDefaults = (config, defaults) => mergeWith_1({}, defaults, config, (_a2, b) => {
  if (Array.isArray(b)) {
    return b;
  }
  return void 0;
});
var DEFAULT_LOG_LEVEL = "warn";
var DEFAULT_LOG_PREFIX = "[audius-sdk]";
var logLevels = ["debug", "info", "warn", "error"];
var Logger = class _Logger {
  constructor(config) {
    var _config$logLevel, _config$logPrefix;
    _defineProperty$1(this, "logLevel", void 0);
    _defineProperty$1(this, "logPrefix", "[audius-sdk]");
    this.logLevel = (_config$logLevel = config === null || config === void 0 ? void 0 : config.logLevel) !== null && _config$logLevel !== void 0 ? _config$logLevel : DEFAULT_LOG_LEVEL;
    this.logPrefix = (_config$logPrefix = config === null || config === void 0 ? void 0 : config.logPrefix) !== null && _config$logPrefix !== void 0 ? _config$logPrefix : DEFAULT_LOG_PREFIX;
  }
  createPrefixedLogger(logPrefix) {
    return new _Logger({
      logLevel: this.logLevel,
      logPrefix: `${this.logPrefix}${logPrefix}`
    });
  }
  debug() {
    if (logLevels.indexOf(this.logLevel) > logLevels.indexOf("debug")) {
      return;
    }
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    console.debug(this.logPrefix, ...args);
  }
  info() {
    if (logLevels.indexOf(this.logLevel) > logLevels.indexOf("info")) {
      return;
    }
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    console.info(this.logPrefix, ...args);
  }
  warn() {
    if (logLevels.indexOf(this.logLevel) > logLevels.indexOf("warn")) {
      return;
    }
    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      args[_key3] = arguments[_key3];
    }
    console.warn(this.logPrefix, ...args);
  }
  error() {
    if (logLevels.indexOf(this.logLevel) > logLevels.indexOf("error")) {
      return;
    }
    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      args[_key4] = arguments[_key4];
    }
    console.error(this.logPrefix, ...args);
  }
};
var getDefaultSolanaClientConfig = (servicesConfig) => ({
  rpcEndpoints: [servicesConfig.solana.rpcEndpoint],
  logger: new Logger()
});
var PrioritySchema = z.enum(["MIN", "LOW", "MEDIUM", "HIGH", "VERY_HIGH", "UNSAFE_MAX"]);
var TransactionInstructionSchema = z.object({
  data: z.custom(),
  keys: z.array(z.object({
    pubkey: PublicKeySchema,
    isSigner: z.boolean(),
    isWritable: z.boolean()
  })),
  programId: PublicKeySchema
}).transform((arg) => arg instanceof TransactionInstruction ? arg : new TransactionInstruction(arg));
var AddressLookupTableAccountSchema = z.object({
  key: PublicKeySchema,
  state: z.object({
    addresses: z.array(PublicKeySchema),
    authority: z.optional(PublicKeySchema),
    deactivationSlot: z.bigint(),
    lastExtendedSlot: z.number(),
    lastExtendedSlotStartIndex: z.number()
  })
}).transform((arg) => arg instanceof AddressLookupTableAccount ? arg : new AddressLookupTableAccount(arg));
var BuildTransactionSchema = z.object({
  instructions: z.array(TransactionInstructionSchema).min(1),
  recentBlockhash: z.string().optional(),
  feePayer: PublicKeySchema.optional(),
  /**
   * Either the public keys or actual account data for related address lookup tables.
   */
  addressLookupTables: z.union([z.array(PublicKeySchema).default([]), z.array(AddressLookupTableAccountSchema).default([])]).optional(),
  /**
   * Adds a ComputeBudget instruction to set the compute unit price for the
   * transaction. Can specify a percentile or percentile enum to use recent
   * prioritization fees to programatically set the price.
   */
  priorityFee: z.union([z.object({
    /**
     * The exact amount of microLamports to add per compute unit.
     */
    microLamports: z.number().min(0)
  }), z.object({
    /**
     * Specify the precise percentile (0-100) of recent priority fees
     * to use as this transaction's base priority fee per compute unit.
     */
    percentile: z.number().min(0).max(100),
    /**
     * Multiply the base priority fee per compute unit by some factor.
     * For example a multiplier of 2 and percentile of 50 will set the
     * priority fee to twice the median.
     */
    multiplier: z.number().min(0).optional(),
    /**
     * The minimum microLamports to use as the priority fee per compute
     * unit, regardless of the percentiles.
     */
    minimumMicroLamports: z.number().min(0).optional(),
    /**
     * The maximum microLamports to use as the priority fee per compute
     * unit, regardless of the percentiles.
     */
    maximumMicroLamports: z.number().min(0).optional()
  }), z.object({
    /**
     * Specify an enum-based percentile of recent priority fees to use as
     * this transactions priority fee per compute unit.
     */
    priority: PrioritySchema,
    /**
     * Multiply the base priority fee per compute unit by some factor.
     * For example a multiplier of 2 and percentile of 50 will set the
     * priority fee to twice the median.
     */
    multiplier: z.number().min(0).optional(),
    /**
     * The minimum microLamports to use as the priority fee per compute
     * unit, regardless of the percentiles.
     */
    minimumMicroLamports: z.number().min(0).optional(),
    /**
     * The maximum microLamports to use as the priority fee per compute
     * unit, regardless of the percentiles.
     */
    maximumMicroLamports: z.number().min(0).optional()
  })]).nullable().optional(),
  computeLimit: z.union([z.object({
    /**
     * Set hard limit on the compute units used.
     */
    units: z.number().min(0)
  }), z.object({
    /**
     * Simulate the transaction and multiply the simulated unitsConsumed
     * by this number to find the budget limit.
     */
    simulationMultiplier: z.number().min(0)
  })]).nullable().optional()
}).strict();
var isPublicKeyArray = (arr) => arr.every((a) => a instanceof PublicKey);
var priorityToPercentileMap = {
  MIN: 0,
  LOW: 25,
  MEDIUM: 50,
  HIGH: 75,
  VERY_HIGH: 95,
  UNSAFE_MAX: 100
};
var SolanaClient = class {
  constructor(config) {
    var _configWithDefaults$l;
    _defineProperty$1(this, "connection", void 0);
    _defineProperty$1(this, "wallet", void 0);
    _defineProperty$1(this, "logger", void 0);
    const configWithDefaults = mergeConfigWithDefaults(config, getDefaultSolanaClientConfig(productionConfig));
    if (!configWithDefaults.rpcEndpoints[0]) {
      throw new Error("RPC Endpoints not configured");
    }
    this.connection = new Connection(
      // Only supports one RPC endpoint right now
      configWithDefaults.rpcEndpoints[0],
      configWithDefaults.rpcConfig
    );
    this.wallet = config.solanaWalletAdapter;
    this.logger = (_configWithDefaults$l = configWithDefaults.logger) === null || _configWithDefaults$l === void 0 ? void 0 : _configWithDefaults$l.createPrefixedLogger("[solana-client]");
  }
  /**
   * Convenience helper to construct v0 transactions.
   *
   * Handles fetching a recent blockhash, getting lookup table accounts,
   * and assigning a fee payer.
   */
  async buildTransaction(params) {
    let {
      instructions,
      feePayer,
      recentBlockhash,
      addressLookupTables = [],
      priorityFee = {
        priority: "VERY_HIGH",
        minimumMicroLamports: 15e4,
        maximumMicroLamports: 1e7,
        multiplier: 1.5
      },
      computeLimit = {
        simulationMultiplier: 1.5
      }
    } = await parseParams("buildTransaction", BuildTransactionSchema)(params);
    if (!recentBlockhash) {
      const res = await this.connection.getLatestBlockhash();
      recentBlockhash = res.blockhash;
    }
    const payerKey = feePayer !== null && feePayer !== void 0 ? feePayer : await this.getFeePayer();
    if (priorityFee) {
      if ("microLamports" in priorityFee) {
        instructions.push(ComputeBudgetProgram.setComputeUnitPrice({
          microLamports: priorityFee.microLamports
        }));
      } else {
        var _priorityFee$multipli, _orderedFees$percenti, _priorityFee$minimumM, _priorityFee$maximumM;
        const res = await this.connection.getRecentPrioritizationFees();
        const orderedFees = res.map((r) => r.prioritizationFee).sort((a, b) => a - b);
        const percentile = "percentile" in priorityFee ? priorityFee.percentile : priorityToPercentileMap[priorityFee.priority];
        const multiplier = (_priorityFee$multipli = priorityFee.multiplier) !== null && _priorityFee$multipli !== void 0 ? _priorityFee$multipli : 1;
        const percentileIndex = Math.max(Math.round(percentile / 100 * orderedFees.length - 1), 0);
        const baseFee = ((_orderedFees$percenti = orderedFees[percentileIndex]) !== null && _orderedFees$percenti !== void 0 ? _orderedFees$percenti : 0) * multiplier;
        const microLamports = Math.min(Math.max(baseFee, (_priorityFee$minimumM = priorityFee.minimumMicroLamports) !== null && _priorityFee$minimumM !== void 0 ? _priorityFee$minimumM : 0), (_priorityFee$maximumM = priorityFee.maximumMicroLamports) !== null && _priorityFee$maximumM !== void 0 ? _priorityFee$maximumM : Number.MAX_SAFE_INTEGER);
        if (microLamports !== void 0) {
          instructions.push(ComputeBudgetProgram.setComputeUnitPrice({
            microLamports
          }));
        }
      }
    }
    const addressLookupTableAccounts = !isPublicKeyArray(addressLookupTables) ? addressLookupTables : await this.getLookupTableAccounts(addressLookupTables);
    if (computeLimit) {
      if ("units" in computeLimit) {
        instructions.push(ComputeBudgetProgram.setComputeUnitLimit({
          units: computeLimit.units
        }));
      } else {
        try {
          const simulatedMessage = new TransactionMessage({
            payerKey,
            recentBlockhash,
            instructions
          }).compileToV0Message(addressLookupTableAccounts);
          const simulatedTx = new VersionedTransaction(simulatedMessage);
          const res = await this.connection.simulateTransaction(simulatedTx, {
            replaceRecentBlockhash: true
          });
          if (res.value.err) {
            throw new Error(JSON.stringify(res.value.err));
          }
          this.logger.debug("Simulation succeeded, compute units used:", res.value.unitsConsumed);
          if (res.value.unitsConsumed) {
            instructions.push(ComputeBudgetProgram.setComputeUnitLimit({
              units: res.value.unitsConsumed * computeLimit.simulationMultiplier
            }));
          }
        } catch (e) {
          this.logger.warn("Failed to get computeLimit", e);
        }
      }
    }
    const message = new TransactionMessage({
      payerKey,
      recentBlockhash,
      instructions
    }).compileToV0Message(addressLookupTableAccounts);
    return new VersionedTransaction(message);
  }
  /**
   * Sends a transaction using the connected wallet adapter and the connection.
   * @param transaction The transaction to send.
   * @param sendOptions The options to send it with.
   */
  async sendTransaction(transaction, sendOptions) {
    return await this.wallet.sendTransaction(transaction, this.connection, sendOptions);
  }
  /**
   * Confirms all the transactions provided
   */
  async confirmAllTransactions(signatures) {
    let commitment = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "confirmed";
    const {
      blockhash,
      lastValidBlockHeight
    } = await this.connection.getLatestBlockhash();
    const results = await Promise.all(signatures.map(async (signature2) => {
      const res = await this.connection.confirmTransaction({
        signature: signature2,
        blockhash,
        lastValidBlockHeight
      }, commitment);
      return {
        signature: signature2,
        err: res.value.err
      };
    }));
    const errors2 = results.filter((r) => !!r.err);
    if (errors2.length > 0) {
      throw new Error(`Failed to confirm transactions: ${errors2.map((e) => `${e.signature}: ${e.err}`).join(", ")}`);
    }
  }
  /**
   * Gets the fee payer from the connected wallet.
   */
  async getFeePayer() {
    if (!this.wallet.connected) {
      await this.wallet.connect();
    }
    return this.wallet.publicKey;
  }
  /**
   * Normalizes the instructions as TransactionInstruction whether from
   * versioned transactions or legacy transactions.
   */
  async getInstructions(transaction) {
    if ("version" in transaction) {
      const lookupTableAccounts = await this.getLookupTableAccounts(transaction.message.addressTableLookups.map((k) => k.accountKey));
      const decompiled = TransactionMessage.decompile(transaction.message, {
        addressLookupTableAccounts: lookupTableAccounts
      });
      return decompiled.instructions;
    } else {
      return transaction.instructions;
    }
  }
  /**
   * Fetches the address look up tables for populating transaction objects
   */
  async getLookupTableAccounts(lookupTableKeys) {
    return await Promise.all(lookupTableKeys.map(async (accountKey) => {
      const res = await this.connection.getAddressLookupTable(accountKey);
      if (res.value === null) {
        throw new Error(`Lookup table not found: ${accountKey.toBase58()}`);
      }
      return res.value;
    }));
  }
};
var parseMint = (mintOrToken, mints) => {
  const mint = mintOrToken instanceof PublicKey ? mintOrToken : mints[mintOrToken];
  if (!mint) {
    throw Error("Mint not configured");
  }
  return mint;
};
var CustomInstructionError = class _CustomInstructionError extends Error {
  constructor(instructionIndex, code2) {
    super(JSON.stringify({
      InstructionError: [instructionIndex, {
        Custom: code2
      }]
    }));
    _defineProperty$1(this, "instructionIndex", void 0);
    _defineProperty$1(this, "code", void 0);
    this.instructionIndex = instructionIndex;
    this.code = code2;
  }
  static parseSendTransactionError(error) {
    var _parsed$InstructionEr, _parsed$InstructionEr2;
    const parsed = JSON.parse(error.transactionError.message);
    if (typeof (parsed === null || parsed === void 0 ? void 0 : (_parsed$InstructionEr = parsed.InstructionError) === null || _parsed$InstructionEr === void 0 ? void 0 : (_parsed$InstructionEr2 = _parsed$InstructionEr[1]) === null || _parsed$InstructionEr2 === void 0 ? void 0 : _parsed$InstructionEr2.Custom) === "number") {
      return new _CustomInstructionError(parsed.InstructionError[0], parsed.InstructionError[1].Custom);
    }
    throw new Error("Unable to parse custom transaction error");
  }
};
var getDefaultClaimableTokensConfig = (config) => ({
  programId: new PublicKey(config.solana.claimableTokensProgramAddress),
  mints: {
    wAUDIO: new PublicKey(config.solana.wAudioTokenMint),
    USDC: new PublicKey(config.solana.usdcTokenMint),
    BONK: new PublicKey(config.solana.bonkTokenMint)
  },
  logger: new Logger()
});
var GetOrCreateUserBankSchema = z.object({
  /** The user's Ethereum wallet. */
  ethWallet: z.string().optional(),
  /** The name of the token mint. */
  mint: MintSchema,
  /**
   * The public key of the account that will be paying the
   * account creation and transaction fees.
   */
  feePayer: PublicKeySchema.optional()
}).strict();
z.object({
  /** The sending user's Ethereum wallet. Defaults to the current audiusWalletClient address. */
  ethWallet: z.string().optional(),
  /** The name of the token mint. */
  mint: MintSchema
}).strict();
var CreateTransferSchema = z.object({
  /** The public key of the account that will be paying the transaction fees. */
  feePayer: PublicKeySchema.optional(),
  /** The sending user's Ethereum wallet. Defaults to the current audiusWalletClient address. */
  ethWallet: z.string().optional(),
  /** The name of the token mint. */
  mint: MintSchema,
  /** The public key of the destination account. */
  destination: PublicKeySchema
});
var CreateSecpSchema = z.object({
  /** The sending user's Ethereum wallet. Defaults to the current audiusWalletClient address. */
  ethWallet: z.string().optional(),
  /** The public key of the destination account. */
  destination: PublicKeySchema,
  /** The amount to send, in "lamports"/"wei" (bigint). */
  amount: z.bigint(),
  /** The name of the token mint. */
  mint: MintSchema,
  /** The index of this instruction within the transaction. */
  instructionIndex: z.number().optional()
}).strict();
var ClaimableTokensError = class extends Error {
  constructor(_ref) {
    var _ClaimableTokensError2;
    let {
      code: code2,
      instructionName,
      cause
    } = _ref;
    super((_ClaimableTokensError2 = ClaimableTokensErrorMessages[code2]) !== null && _ClaimableTokensError2 !== void 0 ? _ClaimableTokensError2 : `Unknown error: ${code2}`, {
      cause
    });
    _defineProperty$1(this, "name", "ClaimableTokensError");
    _defineProperty$1(this, "code", void 0);
    _defineProperty$1(this, "instructionName", void 0);
    _defineProperty$1(this, "customErrorName", void 0);
    this.code = code2;
    this.instructionName = instructionName;
    this.customErrorName = ClaimableTokensErrorCode[code2];
  }
};
var ClaimableTokensClient = class {
  constructor(config) {
    _defineProperty$1(this, "client", void 0);
    _defineProperty$1(this, "programId", void 0);
    _defineProperty$1(this, "preconfiguredMints", void 0);
    _defineProperty$1(this, "authorities", void 0);
    _defineProperty$1(this, "logger", void 0);
    _defineProperty$1(this, "audiusWalletClient", void 0);
    _defineProperty$1(this, "_pendingUserBankCreationPromises", {});
    const configWithDefaults = mergeConfigWithDefaults(config, getDefaultClaimableTokensConfig(productionConfig));
    this.client = configWithDefaults.solanaClient;
    this.programId = configWithDefaults.programId;
    this.preconfiguredMints = configWithDefaults.mints;
    this.authorities = Object.fromEntries(Object.entries(configWithDefaults.mints).map((_ref2) => {
      let [token2, mint] = _ref2;
      return [token2, ClaimableTokensProgram.deriveAuthority({
        programId: configWithDefaults.programId,
        mint
      })];
    }));
    this.audiusWalletClient = configWithDefaults.audiusWalletClient;
    this.logger = configWithDefaults.logger.createPrefixedLogger("[claimable-tokens-client]");
  }
  /**
   * Creates a user bank or returns the existing user bank for a user.
   */
  async getOrCreateUserBank(params) {
    const args = await parseParams("getOrCreateUserBank", GetOrCreateUserBankSchema)(params);
    const {
      ethWallet = await this.getDefaultWalletAddress(),
      feePayer: feePayerOverride
    } = args;
    const mint = parseMint(args.mint, this.preconfiguredMints);
    const feePayer = feePayerOverride !== null && feePayerOverride !== void 0 ? feePayerOverride : await this.client.getFeePayer();
    const userBank = await this.deriveUserBank(args);
    if (this._pendingUserBankCreationPromises[userBank.toBase58()]) {
      await this._pendingUserBankCreationPromises[userBank.toBase58()];
      return {
        userBank,
        didExist: true
      };
    }
    this._pendingUserBankCreationPromises[userBank.toBase58()] = (async () => {
      const userBankAccount = await this.client.connection.getAccountInfo(userBank);
      if (!userBankAccount) {
        this.logger.debug(`User bank ${userBank} does not exist. Creating...`);
        const createUserBankInstruction = ClaimableTokensProgram.createAccountInstruction({
          ethAddress: ethWallet,
          payer: feePayer,
          mint,
          authority: this.deriveAuthority(mint),
          userBank,
          programId: this.programId
        });
        const {
          blockhash,
          lastValidBlockHeight
        } = await this.client.connection.getLatestBlockhash();
        const transaction = await this.client.buildTransaction({
          instructions: [createUserBankInstruction],
          recentBlockhash: blockhash
        });
        const signature2 = await this.sendTransaction(transaction);
        await this.client.connection.confirmTransaction({
          blockhash,
          lastValidBlockHeight,
          signature: signature2
        }, "finalized");
        return {
          userBank,
          didExist: false
        };
      }
      this.logger.debug(`User bank ${userBank} already exists.`);
      return {
        userBank,
        didExist: true
      };
    })();
    try {
      return await this._pendingUserBankCreationPromises[userBank.toBase58()];
    } catch (e) {
      delete this._pendingUserBankCreationPromises[userBank.toBase58()];
      throw e;
    }
  }
  /**
   * Creates a claimable tokens program transfer instruction using configured
   * program ID, mint addresses, derived nonce, and derived authorities.
   *
   * Must be paired with a matching Secp256k1 instruction.
   * @see {@link createTransferSecpInstruction}
   */
  async createTransferInstruction(params) {
    const {
      feePayer: feePayerOverride,
      ethWallet = await this.getDefaultWalletAddress(),
      mint: mintOrToken,
      destination
    } = await parseParams("createTransferInstruction", CreateTransferSchema)(params);
    const mint = parseMint(mintOrToken, this.preconfiguredMints);
    const feePayer = feePayerOverride !== null && feePayerOverride !== void 0 ? feePayerOverride : await this.client.getFeePayer();
    const source = await this.deriveUserBank({
      ethWallet,
      mint
    });
    const nonceKey = ClaimableTokensProgram.deriveNonce({
      ethAddress: ethWallet,
      authority: this.deriveAuthority(mint),
      programId: this.programId
    });
    return ClaimableTokensProgram.createTransferInstruction({
      payer: feePayer,
      sourceEthAddress: ethWallet,
      sourceUserBank: source,
      destination,
      nonceAccount: nonceKey,
      authority: this.deriveAuthority(mint),
      programId: this.programId
    });
  }
  /**
   * Creates a signed Secp256k1 instruction for a claimable tokens transfer
   * using configured program ID, derived nonce, and derived authorities.
   *
   * @see {@link createTransferInstruction}
   */
  async createTransferSecpInstruction(params) {
    const {
      ethWallet = (await this.audiusWalletClient.getAddresses())[0],
      destination,
      amount,
      mint: mintOrToken,
      instructionIndex
    } = await parseParams("createTransferSecpInstruction", CreateSecpSchema)(params);
    const mint = parseMint(mintOrToken, this.preconfiguredMints);
    let nonce = BigInt(0);
    const nonceKey = ClaimableTokensProgram.deriveNonce({
      ethAddress: ethWallet,
      authority: this.deriveAuthority(mint),
      programId: this.programId
    });
    const nonceAccount = await this.client.connection.getAccountInfo(nonceKey);
    const encodedNonceData = nonceAccount === null || nonceAccount === void 0 ? void 0 : nonceAccount.data;
    if (encodedNonceData) {
      const nonceData = ClaimableTokensProgram.layouts.nonceAccountData.decode(encodedNonceData);
      nonce = nonceData.nonce;
    }
    const data = ClaimableTokensProgram.createSignedTransferInstructionData({
      destination,
      amount,
      nonce
    });
    const [signature2, recoveryId] = await this.audiusWalletClient.sign({
      message: {
        raw: data
      }
    });
    return Secp256k1Program.createInstructionWithEthAddress({
      ethAddress: ethWallet,
      message: data,
      signature: signature2,
      recoveryId,
      instructionIndex
    });
  }
  /**
   * Derives the user bank of a user from their Ethereum wallet and the token mint.
   *
   * Use {@link getOrCreateUserBank} instead if you want to ensure the userBank exists.
   */
  async deriveUserBank(params) {
    const {
      ethWallet = (await this.audiusWalletClient.getAddresses())[0],
      mint: mintOrToken
    } = await parseParams("deriveUserBank", GetOrCreateUserBankSchema)(params);
    const mint = parseMint(mintOrToken, this.preconfiguredMints);
    return await ClaimableTokensProgram.deriveUserBank({
      ethAddress: ethWallet,
      claimableTokensPDA: this.deriveAuthority(mint)
    });
  }
  /**
   * Derives the authority for a given mint.
   * If the authority is not already cached, it will derive it.
   */
  deriveAuthority(mint) {
    const authority = this.authorities[mint.toBase58()];
    if (!authority) {
      return ClaimableTokensProgram.deriveAuthority({
        programId: this.programId,
        mint
      });
    }
    return authority;
  }
  /**
   * Override the sendTransaction method to provide some more friendly errors
   * back to the consumer for ClaimableTokens instructions
   */
  async sendTransaction(transaction, sendOptions) {
    try {
      return await this.client.sendTransaction(transaction, sendOptions);
    } catch (e) {
      if (e instanceof SendTransactionError) {
        try {
          const error = CustomInstructionError.parseSendTransactionError(e);
          if (error) {
            const instructions = await this.client.getInstructions(transaction);
            const instruction = instructions[error.instructionIndex];
            if (instruction && instruction.programId.equals(this.programId)) {
              var _ClaimableTokensInstr;
              const decodedInstruction = ClaimableTokensProgram.decodeInstruction(instruction);
              throw new ClaimableTokensError({
                code: error.code,
                instructionName: (_ClaimableTokensInstr = ClaimableTokensInstruction[decodedInstruction.data.instruction]) !== null && _ClaimableTokensInstr !== void 0 ? _ClaimableTokensInstr : "Unknown",
                cause: e
              });
            }
          }
        } catch (nestedError) {
          if (nestedError instanceof ClaimableTokensError) {
            throw nestedError;
          } else {
            this.logger.warn("Failed to parse ClaimableTokensError error", nestedError);
          }
        }
      }
      throw e;
    }
  }
  async getDefaultWalletAddress() {
    const addresses = await this.audiusWalletClient.getAddresses();
    if (!addresses || !addresses[0]) {
      throw new Error('Failed to infer wallet address. Did you forget the "ethAddress" argument?');
    }
    return addresses[0];
  }
};
var getDefaultRewardManagerClentConfig = (config) => ({
  programId: new PublicKey(config.solana.rewardManagerProgramAddress),
  rewardManagerState: new PublicKey(config.solana.rewardManagerStateAddress),
  rewardManagerLookupTable: new PublicKey(config.solana.rewardManagerLookupTableAddress),
  logger: new Logger()
});
var CreateSenderInstructionSchema = z.object({
  manager: PublicKeySchema,
  sender: z.string(),
  operator: z.string(),
  feePayer: PublicKeySchema.optional()
});
var CreateSubmitAttestationInstructionSchema = z.object({
  challengeId: z.string(),
  specifier: z.string(),
  senderEthAddress: z.string(),
  feePayer: PublicKeySchema.optional()
});
var CreateSubmitAttestationSecpInstructionSchema = z.object({
  challengeId: z.string(),
  specifier: z.string(),
  recipientEthAddress: z.string(),
  senderEthAddress: z.string(),
  amount: z.bigint(),
  antiAbuseOracleEthAddress: z.string().optional(),
  senderSignature: z.string(),
  instructionIndex: z.number().optional()
});
var CreateEvaluateAttestationsInstructionSchema = z.object({
  challengeId: z.string(),
  specifier: z.string(),
  recipientEthAddress: z.string(),
  destinationUserBank: PublicKeySchema,
  antiAbuseOracleEthAddress: z.string(),
  amount: z.bigint(),
  feePayer: PublicKeySchema.optional()
});
var GetSubmittedAttestationsSchema = z.object({
  challengeId: z.string(),
  specifier: z.string()
});
var RewardManagerError = class extends Error {
  constructor(_ref) {
    var _RewardManagerErrorMe;
    let {
      code: code2,
      instructionName,
      cause
    } = _ref;
    super((_RewardManagerErrorMe = RewardManagerErrorMessages[code2]) !== null && _RewardManagerErrorMe !== void 0 ? _RewardManagerErrorMe : `Unknown error: ${code2}`, {
      cause
    });
    _defineProperty$1(this, "name", "RewardManagerError");
    _defineProperty$1(this, "code", void 0);
    _defineProperty$1(this, "instructionName", void 0);
    _defineProperty$1(this, "customErrorName", void 0);
    this.code = code2;
    this.instructionName = instructionName;
    this.customErrorName = RewardManagerErrorCode[code2];
  }
};
var RewardManagerClient = class {
  constructor(config) {
    _defineProperty$1(this, "lookupTable", void 0);
    _defineProperty$1(this, "client", void 0);
    _defineProperty$1(this, "programId", void 0);
    _defineProperty$1(this, "rewardManagerStateAccount", void 0);
    _defineProperty$1(this, "authority", void 0);
    _defineProperty$1(this, "rewardManagerState", null);
    _defineProperty$1(this, "logger", void 0);
    const configWithDefaults = mergeConfigWithDefaults(config, getDefaultRewardManagerClentConfig(productionConfig));
    this.lookupTable = configWithDefaults.rewardManagerLookupTable;
    this.client = configWithDefaults.solanaClient;
    this.programId = configWithDefaults.programId;
    this.rewardManagerStateAccount = configWithDefaults.rewardManagerState;
    this.authority = RewardManagerProgram.deriveAuthority({
      programId: configWithDefaults.programId,
      rewardManagerState: configWithDefaults.rewardManagerState
    });
    this.logger = configWithDefaults.logger.createPrefixedLogger("[reward-manager-client]");
  }
  async createSenderInstruction(params) {
    const args = await parseParams("createSenderInstruction", CreateSenderInstructionSchema)(params);
    const {
      manager,
      sender: senderEthAddress,
      operator: operatorEthAddress,
      feePayer: feePayerOverride
    } = args;
    const feePayer = feePayerOverride !== null && feePayerOverride !== void 0 ? feePayerOverride : await this.client.getFeePayer();
    const sender = RewardManagerProgram.deriveSender({
      ethAddress: senderEthAddress,
      programId: this.programId,
      authority: this.authority
    });
    return RewardManagerProgram.createSenderInstruction({
      operatorEthAddress,
      senderEthAddress,
      rewardManagerState: this.rewardManagerStateAccount,
      manager,
      authority: this.authority,
      payer: feePayer,
      sender,
      rewardManagerProgramId: this.programId
    });
  }
  async createSubmitAttestationInstruction(params) {
    const args = await parseParams("createSubmitAttestationInstruction", CreateSubmitAttestationInstructionSchema)(params);
    const {
      challengeId,
      specifier,
      senderEthAddress,
      feePayer: feePayerOverride
    } = args;
    const disbursementId = this.makeDisbursementId(challengeId, specifier);
    const feePayer = feePayerOverride !== null && feePayerOverride !== void 0 ? feePayerOverride : await this.client.getFeePayer();
    const sender = RewardManagerProgram.deriveSender({
      ethAddress: senderEthAddress,
      programId: this.programId,
      authority: this.authority
    });
    const attestations = RewardManagerProgram.deriveAttestations({
      disbursementId,
      programId: this.programId,
      authority: this.authority
    });
    return RewardManagerProgram.createSubmitAttestationInstruction({
      disbursementId,
      attestations,
      rewardManagerState: this.rewardManagerStateAccount,
      authority: this.authority,
      payer: feePayer,
      sender,
      rewardManagerProgramId: this.programId
    });
  }
  async createSubmitAttestationSecpInstruction(params) {
    const args = await parseParams("createSubmitAttestationSecpInstruction", CreateSubmitAttestationSecpInstructionSchema)(params);
    const {
      recipientEthAddress,
      challengeId,
      specifier,
      amount,
      senderEthAddress,
      senderSignature,
      instructionIndex,
      antiAbuseOracleEthAddress
    } = args;
    const disbursementId = this.makeDisbursementId(challengeId, specifier);
    const {
      signature: signature2,
      recoveryId
    } = RewardManagerProgram.encodeSignature(senderSignature);
    const data = RewardManagerProgram.encodeAttestation({
      disbursementId,
      recipientEthAddress,
      amount,
      antiAbuseOracleEthAddress
    });
    return Secp256k1Program.createInstructionWithEthAddress({
      ethAddress: senderEthAddress,
      message: data,
      signature: signature2,
      recoveryId,
      instructionIndex
    });
  }
  async createEvaluateAttestationsInstruction(params) {
    const args = await parseParams("createEvaluateAttestationsInstruction", CreateEvaluateAttestationsInstructionSchema)(params);
    const {
      challengeId,
      specifier,
      recipientEthAddress,
      destinationUserBank,
      antiAbuseOracleEthAddress,
      amount,
      feePayer: feePayerOverride
    } = args;
    const disbursementId = this.makeDisbursementId(challengeId, specifier);
    const feePayer = feePayerOverride !== null && feePayerOverride !== void 0 ? feePayerOverride : await this.client.getFeePayer();
    const state = await this.getRewardManagerState();
    const disbursementAccount = RewardManagerProgram.deriveDisbursement({
      disbursementId,
      programId: this.programId,
      authority: this.authority
    });
    const attestations = RewardManagerProgram.deriveAttestations({
      disbursementId,
      programId: this.programId,
      authority: this.authority
    });
    const antiAbuseOracle = RewardManagerProgram.deriveSender({
      ethAddress: antiAbuseOracleEthAddress,
      programId: this.programId,
      authority: this.authority
    });
    return RewardManagerProgram.createEvaluateAttestationsInstruction({
      disbursementId,
      recipientEthAddress,
      amount,
      attestations,
      rewardManagerState: this.rewardManagerStateAccount,
      authority: this.authority,
      rewardManagerTokenSource: state.tokenAccount,
      destinationUserBank,
      disbursementAccount,
      antiAbuseOracle,
      payer: feePayer,
      rewardManagerProgramId: this.programId
    });
  }
  async getSubmittedAttestations(params) {
    const args = await parseParams("getSubmittedAttestations", GetSubmittedAttestationsSchema)(params);
    const {
      challengeId,
      specifier
    } = args;
    const disbursementId = this.makeDisbursementId(challengeId, specifier);
    const attestationsAccount = RewardManagerProgram.deriveAttestations({
      disbursementId,
      programId: this.programId,
      authority: this.authority
    });
    const accountInfo = await this.client.connection.getAccountInfo(attestationsAccount);
    if (!accountInfo) {
      return null;
    }
    const rewardManagerState = await this.getRewardManagerState();
    const maxAttestations = rewardManagerState.minVotes + 1;
    return RewardManagerProgram.decodeAttestationsAccountData(maxAttestations, accountInfo.data);
  }
  makeDisbursementId(challengeId, specifier) {
    return `${challengeId}:${specifier}`;
  }
  async getRewardManagerState() {
    if (!this.rewardManagerState) {
      const state = await this.client.connection.getAccountInfo(this.rewardManagerStateAccount);
      if (state) {
        this.rewardManagerState = RewardManagerProgram.decodeRewardManagerState(state.data);
      } else {
        throw new Error("Failed to get reward manager account state.");
      }
    }
    return this.rewardManagerState;
  }
  /**
   * Override the sendTransaction method to provide some more friendly errors
   * back to the consumer for RewardManager instructions
   */
  async sendTransaction(transaction, sendOptions) {
    try {
      return await this.client.sendTransaction(transaction, sendOptions);
    } catch (e) {
      if (e instanceof SendTransactionError) {
        try {
          const error = CustomInstructionError.parseSendTransactionError(e);
          if (error) {
            const instructions = await this.client.getInstructions(transaction);
            const instruction = instructions[error.instructionIndex];
            if (instruction && instruction.programId.equals(this.programId)) {
              var _RewardManagerInstruc;
              const decodedInstruction = RewardManagerProgram.decodeInstruction(instruction);
              throw new RewardManagerError({
                code: error.code,
                instructionName: (_RewardManagerInstruc = RewardManagerInstruction[decodedInstruction.data.instruction]) !== null && _RewardManagerInstruc !== void 0 ? _RewardManagerInstruc : "Unknown",
                cause: e
              });
            }
          }
        } catch (nestedError) {
          if (nestedError instanceof RewardManagerError) {
            throw nestedError;
          } else {
            this.logger.warn("Failed to parse RewardManagerError error", nestedError);
          }
        }
      }
      throw e;
    }
  }
};
new PublicKey("Memo1UhkJRfHyvLMcVucJwxXeuD728EqVDDwQDxFMNo");
var MEMO_V2_PROGRAM_ID = new PublicKey("MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr");
var getDefaultPaymentRouterClientConfig = (config) => ({
  programId: new PublicKey(config.solana.paymentRouterProgramAddress),
  mints: {
    USDC: new PublicKey(config.solana.usdcTokenMint),
    wAUDIO: new PublicKey(config.solana.wAudioTokenMint)
  }
});
var CreateTransferInstructionSchema = z.object({
  mint: MintSchema,
  total: z.bigint(),
  sourceWallet: PublicKeySchema
});
var CreateRouteInstructionSchema = z.object({
  mint: MintSchema,
  splits: z.array(z.object({
    wallet: PublicKeySchema,
    amount: z.bigint()
  })),
  total: z.bigint()
});
var CreateMemoInstructionSchema = z.object({
  contentType: z.enum(["track", "album"]),
  contentId: HashId.or(z.number()),
  blockNumber: z.number(),
  buyerUserId: HashId.or(z.number()),
  accessType: z.enum(["stream", "download"]),
  signer: PublicKeySchema.optional()
});
var CreatePurchaseContentInstructionsSchema = CreateTransferInstructionSchema.extend(CreateRouteInstructionSchema.shape).extend(CreateMemoInstructionSchema.shape);
var GetOrCreateProgramTokenAccountSchema = z.object({
  mint: MintSchema
});
var PaymentRouterClient = class {
  constructor(config) {
    _defineProperty$1(this, "client", void 0);
    _defineProperty$1(this, "programId", void 0);
    _defineProperty$1(this, "programAccount", void 0);
    _defineProperty$1(this, "programAccountBumpSeed", void 0);
    _defineProperty$1(this, "mints", void 0);
    _defineProperty$1(this, "existingTokenAccounts", void 0);
    const configWithDefaults = mergeConfigWithDefaults(config, getDefaultPaymentRouterClientConfig(productionConfig));
    this.client = configWithDefaults.solanaClient;
    this.programId = configWithDefaults.programId;
    const [pda, bump] = PublicKey.findProgramAddressSync([new TextEncoder().encode("payment_router")], this.programId);
    this.programAccount = pda;
    this.programAccountBumpSeed = bump;
    this.mints = configWithDefaults.mints;
    this.existingTokenAccounts = {};
  }
  async createTransferInstruction(params) {
    const args = await parseParams("createTransferInstruction", CreateTransferInstructionSchema)(params);
    const mint = parseMint(args.mint, this.mints);
    const programTokenAccount = await this.getOrCreateProgramTokenAccount({
      mint
    });
    const sourceWallet = args.sourceWallet;
    const sourceTokenAccount = getAssociatedTokenAddressSync(mint, sourceWallet, false);
    const amount = args.total;
    return createTransferInstruction(sourceTokenAccount, programTokenAccount.address, sourceWallet, amount);
  }
  async createRouteInstruction(params) {
    const args = await parseParams("createRouteInstruction", CreateRouteInstructionSchema)(params);
    const mint = parseMint(args.mint, this.mints);
    const programTokenAccount = await this.getOrCreateProgramTokenAccount({
      mint
    });
    const recipients = [];
    const amounts = [];
    for (const split6 of args.splits) {
      recipients.push(split6.wallet);
      amounts.push(split6.amount);
    }
    const totalAmount = args.total;
    return PaymentRouterProgram.createRouteInstruction({
      sender: programTokenAccount.address,
      senderOwner: this.programAccount,
      paymentRouterPdaBump: this.programAccountBumpSeed,
      recipients,
      amounts,
      totalAmount,
      programId: this.programId
    });
  }
  async createPurchaseMemoInstruction(params) {
    const {
      contentType,
      contentId,
      blockNumber,
      buyerUserId,
      accessType,
      signer
    } = await parseParams("createMemoInstructionSchema", CreateMemoInstructionSchema)(params);
    const memoString = `${contentType}:${contentId}:${blockNumber}:${buyerUserId}:${accessType}`;
    return new TransactionInstruction({
      keys: signer ? [{
        pubkey: signer,
        isSigner: true,
        isWritable: true
      }] : [],
      programId: MEMO_V2_PROGRAM_ID,
      data: Buffer.from(memoString)
    });
  }
  async createPurchaseContentInstructions(params) {
    const {
      mint,
      splits,
      total,
      contentId,
      contentType,
      blockNumber,
      buyerUserId,
      accessType,
      sourceWallet
    } = await parseParams("createPurchaseContentInstructions", CreatePurchaseContentInstructionsSchema)(params);
    return [await this.createTransferInstruction({
      total,
      mint,
      sourceWallet
    }), await this.createRouteInstruction({
      splits,
      total,
      mint
    }), await this.createPurchaseMemoInstruction({
      contentId,
      contentType,
      blockNumber,
      buyerUserId,
      accessType
    })];
  }
  /**
   * Creates or gets the intermediate funds token account for the program.
   * Only needs to be created once per mint.
   * @see {@link https://github.com/solana-labs/solana-program-library/blob/d72289c79a04411c69a8bf1054f7156b6196f9b3/token/js/src/actions/getOrCreateAssociatedTokenAccount.ts getOrCreateAssociatedTokenAccount}
   */
  async getOrCreateProgramTokenAccount(params) {
    const args = await parseParams("getOrCreateProgramTokenAccount", GetOrCreateProgramTokenAccountSchema)(params);
    const mint = parseMint(args.mint, this.mints);
    const existingTokenAccount = this.existingTokenAccounts[mint.toBase58()];
    if (existingTokenAccount) {
      return existingTokenAccount;
    }
    const associatedTokenAdddress = getAssociatedTokenAddressSync(mint, this.programAccount, true);
    let account = null;
    try {
      account = await getAccount(this.client.connection, associatedTokenAdddress);
      this.existingTokenAccounts[mint.toBase58()] = account;
    } catch (error) {
      if (error instanceof TokenAccountNotFoundError) {
        try {
          const instruction = createAssociatedTokenAccountIdempotentInstruction(await this.client.getFeePayer(), associatedTokenAdddress, this.programAccount, mint);
          const {
            lastValidBlockHeight,
            blockhash
          } = await this.client.connection.getLatestBlockhash();
          const msg = new TransactionMessage({
            payerKey: await this.client.getFeePayer(),
            recentBlockhash: blockhash,
            instructions: [instruction]
          });
          const transaction = new VersionedTransaction(msg.compileToV0Message());
          const signature2 = await this.client.sendTransaction(transaction);
          await this.client.connection.confirmTransaction({
            signature: signature2,
            blockhash,
            lastValidBlockHeight
          }, "finalized");
        } catch (e) {
        }
        account = await getAccount(this.client.connection, associatedTokenAdddress);
      } else {
        throw error;
      }
    }
    if (!account.mint.equals(mint)) throw new TokenInvalidMintError();
    if (!account.owner.equals(this.programAccount)) throw new TokenInvalidOwnerError();
    return account;
  }
};
var StemCategory;
(function(StemCategory2) {
  StemCategory2["INSTRUMENTAL"] = "INSTRUMENTAL";
  StemCategory2["LEAD_VOCALS"] = "LEAD_VOCALS";
  StemCategory2["MELODIC_LEAD"] = "MELODIC_LEAD";
  StemCategory2["PAD"] = "PAD";
  StemCategory2["SNARE"] = "SNARE";
  StemCategory2["KICK"] = "KICK";
  StemCategory2["HIHAT"] = "HIHAT";
  StemCategory2["PERCUSSION"] = "PERCUSSION";
  StemCategory2["SAMPLE"] = "SAMPLE";
  StemCategory2["BACKING_VOX"] = "BACKING_VOX";
  StemCategory2["BASS"] = "BASS";
  StemCategory2["OTHER"] = "OTHER";
})(StemCategory || (StemCategory = {}));
var MAX_DESCRIPTION_LENGTH = 2500;
var messages2 = {
  titleRequiredError: "Your track must have a name",
  artworkRequiredError: "Artwork is required",
  genreRequiredError: "Genre is required",
  genreAllError: 'Genre cannot be set to "All Genres"'
};
var EthCollectibleGatedConditions = z.object({
  chain: z.literal("eth"),
  address: z.string(),
  standard: z.union([z.literal("ERC721"), z.literal("ERC1155")]),
  name: z.string(),
  slug: z.string(),
  imageUrl: z.optional(z.string()),
  externalLink: z.optional(z.string()).nullable()
}).strict();
var SolCollectibleGatedConditions = z.object({
  chain: z.literal("sol"),
  address: z.string(),
  name: z.string(),
  imageUrl: z.optional(z.string()),
  externalLink: z.optional(z.string()).nullable()
}).strict();
var CollectibleGatedConditions = z.object({
  nftCollection: z.optional(z.union([EthCollectibleGatedConditions, SolCollectibleGatedConditions]))
}).strict();
var FollowGatedConditions = z.object({
  followUserId: z.number()
}).strict();
var TipGatedConditions = z.object({
  tipUserId: z.number()
}).strict();
var TokenGatedConditions = z.object({
  tokenGate: z.object({
    tokenMint: z.string(),
    tokenAmount: z.number()
  })
}).strict();
var USDCPurchaseConditions = z.object({
  usdcPurchase: z.object({
    price: z.number().positive(),
    splits: z.any()
  })
}).strict();
var UploadTrackMetadataSchema = z.object({
  trackId: z.optional(HashId),
  aiAttributionUserId: z.optional(HashId),
  description: z.optional(z.string().max(MAX_DESCRIPTION_LENGTH)),
  fieldVisibility: z.optional(z.object({
    mood: z.optional(z.boolean()),
    tags: z.optional(z.boolean()),
    genre: z.optional(z.boolean()),
    share: z.optional(z.boolean()),
    playCount: z.optional(z.boolean()),
    remixes: z.optional(z.boolean())
  })),
  genre: z.enum(Object.values(Genre)).nullable().refine((val) => val !== null, {
    message: messages2.genreRequiredError
  }).refine((val) => val !== Genre.ALL, {
    message: messages2.genreAllError
  }),
  isrc: z.optional(z.string().nullable()),
  isUnlisted: z.optional(z.boolean()),
  iswc: z.optional(z.string().nullable()),
  license: z.optional(z.string().nullable()),
  mood: z.optional(z.enum(Object.values(Mood))).nullable(),
  isStreamGated: z.optional(z.boolean()),
  streamConditions: z.optional(z.union([CollectibleGatedConditions, FollowGatedConditions, TipGatedConditions, USDCPurchaseConditions, TokenGatedConditions])).nullable(),
  isDownloadGated: z.optional(z.boolean()),
  downloadConditions: z.optional(z.union([CollectibleGatedConditions, FollowGatedConditions, TipGatedConditions, USDCPurchaseConditions, TokenGatedConditions])).nullable(),
  releaseDate: z.optional(z.date()),
  remixOf: z.optional(z.object({
    tracks: z.array(z.object({
      parentTrackId: HashId
    })).min(1)
  }).strict()),
  stemOf: z.optional(z.object({
    category: z.enum(Object.values(StemCategory)).default(StemCategory.OTHER),
    parentTrackId: HashId
  })),
  tags: z.optional(z.string()),
  title: z.string({
    required_error: messages2.titleRequiredError
  }),
  duration: z.optional(z.number()),
  previewStartSeconds: z.optional(z.number()),
  placementHosts: z.optional(z.string()),
  audioUploadId: z.optional(z.string()),
  trackCid: z.optional(z.string()),
  previewCid: z.optional(z.string()),
  origFileCid: z.optional(z.string()),
  origFilename: z.optional(z.string()),
  isDownloadable: z.optional(z.boolean()),
  isOriginalAvailable: z.optional(z.boolean()),
  ddexReleaseIds: z.optional(z.record(z.string()).nullable()),
  ddexApp: z.optional(z.string()),
  artists: z.optional(z.array(DDEXResourceContributor)).nullable(),
  resourceContributors: z.optional(z.array(DDEXResourceContributor).nullable()),
  indirectResourceContributors: z.optional(z.array(DDEXResourceContributor).nullable()),
  rightsController: z.optional(DDEXRightsController.nullable()),
  copyrightLine: z.optional(DDEXCopyright.nullable()),
  producerCopyrightLine: z.optional(DDEXCopyright.nullable()),
  parentalWarningType: z.optional(z.string().nullable()),
  bpm: z.optional(z.number().nullable()),
  isCustomBpm: z.optional(z.boolean()),
  musicalKey: z.optional(z.string().nullable()),
  isCustomMusicalKey: z.optional(z.boolean()),
  audioAnalysisErrorCount: z.optional(z.number()),
  commentsDisabled: z.optional(z.boolean()),
  isScheduledRelease: z.optional(z.boolean())
});
var UploadTrackSchema = z.object({
  userId: HashId,
  coverArtFile: ImageFile,
  metadata: UploadTrackMetadataSchema.strict(),
  onProgress: z.optional(z.function()),
  trackFile: AudioFile
}).strict();
var UploadTrackFilesSchema = z.object({
  userId: HashId,
  coverArtFile: z.optional(ImageFile),
  metadata: UploadTrackMetadataSchema.extend({
    genre: z.optional(z.enum(Object.values(Genre)))
  }).strict(),
  onProgress: z.optional(z.function()),
  trackFile: AudioFile
}).strict();
var UpdateTrackSchema = z.object({
  userId: HashId,
  trackId: HashId,
  metadata: UploadTrackMetadataSchema.strict().partial(),
  generatePreview: z.optional(z.boolean()),
  coverArtFile: z.optional(ImageFile),
  onProgress: z.optional(z.function())
}).strict();
var DeleteTrackSchema = z.object({
  userId: HashId,
  trackId: HashId
}).strict();
var FavoriteTrackSchema = z.object({
  userId: HashId,
  trackId: HashId,
  metadata: z.optional(z.object({
    /**
     * Is this a save of a repost? Used to dispatch notifications
     * when a user favorites another user's repost
     */
    isSaveOfRepost: z.boolean()
  }).strict())
}).strict();
var UnfavoriteTrackSchema = z.object({
  userId: HashId,
  trackId: HashId
}).strict();
var RepostTrackSchema = z.object({
  userId: HashId,
  trackId: HashId,
  metadata: z.optional(z.object({
    /**
     * Is this a repost of a repost? Used to dispatch notifications
     * when a user favorites another user's repost
     */
    isRepostOfRepost: z.boolean()
  }).strict())
}).strict();
var UnrepostTrackSchema = z.object({
  userId: HashId,
  trackId: HashId
}).strict();
var RecordTrackDownloadSchema = z.object({
  userId: HashId.optional(),
  trackId: HashId
}).strict();
var ShareTrackSchema = z.object({
  userId: HashId,
  trackId: HashId
}).strict();
var PurchaseTrackSchemaBase = z.object({
  /** The ID of the user purchasing the track. */
  userId: HashId,
  /** The ID of the track to purchase. */
  trackId: HashId,
  /**
   * The price of the track at the time of purchase (in dollars if number, USDC if bigint).
   * Used to check against current track price in case it changed,
   * effectively setting a "max price" for the purchase.
   */
  price: z.union([z.number().min(0), z.bigint().min(BigInt(0))]),
  /** Any extra amount the user wants to donate (in dollars if number, USDC if bigint) */
  extraAmount: z.union([z.number().min(0), z.bigint().min(BigInt(0))]).optional(),
  /** Whether to include the staking system as a recipient */
  includeNetworkCut: z.boolean().optional()
});
var GetPurchaseTrackInstructionsSchema = z.object({}).merge(PurchaseTrackSchemaBase);
var PurchaseTrackSchema = z.object({
  /** A wallet to use to purchase (defaults to the authed user's user bank if not specified) */
  walletAdapter: z.custom().optional(),
  /** A wallet to use to purchase (defaults to the authed user's user bank if not specified) */
  wallet: PublicKeySchema.optional()
}).merge(PurchaseTrackSchemaBase).strict();
var CreatePlaylistMetadataSchema = z.object({
  description: z.optional(z.string().max(1e3)),
  playlistName: z.string(),
  isPrivate: z.optional(z.boolean()),
  coverArtCid: z.optional(z.string()),
  license: z.optional(z.string()),
  mood: z.optional(z.enum(Object.values(Mood))),
  releaseDate: z.optional(z.date()),
  ddexReleaseIds: z.optional(z.record(z.string()).nullable()),
  ddexApp: z.optional(z.string()),
  tags: z.optional(z.string()),
  upc: z.optional(z.string()),
  artists: z.optional(z.array(DDEXResourceContributor).nullable()),
  copyrightLine: z.optional(DDEXCopyright.nullable()),
  producerCopyrightLine: z.optional(DDEXCopyright.nullable()),
  parentalWarningType: z.optional(z.string().nullable()),
  isImageAutogenerated: z.optional(z.boolean()).nullable()
}).strict();
var CreatePlaylistSchema = z.object({
  playlistId: z.optional(HashId),
  coverArtFile: z.optional(ImageFile),
  metadata: CreatePlaylistMetadataSchema,
  onProgress: z.optional(z.function()),
  trackIds: z.optional(z.array(HashId)),
  userId: HashId
}).strict();
var UploadPlaylistMetadataSchema = CreatePlaylistMetadataSchema.extend({
  genre: z.enum(Object.values(Genre))
}).strict();
var PlaylistTrackMetadataSchema = UploadTrackMetadataSchema.partial({
  genre: true,
  mood: true,
  tags: true
});
var UpdatePlaylistMetadataSchema = UploadPlaylistMetadataSchema.partial().merge(z.object({
  isPrivate: z.optional(z.boolean()),
  playlistContents: z.optional(z.array(z.object({
    timestamp: z.number(),
    metadataTimestamp: z.optional(z.number()),
    trackId: HashId
  }))),
  coverArtCid: z.optional(z.string())
})).strict();
var UpdatePlaylistSchema = z.object({
  userId: HashId,
  playlistId: HashId,
  coverArtFile: z.optional(ImageFile),
  metadata: UpdatePlaylistMetadataSchema,
  onProgress: z.optional(z.function())
}).strict();
var UploadPlaylistSchema = z.object({
  userId: HashId,
  coverArtFile: ImageFile,
  metadata: UploadPlaylistMetadataSchema,
  onProgress: z.optional(z.function()),
  /**
   * Track metadata is populated from the playlist if fields are missing
   */
  trackMetadatas: z.array(PlaylistTrackMetadataSchema),
  trackFiles: z.array(AudioFile)
}).strict();
var PublishPlaylistSchema = z.object({
  userId: HashId,
  playlistId: HashId
}).strict();
var AddTrackToPlaylistSchema = z.object({
  userId: HashId,
  playlistId: HashId,
  trackId: HashId
}).strict();
var RemoveTrackFromPlaylistSchema = z.object({
  userId: HashId,
  playlistId: HashId,
  trackIndex: z.number()
}).strict();
var DeletePlaylistSchema = z.object({
  userId: HashId,
  playlistId: HashId
}).strict();
var FavoritePlaylistSchema = z.object({
  userId: HashId,
  playlistId: HashId,
  metadata: z.optional(z.object({
    /**
     * Is this a save of a repost? Used to dispatch notifications
     * when a user favorites another user's repost
     */
    isSaveOfRepost: z.boolean()
  }).strict())
}).strict();
var UnfavoritePlaylistSchema = z.object({
  userId: HashId,
  playlistId: HashId
}).strict();
var RepostPlaylistSchema = z.object({
  userId: HashId,
  playlistId: HashId,
  metadata: z.optional(z.object({
    /**
     * Is this a repost of a repost? Used to dispatch notifications
     * when a user favorites another user's repost
     */
    isRepostOfRepost: z.boolean()
  }).strict())
}).strict();
var UnrepostPlaylistSchema = z.object({
  userId: HashId,
  playlistId: HashId
}).strict();
var SharePlaylistSchema = z.object({
  userId: HashId,
  playlistId: HashId
}).strict();
var getCurrentTimestamp = () => {
  return Math.floor(Date.now() / 1e3);
};
var PlaylistsApi$1 = class extends PlaylistsApi$2 {
  constructor(configuration, storage, entityManager, logger) {
    super(configuration);
    _defineProperty$1(this, "storage", void 0);
    _defineProperty$1(this, "entityManager", void 0);
    _defineProperty$1(this, "logger", void 0);
    _defineProperty$1(this, "trackUploadHelper", void 0);
    this.storage = storage;
    this.entityManager = entityManager;
    this.logger = logger;
    this.trackUploadHelper = new TrackUploadHelper(configuration);
    this.logger = logger.createPrefixedLogger("[playlists-api]");
  }
  /** @hidden
   * Create a playlist from existing tracks
   */
  async createPlaylist(params, advancedOptions) {
    const parsedParameters = await parseParams("createPlaylist", CreatePlaylistSchema)(params);
    return await this.createPlaylistInternal(parsedParameters, advancedOptions);
  }
  /** @hidden
   * Upload a playlist
   * Uploads the specified tracks and combines them into a playlist
   */
  async uploadPlaylist(params, advancedOptions) {
    const parsedParameters = await parseParams("uploadPlaylist", UploadPlaylistSchema)(params);
    return await this.uploadPlaylistInternal(parsedParameters, advancedOptions);
  }
  /** @hidden
   * Publish a playlist
   * Changes a playlist from private to public
   */
  async publishPlaylist(params, advancedOptions) {
    await parseParams("publishPlaylist", PublishPlaylistSchema)(params);
    return await this.fetchAndUpdatePlaylist({
      userId: params.userId,
      playlistId: params.playlistId,
      updateMetadata: (playlist) => ({
        ...playlist,
        isPrivate: false
      })
    }, advancedOptions);
  }
  /** @hidden
   * Add a single track to the end of a playlist
   * For more control use updatePlaylist
   */
  async addTrackToPlaylist(params, advancedOptions) {
    await parseParams("addTrackToPlaylist", AddTrackToPlaylistSchema)(params);
    return await this.fetchAndUpdatePlaylist({
      userId: params.userId,
      playlistId: params.playlistId,
      updateMetadata: (playlist) => {
        var _playlist$playlistCon;
        return {
          ...playlist,
          playlistContents: [...(_playlist$playlistCon = playlist.playlistContents) !== null && _playlist$playlistCon !== void 0 ? _playlist$playlistCon : [], {
            trackId: params.trackId,
            timestamp: getCurrentTimestamp()
          }]
        };
      }
    }, advancedOptions);
  }
  /** @hidden
   * Removes a single track at the given index of playlist
   * For more control use updatePlaylist
   */
  async removeTrackFromPlaylist(params, advancedOptions) {
    const {
      trackIndex
    } = await parseParams("removeTrackFromPlaylist", RemoveTrackFromPlaylistSchema)(params);
    return await this.fetchAndUpdatePlaylist({
      userId: params.userId,
      playlistId: params.playlistId,
      updateMetadata: (playlist) => {
        if (!playlist.playlistContents || playlist.playlistContents.length <= trackIndex) {
          throw new Error(`No track exists at index ${trackIndex}`);
        }
        playlist.playlistContents.splice(trackIndex, 1);
        return {
          ...playlist,
          playlistContents: playlist.playlistContents
        };
      }
    }, advancedOptions);
  }
  /** @hidden
   * Update a playlist
   */
  async updatePlaylist(params, advancedOptions) {
    const parsedParameters = await parseParams("updatePlaylist", UpdatePlaylistSchema)(params);
    return await this.updatePlaylistInternal(parsedParameters, advancedOptions);
  }
  /** @hidden
   * Delete a playlist
   */
  async deletePlaylist(params, advancedOptions) {
    const {
      userId,
      playlistId
    } = await parseParams("deletePlaylist", DeletePlaylistSchema)(params);
    return await this.entityManager.manageEntity({
      userId,
      entityType: EntityType.PLAYLIST,
      entityId: playlistId,
      action: Action.DELETE,
      ...advancedOptions
    });
  }
  /** @hidden
   * Favorite a playlist
   */
  async favoritePlaylist(params, advancedOptions) {
    const {
      userId,
      playlistId,
      metadata
    } = await parseParams("favoritePlaylist", FavoritePlaylistSchema)(params);
    return await this.entityManager.manageEntity({
      userId,
      entityType: EntityType.PLAYLIST,
      entityId: playlistId,
      action: Action.SAVE,
      metadata: metadata && JSON.stringify((0, import_snakecase_keys.default)(metadata)),
      ...advancedOptions
    });
  }
  /** @hidden
   * Unfavorite a playlist
   */
  async unfavoritePlaylist(params, advancedOptions) {
    const {
      userId,
      playlistId
    } = await parseParams("unfavoritePlaylist", UnfavoritePlaylistSchema)(params);
    return await this.entityManager.manageEntity({
      userId,
      entityType: EntityType.PLAYLIST,
      entityId: playlistId,
      action: Action.UNSAVE,
      ...advancedOptions
    });
  }
  /** @hidden
   * Repost a playlist
   */
  async repostPlaylist(params, advancedOptions) {
    const {
      userId,
      playlistId,
      metadata
    } = await parseParams("respostPlaylist", RepostPlaylistSchema)(params);
    return await this.entityManager.manageEntity({
      userId,
      entityType: EntityType.PLAYLIST,
      entityId: playlistId,
      action: Action.REPOST,
      metadata: metadata && JSON.stringify((0, import_snakecase_keys.default)(metadata)),
      ...advancedOptions
    });
  }
  /** @hidden
   * Unrepost a playlist
   */
  async unrepostPlaylist(params, advancedOptions) {
    const {
      userId,
      playlistId
    } = await parseParams("unrepostPlaylist", UnrepostPlaylistSchema)(params);
    return await this.entityManager.manageEntity({
      userId,
      entityType: EntityType.PLAYLIST,
      entityId: playlistId,
      action: Action.UNREPOST,
      ...advancedOptions
    });
  }
  /** @hidden
   * Share a playlist
   */
  async sharePlaylist(params, advancedOptions) {
    const {
      userId,
      playlistId
    } = await parseParams("sharePlaylist", SharePlaylistSchema)(params);
    return await this.entityManager.manageEntity({
      userId,
      entityType: EntityType.PLAYLIST,
      entityId: playlistId,
      action: Action.SHARE,
      ...advancedOptions
    });
  }
  /** @internal
   * Combines the metadata for a track and a collection (playlist or album),
   * taking the metadata from the playlist when the track is missing it.
   */
  combineMetadata(trackMetadata, playlistMetadata) {
    const metadata = trackMetadata;
    if (!metadata.mood) metadata.mood = playlistMetadata.mood;
    if (playlistMetadata.tags) {
      if (!metadata.tags) {
        metadata.tags = playlistMetadata.tags;
      } else {
        metadata.tags = [.../* @__PURE__ */ new Set([...metadata.tags.split(","), ...playlistMetadata.tags.split(",")])].join(",");
      }
    }
    return trackMetadata;
  }
  /** @internal
   * Update helper method that first fetches a playlist and then updates it
   */
  async fetchAndUpdatePlaylist(_ref, advancedOptions) {
    var _playlistResponse$dat;
    let {
      userId,
      playlistId,
      updateMetadata
    } = _ref;
    const playlistResponse = await this.getPlaylist({
      playlistId,
      userId
    });
    const playlist = (_playlistResponse$dat = playlistResponse.data) === null || _playlistResponse$dat === void 0 ? void 0 : _playlistResponse$dat[0];
    if (!playlist) {
      throw new Error(`Could not fetch playlist: ${playlistId}`);
    }
    const supportedUpdateFields = Object.keys(UpdatePlaylistMetadataSchema.shape);
    return await this.updatePlaylist({
      userId,
      playlistId,
      metadata: updateMetadata((0, import_lodash.pick)(playlist, supportedUpdateFields))
    }, advancedOptions);
  }
  /** @internal
   * Method to upload a playlist with already parsed inputs
   * This is used for both playlists and albums
   */
  async uploadPlaylistInternal(_ref2, advancedOptions) {
    let {
      userId,
      coverArtFile,
      trackFiles,
      onProgress,
      metadata,
      trackMetadatas
    } = _ref2;
    const [coverArtResponse, ...audioResponses] = await Promise.all([retry3(async () => await this.storage.uploadFile({
      file: coverArtFile,
      onProgress,
      template: "img_square"
    }), (e) => {
      this.logger.info("Retrying uploadPlaylistCoverArt", e);
    }), ...trackFiles.map(async (trackFile, idx) => await retry3(async () => await this.storage.uploadFile({
      file: trackFile,
      onProgress,
      template: "audio",
      options: this.trackUploadHelper.extractMediorumUploadOptions(trackMetadatas[idx])
    }), (e) => {
      this.logger.info("Retrying uploadTrackAudio", e);
    }))]);
    const trackIds = await Promise.all(trackMetadatas.map(async (parsedTrackMetadata, i) => {
      const trackMetadata = this.combineMetadata(this.trackUploadHelper.transformTrackUploadMetadata(parsedTrackMetadata, userId), metadata);
      const audioResponse = audioResponses[i];
      if (!audioResponse) {
        throw new Error(`Failed to upload track: ${trackMetadata.title}`);
      }
      const updatedMetadata2 = this.trackUploadHelper.populateTrackMetadataWithUploadResponse(trackMetadata, audioResponse, coverArtResponse);
      const trackId = await this.trackUploadHelper.generateId("track");
      await this.entityManager.manageEntity({
        userId,
        entityType: EntityType.TRACK,
        entityId: trackId,
        action: Action.CREATE,
        metadata: JSON.stringify({
          cid: "",
          data: (0, import_snakecase_keys.default)(updatedMetadata2)
        }),
        ...advancedOptions
      });
      return trackId;
    }));
    const playlistId = await this.trackUploadHelper.generateId("playlist");
    const timestamp = getCurrentTimestamp();
    const updatedMetadata = {
      ...metadata,
      isPrivate: false,
      playlistContents: trackIds.map((trackId) => ({
        trackId,
        timestamp
      })),
      playlistImageSizesMultihash: coverArtResponse.id
    };
    const response = await this.entityManager.manageEntity({
      userId,
      entityType: EntityType.PLAYLIST,
      entityId: playlistId,
      action: Action.CREATE,
      metadata: JSON.stringify({
        cid: "",
        data: (0, import_snakecase_keys.default)(updatedMetadata)
      }),
      ...advancedOptions
    });
    return {
      ...response,
      playlistId: encodeHashId(playlistId)
    };
  }
  /** @internal
   * Method to update a playlist with already parsed inputs
   * This is used for both playlists and albums
   */
  async updatePlaylistInternal(_ref3, advancedOptions) {
    let {
      userId,
      playlistId,
      coverArtFile,
      onProgress,
      metadata
    } = _ref3;
    const coverArtResponse = coverArtFile && await retry3(async () => await this.storage.uploadFile({
      file: coverArtFile,
      onProgress,
      template: "img_square"
    }), (e) => {
      this.logger.info("Retrying uploadPlaylistCoverArt", e);
    });
    const updatedMetadata = {
      ...metadata,
      ...coverArtResponse ? {
        playlistImageSizesMultihash: coverArtResponse.id
      } : {}
    };
    return await this.entityManager.manageEntity({
      userId,
      entityType: EntityType.PLAYLIST,
      entityId: playlistId,
      action: Action.UPDATE,
      metadata: JSON.stringify({
        cid: "",
        data: (0, import_snakecase_keys.default)(updatedMetadata)
      }),
      ...advancedOptions
    });
  }
  /** @internal
   * Method to create a playlist with already parsed inputs
   * This is used for both playlists and albums
   */
  async createPlaylistInternal(_ref4, advancedOptions) {
    var _coverArtResponse$id;
    let {
      userId,
      coverArtFile,
      metadata,
      onProgress,
      trackIds,
      playlistId: providedPlaylistId
    } = _ref4;
    const coverArtResponse = coverArtFile && await retry3(async () => await this.storage.uploadFile({
      file: coverArtFile,
      onProgress,
      template: "img_square"
    }), (e) => {
      this.logger.info("Retrying uploadPlaylistCoverArt", e);
    });
    const playlistId = providedPlaylistId || await this.generatePlaylistId();
    const timestamp = getCurrentTimestamp();
    const updatedMetadata = {
      ...metadata,
      playlistContents: (trackIds !== null && trackIds !== void 0 ? trackIds : []).map((trackId) => ({
        trackId,
        timestamp
      })),
      playlistImageSizesMultihash: (_coverArtResponse$id = coverArtResponse === null || coverArtResponse === void 0 ? void 0 : coverArtResponse.id) !== null && _coverArtResponse$id !== void 0 ? _coverArtResponse$id : metadata.coverArtCid
    };
    const response = await this.entityManager.manageEntity({
      userId,
      entityType: EntityType.PLAYLIST,
      entityId: playlistId,
      action: Action.CREATE,
      metadata: JSON.stringify({
        cid: "",
        data: (0, import_snakecase_keys.default)(updatedMetadata)
      }),
      ...advancedOptions
    });
    return {
      ...response,
      playlistId: encodeHashId(playlistId)
    };
  }
  /**
   * Generates a new playlist ID
   *
   * @hidden
   */
  async generatePlaylistId() {
    return this.trackUploadHelper.generateId("playlist");
  }
};
var getAlbumSchema = z.object({
  userId: HashId.optional(),
  albumId: HashId
});
var getAlbumsSchema = z.object({
  userId: HashId.optional(),
  id: z.array(HashId)
});
var getAlbumTracksSchema = z.object({
  albumId: HashId
});
var CreateAlbumMetadataSchema = z.object({
  albumName: z.string(),
  isPrivate: z.optional(z.boolean()),
  description: z.optional(z.string().max(1e3)),
  license: z.optional(z.string()),
  releaseDate: z.optional(z.date()),
  ddexReleaseIds: z.optional(z.record(z.string()).nullable()),
  ddexApp: z.optional(z.string()),
  upc: z.optional(z.string()),
  artists: z.optional(z.array(DDEXResourceContributor).nullable()),
  copyrightLine: z.optional(DDEXCopyright.nullable()),
  producerCopyrightLine: z.optional(DDEXCopyright.nullable()),
  parentalWarningType: z.optional(z.string().nullable()),
  isStreamGated: z.optional(z.boolean()),
  streamConditions: z.optional(USDCPurchaseConditions).nullable(),
  isDownloadGated: z.optional(z.boolean()),
  downloadConditions: z.optional(USDCPurchaseConditions).nullable(),
  isScheduledRelease: z.optional(z.boolean())
}).strict();
var CreateAlbumSchema = z.object({
  albumId: z.optional(HashId),
  userId: HashId,
  coverArtFile: z.optional(ImageFile),
  metadata: CreateAlbumMetadataSchema,
  onProgress: z.optional(z.function()),
  trackIds: z.optional(z.array(HashId))
}).strict();
var UploadAlbumMetadataSchema = CreateAlbumMetadataSchema.extend({
  genre: z.enum(Object.values(Genre)),
  mood: z.optional(z.enum(Object.values(Mood))),
  tags: z.optional(z.string())
});
var AlbumTrackMetadataSchema = UploadTrackMetadataSchema.partial({
  genre: true,
  mood: true,
  tags: true,
  isStreamGated: true,
  streamConditions: true,
  isDownloadable: true,
  downloadConditions: true
});
var UpdateAlbumMetadataSchema = UploadAlbumMetadataSchema.partial().merge(z.object({
  playlistContents: z.optional(z.array(z.object({
    timestamp: z.number(),
    metadataTimestamp: z.optional(z.number()),
    trackId: HashId
  })))
})).strict();
var UploadAlbumSchema = z.object({
  userId: HashId,
  coverArtFile: ImageFile,
  metadata: UploadAlbumMetadataSchema,
  onProgress: z.optional(z.function()),
  /**
   * Track metadata is populated from the album if fields are missing
   */
  trackMetadatas: z.array(AlbumTrackMetadataSchema),
  trackFiles: z.array(AudioFile)
}).strict();
var UpdateAlbumSchema = z.object({
  userId: HashId,
  albumId: HashId,
  coverArtFile: z.optional(ImageFile),
  metadata: UpdateAlbumMetadataSchema,
  onProgress: z.optional(z.function())
}).strict();
var DeleteAlbumSchema = z.object({
  userId: HashId,
  albumId: HashId
}).strict();
var FavoriteAlbumSchema = z.object({
  userId: HashId,
  albumId: HashId,
  metadata: z.optional(z.object({
    /**
     * Is this a save of a repost? Used to dispatch notifications
     * when a user favorites another user's repost
     */
    isSaveOfRepost: z.boolean()
  }))
}).strict();
var UnfavoriteAlbumSchema = z.object({
  userId: HashId,
  albumId: HashId
}).strict();
var RepostAlbumSchema = z.object({
  userId: HashId,
  albumId: HashId,
  metadata: z.optional(z.object({
    /**
     * Is this a repost of a repost? Used to dispatch notifications
     * when a user favorites another user's repost
     */
    isRepostOfRepost: z.boolean()
  }))
}).strict();
var UnrepostAlbumSchema = z.object({
  userId: HashId,
  albumId: HashId
}).strict();
var PurchaseAlbumSchemaBase = z.object({
  /** The ID of the user purchasing the album. */
  userId: HashId,
  /** The ID of the album to purchase. */
  albumId: HashId,
  /**
   * The price of the album at the time of purchase (in dollars if number, USDC if bigint).
   * Used to check against current album price in case it changed,
   * effectively setting a "max price" for the purchase.
   */
  price: z.union([z.number().min(0), z.bigint().min(BigInt(0))]),
  /** Any extra amount the user wants to donate (in dollars if number, USDC if bigint) */
  extraAmount: z.union([z.number().min(0), z.bigint().min(BigInt(0))]).optional(),
  /** Whether to include the staking system as a recipient */
  includeNetworkCut: z.boolean().optional()
});
var GetPurchaseAlbumInstructionsSchema = z.object({}).merge(PurchaseAlbumSchemaBase);
var PurchaseAlbumSchema = z.object({
  /** A wallet to use to purchase (defaults to the authed user's user bank if not specified) */
  walletAdapter: z.custom().optional(),
  /** A wallet to use to purchase (defaults to the authed user's user bank if not specified) */
  wallet: PublicKeySchema.optional()
}).merge(PurchaseAlbumSchemaBase).strict();
var AlbumsApi = class {
  constructor(configuration, storage, entityManager, logger, claimableTokensClient, paymentRouterClient, solanaRelay, solanaClient) {
    _defineProperty$1(this, "logger", void 0);
    _defineProperty$1(this, "claimableTokensClient", void 0);
    _defineProperty$1(this, "paymentRouterClient", void 0);
    _defineProperty$1(this, "solanaRelay", void 0);
    _defineProperty$1(this, "solanaClient", void 0);
    _defineProperty$1(this, "playlistsApi", void 0);
    this.logger = logger;
    this.claimableTokensClient = claimableTokensClient;
    this.paymentRouterClient = paymentRouterClient;
    this.solanaRelay = solanaRelay;
    this.solanaClient = solanaClient;
    this.playlistsApi = new PlaylistsApi$1(configuration, storage, entityManager, logger);
  }
  // READS
  async getAlbum(params) {
    const {
      userId,
      albumId
    } = params;
    return await this.playlistsApi.getPlaylist({
      userId,
      playlistId: albumId
    });
  }
  async getBulkAlbums(params) {
    const {
      userId,
      id
    } = params;
    return await this.playlistsApi.getBulkPlaylists({
      userId,
      id
    });
  }
  async getAlbumTracks(params) {
    const {
      albumId
    } = params;
    return await this.playlistsApi.getPlaylistTracks({
      playlistId: albumId
    });
  }
  // WRITES
  /** @hidden
   * Create an album from existing tracks
   */
  async createAlbum(params, advancedOptions) {
    const {
      metadata,
      ...parsedParameters
    } = await parseParams("createAlbum", CreateAlbumSchema)(params);
    const {
      albumName,
      ...playlistMetadata
    } = metadata;
    const response = await this.playlistsApi.createPlaylistInternal({
      ...parsedParameters,
      playlistId: parsedParameters.albumId,
      metadata: {
        ...playlistMetadata,
        playlistName: albumName,
        isAlbum: true
      }
    }, advancedOptions);
    return {
      ...response,
      albumId: response.playlistId
    };
  }
  /** @hidden
   * Upload an album
   * Uploads the specified tracks and combines them into an album
   */
  async uploadAlbum(params, advancedOptions) {
    const {
      metadata,
      ...parsedParameters
    } = await parseParams("uploadAlbum", UploadAlbumSchema)(params);
    const {
      albumName,
      ...playlistMetadata
    } = metadata;
    const response = await this.playlistsApi.uploadPlaylistInternal({
      ...parsedParameters,
      metadata: {
        ...playlistMetadata,
        playlistName: albumName,
        isAlbum: true
      }
    }, advancedOptions);
    return {
      blockHash: response.blockHash,
      blockNumber: response.blockNumber,
      albumId: response.playlistId
    };
  }
  /** @hidden
   * Update an album
   */
  async updateAlbum(params, advancedOptions) {
    const {
      albumId,
      metadata,
      ...parsedParameters
    } = await parseParams("updateAlbum", UpdateAlbumSchema)(params);
    const {
      albumName,
      ...playlistMetadata
    } = metadata;
    return await this.playlistsApi.updatePlaylistInternal({
      ...parsedParameters,
      playlistId: albumId,
      metadata: {
        ...playlistMetadata,
        playlistName: albumName
      }
    }, advancedOptions);
  }
  /** @hidden
   * Delete an album
   */
  async deleteAlbum(params, advancedOptions) {
    await parseParams("deleteAlbum", DeleteAlbumSchema)(params);
    return await this.playlistsApi.deletePlaylist({
      userId: params.userId,
      playlistId: params.albumId
    }, advancedOptions);
  }
  /** @hidden
   * Favorite an album
   */
  async favoriteAlbum(params, advancedOptions) {
    const {
      metadata
    } = await parseParams("favoriteAlbum", FavoriteAlbumSchema)(params);
    return await this.playlistsApi.favoritePlaylist({
      userId: params.userId,
      playlistId: params.albumId,
      metadata
    }, advancedOptions);
  }
  /** @hidden
   * Unfavorite an album
   */
  async unfavoriteAlbum(params, advancedOptions) {
    await parseParams("unfavoriteAlbum", UnfavoriteAlbumSchema)(params);
    return await this.playlistsApi.unfavoritePlaylist({
      userId: params.userId,
      playlistId: params.albumId
    }, advancedOptions);
  }
  /** @hidden
   * Repost an album
   */
  async repostAlbum(params, advancedOptions) {
    const {
      metadata
    } = await parseParams("repostAlbum", RepostAlbumSchema)(params);
    return await this.playlistsApi.repostPlaylist({
      userId: params.userId,
      playlistId: params.albumId,
      metadata
    }, advancedOptions);
  }
  /** @hidden
   * Unrepost an album
   */
  async unrepostAlbum(params, advancedOptions) {
    await parseParams("unrepostAlbum", UnrepostAlbumSchema)(params);
    return await this.playlistsApi.unrepostPlaylist({
      userId: params.userId,
      playlistId: params.albumId
    }, advancedOptions);
  }
  /**
   * Gets the Solana instructions that purchase the album
   *
   * @hidden
   */
  async getPurchaseAlbumInstructions(params) {
    var _album$access;
    const {
      userId,
      albumId,
      price: priceNumber,
      extraAmount: extraAmountNumber = 0
    } = await parseParams("getPurchaseAlbumInstructions", GetPurchaseAlbumInstructionsSchema)(params);
    const contentType = "album";
    const mint = "USDC";
    this.logger.debug("Fetching album...", {
      albumId
    });
    const {
      data: album
    } = await this.playlistsApi.getPlaylistAccessInfo({
      userId: params.userId,
      playlistId: params.albumId
      // use hashed albumId
    });
    if (!album) {
      throw new Error("Album not found.");
    }
    if (!album.isStreamGated) {
      throw new Error("Attempted to purchase free album.");
    }
    if (album.userId === params.userId) {
      throw new Error("Attempted to purchase own album.");
    }
    let numberSplits = [];
    let centPrice;
    const accessType = "stream";
    if (album.streamConditions && instanceOfExtendedPurchaseGate(album.streamConditions)) {
      centPrice = album.streamConditions.usdcPurchase.price;
      numberSplits = album.streamConditions.usdcPurchase.splits;
    } else {
      this.logger.debug(album.streamConditions);
      throw new Error("Album is not available for purchase.");
    }
    if ((_album$access = album.access) !== null && _album$access !== void 0 && _album$access.stream) {
      throw new Error("Album already purchased");
    }
    if (USDC(priceNumber).value < USDC(centPrice / 100).value) {
      throw new Error("Track price increased.");
    }
    const extraAmount = USDC(extraAmountNumber).value;
    const total = USDC(centPrice / 100).value + extraAmount;
    this.logger.debug("Purchase total:", total);
    const splits = await prepareSplits({
      splits: numberSplits,
      extraAmount,
      claimableTokensClient: this.claimableTokensClient,
      logger: this.logger
    });
    this.logger.debug("Calculated splits:", splits);
    const routeInstruction = await this.paymentRouterClient.createRouteInstruction({
      splits,
      total,
      mint
    });
    const memoInstruction = await this.paymentRouterClient.createPurchaseMemoInstruction({
      contentId: albumId,
      contentType,
      blockNumber: album.blocknumber,
      buyerUserId: userId,
      accessType
    });
    let locationMemoInstruction;
    try {
      locationMemoInstruction = await this.solanaRelay.getLocationInstruction();
    } catch (e) {
      this.logger.warn("Unable to compute location memo instruction");
    }
    return {
      instructions: {
        routeInstruction,
        memoInstruction,
        locationMemoInstruction
      },
      total
    };
  }
  /**
   * Purchases stream access to an album
   *
   * @hidden
   */
  async purchaseAlbum(params) {
    const {
      wallet
    } = await parseParams("purchaseAlbum", PurchaseAlbumSchema)(params);
    const {
      // only send the base params to getPurchaseInstructions
      wallet: ignoredWallet,
      walletAdapter: ignoredWalletAdapter,
      ...baseParams
    } = params;
    const {
      instructions: {
        routeInstruction,
        memoInstruction,
        locationMemoInstruction
      },
      total
    } = await this.getPurchaseAlbumInstructions(baseParams);
    let transaction;
    const mint = "USDC";
    if (wallet) {
      this.logger.debug("Using provided wallet to purchase...", {
        wallet: wallet.toBase58()
      });
      const transferInstruction = await this.paymentRouterClient.createTransferInstruction({
        sourceWallet: wallet,
        total,
        mint
      });
      transaction = await this.solanaClient.buildTransaction({
        feePayer: wallet,
        instructions: [transferInstruction, routeInstruction, memoInstruction, locationMemoInstruction].filter(Boolean)
      });
    } else {
      this.logger.debug(`Using userBank ${await this.claimableTokensClient.deriveUserBank({
        mint: "USDC"
      })} to purchase...`);
      const paymentRouterTokenAccount = await this.paymentRouterClient.getOrCreateProgramTokenAccount({
        mint
      });
      const transferSecpInstruction = await this.claimableTokensClient.createTransferSecpInstruction({
        destination: paymentRouterTokenAccount.address,
        mint,
        amount: total
      });
      const transferInstruction = await this.claimableTokensClient.createTransferInstruction({
        destination: paymentRouterTokenAccount.address,
        mint
      });
      transaction = await this.solanaClient.buildTransaction({
        feePayer: wallet,
        instructions: [transferSecpInstruction, transferInstruction, routeInstruction, memoInstruction, locationMemoInstruction].filter(Boolean)
      });
    }
    if (params.walletAdapter) {
      if (!params.walletAdapter.publicKey) {
        throw new Error("Param walletAdapter was specified, but no wallet selected");
      }
      return await params.walletAdapter.sendTransaction(transaction, this.solanaClient.connection);
    }
    return this.solanaClient.sendTransaction(transaction, {
      skipPreflight: true
    });
  }
};
function EventEmitter3() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || void 0;
}
var events = EventEmitter3;
EventEmitter3.EventEmitter = EventEmitter3;
EventEmitter3.prototype._events = void 0;
EventEmitter3.prototype._maxListeners = void 0;
EventEmitter3.defaultMaxListeners = 10;
EventEmitter3.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n)) throw TypeError("n must be a positive number");
  this._maxListeners = n;
  return this;
};
EventEmitter3.prototype.emit = function(type3) {
  var er, handler, len, args, i, listeners;
  if (!this._events) this._events = {};
  if (type3 === "error") {
    if (!this._events.error || isObject3(this._events.error) && !this._events.error.length) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er;
      } else {
        var err2 = new Error('Uncaught, unspecified "error" event. (' + er + ")");
        err2.context = er;
        throw err2;
      }
    }
  }
  handler = this._events[type3];
  if (isUndefined(handler)) return false;
  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        args = Array.prototype.slice.call(arguments, 1);
        handler.apply(this, args);
    }
  } else if (isObject3(handler)) {
    args = Array.prototype.slice.call(arguments, 1);
    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++) listeners[i].apply(this, args);
  }
  return true;
};
EventEmitter3.prototype.addListener = function(type3, listener) {
  var m;
  if (!isFunction(listener)) throw TypeError("listener must be a function");
  if (!this._events) this._events = {};
  if (this._events.newListener) this.emit("newListener", type3, isFunction(listener.listener) ? listener.listener : listener);
  if (!this._events[type3])
    this._events[type3] = listener;
  else if (isObject3(this._events[type3]))
    this._events[type3].push(listener);
  else
    this._events[type3] = [this._events[type3], listener];
  if (isObject3(this._events[type3]) && !this._events[type3].warned) {
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter3.defaultMaxListeners;
    }
    if (m && m > 0 && this._events[type3].length > m) {
      this._events[type3].warned = true;
      console.error("(node) warning: possible EventEmitter memory leak detected. %d listeners added. Use emitter.setMaxListeners() to increase limit.", this._events[type3].length);
      if (typeof console.trace === "function") {
        console.trace();
      }
    }
  }
  return this;
};
EventEmitter3.prototype.on = EventEmitter3.prototype.addListener;
EventEmitter3.prototype.once = function(type3, listener) {
  if (!isFunction(listener)) throw TypeError("listener must be a function");
  var fired = false;
  function g() {
    this.removeListener(type3, g);
    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }
  g.listener = listener;
  this.on(type3, g);
  return this;
};
EventEmitter3.prototype.removeListener = function(type3, listener) {
  var list, position, length2, i;
  if (!isFunction(listener)) throw TypeError("listener must be a function");
  if (!this._events || !this._events[type3]) return this;
  list = this._events[type3];
  length2 = list.length;
  position = -1;
  if (list === listener || isFunction(list.listener) && list.listener === listener) {
    delete this._events[type3];
    if (this._events.removeListener) this.emit("removeListener", type3, listener);
  } else if (isObject3(list)) {
    for (i = length2; i-- > 0; ) {
      if (list[i] === listener || list[i].listener && list[i].listener === listener) {
        position = i;
        break;
      }
    }
    if (position < 0) return this;
    if (list.length === 1) {
      list.length = 0;
      delete this._events[type3];
    } else {
      list.splice(position, 1);
    }
    if (this._events.removeListener) this.emit("removeListener", type3, listener);
  }
  return this;
};
EventEmitter3.prototype.removeAllListeners = function(type3) {
  var key, listeners;
  if (!this._events) return this;
  if (!this._events.removeListener) {
    if (arguments.length === 0) this._events = {};
    else if (this._events[type3]) delete this._events[type3];
    return this;
  }
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === "removeListener") continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners("removeListener");
    this._events = {};
    return this;
  }
  listeners = this._events[type3];
  if (isFunction(listeners)) {
    this.removeListener(type3, listeners);
  } else if (listeners) {
    while (listeners.length) this.removeListener(type3, listeners[listeners.length - 1]);
  }
  delete this._events[type3];
  return this;
};
EventEmitter3.prototype.listeners = function(type3) {
  var ret;
  if (!this._events || !this._events[type3]) ret = [];
  else if (isFunction(this._events[type3])) ret = [this._events[type3]];
  else ret = this._events[type3].slice();
  return ret;
};
EventEmitter3.prototype.listenerCount = function(type3) {
  if (this._events) {
    var evlistener = this._events[type3];
    if (isFunction(evlistener)) return 1;
    else if (evlistener) return evlistener.length;
  }
  return 0;
};
EventEmitter3.listenerCount = function(emitter, type3) {
  return emitter.listenerCount(type3);
};
function isFunction(arg) {
  return typeof arg === "function";
}
function isNumber(arg) {
  return typeof arg === "number";
}
function isObject3(arg) {
  return typeof arg === "object" && arg !== null;
}
function isUndefined(arg) {
  return arg === void 0;
}
function assertNumber(n) {
  if (!Number.isSafeInteger(n)) throw new Error(`Wrong integer: ${n}`);
}
function chain() {
  const wrap = (a, b) => (c) => a(b(c));
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  const encode4 = Array.from(args).reverse().reduce((acc, i) => acc ? wrap(acc, i.encode) : i.encode, void 0);
  const decode4 = args.reduce((acc, i) => acc ? wrap(acc, i.decode) : i.decode, void 0);
  return {
    encode: encode4,
    decode: decode4
  };
}
function alphabet(alphabet2) {
  return {
    encode: (digits) => {
      if (!Array.isArray(digits) || digits.length && typeof digits[0] !== "number") throw new Error("alphabet.encode input should be an array of numbers");
      return digits.map((i) => {
        assertNumber(i);
        if (i < 0 || i >= alphabet2.length) throw new Error(`Digit index outside alphabet: ${i} (alphabet: ${alphabet2.length})`);
        return alphabet2[i];
      });
    },
    decode: (input) => {
      if (!Array.isArray(input) || input.length && typeof input[0] !== "string") throw new Error("alphabet.decode input should be array of strings");
      return input.map((letter) => {
        if (typeof letter !== "string") throw new Error(`alphabet.decode: not string element=${letter}`);
        const index4 = alphabet2.indexOf(letter);
        if (index4 === -1) throw new Error(`Unknown letter: "${letter}". Allowed: ${alphabet2}`);
        return index4;
      });
    }
  };
}
function join() {
  let separator = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
  if (typeof separator !== "string") throw new Error("join separator should be string");
  return {
    encode: (from2) => {
      if (!Array.isArray(from2) || from2.length && typeof from2[0] !== "string") throw new Error("join.encode input should be array of strings");
      for (let i of from2) if (typeof i !== "string") throw new Error(`join.encode: non-string input=${i}`);
      return from2.join(separator);
    },
    decode: (to) => {
      if (typeof to !== "string") throw new Error("join.decode input should be string");
      return to.split(separator);
    }
  };
}
function padding(bits) {
  let chr = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "=";
  assertNumber(bits);
  if (typeof chr !== "string") throw new Error("padding chr should be string");
  return {
    encode(data) {
      if (!Array.isArray(data) || data.length && typeof data[0] !== "string") throw new Error("padding.encode input should be array of strings");
      for (let i of data) if (typeof i !== "string") throw new Error(`padding.encode: non-string input=${i}`);
      while (data.length * bits % 8) data.push(chr);
      return data;
    },
    decode(input) {
      if (!Array.isArray(input) || input.length && typeof input[0] !== "string") throw new Error("padding.encode input should be array of strings");
      for (let i of input) if (typeof i !== "string") throw new Error(`padding.decode: non-string input=${i}`);
      let end = input.length;
      if (end * bits % 8) throw new Error("Invalid padding: string should have whole number of bytes");
      for (; end > 0 && input[end - 1] === chr; end--) {
        if (!((end - 1) * bits % 8)) throw new Error("Invalid padding: string has too much padding");
      }
      return input.slice(0, end);
    }
  };
}
function normalize(fn) {
  if (typeof fn !== "function") throw new Error("normalize fn should be function");
  return {
    encode: (from2) => from2,
    decode: (to) => fn(to)
  };
}
function convertRadix(data, from2, to) {
  if (from2 < 2) throw new Error(`convertRadix: wrong from=${from2}, base cannot be less than 2`);
  if (to < 2) throw new Error(`convertRadix: wrong to=${to}, base cannot be less than 2`);
  if (!Array.isArray(data)) throw new Error("convertRadix: data should be array");
  if (!data.length) return [];
  let pos = 0;
  const res = [];
  const digits = Array.from(data);
  digits.forEach((d) => {
    assertNumber(d);
    if (d < 0 || d >= from2) throw new Error(`Wrong integer: ${d}`);
  });
  while (true) {
    let carry = 0;
    let done = true;
    for (let i = pos; i < digits.length; i++) {
      const digit = digits[i];
      const digitBase = from2 * carry + digit;
      if (!Number.isSafeInteger(digitBase) || from2 * carry / from2 !== carry || digitBase - digit !== from2 * carry) {
        throw new Error("convertRadix: carry overflow");
      }
      carry = digitBase % to;
      digits[i] = Math.floor(digitBase / to);
      if (!Number.isSafeInteger(digits[i]) || digits[i] * to + carry !== digitBase) throw new Error("convertRadix: carry overflow");
      if (!done) continue;
      else if (!digits[i]) pos = i;
      else done = false;
    }
    res.push(carry);
    if (done) break;
  }
  for (let i = 0; i < data.length - 1 && data[i] === 0; i++) res.push(0);
  return res.reverse();
}
var gcd = (a, b) => !b ? a : gcd(b, a % b);
var radix2carry = (from2, to) => from2 + (to - gcd(from2, to));
function convertRadix2(data, from2, to, padding2) {
  if (!Array.isArray(data)) throw new Error("convertRadix2: data should be array");
  if (from2 <= 0 || from2 > 32) throw new Error(`convertRadix2: wrong from=${from2}`);
  if (to <= 0 || to > 32) throw new Error(`convertRadix2: wrong to=${to}`);
  if (radix2carry(from2, to) > 32) {
    throw new Error(`convertRadix2: carry overflow from=${from2} to=${to} carryBits=${radix2carry(from2, to)}`);
  }
  let carry = 0;
  let pos = 0;
  const mask3 = 2 ** to - 1;
  const res = [];
  for (const n of data) {
    assertNumber(n);
    if (n >= 2 ** from2) throw new Error(`convertRadix2: invalid data word=${n} from=${from2}`);
    carry = carry << from2 | n;
    if (pos + from2 > 32) throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from2}`);
    pos += from2;
    for (; pos >= to; pos -= to) res.push((carry >> pos - to & mask3) >>> 0);
    carry &= 2 ** pos - 1;
  }
  carry = carry << to - pos & mask3;
  if (!padding2 && pos >= from2) throw new Error("Excess padding");
  if (!padding2 && carry) throw new Error(`Non-zero padding: ${carry}`);
  if (padding2 && pos > 0) res.push(carry >>> 0);
  return res;
}
function radix(num2) {
  assertNumber(num2);
  return {
    encode: (bytes3) => {
      if (!(bytes3 instanceof Uint8Array)) throw new Error("radix.encode input should be Uint8Array");
      return convertRadix(Array.from(bytes3), 2 ** 8, num2);
    },
    decode: (digits) => {
      if (!Array.isArray(digits) || digits.length && typeof digits[0] !== "number") throw new Error("radix.decode input should be array of strings");
      return Uint8Array.from(convertRadix(digits, num2, 2 ** 8));
    }
  };
}
function radix2(bits) {
  let revPadding = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  assertNumber(bits);
  if (bits <= 0 || bits > 32) throw new Error("radix2: bits should be in (0..32]");
  if (radix2carry(8, bits) > 32 || radix2carry(bits, 8) > 32) throw new Error("radix2: carry overflow");
  return {
    encode: (bytes3) => {
      if (!(bytes3 instanceof Uint8Array)) throw new Error("radix2.encode input should be Uint8Array");
      return convertRadix2(Array.from(bytes3), 8, bits, !revPadding);
    },
    decode: (digits) => {
      if (!Array.isArray(digits) || digits.length && typeof digits[0] !== "number") throw new Error("radix2.decode input should be array of strings");
      return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));
    }
  };
}
function unsafeWrapper(fn) {
  if (typeof fn !== "function") throw new Error("unsafeWrapper fn should be function");
  return function() {
    try {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      return fn.apply(null, args);
    } catch (e) {
    }
  };
}
var base16 = chain(radix2(4), alphabet("0123456789ABCDEF"), join(""));
var base32$1 = chain(radix2(5), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), padding(5), join(""));
chain(radix2(5), alphabet("0123456789ABCDEFGHIJKLMNOPQRSTUV"), padding(5), join(""));
chain(radix2(5), alphabet("0123456789ABCDEFGHJKMNPQRSTVWXYZ"), join(""), normalize((s) => s.toUpperCase().replace(/O/g, "0").replace(/[IL]/g, "1")));
var base642 = chain(radix2(6), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), padding(6), join(""));
var base64url = chain(radix2(6), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), padding(6), join(""));
var genBase58 = (abc) => chain(radix(58), alphabet(abc), join(""));
var base58 = genBase58("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");
genBase58("123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ");
genBase58("rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz");
var XMR_BLOCK_LEN = [0, 2, 3, 5, 6, 7, 9, 10, 11];
var base58xmr = {
  encode(data) {
    let res = "";
    for (let i = 0; i < data.length; i += 8) {
      const block = data.subarray(i, i + 8);
      res += base58.encode(block).padStart(XMR_BLOCK_LEN[block.length], "1");
    }
    return res;
  },
  decode(str2) {
    let res = [];
    for (let i = 0; i < str2.length; i += 11) {
      const slice3 = str2.slice(i, i + 11);
      const blockLen = XMR_BLOCK_LEN.indexOf(slice3.length);
      const block = base58.decode(slice3);
      for (let j = 0; j < block.length - blockLen; j++) {
        if (block[j] !== 0) throw new Error("base58xmr: wrong padding");
      }
      res = res.concat(Array.from(block.slice(block.length - blockLen)));
    }
    return Uint8Array.from(res);
  }
};
var BECH_ALPHABET = chain(alphabet("qpzry9x8gf2tvdw0s3jn54khce6mua7l"), join(""));
var POLYMOD_GENERATORS = [996825010, 642813549, 513874426, 1027748829, 705979059];
function bech32Polymod(pre) {
  const b = pre >> 25;
  let chk = (pre & 33554431) << 5;
  for (let i = 0; i < POLYMOD_GENERATORS.length; i++) {
    if ((b >> i & 1) === 1) chk ^= POLYMOD_GENERATORS[i];
  }
  return chk;
}
function bechChecksum(prefix, words) {
  let encodingConst = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
  const len = prefix.length;
  let chk = 1;
  for (let i = 0; i < len; i++) {
    const c = prefix.charCodeAt(i);
    if (c < 33 || c > 126) throw new Error(`Invalid prefix (${prefix})`);
    chk = bech32Polymod(chk) ^ c >> 5;
  }
  chk = bech32Polymod(chk);
  for (let i = 0; i < len; i++) chk = bech32Polymod(chk) ^ prefix.charCodeAt(i) & 31;
  for (let v of words) chk = bech32Polymod(chk) ^ v;
  for (let i = 0; i < 6; i++) chk = bech32Polymod(chk);
  chk ^= encodingConst;
  return BECH_ALPHABET.encode(convertRadix2([chk % 2 ** 30], 30, 5, false));
}
function genBech32(encoding) {
  const ENCODING_CONST = encoding === "bech32" ? 1 : 734539939;
  const _words = radix2(5);
  const fromWords = _words.decode;
  const toWords = _words.encode;
  const fromWordsUnsafe = unsafeWrapper(fromWords);
  function encode4(prefix, words) {
    let limit = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 90;
    if (typeof prefix !== "string") throw new Error(`bech32.encode prefix should be string, not ${typeof prefix}`);
    if (!Array.isArray(words) || words.length && typeof words[0] !== "number") throw new Error(`bech32.encode words should be array of numbers, not ${typeof words}`);
    const actualLength = prefix.length + 7 + words.length;
    if (limit !== false && actualLength > limit) throw new TypeError(`Length ${actualLength} exceeds limit ${limit}`);
    prefix = prefix.toLowerCase();
    return `${prefix}1${BECH_ALPHABET.encode(words)}${bechChecksum(prefix, words, ENCODING_CONST)}`;
  }
  function decode4(str2) {
    let limit = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 90;
    if (typeof str2 !== "string") throw new Error(`bech32.decode input should be string, not ${typeof str2}`);
    if (str2.length < 8 || limit !== false && str2.length > limit) throw new TypeError(`Wrong string length: ${str2.length} (${str2}). Expected (8..${limit})`);
    const lowered = str2.toLowerCase();
    if (str2 !== lowered && str2 !== str2.toUpperCase()) throw new Error(`String must be lowercase or uppercase`);
    str2 = lowered;
    const sepIndex = str2.lastIndexOf("1");
    if (sepIndex === 0 || sepIndex === -1) throw new Error(`Letter "1" must be present between prefix and data only`);
    const prefix = str2.slice(0, sepIndex);
    const _words2 = str2.slice(sepIndex + 1);
    if (_words2.length < 6) throw new Error("Data must be at least 6 characters long");
    const words = BECH_ALPHABET.decode(_words2).slice(0, -6);
    const sum = bechChecksum(prefix, words, ENCODING_CONST);
    if (!_words2.endsWith(sum)) throw new Error(`Invalid checksum in ${str2}: expected "${sum}"`);
    return {
      prefix,
      words
    };
  }
  const decodeUnsafe = unsafeWrapper(decode4);
  function decodeToBytes(str2) {
    const {
      prefix,
      words
    } = decode4(str2, false);
    return {
      prefix,
      words,
      bytes: fromWords(words)
    };
  }
  return {
    encode: encode4,
    decode: decode4,
    decodeToBytes,
    decodeUnsafe,
    fromWords,
    fromWordsUnsafe,
    toWords
  };
}
genBech32("bech32");
genBech32("bech32m");
var utf83 = {
  encode: (data) => new TextDecoder().decode(data),
  decode: (str2) => new TextEncoder().encode(str2)
};
var hex2 = chain(radix2(4), alphabet("0123456789abcdef"), join(""), normalize((s) => {
  if (typeof s !== "string" || s.length % 2) throw new TypeError(`hex.decode: expected string, got ${typeof s} with length ${s.length}`);
  return s.toLowerCase();
}));
var CODERS = {
  utf8: utf83,
  hex: hex2,
  base16,
  base32: base32$1,
  base64: base642,
  base64url,
  base58,
  base58xmr
};
`Invalid encoding type. Available types: ${Object.keys(CODERS).join(", ")}`;
var CryptoUtils = class _CryptoUtils {
  /**
   * Encrypts data using AES with the last 32 bytes of the secret
   * @param secret The secret key for encryption
   * @param payload The data to encrypt
   */
  static async encrypt(secret, payload) {
    return await encrypt(secret.slice(secret.length - 32), payload);
  }
  /**
   * Encrypts a string using AES with the last 32 bytes of the secret
   * @param secret The secret key for encryption
   * @param payload The string to encrypt
   */
  static async encryptString(secret, payload) {
    return await _CryptoUtils.encrypt(secret, new TextEncoder().encode(payload));
  }
  /**
   * Decrypts data using AES with the last 32 bytes of the secret
   * @param secret The secret key for decryption
   * @param payload The data to decrypt
   */
  static async decrypt(secret, payload) {
    return await decrypt(secret.slice(secret.length - 32), payload);
  }
  /**
   * Decrypts data and converts it to a string using AES with the last 32 bytes of the secret
   * @param secret The secret key for decryption
   * @param payload The data to decrypt
   */
  static async decryptString(secret, payload) {
    return new TextDecoder().decode(await _CryptoUtils.decrypt(secret, payload));
  }
};
var ChatPermission;
(function(ChatPermission2) {
  ChatPermission2["ALL"] = "all";
  ChatPermission2["TIPPEES"] = "tippees";
  ChatPermission2["TIPPERS"] = "tippers";
  ChatPermission2["FOLLOWEES"] = "followees";
  ChatPermission2["FOLLOWERS"] = "followers";
  ChatPermission2["VERIFIED"] = "verified";
  ChatPermission2["NONE"] = "none";
})(ChatPermission || (ChatPermission = {}));
var ChatBlastAudience;
(function(ChatBlastAudience2) {
  ChatBlastAudience2["FOLLOWERS"] = "follower_audience";
  ChatBlastAudience2["TIPPERS"] = "tipper_audience";
  ChatBlastAudience2["REMIXERS"] = "remixer_audience";
  ChatBlastAudience2["CUSTOMERS"] = "customer_audience";
  ChatBlastAudience2["COIN_HOLDERS"] = "coin_holder_audience";
})(ChatBlastAudience || (ChatBlastAudience = {}));
var ChatGetAllRequestSchema = z.object({
  userId: z.string(),
  limit: z.optional(z.number()),
  before: z.optional(z.string()),
  after: z.optional(z.string())
});
var ChatGetRequestSchema = z.object({
  currentUserId: z.optional(z.string()),
  chatId: z.string()
});
var ChatGetMessagesRequestSchema = z.object({
  currentUserId: z.optional(z.string()),
  chatId: z.string(),
  isBlast: z.optional(z.boolean()),
  limit: z.optional(z.number()),
  before: z.optional(z.string()),
  after: z.optional(z.string())
});
var ChatGetUnreadCountRequestSchema = z.optional(z.object({
  currentUserId: z.optional(z.string())
}));
var ChatGetBlockersRequestSchema = z.optional(z.object({
  currentUserId: z.optional(z.string())
}));
var ChatCreateRequestSchema = z.object({
  currentUserId: z.optional(z.string()),
  userId: z.string(),
  invitedUserIds: z.array(z.string()).min(1)
});
var ChatInviteRequestSchema = z.object({
  currentUserId: z.optional(z.string()),
  chatId: z.string(),
  userId: z.string(),
  invitedUserIds: z.array(z.string()).min(1)
});
var ChatMessageRequestSchema = z.object({
  currentUserId: z.optional(z.string()),
  chatId: z.string(),
  messageId: z.optional(z.string()),
  message: z.string()
});
var ChatBlastMessageRequestSchema = z.object({
  currentUserId: z.optional(z.string()),
  blastId: z.string(),
  message: z.string(),
  audience: z.nativeEnum(ChatBlastAudience),
  audienceContentId: z.optional(z.string()),
  audienceContentType: z.optional(z.enum(["track", "album"]))
});
var ChatReactRequestSchema = z.object({
  currentUserId: z.optional(z.string()),
  chatId: z.string(),
  messageId: z.string(),
  reaction: z.nullable(z.string())
});
var ChatReadRequestSchema = z.object({
  currentUserId: z.optional(z.string()),
  chatId: z.string()
});
var ChatBlockRequestSchema = z.object({
  currentUserId: z.optional(z.string()),
  userId: z.string()
});
var ChatDeleteRequestSchema = z.object({
  currentUserId: z.optional(z.string()),
  chatId: z.string()
});
var ChatPermitRequestSchema = z.object({
  currentUserId: z.optional(z.string()),
  permit: z.optional(z.nativeEnum(ChatPermission)),
  permitList: z.optional(z.array(z.nativeEnum(ChatPermission)).min(1)),
  allow: z.optional(z.boolean())
});
var ChatValidateCanCreateRequestSchema = z.object({
  currentUserId: z.optional(z.string()),
  userIds: z.array(z.string()).min(1)
});
var ChatGetPermissionRequestSchema = z.object({
  currentUserId: z.optional(z.string()),
  userIds: z.array(z.string()).min(1)
});
var ChatUnfurlRequestSchema = z.object({
  urls: z.array(z.string()).min(1)
});
var GENERIC_MESSAGE_ERROR = "Error: this message cannot be displayed";
var ChatsApi = class extends BaseAPI$1 {
  constructor(config, audiusWalletClient, logger) {
    super(config);
    _defineProperty$1(this, "audiusWalletClient", void 0);
    _defineProperty$1(this, "logger", void 0);
    _defineProperty$1(this, "chatSecrets", {});
    _defineProperty$1(this, "publicKeyCache", {});
    _defineProperty$1(this, "eventEmitter", void 0);
    _defineProperty$1(this, "addEventListener", void 0);
    _defineProperty$1(this, "removeEventListener", void 0);
    this.audiusWalletClient = audiusWalletClient;
    this.logger = logger;
    this.eventEmitter = new events();
    this.addEventListener = this.eventEmitter.addListener.bind(this.eventEmitter);
    this.removeEventListener = this.eventEmitter.removeListener.bind(this.eventEmitter);
    this.logger = logger.createPrefixedLogger("[chats-api]");
  }
  // #region QUERY
  /**
   * Establishes a websocket connection for listening to chat events.
   * @param params.currentUserId the user to listen for chat events for
   */
  async listen() {
    await this.createWebsocket(this.configuration.basePath);
  }
  /**
   * Gets a single chat
   * @param params.chatId the chat to get
   * @param params.currentUserId the user to act on behalf of
   * @returns the chat response
   */
  async get(params) {
    const {
      chatId,
      currentUserId
    } = await parseParams("get", ChatGetRequestSchema)(params);
    const response = await this.getRaw(chatId, currentUserId);
    return {
      ...response,
      data: response.data ? await this.decryptLastChatMessage(response.data) : response.data
    };
  }
  /**
   * Gets a list of chats
   * @param params.limit the max number of chats to get
   * @param params.before a timestamp cursor for pagination
   * @param params.after a timestamp cursor for pagination
   * @param params.userId the user to act on behalf of
   * @returns the chat list response
   */
  async getAll(params) {
    const {
      userId,
      limit,
      before,
      after
    } = await parseParams("getAll", ChatGetAllRequestSchema)(params);
    this.upgradeBlasts(userId);
    const path = `/comms/chats`;
    const query = {
      timestamp: (/* @__PURE__ */ new Date()).getTime()
    };
    if (limit) {
      query.limit = limit;
    }
    if (before) {
      query.before = before;
    }
    if (after) {
      query.after = after;
    }
    if (userId) {
      query.current_user_id = userId;
    }
    const response = await this.signAndSendRequest({
      method: "GET",
      headers: {},
      path,
      query
    });
    const json = await response.json();
    const decrypted = await Promise.all(json.data.map(async (c) => await this.decryptLastChatMessage(c)));
    return {
      ...json,
      data: decrypted
    };
  }
  /**
   * Gets a list of messages
   * @param params.chatId the chat to get messages for
   * @param params.before a timestamp cursor for pagination
   * @param params.after a timestamp cursor for pagination
   * @param params.currentUserId the user to act on behalf of
   * @returns the messages list response
   */
  async getMessages(params) {
    const {
      currentUserId,
      chatId,
      isBlast,
      limit,
      before,
      after
    } = await parseParams("getMessages", ChatGetMessagesRequestSchema)(params);
    let sharedSecret;
    if (!isBlast) {
      try {
        sharedSecret = await this.getChatSecret(chatId);
      } catch (e) {
        this.logger.error("[audius-sdk] Couldn't get chat secret", e);
        throw new Error("[audius-sdk] Couldn't get chat secret");
      }
    }
    const path = `/comms/chats/${chatId}/messages`;
    const query = {
      timestamp: (/* @__PURE__ */ new Date()).getTime()
    };
    if (isBlast) {
      query.is_blast = isBlast;
    }
    if (limit) {
      query.limit = limit;
    }
    if (before) {
      query.before = before;
    }
    if (after) {
      query.after = after;
    }
    if (currentUserId) {
      query.current_user_id = currentUserId;
    }
    const response = await this.signAndSendRequest({
      method: "GET",
      headers: {},
      path,
      query
    });
    const json = await response.json();
    const decrypted = await Promise.all(json.data.map(async (m) => ({
      ...m,
      message: m.is_plaintext ? m.message : await CryptoUtils.decryptString(sharedSecret, base642.decode(m.message)).catch((e) => {
        this.logger.error("[audius-sdk]: Error: Couldn't decrypt chat message", m, e);
        return GENERIC_MESSAGE_ERROR;
      })
    })));
    return {
      ...json,
      data: decrypted
    };
  }
  /**
   * Gets a list of chat blasts for which chats haven't been created yet
   * @returns the blast messages list response
   */
  async getBlasts() {
    const query = {
      timestamp: (/* @__PURE__ */ new Date()).getTime()
    };
    const res = await this.signAndSendRequest({
      method: "GET",
      path: `/comms/blasts`,
      headers: {},
      query
    });
    return await res.json();
  }
  /**
   * Gets the total unread message count for a user
   * @param params.currentUserId the user to act on behalf of
   * @returns the unread count response
   */
  async getUnreadCount(params) {
    const parsedArgs = await parseParams("getUnreadCount", ChatGetUnreadCountRequestSchema)(params);
    const query = {
      timestamp: (/* @__PURE__ */ new Date()).getTime()
    };
    if (parsedArgs !== null && parsedArgs !== void 0 && parsedArgs.currentUserId) {
      query.current_user_id = parsedArgs.currentUserId;
    }
    const res = await this.signAndSendRequest({
      method: "GET",
      path: `/comms/chats/unread`,
      headers: {},
      query
    });
    return await res.json();
  }
  /**
   * Gets the permission settings of the given users
   * @param params.userIds the users to fetch permissions of
   * @param params.currentUserId the user to act on behalf of
   * @returns the permissions response
   */
  async getPermissions(params) {
    const query = {
      timestamp: (/* @__PURE__ */ new Date()).getTime()
    };
    const {
      userIds,
      currentUserId
    } = await parseParams("getPermissions", ChatGetPermissionRequestSchema)(params);
    query.id = userIds;
    if (currentUserId) {
      query.current_user_id = currentUserId;
    }
    const res = await this.signAndSendRequest({
      method: "GET",
      path: "/comms/chats/permissions",
      headers: {},
      query
    });
    return await res.json();
  }
  /**
   * Gets the user ids that have blocked the current user
   * @param params.currentUserId the user to act on behalf of
   * @returns the blockers response
   */
  async getBlockers(params) {
    const parsedArgs = await parseParams("getBlockers", ChatGetBlockersRequestSchema)(params);
    const query = {
      timestamp: (/* @__PURE__ */ new Date()).getTime()
    };
    if (parsedArgs !== null && parsedArgs !== void 0 && parsedArgs.currentUserId) {
      query.current_user_id = parsedArgs.currentUserId;
    }
    const response = await this.signAndSendRequest({
      method: "GET",
      path: `/comms/chats/blockers`,
      headers: {},
      query
    });
    return await response.json();
  }
  /**
   * Gets the user ids the current user has blocked
   * @param params.currentUserId the user to act on behalf of
   * @returns
   */
  async getBlockees(params) {
    const parsedArgs = await parseParams("getBlockees", ChatGetBlockersRequestSchema)(params);
    const query = {
      timestamp: (/* @__PURE__ */ new Date()).getTime()
    };
    if (parsedArgs !== null && parsedArgs !== void 0 && parsedArgs.currentUserId) {
      query.current_user_id = parsedArgs.currentUserId;
    }
    const response = await this.signAndSendRequest({
      method: "GET",
      path: `/comms/chats/blockees`,
      headers: {},
      query
    });
    return await response.json();
  }
  /**
   * Gets URL metadata useful for link previews
   * @param params.content the urls to get metadata for
   * @returns the unfurl response
   */
  async unfurl(params) {
    const {
      urls
    } = await parseParams("unfurl", ChatUnfurlRequestSchema)(params);
    const query = {
      content: urls
    };
    const res = await this.request({
      method: "GET",
      path: "/comms/unfurl",
      query,
      headers: {}
    });
    return await res.json();
  }
  // #endregion
  // #region MUTATE
  /**
   * Creates a chat between users
   * @param params.userId the user id who is creating the chat
   * @param params.invitedUserIds the user ids to add to the chat
   * @param params.currentUserId the user to act on behalf of
   * @returns the rpc object
   */
  async create(params) {
    const {
      currentUserId,
      userId,
      invitedUserIds
    } = await parseParams("create", ChatCreateRequestSchema)(params);
    const chatId = [userId, ...invitedUserIds].sort().join(":");
    const chatSecret = utils.randomPrivateKey();
    const invites = await this.createInvites(userId, invitedUserIds, chatSecret);
    return await this.sendRpc({
      current_user_id: currentUserId,
      method: "chat.create",
      params: {
        chat_id: chatId,
        invites
      }
    });
  }
  /**
   * Invites other users to an existing chat
   * @param params.chatId the chat id of the chat to invite to
   * @param params.userId the user id who is creating the chat
   * @param params.invitedUserIds the user ids to add to the chat
   * @param params.currentUserId the user to act on behalf of
   * @returns the rpc object
   */
  async invite(params) {
    const {
      currentUserId,
      chatId,
      userId,
      invitedUserIds
    } = await parseParams("invite", ChatInviteRequestSchema)(params);
    const chatSecret = await this.getChatSecret(chatId);
    const invites = await this.createInvites(userId, invitedUserIds, chatSecret);
    return await this.sendRpc({
      current_user_id: currentUserId,
      method: "chat.invite",
      params: {
        chat_id: chatId,
        invites
      }
    });
  }
  /**
   * Sends a message to a user in a chat
   * @param params.message the message
   * @param params.chatId the chat to send a message in
   * @param params.messageId the id of the message
   * @param params.currentUserId the user to act on behalf of
   * @returns the rpc object
   */
  async message(params) {
    const {
      currentUserId,
      chatId,
      message,
      messageId
    } = await parseParams("message", ChatMessageRequestSchema)(params);
    const chatSecret = await this.getChatSecret(chatId);
    const encrypted = await CryptoUtils.encryptString(chatSecret, message);
    const encodedMessage = base642.encode(encrypted);
    return await this.sendRpc({
      current_user_id: currentUserId,
      method: "chat.message",
      params: {
        chat_id: chatId,
        message_id: messageId !== null && messageId !== void 0 ? messageId : ulid(),
        message: encodedMessage
      }
    });
  }
  /**
   * Sends a blast message to a set of users
   * @param params.message the message
   * @param params.blastId the id of the message
   * @param params.audience the audience to send the message to
   * @param params.audienceTrackId for targeting remixers/purchasers of a specific track
   * @param params.currentUserId the user to act on behalf of
   * @returns the rpc object
   */
  async messageBlast(params) {
    const {
      currentUserId,
      blastId,
      message,
      audience,
      audienceContentId,
      audienceContentType: audienceContentTypeParam
    } = await parseParams("messageBlast", ChatBlastMessageRequestSchema)(params);
    let audienceContentType = audienceContentTypeParam;
    if (audience === ChatBlastAudience.REMIXERS && !!audienceContentId) {
      audienceContentType = "track";
    }
    return await this.sendRpc({
      current_user_id: currentUserId,
      method: "chat.blast",
      params: {
        blast_id: blastId !== null && blastId !== void 0 ? blastId : ulid(),
        audience,
        audience_content_id: audienceContentId,
        audience_content_type: audienceContentType,
        message
      }
    });
  }
  /**
   * Reacts to a message
   * @param params.reaction the reaction
   * @param params.chatId the chat to send a reaction in
   * @param params.messageId the id of the message to react to
   * @param params.currentUserId the user to act on behalf of
   * @returns the rpc object
   */
  async react(params) {
    const {
      currentUserId,
      chatId,
      messageId,
      reaction
    } = await parseParams("react", ChatReactRequestSchema)(params);
    return await this.sendRpc({
      current_user_id: currentUserId,
      method: "chat.react",
      params: {
        chat_id: chatId,
        message_id: messageId,
        reaction
      }
    });
  }
  /**
   * Marks a chat as read
   * @param params.chatId the chat to mark as read
   * @param params.currentUserId the user to act on behalf of
   * @returns the rpc object
   */
  async read(params) {
    const {
      currentUserId,
      chatId
    } = await parseParams("read", ChatReadRequestSchema)(params);
    return await this.sendRpc({
      current_user_id: currentUserId,
      method: "chat.read",
      params: {
        chat_id: chatId
      }
    });
  }
  /**
   * Blocks a user from sending messages to the current user
   * @param params.userId the user to block
   * @param params.currentUserId the user to act on behalf of
   * @returns the rpc object
   */
  async block(params) {
    const {
      currentUserId,
      userId
    } = await parseParams("block", ChatBlockRequestSchema)(params);
    return await this.sendRpc({
      current_user_id: currentUserId,
      method: "chat.block",
      params: {
        user_id: userId
      }
    });
  }
  /**
   * Unblocks a user from sending messages to the current user
   * @param params.userId the user to unblock
   * @param params.currentUserId the user to act on behalf of
   * @returns the rpc object
   */
  async unblock(params) {
    const {
      currentUserId,
      userId
    } = await parseParams("unblock", ChatBlockRequestSchema)(params);
    return await this.sendRpc({
      current_user_id: currentUserId,
      method: "chat.unblock",
      params: {
        user_id: userId
      }
    });
  }
  /**
   * Clears a chat's history for the current user
   * @param params.chatId the chat to clear
   * @param params.currentUserId the user to act on behalf of
   * @returns the rpc object
   */
  async delete(params) {
    const {
      currentUserId,
      chatId
    } = await parseParams("delete", ChatDeleteRequestSchema)(params);
    return await this.sendRpc({
      current_user_id: currentUserId,
      method: "chat.delete",
      params: {
        chat_id: chatId
      }
    });
  }
  /**
   * Sets the inbox settings permissions of the current user
   * @param params.permit the permission to set
   * @param params.currentUserId the user to act on behalf of
   * @returns the rpc object
   */
  async permit(params) {
    const {
      currentUserId,
      permit,
      permitList,
      allow
    } = await parseParams("permit", ChatPermitRequestSchema)(params);
    return await this.sendRpc({
      current_user_id: currentUserId,
      method: "chat.permit",
      params: {
        permit: permit !== null && permit !== void 0 ? permit : ChatPermission.ALL,
        permit_list: permitList !== null && permitList !== void 0 ? permitList : [ChatPermission.ALL],
        allow
      }
    });
  }
  // #endregion
  // #region PRIVATE
  async createInvites(userId, invitedUserIds, chatSecret) {
    const allUserIds = [userId, ...invitedUserIds];
    const publicKeyPromises = allUserIds.map((id) => this.getPublicKey(id));
    const publicKeys = await Promise.all(publicKeyPromises);
    const userPublicKey = publicKeys[0];
    if (!userPublicKey) {
      throw new Error(`Failed to fetch public key for user ${userId}`);
    }
    return await Promise.all(allUserIds.map(async (userId2, index4) => {
      const inviteePublicKey = publicKeys[index4];
      if (!inviteePublicKey) {
        throw new Error(`Failed to fetch public key for user ${userId2}`);
      }
      const inviteCode = await this.createInviteCode(userPublicKey, inviteePublicKey, chatSecret);
      return {
        user_id: userId2,
        invite_code: base642.encode(inviteCode)
      };
    }));
  }
  async createInviteCode(userPublicKey, inviteePublicKey, chatSecret) {
    const sharedSecret = await this.audiusWalletClient.getSharedSecret({
      publicKey: inviteePublicKey
    });
    const encryptedChatSecret = await CryptoUtils.encrypt(sharedSecret, chatSecret);
    const inviteCode = new Uint8Array(65 + encryptedChatSecret.length);
    inviteCode.set(userPublicKey);
    inviteCode.set(encryptedChatSecret, 65);
    return inviteCode;
  }
  async readInviteCode(inviteCode) {
    const friendPublicKey = inviteCode.slice(0, 65);
    const chatSecretEncrypted = inviteCode.slice(65);
    const sharedSecret = await this.audiusWalletClient.getSharedSecret({
      publicKey: friendPublicKey
    });
    return await CryptoUtils.decrypt(sharedSecret, chatSecretEncrypted);
  }
  async decryptLastChatMessage(c) {
    if (c.last_message_is_plaintext) return c;
    let lastMessage = "";
    try {
      const sharedSecret = await this.getChatSecret(c.chat_id);
      if (c.last_message && c.last_message.length > 0) {
        lastMessage = await CryptoUtils.decryptString(sharedSecret, base642.decode(c.last_message));
      }
    } catch (e) {
      this.logger.error("[audius-sdk]: Error: Couldn't decrypt last chat message", c, e);
      lastMessage = GENERIC_MESSAGE_ERROR;
    }
    return {
      ...c,
      last_message: lastMessage
    };
  }
  async getRaw(chatId, currentUserId) {
    const path = `/comms/chats/${chatId}`;
    const queryParameters = {
      timestamp: (/* @__PURE__ */ new Date()).getTime()
    };
    if (currentUserId) {
      queryParameters.current_user_id = currentUserId;
    }
    const response = await this.signAndSendRequest({
      method: "GET",
      headers: {},
      path,
      query: queryParameters
    });
    return await response.json();
  }
  async getChatSecret(chatId) {
    const existingChatSecret = this.chatSecrets[chatId];
    if (!existingChatSecret) {
      const response = await this.getRaw(chatId);
      const chatSecret = await this.readInviteCode(base642.decode(response.data.invite_code));
      this.chatSecrets[chatId] = chatSecret;
      return chatSecret;
    }
    return existingChatSecret;
  }
  async getPublicKey(userId) {
    if (!this.publicKeyCache[userId]) {
      this.publicKeyCache[userId] = this.fetchPublicKey(userId);
    }
    const cachedPromise = this.publicKeyCache[userId];
    if (!cachedPromise) {
      throw new Error(`Public key cache is unexpectedly empty for user ${userId}`);
    }
    return await cachedPromise;
  }
  async fetchPublicKey(userId) {
    const response = await this.request({
      path: `/comms/pubkey/${userId}`,
      method: "GET",
      headers: {}
    });
    const json = await response.json();
    return base642.decode(json.data);
  }
  async upgradeBlasts(userId) {
    const blasts = await this.getBlasts();
    const uniqueBlasts = (0, import_lodash.uniqBy)(blasts.data, "pending_chat_id");
    await Promise.all(uniqueBlasts.map(async (blast) => {
      const encodedSenderId = encodeHashId(blast.from_user_id);
      if (encodedSenderId) {
        await this.create({
          userId,
          invitedUserIds: [encodedSenderId]
        });
      }
    }));
    for (const blast of blasts.data) {
      const encodedSenderId = encodeHashId(blast.from_user_id);
      if (encodedSenderId) {
        this.eventEmitter.emit("message", {
          chatId: blast.pending_chat_id,
          message: {
            // the order of blast_id + pending_chat_id needs to match Misc.BlastMessageID in comms
            message_id: blast.blast_id + blast.pending_chat_id,
            message: blast.plaintext,
            sender_user_id: encodedSenderId,
            created_at: blast.created_at,
            reactions: [],
            is_plaintext: true,
            audience: blast.audience
          }
        });
      }
    }
  }
  async getSignatureHeader(payload) {
    const [signature2, recid] = await this.audiusWalletClient.sign({
      message: payload
    });
    const signatureBytes = new Uint8Array(65);
    signatureBytes.set(signature2, 0);
    signatureBytes[64] = recid;
    return {
      "x-sig": base642.encode(signatureBytes)
    };
  }
  async signAndSendRequest(request) {
    const payload = request.method === "GET" ? request.query ? `${request.path}?${this.configuration.queryParamsStringify(request.query)}` : request.path : request.body;
    return await this.request({
      ...request,
      headers: {
        ...request.headers,
        ...await this.getSignatureHeader(payload)
      }
    });
  }
  async sendRpc(args) {
    const payload = JSON.stringify({
      ...args,
      timestamp: (/* @__PURE__ */ new Date()).getTime()
    });
    await this.signAndSendRequest({
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      path: `/comms/mutate`,
      body: payload
    });
    return args;
  }
  async createWebsocket(endpoint2) {
    const timestamp = (/* @__PURE__ */ new Date()).getTime();
    const originalUrl = `/comms/chats/ws?timestamp=${timestamp}`;
    const signatureHeader = await this.getSignatureHeader(originalUrl);
    const host = endpoint2.replace(/http(s?)/g, "ws$1");
    const url = `${host}${originalUrl}&signature=${encodeURIComponent(signatureHeader["x-sig"])}`;
    const ws = new browser_default(url);
    ws.addEventListener("message", (messageEvent) => {
      const handleAsync = async () => {
        const data = JSON.parse(messageEvent.data);
        if (data.rpc.method === "chat.message") {
          const sharedSecret = await this.getChatSecret(data.rpc.params.chat_id);
          this.eventEmitter.emit("message", {
            chatId: data.rpc.params.chat_id,
            message: {
              message_id: data.rpc.params.message_id,
              message: data.rpc.params.is_plaintext ? data.rpc.params.message : await CryptoUtils.decryptString(sharedSecret, base642.decode(data.rpc.params.message)).catch((e) => {
                this.logger.error("[audius-sdk]: Error: Couldn't decrypt websocket chat message", data, e);
                return GENERIC_MESSAGE_ERROR;
              }),
              sender_user_id: data.metadata.senderUserId,
              created_at: data.metadata.timestamp,
              reactions: [],
              is_plaintext: !!data.rpc.params.is_plaintext,
              audience: data.rpc.params.audience
            }
          });
        } else if (data.rpc.method === "chat.react") {
          this.eventEmitter.emit("reaction", {
            chatId: data.rpc.params.chat_id,
            messageId: data.rpc.params.message_id,
            reaction: {
              reaction: data.rpc.params.reaction,
              user_id: data.metadata.senderUserId,
              created_at: data.metadata.timestamp
            }
          });
        } else if (data.rpc.method === "chat.blast") {
          const userId = data.metadata.receiverUserId;
          await this.upgradeBlasts(userId);
          this.eventEmitter.emit("blast", {
            audience: data.rpc.params.audience,
            audienceContentType: data.rpc.params.audience_content_type,
            audienceContentId: data.rpc.params.audience_content_id,
            message: {
              message_id: data.rpc.params.blast_id,
              message: data.rpc.params.message,
              sender_user_id: data.metadata.senderUserId,
              created_at: data.metadata.timestamp,
              reactions: [],
              is_plaintext: true,
              audience: data.rpc.params.audience
            }
          });
        }
      };
      handleAsync();
    });
    ws.addEventListener("open", () => {
      this.eventEmitter.emit("open");
    });
    ws.addEventListener("close", () => {
      this.eventEmitter.emit("close");
    });
    ws.addEventListener("error", (e) => {
      this.eventEmitter.emit("error", e);
    });
    return ws;
  }
};
var CommentsApi$1 = class extends CommentsApi$2 {
  constructor(configuration, entityManager, logger) {
    super(configuration);
    _defineProperty$1(this, "entityManager", void 0);
    _defineProperty$1(this, "logger", void 0);
    this.entityManager = entityManager;
    this.logger = logger;
  }
  async generateCommentId() {
    const response = await this.getUnclaimedCommentID();
    const {
      data: unclaimedId
    } = response;
    if (!unclaimedId) {
      return Math.floor(Math.random() * 1e6);
    }
    return decodeHashId(unclaimedId);
  }
  async postComment(metadata) {
    const {
      userId,
      entityType = EntityType.TRACK,
      commentId
    } = metadata;
    const newCommentId = commentId !== null && commentId !== void 0 ? commentId : await this.generateCommentId();
    await this.entityManager.manageEntity({
      userId,
      entityType: EntityType.COMMENT,
      entityId: newCommentId,
      action: Action.CREATE,
      metadata: JSON.stringify({
        cid: "",
        data: (0, import_snakecase_keys.default)({
          entityType,
          ...metadata
        })
      })
    });
    this.logger.info("Successfully posted a comment");
    return encodeHashId(newCommentId);
  }
  async editComment(metadata) {
    const {
      userId,
      entityId,
      trackId
    } = metadata;
    const response = await this.entityManager.manageEntity({
      userId,
      entityType: EntityType.COMMENT,
      entityId,
      action: Action.UPDATE,
      metadata: JSON.stringify({
        cid: "",
        data: (0, import_snakecase_keys.default)({
          ...metadata,
          entityId: trackId
        })
      })
    });
    return response;
  }
  async deleteComment(metadata) {
    const {
      userId,
      entityId
    } = metadata;
    const response = await this.entityManager.manageEntity({
      userId,
      entityType: EntityType.COMMENT,
      entityId,
      action: Action.DELETE,
      metadata: ""
    });
    return response;
  }
  async reactComment(metadata) {
    const {
      userId,
      commentId,
      isLiked,
      trackId
    } = metadata;
    const response = await this.entityManager.manageEntity({
      userId,
      entityType: EntityType.COMMENT,
      entityId: commentId,
      action: isLiked ? Action.REACT : Action.UNREACT,
      metadata: JSON.stringify({
        cid: "",
        data: (0, import_snakecase_keys.default)({
          entityId: trackId,
          entityType: EntityType.TRACK
        })
      })
    });
    return response;
  }
  async pinComment(metadata) {
    const {
      userId,
      entityId,
      trackId,
      isPin
    } = metadata;
    const response = await this.entityManager.manageEntity({
      userId,
      entityType: EntityType.COMMENT,
      entityId,
      action: isPin ? Action.PIN : Action.UNPIN,
      metadata: JSON.stringify({
        cid: "",
        data: (0, import_snakecase_keys.default)({
          entityId: trackId
        })
      })
    });
    return response;
  }
  async reportComment(userId, entityId) {
    const response = await this.entityManager.manageEntity({
      userId,
      entityType: EntityType.COMMENT,
      entityId,
      action: Action.REPORT,
      metadata: ""
    });
    return response;
  }
  async muteUser(userId, mutedUserId, isMuted) {
    const response = await this.entityManager.manageEntity({
      userId,
      entityType: EntityType.USER,
      entityId: mutedUserId,
      action: isMuted ? Action.UNMUTE : Action.MUTE,
      metadata: ""
    });
    return response;
  }
  async updateCommentNotificationSetting(config) {
    const response = await this.entityManager.manageEntity({
      ...config,
      metadata: ""
    });
    return response;
  }
};
var EthAddressSchema = z.custom((val) => {
  return z.string().startsWith("0x", "Hex string must start with 0x").regex(/^0x[0-9a-fA-F]+$/, "Hex must only include hexadecimal characters 0-9, a-F").length(42, "Ethereum address must be 42 characters (including 0x").parse(val);
});
var CreateDashboardWalletUser = z.object({
  wallet: EthAddressSchema,
  userId: HashId,
  walletSignature: z.object({
    /** Message should be of the form: "Connecting Audius user id a93jl at 39823489" OR "Connecting Audius user @jill1990 at 39823489" */
    message: z.string(),
    signature: z.string()
  }).optional(),
  userSignature: z.object({
    /** Message should be of the form: "Connecting Audius protocol dashboard wallet 0x6c9CA7D9580d4e8286B0628c0300A2A1235a8e2E at 39823489" */
    message: z.string(),
    signature: z.string()
  }).optional()
}).refine((data) => !!data.userSignature || !!data.walletSignature, "Either `userSignature` or `walletSignature` is required. Use `userSignature` if SDK is authenticated with the wallet's sign methods, and use `walletSignature` if SDK is authenticated with the user's sign methods.");
var DeleteDashboardWalletUserSchema = z.object({
  userId: HashId,
  wallet: EthAddressSchema
});
var DashboardWalletUsersApi = class extends DashboardWalletUsersApi$1 {
  constructor(config, entityManager) {
    super(config);
    _defineProperty$1(this, "entityManager", void 0);
    this.entityManager = entityManager;
  }
  /**
   * Connect an Audius user to a wallet on the protocol dashboard
   */
  async connectUserToDashboardWallet(params, advancedOptions) {
    const {
      wallet,
      userId,
      walletSignature,
      userSignature
    } = await parseParams("createDashboardWalletUser", CreateDashboardWalletUser)(params);
    const signatureMetadata = walletSignature ? {
      wallet_signature: {
        message: walletSignature.message,
        signature: walletSignature.signature
      }
    } : {
      user_signature: {
        message: userSignature.message,
        signature: userSignature.signature
      }
    };
    const response = await this.entityManager.manageEntity({
      userId,
      entityType: EntityType.DASHBOARD_WALLET_USER,
      entityId: 0,
      action: Action.CREATE,
      metadata: JSON.stringify({
        wallet,
        ...signatureMetadata
      }),
      ...advancedOptions
    });
    return {
      ...response
    };
  }
  /**
   * Disconnect an Audius user from a wallet on the protocol dashboard
   */
  async disconnectUserFromDashboardWallet(params) {
    const {
      userId,
      wallet
    } = await parseParams("deleteDashboardWalletUser", DeleteDashboardWalletUserSchema)(params);
    return await this.entityManager.manageEntity({
      userId,
      entityType: EntityType.DASHBOARD_WALLET_USER,
      entityId: 0,
      action: Action.DELETE,
      metadata: JSON.stringify({
        wallet
      })
    });
  }
};
var HMAC2 = class extends Hash$3 {
  constructor(hash3, _key) {
    super();
    this.finished = false;
    this.destroyed = false;
    hash$1(hash3);
    const key = toBytes$1(_key);
    this.iHash = hash3.create();
    if (typeof this.iHash.update !== "function") throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen;
    this.outputLen = this.iHash.outputLen;
    const blockLen = this.blockLen;
    const pad3 = new Uint8Array(blockLen);
    pad3.set(key.length > blockLen ? hash3.create().update(key).digest() : key);
    for (let i = 0; i < pad3.length; i++) pad3[i] ^= 54;
    this.iHash.update(pad3);
    this.oHash = hash3.create();
    for (let i = 0; i < pad3.length; i++) pad3[i] ^= 54 ^ 92;
    this.oHash.update(pad3);
    pad3.fill(0);
  }
  update(buf) {
    exists$3(this);
    this.iHash.update(buf);
    return this;
  }
  digestInto(out) {
    exists$3(this);
    bytes$1(out, this.outputLen);
    this.finished = true;
    this.iHash.digestInto(out);
    this.oHash.update(out);
    this.oHash.digestInto(out);
    this.destroy();
  }
  digest() {
    const out = new Uint8Array(this.oHash.outputLen);
    this.digestInto(out);
    return out;
  }
  _cloneInto(to) {
    to || (to = Object.create(Object.getPrototypeOf(this), {}));
    const {
      oHash,
      iHash,
      finished: finished2,
      destroyed,
      blockLen,
      outputLen
    } = this;
    to = to;
    to.finished = finished2;
    to.destroyed = destroyed;
    to.blockLen = blockLen;
    to.outputLen = outputLen;
    to.oHash = oHash._cloneInto(to.oHash);
    to.iHash = iHash._cloneInto(to.iHash);
    return to;
  }
  destroy() {
    this.destroyed = true;
    this.oHash.destroy();
    this.iHash.destroy();
  }
};
var hmac2 = (hash3, key, message) => new HMAC2(hash3, key).update(message).digest();
hmac2.create = (hash3, key) => new HMAC2(hash3, key);
var _0n$4 = BigInt(0);
var _1n$5 = BigInt(1);
var _2n$3 = BigInt(2);
function isBytes6(a) {
  return a instanceof Uint8Array || a != null && typeof a === "object" && a.constructor.name === "Uint8Array";
}
function abytes4(item) {
  if (!isBytes6(item)) throw new Error("Uint8Array expected");
}
function abool(title, value) {
  if (typeof value !== "boolean") throw new Error(`${title} must be valid boolean, got "${value}".`);
}
var hexes$1 = Array.from({
  length: 256
}, (_, i) => i.toString(16).padStart(2, "0"));
function bytesToHex$1(bytes3) {
  abytes4(bytes3);
  let hex3 = "";
  for (let i = 0; i < bytes3.length; i++) {
    hex3 += hexes$1[bytes3[i]];
  }
  return hex3;
}
function numberToHexUnpadded3(num2) {
  const hex3 = num2.toString(16);
  return hex3.length & 1 ? `0${hex3}` : hex3;
}
function hexToNumber4(hex3) {
  if (typeof hex3 !== "string") throw new Error("hex string expected, got " + typeof hex3);
  return BigInt(hex3 === "" ? "0" : `0x${hex3}`);
}
var asciis2 = {
  _0: 48,
  _9: 57,
  _A: 65,
  _F: 70,
  _a: 97,
  _f: 102
};
function asciiToBase162(char) {
  if (char >= asciis2._0 && char <= asciis2._9) return char - asciis2._0;
  if (char >= asciis2._A && char <= asciis2._F) return char - (asciis2._A - 10);
  if (char >= asciis2._a && char <= asciis2._f) return char - (asciis2._a - 10);
  return;
}
function hexToBytes4(hex3) {
  if (typeof hex3 !== "string") throw new Error("hex string expected, got " + typeof hex3);
  const hl = hex3.length;
  const al = hl / 2;
  if (hl % 2) throw new Error("padded hex string expected, got unpadded hex of length " + hl);
  const array4 = new Uint8Array(al);
  for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
    const n1 = asciiToBase162(hex3.charCodeAt(hi));
    const n2 = asciiToBase162(hex3.charCodeAt(hi + 1));
    if (n1 === void 0 || n2 === void 0) {
      const char = hex3[hi] + hex3[hi + 1];
      throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
    }
    array4[ai] = n1 * 16 + n2;
  }
  return array4;
}
function bytesToNumberBE2(bytes3) {
  return hexToNumber4(bytesToHex$1(bytes3));
}
function bytesToNumberLE2(bytes3) {
  abytes4(bytes3);
  return hexToNumber4(bytesToHex$1(Uint8Array.from(bytes3).reverse()));
}
function numberToBytesBE2(n, len) {
  return hexToBytes4(n.toString(16).padStart(len * 2, "0"));
}
function numberToBytesLE2(n, len) {
  return numberToBytesBE2(n, len).reverse();
}
function numberToVarBytesBE(n) {
  return hexToBytes4(numberToHexUnpadded3(n));
}
function ensureBytes4(title, hex3, expectedLength) {
  let res;
  if (typeof hex3 === "string") {
    try {
      res = hexToBytes4(hex3);
    } catch (e) {
      throw new Error(`${title} must be valid hex string, got "${hex3}". Cause: ${e}`);
    }
  } else if (isBytes6(hex3)) {
    res = Uint8Array.from(hex3);
  } else {
    throw new Error(`${title} must be hex string or Uint8Array`);
  }
  const len = res.length;
  if (typeof expectedLength === "number" && len !== expectedLength) throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);
  return res;
}
function concatBytes5() {
  let sum = 0;
  for (let i = 0; i < arguments.length; i++) {
    const a = i < 0 || arguments.length <= i ? void 0 : arguments[i];
    abytes4(a);
    sum += a.length;
  }
  const res = new Uint8Array(sum);
  for (let i = 0, pad3 = 0; i < arguments.length; i++) {
    const a = i < 0 || arguments.length <= i ? void 0 : arguments[i];
    res.set(a, pad3);
    pad3 += a.length;
  }
  return res;
}
function equalBytes3(a, b) {
  if (a.length !== b.length) return false;
  let diff = 0;
  for (let i = 0; i < a.length; i++) diff |= a[i] ^ b[i];
  return diff === 0;
}
function utf8ToBytes$1(str2) {
  if (typeof str2 !== "string") throw new Error(`utf8ToBytes expected string, got ${typeof str2}`);
  return new Uint8Array(new TextEncoder().encode(str2));
}
var isPosBig2 = (n) => typeof n === "bigint" && _0n$4 <= n;
function inRange3(n, min, max) {
  return isPosBig2(n) && isPosBig2(min) && isPosBig2(max) && min <= n && n < max;
}
function aInRange2(title, n, min, max) {
  if (!inRange3(n, min, max)) throw new Error(`expected valid ${title}: ${min} <= n < ${max}, got ${typeof n} ${n}`);
}
function bitLen2(n) {
  let len;
  for (len = 0; n > _0n$4; n >>= _1n$5, len += 1) ;
  return len;
}
function bitGet(n, pos) {
  return n >> BigInt(pos) & _1n$5;
}
function bitSet(n, pos, value) {
  return n | (value ? _1n$5 : _0n$4) << BigInt(pos);
}
var bitMask2 = (n) => (_2n$3 << BigInt(n - 1)) - _1n$5;
var u8n = (data) => new Uint8Array(data);
var u8fr = (arr) => Uint8Array.from(arr);
function createHmacDrbg2(hashLen, qByteLen, hmacFn) {
  if (typeof hashLen !== "number" || hashLen < 2) throw new Error("hashLen must be a number");
  if (typeof qByteLen !== "number" || qByteLen < 2) throw new Error("qByteLen must be a number");
  if (typeof hmacFn !== "function") throw new Error("hmacFn must be a function");
  let v = u8n(hashLen);
  let k = u8n(hashLen);
  let i = 0;
  const reset2 = () => {
    v.fill(1);
    k.fill(0);
    i = 0;
  };
  const h = function() {
    for (var _len = arguments.length, b = new Array(_len), _key = 0; _key < _len; _key++) {
      b[_key] = arguments[_key];
    }
    return hmacFn(k, v, ...b);
  };
  const reseed = function() {
    let seed2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : u8n();
    k = h(u8fr([0]), seed2);
    v = h();
    if (seed2.length === 0) return;
    k = h(u8fr([1]), seed2);
    v = h();
  };
  const gen4 = () => {
    if (i++ >= 1e3) throw new Error("drbg: tried 1000 values");
    let len = 0;
    const out = [];
    while (len < qByteLen) {
      v = h();
      const sl = v.slice();
      out.push(sl);
      len += v.length;
    }
    return concatBytes5(...out);
  };
  const genUntil = (seed2, pred) => {
    reset2();
    reseed(seed2);
    let res = void 0;
    while (!(res = pred(gen4()))) reseed();
    reset2();
    return res;
  };
  return genUntil;
}
var validatorFns = {
  bigint: (val) => typeof val === "bigint",
  function: (val) => typeof val === "function",
  boolean: (val) => typeof val === "boolean",
  string: (val) => typeof val === "string",
  stringOrUint8Array: (val) => typeof val === "string" || isBytes6(val),
  isSafeInteger: (val) => Number.isSafeInteger(val),
  array: (val) => Array.isArray(val),
  field: (val, object) => object.Fp.isValid(val),
  hash: (val) => typeof val === "function" && Number.isSafeInteger(val.outputLen)
};
function validateObject2(object, validators) {
  let optValidators = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  const checkField = (fieldName, type3, isOptional) => {
    const checkVal = validatorFns[type3];
    if (typeof checkVal !== "function") throw new Error(`Invalid validator "${type3}", expected function`);
    const val = object[fieldName];
    if (isOptional && val === void 0) return;
    if (!checkVal(val, object)) {
      throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type3}`);
    }
  };
  for (const [fieldName, type3] of Object.entries(validators)) checkField(fieldName, type3, false);
  for (const [fieldName, type3] of Object.entries(optValidators)) checkField(fieldName, type3, true);
  return object;
}
var notImplemented2 = () => {
  throw new Error("not implemented");
};
function memoized2(fn) {
  const map = /* @__PURE__ */ new WeakMap();
  return function(arg) {
    const val = map.get(arg);
    if (val !== void 0) return val;
    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      args[_key2 - 1] = arguments[_key2];
    }
    const computed = fn(arg, ...args);
    map.set(arg, computed);
    return computed;
  };
}
var ut = Object.freeze({
  __proto__: null,
  isBytes: isBytes6,
  abytes: abytes4,
  abool,
  bytesToHex: bytesToHex$1,
  numberToHexUnpadded: numberToHexUnpadded3,
  hexToNumber: hexToNumber4,
  hexToBytes: hexToBytes4,
  bytesToNumberBE: bytesToNumberBE2,
  bytesToNumberLE: bytesToNumberLE2,
  numberToBytesBE: numberToBytesBE2,
  numberToBytesLE: numberToBytesLE2,
  numberToVarBytesBE,
  ensureBytes: ensureBytes4,
  concatBytes: concatBytes5,
  equalBytes: equalBytes3,
  utf8ToBytes: utf8ToBytes$1,
  inRange: inRange3,
  aInRange: aInRange2,
  bitLen: bitLen2,
  bitGet,
  bitSet,
  bitMask: bitMask2,
  createHmacDrbg: createHmacDrbg2,
  validateObject: validateObject2,
  notImplemented: notImplemented2,
  memoized: memoized2
});
var _0n$3 = BigInt(0);
var _1n$4 = BigInt(1);
var _2n$2 = BigInt(2);
var _3n$1 = BigInt(3);
var _4n3 = BigInt(4);
var _5n3 = BigInt(5);
var _8n5 = BigInt(8);
BigInt(9);
BigInt(16);
function mod3(a, b) {
  const result = a % b;
  return result >= _0n$3 ? result : b + result;
}
function pow(num2, power, modulo) {
  if (modulo <= _0n$3 || power < _0n$3) throw new Error("Expected power/modulo > 0");
  if (modulo === _1n$4) return _0n$3;
  let res = _1n$4;
  while (power > _0n$3) {
    if (power & _1n$4) res = res * num2 % modulo;
    num2 = num2 * num2 % modulo;
    power >>= _1n$4;
  }
  return res;
}
function pow23(x, power, modulo) {
  let res = x;
  while (power-- > _0n$3) {
    res *= res;
    res %= modulo;
  }
  return res;
}
function invert3(number5, modulo) {
  if (number5 === _0n$3 || modulo <= _0n$3) {
    throw new Error(`invert: expected positive integers, got n=${number5} mod=${modulo}`);
  }
  let a = mod3(number5, modulo);
  let b = modulo;
  let x = _0n$3, u = _1n$4;
  while (a !== _0n$3) {
    const q = b / a;
    const r = b % a;
    const m = x - u * q;
    b = a, a = r, x = u, u = m;
  }
  const gcd2 = b;
  if (gcd2 !== _1n$4) throw new Error("invert: does not exist");
  return mod3(x, modulo);
}
function tonelliShanks2(P) {
  const legendreC = (P - _1n$4) / _2n$2;
  let Q, S, Z;
  for (Q = P - _1n$4, S = 0; Q % _2n$2 === _0n$3; Q /= _2n$2, S++) ;
  for (Z = _2n$2; Z < P && pow(Z, legendreC, P) !== P - _1n$4; Z++) ;
  if (S === 1) {
    const p1div4 = (P + _1n$4) / _4n3;
    return function tonelliFast(Fp3, n) {
      const root2 = Fp3.pow(n, p1div4);
      if (!Fp3.eql(Fp3.sqr(root2), n)) throw new Error("Cannot find square root");
      return root2;
    };
  }
  const Q1div2 = (Q + _1n$4) / _2n$2;
  return function tonelliSlow(Fp3, n) {
    if (Fp3.pow(n, legendreC) === Fp3.neg(Fp3.ONE)) throw new Error("Cannot find square root");
    let r = S;
    let g = Fp3.pow(Fp3.mul(Fp3.ONE, Z), Q);
    let x = Fp3.pow(n, Q1div2);
    let b = Fp3.pow(n, Q);
    while (!Fp3.eql(b, Fp3.ONE)) {
      if (Fp3.eql(b, Fp3.ZERO)) return Fp3.ZERO;
      let m = 1;
      for (let t2 = Fp3.sqr(b); m < r; m++) {
        if (Fp3.eql(t2, Fp3.ONE)) break;
        t2 = Fp3.sqr(t2);
      }
      const ge = Fp3.pow(g, _1n$4 << BigInt(r - m - 1));
      g = Fp3.sqr(ge);
      x = Fp3.mul(x, ge);
      b = Fp3.mul(b, g);
      r = m;
    }
    return x;
  };
}
function FpSqrt2(P) {
  if (P % _4n3 === _3n$1) {
    const p1div4 = (P + _1n$4) / _4n3;
    return function sqrt3mod42(Fp3, n) {
      const root2 = Fp3.pow(n, p1div4);
      if (!Fp3.eql(Fp3.sqr(root2), n)) throw new Error("Cannot find square root");
      return root2;
    };
  }
  if (P % _8n5 === _5n3) {
    const c1 = (P - _5n3) / _8n5;
    return function sqrt5mod82(Fp3, n) {
      const n2 = Fp3.mul(n, _2n$2);
      const v = Fp3.pow(n2, c1);
      const nv = Fp3.mul(n, v);
      const i = Fp3.mul(Fp3.mul(nv, _2n$2), v);
      const root2 = Fp3.mul(nv, Fp3.sub(i, Fp3.ONE));
      if (!Fp3.eql(Fp3.sqr(root2), n)) throw new Error("Cannot find square root");
      return root2;
    };
  }
  return tonelliShanks2(P);
}
var FIELD_FIELDS2 = ["create", "isValid", "is0", "neg", "inv", "sqrt", "sqr", "eql", "add", "sub", "mul", "pow", "div", "addN", "subN", "mulN", "sqrN"];
function validateField2(field) {
  const initial = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "isSafeInteger",
    BITS: "isSafeInteger"
  };
  const opts = FIELD_FIELDS2.reduce((map, val) => {
    map[val] = "function";
    return map;
  }, initial);
  return validateObject2(field, opts);
}
function FpPow2(f3, num2, power) {
  if (power < _0n$3) throw new Error("Expected power > 0");
  if (power === _0n$3) return f3.ONE;
  if (power === _1n$4) return num2;
  let p = f3.ONE;
  let d = num2;
  while (power > _0n$3) {
    if (power & _1n$4) p = f3.mul(p, d);
    d = f3.sqr(d);
    power >>= _1n$4;
  }
  return p;
}
function FpInvertBatch2(f3, nums) {
  const tmp = new Array(nums.length);
  const lastMultiplied = nums.reduce((acc, num2, i) => {
    if (f3.is0(num2)) return acc;
    tmp[i] = acc;
    return f3.mul(acc, num2);
  }, f3.ONE);
  const inverted = f3.inv(lastMultiplied);
  nums.reduceRight((acc, num2, i) => {
    if (f3.is0(num2)) return acc;
    tmp[i] = f3.mul(acc, tmp[i]);
    return f3.mul(acc, num2);
  }, inverted);
  return tmp;
}
function nLength2(n, nBitLength) {
  const _nBitLength = nBitLength !== void 0 ? nBitLength : n.toString(2).length;
  const nByteLength = Math.ceil(_nBitLength / 8);
  return {
    nBitLength: _nBitLength,
    nByteLength
  };
}
function Field2(ORDER, bitLen3) {
  let isLE6 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
  let redef = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
  if (ORDER <= _0n$3) throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);
  const {
    nBitLength: BITS,
    nByteLength: BYTES
  } = nLength2(ORDER, bitLen3);
  if (BYTES > 2048) throw new Error("Field lengths over 2048 bytes are not supported");
  const sqrtP = FpSqrt2(ORDER);
  const f3 = Object.freeze({
    ORDER,
    BITS,
    BYTES,
    MASK: bitMask2(BITS),
    ZERO: _0n$3,
    ONE: _1n$4,
    create: (num2) => mod3(num2, ORDER),
    isValid: (num2) => {
      if (typeof num2 !== "bigint") throw new Error(`Invalid field element: expected bigint, got ${typeof num2}`);
      return _0n$3 <= num2 && num2 < ORDER;
    },
    is0: (num2) => num2 === _0n$3,
    isOdd: (num2) => (num2 & _1n$4) === _1n$4,
    neg: (num2) => mod3(-num2, ORDER),
    eql: (lhs, rhs) => lhs === rhs,
    sqr: (num2) => mod3(num2 * num2, ORDER),
    add: (lhs, rhs) => mod3(lhs + rhs, ORDER),
    sub: (lhs, rhs) => mod3(lhs - rhs, ORDER),
    mul: (lhs, rhs) => mod3(lhs * rhs, ORDER),
    pow: (num2, power) => FpPow2(f3, num2, power),
    div: (lhs, rhs) => mod3(lhs * invert3(rhs, ORDER), ORDER),
    // Same as above, but doesn't normalize
    sqrN: (num2) => num2 * num2,
    addN: (lhs, rhs) => lhs + rhs,
    subN: (lhs, rhs) => lhs - rhs,
    mulN: (lhs, rhs) => lhs * rhs,
    inv: (num2) => invert3(num2, ORDER),
    sqrt: redef.sqrt || ((n) => sqrtP(f3, n)),
    invertBatch: (lst) => FpInvertBatch2(f3, lst),
    // TODO: do we really need constant cmov?
    // We don't have const-time bigints anyway, so probably will be not very useful
    cmov: (a, b, c) => c ? b : a,
    toBytes: (num2) => isLE6 ? numberToBytesLE2(num2, BYTES) : numberToBytesBE2(num2, BYTES),
    fromBytes: (bytes3) => {
      if (bytes3.length !== BYTES) throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes3.length}`);
      return isLE6 ? bytesToNumberLE2(bytes3) : bytesToNumberBE2(bytes3);
    }
  });
  return Object.freeze(f3);
}
function getFieldBytesLength2(fieldOrder) {
  if (typeof fieldOrder !== "bigint") throw new Error("field order must be bigint");
  const bitLength = fieldOrder.toString(2).length;
  return Math.ceil(bitLength / 8);
}
function getMinHashLength2(fieldOrder) {
  const length2 = getFieldBytesLength2(fieldOrder);
  return length2 + Math.ceil(length2 / 2);
}
function mapHashToField2(key, fieldOrder) {
  let isLE6 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
  const len = key.length;
  const fieldLen = getFieldBytesLength2(fieldOrder);
  const minLen = getMinHashLength2(fieldOrder);
  if (len < 16 || len < minLen || len > 1024) throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);
  const num2 = isLE6 ? bytesToNumberBE2(key) : bytesToNumberLE2(key);
  const reduced = mod3(num2, fieldOrder - _1n$4) + _1n$4;
  return isLE6 ? numberToBytesLE2(reduced, fieldLen) : numberToBytesBE2(reduced, fieldLen);
}
var _0n$2 = BigInt(0);
var _1n$3 = BigInt(1);
var pointPrecomputes3 = /* @__PURE__ */ new WeakMap();
var pointWindowSizes2 = /* @__PURE__ */ new WeakMap();
function wNAF2(c, bits) {
  const constTimeNegate = (condition, item) => {
    const neg = item.negate();
    return condition ? neg : item;
  };
  const validateW2 = (W) => {
    if (!Number.isSafeInteger(W) || W <= 0 || W > bits) throw new Error(`Wrong window size=${W}, should be [1..${bits}]`);
  };
  const opts = (W) => {
    validateW2(W);
    const windows = Math.ceil(bits / W) + 1;
    const windowSize = 2 ** (W - 1);
    return {
      windows,
      windowSize
    };
  };
  return {
    constTimeNegate,
    // non-const time multiplication ladder
    unsafeLadder(elm, n) {
      let p = c.ZERO;
      let d = elm;
      while (n > _0n$2) {
        if (n & _1n$3) p = p.add(d);
        d = d.double();
        n >>= _1n$3;
      }
      return p;
    },
    /**
     * Creates a wNAF precomputation window. Used for caching.
     * Default window size is set by `utils.precompute()` and is equal to 8.
     * Number of precomputed points depends on the curve size:
     * 2^(𝑊−1) * (Math.ceil(𝑛 / 𝑊) + 1), where:
     * - 𝑊 is the window size
     * - 𝑛 is the bitlength of the curve order.
     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
     * @returns precomputed point tables flattened to a single array
     */
    precomputeWindow(elm, W) {
      const {
        windows,
        windowSize
      } = opts(W);
      const points = [];
      let p = elm;
      let base3 = p;
      for (let window2 = 0; window2 < windows; window2++) {
        base3 = p;
        points.push(base3);
        for (let i = 1; i < windowSize; i++) {
          base3 = base3.add(p);
          points.push(base3);
        }
        p = base3.double();
      }
      return points;
    },
    /**
     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @returns real and fake (for const-time) points
     */
    wNAF(W, precomputes, n) {
      const {
        windows,
        windowSize
      } = opts(W);
      let p = c.ZERO;
      let f3 = c.BASE;
      const mask3 = BigInt(2 ** W - 1);
      const maxNumber = 2 ** W;
      const shiftBy = BigInt(W);
      for (let window2 = 0; window2 < windows; window2++) {
        const offset3 = window2 * windowSize;
        let wbits = Number(n & mask3);
        n >>= shiftBy;
        if (wbits > windowSize) {
          wbits -= maxNumber;
          n += _1n$3;
        }
        const offset1 = offset3;
        const offset22 = offset3 + Math.abs(wbits) - 1;
        const cond1 = window2 % 2 !== 0;
        const cond2 = wbits < 0;
        if (wbits === 0) {
          f3 = f3.add(constTimeNegate(cond1, precomputes[offset1]));
        } else {
          p = p.add(constTimeNegate(cond2, precomputes[offset22]));
        }
      }
      return {
        p,
        f: f3
      };
    },
    wNAFCached(P, n, transform) {
      const W = pointWindowSizes2.get(P) || 1;
      let comp = pointPrecomputes3.get(P);
      if (!comp) {
        comp = this.precomputeWindow(P, W);
        if (W !== 1) pointPrecomputes3.set(P, transform(comp));
      }
      return this.wNAF(W, comp, n);
    },
    // We calculate precomputes for elliptic curve point multiplication
    // using windowed method. This specifies window size and
    // stores precomputed values. Usually only base point would be precomputed.
    setWindowSize(P, W) {
      validateW2(W);
      pointWindowSizes2.set(P, W);
      pointPrecomputes3.delete(P);
    }
  };
}
function pippenger2(c, field, points, scalars) {
  if (!Array.isArray(points) || !Array.isArray(scalars) || scalars.length !== points.length) throw new Error("arrays of points and scalars must have equal length");
  scalars.forEach((s, i) => {
    if (!field.isValid(s)) throw new Error(`wrong scalar at index ${i}`);
  });
  points.forEach((p, i) => {
    if (!(p instanceof c)) throw new Error(`wrong point at index ${i}`);
  });
  const wbits = bitLen2(BigInt(points.length));
  const windowSize = wbits > 12 ? wbits - 3 : wbits > 4 ? wbits - 2 : wbits ? 2 : 1;
  const MASK = (1 << windowSize) - 1;
  const buckets = new Array(MASK + 1).fill(c.ZERO);
  const lastBits = Math.floor((field.BITS - 1) / windowSize) * windowSize;
  let sum = c.ZERO;
  for (let i = lastBits; i >= 0; i -= windowSize) {
    buckets.fill(c.ZERO);
    for (let j = 0; j < scalars.length; j++) {
      const scalar = scalars[j];
      const wbits2 = Number(scalar >> BigInt(i) & BigInt(MASK));
      buckets[wbits2] = buckets[wbits2].add(points[j]);
    }
    let resI = c.ZERO;
    for (let j = buckets.length - 1, sumI = c.ZERO; j > 0; j--) {
      sumI = sumI.add(buckets[j]);
      resI = resI.add(sumI);
    }
    sum = sum.add(resI);
    if (i !== 0) for (let j = 0; j < windowSize; j++) sum = sum.double();
  }
  return sum;
}
function validateBasic(curve) {
  validateField2(curve.Fp);
  validateObject2(curve, {
    n: "bigint",
    h: "bigint",
    Gx: "field",
    Gy: "field"
  }, {
    nBitLength: "isSafeInteger",
    nByteLength: "isSafeInteger"
  });
  return Object.freeze({
    ...nLength2(curve.n, curve.nBitLength),
    ...curve,
    ...{
      p: curve.Fp.ORDER
    }
  });
}
function validateSigVerOpts(opts) {
  if (opts.lowS !== void 0) abool("lowS", opts.lowS);
  if (opts.prehash !== void 0) abool("prehash", opts.prehash);
}
function validatePointOpts(curve) {
  const opts = validateBasic(curve);
  validateObject2(opts, {
    a: "field",
    b: "field"
  }, {
    allowedPrivateKeyLengths: "array",
    wrapPrivateKey: "boolean",
    isTorsionFree: "function",
    clearCofactor: "function",
    allowInfinityPoint: "boolean",
    fromBytes: "function",
    toBytes: "function"
  });
  const {
    endo,
    Fp: Fp3,
    a
  } = opts;
  if (endo) {
    if (!Fp3.eql(a, Fp3.ZERO)) {
      throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
    }
    if (typeof endo !== "object" || typeof endo.beta !== "bigint" || typeof endo.splitScalar !== "function") {
      throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
    }
  }
  return Object.freeze({
    ...opts
  });
}
var {
  bytesToNumberBE: b2n,
  hexToBytes: h2b
} = ut;
var DER2 = {
  // asn.1 DER encoding utils
  Err: class DERErr2 extends Error {
    constructor() {
      let m = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
      super(m);
    }
  },
  // Basic building block is TLV (Tag-Length-Value)
  _tlv: {
    encode: (tag, data) => {
      const {
        Err: E
      } = DER2;
      if (tag < 0 || tag > 256) throw new E("tlv.encode: wrong tag");
      if (data.length & 1) throw new E("tlv.encode: unpadded data");
      const dataLen = data.length / 2;
      const len = numberToHexUnpadded3(dataLen);
      if (len.length / 2 & 128) throw new E("tlv.encode: long form length too big");
      const lenLen = dataLen > 127 ? numberToHexUnpadded3(len.length / 2 | 128) : "";
      return `${numberToHexUnpadded3(tag)}${lenLen}${len}${data}`;
    },
    // v - value, l - left bytes (unparsed)
    decode(tag, data) {
      const {
        Err: E
      } = DER2;
      let pos = 0;
      if (tag < 0 || tag > 256) throw new E("tlv.encode: wrong tag");
      if (data.length < 2 || data[pos++] !== tag) throw new E("tlv.decode: wrong tlv");
      const first = data[pos++];
      const isLong = !!(first & 128);
      let length2 = 0;
      if (!isLong) length2 = first;
      else {
        const lenLen = first & 127;
        if (!lenLen) throw new E("tlv.decode(long): indefinite length not supported");
        if (lenLen > 4) throw new E("tlv.decode(long): byte length is too big");
        const lengthBytes = data.subarray(pos, pos + lenLen);
        if (lengthBytes.length !== lenLen) throw new E("tlv.decode: length bytes not complete");
        if (lengthBytes[0] === 0) throw new E("tlv.decode(long): zero leftmost byte");
        for (const b of lengthBytes) length2 = length2 << 8 | b;
        pos += lenLen;
        if (length2 < 128) throw new E("tlv.decode(long): not minimal encoding");
      }
      const v = data.subarray(pos, pos + length2);
      if (v.length !== length2) throw new E("tlv.decode: wrong value length");
      return {
        v,
        l: data.subarray(pos + length2)
      };
    }
  },
  // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,
  // since we always use positive integers here. It must always be empty:
  // - add zero byte if exists
  // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)
  _int: {
    encode(num2) {
      const {
        Err: E
      } = DER2;
      if (num2 < _0n$1) throw new E("integer: negative integers are not allowed");
      let hex3 = numberToHexUnpadded3(num2);
      if (Number.parseInt(hex3[0], 16) & 8) hex3 = "00" + hex3;
      if (hex3.length & 1) throw new E("unexpected assertion");
      return hex3;
    },
    decode(data) {
      const {
        Err: E
      } = DER2;
      if (data[0] & 128) throw new E("Invalid signature integer: negative");
      if (data[0] === 0 && !(data[1] & 128)) throw new E("Invalid signature integer: unnecessary leading zero");
      return b2n(data);
    }
  },
  toSig(hex3) {
    const {
      Err: E,
      _int: int,
      _tlv: tlv
    } = DER2;
    const data = typeof hex3 === "string" ? h2b(hex3) : hex3;
    abytes4(data);
    const {
      v: seqBytes,
      l: seqLeftBytes
    } = tlv.decode(48, data);
    if (seqLeftBytes.length) throw new E("Invalid signature: left bytes after parsing");
    const {
      v: rBytes,
      l: rLeftBytes
    } = tlv.decode(2, seqBytes);
    const {
      v: sBytes,
      l: sLeftBytes
    } = tlv.decode(2, rLeftBytes);
    if (sLeftBytes.length) throw new E("Invalid signature: left bytes after parsing");
    return {
      r: int.decode(rBytes),
      s: int.decode(sBytes)
    };
  },
  hexFromSig(sig) {
    const {
      _tlv: tlv,
      _int: int
    } = DER2;
    const seq4 = `${tlv.encode(2, int.encode(sig.r))}${tlv.encode(2, int.encode(sig.s))}`;
    return tlv.encode(48, seq4);
  }
};
var _0n$1 = BigInt(0);
var _1n$2 = BigInt(1);
BigInt(2);
var _3n5 = BigInt(3);
BigInt(4);
function weierstrassPoints(opts) {
  const CURVE2 = validatePointOpts(opts);
  const {
    Fp: Fp3
  } = CURVE2;
  const Fn2 = Field2(CURVE2.n, CURVE2.nBitLength);
  const toBytes8 = CURVE2.toBytes || ((_c, point, _isCompressed) => {
    const a = point.toAffine();
    return concatBytes5(Uint8Array.from([4]), Fp3.toBytes(a.x), Fp3.toBytes(a.y));
  });
  const fromBytes2 = CURVE2.fromBytes || ((bytes3) => {
    const tail = bytes3.subarray(1);
    const x = Fp3.fromBytes(tail.subarray(0, Fp3.BYTES));
    const y = Fp3.fromBytes(tail.subarray(Fp3.BYTES, 2 * Fp3.BYTES));
    return {
      x,
      y
    };
  });
  function weierstrassEquation(x) {
    const {
      a,
      b
    } = CURVE2;
    const x2 = Fp3.sqr(x);
    const x3 = Fp3.mul(x2, x);
    return Fp3.add(Fp3.add(x3, Fp3.mul(x, a)), b);
  }
  if (!Fp3.eql(Fp3.sqr(CURVE2.Gy), weierstrassEquation(CURVE2.Gx))) throw new Error("bad generator point: equation left != right");
  function isWithinCurveOrder2(num2) {
    return inRange3(num2, _1n$2, CURVE2.n);
  }
  function normPrivateKeyToScalar(key) {
    const {
      allowedPrivateKeyLengths: lengths,
      nByteLength,
      wrapPrivateKey,
      n: N
    } = CURVE2;
    if (lengths && typeof key !== "bigint") {
      if (isBytes6(key)) key = bytesToHex$1(key);
      if (typeof key !== "string" || !lengths.includes(key.length)) throw new Error("Invalid key");
      key = key.padStart(nByteLength * 2, "0");
    }
    let num2;
    try {
      num2 = typeof key === "bigint" ? key : bytesToNumberBE2(ensureBytes4("private key", key, nByteLength));
    } catch (error) {
      throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);
    }
    if (wrapPrivateKey) num2 = mod3(num2, N);
    aInRange2("private key", num2, _1n$2, N);
    return num2;
  }
  function assertPrjPoint(other) {
    if (!(other instanceof Point2)) throw new Error("ProjectivePoint expected");
  }
  const toAffineMemo = memoized2((p, iz) => {
    const {
      px: x,
      py: y,
      pz: z2
    } = p;
    if (Fp3.eql(z2, Fp3.ONE)) return {
      x,
      y
    };
    const is0 = p.is0();
    if (iz == null) iz = is0 ? Fp3.ONE : Fp3.inv(z2);
    const ax = Fp3.mul(x, iz);
    const ay = Fp3.mul(y, iz);
    const zz = Fp3.mul(z2, iz);
    if (is0) return {
      x: Fp3.ZERO,
      y: Fp3.ZERO
    };
    if (!Fp3.eql(zz, Fp3.ONE)) throw new Error("invZ was invalid");
    return {
      x: ax,
      y: ay
    };
  });
  const assertValidMemo = memoized2((p) => {
    if (p.is0()) {
      if (CURVE2.allowInfinityPoint && !Fp3.is0(p.py)) return;
      throw new Error("bad point: ZERO");
    }
    const {
      x,
      y
    } = p.toAffine();
    if (!Fp3.isValid(x) || !Fp3.isValid(y)) throw new Error("bad point: x or y not FE");
    const left = Fp3.sqr(y);
    const right = weierstrassEquation(x);
    if (!Fp3.eql(left, right)) throw new Error("bad point: equation left != right");
    if (!p.isTorsionFree()) throw new Error("bad point: not in prime-order subgroup");
    return true;
  });
  class Point2 {
    constructor(px, py, pz) {
      this.px = px;
      this.py = py;
      this.pz = pz;
      if (px == null || !Fp3.isValid(px)) throw new Error("x required");
      if (py == null || !Fp3.isValid(py)) throw new Error("y required");
      if (pz == null || !Fp3.isValid(pz)) throw new Error("z required");
      Object.freeze(this);
    }
    // Does not validate if the point is on-curve.
    // Use fromHex instead, or call assertValidity() later.
    static fromAffine(p) {
      const {
        x,
        y
      } = p || {};
      if (!p || !Fp3.isValid(x) || !Fp3.isValid(y)) throw new Error("invalid affine point");
      if (p instanceof Point2) throw new Error("projective point not allowed");
      const is0 = (i) => Fp3.eql(i, Fp3.ZERO);
      if (is0(x) && is0(y)) return Point2.ZERO;
      return new Point2(x, y, Fp3.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    /**
     * Takes a bunch of Projective Points but executes only one
     * inversion on all of them. Inversion is very slow operation,
     * so this improves performance massively.
     * Optimization: converts a list of projective points to a list of identical points with Z=1.
     */
    static normalizeZ(points) {
      const toInv = Fp3.invertBatch(points.map((p) => p.pz));
      return points.map((p, i) => p.toAffine(toInv[i])).map(Point2.fromAffine);
    }
    /**
     * Converts hash string or Uint8Array to Point.
     * @param hex short/long ECDSA hex
     */
    static fromHex(hex3) {
      const P = Point2.fromAffine(fromBytes2(ensureBytes4("pointHex", hex3)));
      P.assertValidity();
      return P;
    }
    // Multiplies generator point by privateKey.
    static fromPrivateKey(privateKey) {
      return Point2.BASE.multiply(normPrivateKeyToScalar(privateKey));
    }
    // Multiscalar Multiplication
    static msm(points, scalars) {
      return pippenger2(Point2, Fn2, points, scalars);
    }
    // "Private method", don't use it directly
    _setWindowSize(windowSize) {
      wnaf.setWindowSize(this, windowSize);
    }
    // A point on curve is valid if it conforms to equation.
    assertValidity() {
      assertValidMemo(this);
    }
    hasEvenY() {
      const {
        y
      } = this.toAffine();
      if (Fp3.isOdd) return !Fp3.isOdd(y);
      throw new Error("Field doesn't support isOdd");
    }
    /**
     * Compare one point to another.
     */
    equals(other) {
      assertPrjPoint(other);
      const {
        px: X1,
        py: Y1,
        pz: Z1
      } = this;
      const {
        px: X2,
        py: Y2,
        pz: Z2
      } = other;
      const U1 = Fp3.eql(Fp3.mul(X1, Z2), Fp3.mul(X2, Z1));
      const U2 = Fp3.eql(Fp3.mul(Y1, Z2), Fp3.mul(Y2, Z1));
      return U1 && U2;
    }
    /**
     * Flips point to one corresponding to (x, -y) in Affine coordinates.
     */
    negate() {
      return new Point2(this.px, Fp3.neg(this.py), this.pz);
    }
    // Renes-Costello-Batina exception-free doubling formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 3
    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
    double() {
      const {
        a,
        b
      } = CURVE2;
      const b3 = Fp3.mul(b, _3n5);
      const {
        px: X1,
        py: Y1,
        pz: Z1
      } = this;
      let X3 = Fp3.ZERO, Y3 = Fp3.ZERO, Z3 = Fp3.ZERO;
      let t0 = Fp3.mul(X1, X1);
      let t1 = Fp3.mul(Y1, Y1);
      let t2 = Fp3.mul(Z1, Z1);
      let t3 = Fp3.mul(X1, Y1);
      t3 = Fp3.add(t3, t3);
      Z3 = Fp3.mul(X1, Z1);
      Z3 = Fp3.add(Z3, Z3);
      X3 = Fp3.mul(a, Z3);
      Y3 = Fp3.mul(b3, t2);
      Y3 = Fp3.add(X3, Y3);
      X3 = Fp3.sub(t1, Y3);
      Y3 = Fp3.add(t1, Y3);
      Y3 = Fp3.mul(X3, Y3);
      X3 = Fp3.mul(t3, X3);
      Z3 = Fp3.mul(b3, Z3);
      t2 = Fp3.mul(a, t2);
      t3 = Fp3.sub(t0, t2);
      t3 = Fp3.mul(a, t3);
      t3 = Fp3.add(t3, Z3);
      Z3 = Fp3.add(t0, t0);
      t0 = Fp3.add(Z3, t0);
      t0 = Fp3.add(t0, t2);
      t0 = Fp3.mul(t0, t3);
      Y3 = Fp3.add(Y3, t0);
      t2 = Fp3.mul(Y1, Z1);
      t2 = Fp3.add(t2, t2);
      t0 = Fp3.mul(t2, t3);
      X3 = Fp3.sub(X3, t0);
      Z3 = Fp3.mul(t2, t1);
      Z3 = Fp3.add(Z3, Z3);
      Z3 = Fp3.add(Z3, Z3);
      return new Point2(X3, Y3, Z3);
    }
    // Renes-Costello-Batina exception-free addition formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 1
    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
    add(other) {
      assertPrjPoint(other);
      const {
        px: X1,
        py: Y1,
        pz: Z1
      } = this;
      const {
        px: X2,
        py: Y2,
        pz: Z2
      } = other;
      let X3 = Fp3.ZERO, Y3 = Fp3.ZERO, Z3 = Fp3.ZERO;
      const a = CURVE2.a;
      const b3 = Fp3.mul(CURVE2.b, _3n5);
      let t0 = Fp3.mul(X1, X2);
      let t1 = Fp3.mul(Y1, Y2);
      let t2 = Fp3.mul(Z1, Z2);
      let t3 = Fp3.add(X1, Y1);
      let t4 = Fp3.add(X2, Y2);
      t3 = Fp3.mul(t3, t4);
      t4 = Fp3.add(t0, t1);
      t3 = Fp3.sub(t3, t4);
      t4 = Fp3.add(X1, Z1);
      let t5 = Fp3.add(X2, Z2);
      t4 = Fp3.mul(t4, t5);
      t5 = Fp3.add(t0, t2);
      t4 = Fp3.sub(t4, t5);
      t5 = Fp3.add(Y1, Z1);
      X3 = Fp3.add(Y2, Z2);
      t5 = Fp3.mul(t5, X3);
      X3 = Fp3.add(t1, t2);
      t5 = Fp3.sub(t5, X3);
      Z3 = Fp3.mul(a, t4);
      X3 = Fp3.mul(b3, t2);
      Z3 = Fp3.add(X3, Z3);
      X3 = Fp3.sub(t1, Z3);
      Z3 = Fp3.add(t1, Z3);
      Y3 = Fp3.mul(X3, Z3);
      t1 = Fp3.add(t0, t0);
      t1 = Fp3.add(t1, t0);
      t2 = Fp3.mul(a, t2);
      t4 = Fp3.mul(b3, t4);
      t1 = Fp3.add(t1, t2);
      t2 = Fp3.sub(t0, t2);
      t2 = Fp3.mul(a, t2);
      t4 = Fp3.add(t4, t2);
      t0 = Fp3.mul(t1, t4);
      Y3 = Fp3.add(Y3, t0);
      t0 = Fp3.mul(t5, t4);
      X3 = Fp3.mul(t3, X3);
      X3 = Fp3.sub(X3, t0);
      t0 = Fp3.mul(t3, t1);
      Z3 = Fp3.mul(t5, Z3);
      Z3 = Fp3.add(Z3, t0);
      return new Point2(X3, Y3, Z3);
    }
    subtract(other) {
      return this.add(other.negate());
    }
    is0() {
      return this.equals(Point2.ZERO);
    }
    wNAF(n) {
      return wnaf.wNAFCached(this, n, Point2.normalizeZ);
    }
    /**
     * Non-constant-time multiplication. Uses double-and-add algorithm.
     * It's faster, but should only be used when you don't care about
     * an exposed private key e.g. sig verification, which works over *public* keys.
     */
    multiplyUnsafe(sc) {
      aInRange2("scalar", sc, _0n$1, CURVE2.n);
      const I = Point2.ZERO;
      if (sc === _0n$1) return I;
      if (sc === _1n$2) return this;
      const {
        endo
      } = CURVE2;
      if (!endo) return wnaf.unsafeLadder(this, sc);
      let {
        k1neg,
        k1,
        k2neg,
        k2
      } = endo.splitScalar(sc);
      let k1p = I;
      let k2p = I;
      let d = this;
      while (k1 > _0n$1 || k2 > _0n$1) {
        if (k1 & _1n$2) k1p = k1p.add(d);
        if (k2 & _1n$2) k2p = k2p.add(d);
        d = d.double();
        k1 >>= _1n$2;
        k2 >>= _1n$2;
      }
      if (k1neg) k1p = k1p.negate();
      if (k2neg) k2p = k2p.negate();
      k2p = new Point2(Fp3.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
      return k1p.add(k2p);
    }
    /**
     * Constant time multiplication.
     * Uses wNAF method. Windowed method may be 10% faster,
     * but takes 2x longer to generate and consumes 2x memory.
     * Uses precomputes when available.
     * Uses endomorphism for Koblitz curves.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */
    multiply(scalar) {
      const {
        endo,
        n: N
      } = CURVE2;
      aInRange2("scalar", scalar, _1n$2, N);
      let point, fake;
      if (endo) {
        const {
          k1neg,
          k1,
          k2neg,
          k2
        } = endo.splitScalar(scalar);
        let {
          p: k1p,
          f: f1p
        } = this.wNAF(k1);
        let {
          p: k2p,
          f: f2p
        } = this.wNAF(k2);
        k1p = wnaf.constTimeNegate(k1neg, k1p);
        k2p = wnaf.constTimeNegate(k2neg, k2p);
        k2p = new Point2(Fp3.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
        point = k1p.add(k2p);
        fake = f1p.add(f2p);
      } else {
        const {
          p,
          f: f3
        } = this.wNAF(scalar);
        point = p;
        fake = f3;
      }
      return Point2.normalizeZ([point, fake])[0];
    }
    /**
     * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
     * Not using Strauss-Shamir trick: precomputation tables are faster.
     * The trick could be useful if both P and Q are not G (not in our case).
     * @returns non-zero affine point
     */
    multiplyAndAddUnsafe(Q, a, b) {
      const G = Point2.BASE;
      const mul = (P, a2) => a2 === _0n$1 || a2 === _1n$2 || !P.equals(G) ? P.multiplyUnsafe(a2) : P.multiply(a2);
      const sum = mul(this, a).add(mul(Q, b));
      return sum.is0() ? void 0 : sum;
    }
    // Converts Projective point to affine (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    // (x, y, z) ∋ (x=x/z, y=y/z)
    toAffine(iz) {
      return toAffineMemo(this, iz);
    }
    isTorsionFree() {
      const {
        h: cofactor,
        isTorsionFree
      } = CURVE2;
      if (cofactor === _1n$2) return true;
      if (isTorsionFree) return isTorsionFree(Point2, this);
      throw new Error("isTorsionFree() has not been declared for the elliptic curve");
    }
    clearCofactor() {
      const {
        h: cofactor,
        clearCofactor
      } = CURVE2;
      if (cofactor === _1n$2) return this;
      if (clearCofactor) return clearCofactor(Point2, this);
      return this.multiplyUnsafe(CURVE2.h);
    }
    toRawBytes() {
      let isCompressed = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
      abool("isCompressed", isCompressed);
      this.assertValidity();
      return toBytes8(Point2, this, isCompressed);
    }
    toHex() {
      let isCompressed = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
      abool("isCompressed", isCompressed);
      return bytesToHex$1(this.toRawBytes(isCompressed));
    }
  }
  Point2.BASE = new Point2(CURVE2.Gx, CURVE2.Gy, Fp3.ONE);
  Point2.ZERO = new Point2(Fp3.ZERO, Fp3.ONE, Fp3.ZERO);
  const _bits = CURVE2.nBitLength;
  const wnaf = wNAF2(Point2, CURVE2.endo ? Math.ceil(_bits / 2) : _bits);
  return {
    CURVE: CURVE2,
    ProjectivePoint: Point2,
    normPrivateKeyToScalar,
    weierstrassEquation,
    isWithinCurveOrder: isWithinCurveOrder2
  };
}
function validateOpts2(curve) {
  const opts = validateBasic(curve);
  validateObject2(opts, {
    hash: "hash",
    hmac: "function",
    randomBytes: "function"
  }, {
    bits2int: "function",
    bits2int_modN: "function",
    lowS: "boolean"
  });
  return Object.freeze({
    lowS: true,
    ...opts
  });
}
function weierstrass2(curveDef) {
  const CURVE2 = validateOpts2(curveDef);
  const {
    Fp: Fp3,
    n: CURVE_ORDER
  } = CURVE2;
  const compressedLen = Fp3.BYTES + 1;
  const uncompressedLen = 2 * Fp3.BYTES + 1;
  function modN(a) {
    return mod3(a, CURVE_ORDER);
  }
  function invN(a) {
    return invert3(a, CURVE_ORDER);
  }
  const {
    ProjectivePoint: Point2,
    normPrivateKeyToScalar,
    weierstrassEquation,
    isWithinCurveOrder: isWithinCurveOrder2
  } = weierstrassPoints({
    ...CURVE2,
    toBytes(_c, point, isCompressed) {
      const a = point.toAffine();
      const x = Fp3.toBytes(a.x);
      const cat = concatBytes5;
      abool("isCompressed", isCompressed);
      if (isCompressed) {
        return cat(Uint8Array.from([point.hasEvenY() ? 2 : 3]), x);
      } else {
        return cat(Uint8Array.from([4]), x, Fp3.toBytes(a.y));
      }
    },
    fromBytes(bytes3) {
      const len = bytes3.length;
      const head = bytes3[0];
      const tail = bytes3.subarray(1);
      if (len === compressedLen && (head === 2 || head === 3)) {
        const x = bytesToNumberBE2(tail);
        if (!inRange3(x, _1n$2, Fp3.ORDER)) throw new Error("Point is not on curve");
        const y2 = weierstrassEquation(x);
        let y;
        try {
          y = Fp3.sqrt(y2);
        } catch (sqrtError) {
          const suffix = sqrtError instanceof Error ? ": " + sqrtError.message : "";
          throw new Error("Point is not on curve" + suffix);
        }
        const isYOdd = (y & _1n$2) === _1n$2;
        const isHeadOdd = (head & 1) === 1;
        if (isHeadOdd !== isYOdd) y = Fp3.neg(y);
        return {
          x,
          y
        };
      } else if (len === uncompressedLen && head === 4) {
        const x = Fp3.fromBytes(tail.subarray(0, Fp3.BYTES));
        const y = Fp3.fromBytes(tail.subarray(Fp3.BYTES, 2 * Fp3.BYTES));
        return {
          x,
          y
        };
      } else {
        throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);
      }
    }
  });
  const numToNByteStr = (num2) => bytesToHex$1(numberToBytesBE2(num2, CURVE2.nByteLength));
  function isBiggerThanHalfOrder(number5) {
    const HALF = CURVE_ORDER >> _1n$2;
    return number5 > HALF;
  }
  function normalizeS(s) {
    return isBiggerThanHalfOrder(s) ? modN(-s) : s;
  }
  const slcNum = (b, from2, to) => bytesToNumberBE2(b.slice(from2, to));
  class Signature2 {
    constructor(r, s, recovery) {
      this.r = r;
      this.s = s;
      this.recovery = recovery;
      this.assertValidity();
    }
    // pair (bytes of r, bytes of s)
    static fromCompact(hex3) {
      const l = CURVE2.nByteLength;
      hex3 = ensureBytes4("compactSignature", hex3, l * 2);
      return new Signature2(slcNum(hex3, 0, l), slcNum(hex3, l, 2 * l));
    }
    // DER encoded ECDSA signature
    // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
    static fromDER(hex3) {
      const {
        r,
        s
      } = DER2.toSig(ensureBytes4("DER", hex3));
      return new Signature2(r, s);
    }
    assertValidity() {
      aInRange2("r", this.r, _1n$2, CURVE_ORDER);
      aInRange2("s", this.s, _1n$2, CURVE_ORDER);
    }
    addRecoveryBit(recovery) {
      return new Signature2(this.r, this.s, recovery);
    }
    recoverPublicKey(msgHash) {
      const {
        r,
        s,
        recovery: rec
      } = this;
      const h = bits2int_modN(ensureBytes4("msgHash", msgHash));
      if (rec == null || ![0, 1, 2, 3].includes(rec)) throw new Error("recovery id invalid");
      const radj = rec === 2 || rec === 3 ? r + CURVE2.n : r;
      if (radj >= Fp3.ORDER) throw new Error("recovery id 2 or 3 invalid");
      const prefix = (rec & 1) === 0 ? "02" : "03";
      const R = Point2.fromHex(prefix + numToNByteStr(radj));
      const ir = invN(radj);
      const u1 = modN(-h * ir);
      const u2 = modN(s * ir);
      const Q = Point2.BASE.multiplyAndAddUnsafe(R, u1, u2);
      if (!Q) throw new Error("point at infinify");
      Q.assertValidity();
      return Q;
    }
    // Signatures should be low-s, to prevent malleability.
    hasHighS() {
      return isBiggerThanHalfOrder(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new Signature2(this.r, modN(-this.s), this.recovery) : this;
    }
    // DER-encoded
    toDERRawBytes() {
      return hexToBytes4(this.toDERHex());
    }
    toDERHex() {
      return DER2.hexFromSig({
        r: this.r,
        s: this.s
      });
    }
    // padded bytes of r, then padded bytes of s
    toCompactRawBytes() {
      return hexToBytes4(this.toCompactHex());
    }
    toCompactHex() {
      return numToNByteStr(this.r) + numToNByteStr(this.s);
    }
  }
  const utils3 = {
    isValidPrivateKey(privateKey) {
      try {
        normPrivateKeyToScalar(privateKey);
        return true;
      } catch (error) {
        return false;
      }
    },
    normPrivateKeyToScalar,
    /**
     * Produces cryptographically secure private key from random of size
     * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
     */
    randomPrivateKey: () => {
      const length2 = getMinHashLength2(CURVE2.n);
      return mapHashToField2(CURVE2.randomBytes(length2), CURVE2.n);
    },
    /**
     * Creates precompute table for an arbitrary EC point. Makes point "cached".
     * Allows to massively speed-up `point.multiply(scalar)`.
     * @returns cached point
     * @example
     * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
     * fast.multiply(privKey); // much faster ECDH now
     */
    precompute() {
      let windowSize = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 8;
      let point = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Point2.BASE;
      point._setWindowSize(windowSize);
      point.multiply(BigInt(3));
      return point;
    }
  };
  function getPublicKey2(privateKey) {
    let isCompressed = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
    return Point2.fromPrivateKey(privateKey).toRawBytes(isCompressed);
  }
  function isProbPub2(item) {
    const arr = isBytes6(item);
    const str2 = typeof item === "string";
    const len = (arr || str2) && item.length;
    if (arr) return len === compressedLen || len === uncompressedLen;
    if (str2) return len === 2 * compressedLen || len === 2 * uncompressedLen;
    if (item instanceof Point2) return true;
    return false;
  }
  function getSharedSecret3(privateA, publicB) {
    let isCompressed = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
    if (isProbPub2(privateA)) throw new Error("first arg must be private key");
    if (!isProbPub2(publicB)) throw new Error("second arg must be public key");
    const b = Point2.fromHex(publicB);
    return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);
  }
  const bits2int2 = CURVE2.bits2int || function(bytes3) {
    const num2 = bytesToNumberBE2(bytes3);
    const delta = bytes3.length * 8 - CURVE2.nBitLength;
    return delta > 0 ? num2 >> BigInt(delta) : num2;
  };
  const bits2int_modN = CURVE2.bits2int_modN || function(bytes3) {
    return modN(bits2int2(bytes3));
  };
  const ORDER_MASK = bitMask2(CURVE2.nBitLength);
  function int2octets2(num2) {
    aInRange2(`num < 2^${CURVE2.nBitLength}`, num2, _0n$1, ORDER_MASK);
    return numberToBytesBE2(num2, CURVE2.nByteLength);
  }
  function prepSig(msgHash, privateKey) {
    let opts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : defaultSigOpts;
    if (["recovered", "canonical"].some((k) => k in opts)) throw new Error("sign() legacy options not supported");
    const {
      hash: hash3,
      randomBytes: randomBytes3
    } = CURVE2;
    let {
      lowS,
      prehash,
      extraEntropy: ent
    } = opts;
    if (lowS == null) lowS = true;
    msgHash = ensureBytes4("msgHash", msgHash);
    validateSigVerOpts(opts);
    if (prehash) msgHash = ensureBytes4("prehashed msgHash", hash3(msgHash));
    const h1int = bits2int_modN(msgHash);
    const d = normPrivateKeyToScalar(privateKey);
    const seedArgs = [int2octets2(d), int2octets2(h1int)];
    if (ent != null && ent !== false) {
      const e = ent === true ? randomBytes3(Fp3.BYTES) : ent;
      seedArgs.push(ensureBytes4("extraEntropy", e));
    }
    const seed2 = concatBytes5(...seedArgs);
    const m = h1int;
    function k2sig(kBytes) {
      const k = bits2int2(kBytes);
      if (!isWithinCurveOrder2(k)) return;
      const ik = invN(k);
      const q = Point2.BASE.multiply(k).toAffine();
      const r = modN(q.x);
      if (r === _0n$1) return;
      const s = modN(ik * modN(m + r * d));
      if (s === _0n$1) return;
      let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n$2);
      let normS = s;
      if (lowS && isBiggerThanHalfOrder(s)) {
        normS = normalizeS(s);
        recovery ^= 1;
      }
      return new Signature2(r, normS, recovery);
    }
    return {
      seed: seed2,
      k2sig
    };
  }
  const defaultSigOpts = {
    lowS: CURVE2.lowS,
    prehash: false
  };
  const defaultVerOpts = {
    lowS: CURVE2.lowS,
    prehash: false
  };
  function sign4(msgHash, privKey) {
    let opts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : defaultSigOpts;
    const {
      seed: seed2,
      k2sig
    } = prepSig(msgHash, privKey, opts);
    const C = CURVE2;
    const drbg = createHmacDrbg2(C.hash.outputLen, C.nByteLength, C.hmac);
    return drbg(seed2, k2sig);
  }
  Point2.BASE._setWindowSize(8);
  function verify2(signature2, msgHash, publicKey5) {
    var _Point$BASE$multiplyA;
    let opts = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : defaultVerOpts;
    const sg = signature2;
    msgHash = ensureBytes4("msgHash", msgHash);
    publicKey5 = ensureBytes4("publicKey", publicKey5);
    if ("strict" in opts) throw new Error("options.strict was renamed to lowS");
    validateSigVerOpts(opts);
    const {
      lowS,
      prehash
    } = opts;
    let _sig = void 0;
    let P;
    try {
      if (typeof sg === "string" || isBytes6(sg)) {
        try {
          _sig = Signature2.fromDER(sg);
        } catch (derError) {
          if (!(derError instanceof DER2.Err)) throw derError;
          _sig = Signature2.fromCompact(sg);
        }
      } else if (typeof sg === "object" && typeof sg.r === "bigint" && typeof sg.s === "bigint") {
        const {
          r: r2,
          s: s2
        } = sg;
        _sig = new Signature2(r2, s2);
      } else {
        throw new Error("PARSE");
      }
      P = Point2.fromHex(publicKey5);
    } catch (error) {
      if (error.message === "PARSE") throw new Error(`signature must be Signature instance, Uint8Array or hex string`);
      return false;
    }
    if (lowS && _sig.hasHighS()) return false;
    if (prehash) msgHash = CURVE2.hash(msgHash);
    const {
      r,
      s
    } = _sig;
    const h = bits2int_modN(msgHash);
    const is3 = invN(s);
    const u1 = modN(h * is3);
    const u2 = modN(r * is3);
    const R = (_Point$BASE$multiplyA = Point2.BASE.multiplyAndAddUnsafe(P, u1, u2)) === null || _Point$BASE$multiplyA === void 0 ? void 0 : _Point$BASE$multiplyA.toAffine();
    if (!R) return false;
    const v = modN(R.x);
    return v === r;
  }
  return {
    CURVE: CURVE2,
    getPublicKey: getPublicKey2,
    getSharedSecret: getSharedSecret3,
    sign: sign4,
    verify: verify2,
    ProjectivePoint: Point2,
    Signature: Signature2,
    utils: utils3
  };
}
function getHash(hash3) {
  return {
    hash: hash3,
    hmac: function(key) {
      for (var _len = arguments.length, msgs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        msgs[_key - 1] = arguments[_key];
      }
      return hmac2(hash3, key, concatBytes$1(...msgs));
    },
    randomBytes: randomBytes$1
  };
}
function createCurve2(curveDef, defHash) {
  const create4 = (hash3) => weierstrass2({
    ...curveDef,
    ...getHash(hash3)
  });
  return Object.freeze({
    ...create4(defHash),
    create: create4
  });
}
var secp256k1P = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f");
var secp256k1N = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
var _1n$1 = BigInt(1);
var _2n$1 = BigInt(2);
var divNearest3 = (a, b) => (a + b / _2n$1) / b;
function sqrtMod3(y) {
  const P = secp256k1P;
  const _3n6 = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
  const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
  const b2 = y * y * y % P;
  const b3 = b2 * b2 * y % P;
  const b6 = pow23(b3, _3n6, P) * b3 % P;
  const b9 = pow23(b6, _3n6, P) * b3 % P;
  const b11 = pow23(b9, _2n$1, P) * b2 % P;
  const b22 = pow23(b11, _11n, P) * b11 % P;
  const b44 = pow23(b22, _22n, P) * b22 % P;
  const b88 = pow23(b44, _44n, P) * b44 % P;
  const b176 = pow23(b88, _88n, P) * b88 % P;
  const b220 = pow23(b176, _44n, P) * b44 % P;
  const b223 = pow23(b220, _3n6, P) * b3 % P;
  const t1 = pow23(b223, _23n, P) * b22 % P;
  const t2 = pow23(t1, _6n, P) * b2 % P;
  const root2 = pow23(t2, _2n$1, P);
  if (!Fp2.eql(Fp2.sqr(root2), y)) throw new Error("Cannot find square root");
  return root2;
}
var Fp2 = Field2(secp256k1P, void 0, void 0, {
  sqrt: sqrtMod3
});
var secp256k13 = createCurve2({
  a: BigInt(0),
  // equation params: a, b
  b: BigInt(7),
  // Seem to be rigid: bitcointalk.org/index.php?topic=289795.msg3183975#msg3183975
  Fp: Fp2,
  // Field's prime: 2n**256n - 2n**32n - 2n**9n - 2n**8n - 2n**7n - 2n**6n - 2n**4n - 1n
  n: secp256k1N,
  // Curve order, total count of valid points in the field
  // Base point (x, y) aka generator point
  Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
  Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
  h: BigInt(1),
  // Cofactor
  lowS: true,
  // Allow only low-S signatures by default in sign() and verify()
  /**
   * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.
   * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.
   * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.
   * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066
   */
  endo: {
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
    splitScalar: (k) => {
      const n = secp256k1N;
      const a1 = BigInt("0x3086d221a7d46bcde86c90e49284eb15");
      const b1 = -_1n$1 * BigInt("0xe4437ed6010e88286f547fa90abfe4c3");
      const a2 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8");
      const b2 = a1;
      const POW_2_128 = BigInt("0x100000000000000000000000000000000");
      const c1 = divNearest3(b2 * k, n);
      const c2 = divNearest3(-b1 * k, n);
      let k1 = mod3(k - c1 * a1 - c2 * a2, n);
      let k2 = mod3(-c1 * b1 - c2 * b2, n);
      const k1neg = k1 > POW_2_128;
      const k2neg = k2 > POW_2_128;
      if (k1neg) k1 = n - k1;
      if (k2neg) k2 = n - k2;
      if (k1 > POW_2_128 || k2 > POW_2_128) {
        throw new Error("splitScalar: Endomorphism failed, k=" + k);
      }
      return {
        k1neg,
        k1,
        k2neg,
        k2
      };
    }
  }
}, sha256$3);
BigInt(0);
secp256k13.ProjectivePoint;
function generatePrivateKey2() {
  return toHex2(secp256k13.utils.randomPrivateKey());
}
function toAccount(source) {
  if (typeof source === "string") {
    if (!isAddress2(source, {
      strict: false
    })) throw new InvalidAddressError2({
      address: source
    });
    return {
      address: source,
      type: "json-rpc"
    };
  }
  if (!isAddress2(source.address, {
    strict: false
  })) throw new InvalidAddressError2({
    address: source.address
  });
  return {
    address: source.address,
    nonceManager: source.nonceManager,
    sign: source.sign,
    experimental_signAuthorization: source.experimental_signAuthorization,
    signMessage: source.signMessage,
    signTransaction: source.signTransaction,
    signTypedData: source.signTypedData,
    source: "custom",
    type: "local"
  };
}
function serializeSignature2(_ref) {
  let {
    r,
    s,
    to = "hex",
    v,
    yParity
  } = _ref;
  const yParity_ = (() => {
    if (yParity === 0 || yParity === 1) return yParity;
    if (v && (v === 27n || v === 28n || v >= 35n)) return v % 2n === 0n ? 1 : 0;
    throw new Error("Invalid `v` or `yParity` value");
  })();
  const signature2 = `0x${new secp256k13.Signature(hexToBigInt2(r), hexToBigInt2(s)).toCompactHex()}${yParity_ === 0 ? "1b" : "1c"}`;
  if (to === "hex") return signature2;
  return hexToBytes$1(signature2);
}
async function sign$1(_ref) {
  let {
    hash: hash3,
    privateKey,
    to = "object"
  } = _ref;
  const {
    r,
    s,
    recovery
  } = secp256k13.sign(hash3.slice(2), privateKey.slice(2));
  const signature2 = {
    r: numberToHex2(r, {
      size: 32
    }),
    s: numberToHex2(s, {
      size: 32
    }),
    v: recovery ? 28n : 27n,
    yParity: recovery
  };
  return (() => {
    if (to === "bytes" || to === "hex") return serializeSignature2({
      ...signature2,
      to
    });
    return signature2;
  })();
}
async function experimental_signAuthorization(parameters) {
  const {
    contractAddress,
    chainId,
    nonce,
    privateKey,
    to = "object"
  } = parameters;
  const signature2 = await sign$1({
    hash: hashAuthorization2({
      contractAddress,
      chainId,
      nonce
    }),
    privateKey,
    to
  });
  if (to === "object") return {
    contractAddress,
    chainId,
    nonce,
    ...signature2
  };
  return signature2;
}
var presignMessagePrefix2 = "Ethereum Signed Message:\n";
function toPrefixedMessage2(message_) {
  const message = (() => {
    if (typeof message_ === "string") return stringToHex2(message_);
    if (typeof message_.raw === "string") return message_.raw;
    return bytesToHex$2(message_.raw);
  })();
  const prefix = stringToHex2(`${presignMessagePrefix2}${size3(message)}`);
  return concat2([prefix, message]);
}
function hashMessage2(message, to_) {
  return keccak2562(toPrefixedMessage2(message), to_);
}
async function signMessage$1(_ref) {
  let {
    message,
    privateKey
  } = _ref;
  return await sign$1({
    hash: hashMessage2(message),
    privateKey,
    to: "hex"
  });
}
async function signTransaction2(parameters) {
  const {
    privateKey,
    transaction,
    serializer = serializeTransaction2
  } = parameters;
  const signableTransaction = (() => {
    if (transaction.type === "eip4844") return {
      ...transaction,
      sidecars: false
    };
    return transaction;
  })();
  const signature2 = await sign$1({
    hash: keccak2562(serializer(signableTransaction)),
    privateKey
  });
  return serializer(transaction, signature2);
}
var bytesRegex2 = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/;
var integerRegex2 = /^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;
function serializeTypedData2(parameters) {
  const {
    domain: domain_,
    message: message_,
    primaryType,
    types
  } = parameters;
  const normalizeData = (struct52, data_) => {
    const data = {
      ...data_
    };
    for (const param of struct52) {
      const {
        name,
        type: type3
      } = param;
      if (type3 === "address") data[name] = data[name].toLowerCase();
    }
    return data;
  };
  const domain = (() => {
    if (!types.EIP712Domain) return {};
    if (!domain_) return {};
    return normalizeData(types.EIP712Domain, domain_);
  })();
  const message = (() => {
    if (primaryType === "EIP712Domain") return void 0;
    return normalizeData(types[primaryType], message_);
  })();
  return stringify3({
    domain,
    message,
    primaryType,
    types
  });
}
function validateTypedData2(parameters) {
  const {
    domain,
    message,
    primaryType,
    types
  } = parameters;
  const validateData = (struct52, data) => {
    for (const param of struct52) {
      const {
        name,
        type: type3
      } = param;
      const value = data[name];
      const integerMatch = type3.match(integerRegex2);
      if (integerMatch && (typeof value === "number" || typeof value === "bigint")) {
        const [_type, base3, size_] = integerMatch;
        numberToHex2(value, {
          signed: base3 === "int",
          size: Number.parseInt(size_) / 8
        });
      }
      if (type3 === "address" && typeof value === "string" && !isAddress2(value)) throw new InvalidAddressError2({
        address: value
      });
      const bytesMatch = type3.match(bytesRegex2);
      if (bytesMatch) {
        const [_type, size_] = bytesMatch;
        if (size_ && size3(value) !== Number.parseInt(size_)) throw new BytesSizeMismatchError2({
          expectedSize: Number.parseInt(size_),
          givenSize: size3(value)
        });
      }
      const struct53 = types[type3];
      if (struct53) validateData(struct53, value);
    }
  };
  if (types.EIP712Domain && domain) validateData(types.EIP712Domain, domain);
  if (primaryType !== "EIP712Domain") validateData(types[primaryType], message);
}
function getTypesForEIP712Domain2(_ref) {
  let {
    domain
  } = _ref;
  return [typeof (domain === null || domain === void 0 ? void 0 : domain.name) === "string" && {
    name: "name",
    type: "string"
  }, (domain === null || domain === void 0 ? void 0 : domain.version) && {
    name: "version",
    type: "string"
  }, typeof (domain === null || domain === void 0 ? void 0 : domain.chainId) === "number" && {
    name: "chainId",
    type: "uint256"
  }, (domain === null || domain === void 0 ? void 0 : domain.verifyingContract) && {
    name: "verifyingContract",
    type: "address"
  }, (domain === null || domain === void 0 ? void 0 : domain.salt) && {
    name: "salt",
    type: "bytes32"
  }].filter(Boolean);
}
function hashTypedData2(parameters) {
  const {
    domain = {},
    message,
    primaryType
  } = parameters;
  const types = {
    EIP712Domain: getTypesForEIP712Domain2({
      domain
    }),
    ...parameters.types
  };
  validateTypedData2({
    domain,
    message,
    primaryType,
    types
  });
  const parts = ["0x1901"];
  if (domain) parts.push(hashDomain2({
    domain,
    types
  }));
  if (primaryType !== "EIP712Domain") parts.push(hashStruct2({
    data: message,
    primaryType,
    types
  }));
  return keccak2562(concat2(parts));
}
function hashDomain2(_ref) {
  let {
    domain,
    types
  } = _ref;
  return hashStruct2({
    data: domain,
    primaryType: "EIP712Domain",
    types
  });
}
function hashStruct2(_ref2) {
  let {
    data,
    primaryType,
    types
  } = _ref2;
  const encoded = encodeData3({
    data,
    primaryType,
    types
  });
  return keccak2562(encoded);
}
function encodeData3(_ref3) {
  let {
    data,
    primaryType,
    types
  } = _ref3;
  const encodedTypes = [{
    type: "bytes32"
  }];
  const encodedValues = [hashType2({
    primaryType,
    types
  })];
  for (const field of types[primaryType]) {
    const [type3, value] = encodeField2({
      types,
      name: field.name,
      type: field.type,
      value: data[field.name]
    });
    encodedTypes.push(type3);
    encodedValues.push(value);
  }
  return encodeAbiParameters2(encodedTypes, encodedValues);
}
function hashType2(_ref4) {
  let {
    primaryType,
    types
  } = _ref4;
  const encodedHashType = toHex2(encodeType2({
    primaryType,
    types
  }));
  return keccak2562(encodedHashType);
}
function encodeType2(_ref5) {
  let {
    primaryType,
    types
  } = _ref5;
  let result = "";
  const unsortedDeps = findTypeDependencies2({
    primaryType,
    types
  });
  unsortedDeps.delete(primaryType);
  const deps = [primaryType, ...Array.from(unsortedDeps).sort()];
  for (const type3 of deps) {
    result += `${type3}(${types[type3].map((_ref6) => {
      let {
        name,
        type: t
      } = _ref6;
      return `${t} ${name}`;
    }).join(",")})`;
  }
  return result;
}
function findTypeDependencies2(_ref7) {
  let {
    primaryType: primaryType_,
    types
  } = _ref7;
  let results = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : /* @__PURE__ */ new Set();
  const match = primaryType_.match(/^\w*/u);
  const primaryType = match === null || match === void 0 ? void 0 : match[0];
  if (results.has(primaryType) || types[primaryType] === void 0) {
    return results;
  }
  results.add(primaryType);
  for (const field of types[primaryType]) {
    findTypeDependencies2({
      primaryType: field.type,
      types
    }, results);
  }
  return results;
}
function encodeField2(_ref8) {
  let {
    types,
    name,
    type: type3,
    value
  } = _ref8;
  if (types[type3] !== void 0) {
    return [{
      type: "bytes32"
    }, keccak2562(encodeData3({
      data: value,
      primaryType: type3,
      types
    }))];
  }
  if (type3 === "bytes") {
    const prepend = value.length % 2 ? "0" : "";
    value = `0x${prepend + value.slice(2)}`;
    return [{
      type: "bytes32"
    }, keccak2562(value)];
  }
  if (type3 === "string") return [{
    type: "bytes32"
  }, keccak2562(toHex2(value))];
  if (type3.lastIndexOf("]") === type3.length - 1) {
    const parsedType = type3.slice(0, type3.lastIndexOf("["));
    const typeValuePairs = value.map((item) => encodeField2({
      name,
      type: parsedType,
      types,
      value: item
    }));
    return [{
      type: "bytes32"
    }, keccak2562(encodeAbiParameters2(typeValuePairs.map((_ref9) => {
      let [t] = _ref9;
      return t;
    }), typeValuePairs.map((_ref0) => {
      let [, v] = _ref0;
      return v;
    })))];
  }
  return [{
    type: type3
  }, value];
}
async function signTypedData$1(parameters) {
  const {
    privateKey,
    ...typedData
  } = parameters;
  return await sign$1({
    hash: hashTypedData2(typedData),
    privateKey,
    to: "hex"
  });
}
function privateKeyToAccount(privateKey) {
  let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const {
    nonceManager: nonceManager2
  } = options;
  const publicKey5 = toHex2(secp256k13.getPublicKey(privateKey.slice(2), false));
  const address = publicKeyToAddress2(publicKey5);
  const account = toAccount({
    address,
    nonceManager: nonceManager2,
    async sign(_ref) {
      let {
        hash: hash3
      } = _ref;
      return sign$1({
        hash: hash3,
        privateKey,
        to: "hex"
      });
    },
    async experimental_signAuthorization(authorization) {
      return experimental_signAuthorization({
        ...authorization,
        privateKey
      });
    },
    async signMessage(_ref2) {
      let {
        message
      } = _ref2;
      return signMessage$1({
        message,
        privateKey
      });
    },
    async signTransaction(transaction) {
      let {
        serializer
      } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      return signTransaction2({
        privateKey,
        transaction,
        serializer
      });
    },
    async signTypedData(typedData) {
      return signTypedData$1({
        ...typedData,
        privateKey
      });
    }
  });
  return {
    ...account,
    publicKey: publicKey5,
    source: "privateKey"
  };
}
function privateKeyToAddress(privateKey) {
  const publicKey5 = bytesToHex$2(secp256k13.getPublicKey(privateKey.slice(2), false));
  return publicKeyToAddress2(publicKey5);
}
var fetch$1 = (input, init) => (0, import_cross_fetch.default)(input, {
  ...init !== null && init !== void 0 ? init : {},
  credentials: "credentials" in Request.prototype ? init === null || init === void 0 ? void 0 : init.credentials : void 0
});
var ChallengeId;
(function(ChallengeId2) {
  ChallengeId2["TRACK_UPLOADS"] = "u";
  ChallengeId2["REFERRALS"] = "r";
  ChallengeId2["VERIFIED_REFERRALS"] = "rv";
  ChallengeId2["REFERRED"] = "rd";
  ChallengeId2["MOBILE_INSTALL"] = "m";
  ChallengeId2["CONNECT_VERIFIED_ACCOUNT"] = "v";
  ChallengeId2["LISTEN_STREAK_ENDLESS"] = "e";
  ChallengeId2["COMPLETE_PROFILE"] = "p";
  ChallengeId2["SEND_FIRST_TIP"] = "ft";
  ChallengeId2["CREATE_FIRST_PLAYLIST"] = "fp";
  ChallengeId2["AUDIO_MATCHING_BUYER"] = "b";
  ChallengeId2["AUDIO_MATCHING_SELLER"] = "s";
  ChallengeId2["TRENDING_TRACK"] = "tt";
  ChallengeId2["TRENDING_PLAYLIST"] = "tp";
  ChallengeId2["TRENDING_UNDERGROUND_TRACK"] = "tut";
  ChallengeId2["ONE_SHOT"] = "o";
  ChallengeId2["FIRST_WEEKLY_COMMENT"] = "c";
  ChallengeId2["PLAY_COUNT_250_MILESTONE_2025"] = "p1";
  ChallengeId2["PLAY_COUNT_1000_MILESTONE_2025"] = "p2";
  ChallengeId2["PLAY_COUNT_10000_MILESTONE_2025"] = "p3";
  ChallengeId2["TASTEMAKER"] = "t";
  ChallengeId2["COSIGN"] = "cs";
  ChallengeId2["PINNED_COMMENT"] = "cp";
  ChallengeId2["REMIX_CONTEST_WINNER"] = "w";
})(ChallengeId || (ChallengeId = {}));
var GetAttestationSchema = z.object({
  /** The user's handle. */
  handle: z.string(),
  /** The challenge identifier. As in, the challenge "name." */
  challengeId: z.nativeEnum(ChallengeId),
  /**
   * Identifier for the completed challenge instance.
   *
   * @see {@link ChallengesApi.generateSpecifier}
   */
  specifier: z.string(),
  /** The amount being claimed, in decimal wAUDIO. */
  amount: z.number()
});
var AntiAbuseOracle = class extends BaseAPI$1 {
  constructor(_ref) {
    let {
      antiAbuseOracleSelector
    } = _ref;
    super(new Configuration$1({
      basePath: "",
      fetchApi: fetch$1,
      middleware: [antiAbuseOracleSelector.createMiddleware()]
    }));
    _defineProperty$1(this, "antiAbuseOracleSelector", void 0);
    this.antiAbuseOracleSelector = antiAbuseOracleSelector;
  }
  async getWalletAddress() {
    const selected = await this.antiAbuseOracleSelector.getSelectedService();
    return selected.wallet;
  }
  async getChallengeAttestation(params, initOverrides) {
    const response = await this.getChallengeAttestationRaw(params, initOverrides);
    return await response.value();
  }
  async getChallengeAttestationRaw(params, initOverrides) {
    const {
      handle,
      challengeId,
      specifier,
      amount
    } = await parseParams("getChallengeAttestation", GetAttestationSchema)(params);
    const response = await this.request({
      path: `/attestation/${handle}`,
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: {
        challengeId,
        challengeSpecifier: specifier,
        amount
      }
    }, initOverrides);
    return new JSONApiResponse$1(response, (json) => ({
      result: exists$2(json, "result") ? json.result : false,
      errorCode: exists$2(json, "errorCode") ? json.errorCode : void 0
    }));
  }
};
var getPathFromUrl = (url) => {
  const pathRegex = /^([a-z]+:\/\/)?(?:www\.)?([^/]+)?(.*)$/;
  const match = url.match(pathRegex);
  if (match !== null && match !== void 0 && match[3]) {
    const path = match[3];
    return path;
  } else {
    throw new Error(`Invalid URL, couldn't get path.`);
  }
};
var promiseAny = async (iterable) => {
  if (Promise.any) {
    return Promise.any(iterable);
  }
  return await Promise.all([...iterable].map(async (promise) => await new Promise((resolve2, reject2) => {
    Promise.resolve(promise).then(reject2, resolve2);
  }))).then(async (errors2) => await Promise.reject(errors2), async (value) => await Promise.resolve(value));
};
var getDefaultAntiAbuseOracleSelectorConfig = (config) => ({
  registeredAddresses: config.network.antiAbuseOracleNodes.registeredAddresses,
  endpoints: config.network.antiAbuseOracleNodes.endpoints,
  logger: new Logger()
});
var AntiAbuseOracleSelector = class {
  constructor(config) {
    _defineProperty$1(this, "endpoints", void 0);
    _defineProperty$1(this, "registeredAddresses", void 0);
    _defineProperty$1(this, "logger", void 0);
    _defineProperty$1(this, "selectedNode", null);
    const configWithDefaults = mergeConfigWithDefaults(config, getDefaultAntiAbuseOracleSelectorConfig(productionConfig));
    this.endpoints = configWithDefaults.endpoints;
    this.registeredAddresses = configWithDefaults.registeredAddresses;
    this.logger = configWithDefaults.logger;
  }
  createMiddleware() {
    return {
      pre: async (context) => {
        let url = context.url;
        if (!url.startsWith("http")) {
          const service = await this.getSelectedService();
          url = `${service.endpoint}${context.url}`;
        }
        return {
          url,
          init: context.init
        };
      },
      onError: async (context) => {
        const path = getPathFromUrl(context.url);
        this.selectedNode = null;
        const newService = await this.getSelectedService();
        return context.fetch(`${newService.endpoint}${path}`, context.init);
      }
    };
  }
  /**
   * Gets the currently selected Anti Abuse Oracle.
   * @throws if no service is available.
   */
  async getSelectedService() {
    if (!this.selectedNode) {
      this.selectedNode = await this.select();
    }
    return this.selectedNode;
  }
  /**
   * Races the configured endpoints for the fastest healthy registered service.
   * @throws if no services available.
   */
  async select() {
    try {
      return await promiseAny(this.endpoints.map(async (endpoint2) => {
        try {
          return await this.getNode(endpoint2);
        } catch (e) {
          this.logger.warn(`Anti Abuse Oracle ${endpoint2} is unhealthy: ${e}`);
          throw e;
        }
      }));
    } catch (e) {
      throw new Error("All Anti Abuse Oracles are unhealthy");
    }
  }
  /**
   * Fetches the healthcheck for the given endpoint, and checks that the wallet
   * is a registered Anti Abuse Oracle wallet.
   * @returns the node wallet and endpoint if healthy
   */
  async getNode(endpoint2) {
    const response = await fetch$1(`${endpoint2}/health_check`);
    if (response.ok) {
      var _json$walletPubkey;
      const json = await response.json();
      const wallet = (_json$walletPubkey = json.walletPubkey) !== null && _json$walletPubkey !== void 0 ? _json$walletPubkey : json.antiAbuseWalletPubkey;
      if (!this.registeredAddresses.includes(wallet)) {
        throw new Error(`Not registered: ${wallet}`);
      }
      return {
        wallet,
        endpoint: endpoint2
      };
    } else {
      throw new Error(`Response failed with status ${response.status}`);
    }
  }
};
var ArchiverService = class extends BaseAPI$1 {
  async createStemsArchive(_ref) {
    let {
      trackId,
      userId,
      includeParent
    } = _ref;
    const response = await this.request({
      method: "POST",
      path: `/stems/${trackId}`,
      query: {
        user_id: userId,
        include_parent: !!includeParent
      },
      headers: {}
    });
    return new JSONApiResponse$1(response).value();
  }
  async getStemsArchiveJobStatus(_ref2) {
    let {
      jobId
    } = _ref2;
    const response = await this.request({
      method: "GET",
      path: `/stems/job/${jobId}`,
      headers: {}
    });
    return new JSONApiResponse$1(response).value();
  }
  async cancelStemsArchiveJob(_ref3) {
    let {
      jobId
    } = _ref3;
    const response = await this.request({
      method: "DELETE",
      path: `/stems/job/${jobId}`,
      headers: {}
    });
    return new JSONApiResponse$1(response).value();
  }
};
async function getAddresses2(client) {
  var _client$account;
  if (((_client$account = client.account) === null || _client$account === void 0 ? void 0 : _client$account.type) === "local") return [client.account.address];
  const addresses = await client.request({
    method: "eth_accounts"
  }, {
    dedupe: true
  });
  return addresses.map((address) => checksumAddress2(address));
}
async function signMessage2(client, _ref) {
  let {
    account: account_ = client.account,
    message
  } = _ref;
  if (!account_) throw new AccountNotFoundError2({
    docsPath: "/docs/actions/wallet/signMessage"
  });
  const account = parseAccount2(account_);
  if (account.signMessage) return account.signMessage({
    message
  });
  const message_ = (() => {
    if (typeof message === "string") return stringToHex2(message);
    if (message.raw instanceof Uint8Array) return toHex2(message.raw);
    return message.raw;
  })();
  return client.request({
    method: "personal_sign",
    params: [message_, account.address]
  }, {
    retryCount: 0
  });
}
async function signTypedData2(client, parameters) {
  const {
    account: account_ = client.account,
    domain,
    message,
    primaryType
  } = parameters;
  if (!account_) throw new AccountNotFoundError2({
    docsPath: "/docs/actions/wallet/signTypedData"
  });
  const account = parseAccount2(account_);
  const types = {
    EIP712Domain: getTypesForEIP712Domain2({
      domain
    }),
    ...parameters.types
  };
  validateTypedData2({
    domain,
    message,
    primaryType,
    types
  });
  if (account.signTypedData) return account.signTypedData({
    domain,
    message,
    primaryType,
    types
  });
  const typedData = serializeTypedData2({
    domain,
    message,
    primaryType,
    types
  });
  return client.request({
    method: "eth_signTypedData_v4",
    params: [account.address, typedData]
  }, {
    retryCount: 0
  });
}
async function getSharedSecret2(client, _ref) {
  let {
    account: account_ = client.account,
    publicKey: publicKey5
  } = _ref;
  if (!account_) throw new Error("Account not found");
  const account = typeof account_ === "string" ? {
    address: account_,
    type: "json-rpc"
  } : account_;
  if ("getSharedSecret" in account && account.getSharedSecret) {
    return account.getSharedSecret(publicKey5);
  }
  throw new Error(`Account type '${account.type}' does not implement 'getSharedSecret' method.`);
}
async function sign3(client, _ref) {
  let {
    account: account_ = client.account,
    message: message_
  } = _ref;
  if (!account_) throw new Error("Account not found");
  const account = typeof account_ === "string" ? {
    address: account_,
    type: "json-rpc"
  } : account_;
  const message = (() => {
    if (typeof message_ === "string") return stringToHex2(message_);
    if (message_.raw instanceof Uint8Array) return toHex2(message_.raw);
    return message_.raw;
  })();
  if ("signRaw" in account && account.signRaw) {
    return account.signRaw(message);
  }
  throw new Error(`Account type '${account.type}' does not implement 'sign' method.`);
}
var localTransport = () => {
  const request = async (_ref) => {
    let {
      method,
      params
    } = _ref;
    console.error("Local transport in use. RPC methods are not implemented.", {
      method,
      params
    });
    throw new Error(`Method '${method}' not implemented on local transport.`);
  };
  return {
    request
  };
};
function number4(n) {
  if (!Number.isSafeInteger(n) || n < 0) throw new Error(`Wrong positive integer: ${n}`);
}
function bool3(b) {
  if (typeof b !== "boolean") throw new Error(`Expected boolean, not ${b}`);
}
function bytes2(b) {
  if (!(b instanceof Uint8Array)) throw new TypeError("Expected Uint8Array");
  for (var _len = arguments.length, lengths = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    lengths[_key - 1] = arguments[_key];
  }
  if (lengths.length > 0 && !lengths.includes(b.length)) throw new TypeError(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);
}
function hash2(hash3) {
  if (typeof hash3 !== "function" || typeof hash3.create !== "function") throw new Error("Hash should be wrapped by utils.wrapConstructor");
  number4(hash3.outputLen);
  number4(hash3.blockLen);
}
function exists$1(instance2) {
  let checkFinished = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
  if (instance2.destroyed) throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance2.finished) throw new Error("Hash#digest() has already been called");
}
function output3(out, instance2) {
  bytes2(out);
  const min = instance2.outputLen;
  if (out.length < min) {
    throw new Error(`digestInto() expects output buffer of length at least ${min}`);
  }
}
var assert4 = {
  number: number4,
  bool: bool3,
  bytes: bytes2,
  hash: hash2,
  exists: exists$1,
  output: output3
};
var U32_MASK645 = BigInt(2 ** 32 - 1);
var _32n5 = BigInt(32);
function fromBig5(n) {
  let le = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  if (le) return {
    h: Number(n & U32_MASK645),
    l: Number(n >> _32n5 & U32_MASK645)
  };
  return {
    h: Number(n >> _32n5 & U32_MASK645) | 0,
    l: Number(n & U32_MASK645) | 0
  };
}
function split5(lst) {
  let le = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  let Ah = new Uint32Array(lst.length);
  let Al = new Uint32Array(lst.length);
  for (let i = 0; i < lst.length; i++) {
    const {
      h,
      l
    } = fromBig5(lst[i], le);
    [Ah[i], Al[i]] = [h, l];
  }
  return [Ah, Al];
}
var toBig = (h, l) => BigInt(h >>> 0) << _32n5 | BigInt(l >>> 0);
var shrSH4 = (h, l, s) => h >>> s;
var shrSL4 = (h, l, s) => h << 32 - s | l >>> s;
var rotrSH4 = (h, l, s) => h >>> s | l << 32 - s;
var rotrSL4 = (h, l, s) => h << 32 - s | l >>> s;
var rotrBH4 = (h, l, s) => h << 64 - s | l >>> s - 32;
var rotrBL4 = (h, l, s) => h >>> s - 32 | l << 64 - s;
var rotr32H = (h, l) => l;
var rotr32L = (h, l) => h;
var rotlSH3 = (h, l, s) => h << s | l >>> 32 - s;
var rotlSL3 = (h, l, s) => l << s | h >>> 32 - s;
var rotlBH3 = (h, l, s) => l << s - 32 | h >>> 64 - s;
var rotlBL3 = (h, l, s) => h << s - 32 | l >>> 64 - s;
function add4(Ah, Al, Bh, Bl) {
  const l = (Al >>> 0) + (Bl >>> 0);
  return {
    h: Ah + Bh + (l / 2 ** 32 | 0) | 0,
    l: l | 0
  };
}
var add3L4 = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
var add3H4 = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
var add4L4 = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
var add4H4 = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
var add5L4 = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
var add5H4 = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
var u645 = {
  fromBig: fromBig5,
  split: split5,
  toBig,
  shrSH: shrSH4,
  shrSL: shrSL4,
  rotrSH: rotrSH4,
  rotrSL: rotrSL4,
  rotrBH: rotrBH4,
  rotrBL: rotrBL4,
  rotr32H,
  rotr32L,
  rotlSH: rotlSH3,
  rotlSL: rotlSL3,
  rotlBH: rotlBH3,
  rotlBL: rotlBL3,
  add: add4,
  add3L: add3L4,
  add3H: add3H4,
  add4L: add4L4,
  add4H: add4H4,
  add5H: add5H4,
  add5L: add5L4
};
var crypto$1 = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
var u329 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
var createView5 = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
var rotr5 = (word, shift) => word << 32 - shift | word >>> shift;
var isLE5 = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!isLE5) throw new Error("Non little-endian hardware is not supported");
var hexes6 = Array.from({
  length: 256
}, (v, i) => i.toString(16).padStart(2, "0"));
function bytesToHex4(uint8a) {
  if (!(uint8a instanceof Uint8Array)) throw new Error("Uint8Array expected");
  let hex3 = "";
  for (let i = 0; i < uint8a.length; i++) {
    hex3 += hexes6[uint8a[i]];
  }
  return hex3;
}
function utf8ToBytes5(str2) {
  if (typeof str2 !== "string") {
    throw new TypeError(`utf8ToBytes expected string, got ${typeof str2}`);
  }
  return new TextEncoder().encode(str2);
}
function toBytes7(data) {
  if (typeof data === "string") data = utf8ToBytes5(data);
  if (!(data instanceof Uint8Array)) throw new TypeError(`Expected input type is Uint8Array (got ${typeof data})`);
  return data;
}
var Hash6 = class {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
};
function wrapConstructor3(hashConstructor) {
  const hashC = (message) => hashConstructor().update(toBytes7(message)).digest();
  const tmp = hashConstructor();
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = () => hashConstructor();
  return hashC;
}
function wrapConstructorWithOpts(hashCons) {
  const hashC = (msg, opts) => hashCons(opts).update(toBytes7(msg)).digest();
  const tmp = hashCons({});
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = (opts) => hashCons(opts);
  return hashC;
}
function randomBytes2() {
  let bytesLength = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 32;
  if (crypto$1 && typeof crypto$1.getRandomValues === "function") {
    return crypto$1.getRandomValues(new Uint8Array(bytesLength));
  }
  throw new Error("crypto.getRandomValues must be defined");
}
var [SHA3_PI3, SHA3_ROTL3, _SHA3_IOTA3] = [[], [], []];
var _0n12 = BigInt(0);
var _1n12 = BigInt(1);
var _2n10 = BigInt(2);
var _7n4 = BigInt(7);
var _256n3 = BigInt(256);
var _0x71n3 = BigInt(113);
for (let round = 0, R = _1n12, x = 1, y = 0; round < 24; round++) {
  [x, y] = [y, (2 * x + 3 * y) % 5];
  SHA3_PI3.push(2 * (5 * y + x));
  SHA3_ROTL3.push((round + 1) * (round + 2) / 2 % 64);
  let t = _0n12;
  for (let j = 0; j < 7; j++) {
    R = (R << _1n12 ^ (R >> _7n4) * _0x71n3) % _256n3;
    if (R & _2n10) t ^= _1n12 << (_1n12 << BigInt(j)) - _1n12;
  }
  _SHA3_IOTA3.push(t);
}
var [SHA3_IOTA_H3, SHA3_IOTA_L3] = u645.split(_SHA3_IOTA3, true);
var rotlH3 = (h, l, s) => s > 32 ? u645.rotlBH(h, l, s) : u645.rotlSH(h, l, s);
var rotlL3 = (h, l, s) => s > 32 ? u645.rotlBL(h, l, s) : u645.rotlSL(h, l, s);
function keccakP3(s) {
  let rounds = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 24;
  const B = new Uint32Array(5 * 2);
  for (let round = 24 - rounds; round < 24; round++) {
    for (let x = 0; x < 10; x++) B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
    for (let x = 0; x < 10; x += 2) {
      const idx1 = (x + 8) % 10;
      const idx0 = (x + 2) % 10;
      const B0 = B[idx0];
      const B1 = B[idx0 + 1];
      const Th = rotlH3(B0, B1, 1) ^ B[idx1];
      const Tl = rotlL3(B0, B1, 1) ^ B[idx1 + 1];
      for (let y = 0; y < 50; y += 10) {
        s[x + y] ^= Th;
        s[x + y + 1] ^= Tl;
      }
    }
    let curH = s[2];
    let curL = s[3];
    for (let t = 0; t < 24; t++) {
      const shift = SHA3_ROTL3[t];
      const Th = rotlH3(curH, curL, shift);
      const Tl = rotlL3(curH, curL, shift);
      const PI = SHA3_PI3[t];
      curH = s[PI];
      curL = s[PI + 1];
      s[PI] = Th;
      s[PI + 1] = Tl;
    }
    for (let y = 0; y < 50; y += 10) {
      for (let x = 0; x < 10; x++) B[x] = s[y + x];
      for (let x = 0; x < 10; x++) s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
    }
    s[0] ^= SHA3_IOTA_H3[round];
    s[1] ^= SHA3_IOTA_L3[round];
  }
  B.fill(0);
}
var Keccak3 = class _Keccak extends Hash6 {
  // NOTE: we accept arguments in bytes instead of bits here.
  constructor(blockLen, suffix, outputLen) {
    let enableXOF = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
    let rounds = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 24;
    super();
    this.blockLen = blockLen;
    this.suffix = suffix;
    this.outputLen = outputLen;
    this.enableXOF = enableXOF;
    this.rounds = rounds;
    this.pos = 0;
    this.posOut = 0;
    this.finished = false;
    this.destroyed = false;
    assert4.number(outputLen);
    if (0 >= this.blockLen || this.blockLen >= 200) throw new Error("Sha3 supports only keccak-f1600 function");
    this.state = new Uint8Array(200);
    this.state32 = u329(this.state);
  }
  keccak() {
    keccakP3(this.state32, this.rounds);
    this.posOut = 0;
    this.pos = 0;
  }
  update(data) {
    assert4.exists(this);
    const {
      blockLen,
      state
    } = this;
    data = toBytes7(data);
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      for (let i = 0; i < take; i++) state[this.pos++] ^= data[pos++];
      if (this.pos === blockLen) this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished) return;
    this.finished = true;
    const {
      state,
      suffix,
      pos,
      blockLen
    } = this;
    state[pos] ^= suffix;
    if ((suffix & 128) !== 0 && pos === blockLen - 1) this.keccak();
    state[blockLen - 1] ^= 128;
    this.keccak();
  }
  writeInto(out) {
    assert4.exists(this, false);
    assert4.bytes(out);
    this.finish();
    const bufferOut = this.state;
    const {
      blockLen
    } = this;
    for (let pos = 0, len = out.length; pos < len; ) {
      if (this.posOut >= blockLen) this.keccak();
      const take = Math.min(blockLen - this.posOut, len - pos);
      out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
      this.posOut += take;
      pos += take;
    }
    return out;
  }
  xofInto(out) {
    if (!this.enableXOF) throw new Error("XOF is not possible for this instance");
    return this.writeInto(out);
  }
  xof(bytes3) {
    assert4.number(bytes3);
    return this.xofInto(new Uint8Array(bytes3));
  }
  digestInto(out) {
    assert4.output(out, this);
    if (this.finished) throw new Error("digest() was already called");
    this.writeInto(out);
    this.destroy();
    return out;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = true;
    this.state.fill(0);
  }
  _cloneInto(to) {
    const {
      blockLen,
      suffix,
      outputLen,
      rounds,
      enableXOF
    } = this;
    to || (to = new _Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
    to.state32.set(this.state32);
    to.pos = this.pos;
    to.posOut = this.posOut;
    to.finished = this.finished;
    to.rounds = rounds;
    to.suffix = suffix;
    to.outputLen = outputLen;
    to.enableXOF = enableXOF;
    to.destroyed = this.destroyed;
    return to;
  }
};
var gen3 = (suffix, blockLen, outputLen) => wrapConstructor3(() => new Keccak3(blockLen, suffix, outputLen));
gen3(6, 144, 224 / 8);
gen3(6, 136, 256 / 8);
gen3(6, 104, 384 / 8);
gen3(6, 72, 512 / 8);
gen3(1, 144, 224 / 8);
var keccak_2563 = gen3(1, 136, 256 / 8);
gen3(1, 104, 384 / 8);
gen3(1, 72, 512 / 8);
var genShake3 = (suffix, blockLen, outputLen) => wrapConstructorWithOpts(function() {
  let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  return new Keccak3(blockLen, suffix, opts.dkLen === void 0 ? outputLen : opts.dkLen, true);
});
genShake3(31, 168, 128 / 8);
genShake3(31, 136, 256 / 8);
function privateKeyToAudiusAccount(privateKey) {
  const privateKeyAccount = privateKeyToAccount(privateKey);
  return {
    ...privateKeyAccount,
    source: "custom",
    getSharedSecret: async (publicKey5) => {
      return getSharedSecret(hexToBytes(privateKey), publicKey5, true);
    },
    signRaw: async (data) => {
      return sign2(keccak_2563(hexToBytes(data)), hexToBytes(privateKey), {
        recovered: true,
        der: false
      });
    }
  };
}
var HedgehogWalletNotFoundError = class extends Error {
  constructor() {
    super("Hedgehog wallet not found. Is the user logged in?");
  }
};
function createHedgehogWalletClient(hedgehog) {
  let account_;
  const getAccount2 = async () => {
    await hedgehog.waitUntilReady();
    const wallet = hedgehog.getWallet();
    if (!wallet) {
      throw new HedgehogWalletNotFoundError();
    }
    if (!account_ || account_.address !== wallet.getAddressString()) {
      account_ = privateKeyToAudiusAccount(wallet.getPrivateKeyString());
    }
    return account_;
  };
  const client = createClient({
    name: "hedgehog",
    type: "audius",
    transport: custom(localTransport())
  });
  getAccount2().then((account) => {
    client.account = account;
  }).catch((e) => {
    if (e instanceof HedgehogWalletNotFoundError) {
      return;
    }
    throw e;
  });
  return client.extend((client2) => ({
    getAddresses: async () => {
      client2.account = await getAccount2();
      return getAddresses2(client2);
    },
    sign: async (args) => {
      client2.account = await getAccount2();
      return sign3(client2, args);
    },
    signMessage: async (args) => {
      client2.account = await getAccount2();
      return signMessage2(client2, args);
    },
    signTypedData: async (args) => {
      client2.account = await getAccount2();
      return signTypedData2(client2, args);
    },
    getSharedSecret: async (args) => {
      client2.account = await getAccount2();
      return getSharedSecret2(client2, args);
    }
  }));
}
function audiusWalletActions(client) {
  return {
    getAddresses: async () => getAddresses2(client),
    sign: (args) => sign3(client, args),
    signMessage: (args) => signMessage2(client, args),
    signTypedData: (args) => signTypedData2(client, args),
    getSharedSecret: (args) => getSharedSecret2(client, args)
  };
}
var ensureHex = (str2) => str2.startsWith("0x") ? str2 : `0x${str2}`;
var createAppWalletClient = (_ref) => {
  let {
    apiKey: apiKey2,
    apiSecret
  } = _ref;
  if (apiSecret) {
    return createClient({
      name: "Audius App",
      type: "audius",
      account: privateKeyToAudiusAccount(ensureHex(apiSecret)),
      transport: custom(localTransport())
    }).extend(audiusWalletActions);
  } else {
    return createClient({
      name: "Audius Readonly App",
      type: "audius",
      account: {
        address: ensureHex(apiKey2),
        type: "local"
      },
      transport: custom(localTransport())
    }).extend(audiusWalletActions);
  }
};
var getNonce = async () => {
  return "0x" + bytesToHex4(randomBytes2(32));
};
var abi13 = [{
  constant: true,
  inputs: [{
    name: "",
    type: "bytes32"
  }],
  name: "usedSignatures",
  outputs: [{
    name: "",
    type: "bool"
  }],
  payable: false,
  stateMutability: "view",
  type: "function"
}, {
  anonymous: false,
  inputs: [{
    indexed: false,
    name: "_userId",
    type: "uint256"
  }, {
    indexed: false,
    name: "_signer",
    type: "address"
  }, {
    indexed: false,
    name: "_entityType",
    type: "string"
  }, {
    indexed: false,
    name: "_entityId",
    type: "uint256"
  }, {
    indexed: false,
    name: "_metadata",
    type: "string"
  }, {
    indexed: false,
    name: "_action",
    type: "string"
  }],
  name: "ManageEntity",
  type: "event"
}, {
  anonymous: false,
  inputs: [{
    indexed: false,
    name: "_userId",
    type: "uint256"
  }, {
    indexed: false,
    name: "_isVerified",
    type: "bool"
  }],
  name: "ManageIsVerified",
  type: "event"
}, {
  constant: false,
  inputs: [{
    name: "name",
    type: "string"
  }, {
    name: "version",
    type: "string"
  }, {
    name: "chainId",
    type: "uint256"
  }],
  name: "initialize",
  outputs: [],
  payable: false,
  stateMutability: "nonpayable",
  type: "function"
}, {
  constant: false,
  inputs: [{
    name: "_verifierAddress",
    type: "address"
  }, {
    name: "_networkId",
    type: "uint256"
  }],
  name: "initialize",
  outputs: [],
  payable: false,
  stateMutability: "nonpayable",
  type: "function"
}, {
  constant: false,
  inputs: [{
    name: "_userId",
    type: "uint256"
  }, {
    name: "_entityType",
    type: "string"
  }, {
    name: "_entityId",
    type: "uint256"
  }, {
    name: "_action",
    type: "string"
  }, {
    name: "_metadata",
    type: "string"
  }, {
    name: "_nonce",
    type: "bytes32"
  }, {
    name: "_subjectSig",
    type: "bytes"
  }],
  name: "manageEntity",
  outputs: [],
  payable: false,
  stateMutability: "nonpayable",
  type: "function"
}, {
  constant: false,
  inputs: [{
    name: "_userId",
    type: "uint256"
  }, {
    name: "_isVerified",
    type: "bool"
  }],
  name: "manageIsVerified",
  outputs: [],
  payable: false,
  stateMutability: "nonpayable",
  type: "function"
}];
var EntityManager = class {
};
_defineProperty$1(EntityManager, "abi", abi13);
_defineProperty$1(EntityManager, "types", {
  EIP712Domain: [{
    name: "name",
    type: "string"
  }, {
    name: "version",
    type: "string"
  }, {
    name: "chainId",
    type: "uint256"
  }, {
    name: "verifyingContract",
    type: "address"
  }],
  // NOTE: Need to update "uint" to "uint32" ("uint" isn't a thing).
  // Can't do so now because would break signature recovery on relay
  // and in indexing.
  ManageEntity: [{
    name: "userId",
    type: "uint"
  }, {
    name: "entityType",
    type: "string"
  }, {
    name: "entityId",
    type: "uint"
  }, {
    name: "action",
    type: "string"
  }, {
    name: "metadata",
    type: "string"
  }, {
    name: "nonce",
    type: "bytes32"
  }]
});
var getDefaultEntityManagerConfig = (config) => ({
  contractAddress: config.acdc.entityManagerContractAddress,
  chainId: config.acdc.chainId,
  endpoint: config.network.apiEndpoint,
  logger: new Logger()
});
var DEFAULT_GAS_LIMIT = 2e6;
var CONFIRMATION_POLLING_INTERVAL = 2e3;
var CONFIRMATION_TIMEOUT = 45e3;
var EntityManagerClient = class {
  constructor(config_) {
    _defineProperty$1(this, "audiusWalletClient", void 0);
    _defineProperty$1(this, "logger", void 0);
    _defineProperty$1(this, "chainId", void 0);
    _defineProperty$1(this, "contractAddress", void 0);
    _defineProperty$1(this, "endpoint", void 0);
    const config = mergeConfigWithDefaults(config_, getDefaultEntityManagerConfig(productionConfig));
    this.audiusWalletClient = config.audiusWalletClient;
    this.chainId = config.chainId;
    this.contractAddress = config.contractAddress;
    this.logger = config.logger.createPrefixedLogger("[entity-manager]");
    this.endpoint = config.endpoint;
  }
  /**
   * Calls the manage entity method on chain to update some data
   */
  async manageEntity(_ref) {
    let {
      userId,
      entityType,
      entityId,
      action,
      metadata = "",
      confirmationTimeout = CONFIRMATION_TIMEOUT,
      skipConfirmation = false
    } = _ref;
    const nonce = await getNonce();
    const typedData = {
      domain: this.getDomain(),
      primaryType: "ManageEntity",
      message: {
        // TODO: Strictly check callsites to ensure userId always passed in
        // @ts-ignore Need to update this type to "uint32" instead of "uint"
        userId,
        entityType,
        // @ts-ignore Need to update this type to "uint32" instead of "uint"
        entityId,
        action,
        metadata,
        nonce
      },
      types: EntityManager.types
    };
    const [senderAddress] = await this.audiusWalletClient.getAddresses();
    const signature2 = await this.audiusWalletClient.signTypedData(typedData);
    const url = `${this.endpoint}/relay`;
    this.logger.info(`Making relay request to ${url}`);
    const response = await fetch$1(url, {
      method: "POST",
      headers: new import_cross_fetch.Headers({
        "Content-Type": "application/json"
      }),
      body: JSON.stringify({
        contractAddress: this.contractAddress,
        contractRegistryKey: "EntityManager",
        encodedABI: encodeFunctionData({
          abi: EntityManager.abi,
          args: [BigInt(userId), entityType, BigInt(entityId), action, metadata, nonce, signature2],
          functionName: "manageEntity"
        }),
        // Gas limit not really needed with ACDC
        gasLimit: DEFAULT_GAS_LIMIT,
        senderAddress
      })
    });
    if (response.ok) {
      const jsonResponse = await response.json();
      if (!skipConfirmation) {
        await this.confirmWrite({
          blockHash: jsonResponse.receipt.blockHash,
          blockNumber: jsonResponse.receipt.blockNumber,
          confirmationTimeout
        });
      }
      return {
        blockHash: jsonResponse.receipt.blockHash,
        blockNumber: jsonResponse.receipt.blockNumber
      };
    } else {
      if (response.status === 429) {
        this.logger.error("API Rate Limit Exceeded: You have exceeded the allowed number of requests for this action. Please wait and try again later. If you require a higher rate limit, please send an email to api@audius.co with your request, detailing the reasons and expected usage.");
      }
      throw new ResponseError$1(response, "Response returned an error code");
    }
  }
  /**
   * Confirms a write by polling for the block to be indexed by API
   */
  async confirmWrite(_ref2) {
    let {
      blockHash,
      blockNumber,
      confirmationTimeout = CONFIRMATION_TIMEOUT,
      confirmationPollingInterval = CONFIRMATION_POLLING_INTERVAL
    } = _ref2;
    this.logger.info(`Confirming write ${blockHash} ${blockNumber}`);
    const confirmBlock = async () => {
      const url = `${this.endpoint}/block_confirmation?blocknumber=${blockNumber}&blockhash=${blockHash}`;
      const {
        data: {
          block_passed
        }
      } = await (await fetch$1(url)).json();
      return block_passed ? BlockConfirmation.CONFIRMED : BlockConfirmation.UNKNOWN;
    };
    let confirmation = await confirmBlock();
    const start = Date.now();
    while (confirmation === BlockConfirmation.UNKNOWN) {
      if (Date.now() - start > confirmationTimeout) {
        throw new Error(`Could not confirm write within ${confirmationTimeout}ms`);
      }
      await new Promise((resolve2) => setTimeout(resolve2, confirmationPollingInterval));
      confirmation = await confirmBlock();
    }
    this.logger.info("Write confirmed");
    return true;
  }
  /**
   * Decodes the manage entity function data
   * @param data - The encoded function data
   * @returns The decoded function data
   */
  decodeManageEntity(data) {
    const decodedAbi = decodeFunctionData({
      abi: EntityManager.abi,
      data
    });
    if (decodedAbi.functionName !== "manageEntity") {
      throw new Error("Expected manageEntity function");
    }
    const [userId, entityType, entityId, action, metadata, nonce, subjectSig] = decodedAbi.args;
    if (!userId || !entityType || // 0 is a valid entityId for some actions
    !entityId && entityId !== BigInt(0) || !action || // Empty string is valid metadata for some actions
    !metadata && metadata !== "" || !nonce || !subjectSig) {
      throw new Error("Missing complete manageEntity function data");
    }
    return {
      userId,
      entityType,
      entityId,
      action,
      metadata,
      nonce,
      subjectSig
    };
  }
  /**
   * Gets the domain used for proxy signing for the entity manager
   * @returns The domain object
   */
  getDomain() {
    return {
      name: "Entity Manager",
      chainId: BigInt(this.chainId),
      version: "1",
      verifyingContract: this.contractAddress
    };
  }
  /**
   * Recovers the signer address from the encoded ABI
   * @param encodedABI - The encoded ABI
   * @returns The recovered signer address
   */
  async recoverSigner(encodedABI) {
    const decodedAbi = this.decodeManageEntity(encodedABI);
    const {
      userId,
      entityType,
      entityId,
      action,
      metadata,
      nonce,
      subjectSig
    } = decodedAbi;
    return await recoverTypedDataAddress({
      domain: this.getDomain(),
      primaryType: "ManageEntity",
      message: {
        // @ts-ignore Need to update this type to "uint32" instead of "uint"
        userId: Number(userId),
        entityType,
        // @ts-ignore Need to update this type to "uint32" instead of "uint"
        entityId: Number(entityId),
        action,
        metadata,
        nonce
      },
      types: EntityManager.types,
      signature: subjectSig
    });
  }
};
var wait2 = async (milliseconds) => {
  return await new Promise((resolve2) => setTimeout(resolve2, milliseconds));
};
var getDefaultStorageServiceConfig = (_config) => ({
  logger: new Logger()
});
var MAX_TRACK_TRANSCODE_TIMEOUT = 36e5;
var MAX_TRACK_TRANSCODE_NO_PROGRESS_TIMEOUT = 6e5;
var MAX_IMAGE_RESIZE_TIMEOUT_MS = 3e5;
var POLL_STATUS_INTERVAL = 3e3;
var Storage = class {
  constructor(config) {
    _defineProperty$1(this, "config", void 0);
    _defineProperty$1(this, "storageNodeSelector", void 0);
    _defineProperty$1(this, "logger", void 0);
    this.config = mergeConfigWithDefaults(config, getDefaultStorageServiceConfig());
    this.storageNodeSelector = config.storageNodeSelector;
    this.logger = this.config.logger.createPrefixedLogger("[storage]");
  }
  /**
   * Upload a file to a content node
   * @param file
   * @param onProgress
   * @param template
   * @param options
   * @returns
   */
  async uploadFile(_ref) {
    var _file$name, _response2, _response2$data;
    let {
      file,
      onProgress,
      template,
      options = {}
    } = _ref;
    const formData = new import_form_data.default();
    formData.append("template", template);
    Object.keys(options).forEach((key) => {
      formData.append(key, `${options[key]}`);
    });
    const formDataFile = "uri" in file ? {
      ...file,
      // NOTE this is required for react-native
      // certain characters in the file name make formData invalid
      name: file.name ? encodeURIComponent(file.name.replace(/[()]/g, "")) : "blob"
    } : file;
    formData.append("files", isNodeFile(formDataFile) ? formDataFile.buffer : formDataFile, (_file$name = file.name) !== null && _file$name !== void 0 ? _file$name : "blob");
    let response = null;
    const request = {
      method: "post",
      maxContentLength: Infinity,
      data: formData,
      headers: {
        ...formData.getBoundary ? {
          "Content-Type": `multipart/form-data; boundary=${formData.getBoundary()}`
        } : void 0
      },
      onUploadProgress: (progressEvent) => {
        const progress = {
          upload: {
            loaded: progressEvent.loaded,
            total: progressEvent.total
          }
        };
        onProgress === null || onProgress === void 0 ? void 0 : onProgress(template === "audio" ? {
          audio: progress
        } : {
          art: progress
        });
      }
    };
    let lastErr;
    for (let selectedNode = await this.storageNodeSelector.getSelectedNode(); !this.storageNodeSelector.triedSelectingAllNodes(); selectedNode = await this.storageNodeSelector.getSelectedNode(true)) {
      request.url = `${selectedNode}/uploads`;
      try {
        var _response, _response$data;
        response = await (0, import_axios.default)(request);
        if (((_response = response) === null || _response === void 0 ? void 0 : (_response$data = _response.data) === null || _response$data === void 0 ? void 0 : _response$data.length) > 0) {
          break;
        }
      } catch (e) {
        lastErr = e;
      }
    }
    if (!((_response2 = response) !== null && _response2 !== void 0 && (_response2$data = _response2.data) !== null && _response2$data !== void 0 && _response2$data.length)) {
      const msg = `Error sending storagev2 upload request, tried all healthy storage nodes. Last error: ${lastErr}`;
      this.logger.error(msg);
      throw new Error(msg);
    }
    return await this.pollProcessingStatus(response.data[0].id, template, onProgress);
  }
  /**
   * Generates a preview for a track at the given second offset
   * @param {Object} params
   * @param {string} params.cid - The CID of the track to generate a preview for
   * @param {number} params.secondOffset - The offset in seconds to start the preview from
   * @returns {Promise<string>} The CID of the generated preview
   */
  async generatePreview(_ref2) {
    let {
      cid,
      secondOffset
    } = _ref2;
    const contentNodeEndpoint = await this.storageNodeSelector.getSelectedNode();
    if (!contentNodeEndpoint) {
      throw new Error("No content node available");
    }
    const response = await (0, import_axios.default)({
      method: "post",
      url: `${contentNodeEndpoint}/generate_preview/${cid}/${secondOffset}`
    });
    return response.data.cid;
  }
  /**
   * Works for both track transcode and image resize jobs
   * @param id ID of the transcode/resize job
   * @param maxPollingMs millis to stop polling and error if job is not done
   * @returns successful job info, or throws error if job fails / times out
   */
  async pollProcessingStatus(id, template, onProgress) {
    const start = Date.now();
    let lastProgressUpdate = Date.now();
    let lastTranscodeProgress = 0;
    const maxPollingMs = template === "audio" ? MAX_TRACK_TRANSCODE_TIMEOUT : MAX_IMAGE_RESIZE_TIMEOUT_MS;
    while (Date.now() - start < maxPollingMs) {
      try {
        const resp = await this.getProcessingStatus(id);
        if (template === "audio" && resp.transcode_progress) {
          if (resp.transcode_progress > lastTranscodeProgress) {
            lastProgressUpdate = Date.now();
            lastTranscodeProgress = resp.transcode_progress;
          } else if (Date.now() - lastProgressUpdate > MAX_TRACK_TRANSCODE_NO_PROGRESS_TIMEOUT) {
            throw new Error(`No transcoding progress increase for ${MAX_TRACK_TRANSCODE_NO_PROGRESS_TIMEOUT}ms. Progress stuck at ${lastTranscodeProgress}. id=${id}`);
          }
          onProgress === null || onProgress === void 0 ? void 0 : onProgress({
            audio: {
              transcode: {
                decimal: resp.transcode_progress
              }
            }
          });
        }
        if ((resp === null || resp === void 0 ? void 0 : resp.status) === "done") {
          return resp;
        }
        if ((resp === null || resp === void 0 ? void 0 : resp.status) === "error" || (resp === null || resp === void 0 ? void 0 : resp.status) === "error_retranscode_preview") {
          throw new Error(`Upload failed: id=${id}, resp=${JSON.stringify(resp)}`);
        }
      } catch (e) {
        var _e$message, _e$message2, _e$response;
        if ((_e$message = e.message) !== null && _e$message !== void 0 && _e$message.startsWith("Upload failed") || (_e$message2 = e.message) !== null && _e$message2 !== void 0 && _e$message2.startsWith("No transcoding progress increase") || e.response && ((_e$response = e.response) === null || _e$response === void 0 ? void 0 : _e$response.status) === 422) {
          throw e;
        }
        this.logger.error(`Failed to poll for processing status, ${e}`);
      }
      await wait2(POLL_STATUS_INTERVAL);
    }
    throw new Error(`Upload took over ${maxPollingMs}ms. id=${id}`);
  }
  /**
   * Gets the task progress given the task type and id associated with the job
   * @param id the id of the transcoding or resizing job
   * @returns the status, and the success or failed response if the job is complete
   */
  async getProcessingStatus(id) {
    let lastErr;
    for (let selectedNode = await this.storageNodeSelector.getSelectedNode(); !this.storageNodeSelector.triedSelectingAllNodes(); selectedNode = await this.storageNodeSelector.getSelectedNode(true)) {
      try {
        const response = await fetch$1(`${selectedNode}/uploads/${id}`);
        if (response.ok) {
          return await response.json();
        } else {
          lastErr = `HTTP error: ${response.status} ${response.statusText}, ${await response.text()}`;
        }
      } catch (e) {
        lastErr = e;
      }
    }
    const msg = `Error sending storagev2 uploads polling request, tried all healthy storage nodes. Last error: ${lastErr}`;
    this.logger.error(msg);
    throw new Error(msg);
  }
};
var buffer2 = {};
var base64Js = {};
base64Js.byteLength = byteLength;
base64Js.toByteArray = toByteArray;
base64Js.fromByteArray = fromByteArray;
var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
var code$1 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (i = 0, len = code$1.length; i < len; ++i) {
  lookup[i] = code$1[i];
  revLookup[code$1.charCodeAt(i)] = i;
}
var i;
var len;
revLookup["-".charCodeAt(0)] = 62;
revLookup["_".charCodeAt(0)] = 63;
function getLens(b64) {
  var len = b64.length;
  if (len % 4 > 0) {
    throw new Error("Invalid string. Length must be a multiple of 4");
  }
  var validLen = b64.indexOf("=");
  if (validLen === -1) validLen = len;
  var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
  return [validLen, placeHoldersLen];
}
function byteLength(b64) {
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function _byteLength(b64, validLen, placeHoldersLen) {
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function toByteArray(b64) {
  var tmp;
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
  var curByte = 0;
  var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
  var i;
  for (i = 0; i < len; i += 4) {
    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
    arr[curByte++] = tmp >> 16 & 255;
    arr[curByte++] = tmp >> 8 & 255;
    arr[curByte++] = tmp & 255;
  }
  if (placeHoldersLen === 2) {
    tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
    arr[curByte++] = tmp & 255;
  }
  if (placeHoldersLen === 1) {
    tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
    arr[curByte++] = tmp >> 8 & 255;
    arr[curByte++] = tmp & 255;
  }
  return arr;
}
function tripletToBase64(num2) {
  return lookup[num2 >> 18 & 63] + lookup[num2 >> 12 & 63] + lookup[num2 >> 6 & 63] + lookup[num2 & 63];
}
function encodeChunk(uint8, start, end) {
  var tmp;
  var output4 = [];
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16 & 16711680) + (uint8[i + 1] << 8 & 65280) + (uint8[i + 2] & 255);
    output4.push(tripletToBase64(tmp));
  }
  return output4.join("");
}
function fromByteArray(uint8) {
  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3;
  var parts = [];
  var maxChunkLength = 16383;
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
  }
  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "==");
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
    parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "=");
  }
  return parts.join("");
}
var ieee754 = {};
ieee754.read = function(buffer3, offset3, isLE6, mLen, nBytes) {
  var e, m;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE6 ? nBytes - 1 : 0;
  var d = isLE6 ? -1 : 1;
  var s = buffer3[offset3 + i];
  i += d;
  e = s & (1 << -nBits) - 1;
  s >>= -nBits;
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer3[offset3 + i], i += d, nBits -= 8) {
  }
  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer3[offset3 + i], i += d, nBits -= 8) {
  }
  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : (s ? -1 : 1) * Infinity;
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};
ieee754.write = function(buffer3, value, offset3, isLE6, mLen, nBytes) {
  var e, m, c;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i = isLE6 ? 0 : nBytes - 1;
  var d = isLE6 ? 1 : -1;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  value = Math.abs(value);
  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }
    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }
  for (; mLen >= 8; buffer3[offset3 + i] = m & 255, i += d, m /= 256, mLen -= 8) {
  }
  e = e << mLen | m;
  eLen += mLen;
  for (; eLen > 0; buffer3[offset3 + i] = e & 255, i += d, e /= 256, eLen -= 8) {
  }
  buffer3[offset3 + i - d] |= s * 128;
};
(function(exports2) {
  const base643 = base64Js;
  const ieee754$1 = ieee754;
  const customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
  exports2.Buffer = Buffer4;
  exports2.SlowBuffer = SlowBuffer;
  exports2.INSPECT_MAX_BYTES = 50;
  const K_MAX_LENGTH = 2147483647;
  exports2.kMaxLength = K_MAX_LENGTH;
  Buffer4.TYPED_ARRAY_SUPPORT = typedArraySupport();
  if (!Buffer4.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
    console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
  }
  function typedArraySupport() {
    try {
      const arr = new Uint8Array(1);
      const proto = {
        foo: function() {
          return 42;
        }
      };
      Object.setPrototypeOf(proto, Uint8Array.prototype);
      Object.setPrototypeOf(arr, proto);
      return arr.foo() === 42;
    } catch (e) {
      return false;
    }
  }
  Object.defineProperty(Buffer4.prototype, "parent", {
    enumerable: true,
    get: function() {
      if (!Buffer4.isBuffer(this)) return void 0;
      return this.buffer;
    }
  });
  Object.defineProperty(Buffer4.prototype, "offset", {
    enumerable: true,
    get: function() {
      if (!Buffer4.isBuffer(this)) return void 0;
      return this.byteOffset;
    }
  });
  function createBuffer(length2) {
    if (length2 > K_MAX_LENGTH) {
      throw new RangeError('The value "' + length2 + '" is invalid for option "size"');
    }
    const buf = new Uint8Array(length2);
    Object.setPrototypeOf(buf, Buffer4.prototype);
    return buf;
  }
  function Buffer4(arg, encodingOrOffset, length2) {
    if (typeof arg === "number") {
      if (typeof encodingOrOffset === "string") {
        throw new TypeError('The "string" argument must be of type string. Received type number');
      }
      return allocUnsafe(arg);
    }
    return from2(arg, encodingOrOffset, length2);
  }
  Buffer4.poolSize = 8192;
  function from2(value, encodingOrOffset, length2) {
    if (typeof value === "string") {
      return fromString(value, encodingOrOffset);
    }
    if (ArrayBuffer.isView(value)) {
      return fromArrayView(value);
    }
    if (value == null) {
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
    }
    if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
      return fromArrayBuffer(value, encodingOrOffset, length2);
    }
    if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
      return fromArrayBuffer(value, encodingOrOffset, length2);
    }
    if (typeof value === "number") {
      throw new TypeError('The "value" argument must not be of type number. Received type number');
    }
    const valueOf = value.valueOf && value.valueOf();
    if (valueOf != null && valueOf !== value) {
      return Buffer4.from(valueOf, encodingOrOffset, length2);
    }
    const b = fromObject(value);
    if (b) return b;
    if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
      return Buffer4.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length2);
    }
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
  }
  Buffer4.from = function(value, encodingOrOffset, length2) {
    return from2(value, encodingOrOffset, length2);
  };
  Object.setPrototypeOf(Buffer4.prototype, Uint8Array.prototype);
  Object.setPrototypeOf(Buffer4, Uint8Array);
  function assertSize2(size4) {
    if (typeof size4 !== "number") {
      throw new TypeError('"size" argument must be of type number');
    } else if (size4 < 0) {
      throw new RangeError('The value "' + size4 + '" is invalid for option "size"');
    }
  }
  function alloc(size4, fill, encoding) {
    assertSize2(size4);
    if (size4 <= 0) {
      return createBuffer(size4);
    }
    if (fill !== void 0) {
      return typeof encoding === "string" ? createBuffer(size4).fill(fill, encoding) : createBuffer(size4).fill(fill);
    }
    return createBuffer(size4);
  }
  Buffer4.alloc = function(size4, fill, encoding) {
    return alloc(size4, fill, encoding);
  };
  function allocUnsafe(size4) {
    assertSize2(size4);
    return createBuffer(size4 < 0 ? 0 : checked(size4) | 0);
  }
  Buffer4.allocUnsafe = function(size4) {
    return allocUnsafe(size4);
  };
  Buffer4.allocUnsafeSlow = function(size4) {
    return allocUnsafe(size4);
  };
  function fromString(string3, encoding) {
    if (typeof encoding !== "string" || encoding === "") {
      encoding = "utf8";
    }
    if (!Buffer4.isEncoding(encoding)) {
      throw new TypeError("Unknown encoding: " + encoding);
    }
    const length2 = byteLength2(string3, encoding) | 0;
    let buf = createBuffer(length2);
    const actual = buf.write(string3, encoding);
    if (actual !== length2) {
      buf = buf.slice(0, actual);
    }
    return buf;
  }
  function fromArrayLike(array4) {
    const length2 = array4.length < 0 ? 0 : checked(array4.length) | 0;
    const buf = createBuffer(length2);
    for (let i = 0; i < length2; i += 1) {
      buf[i] = array4[i] & 255;
    }
    return buf;
  }
  function fromArrayView(arrayView) {
    if (isInstance(arrayView, Uint8Array)) {
      const copy = new Uint8Array(arrayView);
      return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
    }
    return fromArrayLike(arrayView);
  }
  function fromArrayBuffer(array4, byteOffset, length2) {
    if (byteOffset < 0 || array4.byteLength < byteOffset) {
      throw new RangeError('"offset" is outside of buffer bounds');
    }
    if (array4.byteLength < byteOffset + (length2 || 0)) {
      throw new RangeError('"length" is outside of buffer bounds');
    }
    let buf;
    if (byteOffset === void 0 && length2 === void 0) {
      buf = new Uint8Array(array4);
    } else if (length2 === void 0) {
      buf = new Uint8Array(array4, byteOffset);
    } else {
      buf = new Uint8Array(array4, byteOffset, length2);
    }
    Object.setPrototypeOf(buf, Buffer4.prototype);
    return buf;
  }
  function fromObject(obj) {
    if (Buffer4.isBuffer(obj)) {
      const len = checked(obj.length) | 0;
      const buf = createBuffer(len);
      if (buf.length === 0) {
        return buf;
      }
      obj.copy(buf, 0, 0, len);
      return buf;
    }
    if (obj.length !== void 0) {
      if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
        return createBuffer(0);
      }
      return fromArrayLike(obj);
    }
    if (obj.type === "Buffer" && Array.isArray(obj.data)) {
      return fromArrayLike(obj.data);
    }
  }
  function checked(length2) {
    if (length2 >= K_MAX_LENGTH) {
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
    }
    return length2 | 0;
  }
  function SlowBuffer(length2) {
    if (+length2 != length2) {
      length2 = 0;
    }
    return Buffer4.alloc(+length2);
  }
  Buffer4.isBuffer = function isBuffer2(b) {
    return b != null && b._isBuffer === true && b !== Buffer4.prototype;
  };
  Buffer4.compare = function compare2(a, b) {
    if (isInstance(a, Uint8Array)) a = Buffer4.from(a, a.offset, a.byteLength);
    if (isInstance(b, Uint8Array)) b = Buffer4.from(b, b.offset, b.byteLength);
    if (!Buffer4.isBuffer(a) || !Buffer4.isBuffer(b)) {
      throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    }
    if (a === b) return 0;
    let x = a.length;
    let y = b.length;
    for (let i = 0, len = Math.min(x, y); i < len; ++i) {
      if (a[i] !== b[i]) {
        x = a[i];
        y = b[i];
        break;
      }
    }
    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
  };
  Buffer4.isEncoding = function isEncoding(encoding) {
    switch (String(encoding).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return true;
      default:
        return false;
    }
  };
  Buffer4.concat = function concat3(list, length2) {
    if (!Array.isArray(list)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    if (list.length === 0) {
      return Buffer4.alloc(0);
    }
    let i;
    if (length2 === void 0) {
      length2 = 0;
      for (i = 0; i < list.length; ++i) {
        length2 += list[i].length;
      }
    }
    const buffer3 = Buffer4.allocUnsafe(length2);
    let pos = 0;
    for (i = 0; i < list.length; ++i) {
      let buf = list[i];
      if (isInstance(buf, Uint8Array)) {
        if (pos + buf.length > buffer3.length) {
          if (!Buffer4.isBuffer(buf)) buf = Buffer4.from(buf);
          buf.copy(buffer3, pos);
        } else {
          Uint8Array.prototype.set.call(buffer3, buf, pos);
        }
      } else if (!Buffer4.isBuffer(buf)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      } else {
        buf.copy(buffer3, pos);
      }
      pos += buf.length;
    }
    return buffer3;
  };
  function byteLength2(string3, encoding) {
    if (Buffer4.isBuffer(string3)) {
      return string3.length;
    }
    if (ArrayBuffer.isView(string3) || isInstance(string3, ArrayBuffer)) {
      return string3.byteLength;
    }
    if (typeof string3 !== "string") {
      throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string3);
    }
    const len = string3.length;
    const mustMatch = arguments.length > 2 && arguments[2] === true;
    if (!mustMatch && len === 0) return 0;
    let loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "ascii":
        case "latin1":
        case "binary":
          return len;
        case "utf8":
        case "utf-8":
          return utf8ToBytes6(string3).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return len * 2;
        case "hex":
          return len >>> 1;
        case "base64":
          return base64ToBytes(string3).length;
        default:
          if (loweredCase) {
            return mustMatch ? -1 : utf8ToBytes6(string3).length;
          }
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer4.byteLength = byteLength2;
  function slowToString(encoding, start, end) {
    let loweredCase = false;
    if (start === void 0 || start < 0) {
      start = 0;
    }
    if (start > this.length) {
      return "";
    }
    if (end === void 0 || end > this.length) {
      end = this.length;
    }
    if (end <= 0) {
      return "";
    }
    end >>>= 0;
    start >>>= 0;
    if (end <= start) {
      return "";
    }
    if (!encoding) encoding = "utf8";
    while (true) {
      switch (encoding) {
        case "hex":
          return hexSlice(this, start, end);
        case "utf8":
        case "utf-8":
          return utf8Slice(this, start, end);
        case "ascii":
          return asciiSlice(this, start, end);
        case "latin1":
        case "binary":
          return latin1Slice(this, start, end);
        case "base64":
          return base64Slice(this, start, end);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return utf16leSlice(this, start, end);
        default:
          if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
          encoding = (encoding + "").toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer4.prototype._isBuffer = true;
  function swap(b, n, m) {
    const i = b[n];
    b[n] = b[m];
    b[m] = i;
  }
  Buffer4.prototype.swap16 = function swap16() {
    const len = this.length;
    if (len % 2 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    }
    for (let i = 0; i < len; i += 2) {
      swap(this, i, i + 1);
    }
    return this;
  };
  Buffer4.prototype.swap32 = function swap32() {
    const len = this.length;
    if (len % 4 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    }
    for (let i = 0; i < len; i += 4) {
      swap(this, i, i + 3);
      swap(this, i + 1, i + 2);
    }
    return this;
  };
  Buffer4.prototype.swap64 = function swap64() {
    const len = this.length;
    if (len % 8 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    }
    for (let i = 0; i < len; i += 8) {
      swap(this, i, i + 7);
      swap(this, i + 1, i + 6);
      swap(this, i + 2, i + 5);
      swap(this, i + 3, i + 4);
    }
    return this;
  };
  Buffer4.prototype.toString = function toString2() {
    const length2 = this.length;
    if (length2 === 0) return "";
    if (arguments.length === 0) return utf8Slice(this, 0, length2);
    return slowToString.apply(this, arguments);
  };
  Buffer4.prototype.toLocaleString = Buffer4.prototype.toString;
  Buffer4.prototype.equals = function equals2(b) {
    if (!Buffer4.isBuffer(b)) throw new TypeError("Argument must be a Buffer");
    if (this === b) return true;
    return Buffer4.compare(this, b) === 0;
  };
  Buffer4.prototype.inspect = function inspect() {
    let str2 = "";
    const max = exports2.INSPECT_MAX_BYTES;
    str2 = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
    if (this.length > max) str2 += " ... ";
    return "<Buffer " + str2 + ">";
  };
  if (customInspectSymbol) {
    Buffer4.prototype[customInspectSymbol] = Buffer4.prototype.inspect;
  }
  Buffer4.prototype.compare = function compare2(target, start, end, thisStart, thisEnd) {
    if (isInstance(target, Uint8Array)) {
      target = Buffer4.from(target, target.offset, target.byteLength);
    }
    if (!Buffer4.isBuffer(target)) {
      throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target);
    }
    if (start === void 0) {
      start = 0;
    }
    if (end === void 0) {
      end = target ? target.length : 0;
    }
    if (thisStart === void 0) {
      thisStart = 0;
    }
    if (thisEnd === void 0) {
      thisEnd = this.length;
    }
    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
      throw new RangeError("out of range index");
    }
    if (thisStart >= thisEnd && start >= end) {
      return 0;
    }
    if (thisStart >= thisEnd) {
      return -1;
    }
    if (start >= end) {
      return 1;
    }
    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target) return 0;
    let x = thisEnd - thisStart;
    let y = end - start;
    const len = Math.min(x, y);
    const thisCopy = this.slice(thisStart, thisEnd);
    const targetCopy = target.slice(start, end);
    for (let i = 0; i < len; ++i) {
      if (thisCopy[i] !== targetCopy[i]) {
        x = thisCopy[i];
        y = targetCopy[i];
        break;
      }
    }
    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
  };
  function bidirectionalIndexOf(buffer3, val, byteOffset, encoding, dir) {
    if (buffer3.length === 0) return -1;
    if (typeof byteOffset === "string") {
      encoding = byteOffset;
      byteOffset = 0;
    } else if (byteOffset > 2147483647) {
      byteOffset = 2147483647;
    } else if (byteOffset < -2147483648) {
      byteOffset = -2147483648;
    }
    byteOffset = +byteOffset;
    if (numberIsNaN(byteOffset)) {
      byteOffset = dir ? 0 : buffer3.length - 1;
    }
    if (byteOffset < 0) byteOffset = buffer3.length + byteOffset;
    if (byteOffset >= buffer3.length) {
      if (dir) return -1;
      else byteOffset = buffer3.length - 1;
    } else if (byteOffset < 0) {
      if (dir) byteOffset = 0;
      else return -1;
    }
    if (typeof val === "string") {
      val = Buffer4.from(val, encoding);
    }
    if (Buffer4.isBuffer(val)) {
      if (val.length === 0) {
        return -1;
      }
      return arrayIndexOf(buffer3, val, byteOffset, encoding, dir);
    } else if (typeof val === "number") {
      val = val & 255;
      if (typeof Uint8Array.prototype.indexOf === "function") {
        if (dir) {
          return Uint8Array.prototype.indexOf.call(buffer3, val, byteOffset);
        } else {
          return Uint8Array.prototype.lastIndexOf.call(buffer3, val, byteOffset);
        }
      }
      return arrayIndexOf(buffer3, [val], byteOffset, encoding, dir);
    }
    throw new TypeError("val must be string, number or Buffer");
  }
  function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
    let indexSize = 1;
    let arrLength = arr.length;
    let valLength = val.length;
    if (encoding !== void 0) {
      encoding = String(encoding).toLowerCase();
      if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
        if (arr.length < 2 || val.length < 2) {
          return -1;
        }
        indexSize = 2;
        arrLength /= 2;
        valLength /= 2;
        byteOffset /= 2;
      }
    }
    function read2(buf, i2) {
      if (indexSize === 1) {
        return buf[i2];
      } else {
        return buf.readUInt16BE(i2 * indexSize);
      }
    }
    let i;
    if (dir) {
      let foundIndex = -1;
      for (i = byteOffset; i < arrLength; i++) {
        if (read2(arr, i) === read2(val, foundIndex === -1 ? 0 : i - foundIndex)) {
          if (foundIndex === -1) foundIndex = i;
          if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
        } else {
          if (foundIndex !== -1) i -= i - foundIndex;
          foundIndex = -1;
        }
      }
    } else {
      if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
      for (i = byteOffset; i >= 0; i--) {
        let found = true;
        for (let j = 0; j < valLength; j++) {
          if (read2(arr, i + j) !== read2(val, j)) {
            found = false;
            break;
          }
        }
        if (found) return i;
      }
    }
    return -1;
  }
  Buffer4.prototype.includes = function includes(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
  };
  Buffer4.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
  };
  Buffer4.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
  };
  function hexWrite(buf, string3, offset3, length2) {
    offset3 = Number(offset3) || 0;
    const remaining = buf.length - offset3;
    if (!length2) {
      length2 = remaining;
    } else {
      length2 = Number(length2);
      if (length2 > remaining) {
        length2 = remaining;
      }
    }
    const strLen = string3.length;
    if (length2 > strLen / 2) {
      length2 = strLen / 2;
    }
    let i;
    for (i = 0; i < length2; ++i) {
      const parsed = parseInt(string3.substr(i * 2, 2), 16);
      if (numberIsNaN(parsed)) return i;
      buf[offset3 + i] = parsed;
    }
    return i;
  }
  function utf8Write(buf, string3, offset3, length2) {
    return blitBuffer(utf8ToBytes6(string3, buf.length - offset3), buf, offset3, length2);
  }
  function asciiWrite(buf, string3, offset3, length2) {
    return blitBuffer(asciiToBytes(string3), buf, offset3, length2);
  }
  function base64Write(buf, string3, offset3, length2) {
    return blitBuffer(base64ToBytes(string3), buf, offset3, length2);
  }
  function ucs2Write(buf, string3, offset3, length2) {
    return blitBuffer(utf16leToBytes(string3, buf.length - offset3), buf, offset3, length2);
  }
  Buffer4.prototype.write = function write(string3, offset3, length2, encoding) {
    if (offset3 === void 0) {
      encoding = "utf8";
      length2 = this.length;
      offset3 = 0;
    } else if (length2 === void 0 && typeof offset3 === "string") {
      encoding = offset3;
      length2 = this.length;
      offset3 = 0;
    } else if (isFinite(offset3)) {
      offset3 = offset3 >>> 0;
      if (isFinite(length2)) {
        length2 = length2 >>> 0;
        if (encoding === void 0) encoding = "utf8";
      } else {
        encoding = length2;
        length2 = void 0;
      }
    } else {
      throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
    }
    const remaining = this.length - offset3;
    if (length2 === void 0 || length2 > remaining) length2 = remaining;
    if (string3.length > 0 && (length2 < 0 || offset3 < 0) || offset3 > this.length) {
      throw new RangeError("Attempt to write outside buffer bounds");
    }
    if (!encoding) encoding = "utf8";
    let loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "hex":
          return hexWrite(this, string3, offset3, length2);
        case "utf8":
        case "utf-8":
          return utf8Write(this, string3, offset3, length2);
        case "ascii":
        case "latin1":
        case "binary":
          return asciiWrite(this, string3, offset3, length2);
        case "base64":
          return base64Write(this, string3, offset3, length2);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return ucs2Write(this, string3, offset3, length2);
        default:
          if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  };
  Buffer4.prototype.toJSON = function toJSON() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function base64Slice(buf, start, end) {
    if (start === 0 && end === buf.length) {
      return base643.fromByteArray(buf);
    } else {
      return base643.fromByteArray(buf.slice(start, end));
    }
  }
  function utf8Slice(buf, start, end) {
    end = Math.min(buf.length, end);
    const res = [];
    let i = start;
    while (i < end) {
      const firstByte = buf[i];
      let codePoint = null;
      let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
      if (i + bytesPerSequence <= end) {
        let secondByte, thirdByte, fourthByte, tempCodePoint;
        switch (bytesPerSequence) {
          case 1:
            if (firstByte < 128) {
              codePoint = firstByte;
            }
            break;
          case 2:
            secondByte = buf[i + 1];
            if ((secondByte & 192) === 128) {
              tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
              if (tempCodePoint > 127) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 3:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
              if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 4:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            fourthByte = buf[i + 3];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
              if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                codePoint = tempCodePoint;
              }
            }
        }
      }
      if (codePoint === null) {
        codePoint = 65533;
        bytesPerSequence = 1;
      } else if (codePoint > 65535) {
        codePoint -= 65536;
        res.push(codePoint >>> 10 & 1023 | 55296);
        codePoint = 56320 | codePoint & 1023;
      }
      res.push(codePoint);
      i += bytesPerSequence;
    }
    return decodeCodePointsArray(res);
  }
  const MAX_ARGUMENTS_LENGTH = 4096;
  function decodeCodePointsArray(codePoints) {
    const len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH) {
      return String.fromCharCode.apply(String, codePoints);
    }
    let res = "";
    let i = 0;
    while (i < len) {
      res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
    }
    return res;
  }
  function asciiSlice(buf, start, end) {
    let ret = "";
    end = Math.min(buf.length, end);
    for (let i = start; i < end; ++i) {
      ret += String.fromCharCode(buf[i] & 127);
    }
    return ret;
  }
  function latin1Slice(buf, start, end) {
    let ret = "";
    end = Math.min(buf.length, end);
    for (let i = start; i < end; ++i) {
      ret += String.fromCharCode(buf[i]);
    }
    return ret;
  }
  function hexSlice(buf, start, end) {
    const len = buf.length;
    if (!start || start < 0) start = 0;
    if (!end || end < 0 || end > len) end = len;
    let out = "";
    for (let i = start; i < end; ++i) {
      out += hexSliceLookupTable[buf[i]];
    }
    return out;
  }
  function utf16leSlice(buf, start, end) {
    const bytes3 = buf.slice(start, end);
    let res = "";
    for (let i = 0; i < bytes3.length - 1; i += 2) {
      res += String.fromCharCode(bytes3[i] + bytes3[i + 1] * 256);
    }
    return res;
  }
  Buffer4.prototype.slice = function slice3(start, end) {
    const len = this.length;
    start = ~~start;
    end = end === void 0 ? len : ~~end;
    if (start < 0) {
      start += len;
      if (start < 0) start = 0;
    } else if (start > len) {
      start = len;
    }
    if (end < 0) {
      end += len;
      if (end < 0) end = 0;
    } else if (end > len) {
      end = len;
    }
    if (end < start) end = start;
    const newBuf = this.subarray(start, end);
    Object.setPrototypeOf(newBuf, Buffer4.prototype);
    return newBuf;
  };
  function checkOffset(offset3, ext, length2) {
    if (offset3 % 1 !== 0 || offset3 < 0) throw new RangeError("offset is not uint");
    if (offset3 + ext > length2) throw new RangeError("Trying to access beyond buffer length");
  }
  Buffer4.prototype.readUintLE = Buffer4.prototype.readUIntLE = function readUIntLE(offset3, byteLength3, noAssert) {
    offset3 = offset3 >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) checkOffset(offset3, byteLength3, this.length);
    let val = this[offset3];
    let mul = 1;
    let i = 0;
    while (++i < byteLength3 && (mul *= 256)) {
      val += this[offset3 + i] * mul;
    }
    return val;
  };
  Buffer4.prototype.readUintBE = Buffer4.prototype.readUIntBE = function readUIntBE(offset3, byteLength3, noAssert) {
    offset3 = offset3 >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      checkOffset(offset3, byteLength3, this.length);
    }
    let val = this[offset3 + --byteLength3];
    let mul = 1;
    while (byteLength3 > 0 && (mul *= 256)) {
      val += this[offset3 + --byteLength3] * mul;
    }
    return val;
  };
  Buffer4.prototype.readUint8 = Buffer4.prototype.readUInt8 = function readUInt8(offset3, noAssert) {
    offset3 = offset3 >>> 0;
    if (!noAssert) checkOffset(offset3, 1, this.length);
    return this[offset3];
  };
  Buffer4.prototype.readUint16LE = Buffer4.prototype.readUInt16LE = function readUInt16LE(offset3, noAssert) {
    offset3 = offset3 >>> 0;
    if (!noAssert) checkOffset(offset3, 2, this.length);
    return this[offset3] | this[offset3 + 1] << 8;
  };
  Buffer4.prototype.readUint16BE = Buffer4.prototype.readUInt16BE = function readUInt16BE(offset3, noAssert) {
    offset3 = offset3 >>> 0;
    if (!noAssert) checkOffset(offset3, 2, this.length);
    return this[offset3] << 8 | this[offset3 + 1];
  };
  Buffer4.prototype.readUint32LE = Buffer4.prototype.readUInt32LE = function readUInt32LE(offset3, noAssert) {
    offset3 = offset3 >>> 0;
    if (!noAssert) checkOffset(offset3, 4, this.length);
    return (this[offset3] | this[offset3 + 1] << 8 | this[offset3 + 2] << 16) + this[offset3 + 3] * 16777216;
  };
  Buffer4.prototype.readUint32BE = Buffer4.prototype.readUInt32BE = function readUInt32BE(offset3, noAssert) {
    offset3 = offset3 >>> 0;
    if (!noAssert) checkOffset(offset3, 4, this.length);
    return this[offset3] * 16777216 + (this[offset3 + 1] << 16 | this[offset3 + 2] << 8 | this[offset3 + 3]);
  };
  Buffer4.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset3) {
    offset3 = offset3 >>> 0;
    validateNumber(offset3, "offset");
    const first = this[offset3];
    const last = this[offset3 + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset3, this.length - 8);
    }
    const lo = first + this[++offset3] * 2 ** 8 + this[++offset3] * 2 ** 16 + this[++offset3] * 2 ** 24;
    const hi = this[++offset3] + this[++offset3] * 2 ** 8 + this[++offset3] * 2 ** 16 + last * 2 ** 24;
    return BigInt(lo) + (BigInt(hi) << BigInt(32));
  });
  Buffer4.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset3) {
    offset3 = offset3 >>> 0;
    validateNumber(offset3, "offset");
    const first = this[offset3];
    const last = this[offset3 + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset3, this.length - 8);
    }
    const hi = first * 2 ** 24 + this[++offset3] * 2 ** 16 + this[++offset3] * 2 ** 8 + this[++offset3];
    const lo = this[++offset3] * 2 ** 24 + this[++offset3] * 2 ** 16 + this[++offset3] * 2 ** 8 + last;
    return (BigInt(hi) << BigInt(32)) + BigInt(lo);
  });
  Buffer4.prototype.readIntLE = function readIntLE(offset3, byteLength3, noAssert) {
    offset3 = offset3 >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) checkOffset(offset3, byteLength3, this.length);
    let val = this[offset3];
    let mul = 1;
    let i = 0;
    while (++i < byteLength3 && (mul *= 256)) {
      val += this[offset3 + i] * mul;
    }
    mul *= 128;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength3);
    return val;
  };
  Buffer4.prototype.readIntBE = function readIntBE(offset3, byteLength3, noAssert) {
    offset3 = offset3 >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) checkOffset(offset3, byteLength3, this.length);
    let i = byteLength3;
    let mul = 1;
    let val = this[offset3 + --i];
    while (i > 0 && (mul *= 256)) {
      val += this[offset3 + --i] * mul;
    }
    mul *= 128;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength3);
    return val;
  };
  Buffer4.prototype.readInt8 = function readInt8(offset3, noAssert) {
    offset3 = offset3 >>> 0;
    if (!noAssert) checkOffset(offset3, 1, this.length);
    if (!(this[offset3] & 128)) return this[offset3];
    return (255 - this[offset3] + 1) * -1;
  };
  Buffer4.prototype.readInt16LE = function readInt16LE(offset3, noAssert) {
    offset3 = offset3 >>> 0;
    if (!noAssert) checkOffset(offset3, 2, this.length);
    const val = this[offset3] | this[offset3 + 1] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer4.prototype.readInt16BE = function readInt16BE(offset3, noAssert) {
    offset3 = offset3 >>> 0;
    if (!noAssert) checkOffset(offset3, 2, this.length);
    const val = this[offset3 + 1] | this[offset3] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer4.prototype.readInt32LE = function readInt32LE(offset3, noAssert) {
    offset3 = offset3 >>> 0;
    if (!noAssert) checkOffset(offset3, 4, this.length);
    return this[offset3] | this[offset3 + 1] << 8 | this[offset3 + 2] << 16 | this[offset3 + 3] << 24;
  };
  Buffer4.prototype.readInt32BE = function readInt32BE(offset3, noAssert) {
    offset3 = offset3 >>> 0;
    if (!noAssert) checkOffset(offset3, 4, this.length);
    return this[offset3] << 24 | this[offset3 + 1] << 16 | this[offset3 + 2] << 8 | this[offset3 + 3];
  };
  Buffer4.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset3) {
    offset3 = offset3 >>> 0;
    validateNumber(offset3, "offset");
    const first = this[offset3];
    const last = this[offset3 + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset3, this.length - 8);
    }
    const val = this[offset3 + 4] + this[offset3 + 5] * 2 ** 8 + this[offset3 + 6] * 2 ** 16 + (last << 24);
    return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset3] * 2 ** 8 + this[++offset3] * 2 ** 16 + this[++offset3] * 2 ** 24);
  });
  Buffer4.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset3) {
    offset3 = offset3 >>> 0;
    validateNumber(offset3, "offset");
    const first = this[offset3];
    const last = this[offset3 + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset3, this.length - 8);
    }
    const val = (first << 24) + // Overflow
    this[++offset3] * 2 ** 16 + this[++offset3] * 2 ** 8 + this[++offset3];
    return (BigInt(val) << BigInt(32)) + BigInt(this[++offset3] * 2 ** 24 + this[++offset3] * 2 ** 16 + this[++offset3] * 2 ** 8 + last);
  });
  Buffer4.prototype.readFloatLE = function readFloatLE(offset3, noAssert) {
    offset3 = offset3 >>> 0;
    if (!noAssert) checkOffset(offset3, 4, this.length);
    return ieee754$1.read(this, offset3, true, 23, 4);
  };
  Buffer4.prototype.readFloatBE = function readFloatBE(offset3, noAssert) {
    offset3 = offset3 >>> 0;
    if (!noAssert) checkOffset(offset3, 4, this.length);
    return ieee754$1.read(this, offset3, false, 23, 4);
  };
  Buffer4.prototype.readDoubleLE = function readDoubleLE(offset3, noAssert) {
    offset3 = offset3 >>> 0;
    if (!noAssert) checkOffset(offset3, 8, this.length);
    return ieee754$1.read(this, offset3, true, 52, 8);
  };
  Buffer4.prototype.readDoubleBE = function readDoubleBE(offset3, noAssert) {
    offset3 = offset3 >>> 0;
    if (!noAssert) checkOffset(offset3, 8, this.length);
    return ieee754$1.read(this, offset3, false, 52, 8);
  };
  function checkInt(buf, value, offset3, ext, max, min) {
    if (!Buffer4.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
    if (offset3 + ext > buf.length) throw new RangeError("Index out of range");
  }
  Buffer4.prototype.writeUintLE = Buffer4.prototype.writeUIntLE = function writeUIntLE(value, offset3, byteLength3, noAssert) {
    value = +value;
    offset3 = offset3 >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      const maxBytes = Math.pow(2, 8 * byteLength3) - 1;
      checkInt(this, value, offset3, byteLength3, maxBytes, 0);
    }
    let mul = 1;
    let i = 0;
    this[offset3] = value & 255;
    while (++i < byteLength3 && (mul *= 256)) {
      this[offset3 + i] = value / mul & 255;
    }
    return offset3 + byteLength3;
  };
  Buffer4.prototype.writeUintBE = Buffer4.prototype.writeUIntBE = function writeUIntBE(value, offset3, byteLength3, noAssert) {
    value = +value;
    offset3 = offset3 >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      const maxBytes = Math.pow(2, 8 * byteLength3) - 1;
      checkInt(this, value, offset3, byteLength3, maxBytes, 0);
    }
    let i = byteLength3 - 1;
    let mul = 1;
    this[offset3 + i] = value & 255;
    while (--i >= 0 && (mul *= 256)) {
      this[offset3 + i] = value / mul & 255;
    }
    return offset3 + byteLength3;
  };
  Buffer4.prototype.writeUint8 = Buffer4.prototype.writeUInt8 = function writeUInt8(value, offset3, noAssert) {
    value = +value;
    offset3 = offset3 >>> 0;
    if (!noAssert) checkInt(this, value, offset3, 1, 255, 0);
    this[offset3] = value & 255;
    return offset3 + 1;
  };
  Buffer4.prototype.writeUint16LE = Buffer4.prototype.writeUInt16LE = function writeUInt16LE(value, offset3, noAssert) {
    value = +value;
    offset3 = offset3 >>> 0;
    if (!noAssert) checkInt(this, value, offset3, 2, 65535, 0);
    this[offset3] = value & 255;
    this[offset3 + 1] = value >>> 8;
    return offset3 + 2;
  };
  Buffer4.prototype.writeUint16BE = Buffer4.prototype.writeUInt16BE = function writeUInt16BE(value, offset3, noAssert) {
    value = +value;
    offset3 = offset3 >>> 0;
    if (!noAssert) checkInt(this, value, offset3, 2, 65535, 0);
    this[offset3] = value >>> 8;
    this[offset3 + 1] = value & 255;
    return offset3 + 2;
  };
  Buffer4.prototype.writeUint32LE = Buffer4.prototype.writeUInt32LE = function writeUInt32LE(value, offset3, noAssert) {
    value = +value;
    offset3 = offset3 >>> 0;
    if (!noAssert) checkInt(this, value, offset3, 4, 4294967295, 0);
    this[offset3 + 3] = value >>> 24;
    this[offset3 + 2] = value >>> 16;
    this[offset3 + 1] = value >>> 8;
    this[offset3] = value & 255;
    return offset3 + 4;
  };
  Buffer4.prototype.writeUint32BE = Buffer4.prototype.writeUInt32BE = function writeUInt32BE(value, offset3, noAssert) {
    value = +value;
    offset3 = offset3 >>> 0;
    if (!noAssert) checkInt(this, value, offset3, 4, 4294967295, 0);
    this[offset3] = value >>> 24;
    this[offset3 + 1] = value >>> 16;
    this[offset3 + 2] = value >>> 8;
    this[offset3 + 3] = value & 255;
    return offset3 + 4;
  };
  function wrtBigUInt64LE(buf, value, offset3, min, max) {
    checkIntBI(value, min, max, buf, offset3, 7);
    let lo = Number(value & BigInt(4294967295));
    buf[offset3++] = lo;
    lo = lo >> 8;
    buf[offset3++] = lo;
    lo = lo >> 8;
    buf[offset3++] = lo;
    lo = lo >> 8;
    buf[offset3++] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(4294967295));
    buf[offset3++] = hi;
    hi = hi >> 8;
    buf[offset3++] = hi;
    hi = hi >> 8;
    buf[offset3++] = hi;
    hi = hi >> 8;
    buf[offset3++] = hi;
    return offset3;
  }
  function wrtBigUInt64BE(buf, value, offset3, min, max) {
    checkIntBI(value, min, max, buf, offset3, 7);
    let lo = Number(value & BigInt(4294967295));
    buf[offset3 + 7] = lo;
    lo = lo >> 8;
    buf[offset3 + 6] = lo;
    lo = lo >> 8;
    buf[offset3 + 5] = lo;
    lo = lo >> 8;
    buf[offset3 + 4] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(4294967295));
    buf[offset3 + 3] = hi;
    hi = hi >> 8;
    buf[offset3 + 2] = hi;
    hi = hi >> 8;
    buf[offset3 + 1] = hi;
    hi = hi >> 8;
    buf[offset3] = hi;
    return offset3 + 8;
  }
  Buffer4.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value) {
    let offset3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    return wrtBigUInt64LE(this, value, offset3, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  Buffer4.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value) {
    let offset3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    return wrtBigUInt64BE(this, value, offset3, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  Buffer4.prototype.writeIntLE = function writeIntLE(value, offset3, byteLength3, noAssert) {
    value = +value;
    offset3 = offset3 >>> 0;
    if (!noAssert) {
      const limit = Math.pow(2, 8 * byteLength3 - 1);
      checkInt(this, value, offset3, byteLength3, limit - 1, -limit);
    }
    let i = 0;
    let mul = 1;
    let sub = 0;
    this[offset3] = value & 255;
    while (++i < byteLength3 && (mul *= 256)) {
      if (value < 0 && sub === 0 && this[offset3 + i - 1] !== 0) {
        sub = 1;
      }
      this[offset3 + i] = (value / mul >> 0) - sub & 255;
    }
    return offset3 + byteLength3;
  };
  Buffer4.prototype.writeIntBE = function writeIntBE(value, offset3, byteLength3, noAssert) {
    value = +value;
    offset3 = offset3 >>> 0;
    if (!noAssert) {
      const limit = Math.pow(2, 8 * byteLength3 - 1);
      checkInt(this, value, offset3, byteLength3, limit - 1, -limit);
    }
    let i = byteLength3 - 1;
    let mul = 1;
    let sub = 0;
    this[offset3 + i] = value & 255;
    while (--i >= 0 && (mul *= 256)) {
      if (value < 0 && sub === 0 && this[offset3 + i + 1] !== 0) {
        sub = 1;
      }
      this[offset3 + i] = (value / mul >> 0) - sub & 255;
    }
    return offset3 + byteLength3;
  };
  Buffer4.prototype.writeInt8 = function writeInt8(value, offset3, noAssert) {
    value = +value;
    offset3 = offset3 >>> 0;
    if (!noAssert) checkInt(this, value, offset3, 1, 127, -128);
    if (value < 0) value = 255 + value + 1;
    this[offset3] = value & 255;
    return offset3 + 1;
  };
  Buffer4.prototype.writeInt16LE = function writeInt16LE(value, offset3, noAssert) {
    value = +value;
    offset3 = offset3 >>> 0;
    if (!noAssert) checkInt(this, value, offset3, 2, 32767, -32768);
    this[offset3] = value & 255;
    this[offset3 + 1] = value >>> 8;
    return offset3 + 2;
  };
  Buffer4.prototype.writeInt16BE = function writeInt16BE(value, offset3, noAssert) {
    value = +value;
    offset3 = offset3 >>> 0;
    if (!noAssert) checkInt(this, value, offset3, 2, 32767, -32768);
    this[offset3] = value >>> 8;
    this[offset3 + 1] = value & 255;
    return offset3 + 2;
  };
  Buffer4.prototype.writeInt32LE = function writeInt32LE(value, offset3, noAssert) {
    value = +value;
    offset3 = offset3 >>> 0;
    if (!noAssert) checkInt(this, value, offset3, 4, 2147483647, -2147483648);
    this[offset3] = value & 255;
    this[offset3 + 1] = value >>> 8;
    this[offset3 + 2] = value >>> 16;
    this[offset3 + 3] = value >>> 24;
    return offset3 + 4;
  };
  Buffer4.prototype.writeInt32BE = function writeInt32BE(value, offset3, noAssert) {
    value = +value;
    offset3 = offset3 >>> 0;
    if (!noAssert) checkInt(this, value, offset3, 4, 2147483647, -2147483648);
    if (value < 0) value = 4294967295 + value + 1;
    this[offset3] = value >>> 24;
    this[offset3 + 1] = value >>> 16;
    this[offset3 + 2] = value >>> 8;
    this[offset3 + 3] = value & 255;
    return offset3 + 4;
  };
  Buffer4.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value) {
    let offset3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    return wrtBigUInt64LE(this, value, offset3, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  Buffer4.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value) {
    let offset3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    return wrtBigUInt64BE(this, value, offset3, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function checkIEEE754(buf, value, offset3, ext, max, min) {
    if (offset3 + ext > buf.length) throw new RangeError("Index out of range");
    if (offset3 < 0) throw new RangeError("Index out of range");
  }
  function writeFloat(buf, value, offset3, littleEndian, noAssert) {
    value = +value;
    offset3 = offset3 >>> 0;
    if (!noAssert) {
      checkIEEE754(buf, value, offset3, 4);
    }
    ieee754$1.write(buf, value, offset3, littleEndian, 23, 4);
    return offset3 + 4;
  }
  Buffer4.prototype.writeFloatLE = function writeFloatLE(value, offset3, noAssert) {
    return writeFloat(this, value, offset3, true, noAssert);
  };
  Buffer4.prototype.writeFloatBE = function writeFloatBE(value, offset3, noAssert) {
    return writeFloat(this, value, offset3, false, noAssert);
  };
  function writeDouble(buf, value, offset3, littleEndian, noAssert) {
    value = +value;
    offset3 = offset3 >>> 0;
    if (!noAssert) {
      checkIEEE754(buf, value, offset3, 8);
    }
    ieee754$1.write(buf, value, offset3, littleEndian, 52, 8);
    return offset3 + 8;
  }
  Buffer4.prototype.writeDoubleLE = function writeDoubleLE(value, offset3, noAssert) {
    return writeDouble(this, value, offset3, true, noAssert);
  };
  Buffer4.prototype.writeDoubleBE = function writeDoubleBE(value, offset3, noAssert) {
    return writeDouble(this, value, offset3, false, noAssert);
  };
  Buffer4.prototype.copy = function copy(target, targetStart, start, end) {
    if (!Buffer4.isBuffer(target)) throw new TypeError("argument should be a Buffer");
    if (!start) start = 0;
    if (!end && end !== 0) end = this.length;
    if (targetStart >= target.length) targetStart = target.length;
    if (!targetStart) targetStart = 0;
    if (end > 0 && end < start) end = start;
    if (end === start) return 0;
    if (target.length === 0 || this.length === 0) return 0;
    if (targetStart < 0) {
      throw new RangeError("targetStart out of bounds");
    }
    if (start < 0 || start >= this.length) throw new RangeError("Index out of range");
    if (end < 0) throw new RangeError("sourceEnd out of bounds");
    if (end > this.length) end = this.length;
    if (target.length - targetStart < end - start) {
      end = target.length - targetStart + start;
    }
    const len = end - start;
    if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
      this.copyWithin(targetStart, start, end);
    } else {
      Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
    }
    return len;
  };
  Buffer4.prototype.fill = function fill(val, start, end, encoding) {
    if (typeof val === "string") {
      if (typeof start === "string") {
        encoding = start;
        start = 0;
        end = this.length;
      } else if (typeof end === "string") {
        encoding = end;
        end = this.length;
      }
      if (encoding !== void 0 && typeof encoding !== "string") {
        throw new TypeError("encoding must be a string");
      }
      if (typeof encoding === "string" && !Buffer4.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      if (val.length === 1) {
        const code2 = val.charCodeAt(0);
        if (encoding === "utf8" && code2 < 128 || encoding === "latin1") {
          val = code2;
        }
      }
    } else if (typeof val === "number") {
      val = val & 255;
    } else if (typeof val === "boolean") {
      val = Number(val);
    }
    if (start < 0 || this.length < start || this.length < end) {
      throw new RangeError("Out of range index");
    }
    if (end <= start) {
      return this;
    }
    start = start >>> 0;
    end = end === void 0 ? this.length : end >>> 0;
    if (!val) val = 0;
    let i;
    if (typeof val === "number") {
      for (i = start; i < end; ++i) {
        this[i] = val;
      }
    } else {
      const bytes3 = Buffer4.isBuffer(val) ? val : Buffer4.from(val, encoding);
      const len = bytes3.length;
      if (len === 0) {
        throw new TypeError('The value "' + val + '" is invalid for argument "value"');
      }
      for (i = 0; i < end - start; ++i) {
        this[i + start] = bytes3[i % len];
      }
    }
    return this;
  };
  const errors2 = {};
  function E(sym, getMessage, Base) {
    errors2[sym] = class NodeError extends Base {
      constructor() {
        super();
        Object.defineProperty(this, "message", {
          value: getMessage.apply(this, arguments),
          writable: true,
          configurable: true
        });
        this.name = `${this.name} [${sym}]`;
        this.stack;
        delete this.name;
      }
      get code() {
        return sym;
      }
      set code(value) {
        Object.defineProperty(this, "code", {
          configurable: true,
          enumerable: true,
          value,
          writable: true
        });
      }
      toString() {
        return `${this.name} [${sym}]: ${this.message}`;
      }
    };
  }
  E("ERR_BUFFER_OUT_OF_BOUNDS", function(name) {
    if (name) {
      return `${name} is outside of buffer bounds`;
    }
    return "Attempt to access memory outside buffer bounds";
  }, RangeError);
  E("ERR_INVALID_ARG_TYPE", function(name, actual) {
    return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
  }, TypeError);
  E("ERR_OUT_OF_RANGE", function(str2, range2, input) {
    let msg = `The value of "${str2}" is out of range.`;
    let received = input;
    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
      received = addNumericalSeparator(String(input));
    } else if (typeof input === "bigint") {
      received = String(input);
      if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
        received = addNumericalSeparator(received);
      }
      received += "n";
    }
    msg += ` It must be ${range2}. Received ${received}`;
    return msg;
  }, RangeError);
  function addNumericalSeparator(val) {
    let res = "";
    let i = val.length;
    const start = val[0] === "-" ? 1 : 0;
    for (; i >= start + 4; i -= 3) {
      res = `_${val.slice(i - 3, i)}${res}`;
    }
    return `${val.slice(0, i)}${res}`;
  }
  function checkBounds(buf, offset3, byteLength3) {
    validateNumber(offset3, "offset");
    if (buf[offset3] === void 0 || buf[offset3 + byteLength3] === void 0) {
      boundsError(offset3, buf.length - (byteLength3 + 1));
    }
  }
  function checkIntBI(value, min, max, buf, offset3, byteLength3) {
    if (value > max || value < min) {
      const n = typeof min === "bigint" ? "n" : "";
      let range2;
      if (byteLength3 > 3) {
        if (min === 0 || min === BigInt(0)) {
          range2 = `>= 0${n} and < 2${n} ** ${(byteLength3 + 1) * 8}${n}`;
        } else {
          range2 = `>= -(2${n} ** ${(byteLength3 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength3 + 1) * 8 - 1}${n}`;
        }
      } else {
        range2 = `>= ${min}${n} and <= ${max}${n}`;
      }
      throw new errors2.ERR_OUT_OF_RANGE("value", range2, value);
    }
    checkBounds(buf, offset3, byteLength3);
  }
  function validateNumber(value, name) {
    if (typeof value !== "number") {
      throw new errors2.ERR_INVALID_ARG_TYPE(name, "number", value);
    }
  }
  function boundsError(value, length2, type3) {
    if (Math.floor(value) !== value) {
      validateNumber(value, type3);
      throw new errors2.ERR_OUT_OF_RANGE(type3 || "offset", "an integer", value);
    }
    if (length2 < 0) {
      throw new errors2.ERR_BUFFER_OUT_OF_BOUNDS();
    }
    throw new errors2.ERR_OUT_OF_RANGE(type3 || "offset", `>= ${type3 ? 1 : 0} and <= ${length2}`, value);
  }
  const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
  function base64clean(str2) {
    str2 = str2.split("=")[0];
    str2 = str2.trim().replace(INVALID_BASE64_RE, "");
    if (str2.length < 2) return "";
    while (str2.length % 4 !== 0) {
      str2 = str2 + "=";
    }
    return str2;
  }
  function utf8ToBytes6(string3, units) {
    units = units || Infinity;
    let codePoint;
    const length2 = string3.length;
    let leadSurrogate = null;
    const bytes3 = [];
    for (let i = 0; i < length2; ++i) {
      codePoint = string3.charCodeAt(i);
      if (codePoint > 55295 && codePoint < 57344) {
        if (!leadSurrogate) {
          if (codePoint > 56319) {
            if ((units -= 3) > -1) bytes3.push(239, 191, 189);
            continue;
          } else if (i + 1 === length2) {
            if ((units -= 3) > -1) bytes3.push(239, 191, 189);
            continue;
          }
          leadSurrogate = codePoint;
          continue;
        }
        if (codePoint < 56320) {
          if ((units -= 3) > -1) bytes3.push(239, 191, 189);
          leadSurrogate = codePoint;
          continue;
        }
        codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
      } else if (leadSurrogate) {
        if ((units -= 3) > -1) bytes3.push(239, 191, 189);
      }
      leadSurrogate = null;
      if (codePoint < 128) {
        if ((units -= 1) < 0) break;
        bytes3.push(codePoint);
      } else if (codePoint < 2048) {
        if ((units -= 2) < 0) break;
        bytes3.push(codePoint >> 6 | 192, codePoint & 63 | 128);
      } else if (codePoint < 65536) {
        if ((units -= 3) < 0) break;
        bytes3.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
      } else if (codePoint < 1114112) {
        if ((units -= 4) < 0) break;
        bytes3.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
      } else {
        throw new Error("Invalid code point");
      }
    }
    return bytes3;
  }
  function asciiToBytes(str2) {
    const byteArray = [];
    for (let i = 0; i < str2.length; ++i) {
      byteArray.push(str2.charCodeAt(i) & 255);
    }
    return byteArray;
  }
  function utf16leToBytes(str2, units) {
    let c, hi, lo;
    const byteArray = [];
    for (let i = 0; i < str2.length; ++i) {
      if ((units -= 2) < 0) break;
      c = str2.charCodeAt(i);
      hi = c >> 8;
      lo = c % 256;
      byteArray.push(lo);
      byteArray.push(hi);
    }
    return byteArray;
  }
  function base64ToBytes(str2) {
    return base643.toByteArray(base64clean(str2));
  }
  function blitBuffer(src2, dst, offset3, length2) {
    let i;
    for (i = 0; i < length2; ++i) {
      if (i + offset3 >= dst.length || i >= src2.length) break;
      dst[i + offset3] = src2[i];
    }
    return i;
  }
  function isInstance(obj, type3) {
    return obj instanceof type3 || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type3.name;
  }
  function numberIsNaN(obj) {
    return obj !== obj;
  }
  const hexSliceLookupTable = (function() {
    const alphabet2 = "0123456789abcdef";
    const table = new Array(256);
    for (let i = 0; i < 16; ++i) {
      const i162 = i * 16;
      for (let j = 0; j < 16; ++j) {
        table[i162 + j] = alphabet2[i] + alphabet2[j];
      }
    }
    return table;
  })();
  function defineBigIntMethod(fn) {
    return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
  }
  function BufferBigIntNotDefined() {
    throw new Error("BigInt not supported");
  }
})(buffer2);
function setBigUint645(view, byteOffset, value, isLE6) {
  if (typeof view.setBigUint64 === "function") return view.setBigUint64(byteOffset, value, isLE6);
  const _32n6 = BigInt(32);
  const _u32_max = BigInt(4294967295);
  const wh = Number(value >> _32n6 & _u32_max);
  const wl = Number(value & _u32_max);
  const h = isLE6 ? 4 : 0;
  const l = isLE6 ? 0 : 4;
  view.setUint32(byteOffset + h, wh, isLE6);
  view.setUint32(byteOffset + l, wl, isLE6);
}
var SHA2 = class extends Hash6 {
  constructor(blockLen, outputLen, padOffset, isLE6) {
    super();
    this.blockLen = blockLen;
    this.outputLen = outputLen;
    this.padOffset = padOffset;
    this.isLE = isLE6;
    this.finished = false;
    this.length = 0;
    this.pos = 0;
    this.destroyed = false;
    this.buffer = new Uint8Array(blockLen);
    this.view = createView5(this.buffer);
  }
  update(data) {
    assert4.exists(this);
    const {
      view,
      buffer: buffer3,
      blockLen
    } = this;
    data = toBytes7(data);
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      if (take === blockLen) {
        const dataView = createView5(data);
        for (; blockLen <= len - pos; pos += blockLen) this.process(dataView, pos);
        continue;
      }
      buffer3.set(data.subarray(pos, pos + take), this.pos);
      this.pos += take;
      pos += take;
      if (this.pos === blockLen) {
        this.process(view, 0);
        this.pos = 0;
      }
    }
    this.length += data.length;
    this.roundClean();
    return this;
  }
  digestInto(out) {
    assert4.exists(this);
    assert4.output(out, this);
    this.finished = true;
    const {
      buffer: buffer3,
      view,
      blockLen,
      isLE: isLE6
    } = this;
    let {
      pos
    } = this;
    buffer3[pos++] = 128;
    this.buffer.subarray(pos).fill(0);
    if (this.padOffset > blockLen - pos) {
      this.process(view, 0);
      pos = 0;
    }
    for (let i = pos; i < blockLen; i++) buffer3[i] = 0;
    setBigUint645(view, blockLen - 8, BigInt(this.length * 8), isLE6);
    this.process(view, 0);
    const oview = createView5(out);
    const len = this.outputLen;
    if (len % 4) throw new Error("_sha2: outputLen should be aligned to 32bit");
    const outLen = len / 4;
    const state = this.get();
    if (outLen > state.length) throw new Error("_sha2: outputLen bigger than state");
    for (let i = 0; i < outLen; i++) oview.setUint32(4 * i, state[i], isLE6);
  }
  digest() {
    const {
      buffer: buffer3,
      outputLen
    } = this;
    this.digestInto(buffer3);
    const res = buffer3.slice(0, outputLen);
    this.destroy();
    return res;
  }
  _cloneInto(to) {
    to || (to = new this.constructor());
    to.set(...this.get());
    const {
      blockLen,
      buffer: buffer3,
      length: length2,
      finished: finished2,
      destroyed,
      pos
    } = this;
    to.length = length2;
    to.pos = pos;
    to.finished = finished2;
    to.destroyed = destroyed;
    if (length2 % blockLen) to.buffer.set(buffer3);
    return to;
  }
};
var Chi5 = (a, b, c) => a & b ^ ~a & c;
var Maj5 = (a, b, c) => a & b ^ a & c ^ b & c;
var SHA256_K5 = new Uint32Array([1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298]);
var IV = new Uint32Array([1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225]);
var SHA256_W5 = new Uint32Array(64);
var SHA2565 = class extends SHA2 {
  constructor() {
    super(64, 32, 8, false);
    this.A = IV[0] | 0;
    this.B = IV[1] | 0;
    this.C = IV[2] | 0;
    this.D = IV[3] | 0;
    this.E = IV[4] | 0;
    this.F = IV[5] | 0;
    this.G = IV[6] | 0;
    this.H = IV[7] | 0;
  }
  get() {
    const {
      A,
      B,
      C,
      D,
      E,
      F,
      G,
      H
    } = this;
    return [A, B, C, D, E, F, G, H];
  }
  // prettier-ignore
  set(A, B, C, D, E, F, G, H) {
    this.A = A | 0;
    this.B = B | 0;
    this.C = C | 0;
    this.D = D | 0;
    this.E = E | 0;
    this.F = F | 0;
    this.G = G | 0;
    this.H = H | 0;
  }
  process(view, offset3) {
    for (let i = 0; i < 16; i++, offset3 += 4) SHA256_W5[i] = view.getUint32(offset3, false);
    for (let i = 16; i < 64; i++) {
      const W15 = SHA256_W5[i - 15];
      const W2 = SHA256_W5[i - 2];
      const s0 = rotr5(W15, 7) ^ rotr5(W15, 18) ^ W15 >>> 3;
      const s1 = rotr5(W2, 17) ^ rotr5(W2, 19) ^ W2 >>> 10;
      SHA256_W5[i] = s1 + SHA256_W5[i - 7] + s0 + SHA256_W5[i - 16] | 0;
    }
    let {
      A,
      B,
      C,
      D,
      E,
      F,
      G,
      H
    } = this;
    for (let i = 0; i < 64; i++) {
      const sigma1 = rotr5(E, 6) ^ rotr5(E, 11) ^ rotr5(E, 25);
      const T1 = H + sigma1 + Chi5(E, F, G) + SHA256_K5[i] + SHA256_W5[i] | 0;
      const sigma0 = rotr5(A, 2) ^ rotr5(A, 13) ^ rotr5(A, 22);
      const T2 = sigma0 + Maj5(A, B, C) | 0;
      H = G;
      G = F;
      F = E;
      E = D + T1 | 0;
      D = C;
      C = B;
      B = A;
      A = T1 + T2 | 0;
    }
    A = A + this.A | 0;
    B = B + this.B | 0;
    C = C + this.C | 0;
    D = D + this.D | 0;
    E = E + this.E | 0;
    F = F + this.F | 0;
    G = G + this.G | 0;
    H = H + this.H | 0;
    this.set(A, B, C, D, E, F, G, H);
  }
  roundClean() {
    SHA256_W5.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0);
    this.buffer.fill(0);
  }
};
var SHA2245 = class extends SHA2565 {
  constructor() {
    super();
    this.A = 3238371032 | 0;
    this.B = 914150663 | 0;
    this.C = 812702999 | 0;
    this.D = 4144912697 | 0;
    this.E = 4290775857 | 0;
    this.F = 1750603025 | 0;
    this.G = 1694076839 | 0;
    this.H = 3204075428 | 0;
    this.outputLen = 28;
  }
};
var sha256$1 = wrapConstructor3(() => new SHA2565());
wrapConstructor3(() => new SHA2245());
var NodeScore = class {
  constructor(node) {
    _defineProperty$1(this, "node", void 0);
    _defineProperty$1(this, "score", void 0);
    this.node = node;
    this.score = 0;
  }
};
var RendezvousHash = class {
  constructor() {
    _defineProperty$1(this, "nodes", []);
    this.add(...arguments);
  }
  add() {
    for (var _len = arguments.length, nodes = new Array(_len), _key = 0; _key < _len; _key++) {
      nodes[_key] = arguments[_key];
    }
    for (const node of nodes) {
      this.nodes.push(new NodeScore(buffer2.Buffer.from(node)));
    }
  }
  getNodes() {
    return this.nodes.map((nodeScore) => nodeScore.node.toString());
  }
  get(key) {
    const first = this.getN(1, key)[0];
    return first !== null && first !== void 0 ? first : "";
  }
  getN(n, key) {
    return this.rendezvous256(key).slice(0, n);
  }
  rendezvous256(key) {
    const tuples = this.nodes.map((n) => {
      const hostName = n.node.toString();
      return [hostName, bytesToHex4(sha256$1(`${hostName}${key}`))];
    });
    tuples.sort((t1, t2) => {
      const [aHost, aScore] = t1;
      const [bHost, bScore] = t2;
      if (aScore === bScore) {
        return aHost < bHost ? -1 : 1;
      }
      return aScore < bScore ? -1 : 1;
    });
    return tuples.map((t) => t[0]);
  }
};
var getDefaultStorageNodeSelectorConfig = (config) => ({
  bootstrapNodes: config.network.storageNodes,
  endpoint: config.network.apiEndpoint,
  logger: new Logger()
});
var isNodeHealthy = async function(endpoint2) {
  let logger = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : console;
  try {
    var _health$transcodeStat;
    const resp = await (0, import_axios.default)({
      baseURL: endpoint2,
      url: `/health_check`,
      method: "get",
      timeout: 3e3
    });
    if (resp.status !== 200) {
      logger.warn(`isNodeHealthy: ${endpoint2} returned non-200 status ${resp.status}`);
      return false;
    }
    const health = resp.data.data;
    const avgTranscodeTime = ((_health$transcodeStat = health.transcodeStats) === null || _health$transcodeStat === void 0 ? void 0 : _health$transcodeStat.AvgTranscodeTime) || 0;
    const isSlowTranscode = avgTranscodeTime > 180;
    return health.diskHasSpace && !isSlowTranscode;
  } catch (e) {
    logger.error(`isNodeHealthy: Error checking health: ${e}`);
    return false;
  }
};
var StorageNodeSelector = class {
  constructor(config) {
    var _this$config$bootstra;
    _defineProperty$1(this, "config", void 0);
    _defineProperty$1(this, "logger", void 0);
    _defineProperty$1(this, "nodes", void 0);
    _defineProperty$1(this, "orderedNodes", void 0);
    _defineProperty$1(this, "selectedNode", void 0);
    _defineProperty$1(this, "selectionState", void 0);
    this.config = mergeConfigWithDefaults(config, getDefaultStorageNodeSelectorConfig(productionConfig));
    this.logger = this.config.logger.createPrefixedLogger("[storage-node-selector]");
    this.nodes = (_this$config$bootstra = this.config.bootstrapNodes) !== null && _this$config$bootstra !== void 0 ? _this$config$bootstra : [];
    this.selectionState = "healthy_only";
    this.updateAvailableStorageNodes(this.config.endpoint);
  }
  async updateAvailableStorageNodes(endpoint2) {
    var _responseData$data$ne;
    this.logger.info("Updating list of available storage nodes");
    const healthCheckEndpoint = `${endpoint2}/health_check`;
    const healthCheckResponse = await fetch(healthCheckEndpoint);
    if (!healthCheckResponse.ok) {
      this.logger.warn("API health check did not respond successfully");
      return;
    }
    const responseData = await healthCheckResponse.json();
    const contentNodes = (_responseData$data$ne = responseData.data.network) === null || _responseData$data$ne === void 0 ? void 0 : _responseData$data$ne.content_nodes;
    if (!contentNodes) {
      this.logger.warn("API health check did not contain any available content nodes");
      return;
    }
    this.nodes = contentNodes;
    this.selectionState = "healthy_only";
  }
  async getSelectedNode() {
    let forceReselect = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
    if (this.selectedNode && !forceReselect) {
      return this.selectedNode;
    }
    return await this.select();
  }
  triedSelectingAllNodes() {
    return this.selectionState === "failed_all";
  }
  getNodes(cid) {
    return this.orderNodes(cid);
  }
  async select() {
    var _await$this$selectUnt;
    if (this.selectionState === "failed_all") {
      this.selectionState = "healthy_only";
    }
    this.selectedNode = (_await$this$selectUnt = await this.selectUntilEndOfList()) !== null && _await$this$selectUnt !== void 0 ? _await$this$selectUnt : null;
    this.logger.info("Selected content node", this.selectedNode);
    if (!this.selectedNode) {
      this.logger.info("Selected all healthy nodes. Returning null and starting over next time select() is called");
      this.selectionState = "failed_all";
    }
    return this.selectedNode;
  }
  async selectUntilEndOfList() {
    var _this$orderedNodes;
    if (!((_this$orderedNodes = this.orderedNodes) !== null && _this$orderedNodes !== void 0 && _this$orderedNodes.length)) {
      this.orderedNodes = this.orderNodes((/* @__PURE__ */ new Date()).toString());
    }
    if (this.orderedNodes.length === 0) {
      return void 0;
    }
    const currentNodeIndex = this.selectedNode ? this.orderedNodes.indexOf(this.selectedNode) : -1;
    let selectedNode;
    let nextNodeIndex = currentNodeIndex;
    while (nextNodeIndex !== this.orderedNodes.length - 1) {
      nextNodeIndex++;
      const nextNode = this.orderedNodes[nextNodeIndex];
      if (!nextNode) continue;
      if (await isNodeHealthy(nextNode)) {
        selectedNode = nextNode;
        break;
      }
    }
    return selectedNode;
  }
  orderNodes(key) {
    const endpoints = this.nodes.map((node) => node.endpoint.toLowerCase());
    const hash3 = new RendezvousHash(...endpoints);
    return hash3.getN(this.nodes.length, key);
  }
};
var EthereumContract = class {
  constructor(config) {
    _defineProperty$1(this, "client", void 0);
    this.client = createPublicClient({
      chain: mainnet,
      transport: http(config.rpcEndpoint)
    });
  }
};
var ServiceTypeManagerClient = class extends EthereumContract {
  constructor(config) {
    super(config);
    _defineProperty$1(this, "discoveryNodeServiceType", void 0);
    _defineProperty$1(this, "contentNodeServiceType", void 0);
    _defineProperty$1(this, "contract", void 0);
    _defineProperty$1(this, "getDiscoveryNodeVersion", async () => {
      const version3 = await this.contract.getCurrentVersion({
        serviceType: this.discoveryNodeServiceType
      });
      return hexToString(version3, {
        size: 32
      });
    });
    _defineProperty$1(this, "getContentNodeVersion", async () => {
      const version3 = await this.contract.getCurrentVersion({
        serviceType: this.contentNodeServiceType
      });
      return hexToString(version3, {
        size: 32
      });
    });
    this.discoveryNodeServiceType = config.discoveryNodeServiceType;
    this.contentNodeServiceType = config.contentNodeServiceType;
    this.contract = new ServiceTypeManager(this.client, {
      address: config.addresses.serviceTypeManagerAddress
    });
  }
};
var getDefaultEthereumClientConfig = (servicesConfig) => {
  return {
    rpcEndpoint: servicesConfig.ethereum.rpcEndpoint,
    addresses: servicesConfig.ethereum.addresses,
    client: createPublicClient({
      chain: mainnet,
      transport: http(servicesConfig.ethereum.rpcEndpoint)
    })
  };
};
var getDefaultServiceTypeManagerConfig = (config) => ({
  discoveryNodeServiceType: "0x646973636f766572792d6e6f6465000000000000000000000000000000000000",
  contentNodeServiceType: "0x636f6e74656e742d6e6f64650000000000000000000000000000000000000000",
  ...getDefaultEthereumClientConfig(config)
});
var ServiceProviderFactoryClient = class extends EthereumContract {
  constructor(config) {
    super(config);
    _defineProperty$1(this, "discoveryNodeServiceType", void 0);
    _defineProperty$1(this, "contentNodeServiceType", void 0);
    _defineProperty$1(this, "contract", void 0);
    _defineProperty$1(this, "getDiscoveryNodes", async () => {
      const count = await this.contract.getTotalServiceTypeProviders({
        serviceType: this.discoveryNodeServiceType
      });
      const list = await Promise.all((0, import_lodash.range)(1, Number(count) + 1).map(async (i) => await this.contract.getServiceEndpointInfo({
        serviceType: this.discoveryNodeServiceType,
        index: BigInt(i)
      })));
      return list.filter((_ref) => {
        let [_, endpoint2] = _ref;
        return endpoint2 !== "";
      });
    });
    _defineProperty$1(this, "getContentNodes", async () => {
      const count = await this.contract.getTotalServiceTypeProviders({
        serviceType: this.contentNodeServiceType
      });
      const list = await Promise.all((0, import_lodash.range)(1, Number(count) + 1).map(async (i) => await this.contract.getServiceEndpointInfo({
        serviceType: this.contentNodeServiceType,
        index: BigInt(i)
      })));
      return list.filter((_ref2) => {
        let [_, endpoint2] = _ref2;
        return endpoint2 !== "";
      });
    });
    this.discoveryNodeServiceType = config.discoveryNodeServiceType;
    this.contentNodeServiceType = config.contentNodeServiceType;
    this.contract = new ServiceProviderFactory(this.client, {
      address: config.addresses.serviceProviderFactoryAddress
    });
  }
};
var getDefaultServiceProviderFactoryConfig = (config) => ({
  discoveryNodeServiceType: "0x646973636f766572792d6e6f6465000000000000000000000000000000000000",
  contentNodeServiceType: "0x636f6e74656e742d6e6f64650000000000000000000000000000000000000000",
  ...getDefaultEthereumClientConfig(config)
});
var EthRewardsManagerClient = class extends EthereumContract {
  constructor(config) {
    super(config);
    _defineProperty$1(this, "contract", void 0);
    this.contract = new EthRewardsManager(this.client, {
      address: config.addresses.ethRewardsManagerAddress
    });
  }
};
var getDefaultEthRewardsManagerConfig = (config) => ({
  ...getDefaultEthereumClientConfig(config)
});
var GasFeeSchema = z.union([z.object({
  // Legacy
  gasPrice: z.bigint().optional()
}), z.object({
  // EIP-1559
  maxFeePerGas: z.bigint().optional(),
  maxPriorityFeePerGas: z.bigint().optional()
})]).and(z.object({
  gas: z.bigint().optional()
}));
var BalanceOfSchema = z.object({
  account: EthAddressSchema
});
var PermitSchema = GasFeeSchema.and(z.object({
  args: z.object({
    owner: EthAddressSchema.optional(),
    spender: EthAddressSchema,
    value: z.bigint(),
    deadline: z.bigint().optional()
  }),
  account: z.custom().optional()
}));
var ONE_HOUR_IN_MS = 1e3 * 60 * 60;
var AudiusTokenClient = class {
  constructor(config) {
    _defineProperty$1(this, "contractAddress", void 0);
    _defineProperty$1(this, "audiusWalletClient", void 0);
    _defineProperty$1(this, "walletClient", void 0);
    _defineProperty$1(this, "publicClient", void 0);
    this.audiusWalletClient = config.audiusWalletClient;
    this.walletClient = config.ethWalletClient;
    this.publicClient = config.ethPublicClient;
    this.contractAddress = config.address;
  }
  async permit(params) {
    const {
      args: {
        owner = (await this.audiusWalletClient.getAddresses())[0],
        spender,
        value,
        deadline = BigInt(Date.now() + ONE_HOUR_IN_MS)
      },
      ...other
    } = await parseParams("permit", PermitSchema)(params);
    if (owner === void 0) {
      throw new Error('Parameter "owner" could not be derived from wallet client.');
    }
    const nonce = await this.publicClient.readContract({
      address: this.contractAddress,
      abi: AudiusToken.abi,
      functionName: "nonces",
      args: [owner]
    });
    const typedData = {
      primaryType: "Permit",
      domain: await this.domain(),
      message: {
        owner,
        spender,
        value,
        nonce,
        deadline
      },
      types: AudiusToken.types
    };
    const signature2 = await this.audiusWalletClient.signTypedData(typedData);
    const {
      r,
      s,
      v
    } = parseSignature(signature2);
    const {
      request
    } = await this.publicClient.simulateContract({
      address: this.contractAddress,
      abi: AudiusToken.abi,
      functionName: "permit",
      args: [owner, spender, value, deadline, Number(v), r, s],
      ...other
    });
    return await this.walletClient.writeContract(request);
  }
  async balanceOf(params) {
    const {
      account
    } = await parseParams("balanceOf", BalanceOfSchema)(params);
    const balance = await this.publicClient.readContract({
      address: this.contractAddress,
      abi: AudiusToken.abi,
      functionName: "balanceOf",
      args: [account]
    });
    return BigInt(balance);
  }
  async domain() {
    return {
      name: await this.publicClient.readContract({
        abi: AudiusToken.abi,
        address: this.contractAddress,
        functionName: "name"
      }),
      chainId: BigInt(await this.publicClient.getChainId()),
      verifyingContract: this.contractAddress,
      version: "1"
    };
  }
};
var getDefaultAudiusTokenConfig = (config) => ({
  address: config.ethereum.addresses.audiusTokenAddress
});
var ClaimsManagerClient = class extends EthereumContract {
  constructor(config) {
    super(config);
    _defineProperty$1(this, "contract", void 0);
    this.contract = new ClaimsManager(this.client);
  }
};
var getDefaultClaimsManagerConfig = (config) => ({
  ...getDefaultEthereumClientConfig(config)
});
var DelegateManagerClient = class {
  constructor(config) {
    _defineProperty$1(this, "contractAddress", void 0);
    _defineProperty$1(this, "publicClient", void 0);
    _defineProperty$1(this, "getIncreaseDelegatedStakeEvents", (_ref) => {
      let {
        fromBlock = BigInt(0),
        delegator,
        serviceProvider,
        increaseAmount
      } = _ref;
      const args = {};
      if (delegator) args._delegator = delegator;
      if (serviceProvider) args._serviceProvider = serviceProvider;
      if (increaseAmount) args._increaseAmount = increaseAmount;
      return this.publicClient.getContractEvents({
        address: this.contractAddress,
        abi: DelegateManager.abi,
        eventName: "IncreaseDelegatedStake",
        fromBlock,
        args
      });
    });
    _defineProperty$1(this, "getUndelegateStakeRequestedEvents", (_ref2) => {
      let {
        fromBlock = BigInt(0),
        delegator,
        serviceProvider
      } = _ref2;
      const args = {};
      if (delegator) args._delegator = delegator;
      if (serviceProvider) args._serviceProvider = serviceProvider;
      return this.publicClient.getContractEvents({
        address: this.contractAddress,
        abi: DelegateManager.abi,
        eventName: "UndelegateStakeRequested",
        fromBlock,
        args
      });
    });
    _defineProperty$1(this, "getUndelegateStakeRequestEvaluatedEvents", (_ref3) => {
      let {
        fromBlock = BigInt(0),
        delegator,
        serviceProvider
      } = _ref3;
      const args = {};
      if (delegator) args._delegator = delegator;
      if (serviceProvider) args._serviceProvider = serviceProvider;
      return this.publicClient.getContractEvents({
        address: this.contractAddress,
        abi: DelegateManager.abi,
        eventName: "UndelegateStakeRequestEvaluated",
        fromBlock,
        args
      });
    });
    _defineProperty$1(this, "getUndelegateStakeRequestCancelledEvents", (_ref4) => {
      let {
        fromBlock = BigInt(0),
        delegator,
        serviceProvider
      } = _ref4;
      const args = {};
      if (delegator) args._delegator = delegator;
      if (serviceProvider) args._serviceProvider = serviceProvider;
      return this.publicClient.getContractEvents({
        address: this.contractAddress,
        abi: DelegateManager.abi,
        eventName: "UndelegateStakeRequestCancelled",
        fromBlock,
        args
      });
    });
    _defineProperty$1(this, "getRemoveDelegatorRequestedEvents", (_ref5) => {
      let {
        fromBlock = BigInt(0),
        delegator,
        serviceProvider
      } = _ref5;
      const args = {};
      if (delegator) args._delegator = delegator;
      if (serviceProvider) args._serviceProvider = serviceProvider;
      return this.publicClient.getContractEvents({
        address: this.contractAddress,
        abi: DelegateManager.abi,
        eventName: "RemoveDelegatorRequested",
        fromBlock,
        args
      });
    });
    _defineProperty$1(this, "getRemoveDelegatorEvaluatedEvents", (_ref6) => {
      let {
        fromBlock = BigInt(0),
        delegator,
        serviceProvider,
        unstakedAmount
      } = _ref6;
      const args = {};
      if (delegator) args._delegator = delegator;
      if (serviceProvider) args._serviceProvider = serviceProvider;
      if (unstakedAmount) args._unstakedAmount = unstakedAmount;
      return this.publicClient.getContractEvents({
        address: this.contractAddress,
        abi: DelegateManager.abi,
        eventName: "RemoveDelegatorRequestEvaluated",
        fromBlock,
        args
      });
    });
    _defineProperty$1(this, "getRemoveDelegatorCancelledEvents", (_ref7) => {
      let {
        fromBlock = BigInt(0),
        delegator,
        serviceProvider
      } = _ref7;
      const args = {};
      if (delegator) args._delegator = delegator;
      if (serviceProvider) args._serviceProvider = serviceProvider;
      return this.publicClient.getContractEvents({
        address: this.contractAddress,
        abi: DelegateManager.abi,
        eventName: "RemoveDelegatorRequestCancelled",
        fromBlock,
        args
      });
    });
    _defineProperty$1(this, "getClaimEvents", (_ref8) => {
      let {
        fromBlock = BigInt(0),
        claimer
      } = _ref8;
      const args = {};
      if (claimer) args._claimer = claimer;
      return this.publicClient.getContractEvents({
        address: this.contractAddress,
        abi: DelegateManager.abi,
        eventName: "Claim",
        fromBlock,
        args
      });
    });
    _defineProperty$1(this, "getSlashEvents", (_ref9) => {
      let {
        fromBlock = BigInt(0),
        target
      } = _ref9;
      const args = {};
      if (target) args._target = target;
      return this.publicClient.getContractEvents({
        address: this.contractAddress,
        abi: DelegateManager.abi,
        eventName: "Slash",
        fromBlock,
        args
      });
    });
    _defineProperty$1(this, "getDelegatorsList", (_ref0) => {
      let {
        serviceProviderAddress
      } = _ref0;
      return this.publicClient.readContract({
        address: this.contractAddress,
        abi: DelegateManager.abi,
        functionName: "getDelegatorsList",
        args: [serviceProviderAddress]
      });
    });
    _defineProperty$1(this, "getTotalDelegatedToServiceProvider", (_ref1) => {
      let {
        serviceProviderAddress
      } = _ref1;
      return this.publicClient.readContract({
        address: this.contractAddress,
        abi: DelegateManager.abi,
        functionName: "getTotalDelegatedToServiceProvider",
        args: [serviceProviderAddress]
      });
    });
    _defineProperty$1(this, "getTotalLockedDelegationForServiceProvider", (_ref10) => {
      let {
        serviceProviderAddress
      } = _ref10;
      return this.publicClient.readContract({
        address: this.contractAddress,
        abi: DelegateManager.abi,
        functionName: "getTotalLockedDelegationForServiceProvider",
        args: [serviceProviderAddress]
      });
    });
    _defineProperty$1(this, "getTotalDelegatorStake", (_ref11) => {
      let {
        delegatorAddress
      } = _ref11;
      return this.publicClient.readContract({
        address: this.contractAddress,
        abi: DelegateManager.abi,
        functionName: "getTotalDelegatorStake",
        args: [delegatorAddress]
      });
    });
    _defineProperty$1(this, "getDelegatorStakeForServiceProvider", (_ref12) => {
      let {
        delegatorAddress,
        serviceProviderAddress
      } = _ref12;
      return this.publicClient.readContract({
        address: this.contractAddress,
        abi: DelegateManager.abi,
        functionName: "getDelegatorStakeForServiceProvider",
        args: [delegatorAddress, serviceProviderAddress]
      });
    });
    _defineProperty$1(this, "getPendingRemoveDelegatorRequest", (_ref13) => {
      let {
        delegatorAddress,
        serviceProviderAddress
      } = _ref13;
      return this.publicClient.readContract({
        address: this.contractAddress,
        abi: DelegateManager.abi,
        functionName: "getPendingRemoveDelegatorRequest",
        args: [serviceProviderAddress, delegatorAddress]
      });
    });
    _defineProperty$1(this, "getPendingUndelegateRequest", (_ref14) => {
      let {
        delegatorAddress
      } = _ref14;
      return this.publicClient.readContract({
        address: this.contractAddress,
        abi: DelegateManager.abi,
        functionName: "getPendingUndelegateRequest",
        args: [delegatorAddress]
      });
    });
    _defineProperty$1(this, "getUndelegateLockupDuration", () => this.publicClient.readContract({
      address: this.contractAddress,
      abi: DelegateManager.abi,
      functionName: "getUndelegateLockupDuration"
    }));
    _defineProperty$1(this, "getMaxDelegators", () => this.publicClient.readContract({
      address: this.contractAddress,
      abi: DelegateManager.abi,
      functionName: "getMaxDelegators"
    }));
    _defineProperty$1(this, "getMinDelegationAmount", () => this.publicClient.readContract({
      address: this.contractAddress,
      abi: DelegateManager.abi,
      functionName: "getMinDelegationAmount"
    }));
    _defineProperty$1(this, "getRemoveDelegatorLockupDuration", () => this.publicClient.readContract({
      address: this.contractAddress,
      abi: DelegateManager.abi,
      functionName: "getRemoveDelegatorLockupDuration"
    }));
    _defineProperty$1(this, "getRemoveDelegatorEvalDuration", () => this.publicClient.readContract({
      address: this.contractAddress,
      abi: DelegateManager.abi,
      functionName: "getRemoveDelegatorEvalDuration"
    }));
    _defineProperty$1(this, "getGovernanceAddress", () => this.publicClient.readContract({
      address: this.contractAddress,
      abi: DelegateManager.abi,
      functionName: "getGovernanceAddress"
    }));
    _defineProperty$1(this, "getServiceProviderFactoryAddress", () => this.publicClient.readContract({
      address: this.contractAddress,
      abi: DelegateManager.abi,
      functionName: "getServiceProviderFactoryAddress"
    }));
    _defineProperty$1(this, "getClaimsManagerAddress", () => this.publicClient.readContract({
      address: this.contractAddress,
      abi: DelegateManager.abi,
      functionName: "getClaimsManagerAddress"
    }));
    _defineProperty$1(this, "getStakingAddress", () => this.publicClient.readContract({
      address: this.contractAddress,
      abi: DelegateManager.abi,
      functionName: "getStakingAddress"
    }));
    _defineProperty$1(this, "getSPMinDelegationAmount", (_ref15) => {
      let {
        serviceProviderAddress
      } = _ref15;
      return this.publicClient.readContract({
        address: this.contractAddress,
        abi: DelegateManager.abi,
        functionName: "getSPMinDelegationAmount",
        args: [serviceProviderAddress]
      });
    });
    this.contractAddress = config.address;
    this.publicClient = config.ethPublicClient;
  }
};
var getDefaultDelegateManagerConfig = (config) => ({
  address: config.ethereum.addresses.delegateManagerAddress
});
var StakingClient = class {
  constructor(config) {
    _defineProperty$1(this, "contractAddress", void 0);
    _defineProperty$1(this, "publicClient", void 0);
    _defineProperty$1(this, "token", () => this.publicClient.readContract({
      address: this.contractAddress,
      abi: Staking.abi,
      functionName: "token"
    }));
    _defineProperty$1(this, "totalStaked", () => this.publicClient.readContract({
      address: this.contractAddress,
      abi: Staking.abi,
      functionName: "totalStaked"
    }));
    _defineProperty$1(this, "supportsHistory", () => this.publicClient.readContract({
      address: this.contractAddress,
      abi: Staking.abi,
      functionName: "supportsHistory"
    }));
    _defineProperty$1(this, "totalStakedFor", (_ref) => {
      let {
        account
      } = _ref;
      return this.publicClient.readContract({
        address: this.contractAddress,
        abi: Staking.abi,
        functionName: "totalStakedFor",
        args: [account]
      });
    });
    _defineProperty$1(this, "totalStakedAt", (_ref2) => {
      let {
        blockNumber
      } = _ref2;
      return this.publicClient.readContract({
        address: this.contractAddress,
        abi: Staking.abi,
        functionName: "totalStakedAt",
        args: [blockNumber]
      });
    });
    _defineProperty$1(this, "totalStakedForAt", (_ref3) => {
      let {
        account,
        blockNumber
      } = _ref3;
      return this.publicClient.readContract({
        address: this.contractAddress,
        abi: Staking.abi,
        functionName: "totalStakedForAt",
        args: [account, blockNumber]
      });
    });
    _defineProperty$1(this, "isStaker", (_ref4) => {
      let {
        account
      } = _ref4;
      return this.publicClient.readContract({
        address: this.contractAddress,
        abi: Staking.abi,
        functionName: "isStaker",
        args: [account]
      });
    });
    _defineProperty$1(this, "lastClaimedFor", (_ref5) => {
      let {
        account
      } = _ref5;
      return this.publicClient.readContract({
        address: this.contractAddress,
        abi: Staking.abi,
        functionName: "lastClaimedFor",
        args: [account]
      });
    });
    _defineProperty$1(this, "getDelegateManagerAddress", () => this.publicClient.readContract({
      address: this.contractAddress,
      abi: Staking.abi,
      functionName: "getDelegateManagerAddress"
    }));
    _defineProperty$1(this, "getClaimsManagerAddress", () => this.publicClient.readContract({
      address: this.contractAddress,
      abi: Staking.abi,
      functionName: "getClaimsManagerAddress"
    }));
    _defineProperty$1(this, "getServiceProviderFactoryAddress", () => this.publicClient.readContract({
      address: this.contractAddress,
      abi: Staking.abi,
      functionName: "getServiceProviderFactoryAddress"
    }));
    _defineProperty$1(this, "getGovernanceAddress", () => this.publicClient.readContract({
      address: this.contractAddress,
      abi: Staking.abi,
      functionName: "getGovernanceAddress"
    }));
    this.contractAddress = config.address;
    this.publicClient = config.ethPublicClient;
  }
};
var getDefaultStakingConfig = (config) => ({
  address: config.ethereum.addresses.stakingAddress
});
var TrustedNotifierManagerClient = class extends EthereumContract {
  constructor(config) {
    super(config);
    _defineProperty$1(this, "contract", void 0);
    this.contract = new TrustedNotifierManager(this.client);
  }
};
var getDefaultTrustedNotifierManagerConfig = (config) => ({
  ...getDefaultEthereumClientConfig(config)
});
var range = (length2) => [...Array(length2).keys()];
var zip = (arr) => range(arr[0].length).map((col) => range(arr.length).map((row) => arr[row][col]));
function isMappableKey(key) {
  return ["string", "number", "symbol", "bigint", "boolean"].includes(typeof key);
}
var isRecursiveTuple = (arr) => arr.length === 2 && !Array.isArray(arr[0]) && Array.isArray(arr[1]);
var cartesianRightRecursive = (arr) => arr.length === 0 ? [] : Array.isArray(arr[0]) ? arr.map((_ref) => {
  let [key, val] = _ref;
  return Array.isArray(val) ? (isRecursiveTuple(val) ? cartesianRightRecursive(val) : val).map((ele) => [key, ele].flat()) : [[key, val]];
}).flat() : isRecursiveTuple(arr) ? cartesianRightRecursive(arr[1]).map((ele) => [arr[0], ele]) : arr;
var toMapping = (mapping, shape) => {
  const crr = cartesianRightRecursive(mapping);
  if (crr.length === 0) throw new Error("Invalid mapping: empty");
  const definedShape = shape === void 0 ? [range(crr[0].length - 1), [crr[0].length - 1]] : shape.map((ind) => typeof ind === "number" ? [ind] : ind);
  let leafObjects = [];
  let allSingletons = true;
  const buildMappingRecursively = (keyCartesianSet2, values) => {
    const distinctKeys = Array.from(new Set(keyCartesianSet2[0]).values());
    const keyRows = new Map(distinctKeys.map((key) => [key, []]));
    for (const [i, key] of keyCartesianSet2[0].entries()) keyRows.get(key).push(i);
    if (keyCartesianSet2.length === 1) {
      const ret2 = Object.fromEntries(distinctKeys.map((key) => [key, keyRows.get(key).map((i) => values[i].length === 1 ? values[i][0] : values[i])]));
      if (allSingletons) {
        for (const valRow of keyRows.values()) if (valRow.length > 1) {
          allSingletons = false;
          return ret2;
        }
        leafObjects.push(ret2);
      }
      return ret2;
    }
    const droppedKeyCol = zip(keyCartesianSet2.slice(1));
    return Object.fromEntries(distinctKeys.map((key) => {
      const rows = keyRows.get(key);
      const keyCartesianSubset = zip(rows.map((i) => droppedKeyCol[i]));
      const valuesSubset = rows.map((i) => values[i]);
      return [key, buildMappingRecursively(keyCartesianSubset, valuesSubset)];
    }));
  };
  const cols = zip(crr);
  const getCol = (col) => {
    const colArr = cols[col];
    if (colArr === void 0) throw new Error(`Invalid shape: column ${col} does not exist`);
    return colArr;
  };
  const [keyCartesianSet, leafValues] = definedShape.map((indx) => indx.map((col) => getCol(col)));
  if (keyCartesianSet.length === 0) throw new Error("Invalid shape: empty key set");
  if (leafValues.length === 0) throw new Error("Invalid shape: empty value set");
  for (const keyCol of keyCartesianSet) for (const key of keyCol) if (!isMappableKey(key)) throw new Error(`Invalid key: ${key} in ${keyCol}`);
  const ret = buildMappingRecursively(keyCartesianSet, zip(leafValues));
  if (allSingletons) for (const leafObj of leafObjects) for (const key of Object.keys(leafObj)) leafObj[key] = leafObj[key][0];
  return ret;
};
function constMap(mappingEntries, shape) {
  const mapping = toMapping(mappingEntries, shape);
  const genericMappingFunc = function() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return args.reduce((subMapping, key) => {
      var _subMapping$key$toStr;
      return subMapping ? (_subMapping$key$toStr = subMapping[key.toString()]) !== null && _subMapping$key$toStr !== void 0 ? _subMapping$key$toStr : void 0 : void 0;
    }, mapping);
  };
  return Object.assign(genericMappingFunc, {
    has: function() {
      return genericMappingFunc(...arguments) !== void 0;
    },
    get: function() {
      return genericMappingFunc(...arguments);
    },
    subMap: (key) => mapping[key.toString()]
  });
}
var chainIdAndChainEntries = [
  //Unlike the old sdk, we are not including an "Unset" chain with chainId 0 here because:
  //  * no other types would be associated with it (such as contracts or a platform)
  //  * avoids awkward "chain but not 'Unset'" checks
  //  * "off" is not a TV channel either
  //Instead we'll use `null` for chain and 0 as the chainId where appropriate (e.g. governance VAAs)
  [1, "Solana"],
  [2, "Ethereum"],
  [3, "Terra"],
  [4, "Bsc"],
  [5, "Polygon"],
  [6, "Avalanche"],
  [7, "Oasis"],
  [8, "Algorand"],
  [9, "Aurora"],
  [10, "Fantom"],
  [11, "Karura"],
  [12, "Acala"],
  [13, "Klaytn"],
  [14, "Celo"],
  [15, "Near"],
  [16, "Moonbeam"],
  [17, "Neon"],
  [18, "Terra2"],
  [19, "Injective"],
  [20, "Osmosis"],
  [21, "Sui"],
  [22, "Aptos"],
  [23, "Arbitrum"],
  [24, "Optimism"],
  [25, "Gnosis"],
  [26, "Pythnet"],
  [28, "Xpla"],
  [29, "Btc"],
  [30, "Base"],
  [32, "Sei"],
  [33, "Rootstock"],
  [34, "Scroll"],
  [35, "Mantle"],
  [36, "Blast"],
  [37, "Xlayer"],
  [38, "Linea"],
  [39, "Berachain"],
  [40, "Seievm"],
  [43, "Snaxchain"],
  [44, "Unichain"],
  [45, "Worldchain"],
  [3104, "Wormchain"],
  [4e3, "Cosmoshub"],
  [4001, "Evmos"],
  [4002, "Kujira"],
  [4003, "Neutron"],
  [4004, "Celestia"],
  [4005, "Stargaze"],
  [4006, "Seda"],
  [4007, "Dymension"],
  [4008, "Provenance"],
  [10002, "Sepolia"],
  [10003, "ArbitrumSepolia"],
  [10004, "BaseSepolia"],
  [10005, "OptimismSepolia"],
  [10006, "Holesky"],
  [10007, "PolygonSepolia"],
  [10008, "MonadDevnet"]
];
var [chainIds, chains] = zip(chainIdAndChainEntries);
var chainToChainId = constMap(chainIdAndChainEntries, [1, 0]);
var chainIdToChain = constMap(chainIdAndChainEntries);
var isChain = (chain2) => chainToChainId.has(chain2);
var isChainId = (chainId) => chainIdToChain.has(chainId);
var toChainId = (chain2) => {
  switch (typeof chain2) {
    case "string":
      if (isChain(chain2)) return chainToChainId(chain2);
      break;
    case "number":
      if (isChainId(chain2)) return chain2;
      break;
  }
  throw Error(`Cannot convert to ChainId: ${chain2}`);
};
var HexSchema = z.custom((val) => {
  return z.string().startsWith("0x", "Hex string must start with 0x").regex(/^0x[0-9a-fA-F]+$/, "Hex must only include hexadecimal characters 0-9, a-F").parse(val);
});
var TransferTokensSchema = GasFeeSchema.and(z.object({
  args: z.object({
    from: EthAddressSchema.optional(),
    amount: z.bigint(),
    recipientChain: z.enum(chains).transform(toChainId),
    recipient: HexSchema,
    deadline: z.bigint().optional(),
    arbiterFee: z.bigint().optional()
  }),
  account: z.custom().optional()
}));
var ONE_HOUR_IN_S = 60 * 60;
var AudiusWormholeClient = class {
  constructor(config) {
    _defineProperty$1(this, "contractAddress", void 0);
    _defineProperty$1(this, "audiusWalletClient", void 0);
    _defineProperty$1(this, "walletClient", void 0);
    _defineProperty$1(this, "publicClient", void 0);
    this.audiusWalletClient = config.audiusWalletClient;
    this.walletClient = config.ethWalletClient;
    this.publicClient = config.ethPublicClient;
    this.contractAddress = config.address;
  }
  async transferTokens(params) {
    const {
      args: {
        from: from2 = (await this.audiusWalletClient.getAddresses())[0],
        amount,
        recipientChain,
        recipient,
        deadline = BigInt(Math.round(Date.now() / 1e3) + ONE_HOUR_IN_S),
        arbiterFee = BigInt(0)
      },
      ...other
    } = await parseParams("transferTokens", TransferTokensSchema)(params);
    if (from2 === void 0) {
      throw new Error('Parameter "from" could not be derived from wallet client.');
    }
    const nonce = await this.publicClient.readContract({
      address: this.contractAddress,
      abi: AudiusWormhole.abi,
      functionName: "nonces",
      args: [from2]
    });
    const typedData = {
      primaryType: "TransferTokens",
      domain: await this.domain(),
      message: {
        from: from2,
        amount,
        recipientChain,
        recipient,
        artbiterFee: arbiterFee,
        deadline,
        nonce
      },
      types: AudiusWormhole.types
    };
    const signature2 = await this.audiusWalletClient.signTypedData(typedData);
    const {
      r,
      s,
      v
    } = parseSignature(signature2);
    const {
      request
    } = await this.publicClient.simulateContract({
      address: this.contractAddress,
      abi: AudiusWormhole.abi,
      functionName: "transferTokens",
      args: [from2, amount, recipientChain, recipient, arbiterFee, deadline, Number(v), r, s],
      ...other
    });
    return await this.walletClient.writeContract(request);
  }
  async domain() {
    return {
      name: "AudiusWormholeClient",
      chainId: BigInt(await this.publicClient.getChainId()),
      verifyingContract: this.contractAddress,
      version: "1"
    };
  }
};
var getDefaultWormholeConfig = (config) => ({
  address: config.ethereum.addresses.audiusWormholeAddress
});
var RegistryClient = class extends EthereumContract {
  constructor(config) {
    super(config);
    _defineProperty$1(this, "contract", void 0);
    this.contract = new Registry(this.client);
  }
};
var getDefaultRegistryConfig = (config) => ({
  ...getDefaultEthereumClientConfig(config)
});
var GovernanceClient = class extends EthereumContract {
  constructor(config) {
    super(config);
    _defineProperty$1(this, "contract", void 0);
    this.contract = new Governance(this.client);
  }
};
var getDefaultGovernanceConfig = (config) => ({
  ...getDefaultEthereumClientConfig(config)
});
var EmailEncryptionService = class extends BaseAPI$1 {
  /**
   * Constructs a new EmailEncryptionService instance
   * @param config - SDK configuration object
   * @param audiusWalletClient - Configured AudiusWalletClient instance for cryptographic operations
   */
  constructor(config, audiusWalletClient) {
    super(config);
    _defineProperty$1(this, "audiusWalletClient", void 0);
    _defineProperty$1(this, "symmetricKeyCache", /* @__PURE__ */ new Map());
    _defineProperty$1(this, "sharedSecretCache", /* @__PURE__ */ new Map());
    _defineProperty$1(this, "cacheSize", 1e3);
    this.audiusWalletClient = audiusWalletClient;
  }
  /**
   * Creates a new symmetric key for email encryption
   * @returns The symmetric key as Uint8Array
   */
  createSymmetricKey() {
    return crypto.getRandomValues(new Uint8Array(32));
  }
  /**
   * Encrypts a symmetric key for a user using their public key and shared secret
   * @param userId - The ID of the user to encrypt for
   * @param symmetricKey - The symmetric key to encrypt
   * @returns The encrypted key as a base64 string
   */
  async encryptSymmetricKey(userId, symmetricKey) {
    const userPublicKey = await this.getPublicKey(userId);
    const sharedSecret = await this.audiusWalletClient.getSharedSecret({
      publicKey: userPublicKey
    });
    const encryptedKeyBytes = await CryptoUtils.encrypt(sharedSecret, symmetricKey);
    return base642.encode(encryptedKeyBytes);
  }
  /**
   * Decrypts a symmetric key using cached shared secrets
   * @param encryptedKey - The encrypted symmetric key as a base64 string
   * @param userId - The ID of the user who encrypted the key
   * @param pubkeyBase64 - Optional pre-provided public key to avoid API calls
   * @returns The decrypted symmetric key from cache or new decryption
   * @remarks Uses LRU caching for symmetric keys and shared secrets to improve performance
   */
  async decryptSymmetricKey(encryptedKey, userId, pubkeyBase64) {
    const cacheKey2 = `${userId}-${encryptedKey}`;
    if (!this.symmetricKeyCache.has(cacheKey2)) {
      this.symmetricKeyCache.set(cacheKey2, pubkeyBase64 ? this.decryptSymmetricKeyWithPublicKey(encryptedKey, pubkeyBase64) : this.decryptSymmetricKeyDirect(encryptedKey, userId));
      if (this.symmetricKeyCache.size >= this.cacheSize) {
        this.removeOldestEntries(this.symmetricKeyCache);
      }
      if (this.sharedSecretCache.size >= this.cacheSize) {
        this.removeOldestEntries(this.sharedSecretCache);
      }
    }
    return this.symmetricKeyCache.get(cacheKey2);
  }
  /**
   * Encrypts an email using a symmetric key
   * @param email - The email to encrypt
   * @param symmetricKey - The symmetric key to use
   * @returns The encrypted email as a base64 string
   */
  async encryptEmail(email, symmetricKey) {
    const encryptedBytes = await CryptoUtils.encryptString(symmetricKey, email);
    return base642.encode(encryptedBytes);
  }
  /**
   * Decrypts an email using a symmetric key
   * @param encryptedEmail - The encrypted email as a base64 string
   * @param symmetricKey - The symmetric key to use
   * @returns The decrypted email
   */
  async decryptEmail(encryptedEmail, symmetricKey) {
    return await CryptoUtils.decryptString(symmetricKey, base642.decode(encryptedEmail));
  }
  /**
   * Creates and distributes a symmetric key between an email owner and recipients
   * @param emailOwnerId - The ID of the email owner
   * @param receivingIds - List of user IDs who will receive access
   * @param grantorId - The ID of the user granting access
   * @returns The encrypted symmetric keys for storage
   * @remarks Includes the email owner in the recipient list automatically
   */
  async createSharedKey(emailOwnerId, receivingIds, grantorId) {
    const symmetricKey = this.createSymmetricKey();
    const allRecipientIds = [emailOwnerId, ...receivingIds];
    const receiverEncryptedKeys = await Promise.all(allRecipientIds.map(async (receivingId) => {
      const encryptedKey = await this.encryptSymmetricKey(receivingId, symmetricKey);
      return {
        receivingId,
        encryptedKey,
        grantorId
      };
    }));
    return {
      symmetricKey,
      receiverEncryptedKeys
    };
  }
  /**
   * Encrypts emails for multiple recipients using a shared symmetric key
   * @param emailOwnerId - The ID of the email owner
   * @param receivingIds - List of user IDs who will receive access
   * @param grantorId - The ID of the user granting access
   * @param emails - List of emails to encrypt
   * @returns Object containing encrypted emails and encrypted symmetric keys
   */
  async encryptEmails(emailOwnerId, receivingIds, grantorId, emails) {
    const {
      symmetricKey,
      receiverEncryptedKeys
    } = await this.createSharedKey(emailOwnerId, receivingIds, grantorId);
    const encryptedEmails = await Promise.all(emails.map((email) => this.encryptEmail(email, symmetricKey)));
    return {
      encryptedEmails,
      receiverEncryptedKeys
    };
  }
  // Caching Infrastructure
  /**
   * Removes oldest entries from a cache map when size limit is reached
   * @param map - The cache map to prune
   * @remarks Implements LRU-like cache eviction by removing oldest 1/3 of entries
   * @private Internal cache maintenance utility
   */
  removeOldestEntries(map) {
    const entries = Array.from(map.keys());
    entries.slice(0, this.cacheSize / 3).forEach((key) => map.delete(key));
  }
  // Core Decryption Implementations
  /**
   * Direct decryption path using user ID to fetch public key
   * @param encryptedKey - Base64 encoded encrypted symmetric key
   * @param userId - ID of user who encrypted the key
   * @returns Decrypted symmetric key bytes
   * @private Internal decryption implementation
   */
  async decryptSymmetricKeyDirect(encryptedKey, userId) {
    const userPublicKey = await this.getPublicKey(userId);
    const sharedSecret = await this.getSharedSecretWithCache(userPublicKey);
    return await CryptoUtils.decrypt(sharedSecret, base642.decode(encryptedKey));
  }
  /**
   * Optimized decryption path using pre-provided public key
   * @param encryptedKey - Base64 encoded encrypted symmetric key
   * @param pubkeyBase64 - Base64 encoded public key of encrypting user
   * @returns Decrypted symmetric key bytes
   * @private Internal decryption implementation
   * @remarks Bypasses public key API call when key is already known
   */
  async decryptSymmetricKeyWithPublicKey(encryptedKey, pubkeyBase64) {
    const userPublicKey = base642.decode(pubkeyBase64);
    const sharedSecret = await this.getSharedSecretWithCache(userPublicKey);
    return await CryptoUtils.decrypt(sharedSecret, base642.decode(encryptedKey));
  }
  /**
   * Gets the public key for a user from the comms API
   * @param userId - The ID of the user to get the public key for
   * @returns The user's public key as a Uint8Array
   * @private Internal API call wrapper
   */
  async getPublicKey(userId) {
    const response = await this.request({
      path: `/comms/pubkey/${userId}`,
      method: "GET",
      headers: {}
    });
    const json = await response.json();
    return base642.decode(json.data);
  }
  /**
   * Retrieves shared secret with caching mechanism
   * @param publicKey - Public key to derive shared secret from
   * @returns Cached shared secret promise
   * @private Manages LRU cache for shared secrets
   */
  async getSharedSecretWithCache(publicKey5) {
    const cacheKey2 = Buffer.from(publicKey5).toString("base64");
    if (!this.sharedSecretCache.has(cacheKey2)) {
      this.sharedSecretCache.set(cacheKey2, this.audiusWalletClient.getSharedSecret({
        publicKey: publicKey5
      }));
    }
    return this.sharedSecretCache.get(cacheKey2);
  }
};
var isApiKeyValid = (apiKey2) => {
  try {
    if (apiKey2.length !== 40) {
      return false;
    }
    const hexadecimalRegex = /^[0-9a-fA-F]+$/;
    return hexadecimalRegex.test(apiKey2);
  } catch (_e) {
    return false;
  }
};
var DEVELOPER_APP_MAX_DESCRIPTION_LENGTH = 128;
var DEVELOPER_APP_MAX_IMAGE_URL_LENGTH = 2e3;
var DEVELOPER_APP_IMAGE_URL_REGEX = /^(https?):\/\//i;
var CreateDeveloperAppSchema = z.object({
  name: z.string(),
  description: z.optional(z.string().max(DEVELOPER_APP_MAX_DESCRIPTION_LENGTH)),
  imageUrl: z.optional(z.string().max(DEVELOPER_APP_MAX_IMAGE_URL_LENGTH).refine((value) => DEVELOPER_APP_IMAGE_URL_REGEX.test(value), {
    message: "Invalid URL"
  })),
  userId: HashId
});
var UpdateDeveloperAppSchema = z.object({
  appApiKey: z.custom((data) => {
    return isApiKeyValid(data);
  }),
  name: z.string(),
  description: z.optional(z.string().max(DEVELOPER_APP_MAX_DESCRIPTION_LENGTH)),
  imageUrl: z.optional(z.string().max(DEVELOPER_APP_MAX_IMAGE_URL_LENGTH).refine((value) => DEVELOPER_APP_IMAGE_URL_REGEX.test(value), {
    message: "Invalid URL"
  })),
  userId: HashId
});
var DeleteDeveloperAppSchema = z.object({
  userId: HashId,
  appApiKey: z.custom((data) => {
    return isApiKeyValid(data);
  })
});
var DeveloperAppsApi = class extends DeveloperAppsApi$1 {
  constructor(config, entityManager) {
    super(config);
    _defineProperty$1(this, "entityManager", void 0);
    this.entityManager = entityManager;
  }
  /**
   * Create a developer app
   */
  async createDeveloperApp(params, advancedOptions) {
    const {
      name,
      userId,
      description,
      imageUrl
    } = await parseParams("createDeveloperApp", CreateDeveloperAppSchema)(params);
    const privateKey = generatePrivateKey2();
    const address = privateKeyToAddress(privateKey);
    const wallet = createAppWalletClient({
      apiKey: address,
      apiSecret: privateKey
    });
    const unixTs = Math.round((/* @__PURE__ */ new Date()).getTime() / 1e3);
    const message = `Creating Audius developer app at ${unixTs}`;
    const signature2 = await wallet.signMessage({
      message
    });
    const response = await this.entityManager.manageEntity({
      userId,
      entityType: EntityType.DEVELOPER_APP,
      entityId: 0,
      action: Action.CREATE,
      metadata: JSON.stringify({
        name,
        description,
        image_url: imageUrl,
        app_signature: {
          message,
          signature: signature2
        }
      }),
      ...advancedOptions
    });
    const apiKey2 = address.slice(2).toLowerCase();
    const apiSecret = privateKey.slice(2).toLowerCase();
    return {
      ...response,
      apiKey: apiKey2,
      apiSecret
    };
  }
  /**
   * Update a developer app
   */
  async updateDeveloperApp(params, advancedOptions) {
    const {
      appApiKey,
      name,
      userId,
      description,
      imageUrl
    } = await parseParams("updateDeveloperApp", UpdateDeveloperAppSchema)(params);
    const response = await this.entityManager.manageEntity({
      userId,
      entityType: EntityType.DEVELOPER_APP,
      entityId: 0,
      action: Action.UPDATE,
      metadata: JSON.stringify({
        address: `0x${appApiKey}`,
        name,
        description,
        image_url: imageUrl
      }),
      ...advancedOptions
    });
    return {
      ...response
    };
  }
  /**
   * Delete a developer app
   */
  async deleteDeveloperApp(params) {
    const {
      userId,
      appApiKey
    } = await parseParams("deleteDeveloperApp", DeleteDeveloperAppSchema)(params);
    return await this.entityManager.manageEntity({
      userId,
      entityType: EntityType.DEVELOPER_APP,
      entityId: 0,
      action: Action.DELETE,
      metadata: JSON.stringify({
        address: `0x${appApiKey}`
      })
    });
  }
};
var EventMetadataSchema = z.object({
  userId: z.number(),
  eventId: z.number(),
  eventType: z.nativeEnum(EventEventTypeEnum).optional(),
  entityType: z.nativeEnum(EventEntityTypeEnum).optional(),
  entityId: z.number().optional(),
  endDate: z.string().optional(),
  eventData: z.record(z.any()).optional()
});
var CreateEventSchema = EventMetadataSchema.omit({
  eventId: true
}).extend({
  eventId: z.number().optional()
  // Make eventId optional for creation
});
var UpdateEventSchema = EventMetadataSchema.pick({
  userId: true,
  eventId: true,
  endDate: true,
  eventData: true
});
var DeleteEventSchema = EventMetadataSchema.pick({
  userId: true,
  eventId: true
});
var EventsApi = class extends EventsApi$1 {
  constructor(configuration, entityManager, logger) {
    super(configuration);
    _defineProperty$1(this, "entityManager", void 0);
    _defineProperty$1(this, "logger", void 0);
    this.entityManager = entityManager;
    this.logger = logger;
    this.logger = logger.createPrefixedLogger("[events-api]");
  }
  async generateEventId() {
    const response = await this.getUnclaimedEventID();
    const {
      data: unclaimedId
    } = response;
    if (!unclaimedId) {
      return Math.floor(Math.random() * 1e6);
    }
    return decodeHashId(unclaimedId);
  }
  /**
   * Create an event
   */
  async createEvent(params) {
    const parsedParameters = await parseParams("createEvent", CreateEventSchema)(params);
    const {
      userId,
      eventId,
      eventType,
      entityType,
      entityId: eventEntityId,
      endDate,
      eventData
    } = parsedParameters;
    const entityId = eventId !== null && eventId !== void 0 ? eventId : await this.generateEventId();
    const response = await this.entityManager.manageEntity({
      entityId,
      userId,
      entityType: EntityType.EVENT,
      action: Action.CREATE,
      metadata: JSON.stringify({
        cid: "",
        data: (0, import_snakecase_keys.default)({
          eventType,
          entityType,
          entityId: eventEntityId,
          endDate,
          eventData
        })
      })
    });
    this.logger.info("Successfully created a event");
    return response;
  }
  /**
   * Update an event
   */
  async updateEvent(params) {
    const parsedParameters = await parseParams("updateEvent", UpdateEventSchema)(params);
    const {
      userId,
      eventId,
      endDate,
      eventData
    } = parsedParameters;
    const response = await this.entityManager.manageEntity({
      entityId: eventId,
      userId,
      entityType: EntityType.EVENT,
      action: Action.UPDATE,
      metadata: JSON.stringify({
        cid: "",
        data: (0, import_snakecase_keys.default)({
          endDate,
          eventData
        })
      })
    });
    this.logger.info("Successfully updated the event");
    return response;
  }
  /**
   * Delete an event
   */
  async deleteEvent(params) {
    const parsedParameters = await parseParams("deleteEvent", DeleteEventSchema)(params);
    const {
      userId,
      eventId
    } = parsedParameters;
    const response = await this.entityManager.manageEntity({
      entityId: eventId,
      userId,
      entityType: EntityType.EVENT,
      action: Action.DELETE,
      metadata: ""
    });
    this.logger.info("Successfully deleted the event");
    return response;
  }
};
var BASE_PATH = "/v1/full".replace(/\/+$/, "");
var Configuration = class {
  constructor() {
    let configuration = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    _defineProperty$1(this, "configuration", void 0);
    this.configuration = configuration;
  }
  set config(configuration) {
    this.configuration = configuration;
  }
  get basePath() {
    return this.configuration.basePath != null ? this.configuration.basePath : BASE_PATH;
  }
  get fetchApi() {
    return this.configuration.fetchApi;
  }
  get middleware() {
    return this.configuration.middleware || [];
  }
  get queryParamsStringify() {
    return this.configuration.queryParamsStringify || querystring;
  }
  get username() {
    return this.configuration.username;
  }
  get password() {
    return this.configuration.password;
  }
  get apiKey() {
    const apiKey2 = this.configuration.apiKey;
    if (apiKey2) {
      return typeof apiKey2 === "function" ? apiKey2 : () => apiKey2;
    }
    return void 0;
  }
  get accessToken() {
    const accessToken = this.configuration.accessToken;
    if (accessToken) {
      return typeof accessToken === "function" ? accessToken : async () => accessToken;
    }
    return void 0;
  }
  get headers() {
    return this.configuration.headers;
  }
  get credentials() {
    return this.configuration.credentials;
  }
};
var DefaultConfig = new Configuration();
var BaseAPI = class {
  constructor() {
    let configuration = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : DefaultConfig;
    _defineProperty$1(this, "configuration", void 0);
    _defineProperty$1(this, "middleware", void 0);
    _defineProperty$1(this, "fetchApi", async (url, init) => {
      let fetchParams = {
        url,
        init
      };
      for (const middleware of this.middleware) {
        if (middleware.pre) {
          fetchParams = await middleware.pre({
            fetch: this.fetchApi,
            ...fetchParams
          }) || fetchParams;
        }
      }
      let response = void 0;
      try {
        response = await (this.configuration.fetchApi || fetch)(fetchParams.url, fetchParams.init);
      } catch (e) {
        for (const middleware of this.middleware) {
          if (middleware.onError) {
            response = await middleware.onError({
              fetch: this.fetchApi,
              url: fetchParams.url,
              init: fetchParams.init,
              error: e,
              response: response ? response.clone() : void 0
            }) || response;
          }
        }
        if (response === void 0) {
          if (e instanceof Error) {
            throw new FetchError(e, "The request failed and the interceptors did not return an alternative response");
          } else {
            throw e;
          }
        }
      }
      for (const middleware of this.middleware) {
        if (middleware.post) {
          response = await middleware.post({
            fetch: this.fetchApi,
            url: fetchParams.url,
            init: fetchParams.init,
            response: response.clone()
          }) || response;
        }
      }
      return response;
    });
    this.configuration = configuration;
    this.middleware = configuration.middleware;
  }
  /** @hidden */
  withMiddleware() {
    const next = this.clone();
    next.middleware = next.middleware.concat(...arguments);
    return next;
  }
  /** @hidden */
  withPreMiddleware() {
    for (var _len = arguments.length, preMiddlewares = new Array(_len), _key = 0; _key < _len; _key++) {
      preMiddlewares[_key] = arguments[_key];
    }
    const middlewares = preMiddlewares.map((pre) => ({
      pre
    }));
    return this.withMiddleware(...middlewares);
  }
  /** @hidden */
  withPostMiddleware() {
    for (var _len2 = arguments.length, postMiddlewares = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      postMiddlewares[_key2] = arguments[_key2];
    }
    const middlewares = postMiddlewares.map((post) => ({
      post
    }));
    return this.withMiddleware(...middlewares);
  }
  /** @hidden */
  async request(context, initOverrides) {
    const {
      url,
      init
    } = await this.createFetchParams(context, initOverrides);
    const response = await this.fetchApi(url, init);
    if (response && response.status >= 200 && response.status < 300) {
      return response;
    }
    throw new ResponseError(response, "Response returned an error code");
  }
  async createFetchParams(context, initOverrides) {
    let url = this.configuration.basePath + context.path;
    if (context.query !== void 0 && Object.keys(context.query).length !== 0) {
      url += "?" + this.configuration.queryParamsStringify(context.query);
    }
    const headers = Object.assign({}, this.configuration.headers, context.headers);
    Object.keys(headers).forEach((key) => headers[key] === void 0 ? delete headers[key] : {});
    const initOverrideFn = typeof initOverrides === "function" ? initOverrides : async () => initOverrides;
    const initParams = {
      method: context.method,
      headers,
      body: context.body,
      credentials: this.configuration.credentials
    };
    const overriddenInit = {
      ...initParams,
      ...await initOverrideFn({
        init: initParams,
        context
      })
    };
    const init = {
      ...overriddenInit,
      body: isFormData(overriddenInit.body) || overriddenInit.body instanceof URLSearchParams || isBlob(overriddenInit.body) || isString(overriddenInit.body) ? overriddenInit.body : JSON.stringify(overriddenInit.body)
    };
    return {
      url,
      init
    };
  }
  /**
   * Create a shallow clone of `this` by constructing a new instance
   * and then shallow cloning data members.
   */
  clone() {
    const constructor = this.constructor;
    const next = new constructor(this.configuration);
    next.middleware = this.middleware.slice();
    return next;
  }
};
function isBlob(value) {
  return typeof Blob !== "undefined" && value instanceof Blob;
}
function isFormData(value) {
  return typeof FormData !== "undefined" && value instanceof FormData;
}
function isString(value) {
  return typeof value === "string";
}
var ResponseError = class extends Error {
  constructor(response, msg) {
    super(msg);
    _defineProperty$1(this, "response", void 0);
    _defineProperty$1(this, "name", "ResponseError");
    this.response = response;
  }
};
var FetchError = class extends Error {
  constructor(cause, msg) {
    super(msg, {
      cause
    });
    _defineProperty$1(this, "name", "FetchError");
  }
};
var RequiredError = class extends Error {
  constructor(field, msg) {
    super(msg);
    _defineProperty$1(this, "field", void 0);
    _defineProperty$1(this, "name", "RequiredError");
    this.field = field;
  }
};
var COLLECTION_FORMATS = {
  csv: ",",
  ssv: " ",
  tsv: "	",
  pipes: "|"
};
function exists3(json, key) {
  const value = json[key];
  return value !== null && value !== void 0;
}
function querystring(params) {
  let prefix = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
  return Object.keys(params).sort().map((key) => querystringSingleKey(key, params[key], prefix)).filter((part) => part.length > 0).join("&");
}
function querystringSingleKey(key, value) {
  let keyPrefix = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "";
  const fullKey = keyPrefix + (keyPrefix.length ? `[${key}]` : key);
  if (value instanceof Array) {
    const multiValue = value.map((singleValue) => encodeURIComponent(String(singleValue))).join(`&${encodeURIComponent(fullKey)}=`);
    return `${encodeURIComponent(fullKey)}=${multiValue}`;
  }
  if (value instanceof Set) {
    const valueAsArray = Array.from(value);
    return querystringSingleKey(key, valueAsArray, keyPrefix);
  }
  if (value instanceof Date) {
    return `${encodeURIComponent(fullKey)}=${encodeURIComponent(value.toISOString())}`;
  }
  if (value instanceof Object) {
    return querystring(value, fullKey);
  }
  return `${encodeURIComponent(fullKey)}=${encodeURIComponent(String(value))}`;
}
function mapValues(data, fn) {
  return Object.keys(data).reduce((acc, key) => ({
    ...acc,
    [key]: fn(data[key])
  }), {});
}
function canConsumeForm(consumes) {
  for (const consume of consumes) {
    if ("multipart/form-data" === consume.contentType) {
      return true;
    }
  }
  return false;
}
var JSONApiResponse = class {
  constructor(raw) {
    let transformer = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : (jsonValue) => jsonValue;
    _defineProperty$1(this, "raw", void 0);
    _defineProperty$1(this, "transformer", void 0);
    this.raw = raw;
    this.transformer = transformer;
  }
  async value() {
    return this.transformer(await this.raw.json());
  }
};
var VoidApiResponse = class {
  constructor(raw) {
    _defineProperty$1(this, "raw", void 0);
    this.raw = raw;
  }
  async value() {
    return void 0;
  }
};
var BlobApiResponse = class {
  constructor(raw) {
    _defineProperty$1(this, "raw", void 0);
    this.raw = raw;
  }
  async value() {
    return await this.raw.blob();
  }
};
var TextApiResponse = class {
  constructor(raw) {
    _defineProperty$1(this, "raw", void 0);
    this.raw = raw;
  }
  async value() {
    return await this.raw.text();
  }
};
function instanceOfAccess(value) {
  let isInstance = true;
  isInstance = isInstance && "stream" in value && value["stream"] !== void 0;
  isInstance = isInstance && "download" in value && value["download"] !== void 0;
  return isInstance;
}
function AccessFromJSON(json) {
  return AccessFromJSONTyped(json);
}
function AccessFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "stream": json["stream"],
    "download": json["download"]
  };
}
function AccessToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "stream": value.stream,
    "download": value.download
  };
}
function instanceOfFollowGate(value) {
  let isInstance = true;
  isInstance = isInstance && "followUserId" in value && value["followUserId"] !== void 0;
  return isInstance;
}
function FollowGateFromJSON(json) {
  return FollowGateFromJSONTyped(json);
}
function FollowGateFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "followUserId": json["follow_user_id"]
  };
}
function FollowGateToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "follow_user_id": value.followUserId
  };
}
var NftCollectionChainEnum = {
  Eth: "eth",
  Sol: "sol"
};
var NftCollectionStandardEnum = {
  Erc721: "ERC721",
  Erc1155: "ERC1155"
};
function instanceOfNftCollection(value) {
  let isInstance = true;
  isInstance = isInstance && "chain" in value && value["chain"] !== void 0;
  isInstance = isInstance && "address" in value && value["address"] !== void 0;
  isInstance = isInstance && "name" in value && value["name"] !== void 0;
  return isInstance;
}
function NftCollectionFromJSON(json) {
  return NftCollectionFromJSONTyped(json);
}
function NftCollectionFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "chain": json["chain"],
    "standard": !exists3(json, "standard") ? void 0 : json["standard"],
    "address": json["address"],
    "name": json["name"],
    "imageUrl": !exists3(json, "imageUrl") ? void 0 : json["imageUrl"],
    "externalLink": !exists3(json, "externalLink") ? void 0 : json["externalLink"]
  };
}
function NftCollectionToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "chain": value.chain,
    "standard": value.standard,
    "address": value.address,
    "name": value.name,
    "imageUrl": value.imageUrl,
    "externalLink": value.externalLink
  };
}
function instanceOfNftGate(value) {
  let isInstance = true;
  isInstance = isInstance && "nftCollection" in value && value["nftCollection"] !== void 0;
  return isInstance;
}
function NftGateFromJSON(json) {
  return NftGateFromJSONTyped(json);
}
function NftGateFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "nftCollection": NftCollectionFromJSON(json["nft_collection"])
  };
}
function NftGateToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "nft_collection": NftCollectionToJSON(value.nftCollection)
  };
}
function instanceOfUsdcGate(value) {
  let isInstance = true;
  isInstance = isInstance && "splits" in value && value["splits"] !== void 0;
  isInstance = isInstance && "price" in value && value["price"] !== void 0;
  return isInstance;
}
function UsdcGateFromJSON(json) {
  return UsdcGateFromJSONTyped(json);
}
function UsdcGateFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "splits": json["splits"],
    "price": json["price"]
  };
}
function UsdcGateToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "splits": value.splits,
    "price": value.price
  };
}
function instanceOfPurchaseGate(value) {
  let isInstance = true;
  isInstance = isInstance && "usdcPurchase" in value && value["usdcPurchase"] !== void 0;
  return isInstance;
}
function PurchaseGateFromJSON(json) {
  return PurchaseGateFromJSONTyped(json);
}
function PurchaseGateFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "usdcPurchase": UsdcGateFromJSON(json["usdc_purchase"])
  };
}
function PurchaseGateToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "usdc_purchase": UsdcGateToJSON(value.usdcPurchase)
  };
}
function instanceOfTipGate(value) {
  let isInstance = true;
  isInstance = isInstance && "tipUserId" in value && value["tipUserId"] !== void 0;
  return isInstance;
}
function TipGateFromJSON(json) {
  return TipGateFromJSONTyped(json);
}
function TipGateFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "tipUserId": json["tip_user_id"]
  };
}
function TipGateToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "tip_user_id": value.tipUserId
  };
}
function instanceOfExtendedTokenGate(value) {
  let isInstance = true;
  isInstance = isInstance && "tokenMint" in value && value["tokenMint"] !== void 0;
  isInstance = isInstance && "tokenAmount" in value && value["tokenAmount"] !== void 0;
  return isInstance;
}
function ExtendedTokenGateFromJSON(json) {
  return ExtendedTokenGateFromJSONTyped(json);
}
function ExtendedTokenGateFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "tokenMint": json["token_mint"],
    "tokenAmount": json["token_amount"]
  };
}
function ExtendedTokenGateToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "token_mint": value.tokenMint,
    "token_amount": value.tokenAmount
  };
}
function instanceOfTokenGate(value) {
  let isInstance = true;
  isInstance = isInstance && "tokenGate" in value && value["tokenGate"] !== void 0;
  return isInstance;
}
function TokenGateFromJSON(json) {
  return TokenGateFromJSONTyped(json);
}
function TokenGateFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "tokenGate": ExtendedTokenGateFromJSON(json["token_gate"])
  };
}
function TokenGateToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "token_gate": ExtendedTokenGateToJSON(value.tokenGate)
  };
}
function AccessGateFromJSON(json) {
  return AccessGateFromJSONTyped(json);
}
function AccessGateFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    ...FollowGateFromJSONTyped(json),
    ...NftGateFromJSONTyped(json),
    ...PurchaseGateFromJSONTyped(json),
    ...TipGateFromJSONTyped(json),
    ...TokenGateFromJSONTyped(json)
  };
}
function AccessGateToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  if (instanceOfFollowGate(value)) {
    return FollowGateToJSON(value);
  }
  if (instanceOfNftGate(value)) {
    return NftGateToJSON(value);
  }
  if (instanceOfPurchaseGate(value)) {
    return PurchaseGateToJSON(value);
  }
  if (instanceOfTipGate(value)) {
    return TipGateToJSON(value);
  }
  if (instanceOfTokenGate(value)) {
    return TokenGateToJSON(value);
  }
  return {};
}
function instanceOfAccountCollectionUser(value) {
  let isInstance = true;
  isInstance = isInstance && "id" in value && value["id"] !== void 0;
  isInstance = isInstance && "handle" in value && value["handle"] !== void 0;
  return isInstance;
}
function AccountCollectionUserFromJSON(json) {
  return AccountCollectionUserFromJSONTyped(json);
}
function AccountCollectionUserFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "id": json["id"],
    "handle": json["handle"],
    "isDeactivated": !exists3(json, "is_deactivated") ? void 0 : json["is_deactivated"]
  };
}
function AccountCollectionUserToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "id": value.id,
    "handle": value.handle,
    "is_deactivated": value.isDeactivated
  };
}
function instanceOfAccountCollection(value) {
  let isInstance = true;
  isInstance = isInstance && "id" in value && value["id"] !== void 0;
  isInstance = isInstance && "isAlbum" in value && value["isAlbum"] !== void 0;
  isInstance = isInstance && "name" in value && value["name"] !== void 0;
  isInstance = isInstance && "permalink" in value && value["permalink"] !== void 0;
  isInstance = isInstance && "user" in value && value["user"] !== void 0;
  return isInstance;
}
function AccountCollectionFromJSON(json) {
  return AccountCollectionFromJSONTyped(json);
}
function AccountCollectionFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "id": json["id"],
    "isAlbum": json["is_album"],
    "name": json["name"],
    "permalink": json["permalink"],
    "user": AccountCollectionUserFromJSON(json["user"])
  };
}
function AccountCollectionToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "id": value.id,
    "is_album": value.isAlbum,
    "name": value.name,
    "permalink": value.permalink,
    "user": AccountCollectionUserToJSON(value.user)
  };
}
function instanceOfPlaylistLibrary(value) {
  let isInstance = true;
  return isInstance;
}
function PlaylistLibraryFromJSON(json) {
  return PlaylistLibraryFromJSONTyped(json);
}
function PlaylistLibraryFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "contents": !exists3(json, "contents") ? void 0 : json["contents"]
  };
}
function PlaylistLibraryToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "contents": value.contents
  };
}
function instanceOfCoverPhoto(value) {
  let isInstance = true;
  return isInstance;
}
function CoverPhotoFromJSON(json) {
  return CoverPhotoFromJSONTyped(json);
}
function CoverPhotoFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "_640x": !exists3(json, "640x") ? void 0 : json["640x"],
    "_2000x": !exists3(json, "2000x") ? void 0 : json["2000x"]
  };
}
function CoverPhotoToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "640x": value._640x,
    "2000x": value._2000x
  };
}
function instanceOfCoverPhotoFull(value) {
  let isInstance = true;
  return isInstance;
}
function CoverPhotoFullFromJSON(json) {
  return CoverPhotoFullFromJSONTyped(json);
}
function CoverPhotoFullFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "_640x": !exists3(json, "640x") ? void 0 : json["640x"],
    "_2000x": !exists3(json, "2000x") ? void 0 : json["2000x"],
    "mirrors": !exists3(json, "mirrors") ? void 0 : json["mirrors"]
  };
}
function CoverPhotoFullToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "640x": value._640x,
    "2000x": value._2000x,
    "mirrors": value.mirrors
  };
}
function instanceOfProfilePicture(value) {
  let isInstance = true;
  return isInstance;
}
function ProfilePictureFromJSON(json) {
  return ProfilePictureFromJSONTyped(json);
}
function ProfilePictureFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "_150x150": !exists3(json, "150x150") ? void 0 : json["150x150"],
    "_480x480": !exists3(json, "480x480") ? void 0 : json["480x480"],
    "_1000x1000": !exists3(json, "1000x1000") ? void 0 : json["1000x1000"]
  };
}
function ProfilePictureToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "150x150": value._150x150,
    "480x480": value._480x480,
    "1000x1000": value._1000x1000
  };
}
function instanceOfProfilePictureFull(value) {
  let isInstance = true;
  return isInstance;
}
function ProfilePictureFullFromJSON(json) {
  return ProfilePictureFullFromJSONTyped(json);
}
function ProfilePictureFullFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "_150x150": !exists3(json, "150x150") ? void 0 : json["150x150"],
    "_480x480": !exists3(json, "480x480") ? void 0 : json["480x480"],
    "_1000x1000": !exists3(json, "1000x1000") ? void 0 : json["1000x1000"],
    "mirrors": !exists3(json, "mirrors") ? void 0 : json["mirrors"]
  };
}
function ProfilePictureFullToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "150x150": value._150x150,
    "480x480": value._480x480,
    "1000x1000": value._1000x1000,
    "mirrors": value.mirrors
  };
}
function instanceOfUserFullArtistCoinBadge(value) {
  let isInstance = true;
  return isInstance;
}
function UserFullArtistCoinBadgeFromJSON(json) {
  return UserFullArtistCoinBadgeFromJSONTyped(json);
}
function UserFullArtistCoinBadgeFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "mint": !exists3(json, "mint") ? void 0 : json["mint"],
    "logoUri": !exists3(json, "logo_uri") ? void 0 : json["logo_uri"],
    "ticker": !exists3(json, "ticker") ? void 0 : json["ticker"]
  };
}
function UserFullArtistCoinBadgeToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "mint": value.mint,
    "logo_uri": value.logoUri,
    "ticker": value.ticker
  };
}
function instanceOfUserFull(value) {
  let isInstance = true;
  isInstance = isInstance && "albumCount" in value && value["albumCount"] !== void 0;
  isInstance = isInstance && "artistCoinBadge" in value && value["artistCoinBadge"] !== void 0;
  isInstance = isInstance && "followeeCount" in value && value["followeeCount"] !== void 0;
  isInstance = isInstance && "followerCount" in value && value["followerCount"] !== void 0;
  isInstance = isInstance && "handle" in value && value["handle"] !== void 0;
  isInstance = isInstance && "id" in value && value["id"] !== void 0;
  isInstance = isInstance && "isVerified" in value && value["isVerified"] !== void 0;
  isInstance = isInstance && "verifiedWithTwitter" in value && value["verifiedWithTwitter"] !== void 0;
  isInstance = isInstance && "verifiedWithInstagram" in value && value["verifiedWithInstagram"] !== void 0;
  isInstance = isInstance && "verifiedWithTiktok" in value && value["verifiedWithTiktok"] !== void 0;
  isInstance = isInstance && "name" in value && value["name"] !== void 0;
  isInstance = isInstance && "playlistCount" in value && value["playlistCount"] !== void 0;
  isInstance = isInstance && "repostCount" in value && value["repostCount"] !== void 0;
  isInstance = isInstance && "trackCount" in value && value["trackCount"] !== void 0;
  isInstance = isInstance && "isDeactivated" in value && value["isDeactivated"] !== void 0;
  isInstance = isInstance && "isAvailable" in value && value["isAvailable"] !== void 0;
  isInstance = isInstance && "ercWallet" in value && value["ercWallet"] !== void 0;
  isInstance = isInstance && "splWallet" in value && value["splWallet"] !== void 0;
  isInstance = isInstance && "splUsdcWallet" in value && value["splUsdcWallet"] !== void 0;
  isInstance = isInstance && "supporterCount" in value && value["supporterCount"] !== void 0;
  isInstance = isInstance && "supportingCount" in value && value["supportingCount"] !== void 0;
  isInstance = isInstance && "totalAudioBalance" in value && value["totalAudioBalance"] !== void 0;
  isInstance = isInstance && "wallet" in value && value["wallet"] !== void 0;
  isInstance = isInstance && "balance" in value && value["balance"] !== void 0;
  isInstance = isInstance && "associatedWalletsBalance" in value && value["associatedWalletsBalance"] !== void 0;
  isInstance = isInstance && "totalBalance" in value && value["totalBalance"] !== void 0;
  isInstance = isInstance && "waudioBalance" in value && value["waudioBalance"] !== void 0;
  isInstance = isInstance && "associatedSolWalletsBalance" in value && value["associatedSolWalletsBalance"] !== void 0;
  isInstance = isInstance && "blocknumber" in value && value["blocknumber"] !== void 0;
  isInstance = isInstance && "createdAt" in value && value["createdAt"] !== void 0;
  isInstance = isInstance && "isStorageV2" in value && value["isStorageV2"] !== void 0;
  isInstance = isInstance && "currentUserFolloweeFollowCount" in value && value["currentUserFolloweeFollowCount"] !== void 0;
  isInstance = isInstance && "doesCurrentUserFollow" in value && value["doesCurrentUserFollow"] !== void 0;
  isInstance = isInstance && "doesCurrentUserSubscribe" in value && value["doesCurrentUserSubscribe"] !== void 0;
  isInstance = isInstance && "doesFollowCurrentUser" in value && value["doesFollowCurrentUser"] !== void 0;
  isInstance = isInstance && "handleLc" in value && value["handleLc"] !== void 0;
  isInstance = isInstance && "updatedAt" in value && value["updatedAt"] !== void 0;
  isInstance = isInstance && "hasCollectibles" in value && value["hasCollectibles"] !== void 0;
  isInstance = isInstance && "allowAiAttribution" in value && value["allowAiAttribution"] !== void 0;
  return isInstance;
}
function UserFullFromJSON(json) {
  return UserFullFromJSONTyped(json);
}
function UserFullFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "albumCount": json["album_count"],
    "artistPickTrackId": !exists3(json, "artist_pick_track_id") ? void 0 : json["artist_pick_track_id"],
    "artistCoinBadge": UserFullArtistCoinBadgeFromJSON(json["artist_coin_badge"]),
    "bio": !exists3(json, "bio") ? void 0 : json["bio"],
    "coverPhoto": !exists3(json, "cover_photo") ? void 0 : CoverPhotoFullFromJSON(json["cover_photo"]),
    "followeeCount": json["followee_count"],
    "followerCount": json["follower_count"],
    "handle": json["handle"],
    "id": json["id"],
    "isVerified": json["is_verified"],
    "twitterHandle": !exists3(json, "twitter_handle") ? void 0 : json["twitter_handle"],
    "instagramHandle": !exists3(json, "instagram_handle") ? void 0 : json["instagram_handle"],
    "tiktokHandle": !exists3(json, "tiktok_handle") ? void 0 : json["tiktok_handle"],
    "verifiedWithTwitter": json["verified_with_twitter"],
    "verifiedWithInstagram": json["verified_with_instagram"],
    "verifiedWithTiktok": json["verified_with_tiktok"],
    "website": !exists3(json, "website") ? void 0 : json["website"],
    "donation": !exists3(json, "donation") ? void 0 : json["donation"],
    "location": !exists3(json, "location") ? void 0 : json["location"],
    "name": json["name"],
    "playlistCount": json["playlist_count"],
    "profilePicture": !exists3(json, "profile_picture") ? void 0 : ProfilePictureFullFromJSON(json["profile_picture"]),
    "repostCount": json["repost_count"],
    "trackCount": json["track_count"],
    "isDeactivated": json["is_deactivated"],
    "isAvailable": json["is_available"],
    "ercWallet": json["erc_wallet"],
    "splWallet": json["spl_wallet"],
    "splUsdcWallet": json["spl_usdc_wallet"],
    "splUsdcPayoutWallet": !exists3(json, "spl_usdc_payout_wallet") ? void 0 : json["spl_usdc_payout_wallet"],
    "supporterCount": json["supporter_count"],
    "supportingCount": json["supporting_count"],
    "totalAudioBalance": json["total_audio_balance"],
    "wallet": json["wallet"],
    "balance": json["balance"],
    "associatedWalletsBalance": json["associated_wallets_balance"],
    "totalBalance": json["total_balance"],
    "waudioBalance": json["waudio_balance"],
    "associatedSolWalletsBalance": json["associated_sol_wallets_balance"],
    "blocknumber": json["blocknumber"],
    "createdAt": json["created_at"],
    "isStorageV2": json["is_storage_v2"],
    "creatorNodeEndpoint": !exists3(json, "creator_node_endpoint") ? void 0 : json["creator_node_endpoint"],
    "currentUserFolloweeFollowCount": json["current_user_followee_follow_count"],
    "doesCurrentUserFollow": json["does_current_user_follow"],
    "doesCurrentUserSubscribe": json["does_current_user_subscribe"],
    "doesFollowCurrentUser": json["does_follow_current_user"],
    "handleLc": json["handle_lc"],
    "updatedAt": json["updated_at"],
    "coverPhotoSizes": !exists3(json, "cover_photo_sizes") ? void 0 : json["cover_photo_sizes"],
    "coverPhotoCids": !exists3(json, "cover_photo_cids") ? void 0 : CoverPhotoFromJSON(json["cover_photo_cids"]),
    "coverPhotoLegacy": !exists3(json, "cover_photo_legacy") ? void 0 : json["cover_photo_legacy"],
    "profilePictureSizes": !exists3(json, "profile_picture_sizes") ? void 0 : json["profile_picture_sizes"],
    "profilePictureCids": !exists3(json, "profile_picture_cids") ? void 0 : ProfilePictureFromJSON(json["profile_picture_cids"]),
    "profilePictureLegacy": !exists3(json, "profile_picture_legacy") ? void 0 : json["profile_picture_legacy"],
    "hasCollectibles": json["has_collectibles"],
    "playlistLibrary": !exists3(json, "playlist_library") ? void 0 : PlaylistLibraryFromJSON(json["playlist_library"]),
    "allowAiAttribution": json["allow_ai_attribution"],
    "profileType": !exists3(json, "profile_type") ? void 0 : json["profile_type"]
  };
}
function UserFullToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "album_count": value.albumCount,
    "artist_pick_track_id": value.artistPickTrackId,
    "artist_coin_badge": UserFullArtistCoinBadgeToJSON(value.artistCoinBadge),
    "bio": value.bio,
    "cover_photo": CoverPhotoFullToJSON(value.coverPhoto),
    "followee_count": value.followeeCount,
    "follower_count": value.followerCount,
    "handle": value.handle,
    "id": value.id,
    "is_verified": value.isVerified,
    "twitter_handle": value.twitterHandle,
    "instagram_handle": value.instagramHandle,
    "tiktok_handle": value.tiktokHandle,
    "verified_with_twitter": value.verifiedWithTwitter,
    "verified_with_instagram": value.verifiedWithInstagram,
    "verified_with_tiktok": value.verifiedWithTiktok,
    "website": value.website,
    "donation": value.donation,
    "location": value.location,
    "name": value.name,
    "playlist_count": value.playlistCount,
    "profile_picture": ProfilePictureFullToJSON(value.profilePicture),
    "repost_count": value.repostCount,
    "track_count": value.trackCount,
    "is_deactivated": value.isDeactivated,
    "is_available": value.isAvailable,
    "erc_wallet": value.ercWallet,
    "spl_wallet": value.splWallet,
    "spl_usdc_wallet": value.splUsdcWallet,
    "spl_usdc_payout_wallet": value.splUsdcPayoutWallet,
    "supporter_count": value.supporterCount,
    "supporting_count": value.supportingCount,
    "total_audio_balance": value.totalAudioBalance,
    "wallet": value.wallet,
    "balance": value.balance,
    "associated_wallets_balance": value.associatedWalletsBalance,
    "total_balance": value.totalBalance,
    "waudio_balance": value.waudioBalance,
    "associated_sol_wallets_balance": value.associatedSolWalletsBalance,
    "blocknumber": value.blocknumber,
    "created_at": value.createdAt,
    "is_storage_v2": value.isStorageV2,
    "creator_node_endpoint": value.creatorNodeEndpoint,
    "current_user_followee_follow_count": value.currentUserFolloweeFollowCount,
    "does_current_user_follow": value.doesCurrentUserFollow,
    "does_current_user_subscribe": value.doesCurrentUserSubscribe,
    "does_follow_current_user": value.doesFollowCurrentUser,
    "handle_lc": value.handleLc,
    "updated_at": value.updatedAt,
    "cover_photo_sizes": value.coverPhotoSizes,
    "cover_photo_cids": CoverPhotoToJSON(value.coverPhotoCids),
    "cover_photo_legacy": value.coverPhotoLegacy,
    "profile_picture_sizes": value.profilePictureSizes,
    "profile_picture_cids": ProfilePictureToJSON(value.profilePictureCids),
    "profile_picture_legacy": value.profilePictureLegacy,
    "has_collectibles": value.hasCollectibles,
    "playlist_library": PlaylistLibraryToJSON(value.playlistLibrary),
    "allow_ai_attribution": value.allowAiAttribution,
    "profile_type": value.profileType
  };
}
function instanceOfAccountFull(value) {
  let isInstance = true;
  isInstance = isInstance && "user" in value && value["user"] !== void 0;
  isInstance = isInstance && "playlists" in value && value["playlists"] !== void 0;
  isInstance = isInstance && "trackSaveCount" in value && value["trackSaveCount"] !== void 0;
  return isInstance;
}
function AccountFullFromJSON(json) {
  return AccountFullFromJSONTyped(json);
}
function AccountFullFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "user": UserFullFromJSON(json["user"]),
    "playlists": json["playlists"].map(AccountCollectionFromJSON),
    "playlistLibrary": !exists3(json, "playlist_library") ? void 0 : PlaylistLibraryFromJSON(json["playlist_library"]),
    "trackSaveCount": json["track_save_count"]
  };
}
function AccountFullToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "user": UserFullToJSON(value.user),
    "playlists": value.playlists.map(AccountCollectionToJSON),
    "playlist_library": PlaylistLibraryToJSON(value.playlistLibrary),
    "track_save_count": value.trackSaveCount
  };
}
var ActivityFullItemTypeEnum = {
  Track: "track",
  Playlist: "playlist"
};
function instanceOfActivityFull(value) {
  let isInstance = true;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== void 0;
  isInstance = isInstance && "itemType" in value && value["itemType"] !== void 0;
  isInstance = isInstance && "item" in value && value["item"] !== void 0;
  isInstance = isInstance && "_class" in value && value["_class"] !== void 0;
  return isInstance;
}
function ActivityFullFromJSON(json) {
  return ActivityFullFromJSONTyped(json, false);
}
function ActivityFullFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  if (!ignoreDiscriminator) {
    if (json["_class"] === "collection_activity_full") {
      return CollectionActivityFullFromJSONTyped(json, true);
    }
    if (json["_class"] === "collection_activity_full_without_tracks") {
      return CollectionActivityFullWithoutTracksFromJSONTyped(json, true);
    }
    if (json["_class"] === "track_activity_full") {
      return TrackActivityFullFromJSONTyped(json, true);
    }
  }
  return {
    "timestamp": json["timestamp"],
    "itemType": json["item_type"],
    "item": json["item"],
    "_class": json["class"]
  };
}
function ActivityFullToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "timestamp": value.timestamp,
    "item_type": value.itemType,
    "item": value.item,
    "class": value._class
  };
}
function instanceOfAlbumBacklink(value) {
  let isInstance = true;
  isInstance = isInstance && "playlistId" in value && value["playlistId"] !== void 0;
  isInstance = isInstance && "playlistName" in value && value["playlistName"] !== void 0;
  isInstance = isInstance && "permalink" in value && value["permalink"] !== void 0;
  return isInstance;
}
function AlbumBacklinkFromJSON(json) {
  return AlbumBacklinkFromJSONTyped(json);
}
function AlbumBacklinkFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "playlistId": json["playlist_id"],
    "playlistName": json["playlist_name"],
    "permalink": json["permalink"]
  };
}
function AlbumBacklinkToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "playlist_id": value.playlistId,
    "playlist_name": value.playlistName,
    "permalink": value.permalink
  };
}
function instanceOfFavorite(value) {
  let isInstance = true;
  isInstance = isInstance && "favoriteItemId" in value && value["favoriteItemId"] !== void 0;
  isInstance = isInstance && "favoriteType" in value && value["favoriteType"] !== void 0;
  isInstance = isInstance && "userId" in value && value["userId"] !== void 0;
  isInstance = isInstance && "createdAt" in value && value["createdAt"] !== void 0;
  return isInstance;
}
function FavoriteFromJSON(json) {
  return FavoriteFromJSONTyped(json);
}
function FavoriteFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "favoriteItemId": json["favorite_item_id"],
    "favoriteType": json["favorite_type"],
    "userId": json["user_id"],
    "createdAt": json["created_at"]
  };
}
function FavoriteToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "favorite_item_id": value.favoriteItemId,
    "favorite_type": value.favoriteType,
    "user_id": value.userId,
    "created_at": value.createdAt
  };
}
function instanceOfPlaylistAddedTimestamp(value) {
  let isInstance = true;
  isInstance = isInstance && "metadataTimestamp" in value && value["metadataTimestamp"] !== void 0;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== void 0;
  isInstance = isInstance && "trackId" in value && value["trackId"] !== void 0;
  return isInstance;
}
function PlaylistAddedTimestampFromJSON(json) {
  return PlaylistAddedTimestampFromJSONTyped(json);
}
function PlaylistAddedTimestampFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "metadataTimestamp": json["metadata_timestamp"],
    "timestamp": json["timestamp"],
    "trackId": json["track_id"]
  };
}
function PlaylistAddedTimestampToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "metadata_timestamp": value.metadataTimestamp,
    "timestamp": value.timestamp,
    "track_id": value.trackId
  };
}
function instanceOfPlaylistArtwork(value) {
  let isInstance = true;
  return isInstance;
}
function PlaylistArtworkFromJSON(json) {
  return PlaylistArtworkFromJSONTyped(json);
}
function PlaylistArtworkFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "_150x150": !exists3(json, "150x150") ? void 0 : json["150x150"],
    "_480x480": !exists3(json, "480x480") ? void 0 : json["480x480"],
    "_1000x1000": !exists3(json, "1000x1000") ? void 0 : json["1000x1000"]
  };
}
function PlaylistArtworkToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "150x150": value._150x150,
    "480x480": value._480x480,
    "1000x1000": value._1000x1000
  };
}
function instanceOfPlaylistArtworkFull(value) {
  let isInstance = true;
  return isInstance;
}
function PlaylistArtworkFullFromJSON(json) {
  return PlaylistArtworkFullFromJSONTyped(json);
}
function PlaylistArtworkFullFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "_150x150": !exists3(json, "150x150") ? void 0 : json["150x150"],
    "_480x480": !exists3(json, "480x480") ? void 0 : json["480x480"],
    "_1000x1000": !exists3(json, "1000x1000") ? void 0 : json["1000x1000"],
    "mirrors": !exists3(json, "mirrors") ? void 0 : json["mirrors"]
  };
}
function PlaylistArtworkFullToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "150x150": value._150x150,
    "480x480": value._480x480,
    "1000x1000": value._1000x1000,
    "mirrors": value.mirrors
  };
}
function instanceOfRepost(value) {
  let isInstance = true;
  isInstance = isInstance && "repostItemId" in value && value["repostItemId"] !== void 0;
  isInstance = isInstance && "repostType" in value && value["repostType"] !== void 0;
  isInstance = isInstance && "userId" in value && value["userId"] !== void 0;
  return isInstance;
}
function RepostFromJSON(json) {
  return RepostFromJSONTyped(json);
}
function RepostFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "repostItemId": json["repost_item_id"],
    "repostType": json["repost_type"],
    "userId": json["user_id"]
  };
}
function RepostToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "repost_item_id": value.repostItemId,
    "repost_type": value.repostType,
    "user_id": value.userId
  };
}
function instanceOfCoverArt(value) {
  let isInstance = true;
  return isInstance;
}
function CoverArtFromJSON(json) {
  return CoverArtFromJSONTyped(json);
}
function CoverArtFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "_150x150": !exists3(json, "150x150") ? void 0 : json["150x150"],
    "_480x480": !exists3(json, "480x480") ? void 0 : json["480x480"],
    "_1000x1000": !exists3(json, "1000x1000") ? void 0 : json["1000x1000"]
  };
}
function CoverArtToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "150x150": value._150x150,
    "480x480": value._480x480,
    "1000x1000": value._1000x1000
  };
}
function instanceOfFieldVisibility(value) {
  let isInstance = true;
  isInstance = isInstance && "mood" in value && value["mood"] !== void 0;
  isInstance = isInstance && "tags" in value && value["tags"] !== void 0;
  isInstance = isInstance && "genre" in value && value["genre"] !== void 0;
  isInstance = isInstance && "share" in value && value["share"] !== void 0;
  isInstance = isInstance && "playCount" in value && value["playCount"] !== void 0;
  isInstance = isInstance && "remixes" in value && value["remixes"] !== void 0;
  return isInstance;
}
function FieldVisibilityFromJSON(json) {
  return FieldVisibilityFromJSONTyped(json);
}
function FieldVisibilityFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "mood": json["mood"],
    "tags": json["tags"],
    "genre": json["genre"],
    "share": json["share"],
    "playCount": json["play_count"],
    "remixes": json["remixes"]
  };
}
function FieldVisibilityToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "mood": value.mood,
    "tags": value.tags,
    "genre": value.genre,
    "share": value.share,
    "play_count": value.playCount,
    "remixes": value.remixes
  };
}
function instanceOfFullRemix(value) {
  let isInstance = true;
  isInstance = isInstance && "parentTrackId" in value && value["parentTrackId"] !== void 0;
  isInstance = isInstance && "user" in value && value["user"] !== void 0;
  isInstance = isInstance && "hasRemixAuthorReposted" in value && value["hasRemixAuthorReposted"] !== void 0;
  isInstance = isInstance && "hasRemixAuthorSaved" in value && value["hasRemixAuthorSaved"] !== void 0;
  return isInstance;
}
function FullRemixFromJSON(json) {
  return FullRemixFromJSONTyped(json);
}
function FullRemixFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "parentTrackId": json["parent_track_id"],
    "user": UserFullFromJSON(json["user"]),
    "hasRemixAuthorReposted": json["has_remix_author_reposted"],
    "hasRemixAuthorSaved": json["has_remix_author_saved"]
  };
}
function FullRemixToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "parent_track_id": value.parentTrackId,
    "user": UserFullToJSON(value.user),
    "has_remix_author_reposted": value.hasRemixAuthorReposted,
    "has_remix_author_saved": value.hasRemixAuthorSaved
  };
}
function instanceOfFullRemixParent(value) {
  let isInstance = true;
  return isInstance;
}
function FullRemixParentFromJSON(json) {
  return FullRemixParentFromJSONTyped(json);
}
function FullRemixParentFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "tracks": !exists3(json, "tracks") ? void 0 : json["tracks"].map(FullRemixFromJSON)
  };
}
function FullRemixParentToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "tracks": value.tracks === void 0 ? void 0 : value.tracks.map(FullRemixToJSON)
  };
}
function instanceOfStemParent(value) {
  let isInstance = true;
  isInstance = isInstance && "category" in value && value["category"] !== void 0;
  isInstance = isInstance && "parentTrackId" in value && value["parentTrackId"] !== void 0;
  return isInstance;
}
function StemParentFromJSON(json) {
  return StemParentFromJSONTyped(json);
}
function StemParentFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "category": json["category"],
    "parentTrackId": json["parent_track_id"]
  };
}
function StemParentToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "category": value.category,
    "parent_track_id": value.parentTrackId
  };
}
function instanceOfTrackArtworkFull(value) {
  let isInstance = true;
  return isInstance;
}
function TrackArtworkFullFromJSON(json) {
  return TrackArtworkFullFromJSONTyped(json);
}
function TrackArtworkFullFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "_150x150": !exists3(json, "150x150") ? void 0 : json["150x150"],
    "_480x480": !exists3(json, "480x480") ? void 0 : json["480x480"],
    "_1000x1000": !exists3(json, "1000x1000") ? void 0 : json["1000x1000"],
    "mirrors": !exists3(json, "mirrors") ? void 0 : json["mirrors"]
  };
}
function TrackArtworkFullToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "150x150": value._150x150,
    "480x480": value._480x480,
    "1000x1000": value._1000x1000,
    "mirrors": value.mirrors
  };
}
function instanceOfTrackSegment(value) {
  let isInstance = true;
  isInstance = isInstance && "duration" in value && value["duration"] !== void 0;
  isInstance = isInstance && "multihash" in value && value["multihash"] !== void 0;
  return isInstance;
}
function TrackSegmentFromJSON(json) {
  return TrackSegmentFromJSONTyped(json);
}
function TrackSegmentFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "duration": json["duration"],
    "multihash": json["multihash"]
  };
}
function TrackSegmentToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "duration": value.duration,
    "multihash": value.multihash
  };
}
function instanceOfUrlWithMirrors(value) {
  let isInstance = true;
  isInstance = isInstance && "mirrors" in value && value["mirrors"] !== void 0;
  return isInstance;
}
function UrlWithMirrorsFromJSON(json) {
  return UrlWithMirrorsFromJSONTyped(json);
}
function UrlWithMirrorsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "url": !exists3(json, "url") ? void 0 : json["url"],
    "mirrors": json["mirrors"]
  };
}
function UrlWithMirrorsToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "url": value.url,
    "mirrors": value.mirrors
  };
}
function instanceOfTrackFull(value) {
  let isInstance = true;
  isInstance = isInstance && "artwork" in value && value["artwork"] !== void 0;
  isInstance = isInstance && "genre" in value && value["genre"] !== void 0;
  isInstance = isInstance && "id" in value && value["id"] !== void 0;
  isInstance = isInstance && "isOriginalAvailable" in value && value["isOriginalAvailable"] !== void 0;
  isInstance = isInstance && "remixOf" in value && value["remixOf"] !== void 0;
  isInstance = isInstance && "repostCount" in value && value["repostCount"] !== void 0;
  isInstance = isInstance && "favoriteCount" in value && value["favoriteCount"] !== void 0;
  isInstance = isInstance && "commentCount" in value && value["commentCount"] !== void 0;
  isInstance = isInstance && "title" in value && value["title"] !== void 0;
  isInstance = isInstance && "user" in value && value["user"] !== void 0;
  isInstance = isInstance && "duration" in value && value["duration"] !== void 0;
  isInstance = isInstance && "isDownloadable" in value && value["isDownloadable"] !== void 0;
  isInstance = isInstance && "playCount" in value && value["playCount"] !== void 0;
  isInstance = isInstance && "permalink" in value && value["permalink"] !== void 0;
  isInstance = isInstance && "access" in value && value["access"] !== void 0;
  isInstance = isInstance && "blocknumber" in value && value["blocknumber"] !== void 0;
  isInstance = isInstance && "coverArtSizes" in value && value["coverArtSizes"] !== void 0;
  isInstance = isInstance && "createdAt" in value && value["createdAt"] !== void 0;
  isInstance = isInstance && "fieldVisibility" in value && value["fieldVisibility"] !== void 0;
  isInstance = isInstance && "followeeReposts" in value && value["followeeReposts"] !== void 0;
  isInstance = isInstance && "hasCurrentUserReposted" in value && value["hasCurrentUserReposted"] !== void 0;
  isInstance = isInstance && "isScheduledRelease" in value && value["isScheduledRelease"] !== void 0;
  isInstance = isInstance && "isUnlisted" in value && value["isUnlisted"] !== void 0;
  isInstance = isInstance && "hasCurrentUserSaved" in value && value["hasCurrentUserSaved"] !== void 0;
  isInstance = isInstance && "followeeFavorites" in value && value["followeeFavorites"] !== void 0;
  isInstance = isInstance && "routeId" in value && value["routeId"] !== void 0;
  isInstance = isInstance && "trackSegments" in value && value["trackSegments"] !== void 0;
  isInstance = isInstance && "updatedAt" in value && value["updatedAt"] !== void 0;
  isInstance = isInstance && "userId" in value && value["userId"] !== void 0;
  isInstance = isInstance && "isDelete" in value && value["isDelete"] !== void 0;
  isInstance = isInstance && "isAvailable" in value && value["isAvailable"] !== void 0;
  isInstance = isInstance && "isStreamGated" in value && value["isStreamGated"] !== void 0;
  isInstance = isInstance && "isDownloadGated" in value && value["isDownloadGated"] !== void 0;
  isInstance = isInstance && "isOwnedByUser" in value && value["isOwnedByUser"] !== void 0;
  isInstance = isInstance && "stream" in value && value["stream"] !== void 0;
  isInstance = isInstance && "download" in value && value["download"] !== void 0;
  isInstance = isInstance && "preview" in value && value["preview"] !== void 0;
  return isInstance;
}
function TrackFullFromJSON(json) {
  return TrackFullFromJSONTyped(json);
}
function TrackFullFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "artwork": TrackArtworkFullFromJSON(json["artwork"]),
    "description": !exists3(json, "description") ? void 0 : json["description"],
    "genre": json["genre"],
    "id": json["id"],
    "trackCid": !exists3(json, "track_cid") ? void 0 : json["track_cid"],
    "previewCid": !exists3(json, "preview_cid") ? void 0 : json["preview_cid"],
    "origFileCid": !exists3(json, "orig_file_cid") ? void 0 : json["orig_file_cid"],
    "origFilename": !exists3(json, "orig_filename") ? void 0 : json["orig_filename"],
    "isOriginalAvailable": json["is_original_available"],
    "mood": !exists3(json, "mood") ? void 0 : json["mood"],
    "releaseDate": !exists3(json, "release_date") ? void 0 : json["release_date"],
    "remixOf": FullRemixParentFromJSON(json["remix_of"]),
    "repostCount": json["repost_count"],
    "favoriteCount": json["favorite_count"],
    "commentCount": json["comment_count"],
    "tags": !exists3(json, "tags") ? void 0 : json["tags"],
    "title": json["title"],
    "user": UserFullFromJSON(json["user"]),
    "duration": json["duration"],
    "isDownloadable": json["is_downloadable"],
    "playCount": json["play_count"],
    "permalink": json["permalink"],
    "isStreamable": !exists3(json, "is_streamable") ? void 0 : json["is_streamable"],
    "ddexApp": !exists3(json, "ddex_app") ? void 0 : json["ddex_app"],
    "playlistsContainingTrack": !exists3(json, "playlists_containing_track") ? void 0 : json["playlists_containing_track"],
    "pinnedCommentId": !exists3(json, "pinned_comment_id") ? void 0 : json["pinned_comment_id"],
    "albumBacklink": !exists3(json, "album_backlink") ? void 0 : AlbumBacklinkFromJSON(json["album_backlink"]),
    "access": AccessFromJSON(json["access"]),
    "blocknumber": json["blocknumber"],
    "createDate": !exists3(json, "create_date") ? void 0 : json["create_date"],
    "coverArtSizes": json["cover_art_sizes"],
    "coverArtCids": !exists3(json, "cover_art_cids") ? void 0 : CoverArtFromJSON(json["cover_art_cids"]),
    "createdAt": json["created_at"],
    "creditsSplits": !exists3(json, "credits_splits") ? void 0 : json["credits_splits"],
    "isrc": !exists3(json, "isrc") ? void 0 : json["isrc"],
    "license": !exists3(json, "license") ? void 0 : json["license"],
    "iswc": !exists3(json, "iswc") ? void 0 : json["iswc"],
    "fieldVisibility": FieldVisibilityFromJSON(json["field_visibility"]),
    "followeeReposts": json["followee_reposts"].map(RepostFromJSON),
    "hasCurrentUserReposted": json["has_current_user_reposted"],
    "isScheduledRelease": json["is_scheduled_release"],
    "isUnlisted": json["is_unlisted"],
    "hasCurrentUserSaved": json["has_current_user_saved"],
    "followeeFavorites": json["followee_favorites"].map(FavoriteFromJSON),
    "routeId": json["route_id"],
    "stemOf": !exists3(json, "stem_of") ? void 0 : StemParentFromJSON(json["stem_of"]),
    "trackSegments": json["track_segments"].map(TrackSegmentFromJSON),
    "updatedAt": json["updated_at"],
    "userId": json["user_id"],
    "isDelete": json["is_delete"],
    "coverArt": !exists3(json, "cover_art") ? void 0 : json["cover_art"],
    "isAvailable": json["is_available"],
    "aiAttributionUserId": !exists3(json, "ai_attribution_user_id") ? void 0 : json["ai_attribution_user_id"],
    "allowedApiKeys": !exists3(json, "allowed_api_keys") ? void 0 : json["allowed_api_keys"],
    "audioUploadId": !exists3(json, "audio_upload_id") ? void 0 : json["audio_upload_id"],
    "previewStartSeconds": !exists3(json, "preview_start_seconds") ? void 0 : json["preview_start_seconds"],
    "bpm": !exists3(json, "bpm") ? void 0 : json["bpm"],
    "isCustomBpm": !exists3(json, "is_custom_bpm") ? void 0 : json["is_custom_bpm"],
    "musicalKey": !exists3(json, "musical_key") ? void 0 : json["musical_key"],
    "isCustomMusicalKey": !exists3(json, "is_custom_musical_key") ? void 0 : json["is_custom_musical_key"],
    "audioAnalysisErrorCount": !exists3(json, "audio_analysis_error_count") ? void 0 : json["audio_analysis_error_count"],
    "commentsDisabled": !exists3(json, "comments_disabled") ? void 0 : json["comments_disabled"],
    "ddexReleaseIds": !exists3(json, "ddex_release_ids") ? void 0 : json["ddex_release_ids"],
    "artists": !exists3(json, "artists") ? void 0 : json["artists"],
    "resourceContributors": !exists3(json, "resource_contributors") ? void 0 : json["resource_contributors"],
    "indirectResourceContributors": !exists3(json, "indirect_resource_contributors") ? void 0 : json["indirect_resource_contributors"],
    "rightsController": !exists3(json, "rights_controller") ? void 0 : json["rights_controller"],
    "copyrightLine": !exists3(json, "copyright_line") ? void 0 : json["copyright_line"],
    "producerCopyrightLine": !exists3(json, "producer_copyright_line") ? void 0 : json["producer_copyright_line"],
    "parentalWarningType": !exists3(json, "parental_warning_type") ? void 0 : json["parental_warning_type"],
    "isStreamGated": json["is_stream_gated"],
    "streamConditions": !exists3(json, "stream_conditions") ? void 0 : AccessGateFromJSON(json["stream_conditions"]),
    "isDownloadGated": json["is_download_gated"],
    "downloadConditions": !exists3(json, "download_conditions") ? void 0 : AccessGateFromJSON(json["download_conditions"]),
    "coverOriginalSongTitle": !exists3(json, "cover_original_song_title") ? void 0 : json["cover_original_song_title"],
    "coverOriginalArtist": !exists3(json, "cover_original_artist") ? void 0 : json["cover_original_artist"],
    "isOwnedByUser": json["is_owned_by_user"],
    "stream": UrlWithMirrorsFromJSON(json["stream"]),
    "download": UrlWithMirrorsFromJSON(json["download"]),
    "preview": UrlWithMirrorsFromJSON(json["preview"])
  };
}
function TrackFullToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "artwork": TrackArtworkFullToJSON(value.artwork),
    "description": value.description,
    "genre": value.genre,
    "id": value.id,
    "track_cid": value.trackCid,
    "preview_cid": value.previewCid,
    "orig_file_cid": value.origFileCid,
    "orig_filename": value.origFilename,
    "is_original_available": value.isOriginalAvailable,
    "mood": value.mood,
    "release_date": value.releaseDate,
    "remix_of": FullRemixParentToJSON(value.remixOf),
    "repost_count": value.repostCount,
    "favorite_count": value.favoriteCount,
    "comment_count": value.commentCount,
    "tags": value.tags,
    "title": value.title,
    "user": UserFullToJSON(value.user),
    "duration": value.duration,
    "is_downloadable": value.isDownloadable,
    "play_count": value.playCount,
    "permalink": value.permalink,
    "is_streamable": value.isStreamable,
    "ddex_app": value.ddexApp,
    "playlists_containing_track": value.playlistsContainingTrack,
    "pinned_comment_id": value.pinnedCommentId,
    "album_backlink": AlbumBacklinkToJSON(value.albumBacklink),
    "access": AccessToJSON(value.access),
    "blocknumber": value.blocknumber,
    "create_date": value.createDate,
    "cover_art_sizes": value.coverArtSizes,
    "cover_art_cids": CoverArtToJSON(value.coverArtCids),
    "created_at": value.createdAt,
    "credits_splits": value.creditsSplits,
    "isrc": value.isrc,
    "license": value.license,
    "iswc": value.iswc,
    "field_visibility": FieldVisibilityToJSON(value.fieldVisibility),
    "followee_reposts": value.followeeReposts.map(RepostToJSON),
    "has_current_user_reposted": value.hasCurrentUserReposted,
    "is_scheduled_release": value.isScheduledRelease,
    "is_unlisted": value.isUnlisted,
    "has_current_user_saved": value.hasCurrentUserSaved,
    "followee_favorites": value.followeeFavorites.map(FavoriteToJSON),
    "route_id": value.routeId,
    "stem_of": StemParentToJSON(value.stemOf),
    "track_segments": value.trackSegments.map(TrackSegmentToJSON),
    "updated_at": value.updatedAt,
    "user_id": value.userId,
    "is_delete": value.isDelete,
    "cover_art": value.coverArt,
    "is_available": value.isAvailable,
    "ai_attribution_user_id": value.aiAttributionUserId,
    "allowed_api_keys": value.allowedApiKeys,
    "audio_upload_id": value.audioUploadId,
    "preview_start_seconds": value.previewStartSeconds,
    "bpm": value.bpm,
    "is_custom_bpm": value.isCustomBpm,
    "musical_key": value.musicalKey,
    "is_custom_musical_key": value.isCustomMusicalKey,
    "audio_analysis_error_count": value.audioAnalysisErrorCount,
    "comments_disabled": value.commentsDisabled,
    "ddex_release_ids": value.ddexReleaseIds,
    "artists": value.artists,
    "resource_contributors": value.resourceContributors,
    "indirect_resource_contributors": value.indirectResourceContributors,
    "rights_controller": value.rightsController,
    "copyright_line": value.copyrightLine,
    "producer_copyright_line": value.producerCopyrightLine,
    "parental_warning_type": value.parentalWarningType,
    "is_stream_gated": value.isStreamGated,
    "stream_conditions": AccessGateToJSON(value.streamConditions),
    "is_download_gated": value.isDownloadGated,
    "download_conditions": AccessGateToJSON(value.downloadConditions),
    "cover_original_song_title": value.coverOriginalSongTitle,
    "cover_original_artist": value.coverOriginalArtist,
    "is_owned_by_user": value.isOwnedByUser,
    "stream": UrlWithMirrorsToJSON(value.stream),
    "download": UrlWithMirrorsToJSON(value.download),
    "preview": UrlWithMirrorsToJSON(value.preview)
  };
}
function instanceOfPlaylistFullWithoutTracks(value) {
  let isInstance = true;
  isInstance = isInstance && "permalink" in value && value["permalink"] !== void 0;
  isInstance = isInstance && "id" in value && value["id"] !== void 0;
  isInstance = isInstance && "isAlbum" in value && value["isAlbum"] !== void 0;
  isInstance = isInstance && "isImageAutogenerated" in value && value["isImageAutogenerated"] !== void 0;
  isInstance = isInstance && "playlistName" in value && value["playlistName"] !== void 0;
  isInstance = isInstance && "playlistContents" in value && value["playlistContents"] !== void 0;
  isInstance = isInstance && "repostCount" in value && value["repostCount"] !== void 0;
  isInstance = isInstance && "favoriteCount" in value && value["favoriteCount"] !== void 0;
  isInstance = isInstance && "totalPlayCount" in value && value["totalPlayCount"] !== void 0;
  isInstance = isInstance && "user" in value && value["user"] !== void 0;
  isInstance = isInstance && "access" in value && value["access"] !== void 0;
  isInstance = isInstance && "trackCount" in value && value["trackCount"] !== void 0;
  isInstance = isInstance && "blocknumber" in value && value["blocknumber"] !== void 0;
  isInstance = isInstance && "createdAt" in value && value["createdAt"] !== void 0;
  isInstance = isInstance && "followeeReposts" in value && value["followeeReposts"] !== void 0;
  isInstance = isInstance && "followeeFavorites" in value && value["followeeFavorites"] !== void 0;
  isInstance = isInstance && "hasCurrentUserReposted" in value && value["hasCurrentUserReposted"] !== void 0;
  isInstance = isInstance && "hasCurrentUserSaved" in value && value["hasCurrentUserSaved"] !== void 0;
  isInstance = isInstance && "isDelete" in value && value["isDelete"] !== void 0;
  isInstance = isInstance && "isPrivate" in value && value["isPrivate"] !== void 0;
  isInstance = isInstance && "updatedAt" in value && value["updatedAt"] !== void 0;
  isInstance = isInstance && "addedTimestamps" in value && value["addedTimestamps"] !== void 0;
  isInstance = isInstance && "userId" in value && value["userId"] !== void 0;
  isInstance = isInstance && "isStreamGated" in value && value["isStreamGated"] !== void 0;
  isInstance = isInstance && "isScheduledRelease" in value && value["isScheduledRelease"] !== void 0;
  return isInstance;
}
function PlaylistFullWithoutTracksFromJSON(json) {
  return PlaylistFullWithoutTracksFromJSONTyped(json);
}
function PlaylistFullWithoutTracksFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "artwork": !exists3(json, "artwork") ? void 0 : PlaylistArtworkFullFromJSON(json["artwork"]),
    "description": !exists3(json, "description") ? void 0 : json["description"],
    "permalink": json["permalink"],
    "id": json["id"],
    "isAlbum": json["is_album"],
    "isImageAutogenerated": json["is_image_autogenerated"],
    "playlistName": json["playlist_name"],
    "playlistContents": json["playlist_contents"].map(PlaylistAddedTimestampFromJSON),
    "repostCount": json["repost_count"],
    "favoriteCount": json["favorite_count"],
    "totalPlayCount": json["total_play_count"],
    "user": UserFullFromJSON(json["user"]),
    "ddexApp": !exists3(json, "ddex_app") ? void 0 : json["ddex_app"],
    "access": AccessFromJSON(json["access"]),
    "upc": !exists3(json, "upc") ? void 0 : json["upc"],
    "trackCount": json["track_count"],
    "blocknumber": json["blocknumber"],
    "createdAt": json["created_at"],
    "followeeReposts": json["followee_reposts"].map(RepostFromJSON),
    "followeeFavorites": json["followee_favorites"].map(FavoriteFromJSON),
    "hasCurrentUserReposted": json["has_current_user_reposted"],
    "hasCurrentUserSaved": json["has_current_user_saved"],
    "isDelete": json["is_delete"],
    "isPrivate": json["is_private"],
    "updatedAt": json["updated_at"],
    "addedTimestamps": json["added_timestamps"].map(PlaylistAddedTimestampFromJSON),
    "userId": json["user_id"],
    "tracks": !exists3(json, "tracks") ? void 0 : json["tracks"].map(TrackFullFromJSON),
    "coverArt": !exists3(json, "cover_art") ? void 0 : json["cover_art"],
    "coverArtSizes": !exists3(json, "cover_art_sizes") ? void 0 : json["cover_art_sizes"],
    "coverArtCids": !exists3(json, "cover_art_cids") ? void 0 : PlaylistArtworkFromJSON(json["cover_art_cids"]),
    "isStreamGated": json["is_stream_gated"],
    "streamConditions": !exists3(json, "stream_conditions") ? void 0 : AccessGateFromJSON(json["stream_conditions"]),
    "isScheduledRelease": json["is_scheduled_release"],
    "releaseDate": !exists3(json, "release_date") ? void 0 : json["release_date"],
    "ddexReleaseIds": !exists3(json, "ddex_release_ids") ? void 0 : json["ddex_release_ids"],
    "artists": !exists3(json, "artists") ? void 0 : json["artists"],
    "copyrightLine": !exists3(json, "copyright_line") ? void 0 : json["copyright_line"],
    "producerCopyrightLine": !exists3(json, "producer_copyright_line") ? void 0 : json["producer_copyright_line"],
    "parentalWarningType": !exists3(json, "parental_warning_type") ? void 0 : json["parental_warning_type"]
  };
}
function PlaylistFullWithoutTracksToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "artwork": PlaylistArtworkFullToJSON(value.artwork),
    "description": value.description,
    "permalink": value.permalink,
    "id": value.id,
    "is_album": value.isAlbum,
    "is_image_autogenerated": value.isImageAutogenerated,
    "playlist_name": value.playlistName,
    "playlist_contents": value.playlistContents.map(PlaylistAddedTimestampToJSON),
    "repost_count": value.repostCount,
    "favorite_count": value.favoriteCount,
    "total_play_count": value.totalPlayCount,
    "user": UserFullToJSON(value.user),
    "ddex_app": value.ddexApp,
    "access": AccessToJSON(value.access),
    "upc": value.upc,
    "track_count": value.trackCount,
    "blocknumber": value.blocknumber,
    "created_at": value.createdAt,
    "followee_reposts": value.followeeReposts.map(RepostToJSON),
    "followee_favorites": value.followeeFavorites.map(FavoriteToJSON),
    "has_current_user_reposted": value.hasCurrentUserReposted,
    "has_current_user_saved": value.hasCurrentUserSaved,
    "is_delete": value.isDelete,
    "is_private": value.isPrivate,
    "updated_at": value.updatedAt,
    "added_timestamps": value.addedTimestamps.map(PlaylistAddedTimestampToJSON),
    "user_id": value.userId,
    "tracks": value.tracks === void 0 ? void 0 : value.tracks.map(TrackFullToJSON),
    "cover_art": value.coverArt,
    "cover_art_sizes": value.coverArtSizes,
    "cover_art_cids": PlaylistArtworkToJSON(value.coverArtCids),
    "is_stream_gated": value.isStreamGated,
    "stream_conditions": AccessGateToJSON(value.streamConditions),
    "is_scheduled_release": value.isScheduledRelease,
    "release_date": value.releaseDate,
    "ddex_release_ids": value.ddexReleaseIds,
    "artists": value.artists,
    "copyright_line": value.copyrightLine,
    "producer_copyright_line": value.producerCopyrightLine,
    "parental_warning_type": value.parentalWarningType
  };
}
function instanceOfVersionMetadata(value) {
  let isInstance = true;
  isInstance = isInstance && "service" in value && value["service"] !== void 0;
  isInstance = isInstance && "version" in value && value["version"] !== void 0;
  return isInstance;
}
function VersionMetadataFromJSON(json) {
  return VersionMetadataFromJSONTyped(json);
}
function VersionMetadataFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "service": json["service"],
    "version": json["version"]
  };
}
function VersionMetadataToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "service": value.service,
    "version": value.version
  };
}
function instanceOfAlbumsResponseFull(value) {
  let isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value && value["latestChainBlock"] !== void 0;
  isInstance = isInstance && "latestIndexedBlock" in value && value["latestIndexedBlock"] !== void 0;
  isInstance = isInstance && "latestChainSlotPlays" in value && value["latestChainSlotPlays"] !== void 0;
  isInstance = isInstance && "latestIndexedSlotPlays" in value && value["latestIndexedSlotPlays"] !== void 0;
  isInstance = isInstance && "signature" in value && value["signature"] !== void 0;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== void 0;
  isInstance = isInstance && "version" in value && value["version"] !== void 0;
  return isInstance;
}
function AlbumsResponseFullFromJSON(json) {
  return AlbumsResponseFullFromJSONTyped(json);
}
function AlbumsResponseFullFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "latestChainBlock": json["latest_chain_block"],
    "latestIndexedBlock": json["latest_indexed_block"],
    "latestChainSlotPlays": json["latest_chain_slot_plays"],
    "latestIndexedSlotPlays": json["latest_indexed_slot_plays"],
    "signature": json["signature"],
    "timestamp": json["timestamp"],
    "version": VersionMetadataFromJSON(json["version"]),
    "data": !exists3(json, "data") ? void 0 : json["data"].map(PlaylistFullWithoutTracksFromJSON)
  };
}
function AlbumsResponseFullToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "latest_chain_block": value.latestChainBlock,
    "latest_indexed_block": value.latestIndexedBlock,
    "latest_chain_slot_plays": value.latestChainSlotPlays,
    "latest_indexed_slot_plays": value.latestIndexedSlotPlays,
    "signature": value.signature,
    "timestamp": value.timestamp,
    "version": VersionMetadataToJSON(value.version),
    "data": value.data === void 0 ? void 0 : value.data.map(PlaylistFullWithoutTracksToJSON)
  };
}
function instanceOfAnnouncementNotificationActionData(value) {
  let isInstance = true;
  isInstance = isInstance && "title" in value && value["title"] !== void 0;
  isInstance = isInstance && "pushBody" in value && value["pushBody"] !== void 0;
  isInstance = isInstance && "shortDescription" in value && value["shortDescription"] !== void 0;
  isInstance = isInstance && "longDescription" in value && value["longDescription"] !== void 0;
  return isInstance;
}
function AnnouncementNotificationActionDataFromJSON(json) {
  return AnnouncementNotificationActionDataFromJSONTyped(json);
}
function AnnouncementNotificationActionDataFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "title": json["title"],
    "pushBody": json["push_body"],
    "shortDescription": json["short_description"],
    "longDescription": json["long_description"]
  };
}
function AnnouncementNotificationActionDataToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "title": value.title,
    "push_body": value.pushBody,
    "short_description": value.shortDescription,
    "long_description": value.longDescription
  };
}
function instanceOfAnnouncementNotificationAction(value) {
  let isInstance = true;
  isInstance = isInstance && "specifier" in value && value["specifier"] !== void 0;
  isInstance = isInstance && "type" in value && value["type"] !== void 0;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== void 0;
  isInstance = isInstance && "data" in value && value["data"] !== void 0;
  return isInstance;
}
function AnnouncementNotificationActionFromJSON(json) {
  return AnnouncementNotificationActionFromJSONTyped(json);
}
function AnnouncementNotificationActionFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "specifier": json["specifier"],
    "type": json["type"],
    "timestamp": json["timestamp"],
    "data": AnnouncementNotificationActionDataFromJSON(json["data"])
  };
}
function AnnouncementNotificationActionToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "specifier": value.specifier,
    "type": value.type,
    "timestamp": value.timestamp,
    "data": AnnouncementNotificationActionDataToJSON(value.data)
  };
}
function instanceOfAnnouncementNotification(value) {
  let isInstance = true;
  isInstance = isInstance && "type" in value && value["type"] !== void 0;
  isInstance = isInstance && "groupId" in value && value["groupId"] !== void 0;
  isInstance = isInstance && "isSeen" in value && value["isSeen"] !== void 0;
  isInstance = isInstance && "actions" in value && value["actions"] !== void 0;
  return isInstance;
}
function AnnouncementNotificationFromJSON(json) {
  return AnnouncementNotificationFromJSONTyped(json);
}
function AnnouncementNotificationFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "groupId": json["group_id"],
    "isSeen": json["is_seen"],
    "seenAt": !exists3(json, "seen_at") ? void 0 : json["seen_at"],
    "actions": json["actions"].map(AnnouncementNotificationActionFromJSON)
  };
}
function AnnouncementNotificationToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "group_id": value.groupId,
    "is_seen": value.isSeen,
    "seen_at": value.seenAt,
    "actions": value.actions.map(AnnouncementNotificationActionToJSON)
  };
}
function instanceOfApproveManagerRequestNotificationActionData(value) {
  let isInstance = true;
  isInstance = isInstance && "userId" in value && value["userId"] !== void 0;
  isInstance = isInstance && "granteeUserId" in value && value["granteeUserId"] !== void 0;
  isInstance = isInstance && "granteeAddress" in value && value["granteeAddress"] !== void 0;
  return isInstance;
}
function ApproveManagerRequestNotificationActionDataFromJSON(json) {
  return ApproveManagerRequestNotificationActionDataFromJSONTyped(json);
}
function ApproveManagerRequestNotificationActionDataFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "userId": json["user_id"],
    "granteeUserId": json["grantee_user_id"],
    "granteeAddress": json["grantee_address"]
  };
}
function ApproveManagerRequestNotificationActionDataToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "user_id": value.userId,
    "grantee_user_id": value.granteeUserId,
    "grantee_address": value.granteeAddress
  };
}
function instanceOfApproveManagerRequestNotificationAction(value) {
  let isInstance = true;
  isInstance = isInstance && "specifier" in value && value["specifier"] !== void 0;
  isInstance = isInstance && "type" in value && value["type"] !== void 0;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== void 0;
  isInstance = isInstance && "data" in value && value["data"] !== void 0;
  return isInstance;
}
function ApproveManagerRequestNotificationActionFromJSON(json) {
  return ApproveManagerRequestNotificationActionFromJSONTyped(json);
}
function ApproveManagerRequestNotificationActionFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "specifier": json["specifier"],
    "type": json["type"],
    "timestamp": json["timestamp"],
    "data": ApproveManagerRequestNotificationActionDataFromJSON(json["data"])
  };
}
function ApproveManagerRequestNotificationActionToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "specifier": value.specifier,
    "type": value.type,
    "timestamp": value.timestamp,
    "data": ApproveManagerRequestNotificationActionDataToJSON(value.data)
  };
}
function instanceOfApproveManagerRequestNotification(value) {
  let isInstance = true;
  isInstance = isInstance && "type" in value && value["type"] !== void 0;
  isInstance = isInstance && "groupId" in value && value["groupId"] !== void 0;
  isInstance = isInstance && "isSeen" in value && value["isSeen"] !== void 0;
  isInstance = isInstance && "actions" in value && value["actions"] !== void 0;
  return isInstance;
}
function ApproveManagerRequestNotificationFromJSON(json) {
  return ApproveManagerRequestNotificationFromJSONTyped(json);
}
function ApproveManagerRequestNotificationFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "groupId": json["group_id"],
    "isSeen": json["is_seen"],
    "seenAt": !exists3(json, "seen_at") ? void 0 : json["seen_at"],
    "actions": json["actions"].map(ApproveManagerRequestNotificationActionFromJSON)
  };
}
function ApproveManagerRequestNotificationToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "group_id": value.groupId,
    "is_seen": value.isSeen,
    "seen_at": value.seenAt,
    "actions": value.actions.map(ApproveManagerRequestNotificationActionToJSON)
  };
}
function instanceOfArtistRemixContestEndedNotificationActionData(value) {
  let isInstance = true;
  isInstance = isInstance && "entityId" in value && value["entityId"] !== void 0;
  return isInstance;
}
function ArtistRemixContestEndedNotificationActionDataFromJSON(json) {
  return ArtistRemixContestEndedNotificationActionDataFromJSONTyped(json);
}
function ArtistRemixContestEndedNotificationActionDataFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "entityId": json["entity_id"]
  };
}
function ArtistRemixContestEndedNotificationActionDataToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "entity_id": value.entityId
  };
}
function instanceOfArtistRemixContestEndedNotificationAction(value) {
  let isInstance = true;
  isInstance = isInstance && "specifier" in value && value["specifier"] !== void 0;
  isInstance = isInstance && "type" in value && value["type"] !== void 0;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== void 0;
  isInstance = isInstance && "data" in value && value["data"] !== void 0;
  return isInstance;
}
function ArtistRemixContestEndedNotificationActionFromJSON(json) {
  return ArtistRemixContestEndedNotificationActionFromJSONTyped(json);
}
function ArtistRemixContestEndedNotificationActionFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "specifier": json["specifier"],
    "type": json["type"],
    "timestamp": json["timestamp"],
    "data": ArtistRemixContestEndedNotificationActionDataFromJSON(json["data"])
  };
}
function ArtistRemixContestEndedNotificationActionToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "specifier": value.specifier,
    "type": value.type,
    "timestamp": value.timestamp,
    "data": ArtistRemixContestEndedNotificationActionDataToJSON(value.data)
  };
}
function instanceOfArtistRemixContestEndedNotification(value) {
  let isInstance = true;
  isInstance = isInstance && "type" in value && value["type"] !== void 0;
  isInstance = isInstance && "groupId" in value && value["groupId"] !== void 0;
  isInstance = isInstance && "isSeen" in value && value["isSeen"] !== void 0;
  isInstance = isInstance && "actions" in value && value["actions"] !== void 0;
  return isInstance;
}
function ArtistRemixContestEndedNotificationFromJSON(json) {
  return ArtistRemixContestEndedNotificationFromJSONTyped(json);
}
function ArtistRemixContestEndedNotificationFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "groupId": json["group_id"],
    "isSeen": json["is_seen"],
    "seenAt": !exists3(json, "seen_at") ? void 0 : json["seen_at"],
    "actions": json["actions"].map(ArtistRemixContestEndedNotificationActionFromJSON)
  };
}
function ArtistRemixContestEndedNotificationToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "group_id": value.groupId,
    "is_seen": value.isSeen,
    "seen_at": value.seenAt,
    "actions": value.actions.map(ArtistRemixContestEndedNotificationActionToJSON)
  };
}
function instanceOfArtistRemixContestEndingSoonNotificationActionData(value) {
  let isInstance = true;
  isInstance = isInstance && "entityUserId" in value && value["entityUserId"] !== void 0;
  isInstance = isInstance && "entityId" in value && value["entityId"] !== void 0;
  return isInstance;
}
function ArtistRemixContestEndingSoonNotificationActionDataFromJSON(json) {
  return ArtistRemixContestEndingSoonNotificationActionDataFromJSONTyped(json);
}
function ArtistRemixContestEndingSoonNotificationActionDataFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "entityUserId": json["entity_user_id"],
    "entityId": json["entity_id"]
  };
}
function ArtistRemixContestEndingSoonNotificationActionDataToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "entity_user_id": value.entityUserId,
    "entity_id": value.entityId
  };
}
function instanceOfArtistRemixContestEndingSoonNotificationAction(value) {
  let isInstance = true;
  isInstance = isInstance && "specifier" in value && value["specifier"] !== void 0;
  isInstance = isInstance && "type" in value && value["type"] !== void 0;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== void 0;
  isInstance = isInstance && "data" in value && value["data"] !== void 0;
  return isInstance;
}
function ArtistRemixContestEndingSoonNotificationActionFromJSON(json) {
  return ArtistRemixContestEndingSoonNotificationActionFromJSONTyped(json);
}
function ArtistRemixContestEndingSoonNotificationActionFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "specifier": json["specifier"],
    "type": json["type"],
    "timestamp": json["timestamp"],
    "data": ArtistRemixContestEndingSoonNotificationActionDataFromJSON(json["data"])
  };
}
function ArtistRemixContestEndingSoonNotificationActionToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "specifier": value.specifier,
    "type": value.type,
    "timestamp": value.timestamp,
    "data": ArtistRemixContestEndingSoonNotificationActionDataToJSON(value.data)
  };
}
function instanceOfArtistRemixContestEndingSoonNotification(value) {
  let isInstance = true;
  isInstance = isInstance && "type" in value && value["type"] !== void 0;
  isInstance = isInstance && "groupId" in value && value["groupId"] !== void 0;
  isInstance = isInstance && "isSeen" in value && value["isSeen"] !== void 0;
  isInstance = isInstance && "actions" in value && value["actions"] !== void 0;
  return isInstance;
}
function ArtistRemixContestEndingSoonNotificationFromJSON(json) {
  return ArtistRemixContestEndingSoonNotificationFromJSONTyped(json);
}
function ArtistRemixContestEndingSoonNotificationFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "groupId": json["group_id"],
    "isSeen": json["is_seen"],
    "seenAt": !exists3(json, "seen_at") ? void 0 : json["seen_at"],
    "actions": json["actions"].map(ArtistRemixContestEndingSoonNotificationActionFromJSON)
  };
}
function ArtistRemixContestEndingSoonNotificationToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "group_id": value.groupId,
    "is_seen": value.isSeen,
    "seen_at": value.seenAt,
    "actions": value.actions.map(ArtistRemixContestEndingSoonNotificationActionToJSON)
  };
}
function instanceOfArtistRemixContestSubmissionsNotificationActionData(value) {
  let isInstance = true;
  isInstance = isInstance && "eventId" in value && value["eventId"] !== void 0;
  isInstance = isInstance && "milestone" in value && value["milestone"] !== void 0;
  isInstance = isInstance && "entityId" in value && value["entityId"] !== void 0;
  return isInstance;
}
function ArtistRemixContestSubmissionsNotificationActionDataFromJSON(json) {
  return ArtistRemixContestSubmissionsNotificationActionDataFromJSONTyped(json);
}
function ArtistRemixContestSubmissionsNotificationActionDataFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "eventId": json["event_id"],
    "milestone": json["milestone"],
    "entityId": json["entity_id"]
  };
}
function ArtistRemixContestSubmissionsNotificationActionDataToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "event_id": value.eventId,
    "milestone": value.milestone,
    "entity_id": value.entityId
  };
}
function instanceOfArtistRemixContestSubmissionsNotificationAction(value) {
  let isInstance = true;
  isInstance = isInstance && "specifier" in value && value["specifier"] !== void 0;
  isInstance = isInstance && "type" in value && value["type"] !== void 0;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== void 0;
  isInstance = isInstance && "data" in value && value["data"] !== void 0;
  return isInstance;
}
function ArtistRemixContestSubmissionsNotificationActionFromJSON(json) {
  return ArtistRemixContestSubmissionsNotificationActionFromJSONTyped(json);
}
function ArtistRemixContestSubmissionsNotificationActionFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "specifier": json["specifier"],
    "type": json["type"],
    "timestamp": json["timestamp"],
    "data": ArtistRemixContestSubmissionsNotificationActionDataFromJSON(json["data"])
  };
}
function ArtistRemixContestSubmissionsNotificationActionToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "specifier": value.specifier,
    "type": value.type,
    "timestamp": value.timestamp,
    "data": ArtistRemixContestSubmissionsNotificationActionDataToJSON(value.data)
  };
}
function instanceOfArtistRemixContestSubmissionsNotification(value) {
  let isInstance = true;
  isInstance = isInstance && "type" in value && value["type"] !== void 0;
  isInstance = isInstance && "groupId" in value && value["groupId"] !== void 0;
  isInstance = isInstance && "isSeen" in value && value["isSeen"] !== void 0;
  isInstance = isInstance && "actions" in value && value["actions"] !== void 0;
  return isInstance;
}
function ArtistRemixContestSubmissionsNotificationFromJSON(json) {
  return ArtistRemixContestSubmissionsNotificationFromJSONTyped(json);
}
function ArtistRemixContestSubmissionsNotificationFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "groupId": json["group_id"],
    "isSeen": json["is_seen"],
    "seenAt": !exists3(json, "seen_at") ? void 0 : json["seen_at"],
    "actions": json["actions"].map(ArtistRemixContestSubmissionsNotificationActionFromJSON)
  };
}
function ArtistRemixContestSubmissionsNotificationToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "group_id": value.groupId,
    "is_seen": value.isSeen,
    "seen_at": value.seenAt,
    "actions": value.actions.map(ArtistRemixContestSubmissionsNotificationActionToJSON)
  };
}
function instanceOfAttestation(value) {
  let isInstance = true;
  isInstance = isInstance && "ownerWallet" in value && value["ownerWallet"] !== void 0;
  isInstance = isInstance && "attestation" in value && value["attestation"] !== void 0;
  return isInstance;
}
function AttestationFromJSON(json) {
  return AttestationFromJSONTyped(json);
}
function AttestationFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "ownerWallet": json["owner_wallet"],
    "attestation": json["attestation"]
  };
}
function AttestationToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "owner_wallet": value.ownerWallet,
    "attestation": value.attestation
  };
}
function instanceOfAttestationReponse(value) {
  let isInstance = true;
  return isInstance;
}
function AttestationReponseFromJSON(json) {
  return AttestationReponseFromJSONTyped(json);
}
function AttestationReponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "data": !exists3(json, "data") ? void 0 : AttestationFromJSON(json["data"])
  };
}
function AttestationReponseToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "data": AttestationToJSON(value.data)
  };
}
var BestSellingItemContentTypeEnum = {
  Track: "track",
  Album: "album"
};
function instanceOfBestSellingItem(value) {
  let isInstance = true;
  isInstance = isInstance && "contentId" in value && value["contentId"] !== void 0;
  isInstance = isInstance && "title" in value && value["title"] !== void 0;
  isInstance = isInstance && "ownerId" in value && value["ownerId"] !== void 0;
  return isInstance;
}
function BestSellingItemFromJSON(json) {
  return BestSellingItemFromJSONTyped(json);
}
function BestSellingItemFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "contentId": json["content_id"],
    "contentType": !exists3(json, "content_type") ? void 0 : json["content_type"],
    "title": json["title"],
    "ownerId": json["owner_id"]
  };
}
function BestSellingItemToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "content_id": value.contentId,
    "content_type": value.contentType,
    "title": value.title,
    "owner_id": value.ownerId
  };
}
function instanceOfPlaylistFull(value) {
  let isInstance = true;
  isInstance = isInstance && "permalink" in value && value["permalink"] !== void 0;
  isInstance = isInstance && "id" in value && value["id"] !== void 0;
  isInstance = isInstance && "isAlbum" in value && value["isAlbum"] !== void 0;
  isInstance = isInstance && "isImageAutogenerated" in value && value["isImageAutogenerated"] !== void 0;
  isInstance = isInstance && "playlistName" in value && value["playlistName"] !== void 0;
  isInstance = isInstance && "playlistContents" in value && value["playlistContents"] !== void 0;
  isInstance = isInstance && "repostCount" in value && value["repostCount"] !== void 0;
  isInstance = isInstance && "favoriteCount" in value && value["favoriteCount"] !== void 0;
  isInstance = isInstance && "totalPlayCount" in value && value["totalPlayCount"] !== void 0;
  isInstance = isInstance && "user" in value && value["user"] !== void 0;
  isInstance = isInstance && "access" in value && value["access"] !== void 0;
  isInstance = isInstance && "trackCount" in value && value["trackCount"] !== void 0;
  isInstance = isInstance && "blocknumber" in value && value["blocknumber"] !== void 0;
  isInstance = isInstance && "createdAt" in value && value["createdAt"] !== void 0;
  isInstance = isInstance && "followeeReposts" in value && value["followeeReposts"] !== void 0;
  isInstance = isInstance && "followeeFavorites" in value && value["followeeFavorites"] !== void 0;
  isInstance = isInstance && "hasCurrentUserReposted" in value && value["hasCurrentUserReposted"] !== void 0;
  isInstance = isInstance && "hasCurrentUserSaved" in value && value["hasCurrentUserSaved"] !== void 0;
  isInstance = isInstance && "isDelete" in value && value["isDelete"] !== void 0;
  isInstance = isInstance && "isPrivate" in value && value["isPrivate"] !== void 0;
  isInstance = isInstance && "updatedAt" in value && value["updatedAt"] !== void 0;
  isInstance = isInstance && "addedTimestamps" in value && value["addedTimestamps"] !== void 0;
  isInstance = isInstance && "userId" in value && value["userId"] !== void 0;
  isInstance = isInstance && "isStreamGated" in value && value["isStreamGated"] !== void 0;
  isInstance = isInstance && "isScheduledRelease" in value && value["isScheduledRelease"] !== void 0;
  return isInstance;
}
function PlaylistFullFromJSON(json) {
  return PlaylistFullFromJSONTyped(json);
}
function PlaylistFullFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "artwork": !exists3(json, "artwork") ? void 0 : PlaylistArtworkFullFromJSON(json["artwork"]),
    "description": !exists3(json, "description") ? void 0 : json["description"],
    "permalink": json["permalink"],
    "id": json["id"],
    "isAlbum": json["is_album"],
    "isImageAutogenerated": json["is_image_autogenerated"],
    "playlistName": json["playlist_name"],
    "playlistContents": json["playlist_contents"].map(PlaylistAddedTimestampFromJSON),
    "repostCount": json["repost_count"],
    "favoriteCount": json["favorite_count"],
    "totalPlayCount": json["total_play_count"],
    "user": UserFullFromJSON(json["user"]),
    "ddexApp": !exists3(json, "ddex_app") ? void 0 : json["ddex_app"],
    "access": AccessFromJSON(json["access"]),
    "upc": !exists3(json, "upc") ? void 0 : json["upc"],
    "trackCount": json["track_count"],
    "blocknumber": json["blocknumber"],
    "createdAt": json["created_at"],
    "followeeReposts": json["followee_reposts"].map(RepostFromJSON),
    "followeeFavorites": json["followee_favorites"].map(FavoriteFromJSON),
    "hasCurrentUserReposted": json["has_current_user_reposted"],
    "hasCurrentUserSaved": json["has_current_user_saved"],
    "isDelete": json["is_delete"],
    "isPrivate": json["is_private"],
    "updatedAt": json["updated_at"],
    "addedTimestamps": json["added_timestamps"].map(PlaylistAddedTimestampFromJSON),
    "userId": json["user_id"],
    "tracks": !exists3(json, "tracks") ? void 0 : json["tracks"].map(TrackFullFromJSON),
    "coverArt": !exists3(json, "cover_art") ? void 0 : json["cover_art"],
    "coverArtSizes": !exists3(json, "cover_art_sizes") ? void 0 : json["cover_art_sizes"],
    "coverArtCids": !exists3(json, "cover_art_cids") ? void 0 : PlaylistArtworkFromJSON(json["cover_art_cids"]),
    "isStreamGated": json["is_stream_gated"],
    "streamConditions": !exists3(json, "stream_conditions") ? void 0 : AccessGateFromJSON(json["stream_conditions"]),
    "isScheduledRelease": json["is_scheduled_release"],
    "releaseDate": !exists3(json, "release_date") ? void 0 : json["release_date"],
    "ddexReleaseIds": !exists3(json, "ddex_release_ids") ? void 0 : json["ddex_release_ids"],
    "artists": !exists3(json, "artists") ? void 0 : json["artists"],
    "copyrightLine": !exists3(json, "copyright_line") ? void 0 : json["copyright_line"],
    "producerCopyrightLine": !exists3(json, "producer_copyright_line") ? void 0 : json["producer_copyright_line"],
    "parentalWarningType": !exists3(json, "parental_warning_type") ? void 0 : json["parental_warning_type"]
  };
}
function PlaylistFullToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "artwork": PlaylistArtworkFullToJSON(value.artwork),
    "description": value.description,
    "permalink": value.permalink,
    "id": value.id,
    "is_album": value.isAlbum,
    "is_image_autogenerated": value.isImageAutogenerated,
    "playlist_name": value.playlistName,
    "playlist_contents": value.playlistContents.map(PlaylistAddedTimestampToJSON),
    "repost_count": value.repostCount,
    "favorite_count": value.favoriteCount,
    "total_play_count": value.totalPlayCount,
    "user": UserFullToJSON(value.user),
    "ddex_app": value.ddexApp,
    "access": AccessToJSON(value.access),
    "upc": value.upc,
    "track_count": value.trackCount,
    "blocknumber": value.blocknumber,
    "created_at": value.createdAt,
    "followee_reposts": value.followeeReposts.map(RepostToJSON),
    "followee_favorites": value.followeeFavorites.map(FavoriteToJSON),
    "has_current_user_reposted": value.hasCurrentUserReposted,
    "has_current_user_saved": value.hasCurrentUserSaved,
    "is_delete": value.isDelete,
    "is_private": value.isPrivate,
    "updated_at": value.updatedAt,
    "added_timestamps": value.addedTimestamps.map(PlaylistAddedTimestampToJSON),
    "user_id": value.userId,
    "tracks": value.tracks === void 0 ? void 0 : value.tracks.map(TrackFullToJSON),
    "cover_art": value.coverArt,
    "cover_art_sizes": value.coverArtSizes,
    "cover_art_cids": PlaylistArtworkToJSON(value.coverArtCids),
    "is_stream_gated": value.isStreamGated,
    "stream_conditions": AccessGateToJSON(value.streamConditions),
    "is_scheduled_release": value.isScheduledRelease,
    "release_date": value.releaseDate,
    "ddex_release_ids": value.ddexReleaseIds,
    "artists": value.artists,
    "copyright_line": value.copyrightLine,
    "producer_copyright_line": value.producerCopyrightLine,
    "parental_warning_type": value.parentalWarningType
  };
}
function instanceOfRelated(value) {
  let isInstance = true;
  return isInstance;
}
function RelatedFromJSON(json) {
  return RelatedFromJSONTyped(json);
}
function RelatedFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "users": !exists3(json, "users") ? void 0 : json["users"].map(UserFullFromJSON),
    "tracks": !exists3(json, "tracks") ? void 0 : json["tracks"].map(TrackFullFromJSON),
    "playlists": !exists3(json, "playlists") ? void 0 : json["playlists"].map(PlaylistFullFromJSON)
  };
}
function RelatedToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "users": value.users === void 0 ? void 0 : value.users.map(UserFullToJSON),
    "tracks": value.tracks === void 0 ? void 0 : value.tracks.map(TrackFullToJSON),
    "playlists": value.playlists === void 0 ? void 0 : value.playlists.map(PlaylistFullToJSON)
  };
}
function instanceOfBestSellingFullResponse(value) {
  let isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value && value["latestChainBlock"] !== void 0;
  isInstance = isInstance && "latestIndexedBlock" in value && value["latestIndexedBlock"] !== void 0;
  isInstance = isInstance && "latestChainSlotPlays" in value && value["latestChainSlotPlays"] !== void 0;
  isInstance = isInstance && "latestIndexedSlotPlays" in value && value["latestIndexedSlotPlays"] !== void 0;
  isInstance = isInstance && "signature" in value && value["signature"] !== void 0;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== void 0;
  isInstance = isInstance && "version" in value && value["version"] !== void 0;
  return isInstance;
}
function BestSellingFullResponseFromJSON(json) {
  return BestSellingFullResponseFromJSONTyped(json);
}
function BestSellingFullResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "latestChainBlock": json["latest_chain_block"],
    "latestIndexedBlock": json["latest_indexed_block"],
    "latestChainSlotPlays": json["latest_chain_slot_plays"],
    "latestIndexedSlotPlays": json["latest_indexed_slot_plays"],
    "signature": json["signature"],
    "timestamp": json["timestamp"],
    "version": VersionMetadataFromJSON(json["version"]),
    "data": !exists3(json, "data") ? void 0 : json["data"].map(BestSellingItemFromJSON),
    "related": !exists3(json, "related") ? void 0 : RelatedFromJSON(json["related"])
  };
}
function BestSellingFullResponseToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "latest_chain_block": value.latestChainBlock,
    "latest_indexed_block": value.latestIndexedBlock,
    "latest_chain_slot_plays": value.latestChainSlotPlays,
    "latest_indexed_slot_plays": value.latestIndexedSlotPlays,
    "signature": value.signature,
    "timestamp": value.timestamp,
    "version": VersionMetadataToJSON(value.version),
    "data": value.data === void 0 ? void 0 : value.data.map(BestSellingItemToJSON),
    "related": RelatedToJSON(value.related)
  };
}
function instanceOfChallengeRewardNotificationActionData(value) {
  let isInstance = true;
  isInstance = isInstance && "amount" in value && value["amount"] !== void 0;
  isInstance = isInstance && "specifier" in value && value["specifier"] !== void 0;
  isInstance = isInstance && "challengeId" in value && value["challengeId"] !== void 0;
  return isInstance;
}
function ChallengeRewardNotificationActionDataFromJSON(json) {
  return ChallengeRewardNotificationActionDataFromJSONTyped(json);
}
function ChallengeRewardNotificationActionDataFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "amount": json["amount"],
    "specifier": json["specifier"],
    "challengeId": json["challenge_id"],
    "listenStreak": !exists3(json, "listen_streak") ? void 0 : json["listen_streak"]
  };
}
function ChallengeRewardNotificationActionDataToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "amount": value.amount,
    "specifier": value.specifier,
    "challenge_id": value.challengeId,
    "listen_streak": value.listenStreak
  };
}
function instanceOfChallengeRewardNotificationAction(value) {
  let isInstance = true;
  isInstance = isInstance && "specifier" in value && value["specifier"] !== void 0;
  isInstance = isInstance && "type" in value && value["type"] !== void 0;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== void 0;
  isInstance = isInstance && "data" in value && value["data"] !== void 0;
  return isInstance;
}
function ChallengeRewardNotificationActionFromJSON(json) {
  return ChallengeRewardNotificationActionFromJSONTyped(json);
}
function ChallengeRewardNotificationActionFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "specifier": json["specifier"],
    "type": json["type"],
    "timestamp": json["timestamp"],
    "data": ChallengeRewardNotificationActionDataFromJSON(json["data"])
  };
}
function ChallengeRewardNotificationActionToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "specifier": value.specifier,
    "type": value.type,
    "timestamp": value.timestamp,
    "data": ChallengeRewardNotificationActionDataToJSON(value.data)
  };
}
function instanceOfChallengeRewardNotification(value) {
  let isInstance = true;
  isInstance = isInstance && "type" in value && value["type"] !== void 0;
  isInstance = isInstance && "groupId" in value && value["groupId"] !== void 0;
  isInstance = isInstance && "isSeen" in value && value["isSeen"] !== void 0;
  isInstance = isInstance && "actions" in value && value["actions"] !== void 0;
  return isInstance;
}
function ChallengeRewardNotificationFromJSON(json) {
  return ChallengeRewardNotificationFromJSONTyped(json);
}
function ChallengeRewardNotificationFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "groupId": json["group_id"],
    "isSeen": json["is_seen"],
    "seenAt": !exists3(json, "seen_at") ? void 0 : json["seen_at"],
    "actions": json["actions"].map(ChallengeRewardNotificationActionFromJSON)
  };
}
function ChallengeRewardNotificationToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "group_id": value.groupId,
    "is_seen": value.isSeen,
    "seen_at": value.seenAt,
    "actions": value.actions.map(ChallengeRewardNotificationActionToJSON)
  };
}
function instanceOfCidData(value) {
  let isInstance = true;
  return isInstance;
}
function CidDataFromJSON(json) {
  return CidDataFromJSONTyped(json);
}
function CidDataFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "collectibles": !exists3(json, "collectibles") ? void 0 : json["collectibles"],
    "associatedSolWallets": !exists3(json, "associated_sol_wallets") ? void 0 : json["associated_sol_wallets"],
    "associatedWallets": !exists3(json, "associated_wallets") ? void 0 : json["associated_wallets"]
  };
}
function CidDataToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "collectibles": value.collectibles,
    "associated_sol_wallets": value.associatedSolWallets,
    "associated_wallets": value.associatedWallets
  };
}
function instanceOfDataAndType(value) {
  let isInstance = true;
  return isInstance;
}
function DataAndTypeFromJSON(json) {
  return DataAndTypeFromJSONTyped(json);
}
function DataAndTypeFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": !exists3(json, "type") ? void 0 : json["type"],
    "data": !exists3(json, "data") ? void 0 : CidDataFromJSON(json["data"])
  };
}
function DataAndTypeToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "data": CidDataToJSON(value.data)
  };
}
function instanceOfCidDataResponse(value) {
  let isInstance = true;
  return isInstance;
}
function CidDataResponseFromJSON(json) {
  return CidDataResponseFromJSONTyped(json);
}
function CidDataResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "data": !exists3(json, "data") ? void 0 : DataAndTypeFromJSON(json["data"])
  };
}
function CidDataResponseToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "data": DataAndTypeToJSON(value.data)
  };
}
function instanceOfClaimableRewardNotificationActionData(value) {
  let isInstance = true;
  isInstance = isInstance && "amount" in value && value["amount"] !== void 0;
  isInstance = isInstance && "specifier" in value && value["specifier"] !== void 0;
  isInstance = isInstance && "challengeId" in value && value["challengeId"] !== void 0;
  return isInstance;
}
function ClaimableRewardNotificationActionDataFromJSON(json) {
  return ClaimableRewardNotificationActionDataFromJSONTyped(json);
}
function ClaimableRewardNotificationActionDataFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "amount": json["amount"],
    "specifier": json["specifier"],
    "challengeId": json["challenge_id"]
  };
}
function ClaimableRewardNotificationActionDataToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "amount": value.amount,
    "specifier": value.specifier,
    "challenge_id": value.challengeId
  };
}
function instanceOfClaimableRewardNotificationAction(value) {
  let isInstance = true;
  isInstance = isInstance && "specifier" in value && value["specifier"] !== void 0;
  isInstance = isInstance && "type" in value && value["type"] !== void 0;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== void 0;
  isInstance = isInstance && "data" in value && value["data"] !== void 0;
  return isInstance;
}
function ClaimableRewardNotificationActionFromJSON(json) {
  return ClaimableRewardNotificationActionFromJSONTyped(json);
}
function ClaimableRewardNotificationActionFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "specifier": json["specifier"],
    "type": json["type"],
    "timestamp": json["timestamp"],
    "data": ClaimableRewardNotificationActionDataFromJSON(json["data"])
  };
}
function ClaimableRewardNotificationActionToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "specifier": value.specifier,
    "type": value.type,
    "timestamp": value.timestamp,
    "data": ClaimableRewardNotificationActionDataToJSON(value.data)
  };
}
function instanceOfClaimableRewardNotification(value) {
  let isInstance = true;
  isInstance = isInstance && "type" in value && value["type"] !== void 0;
  isInstance = isInstance && "groupId" in value && value["groupId"] !== void 0;
  isInstance = isInstance && "isSeen" in value && value["isSeen"] !== void 0;
  isInstance = isInstance && "actions" in value && value["actions"] !== void 0;
  return isInstance;
}
function ClaimableRewardNotificationFromJSON(json) {
  return ClaimableRewardNotificationFromJSONTyped(json);
}
function ClaimableRewardNotificationFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "groupId": json["group_id"],
    "isSeen": json["is_seen"],
    "seenAt": !exists3(json, "seen_at") ? void 0 : json["seen_at"],
    "actions": json["actions"].map(ClaimableRewardNotificationActionFromJSON)
  };
}
function ClaimableRewardNotificationToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "group_id": value.groupId,
    "is_seen": value.isSeen,
    "seen_at": value.seenAt,
    "actions": value.actions.map(ClaimableRewardNotificationActionToJSON)
  };
}
function instanceOfCoin(value) {
  let isInstance = true;
  isInstance = isInstance && "mint" in value && value["mint"] !== void 0;
  isInstance = isInstance && "ticker" in value && value["ticker"] !== void 0;
  isInstance = isInstance && "decimals" in value && value["decimals"] !== void 0;
  isInstance = isInstance && "name" in value && value["name"] !== void 0;
  isInstance = isInstance && "createdAt" in value && value["createdAt"] !== void 0;
  return isInstance;
}
function CoinFromJSON(json) {
  return CoinFromJSONTyped(json);
}
function CoinFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "mint": json["mint"],
    "ticker": json["ticker"],
    "decimals": json["decimals"],
    "name": json["name"],
    "logoUri": !exists3(json, "logo_uri") ? void 0 : json["logo_uri"],
    "description": !exists3(json, "description") ? void 0 : json["description"],
    "xHandle": !exists3(json, "x_handle") ? void 0 : json["x_handle"],
    "instagramHandle": !exists3(json, "instagram_handle") ? void 0 : json["instagram_handle"],
    "tiktokHandle": !exists3(json, "tiktok_handle") ? void 0 : json["tiktok_handle"],
    "website": !exists3(json, "website") ? void 0 : json["website"],
    "link1": !exists3(json, "link_1") ? void 0 : json["link_1"],
    "link2": !exists3(json, "link_2") ? void 0 : json["link_2"],
    "link3": !exists3(json, "link_3") ? void 0 : json["link_3"],
    "link4": !exists3(json, "link_4") ? void 0 : json["link_4"],
    "hasDiscord": !exists3(json, "has_discord") ? void 0 : json["has_discord"],
    "createdAt": new Date(json["created_at"]),
    "updatedAt": !exists3(json, "updated_at") ? void 0 : new Date(json["updated_at"]),
    "ownerId": !exists3(json, "owner_id") ? void 0 : json["owner_id"]
  };
}
function CoinToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "mint": value.mint,
    "ticker": value.ticker,
    "decimals": value.decimals,
    "name": value.name,
    "logo_uri": value.logoUri,
    "description": value.description,
    "x_handle": value.xHandle,
    "instagram_handle": value.instagramHandle,
    "tiktok_handle": value.tiktokHandle,
    "website": value.website,
    "link_1": value.link1,
    "link_2": value.link2,
    "link_3": value.link3,
    "link_4": value.link4,
    "has_discord": value.hasDiscord,
    "created_at": value.createdAt.toISOString(),
    "updated_at": value.updatedAt === void 0 ? void 0 : value.updatedAt.toISOString(),
    "owner_id": value.ownerId
  };
}
function instanceOfCoinResponse(value) {
  let isInstance = true;
  return isInstance;
}
function CoinResponseFromJSON(json) {
  return CoinResponseFromJSONTyped(json);
}
function CoinResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "data": !exists3(json, "data") ? void 0 : CoinFromJSON(json["data"])
  };
}
function CoinResponseToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "data": CoinToJSON(value.data)
  };
}
function instanceOfCoinsResponse(value) {
  let isInstance = true;
  isInstance = isInstance && "data" in value && value["data"] !== void 0;
  return isInstance;
}
function CoinsResponseFromJSON(json) {
  return CoinsResponseFromJSONTyped(json);
}
function CoinsResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "data": json["data"].map(CoinFromJSON)
  };
}
function CoinsResponseToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "data": value.data.map(CoinToJSON)
  };
}
var CollectionActivityFullItemTypeEnum = {
  Playlist: "playlist"
};
function instanceOfCollectionActivityFull(value) {
  let isInstance = true;
  isInstance = isInstance && "itemType" in value && value["itemType"] !== void 0;
  isInstance = isInstance && "item" in value && value["item"] !== void 0;
  return isInstance;
}
function CollectionActivityFullFromJSON(json) {
  return CollectionActivityFullFromJSONTyped(json, false);
}
function CollectionActivityFullFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    ...ActivityFullFromJSONTyped(json, ignoreDiscriminator),
    "itemType": json["item_type"],
    "item": PlaylistFullFromJSON(json["item"])
  };
}
function CollectionActivityFullToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    ...ActivityFullToJSON(value),
    "item_type": value.itemType,
    "item": PlaylistFullToJSON(value.item)
  };
}
var CollectionActivityFullWithoutTracksItemTypeEnum = {
  Playlist: "playlist"
};
function instanceOfCollectionActivityFullWithoutTracks(value) {
  let isInstance = true;
  isInstance = isInstance && "itemType" in value && value["itemType"] !== void 0;
  isInstance = isInstance && "item" in value && value["item"] !== void 0;
  return isInstance;
}
function CollectionActivityFullWithoutTracksFromJSON(json) {
  return CollectionActivityFullWithoutTracksFromJSONTyped(json, false);
}
function CollectionActivityFullWithoutTracksFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    ...ActivityFullFromJSONTyped(json, ignoreDiscriminator),
    "itemType": json["item_type"],
    "item": PlaylistFullWithoutTracksFromJSON(json["item"])
  };
}
function CollectionActivityFullWithoutTracksToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    ...ActivityFullToJSON(value),
    "item_type": value.itemType,
    "item": PlaylistFullWithoutTracksToJSON(value.item)
  };
}
function instanceOfCollectionLibraryResponseFull(value) {
  let isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value && value["latestChainBlock"] !== void 0;
  isInstance = isInstance && "latestIndexedBlock" in value && value["latestIndexedBlock"] !== void 0;
  isInstance = isInstance && "latestChainSlotPlays" in value && value["latestChainSlotPlays"] !== void 0;
  isInstance = isInstance && "latestIndexedSlotPlays" in value && value["latestIndexedSlotPlays"] !== void 0;
  isInstance = isInstance && "signature" in value && value["signature"] !== void 0;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== void 0;
  isInstance = isInstance && "version" in value && value["version"] !== void 0;
  return isInstance;
}
function CollectionLibraryResponseFullFromJSON(json) {
  return CollectionLibraryResponseFullFromJSONTyped(json);
}
function CollectionLibraryResponseFullFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "latestChainBlock": json["latest_chain_block"],
    "latestIndexedBlock": json["latest_indexed_block"],
    "latestChainSlotPlays": json["latest_chain_slot_plays"],
    "latestIndexedSlotPlays": json["latest_indexed_slot_plays"],
    "signature": json["signature"],
    "timestamp": json["timestamp"],
    "version": VersionMetadataFromJSON(json["version"]),
    "data": !exists3(json, "data") ? void 0 : json["data"].map(CollectionActivityFullWithoutTracksFromJSON)
  };
}
function CollectionLibraryResponseFullToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "latest_chain_block": value.latestChainBlock,
    "latest_indexed_block": value.latestIndexedBlock,
    "latest_chain_slot_plays": value.latestChainSlotPlays,
    "latest_indexed_slot_plays": value.latestIndexedSlotPlays,
    "signature": value.signature,
    "timestamp": value.timestamp,
    "version": VersionMetadataToJSON(value.version),
    "data": value.data === void 0 ? void 0 : value.data.map(CollectionActivityFullWithoutTracksToJSON)
  };
}
function instanceOfCommentMention(value) {
  let isInstance = true;
  isInstance = isInstance && "userId" in value && value["userId"] !== void 0;
  isInstance = isInstance && "handle" in value && value["handle"] !== void 0;
  return isInstance;
}
function CommentMentionFromJSON(json) {
  return CommentMentionFromJSONTyped(json);
}
function CommentMentionFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "userId": json["user_id"],
    "handle": json["handle"]
  };
}
function CommentMentionToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "user_id": value.userId,
    "handle": value.handle
  };
}
function instanceOfReplyComment(value) {
  let isInstance = true;
  isInstance = isInstance && "id" in value && value["id"] !== void 0;
  isInstance = isInstance && "entityId" in value && value["entityId"] !== void 0;
  isInstance = isInstance && "entityType" in value && value["entityType"] !== void 0;
  isInstance = isInstance && "userId" in value && value["userId"] !== void 0;
  isInstance = isInstance && "message" in value && value["message"] !== void 0;
  isInstance = isInstance && "reactCount" in value && value["reactCount"] !== void 0;
  isInstance = isInstance && "isEdited" in value && value["isEdited"] !== void 0;
  isInstance = isInstance && "createdAt" in value && value["createdAt"] !== void 0;
  return isInstance;
}
function ReplyCommentFromJSON(json) {
  return ReplyCommentFromJSONTyped(json);
}
function ReplyCommentFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "id": json["id"],
    "entityId": json["entity_id"],
    "entityType": json["entity_type"],
    "userId": json["user_id"],
    "message": json["message"],
    "mentions": !exists3(json, "mentions") ? void 0 : json["mentions"].map(CommentMentionFromJSON),
    "trackTimestampS": !exists3(json, "track_timestamp_s") ? void 0 : json["track_timestamp_s"],
    "reactCount": json["react_count"],
    "isEdited": json["is_edited"],
    "isCurrentUserReacted": !exists3(json, "is_current_user_reacted") ? void 0 : json["is_current_user_reacted"],
    "isArtistReacted": !exists3(json, "is_artist_reacted") ? void 0 : json["is_artist_reacted"],
    "createdAt": json["created_at"],
    "updatedAt": !exists3(json, "updated_at") ? void 0 : json["updated_at"],
    "parentCommentId": !exists3(json, "parent_comment_id") ? void 0 : json["parent_comment_id"]
  };
}
function ReplyCommentToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "id": value.id,
    "entity_id": value.entityId,
    "entity_type": value.entityType,
    "user_id": value.userId,
    "message": value.message,
    "mentions": value.mentions === void 0 ? void 0 : value.mentions.map(CommentMentionToJSON),
    "track_timestamp_s": value.trackTimestampS,
    "react_count": value.reactCount,
    "is_edited": value.isEdited,
    "is_current_user_reacted": value.isCurrentUserReacted,
    "is_artist_reacted": value.isArtistReacted,
    "created_at": value.createdAt,
    "updated_at": value.updatedAt,
    "parent_comment_id": value.parentCommentId
  };
}
function instanceOfComment(value) {
  let isInstance = true;
  isInstance = isInstance && "id" in value && value["id"] !== void 0;
  isInstance = isInstance && "entityId" in value && value["entityId"] !== void 0;
  isInstance = isInstance && "entityType" in value && value["entityType"] !== void 0;
  isInstance = isInstance && "message" in value && value["message"] !== void 0;
  isInstance = isInstance && "reactCount" in value && value["reactCount"] !== void 0;
  isInstance = isInstance && "replyCount" in value && value["replyCount"] !== void 0;
  isInstance = isInstance && "isEdited" in value && value["isEdited"] !== void 0;
  isInstance = isInstance && "createdAt" in value && value["createdAt"] !== void 0;
  return isInstance;
}
function CommentFromJSON(json) {
  return CommentFromJSONTyped(json);
}
function CommentFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "id": json["id"],
    "entityId": json["entity_id"],
    "entityType": json["entity_type"],
    "userId": !exists3(json, "user_id") ? void 0 : json["user_id"],
    "message": json["message"],
    "mentions": !exists3(json, "mentions") ? void 0 : json["mentions"].map(CommentMentionFromJSON),
    "trackTimestampS": !exists3(json, "track_timestamp_s") ? void 0 : json["track_timestamp_s"],
    "reactCount": json["react_count"],
    "replyCount": json["reply_count"],
    "isEdited": json["is_edited"],
    "isCurrentUserReacted": !exists3(json, "is_current_user_reacted") ? void 0 : json["is_current_user_reacted"],
    "isArtistReacted": !exists3(json, "is_artist_reacted") ? void 0 : json["is_artist_reacted"],
    "isTombstone": !exists3(json, "is_tombstone") ? void 0 : json["is_tombstone"],
    "isMuted": !exists3(json, "is_muted") ? void 0 : json["is_muted"],
    "createdAt": json["created_at"],
    "updatedAt": !exists3(json, "updated_at") ? void 0 : json["updated_at"],
    "replies": !exists3(json, "replies") ? void 0 : json["replies"].map(ReplyCommentFromJSON),
    "parentCommentId": !exists3(json, "parent_comment_id") ? void 0 : json["parent_comment_id"]
  };
}
function CommentToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "id": value.id,
    "entity_id": value.entityId,
    "entity_type": value.entityType,
    "user_id": value.userId,
    "message": value.message,
    "mentions": value.mentions === void 0 ? void 0 : value.mentions.map(CommentMentionToJSON),
    "track_timestamp_s": value.trackTimestampS,
    "react_count": value.reactCount,
    "reply_count": value.replyCount,
    "is_edited": value.isEdited,
    "is_current_user_reacted": value.isCurrentUserReacted,
    "is_artist_reacted": value.isArtistReacted,
    "is_tombstone": value.isTombstone,
    "is_muted": value.isMuted,
    "created_at": value.createdAt,
    "updated_at": value.updatedAt,
    "replies": value.replies === void 0 ? void 0 : value.replies.map(ReplyCommentToJSON),
    "parent_comment_id": value.parentCommentId
  };
}
var CommentMentionNotificationActionDataTypeEnum = {
  Track: "Track",
  Playlist: "Playlist",
  Album: "Album"
};
function instanceOfCommentMentionNotificationActionData(value) {
  let isInstance = true;
  isInstance = isInstance && "type" in value && value["type"] !== void 0;
  isInstance = isInstance && "entityId" in value && value["entityId"] !== void 0;
  isInstance = isInstance && "entityUserId" in value && value["entityUserId"] !== void 0;
  isInstance = isInstance && "commentUserId" in value && value["commentUserId"] !== void 0;
  return isInstance;
}
function CommentMentionNotificationActionDataFromJSON(json) {
  return CommentMentionNotificationActionDataFromJSONTyped(json);
}
function CommentMentionNotificationActionDataFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "entityId": json["entity_id"],
    "entityUserId": json["entity_user_id"],
    "commentUserId": json["comment_user_id"],
    "commentId": !exists3(json, "comment_id") ? void 0 : json["comment_id"]
  };
}
function CommentMentionNotificationActionDataToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "entity_id": value.entityId,
    "entity_user_id": value.entityUserId,
    "comment_user_id": value.commentUserId,
    "comment_id": value.commentId
  };
}
function instanceOfCommentMentionNotificationAction(value) {
  let isInstance = true;
  isInstance = isInstance && "specifier" in value && value["specifier"] !== void 0;
  isInstance = isInstance && "type" in value && value["type"] !== void 0;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== void 0;
  isInstance = isInstance && "data" in value && value["data"] !== void 0;
  return isInstance;
}
function CommentMentionNotificationActionFromJSON(json) {
  return CommentMentionNotificationActionFromJSONTyped(json);
}
function CommentMentionNotificationActionFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "specifier": json["specifier"],
    "type": json["type"],
    "timestamp": json["timestamp"],
    "data": CommentMentionNotificationActionDataFromJSON(json["data"])
  };
}
function CommentMentionNotificationActionToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "specifier": value.specifier,
    "type": value.type,
    "timestamp": value.timestamp,
    "data": CommentMentionNotificationActionDataToJSON(value.data)
  };
}
function instanceOfCommentMentionNotification(value) {
  let isInstance = true;
  isInstance = isInstance && "type" in value && value["type"] !== void 0;
  isInstance = isInstance && "groupId" in value && value["groupId"] !== void 0;
  isInstance = isInstance && "isSeen" in value && value["isSeen"] !== void 0;
  isInstance = isInstance && "actions" in value && value["actions"] !== void 0;
  return isInstance;
}
function CommentMentionNotificationFromJSON(json) {
  return CommentMentionNotificationFromJSONTyped(json);
}
function CommentMentionNotificationFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "groupId": json["group_id"],
    "isSeen": json["is_seen"],
    "seenAt": !exists3(json, "seen_at") ? void 0 : json["seen_at"],
    "actions": json["actions"].map(CommentMentionNotificationActionFromJSON)
  };
}
function CommentMentionNotificationToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "group_id": value.groupId,
    "is_seen": value.isSeen,
    "seen_at": value.seenAt,
    "actions": value.actions.map(CommentMentionNotificationActionToJSON)
  };
}
var CommentNotificationActionDataTypeEnum = {
  Track: "Track",
  Playlist: "Playlist",
  Album: "Album"
};
function instanceOfCommentNotificationActionData(value) {
  let isInstance = true;
  isInstance = isInstance && "type" in value && value["type"] !== void 0;
  isInstance = isInstance && "entityId" in value && value["entityId"] !== void 0;
  isInstance = isInstance && "commentUserId" in value && value["commentUserId"] !== void 0;
  return isInstance;
}
function CommentNotificationActionDataFromJSON(json) {
  return CommentNotificationActionDataFromJSONTyped(json);
}
function CommentNotificationActionDataFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "entityId": json["entity_id"],
    "commentUserId": json["comment_user_id"],
    "commentId": !exists3(json, "comment_id") ? void 0 : json["comment_id"]
  };
}
function CommentNotificationActionDataToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "entity_id": value.entityId,
    "comment_user_id": value.commentUserId,
    "comment_id": value.commentId
  };
}
function instanceOfCommentNotificationAction(value) {
  let isInstance = true;
  isInstance = isInstance && "specifier" in value && value["specifier"] !== void 0;
  isInstance = isInstance && "type" in value && value["type"] !== void 0;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== void 0;
  isInstance = isInstance && "data" in value && value["data"] !== void 0;
  return isInstance;
}
function CommentNotificationActionFromJSON(json) {
  return CommentNotificationActionFromJSONTyped(json);
}
function CommentNotificationActionFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "specifier": json["specifier"],
    "type": json["type"],
    "timestamp": json["timestamp"],
    "data": CommentNotificationActionDataFromJSON(json["data"])
  };
}
function CommentNotificationActionToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "specifier": value.specifier,
    "type": value.type,
    "timestamp": value.timestamp,
    "data": CommentNotificationActionDataToJSON(value.data)
  };
}
function instanceOfCommentNotification(value) {
  let isInstance = true;
  isInstance = isInstance && "type" in value && value["type"] !== void 0;
  isInstance = isInstance && "groupId" in value && value["groupId"] !== void 0;
  isInstance = isInstance && "isSeen" in value && value["isSeen"] !== void 0;
  isInstance = isInstance && "actions" in value && value["actions"] !== void 0;
  return isInstance;
}
function CommentNotificationFromJSON(json) {
  return CommentNotificationFromJSONTyped(json);
}
function CommentNotificationFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "groupId": json["group_id"],
    "isSeen": json["is_seen"],
    "seenAt": !exists3(json, "seen_at") ? void 0 : json["seen_at"],
    "actions": json["actions"].map(CommentNotificationActionFromJSON)
  };
}
function CommentNotificationToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "group_id": value.groupId,
    "is_seen": value.isSeen,
    "seen_at": value.seenAt,
    "actions": value.actions.map(CommentNotificationActionToJSON)
  };
}
var CommentReactionNotificationActionDataTypeEnum = {
  Track: "Track",
  Playlist: "Playlist",
  Album: "Album"
};
function instanceOfCommentReactionNotificationActionData(value) {
  let isInstance = true;
  isInstance = isInstance && "type" in value && value["type"] !== void 0;
  isInstance = isInstance && "entityId" in value && value["entityId"] !== void 0;
  isInstance = isInstance && "entityUserId" in value && value["entityUserId"] !== void 0;
  isInstance = isInstance && "reacterUserId" in value && value["reacterUserId"] !== void 0;
  return isInstance;
}
function CommentReactionNotificationActionDataFromJSON(json) {
  return CommentReactionNotificationActionDataFromJSONTyped(json);
}
function CommentReactionNotificationActionDataFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "entityId": json["entity_id"],
    "entityUserId": json["entity_user_id"],
    "reacterUserId": json["reacter_user_id"],
    "commentId": !exists3(json, "comment_id") ? void 0 : json["comment_id"]
  };
}
function CommentReactionNotificationActionDataToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "entity_id": value.entityId,
    "entity_user_id": value.entityUserId,
    "reacter_user_id": value.reacterUserId,
    "comment_id": value.commentId
  };
}
function instanceOfCommentReactionNotificationAction(value) {
  let isInstance = true;
  isInstance = isInstance && "specifier" in value && value["specifier"] !== void 0;
  isInstance = isInstance && "type" in value && value["type"] !== void 0;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== void 0;
  isInstance = isInstance && "data" in value && value["data"] !== void 0;
  return isInstance;
}
function CommentReactionNotificationActionFromJSON(json) {
  return CommentReactionNotificationActionFromJSONTyped(json);
}
function CommentReactionNotificationActionFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "specifier": json["specifier"],
    "type": json["type"],
    "timestamp": json["timestamp"],
    "data": CommentReactionNotificationActionDataFromJSON(json["data"])
  };
}
function CommentReactionNotificationActionToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "specifier": value.specifier,
    "type": value.type,
    "timestamp": value.timestamp,
    "data": CommentReactionNotificationActionDataToJSON(value.data)
  };
}
function instanceOfCommentReactionNotification(value) {
  let isInstance = true;
  isInstance = isInstance && "type" in value && value["type"] !== void 0;
  isInstance = isInstance && "groupId" in value && value["groupId"] !== void 0;
  isInstance = isInstance && "isSeen" in value && value["isSeen"] !== void 0;
  isInstance = isInstance && "actions" in value && value["actions"] !== void 0;
  return isInstance;
}
function CommentReactionNotificationFromJSON(json) {
  return CommentReactionNotificationFromJSONTyped(json);
}
function CommentReactionNotificationFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "groupId": json["group_id"],
    "isSeen": json["is_seen"],
    "seenAt": !exists3(json, "seen_at") ? void 0 : json["seen_at"],
    "actions": json["actions"].map(CommentReactionNotificationActionFromJSON)
  };
}
function CommentReactionNotificationToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "group_id": value.groupId,
    "is_seen": value.isSeen,
    "seen_at": value.seenAt,
    "actions": value.actions.map(CommentReactionNotificationActionToJSON)
  };
}
function instanceOfCommentRepliesResponse(value) {
  let isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value && value["latestChainBlock"] !== void 0;
  isInstance = isInstance && "latestIndexedBlock" in value && value["latestIndexedBlock"] !== void 0;
  isInstance = isInstance && "latestChainSlotPlays" in value && value["latestChainSlotPlays"] !== void 0;
  isInstance = isInstance && "latestIndexedSlotPlays" in value && value["latestIndexedSlotPlays"] !== void 0;
  isInstance = isInstance && "signature" in value && value["signature"] !== void 0;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== void 0;
  isInstance = isInstance && "version" in value && value["version"] !== void 0;
  return isInstance;
}
function CommentRepliesResponseFromJSON(json) {
  return CommentRepliesResponseFromJSONTyped(json);
}
function CommentRepliesResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "latestChainBlock": json["latest_chain_block"],
    "latestIndexedBlock": json["latest_indexed_block"],
    "latestChainSlotPlays": json["latest_chain_slot_plays"],
    "latestIndexedSlotPlays": json["latest_indexed_slot_plays"],
    "signature": json["signature"],
    "timestamp": json["timestamp"],
    "version": VersionMetadataFromJSON(json["version"]),
    "data": !exists3(json, "data") ? void 0 : json["data"].map(ReplyCommentFromJSON),
    "related": !exists3(json, "related") ? void 0 : RelatedFromJSON(json["related"])
  };
}
function CommentRepliesResponseToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "latest_chain_block": value.latestChainBlock,
    "latest_indexed_block": value.latestIndexedBlock,
    "latest_chain_slot_plays": value.latestChainSlotPlays,
    "latest_indexed_slot_plays": value.latestIndexedSlotPlays,
    "signature": value.signature,
    "timestamp": value.timestamp,
    "version": VersionMetadataToJSON(value.version),
    "data": value.data === void 0 ? void 0 : value.data.map(ReplyCommentToJSON),
    "related": RelatedToJSON(value.related)
  };
}
function instanceOfCommentResponse(value) {
  let isInstance = true;
  return isInstance;
}
function CommentResponseFromJSON(json) {
  return CommentResponseFromJSONTyped(json);
}
function CommentResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "data": !exists3(json, "data") ? void 0 : json["data"].map(CommentFromJSON)
  };
}
function CommentResponseToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "data": value.data === void 0 ? void 0 : value.data.map(CommentToJSON)
  };
}
var CommentThreadNotificationActionDataTypeEnum = {
  Track: "Track",
  Playlist: "Playlist",
  Album: "Album"
};
function instanceOfCommentThreadNotificationActionData(value) {
  let isInstance = true;
  isInstance = isInstance && "type" in value && value["type"] !== void 0;
  isInstance = isInstance && "entityId" in value && value["entityId"] !== void 0;
  isInstance = isInstance && "entityUserId" in value && value["entityUserId"] !== void 0;
  isInstance = isInstance && "commentUserId" in value && value["commentUserId"] !== void 0;
  return isInstance;
}
function CommentThreadNotificationActionDataFromJSON(json) {
  return CommentThreadNotificationActionDataFromJSONTyped(json);
}
function CommentThreadNotificationActionDataFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "entityId": json["entity_id"],
    "entityUserId": json["entity_user_id"],
    "commentUserId": json["comment_user_id"],
    "commentId": !exists3(json, "comment_id") ? void 0 : json["comment_id"]
  };
}
function CommentThreadNotificationActionDataToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "entity_id": value.entityId,
    "entity_user_id": value.entityUserId,
    "comment_user_id": value.commentUserId,
    "comment_id": value.commentId
  };
}
function instanceOfCommentThreadNotificationAction(value) {
  let isInstance = true;
  isInstance = isInstance && "specifier" in value && value["specifier"] !== void 0;
  isInstance = isInstance && "type" in value && value["type"] !== void 0;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== void 0;
  isInstance = isInstance && "data" in value && value["data"] !== void 0;
  return isInstance;
}
function CommentThreadNotificationActionFromJSON(json) {
  return CommentThreadNotificationActionFromJSONTyped(json);
}
function CommentThreadNotificationActionFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "specifier": json["specifier"],
    "type": json["type"],
    "timestamp": json["timestamp"],
    "data": CommentThreadNotificationActionDataFromJSON(json["data"])
  };
}
function CommentThreadNotificationActionToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "specifier": value.specifier,
    "type": value.type,
    "timestamp": value.timestamp,
    "data": CommentThreadNotificationActionDataToJSON(value.data)
  };
}
function instanceOfCommentThreadNotification(value) {
  let isInstance = true;
  isInstance = isInstance && "type" in value && value["type"] !== void 0;
  isInstance = isInstance && "groupId" in value && value["groupId"] !== void 0;
  isInstance = isInstance && "isSeen" in value && value["isSeen"] !== void 0;
  isInstance = isInstance && "actions" in value && value["actions"] !== void 0;
  return isInstance;
}
function CommentThreadNotificationFromJSON(json) {
  return CommentThreadNotificationFromJSONTyped(json);
}
function CommentThreadNotificationFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "groupId": json["group_id"],
    "isSeen": json["is_seen"],
    "seenAt": !exists3(json, "seen_at") ? void 0 : json["seen_at"],
    "actions": json["actions"].map(CommentThreadNotificationActionFromJSON)
  };
}
function CommentThreadNotificationToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "group_id": value.groupId,
    "is_seen": value.isSeen,
    "seen_at": value.seenAt,
    "actions": value.actions.map(CommentThreadNotificationActionToJSON)
  };
}
function instanceOfCosignNotificationActionData(value) {
  let isInstance = true;
  isInstance = isInstance && "parentTrackId" in value && value["parentTrackId"] !== void 0;
  isInstance = isInstance && "trackId" in value && value["trackId"] !== void 0;
  isInstance = isInstance && "trackOwnerId" in value && value["trackOwnerId"] !== void 0;
  return isInstance;
}
function CosignNotificationActionDataFromJSON(json) {
  return CosignNotificationActionDataFromJSONTyped(json);
}
function CosignNotificationActionDataFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "parentTrackId": json["parent_track_id"],
    "trackId": json["track_id"],
    "trackOwnerId": json["track_owner_id"]
  };
}
function CosignNotificationActionDataToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "parent_track_id": value.parentTrackId,
    "track_id": value.trackId,
    "track_owner_id": value.trackOwnerId
  };
}
function instanceOfCosignNotificationAction(value) {
  let isInstance = true;
  isInstance = isInstance && "specifier" in value && value["specifier"] !== void 0;
  isInstance = isInstance && "type" in value && value["type"] !== void 0;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== void 0;
  isInstance = isInstance && "data" in value && value["data"] !== void 0;
  return isInstance;
}
function CosignNotificationActionFromJSON(json) {
  return CosignNotificationActionFromJSONTyped(json);
}
function CosignNotificationActionFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "specifier": json["specifier"],
    "type": json["type"],
    "timestamp": json["timestamp"],
    "data": CosignNotificationActionDataFromJSON(json["data"])
  };
}
function CosignNotificationActionToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "specifier": value.specifier,
    "type": value.type,
    "timestamp": value.timestamp,
    "data": CosignNotificationActionDataToJSON(value.data)
  };
}
function instanceOfCosignNotification(value) {
  let isInstance = true;
  isInstance = isInstance && "type" in value && value["type"] !== void 0;
  isInstance = isInstance && "groupId" in value && value["groupId"] !== void 0;
  isInstance = isInstance && "isSeen" in value && value["isSeen"] !== void 0;
  isInstance = isInstance && "actions" in value && value["actions"] !== void 0;
  return isInstance;
}
function CosignNotificationFromJSON(json) {
  return CosignNotificationFromJSONTyped(json);
}
function CosignNotificationFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "groupId": json["group_id"],
    "isSeen": json["is_seen"],
    "seenAt": !exists3(json, "seen_at") ? void 0 : json["seen_at"],
    "actions": json["actions"].map(CosignNotificationActionFromJSON)
  };
}
function CosignNotificationToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "group_id": value.groupId,
    "is_seen": value.isSeen,
    "seen_at": value.seenAt,
    "actions": value.actions.map(CosignNotificationActionToJSON)
  };
}
function instanceOfCreateCoinRequest(value) {
  let isInstance = true;
  isInstance = isInstance && "mint" in value && value["mint"] !== void 0;
  isInstance = isInstance && "ticker" in value && value["ticker"] !== void 0;
  isInstance = isInstance && "decimals" in value && value["decimals"] !== void 0;
  isInstance = isInstance && "name" in value && value["name"] !== void 0;
  return isInstance;
}
function CreateCoinRequestFromJSON(json) {
  return CreateCoinRequestFromJSONTyped(json);
}
function CreateCoinRequestFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "mint": json["mint"],
    "ticker": json["ticker"],
    "decimals": json["decimals"],
    "name": json["name"],
    "logoUri": !exists3(json, "logo_uri") ? void 0 : json["logo_uri"],
    "description": !exists3(json, "description") ? void 0 : json["description"]
  };
}
function CreateCoinRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "mint": value.mint,
    "ticker": value.ticker,
    "decimals": value.decimals,
    "name": value.name,
    "logo_uri": value.logoUri,
    "description": value.description
  };
}
function instanceOfCreateCoinResponseData(value) {
  let isInstance = true;
  isInstance = isInstance && "mint" in value && value["mint"] !== void 0;
  isInstance = isInstance && "ticker" in value && value["ticker"] !== void 0;
  isInstance = isInstance && "userId" in value && value["userId"] !== void 0;
  isInstance = isInstance && "decimals" in value && value["decimals"] !== void 0;
  isInstance = isInstance && "name" in value && value["name"] !== void 0;
  isInstance = isInstance && "createdAt" in value && value["createdAt"] !== void 0;
  return isInstance;
}
function CreateCoinResponseDataFromJSON(json) {
  return CreateCoinResponseDataFromJSONTyped(json);
}
function CreateCoinResponseDataFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "mint": json["mint"],
    "ticker": json["ticker"],
    "userId": json["user_id"],
    "decimals": json["decimals"],
    "name": json["name"],
    "logoUri": !exists3(json, "logo_uri") ? void 0 : json["logo_uri"],
    "createdAt": new Date(json["created_at"])
  };
}
function CreateCoinResponseDataToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "mint": value.mint,
    "ticker": value.ticker,
    "user_id": value.userId,
    "decimals": value.decimals,
    "name": value.name,
    "logo_uri": value.logoUri,
    "created_at": value.createdAt.toISOString()
  };
}
function instanceOfCreateCoinResponse(value) {
  let isInstance = true;
  return isInstance;
}
function CreateCoinResponseFromJSON(json) {
  return CreateCoinResponseFromJSONTyped(json);
}
function CreateCoinResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "data": !exists3(json, "data") ? void 0 : CreateCoinResponseDataFromJSON(json["data"])
  };
}
function CreateCoinResponseToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "data": CreateCoinResponseDataToJSON(value.data)
  };
}
function instanceOfCreatePlaylistNotificationActionData(value) {
  let isInstance = true;
  isInstance = isInstance && "isAlbum" in value && value["isAlbum"] !== void 0;
  isInstance = isInstance && "playlistId" in value && value["playlistId"] !== void 0;
  return isInstance;
}
function CreatePlaylistNotificationActionDataFromJSON(json) {
  return CreatePlaylistNotificationActionDataFromJSONTyped(json);
}
function CreatePlaylistNotificationActionDataFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "isAlbum": json["is_album"],
    "playlistId": json["playlist_id"]
  };
}
function CreatePlaylistNotificationActionDataToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "is_album": value.isAlbum,
    "playlist_id": value.playlistId
  };
}
function instanceOfCreateTrackNotificationActionData(value) {
  let isInstance = true;
  isInstance = isInstance && "trackId" in value && value["trackId"] !== void 0;
  return isInstance;
}
function CreateTrackNotificationActionDataFromJSON(json) {
  return CreateTrackNotificationActionDataFromJSONTyped(json);
}
function CreateTrackNotificationActionDataFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "trackId": json["track_id"]
  };
}
function CreateTrackNotificationActionDataToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "track_id": value.trackId
  };
}
function CreateNotificationActionDataFromJSON(json) {
  return CreateNotificationActionDataFromJSONTyped(json);
}
function CreateNotificationActionDataFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    ...CreatePlaylistNotificationActionDataFromJSONTyped(json),
    ...CreateTrackNotificationActionDataFromJSONTyped(json)
  };
}
function CreateNotificationActionDataToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  if (instanceOfCreatePlaylistNotificationActionData(value)) {
    return CreatePlaylistNotificationActionDataToJSON(value);
  }
  if (instanceOfCreateTrackNotificationActionData(value)) {
    return CreateTrackNotificationActionDataToJSON(value);
  }
  return {};
}
function instanceOfCreateNotificationAction(value) {
  let isInstance = true;
  isInstance = isInstance && "specifier" in value && value["specifier"] !== void 0;
  isInstance = isInstance && "type" in value && value["type"] !== void 0;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== void 0;
  isInstance = isInstance && "data" in value && value["data"] !== void 0;
  return isInstance;
}
function CreateNotificationActionFromJSON(json) {
  return CreateNotificationActionFromJSONTyped(json);
}
function CreateNotificationActionFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "specifier": json["specifier"],
    "type": json["type"],
    "timestamp": json["timestamp"],
    "data": CreateNotificationActionDataFromJSON(json["data"])
  };
}
function CreateNotificationActionToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "specifier": value.specifier,
    "type": value.type,
    "timestamp": value.timestamp,
    "data": CreateNotificationActionDataToJSON(value.data)
  };
}
function instanceOfCreateNotification(value) {
  let isInstance = true;
  isInstance = isInstance && "type" in value && value["type"] !== void 0;
  isInstance = isInstance && "groupId" in value && value["groupId"] !== void 0;
  isInstance = isInstance && "isSeen" in value && value["isSeen"] !== void 0;
  isInstance = isInstance && "actions" in value && value["actions"] !== void 0;
  return isInstance;
}
function CreateNotificationFromJSON(json) {
  return CreateNotificationFromJSONTyped(json);
}
function CreateNotificationFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "groupId": json["group_id"],
    "isSeen": json["is_seen"],
    "seenAt": !exists3(json, "seen_at") ? void 0 : json["seen_at"],
    "actions": json["actions"].map(CreateNotificationActionFromJSON)
  };
}
function CreateNotificationToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "group_id": value.groupId,
    "is_seen": value.isSeen,
    "seen_at": value.seenAt,
    "actions": value.actions.map(CreateNotificationActionToJSON)
  };
}
function instanceOfFanRemixContestEndedNotificationActionData(value) {
  let isInstance = true;
  isInstance = isInstance && "entityUserId" in value && value["entityUserId"] !== void 0;
  isInstance = isInstance && "entityId" in value && value["entityId"] !== void 0;
  return isInstance;
}
function FanRemixContestEndedNotificationActionDataFromJSON(json) {
  return FanRemixContestEndedNotificationActionDataFromJSONTyped(json);
}
function FanRemixContestEndedNotificationActionDataFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "entityUserId": json["entity_user_id"],
    "entityId": json["entity_id"]
  };
}
function FanRemixContestEndedNotificationActionDataToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "entity_user_id": value.entityUserId,
    "entity_id": value.entityId
  };
}
function instanceOfFanRemixContestEndedNotificationAction(value) {
  let isInstance = true;
  isInstance = isInstance && "specifier" in value && value["specifier"] !== void 0;
  isInstance = isInstance && "type" in value && value["type"] !== void 0;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== void 0;
  isInstance = isInstance && "data" in value && value["data"] !== void 0;
  return isInstance;
}
function FanRemixContestEndedNotificationActionFromJSON(json) {
  return FanRemixContestEndedNotificationActionFromJSONTyped(json);
}
function FanRemixContestEndedNotificationActionFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "specifier": json["specifier"],
    "type": json["type"],
    "timestamp": json["timestamp"],
    "data": FanRemixContestEndedNotificationActionDataFromJSON(json["data"])
  };
}
function FanRemixContestEndedNotificationActionToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "specifier": value.specifier,
    "type": value.type,
    "timestamp": value.timestamp,
    "data": FanRemixContestEndedNotificationActionDataToJSON(value.data)
  };
}
function instanceOfFanRemixContestEndedNotification(value) {
  let isInstance = true;
  isInstance = isInstance && "type" in value && value["type"] !== void 0;
  isInstance = isInstance && "groupId" in value && value["groupId"] !== void 0;
  isInstance = isInstance && "isSeen" in value && value["isSeen"] !== void 0;
  isInstance = isInstance && "actions" in value && value["actions"] !== void 0;
  return isInstance;
}
function FanRemixContestEndedNotificationFromJSON(json) {
  return FanRemixContestEndedNotificationFromJSONTyped(json);
}
function FanRemixContestEndedNotificationFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "groupId": json["group_id"],
    "isSeen": json["is_seen"],
    "seenAt": !exists3(json, "seen_at") ? void 0 : json["seen_at"],
    "actions": json["actions"].map(FanRemixContestEndedNotificationActionFromJSON)
  };
}
function FanRemixContestEndedNotificationToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "group_id": value.groupId,
    "is_seen": value.isSeen,
    "seen_at": value.seenAt,
    "actions": value.actions.map(FanRemixContestEndedNotificationActionToJSON)
  };
}
function instanceOfFanRemixContestEndingSoonNotificationActionData(value) {
  let isInstance = true;
  isInstance = isInstance && "entityUserId" in value && value["entityUserId"] !== void 0;
  isInstance = isInstance && "entityId" in value && value["entityId"] !== void 0;
  return isInstance;
}
function FanRemixContestEndingSoonNotificationActionDataFromJSON(json) {
  return FanRemixContestEndingSoonNotificationActionDataFromJSONTyped(json);
}
function FanRemixContestEndingSoonNotificationActionDataFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "entityUserId": json["entity_user_id"],
    "entityId": json["entity_id"]
  };
}
function FanRemixContestEndingSoonNotificationActionDataToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "entity_user_id": value.entityUserId,
    "entity_id": value.entityId
  };
}
function instanceOfFanRemixContestEndingSoonNotificationAction(value) {
  let isInstance = true;
  isInstance = isInstance && "specifier" in value && value["specifier"] !== void 0;
  isInstance = isInstance && "type" in value && value["type"] !== void 0;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== void 0;
  isInstance = isInstance && "data" in value && value["data"] !== void 0;
  return isInstance;
}
function FanRemixContestEndingSoonNotificationActionFromJSON(json) {
  return FanRemixContestEndingSoonNotificationActionFromJSONTyped(json);
}
function FanRemixContestEndingSoonNotificationActionFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "specifier": json["specifier"],
    "type": json["type"],
    "timestamp": json["timestamp"],
    "data": FanRemixContestEndingSoonNotificationActionDataFromJSON(json["data"])
  };
}
function FanRemixContestEndingSoonNotificationActionToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "specifier": value.specifier,
    "type": value.type,
    "timestamp": value.timestamp,
    "data": FanRemixContestEndingSoonNotificationActionDataToJSON(value.data)
  };
}
function instanceOfFanRemixContestEndingSoonNotification(value) {
  let isInstance = true;
  isInstance = isInstance && "type" in value && value["type"] !== void 0;
  isInstance = isInstance && "groupId" in value && value["groupId"] !== void 0;
  isInstance = isInstance && "isSeen" in value && value["isSeen"] !== void 0;
  isInstance = isInstance && "actions" in value && value["actions"] !== void 0;
  return isInstance;
}
function FanRemixContestEndingSoonNotificationFromJSON(json) {
  return FanRemixContestEndingSoonNotificationFromJSONTyped(json);
}
function FanRemixContestEndingSoonNotificationFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "groupId": json["group_id"],
    "isSeen": json["is_seen"],
    "seenAt": !exists3(json, "seen_at") ? void 0 : json["seen_at"],
    "actions": json["actions"].map(FanRemixContestEndingSoonNotificationActionFromJSON)
  };
}
function FanRemixContestEndingSoonNotificationToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "group_id": value.groupId,
    "is_seen": value.isSeen,
    "seen_at": value.seenAt,
    "actions": value.actions.map(FanRemixContestEndingSoonNotificationActionToJSON)
  };
}
function instanceOfFanRemixContestStartedNotificationActionData(value) {
  let isInstance = true;
  isInstance = isInstance && "entityUserId" in value && value["entityUserId"] !== void 0;
  isInstance = isInstance && "entityId" in value && value["entityId"] !== void 0;
  return isInstance;
}
function FanRemixContestStartedNotificationActionDataFromJSON(json) {
  return FanRemixContestStartedNotificationActionDataFromJSONTyped(json);
}
function FanRemixContestStartedNotificationActionDataFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "entityUserId": json["entity_user_id"],
    "entityId": json["entity_id"]
  };
}
function FanRemixContestStartedNotificationActionDataToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "entity_user_id": value.entityUserId,
    "entity_id": value.entityId
  };
}
function instanceOfFanRemixContestStartedNotificationAction(value) {
  let isInstance = true;
  isInstance = isInstance && "specifier" in value && value["specifier"] !== void 0;
  isInstance = isInstance && "type" in value && value["type"] !== void 0;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== void 0;
  isInstance = isInstance && "data" in value && value["data"] !== void 0;
  return isInstance;
}
function FanRemixContestStartedNotificationActionFromJSON(json) {
  return FanRemixContestStartedNotificationActionFromJSONTyped(json);
}
function FanRemixContestStartedNotificationActionFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "specifier": json["specifier"],
    "type": json["type"],
    "timestamp": json["timestamp"],
    "data": FanRemixContestStartedNotificationActionDataFromJSON(json["data"])
  };
}
function FanRemixContestStartedNotificationActionToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "specifier": value.specifier,
    "type": value.type,
    "timestamp": value.timestamp,
    "data": FanRemixContestStartedNotificationActionDataToJSON(value.data)
  };
}
function instanceOfFanRemixContestStartedNotification(value) {
  let isInstance = true;
  isInstance = isInstance && "type" in value && value["type"] !== void 0;
  isInstance = isInstance && "groupId" in value && value["groupId"] !== void 0;
  isInstance = isInstance && "isSeen" in value && value["isSeen"] !== void 0;
  isInstance = isInstance && "actions" in value && value["actions"] !== void 0;
  return isInstance;
}
function FanRemixContestStartedNotificationFromJSON(json) {
  return FanRemixContestStartedNotificationFromJSONTyped(json);
}
function FanRemixContestStartedNotificationFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "groupId": json["group_id"],
    "isSeen": json["is_seen"],
    "seenAt": !exists3(json, "seen_at") ? void 0 : json["seen_at"],
    "actions": json["actions"].map(FanRemixContestStartedNotificationActionFromJSON)
  };
}
function FanRemixContestStartedNotificationToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "group_id": value.groupId,
    "is_seen": value.isSeen,
    "seen_at": value.seenAt,
    "actions": value.actions.map(FanRemixContestStartedNotificationActionToJSON)
  };
}
function instanceOfFanRemixContestWinnersSelectedNotificationActionData(value) {
  let isInstance = true;
  isInstance = isInstance && "entityUserId" in value && value["entityUserId"] !== void 0;
  isInstance = isInstance && "entityId" in value && value["entityId"] !== void 0;
  return isInstance;
}
function FanRemixContestWinnersSelectedNotificationActionDataFromJSON(json) {
  return FanRemixContestWinnersSelectedNotificationActionDataFromJSONTyped(json);
}
function FanRemixContestWinnersSelectedNotificationActionDataFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "entityUserId": json["entity_user_id"],
    "entityId": json["entity_id"]
  };
}
function FanRemixContestWinnersSelectedNotificationActionDataToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "entity_user_id": value.entityUserId,
    "entity_id": value.entityId
  };
}
function instanceOfFanRemixContestWinnersSelectedNotificationAction(value) {
  let isInstance = true;
  isInstance = isInstance && "specifier" in value && value["specifier"] !== void 0;
  isInstance = isInstance && "type" in value && value["type"] !== void 0;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== void 0;
  isInstance = isInstance && "data" in value && value["data"] !== void 0;
  return isInstance;
}
function FanRemixContestWinnersSelectedNotificationActionFromJSON(json) {
  return FanRemixContestWinnersSelectedNotificationActionFromJSONTyped(json);
}
function FanRemixContestWinnersSelectedNotificationActionFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "specifier": json["specifier"],
    "type": json["type"],
    "timestamp": json["timestamp"],
    "data": FanRemixContestWinnersSelectedNotificationActionDataFromJSON(json["data"])
  };
}
function FanRemixContestWinnersSelectedNotificationActionToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "specifier": value.specifier,
    "type": value.type,
    "timestamp": value.timestamp,
    "data": FanRemixContestWinnersSelectedNotificationActionDataToJSON(value.data)
  };
}
function instanceOfFanRemixContestWinnersSelectedNotification(value) {
  let isInstance = true;
  isInstance = isInstance && "type" in value && value["type"] !== void 0;
  isInstance = isInstance && "groupId" in value && value["groupId"] !== void 0;
  isInstance = isInstance && "isSeen" in value && value["isSeen"] !== void 0;
  isInstance = isInstance && "actions" in value && value["actions"] !== void 0;
  return isInstance;
}
function FanRemixContestWinnersSelectedNotificationFromJSON(json) {
  return FanRemixContestWinnersSelectedNotificationFromJSONTyped(json);
}
function FanRemixContestWinnersSelectedNotificationFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "groupId": json["group_id"],
    "isSeen": json["is_seen"],
    "seenAt": !exists3(json, "seen_at") ? void 0 : json["seen_at"],
    "actions": json["actions"].map(FanRemixContestWinnersSelectedNotificationActionFromJSON)
  };
}
function FanRemixContestWinnersSelectedNotificationToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "group_id": value.groupId,
    "is_seen": value.isSeen,
    "seen_at": value.seenAt,
    "actions": value.actions.map(FanRemixContestWinnersSelectedNotificationActionToJSON)
  };
}
function instanceOfFollowNotificationActionData(value) {
  let isInstance = true;
  isInstance = isInstance && "followerUserId" in value && value["followerUserId"] !== void 0;
  isInstance = isInstance && "followeeUserId" in value && value["followeeUserId"] !== void 0;
  return isInstance;
}
function FollowNotificationActionDataFromJSON(json) {
  return FollowNotificationActionDataFromJSONTyped(json);
}
function FollowNotificationActionDataFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "followerUserId": json["follower_user_id"],
    "followeeUserId": json["followee_user_id"]
  };
}
function FollowNotificationActionDataToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "follower_user_id": value.followerUserId,
    "followee_user_id": value.followeeUserId
  };
}
function instanceOfFollowNotificationAction(value) {
  let isInstance = true;
  isInstance = isInstance && "specifier" in value && value["specifier"] !== void 0;
  isInstance = isInstance && "type" in value && value["type"] !== void 0;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== void 0;
  isInstance = isInstance && "data" in value && value["data"] !== void 0;
  return isInstance;
}
function FollowNotificationActionFromJSON(json) {
  return FollowNotificationActionFromJSONTyped(json);
}
function FollowNotificationActionFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "specifier": json["specifier"],
    "type": json["type"],
    "timestamp": json["timestamp"],
    "data": FollowNotificationActionDataFromJSON(json["data"])
  };
}
function FollowNotificationActionToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "specifier": value.specifier,
    "type": value.type,
    "timestamp": value.timestamp,
    "data": FollowNotificationActionDataToJSON(value.data)
  };
}
function instanceOfFollowNotification(value) {
  let isInstance = true;
  isInstance = isInstance && "type" in value && value["type"] !== void 0;
  isInstance = isInstance && "groupId" in value && value["groupId"] !== void 0;
  isInstance = isInstance && "isSeen" in value && value["isSeen"] !== void 0;
  isInstance = isInstance && "actions" in value && value["actions"] !== void 0;
  return isInstance;
}
function FollowNotificationFromJSON(json) {
  return FollowNotificationFromJSONTyped(json);
}
function FollowNotificationFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "groupId": json["group_id"],
    "isSeen": json["is_seen"],
    "seenAt": !exists3(json, "seen_at") ? void 0 : json["seen_at"],
    "actions": json["actions"].map(FollowNotificationActionFromJSON)
  };
}
function FollowNotificationToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "group_id": value.groupId,
    "is_seen": value.isSeen,
    "seen_at": value.seenAt,
    "actions": value.actions.map(FollowNotificationActionToJSON)
  };
}
function instanceOfFollowingResponse(value) {
  let isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value && value["latestChainBlock"] !== void 0;
  isInstance = isInstance && "latestIndexedBlock" in value && value["latestIndexedBlock"] !== void 0;
  isInstance = isInstance && "latestChainSlotPlays" in value && value["latestChainSlotPlays"] !== void 0;
  isInstance = isInstance && "latestIndexedSlotPlays" in value && value["latestIndexedSlotPlays"] !== void 0;
  isInstance = isInstance && "signature" in value && value["signature"] !== void 0;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== void 0;
  isInstance = isInstance && "version" in value && value["version"] !== void 0;
  return isInstance;
}
function FollowingResponseFromJSON(json) {
  return FollowingResponseFromJSONTyped(json);
}
function FollowingResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "latestChainBlock": json["latest_chain_block"],
    "latestIndexedBlock": json["latest_indexed_block"],
    "latestChainSlotPlays": json["latest_chain_slot_plays"],
    "latestIndexedSlotPlays": json["latest_indexed_slot_plays"],
    "signature": json["signature"],
    "timestamp": json["timestamp"],
    "version": VersionMetadataFromJSON(json["version"]),
    "data": !exists3(json, "data") ? void 0 : json["data"].map(UserFullFromJSON)
  };
}
function FollowingResponseToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "latest_chain_block": value.latestChainBlock,
    "latest_indexed_block": value.latestIndexedBlock,
    "latest_chain_slot_plays": value.latestChainSlotPlays,
    "latest_indexed_slot_plays": value.latestIndexedSlotPlays,
    "signature": value.signature,
    "timestamp": value.timestamp,
    "version": VersionMetadataToJSON(value.version),
    "data": value.data === void 0 ? void 0 : value.data.map(UserFullToJSON)
  };
}
function instanceOfFollowingResponseFull(value) {
  let isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value && value["latestChainBlock"] !== void 0;
  isInstance = isInstance && "latestIndexedBlock" in value && value["latestIndexedBlock"] !== void 0;
  isInstance = isInstance && "latestChainSlotPlays" in value && value["latestChainSlotPlays"] !== void 0;
  isInstance = isInstance && "latestIndexedSlotPlays" in value && value["latestIndexedSlotPlays"] !== void 0;
  isInstance = isInstance && "signature" in value && value["signature"] !== void 0;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== void 0;
  isInstance = isInstance && "version" in value && value["version"] !== void 0;
  return isInstance;
}
function FollowingResponseFullFromJSON(json) {
  return FollowingResponseFullFromJSONTyped(json);
}
function FollowingResponseFullFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "latestChainBlock": json["latest_chain_block"],
    "latestIndexedBlock": json["latest_indexed_block"],
    "latestChainSlotPlays": json["latest_chain_slot_plays"],
    "latestIndexedSlotPlays": json["latest_indexed_slot_plays"],
    "signature": json["signature"],
    "timestamp": json["timestamp"],
    "version": VersionMetadataFromJSON(json["version"]),
    "data": !exists3(json, "data") ? void 0 : json["data"].map(UserFullFromJSON)
  };
}
function FollowingResponseFullToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "latest_chain_block": value.latestChainBlock,
    "latest_indexed_block": value.latestIndexedBlock,
    "latest_chain_slot_plays": value.latestChainSlotPlays,
    "latest_indexed_slot_plays": value.latestIndexedSlotPlays,
    "signature": value.signature,
    "timestamp": value.timestamp,
    "version": VersionMetadataToJSON(value.version),
    "data": value.data === void 0 ? void 0 : value.data.map(UserFullToJSON)
  };
}
function instanceOfUserSubscribers(value) {
  let isInstance = true;
  isInstance = isInstance && "userId" in value && value["userId"] !== void 0;
  return isInstance;
}
function UserSubscribersFromJSON(json) {
  return UserSubscribersFromJSONTyped(json);
}
function UserSubscribersFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "userId": json["user_id"],
    "subscriberIds": !exists3(json, "subscriber_ids") ? void 0 : json["subscriber_ids"]
  };
}
function UserSubscribersToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "user_id": value.userId,
    "subscriber_ids": value.subscriberIds
  };
}
function instanceOfFullBulkSubscribersResponse(value) {
  let isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value && value["latestChainBlock"] !== void 0;
  isInstance = isInstance && "latestIndexedBlock" in value && value["latestIndexedBlock"] !== void 0;
  isInstance = isInstance && "latestChainSlotPlays" in value && value["latestChainSlotPlays"] !== void 0;
  isInstance = isInstance && "latestIndexedSlotPlays" in value && value["latestIndexedSlotPlays"] !== void 0;
  isInstance = isInstance && "signature" in value && value["signature"] !== void 0;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== void 0;
  isInstance = isInstance && "version" in value && value["version"] !== void 0;
  return isInstance;
}
function FullBulkSubscribersResponseFromJSON(json) {
  return FullBulkSubscribersResponseFromJSONTyped(json);
}
function FullBulkSubscribersResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "latestChainBlock": json["latest_chain_block"],
    "latestIndexedBlock": json["latest_indexed_block"],
    "latestChainSlotPlays": json["latest_chain_slot_plays"],
    "latestIndexedSlotPlays": json["latest_indexed_slot_plays"],
    "signature": json["signature"],
    "timestamp": json["timestamp"],
    "version": VersionMetadataFromJSON(json["version"]),
    "data": !exists3(json, "data") ? void 0 : json["data"].map(UserSubscribersFromJSON)
  };
}
function FullBulkSubscribersResponseToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "latest_chain_block": value.latestChainBlock,
    "latest_indexed_block": value.latestIndexedBlock,
    "latest_chain_slot_plays": value.latestChainSlotPlays,
    "latest_indexed_slot_plays": value.latestIndexedSlotPlays,
    "signature": value.signature,
    "timestamp": value.timestamp,
    "version": VersionMetadataToJSON(value.version),
    "data": value.data === void 0 ? void 0 : value.data.map(UserSubscribersToJSON)
  };
}
function instanceOfFullFollowersResponse(value) {
  let isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value && value["latestChainBlock"] !== void 0;
  isInstance = isInstance && "latestIndexedBlock" in value && value["latestIndexedBlock"] !== void 0;
  isInstance = isInstance && "latestChainSlotPlays" in value && value["latestChainSlotPlays"] !== void 0;
  isInstance = isInstance && "latestIndexedSlotPlays" in value && value["latestIndexedSlotPlays"] !== void 0;
  isInstance = isInstance && "signature" in value && value["signature"] !== void 0;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== void 0;
  isInstance = isInstance && "version" in value && value["version"] !== void 0;
  return isInstance;
}
function FullFollowersResponseFromJSON(json) {
  return FullFollowersResponseFromJSONTyped(json);
}
function FullFollowersResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "latestChainBlock": json["latest_chain_block"],
    "latestIndexedBlock": json["latest_indexed_block"],
    "latestChainSlotPlays": json["latest_chain_slot_plays"],
    "latestIndexedSlotPlays": json["latest_indexed_slot_plays"],
    "signature": json["signature"],
    "timestamp": json["timestamp"],
    "version": VersionMetadataFromJSON(json["version"]),
    "data": !exists3(json, "data") ? void 0 : json["data"].map(UserFullFromJSON)
  };
}
function FullFollowersResponseToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "latest_chain_block": value.latestChainBlock,
    "latest_indexed_block": value.latestIndexedBlock,
    "latest_chain_slot_plays": value.latestChainSlotPlays,
    "latest_indexed_slot_plays": value.latestIndexedSlotPlays,
    "signature": value.signature,
    "timestamp": value.timestamp,
    "version": VersionMetadataToJSON(value.version),
    "data": value.data === void 0 ? void 0 : value.data.map(UserFullToJSON)
  };
}
function instanceOfFullSupporting(value) {
  let isInstance = true;
  isInstance = isInstance && "rank" in value && value["rank"] !== void 0;
  isInstance = isInstance && "amount" in value && value["amount"] !== void 0;
  isInstance = isInstance && "receiver" in value && value["receiver"] !== void 0;
  return isInstance;
}
function FullSupportingFromJSON(json) {
  return FullSupportingFromJSONTyped(json);
}
function FullSupportingFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "rank": json["rank"],
    "amount": json["amount"],
    "receiver": UserFullFromJSON(json["receiver"])
  };
}
function FullSupportingToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "rank": value.rank,
    "amount": value.amount,
    "receiver": UserFullToJSON(value.receiver)
  };
}
function instanceOfFullGetSupportedUsers(value) {
  let isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value && value["latestChainBlock"] !== void 0;
  isInstance = isInstance && "latestIndexedBlock" in value && value["latestIndexedBlock"] !== void 0;
  isInstance = isInstance && "latestChainSlotPlays" in value && value["latestChainSlotPlays"] !== void 0;
  isInstance = isInstance && "latestIndexedSlotPlays" in value && value["latestIndexedSlotPlays"] !== void 0;
  isInstance = isInstance && "signature" in value && value["signature"] !== void 0;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== void 0;
  isInstance = isInstance && "version" in value && value["version"] !== void 0;
  return isInstance;
}
function FullGetSupportedUsersFromJSON(json) {
  return FullGetSupportedUsersFromJSONTyped(json);
}
function FullGetSupportedUsersFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "latestChainBlock": json["latest_chain_block"],
    "latestIndexedBlock": json["latest_indexed_block"],
    "latestChainSlotPlays": json["latest_chain_slot_plays"],
    "latestIndexedSlotPlays": json["latest_indexed_slot_plays"],
    "signature": json["signature"],
    "timestamp": json["timestamp"],
    "version": VersionMetadataFromJSON(json["version"]),
    "data": !exists3(json, "data") ? void 0 : json["data"].map(FullSupportingFromJSON)
  };
}
function FullGetSupportedUsersToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "latest_chain_block": value.latestChainBlock,
    "latest_indexed_block": value.latestIndexedBlock,
    "latest_chain_slot_plays": value.latestChainSlotPlays,
    "latest_indexed_slot_plays": value.latestIndexedSlotPlays,
    "signature": value.signature,
    "timestamp": value.timestamp,
    "version": VersionMetadataToJSON(value.version),
    "data": value.data === void 0 ? void 0 : value.data.map(FullSupportingToJSON)
  };
}
function instanceOfFullSupporter(value) {
  let isInstance = true;
  isInstance = isInstance && "rank" in value && value["rank"] !== void 0;
  isInstance = isInstance && "amount" in value && value["amount"] !== void 0;
  isInstance = isInstance && "sender" in value && value["sender"] !== void 0;
  return isInstance;
}
function FullSupporterFromJSON(json) {
  return FullSupporterFromJSONTyped(json);
}
function FullSupporterFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "rank": json["rank"],
    "amount": json["amount"],
    "sender": UserFullFromJSON(json["sender"])
  };
}
function FullSupporterToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "rank": value.rank,
    "amount": value.amount,
    "sender": UserFullToJSON(value.sender)
  };
}
function instanceOfFullGetSupporter(value) {
  let isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value && value["latestChainBlock"] !== void 0;
  isInstance = isInstance && "latestIndexedBlock" in value && value["latestIndexedBlock"] !== void 0;
  isInstance = isInstance && "latestChainSlotPlays" in value && value["latestChainSlotPlays"] !== void 0;
  isInstance = isInstance && "latestIndexedSlotPlays" in value && value["latestIndexedSlotPlays"] !== void 0;
  isInstance = isInstance && "signature" in value && value["signature"] !== void 0;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== void 0;
  isInstance = isInstance && "version" in value && value["version"] !== void 0;
  return isInstance;
}
function FullGetSupporterFromJSON(json) {
  return FullGetSupporterFromJSONTyped(json);
}
function FullGetSupporterFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "latestChainBlock": json["latest_chain_block"],
    "latestIndexedBlock": json["latest_indexed_block"],
    "latestChainSlotPlays": json["latest_chain_slot_plays"],
    "latestIndexedSlotPlays": json["latest_indexed_slot_plays"],
    "signature": json["signature"],
    "timestamp": json["timestamp"],
    "version": VersionMetadataFromJSON(json["version"]),
    "data": !exists3(json, "data") ? void 0 : FullSupporterFromJSON(json["data"])
  };
}
function FullGetSupporterToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "latest_chain_block": value.latestChainBlock,
    "latest_indexed_block": value.latestIndexedBlock,
    "latest_chain_slot_plays": value.latestChainSlotPlays,
    "latest_indexed_slot_plays": value.latestIndexedSlotPlays,
    "signature": value.signature,
    "timestamp": value.timestamp,
    "version": VersionMetadataToJSON(value.version),
    "data": FullSupporterToJSON(value.data)
  };
}
function instanceOfFullGetSupporters(value) {
  let isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value && value["latestChainBlock"] !== void 0;
  isInstance = isInstance && "latestIndexedBlock" in value && value["latestIndexedBlock"] !== void 0;
  isInstance = isInstance && "latestChainSlotPlays" in value && value["latestChainSlotPlays"] !== void 0;
  isInstance = isInstance && "latestIndexedSlotPlays" in value && value["latestIndexedSlotPlays"] !== void 0;
  isInstance = isInstance && "signature" in value && value["signature"] !== void 0;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== void 0;
  isInstance = isInstance && "version" in value && value["version"] !== void 0;
  return isInstance;
}
function FullGetSupportersFromJSON(json) {
  return FullGetSupportersFromJSONTyped(json);
}
function FullGetSupportersFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "latestChainBlock": json["latest_chain_block"],
    "latestIndexedBlock": json["latest_indexed_block"],
    "latestChainSlotPlays": json["latest_chain_slot_plays"],
    "latestIndexedSlotPlays": json["latest_indexed_slot_plays"],
    "signature": json["signature"],
    "timestamp": json["timestamp"],
    "version": VersionMetadataFromJSON(json["version"]),
    "data": !exists3(json, "data") ? void 0 : json["data"].map(FullSupporterFromJSON)
  };
}
function FullGetSupportersToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "latest_chain_block": value.latestChainBlock,
    "latest_indexed_block": value.latestIndexedBlock,
    "latest_chain_slot_plays": value.latestChainSlotPlays,
    "latest_indexed_slot_plays": value.latestIndexedSlotPlays,
    "signature": value.signature,
    "timestamp": value.timestamp,
    "version": VersionMetadataToJSON(value.version),
    "data": value.data === void 0 ? void 0 : value.data.map(FullSupporterToJSON)
  };
}
function instanceOfFullGetSupporting(value) {
  let isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value && value["latestChainBlock"] !== void 0;
  isInstance = isInstance && "latestIndexedBlock" in value && value["latestIndexedBlock"] !== void 0;
  isInstance = isInstance && "latestChainSlotPlays" in value && value["latestChainSlotPlays"] !== void 0;
  isInstance = isInstance && "latestIndexedSlotPlays" in value && value["latestIndexedSlotPlays"] !== void 0;
  isInstance = isInstance && "signature" in value && value["signature"] !== void 0;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== void 0;
  isInstance = isInstance && "version" in value && value["version"] !== void 0;
  return isInstance;
}
function FullGetSupportingFromJSON(json) {
  return FullGetSupportingFromJSONTyped(json);
}
function FullGetSupportingFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "latestChainBlock": json["latest_chain_block"],
    "latestIndexedBlock": json["latest_indexed_block"],
    "latestChainSlotPlays": json["latest_chain_slot_plays"],
    "latestIndexedSlotPlays": json["latest_indexed_slot_plays"],
    "signature": json["signature"],
    "timestamp": json["timestamp"],
    "version": VersionMetadataFromJSON(json["version"]),
    "data": !exists3(json, "data") ? void 0 : FullSupportingFromJSON(json["data"])
  };
}
function FullGetSupportingToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "latest_chain_block": value.latestChainBlock,
    "latest_indexed_block": value.latestIndexedBlock,
    "latest_chain_slot_plays": value.latestChainSlotPlays,
    "latest_indexed_slot_plays": value.latestIndexedSlotPlays,
    "signature": value.signature,
    "timestamp": value.timestamp,
    "version": VersionMetadataToJSON(value.version),
    "data": FullSupportingToJSON(value.data)
  };
}
function instanceOfFullMutualFollowersResponse(value) {
  let isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value && value["latestChainBlock"] !== void 0;
  isInstance = isInstance && "latestIndexedBlock" in value && value["latestIndexedBlock"] !== void 0;
  isInstance = isInstance && "latestChainSlotPlays" in value && value["latestChainSlotPlays"] !== void 0;
  isInstance = isInstance && "latestIndexedSlotPlays" in value && value["latestIndexedSlotPlays"] !== void 0;
  isInstance = isInstance && "signature" in value && value["signature"] !== void 0;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== void 0;
  isInstance = isInstance && "version" in value && value["version"] !== void 0;
  return isInstance;
}
function FullMutualFollowersResponseFromJSON(json) {
  return FullMutualFollowersResponseFromJSONTyped(json);
}
function FullMutualFollowersResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "latestChainBlock": json["latest_chain_block"],
    "latestIndexedBlock": json["latest_indexed_block"],
    "latestChainSlotPlays": json["latest_chain_slot_plays"],
    "latestIndexedSlotPlays": json["latest_indexed_slot_plays"],
    "signature": json["signature"],
    "timestamp": json["timestamp"],
    "version": VersionMetadataFromJSON(json["version"]),
    "data": !exists3(json, "data") ? void 0 : json["data"].map(UserFullFromJSON)
  };
}
function FullMutualFollowersResponseToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "latest_chain_block": value.latestChainBlock,
    "latest_indexed_block": value.latestIndexedBlock,
    "latest_chain_slot_plays": value.latestChainSlotPlays,
    "latest_indexed_slot_plays": value.latestIndexedSlotPlays,
    "signature": value.signature,
    "timestamp": value.timestamp,
    "version": VersionMetadataToJSON(value.version),
    "data": value.data === void 0 ? void 0 : value.data.map(UserFullToJSON)
  };
}
function instanceOfFullPlaylistResponse(value) {
  let isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value && value["latestChainBlock"] !== void 0;
  isInstance = isInstance && "latestIndexedBlock" in value && value["latestIndexedBlock"] !== void 0;
  isInstance = isInstance && "latestChainSlotPlays" in value && value["latestChainSlotPlays"] !== void 0;
  isInstance = isInstance && "latestIndexedSlotPlays" in value && value["latestIndexedSlotPlays"] !== void 0;
  isInstance = isInstance && "signature" in value && value["signature"] !== void 0;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== void 0;
  isInstance = isInstance && "version" in value && value["version"] !== void 0;
  return isInstance;
}
function FullPlaylistResponseFromJSON(json) {
  return FullPlaylistResponseFromJSONTyped(json);
}
function FullPlaylistResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "latestChainBlock": json["latest_chain_block"],
    "latestIndexedBlock": json["latest_indexed_block"],
    "latestChainSlotPlays": json["latest_chain_slot_plays"],
    "latestIndexedSlotPlays": json["latest_indexed_slot_plays"],
    "signature": json["signature"],
    "timestamp": json["timestamp"],
    "version": VersionMetadataFromJSON(json["version"]),
    "data": !exists3(json, "data") ? void 0 : json["data"].map(PlaylistFullFromJSON)
  };
}
function FullPlaylistResponseToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "latest_chain_block": value.latestChainBlock,
    "latest_indexed_block": value.latestIndexedBlock,
    "latest_chain_slot_plays": value.latestChainSlotPlays,
    "latest_indexed_slot_plays": value.latestIndexedSlotPlays,
    "signature": value.signature,
    "timestamp": value.timestamp,
    "version": VersionMetadataToJSON(value.version),
    "data": value.data === void 0 ? void 0 : value.data.map(PlaylistFullToJSON)
  };
}
function instanceOfFullPlaylistTracksResponse(value) {
  let isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value && value["latestChainBlock"] !== void 0;
  isInstance = isInstance && "latestIndexedBlock" in value && value["latestIndexedBlock"] !== void 0;
  isInstance = isInstance && "latestChainSlotPlays" in value && value["latestChainSlotPlays"] !== void 0;
  isInstance = isInstance && "latestIndexedSlotPlays" in value && value["latestIndexedSlotPlays"] !== void 0;
  isInstance = isInstance && "signature" in value && value["signature"] !== void 0;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== void 0;
  isInstance = isInstance && "version" in value && value["version"] !== void 0;
  return isInstance;
}
function FullPlaylistTracksResponseFromJSON(json) {
  return FullPlaylistTracksResponseFromJSONTyped(json);
}
function FullPlaylistTracksResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "latestChainBlock": json["latest_chain_block"],
    "latestIndexedBlock": json["latest_indexed_block"],
    "latestChainSlotPlays": json["latest_chain_slot_plays"],
    "latestIndexedSlotPlays": json["latest_indexed_slot_plays"],
    "signature": json["signature"],
    "timestamp": json["timestamp"],
    "version": VersionMetadataFromJSON(json["version"]),
    "data": !exists3(json, "data") ? void 0 : json["data"].map(TrackFullFromJSON)
  };
}
function FullPlaylistTracksResponseToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "latest_chain_block": value.latestChainBlock,
    "latest_indexed_block": value.latestIndexedBlock,
    "latest_chain_slot_plays": value.latestChainSlotPlays,
    "latest_indexed_slot_plays": value.latestIndexedSlotPlays,
    "signature": value.signature,
    "timestamp": value.timestamp,
    "version": VersionMetadataToJSON(value.version),
    "data": value.data === void 0 ? void 0 : value.data.map(TrackFullToJSON)
  };
}
function instanceOfFullPurchasersResponse(value) {
  let isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value && value["latestChainBlock"] !== void 0;
  isInstance = isInstance && "latestIndexedBlock" in value && value["latestIndexedBlock"] !== void 0;
  isInstance = isInstance && "latestChainSlotPlays" in value && value["latestChainSlotPlays"] !== void 0;
  isInstance = isInstance && "latestIndexedSlotPlays" in value && value["latestIndexedSlotPlays"] !== void 0;
  isInstance = isInstance && "signature" in value && value["signature"] !== void 0;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== void 0;
  isInstance = isInstance && "version" in value && value["version"] !== void 0;
  return isInstance;
}
function FullPurchasersResponseFromJSON(json) {
  return FullPurchasersResponseFromJSONTyped(json);
}
function FullPurchasersResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "latestChainBlock": json["latest_chain_block"],
    "latestIndexedBlock": json["latest_indexed_block"],
    "latestChainSlotPlays": json["latest_chain_slot_plays"],
    "latestIndexedSlotPlays": json["latest_indexed_slot_plays"],
    "signature": json["signature"],
    "timestamp": json["timestamp"],
    "version": VersionMetadataFromJSON(json["version"]),
    "data": !exists3(json, "data") ? void 0 : json["data"].map(UserFullFromJSON)
  };
}
function FullPurchasersResponseToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "latest_chain_block": value.latestChainBlock,
    "latest_indexed_block": value.latestIndexedBlock,
    "latest_chain_slot_plays": value.latestChainSlotPlays,
    "latest_indexed_slot_plays": value.latestIndexedSlotPlays,
    "signature": value.signature,
    "timestamp": value.timestamp,
    "version": VersionMetadataToJSON(value.version),
    "data": value.data === void 0 ? void 0 : value.data.map(UserFullToJSON)
  };
}
function instanceOfFullRemixersResponse(value) {
  let isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value && value["latestChainBlock"] !== void 0;
  isInstance = isInstance && "latestIndexedBlock" in value && value["latestIndexedBlock"] !== void 0;
  isInstance = isInstance && "latestChainSlotPlays" in value && value["latestChainSlotPlays"] !== void 0;
  isInstance = isInstance && "latestIndexedSlotPlays" in value && value["latestIndexedSlotPlays"] !== void 0;
  isInstance = isInstance && "signature" in value && value["signature"] !== void 0;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== void 0;
  isInstance = isInstance && "version" in value && value["version"] !== void 0;
  return isInstance;
}
function FullRemixersResponseFromJSON(json) {
  return FullRemixersResponseFromJSONTyped(json);
}
function FullRemixersResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "latestChainBlock": json["latest_chain_block"],
    "latestIndexedBlock": json["latest_indexed_block"],
    "latestChainSlotPlays": json["latest_chain_slot_plays"],
    "latestIndexedSlotPlays": json["latest_indexed_slot_plays"],
    "signature": json["signature"],
    "timestamp": json["timestamp"],
    "version": VersionMetadataFromJSON(json["version"]),
    "data": !exists3(json, "data") ? void 0 : json["data"].map(UserFullFromJSON)
  };
}
function FullRemixersResponseToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "latest_chain_block": value.latestChainBlock,
    "latest_indexed_block": value.latestIndexedBlock,
    "latest_chain_slot_plays": value.latestChainSlotPlays,
    "latest_indexed_slot_plays": value.latestIndexedSlotPlays,
    "signature": value.signature,
    "timestamp": value.timestamp,
    "version": VersionMetadataToJSON(value.version),
    "data": value.data === void 0 ? void 0 : value.data.map(UserFullToJSON)
  };
}
function instanceOfFullReposts(value) {
  let isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value && value["latestChainBlock"] !== void 0;
  isInstance = isInstance && "latestIndexedBlock" in value && value["latestIndexedBlock"] !== void 0;
  isInstance = isInstance && "latestChainSlotPlays" in value && value["latestChainSlotPlays"] !== void 0;
  isInstance = isInstance && "latestIndexedSlotPlays" in value && value["latestIndexedSlotPlays"] !== void 0;
  isInstance = isInstance && "signature" in value && value["signature"] !== void 0;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== void 0;
  isInstance = isInstance && "version" in value && value["version"] !== void 0;
  return isInstance;
}
function FullRepostsFromJSON(json) {
  return FullRepostsFromJSONTyped(json);
}
function FullRepostsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "latestChainBlock": json["latest_chain_block"],
    "latestIndexedBlock": json["latest_indexed_block"],
    "latestChainSlotPlays": json["latest_chain_slot_plays"],
    "latestIndexedSlotPlays": json["latest_indexed_slot_plays"],
    "signature": json["signature"],
    "timestamp": json["timestamp"],
    "version": VersionMetadataFromJSON(json["version"]),
    "data": !exists3(json, "data") ? void 0 : json["data"].map(ActivityFullFromJSON)
  };
}
function FullRepostsToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "latest_chain_block": value.latestChainBlock,
    "latest_indexed_block": value.latestIndexedBlock,
    "latest_chain_slot_plays": value.latestChainSlotPlays,
    "latest_indexed_slot_plays": value.latestIndexedSlotPlays,
    "signature": value.signature,
    "timestamp": value.timestamp,
    "version": VersionMetadataToJSON(value.version),
    "data": value.data === void 0 ? void 0 : value.data.map(ActivityFullToJSON)
  };
}
function instanceOfFullSubscribersResponse(value) {
  let isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value && value["latestChainBlock"] !== void 0;
  isInstance = isInstance && "latestIndexedBlock" in value && value["latestIndexedBlock"] !== void 0;
  isInstance = isInstance && "latestChainSlotPlays" in value && value["latestChainSlotPlays"] !== void 0;
  isInstance = isInstance && "latestIndexedSlotPlays" in value && value["latestIndexedSlotPlays"] !== void 0;
  isInstance = isInstance && "signature" in value && value["signature"] !== void 0;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== void 0;
  isInstance = isInstance && "version" in value && value["version"] !== void 0;
  return isInstance;
}
function FullSubscribersResponseFromJSON(json) {
  return FullSubscribersResponseFromJSONTyped(json);
}
function FullSubscribersResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "latestChainBlock": json["latest_chain_block"],
    "latestIndexedBlock": json["latest_indexed_block"],
    "latestChainSlotPlays": json["latest_chain_slot_plays"],
    "latestIndexedSlotPlays": json["latest_indexed_slot_plays"],
    "signature": json["signature"],
    "timestamp": json["timestamp"],
    "version": VersionMetadataFromJSON(json["version"]),
    "data": !exists3(json, "data") ? void 0 : json["data"].map(UserFullFromJSON)
  };
}
function FullSubscribersResponseToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "latest_chain_block": value.latestChainBlock,
    "latest_indexed_block": value.latestIndexedBlock,
    "latest_chain_slot_plays": value.latestChainSlotPlays,
    "latest_indexed_slot_plays": value.latestIndexedSlotPlays,
    "signature": value.signature,
    "timestamp": value.timestamp,
    "version": VersionMetadataToJSON(value.version),
    "data": value.data === void 0 ? void 0 : value.data.map(UserFullToJSON)
  };
}
function instanceOfSupporterReference(value) {
  let isInstance = true;
  isInstance = isInstance && "userId" in value && value["userId"] !== void 0;
  return isInstance;
}
function SupporterReferenceFromJSON(json) {
  return SupporterReferenceFromJSONTyped(json);
}
function SupporterReferenceFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "userId": json["user_id"]
  };
}
function SupporterReferenceToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "user_id": value.userId
  };
}
function instanceOfFullTip(value) {
  let isInstance = true;
  isInstance = isInstance && "amount" in value && value["amount"] !== void 0;
  isInstance = isInstance && "sender" in value && value["sender"] !== void 0;
  isInstance = isInstance && "receiver" in value && value["receiver"] !== void 0;
  isInstance = isInstance && "createdAt" in value && value["createdAt"] !== void 0;
  isInstance = isInstance && "slot" in value && value["slot"] !== void 0;
  isInstance = isInstance && "followeeSupporters" in value && value["followeeSupporters"] !== void 0;
  isInstance = isInstance && "txSignature" in value && value["txSignature"] !== void 0;
  return isInstance;
}
function FullTipFromJSON(json) {
  return FullTipFromJSONTyped(json);
}
function FullTipFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "amount": json["amount"],
    "sender": UserFullFromJSON(json["sender"]),
    "receiver": UserFullFromJSON(json["receiver"]),
    "createdAt": json["created_at"],
    "slot": json["slot"],
    "followeeSupporters": json["followee_supporters"].map(SupporterReferenceFromJSON),
    "txSignature": json["tx_signature"]
  };
}
function FullTipToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "amount": value.amount,
    "sender": UserFullToJSON(value.sender),
    "receiver": UserFullToJSON(value.receiver),
    "created_at": value.createdAt,
    "slot": value.slot,
    "followee_supporters": value.followeeSupporters.map(SupporterReferenceToJSON),
    "tx_signature": value.txSignature
  };
}
function instanceOfFullTopListener(value) {
  let isInstance = true;
  return isInstance;
}
function FullTopListenerFromJSON(json) {
  return FullTopListenerFromJSONTyped(json);
}
function FullTopListenerFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "data": !exists3(json, "data") ? void 0 : json["data"].map(FullTopListenerFromJSON)
  };
}
function FullTopListenerToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "data": value.data === void 0 ? void 0 : value.data.map(FullTopListenerToJSON)
  };
}
function instanceOfFullTrackResponse(value) {
  let isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value && value["latestChainBlock"] !== void 0;
  isInstance = isInstance && "latestIndexedBlock" in value && value["latestIndexedBlock"] !== void 0;
  isInstance = isInstance && "latestChainSlotPlays" in value && value["latestChainSlotPlays"] !== void 0;
  isInstance = isInstance && "latestIndexedSlotPlays" in value && value["latestIndexedSlotPlays"] !== void 0;
  isInstance = isInstance && "signature" in value && value["signature"] !== void 0;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== void 0;
  isInstance = isInstance && "version" in value && value["version"] !== void 0;
  return isInstance;
}
function FullTrackResponseFromJSON(json) {
  return FullTrackResponseFromJSONTyped(json);
}
function FullTrackResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "latestChainBlock": json["latest_chain_block"],
    "latestIndexedBlock": json["latest_indexed_block"],
    "latestChainSlotPlays": json["latest_chain_slot_plays"],
    "latestIndexedSlotPlays": json["latest_indexed_slot_plays"],
    "signature": json["signature"],
    "timestamp": json["timestamp"],
    "version": VersionMetadataFromJSON(json["version"]),
    "data": !exists3(json, "data") ? void 0 : TrackFullFromJSON(json["data"])
  };
}
function FullTrackResponseToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "latest_chain_block": value.latestChainBlock,
    "latest_indexed_block": value.latestIndexedBlock,
    "latest_chain_slot_plays": value.latestChainSlotPlays,
    "latest_indexed_slot_plays": value.latestIndexedSlotPlays,
    "signature": value.signature,
    "timestamp": value.timestamp,
    "version": VersionMetadataToJSON(value.version),
    "data": TrackFullToJSON(value.data)
  };
}
function instanceOfFullTracks(value) {
  let isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value && value["latestChainBlock"] !== void 0;
  isInstance = isInstance && "latestIndexedBlock" in value && value["latestIndexedBlock"] !== void 0;
  isInstance = isInstance && "latestChainSlotPlays" in value && value["latestChainSlotPlays"] !== void 0;
  isInstance = isInstance && "latestIndexedSlotPlays" in value && value["latestIndexedSlotPlays"] !== void 0;
  isInstance = isInstance && "signature" in value && value["signature"] !== void 0;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== void 0;
  isInstance = isInstance && "version" in value && value["version"] !== void 0;
  return isInstance;
}
function FullTracksFromJSON(json) {
  return FullTracksFromJSONTyped(json);
}
function FullTracksFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "latestChainBlock": json["latest_chain_block"],
    "latestIndexedBlock": json["latest_indexed_block"],
    "latestChainSlotPlays": json["latest_chain_slot_plays"],
    "latestIndexedSlotPlays": json["latest_indexed_slot_plays"],
    "signature": json["signature"],
    "timestamp": json["timestamp"],
    "version": VersionMetadataFromJSON(json["version"]),
    "data": !exists3(json, "data") ? void 0 : json["data"].map(TrackFullFromJSON)
  };
}
function FullTracksToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "latest_chain_block": value.latestChainBlock,
    "latest_indexed_block": value.latestIndexedBlock,
    "latest_chain_slot_plays": value.latestChainSlotPlays,
    "latest_indexed_slot_plays": value.latestIndexedSlotPlays,
    "signature": value.signature,
    "timestamp": value.timestamp,
    "version": VersionMetadataToJSON(value.version),
    "data": value.data === void 0 ? void 0 : value.data.map(TrackFullToJSON)
  };
}
function instanceOfFullTracksResponse(value) {
  let isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value && value["latestChainBlock"] !== void 0;
  isInstance = isInstance && "latestIndexedBlock" in value && value["latestIndexedBlock"] !== void 0;
  isInstance = isInstance && "latestChainSlotPlays" in value && value["latestChainSlotPlays"] !== void 0;
  isInstance = isInstance && "latestIndexedSlotPlays" in value && value["latestIndexedSlotPlays"] !== void 0;
  isInstance = isInstance && "signature" in value && value["signature"] !== void 0;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== void 0;
  isInstance = isInstance && "version" in value && value["version"] !== void 0;
  return isInstance;
}
function FullTracksResponseFromJSON(json) {
  return FullTracksResponseFromJSONTyped(json);
}
function FullTracksResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "latestChainBlock": json["latest_chain_block"],
    "latestIndexedBlock": json["latest_indexed_block"],
    "latestChainSlotPlays": json["latest_chain_slot_plays"],
    "latestIndexedSlotPlays": json["latest_indexed_slot_plays"],
    "signature": json["signature"],
    "timestamp": json["timestamp"],
    "version": VersionMetadataFromJSON(json["version"]),
    "data": !exists3(json, "data") ? void 0 : json["data"].map(TrackFullFromJSON)
  };
}
function FullTracksResponseToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "latest_chain_block": value.latestChainBlock,
    "latest_indexed_block": value.latestIndexedBlock,
    "latest_chain_slot_plays": value.latestChainSlotPlays,
    "latest_indexed_slot_plays": value.latestIndexedSlotPlays,
    "signature": value.signature,
    "timestamp": value.timestamp,
    "version": VersionMetadataToJSON(value.version),
    "data": value.data === void 0 ? void 0 : value.data.map(TrackFullToJSON)
  };
}
function instanceOfFullTrendingPlaylistsResponse(value) {
  let isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value && value["latestChainBlock"] !== void 0;
  isInstance = isInstance && "latestIndexedBlock" in value && value["latestIndexedBlock"] !== void 0;
  isInstance = isInstance && "latestChainSlotPlays" in value && value["latestChainSlotPlays"] !== void 0;
  isInstance = isInstance && "latestIndexedSlotPlays" in value && value["latestIndexedSlotPlays"] !== void 0;
  isInstance = isInstance && "signature" in value && value["signature"] !== void 0;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== void 0;
  isInstance = isInstance && "version" in value && value["version"] !== void 0;
  return isInstance;
}
function FullTrendingPlaylistsResponseFromJSON(json) {
  return FullTrendingPlaylistsResponseFromJSONTyped(json);
}
function FullTrendingPlaylistsResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "latestChainBlock": json["latest_chain_block"],
    "latestIndexedBlock": json["latest_indexed_block"],
    "latestChainSlotPlays": json["latest_chain_slot_plays"],
    "latestIndexedSlotPlays": json["latest_indexed_slot_plays"],
    "signature": json["signature"],
    "timestamp": json["timestamp"],
    "version": VersionMetadataFromJSON(json["version"]),
    "data": !exists3(json, "data") ? void 0 : json["data"].map(PlaylistFullFromJSON)
  };
}
function FullTrendingPlaylistsResponseToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "latest_chain_block": value.latestChainBlock,
    "latest_indexed_block": value.latestIndexedBlock,
    "latest_chain_slot_plays": value.latestChainSlotPlays,
    "latest_indexed_slot_plays": value.latestIndexedSlotPlays,
    "signature": value.signature,
    "timestamp": value.timestamp,
    "version": VersionMetadataToJSON(value.version),
    "data": value.data === void 0 ? void 0 : value.data.map(PlaylistFullToJSON)
  };
}
function instanceOfFullUserResponse(value) {
  let isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value && value["latestChainBlock"] !== void 0;
  isInstance = isInstance && "latestIndexedBlock" in value && value["latestIndexedBlock"] !== void 0;
  isInstance = isInstance && "latestChainSlotPlays" in value && value["latestChainSlotPlays"] !== void 0;
  isInstance = isInstance && "latestIndexedSlotPlays" in value && value["latestIndexedSlotPlays"] !== void 0;
  isInstance = isInstance && "signature" in value && value["signature"] !== void 0;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== void 0;
  isInstance = isInstance && "version" in value && value["version"] !== void 0;
  return isInstance;
}
function FullUserResponseFromJSON(json) {
  return FullUserResponseFromJSONTyped(json);
}
function FullUserResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "latestChainBlock": json["latest_chain_block"],
    "latestIndexedBlock": json["latest_indexed_block"],
    "latestChainSlotPlays": json["latest_chain_slot_plays"],
    "latestIndexedSlotPlays": json["latest_indexed_slot_plays"],
    "signature": json["signature"],
    "timestamp": json["timestamp"],
    "version": VersionMetadataFromJSON(json["version"]),
    "data": !exists3(json, "data") ? void 0 : json["data"].map(UserFullFromJSON)
  };
}
function FullUserResponseToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "latest_chain_block": value.latestChainBlock,
    "latest_indexed_block": value.latestIndexedBlock,
    "latest_chain_slot_plays": value.latestChainSlotPlays,
    "latest_indexed_slot_plays": value.latestIndexedSlotPlays,
    "signature": value.signature,
    "timestamp": value.timestamp,
    "version": VersionMetadataToJSON(value.version),
    "data": value.data === void 0 ? void 0 : value.data.map(UserFullToJSON)
  };
}
function instanceOfGetTipsResponse(value) {
  let isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value && value["latestChainBlock"] !== void 0;
  isInstance = isInstance && "latestIndexedBlock" in value && value["latestIndexedBlock"] !== void 0;
  isInstance = isInstance && "latestChainSlotPlays" in value && value["latestChainSlotPlays"] !== void 0;
  isInstance = isInstance && "latestIndexedSlotPlays" in value && value["latestIndexedSlotPlays"] !== void 0;
  isInstance = isInstance && "signature" in value && value["signature"] !== void 0;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== void 0;
  isInstance = isInstance && "version" in value && value["version"] !== void 0;
  return isInstance;
}
function GetTipsResponseFromJSON(json) {
  return GetTipsResponseFromJSONTyped(json);
}
function GetTipsResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "latestChainBlock": json["latest_chain_block"],
    "latestIndexedBlock": json["latest_indexed_block"],
    "latestChainSlotPlays": json["latest_chain_slot_plays"],
    "latestIndexedSlotPlays": json["latest_indexed_slot_plays"],
    "signature": json["signature"],
    "timestamp": json["timestamp"],
    "version": VersionMetadataFromJSON(json["version"]),
    "data": !exists3(json, "data") ? void 0 : json["data"].map(FullTipFromJSON)
  };
}
function GetTipsResponseToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "latest_chain_block": value.latestChainBlock,
    "latest_indexed_block": value.latestIndexedBlock,
    "latest_chain_slot_plays": value.latestChainSlotPlays,
    "latest_indexed_slot_plays": value.latestIndexedSlotPlays,
    "signature": value.signature,
    "timestamp": value.timestamp,
    "version": VersionMetadataToJSON(value.version),
    "data": value.data === void 0 ? void 0 : value.data.map(FullTipToJSON)
  };
}
function instanceOfGrant(value) {
  let isInstance = true;
  isInstance = isInstance && "granteeAddress" in value && value["granteeAddress"] !== void 0;
  isInstance = isInstance && "userId" in value && value["userId"] !== void 0;
  isInstance = isInstance && "isRevoked" in value && value["isRevoked"] !== void 0;
  isInstance = isInstance && "isApproved" in value && value["isApproved"] !== void 0;
  isInstance = isInstance && "createdAt" in value && value["createdAt"] !== void 0;
  isInstance = isInstance && "updatedAt" in value && value["updatedAt"] !== void 0;
  return isInstance;
}
function GrantFromJSON(json) {
  return GrantFromJSONTyped(json);
}
function GrantFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "granteeAddress": json["grantee_address"],
    "userId": json["user_id"],
    "isRevoked": json["is_revoked"],
    "isApproved": json["is_approved"],
    "createdAt": json["created_at"],
    "updatedAt": json["updated_at"]
  };
}
function GrantToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "grantee_address": value.granteeAddress,
    "user_id": value.userId,
    "is_revoked": value.isRevoked,
    "is_approved": value.isApproved,
    "created_at": value.createdAt,
    "updated_at": value.updatedAt
  };
}
var TrackActivityFullItemTypeEnum = {
  Track: "track"
};
function instanceOfTrackActivityFull(value) {
  let isInstance = true;
  isInstance = isInstance && "itemType" in value && value["itemType"] !== void 0;
  isInstance = isInstance && "item" in value && value["item"] !== void 0;
  return isInstance;
}
function TrackActivityFullFromJSON(json) {
  return TrackActivityFullFromJSONTyped(json, false);
}
function TrackActivityFullFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    ...ActivityFullFromJSONTyped(json, ignoreDiscriminator),
    "itemType": json["item_type"],
    "item": TrackFullFromJSON(json["item"])
  };
}
function TrackActivityFullToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    ...ActivityFullToJSON(value),
    "item_type": value.itemType,
    "item": TrackFullToJSON(value.item)
  };
}
function instanceOfHistoryResponseFull(value) {
  let isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value && value["latestChainBlock"] !== void 0;
  isInstance = isInstance && "latestIndexedBlock" in value && value["latestIndexedBlock"] !== void 0;
  isInstance = isInstance && "latestChainSlotPlays" in value && value["latestChainSlotPlays"] !== void 0;
  isInstance = isInstance && "latestIndexedSlotPlays" in value && value["latestIndexedSlotPlays"] !== void 0;
  isInstance = isInstance && "signature" in value && value["signature"] !== void 0;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== void 0;
  isInstance = isInstance && "version" in value && value["version"] !== void 0;
  return isInstance;
}
function HistoryResponseFullFromJSON(json) {
  return HistoryResponseFullFromJSONTyped(json);
}
function HistoryResponseFullFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "latestChainBlock": json["latest_chain_block"],
    "latestIndexedBlock": json["latest_indexed_block"],
    "latestChainSlotPlays": json["latest_chain_slot_plays"],
    "latestIndexedSlotPlays": json["latest_indexed_slot_plays"],
    "signature": json["signature"],
    "timestamp": json["timestamp"],
    "version": VersionMetadataFromJSON(json["version"]),
    "data": !exists3(json, "data") ? void 0 : json["data"].map(TrackActivityFullFromJSON)
  };
}
function HistoryResponseFullToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "latest_chain_block": value.latestChainBlock,
    "latest_indexed_block": value.latestIndexedBlock,
    "latest_chain_slot_plays": value.latestChainSlotPlays,
    "latest_indexed_slot_plays": value.latestIndexedSlotPlays,
    "signature": value.signature,
    "timestamp": value.timestamp,
    "version": VersionMetadataToJSON(value.version),
    "data": value.data === void 0 ? void 0 : value.data.map(TrackActivityFullToJSON)
  };
}
function instanceOfListenStreakReminderNotificationActionData(value) {
  let isInstance = true;
  isInstance = isInstance && "streak" in value && value["streak"] !== void 0;
  return isInstance;
}
function ListenStreakReminderNotificationActionDataFromJSON(json) {
  return ListenStreakReminderNotificationActionDataFromJSONTyped(json);
}
function ListenStreakReminderNotificationActionDataFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "streak": json["streak"]
  };
}
function ListenStreakReminderNotificationActionDataToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "streak": value.streak
  };
}
function instanceOfListenStreakReminderNotificationAction(value) {
  let isInstance = true;
  isInstance = isInstance && "specifier" in value && value["specifier"] !== void 0;
  isInstance = isInstance && "type" in value && value["type"] !== void 0;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== void 0;
  isInstance = isInstance && "data" in value && value["data"] !== void 0;
  return isInstance;
}
function ListenStreakReminderNotificationActionFromJSON(json) {
  return ListenStreakReminderNotificationActionFromJSONTyped(json);
}
function ListenStreakReminderNotificationActionFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "specifier": json["specifier"],
    "type": json["type"],
    "timestamp": json["timestamp"],
    "data": ListenStreakReminderNotificationActionDataFromJSON(json["data"])
  };
}
function ListenStreakReminderNotificationActionToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "specifier": value.specifier,
    "type": value.type,
    "timestamp": value.timestamp,
    "data": ListenStreakReminderNotificationActionDataToJSON(value.data)
  };
}
function instanceOfListenStreakReminderNotification(value) {
  let isInstance = true;
  isInstance = isInstance && "type" in value && value["type"] !== void 0;
  isInstance = isInstance && "groupId" in value && value["groupId"] !== void 0;
  isInstance = isInstance && "isSeen" in value && value["isSeen"] !== void 0;
  isInstance = isInstance && "actions" in value && value["actions"] !== void 0;
  return isInstance;
}
function ListenStreakReminderNotificationFromJSON(json) {
  return ListenStreakReminderNotificationFromJSONTyped(json);
}
function ListenStreakReminderNotificationFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "groupId": json["group_id"],
    "isSeen": json["is_seen"],
    "seenAt": !exists3(json, "seen_at") ? void 0 : json["seen_at"],
    "actions": json["actions"].map(ListenStreakReminderNotificationActionFromJSON)
  };
}
function ListenStreakReminderNotificationToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "group_id": value.groupId,
    "is_seen": value.isSeen,
    "seen_at": value.seenAt,
    "actions": value.actions.map(ListenStreakReminderNotificationActionToJSON)
  };
}
function instanceOfManagedUser(value) {
  let isInstance = true;
  isInstance = isInstance && "user" in value && value["user"] !== void 0;
  isInstance = isInstance && "grant" in value && value["grant"] !== void 0;
  return isInstance;
}
function ManagedUserFromJSON(json) {
  return ManagedUserFromJSONTyped(json);
}
function ManagedUserFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "user": UserFullFromJSON(json["user"]),
    "grant": GrantFromJSON(json["grant"])
  };
}
function ManagedUserToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "user": UserFullToJSON(value.user),
    "grant": GrantToJSON(value.grant)
  };
}
function instanceOfManagedUsersResponse(value) {
  let isInstance = true;
  return isInstance;
}
function ManagedUsersResponseFromJSON(json) {
  return ManagedUsersResponseFromJSONTyped(json);
}
function ManagedUsersResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "data": !exists3(json, "data") ? void 0 : json["data"].map(ManagedUserFromJSON)
  };
}
function ManagedUsersResponseToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "data": value.data === void 0 ? void 0 : value.data.map(ManagedUserToJSON)
  };
}
function instanceOfUserManager(value) {
  let isInstance = true;
  isInstance = isInstance && "manager" in value && value["manager"] !== void 0;
  isInstance = isInstance && "grant" in value && value["grant"] !== void 0;
  return isInstance;
}
function UserManagerFromJSON(json) {
  return UserManagerFromJSONTyped(json);
}
function UserManagerFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "manager": UserFullFromJSON(json["manager"]),
    "grant": GrantFromJSON(json["grant"])
  };
}
function UserManagerToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "manager": UserFullToJSON(value.manager),
    "grant": GrantToJSON(value.grant)
  };
}
function instanceOfManagersResponse(value) {
  let isInstance = true;
  return isInstance;
}
function ManagersResponseFromJSON(json) {
  return ManagersResponseFromJSONTyped(json);
}
function ManagersResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "data": !exists3(json, "data") ? void 0 : json["data"].map(UserManagerFromJSON)
  };
}
function ManagersResponseToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "data": value.data === void 0 ? void 0 : value.data.map(UserManagerToJSON)
  };
}
function instanceOfPlaylistMilestoneNotificationActionData(value) {
  let isInstance = true;
  isInstance = isInstance && "type" in value && value["type"] !== void 0;
  isInstance = isInstance && "threshold" in value && value["threshold"] !== void 0;
  isInstance = isInstance && "playlistId" in value && value["playlistId"] !== void 0;
  isInstance = isInstance && "isAlbum" in value && value["isAlbum"] !== void 0;
  return isInstance;
}
function PlaylistMilestoneNotificationActionDataFromJSON(json) {
  return PlaylistMilestoneNotificationActionDataFromJSONTyped(json);
}
function PlaylistMilestoneNotificationActionDataFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "threshold": json["threshold"],
    "playlistId": json["playlist_id"],
    "isAlbum": json["is_album"]
  };
}
function PlaylistMilestoneNotificationActionDataToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "threshold": value.threshold,
    "playlist_id": value.playlistId,
    "is_album": value.isAlbum
  };
}
function instanceOfTrackMilestoneNotificationActionData(value) {
  let isInstance = true;
  isInstance = isInstance && "type" in value && value["type"] !== void 0;
  isInstance = isInstance && "threshold" in value && value["threshold"] !== void 0;
  isInstance = isInstance && "trackId" in value && value["trackId"] !== void 0;
  return isInstance;
}
function TrackMilestoneNotificationActionDataFromJSON(json) {
  return TrackMilestoneNotificationActionDataFromJSONTyped(json);
}
function TrackMilestoneNotificationActionDataFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "threshold": json["threshold"],
    "trackId": json["track_id"]
  };
}
function TrackMilestoneNotificationActionDataToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "threshold": value.threshold,
    "track_id": value.trackId
  };
}
function instanceOfUserMilestoneNotificationActionData(value) {
  let isInstance = true;
  isInstance = isInstance && "type" in value && value["type"] !== void 0;
  isInstance = isInstance && "threshold" in value && value["threshold"] !== void 0;
  isInstance = isInstance && "userId" in value && value["userId"] !== void 0;
  return isInstance;
}
function UserMilestoneNotificationActionDataFromJSON(json) {
  return UserMilestoneNotificationActionDataFromJSONTyped(json);
}
function UserMilestoneNotificationActionDataFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "threshold": json["threshold"],
    "userId": json["user_id"]
  };
}
function UserMilestoneNotificationActionDataToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "threshold": value.threshold,
    "user_id": value.userId
  };
}
function MilestoneNotificationActionDataFromJSON(json) {
  return MilestoneNotificationActionDataFromJSONTyped(json);
}
function MilestoneNotificationActionDataFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    ...PlaylistMilestoneNotificationActionDataFromJSONTyped(json),
    ...TrackMilestoneNotificationActionDataFromJSONTyped(json),
    ...UserMilestoneNotificationActionDataFromJSONTyped(json)
  };
}
function MilestoneNotificationActionDataToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  if (instanceOfPlaylistMilestoneNotificationActionData(value)) {
    return PlaylistMilestoneNotificationActionDataToJSON(value);
  }
  if (instanceOfTrackMilestoneNotificationActionData(value)) {
    return TrackMilestoneNotificationActionDataToJSON(value);
  }
  if (instanceOfUserMilestoneNotificationActionData(value)) {
    return UserMilestoneNotificationActionDataToJSON(value);
  }
  return {};
}
function instanceOfMilestoneNotificationAction(value) {
  let isInstance = true;
  isInstance = isInstance && "specifier" in value && value["specifier"] !== void 0;
  isInstance = isInstance && "type" in value && value["type"] !== void 0;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== void 0;
  isInstance = isInstance && "data" in value && value["data"] !== void 0;
  return isInstance;
}
function MilestoneNotificationActionFromJSON(json) {
  return MilestoneNotificationActionFromJSONTyped(json);
}
function MilestoneNotificationActionFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "specifier": json["specifier"],
    "type": json["type"],
    "timestamp": json["timestamp"],
    "data": MilestoneNotificationActionDataFromJSON(json["data"])
  };
}
function MilestoneNotificationActionToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "specifier": value.specifier,
    "type": value.type,
    "timestamp": value.timestamp,
    "data": MilestoneNotificationActionDataToJSON(value.data)
  };
}
function instanceOfMilestoneNotification(value) {
  let isInstance = true;
  isInstance = isInstance && "type" in value && value["type"] !== void 0;
  isInstance = isInstance && "groupId" in value && value["groupId"] !== void 0;
  isInstance = isInstance && "isSeen" in value && value["isSeen"] !== void 0;
  isInstance = isInstance && "actions" in value && value["actions"] !== void 0;
  return isInstance;
}
function MilestoneNotificationFromJSON(json) {
  return MilestoneNotificationFromJSONTyped(json);
}
function MilestoneNotificationFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "groupId": json["group_id"],
    "isSeen": json["is_seen"],
    "seenAt": !exists3(json, "seen_at") ? void 0 : json["seen_at"],
    "actions": json["actions"].map(MilestoneNotificationActionFromJSON)
  };
}
function MilestoneNotificationToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "group_id": value.groupId,
    "is_seen": value.isSeen,
    "seen_at": value.seenAt,
    "actions": value.actions.map(MilestoneNotificationActionToJSON)
  };
}
function instanceOfReactionNotificationActionData(value) {
  let isInstance = true;
  isInstance = isInstance && "reactedTo" in value && value["reactedTo"] !== void 0;
  isInstance = isInstance && "reactionType" in value && value["reactionType"] !== void 0;
  isInstance = isInstance && "reactionValue" in value && value["reactionValue"] !== void 0;
  isInstance = isInstance && "receiverUserId" in value && value["receiverUserId"] !== void 0;
  isInstance = isInstance && "senderUserId" in value && value["senderUserId"] !== void 0;
  isInstance = isInstance && "senderWallet" in value && value["senderWallet"] !== void 0;
  isInstance = isInstance && "tipAmount" in value && value["tipAmount"] !== void 0;
  return isInstance;
}
function ReactionNotificationActionDataFromJSON(json) {
  return ReactionNotificationActionDataFromJSONTyped(json);
}
function ReactionNotificationActionDataFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "reactedTo": json["reacted_to"],
    "reactionType": json["reaction_type"],
    "reactionValue": json["reaction_value"],
    "receiverUserId": json["receiver_user_id"],
    "senderUserId": json["sender_user_id"],
    "senderWallet": json["sender_wallet"],
    "tipAmount": json["tip_amount"]
  };
}
function ReactionNotificationActionDataToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "reacted_to": value.reactedTo,
    "reaction_type": value.reactionType,
    "reaction_value": value.reactionValue,
    "receiver_user_id": value.receiverUserId,
    "sender_user_id": value.senderUserId,
    "sender_wallet": value.senderWallet,
    "tip_amount": value.tipAmount
  };
}
function instanceOfReactionNotificationAction(value) {
  let isInstance = true;
  isInstance = isInstance && "specifier" in value && value["specifier"] !== void 0;
  isInstance = isInstance && "type" in value && value["type"] !== void 0;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== void 0;
  isInstance = isInstance && "data" in value && value["data"] !== void 0;
  return isInstance;
}
function ReactionNotificationActionFromJSON(json) {
  return ReactionNotificationActionFromJSONTyped(json);
}
function ReactionNotificationActionFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "specifier": json["specifier"],
    "type": json["type"],
    "timestamp": json["timestamp"],
    "data": ReactionNotificationActionDataFromJSON(json["data"])
  };
}
function ReactionNotificationActionToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "specifier": value.specifier,
    "type": value.type,
    "timestamp": value.timestamp,
    "data": ReactionNotificationActionDataToJSON(value.data)
  };
}
function instanceOfReactionNotification(value) {
  let isInstance = true;
  isInstance = isInstance && "type" in value && value["type"] !== void 0;
  isInstance = isInstance && "groupId" in value && value["groupId"] !== void 0;
  isInstance = isInstance && "isSeen" in value && value["isSeen"] !== void 0;
  isInstance = isInstance && "actions" in value && value["actions"] !== void 0;
  return isInstance;
}
function ReactionNotificationFromJSON(json) {
  return ReactionNotificationFromJSONTyped(json);
}
function ReactionNotificationFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "groupId": json["group_id"],
    "isSeen": json["is_seen"],
    "seenAt": !exists3(json, "seen_at") ? void 0 : json["seen_at"],
    "actions": json["actions"].map(ReactionNotificationActionFromJSON)
  };
}
function ReactionNotificationToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "group_id": value.groupId,
    "is_seen": value.isSeen,
    "seen_at": value.seenAt,
    "actions": value.actions.map(ReactionNotificationActionToJSON)
  };
}
function instanceOfReceiveTipNotificationActionData(value) {
  let isInstance = true;
  isInstance = isInstance && "amount" in value && value["amount"] !== void 0;
  isInstance = isInstance && "senderUserId" in value && value["senderUserId"] !== void 0;
  isInstance = isInstance && "receiverUserId" in value && value["receiverUserId"] !== void 0;
  isInstance = isInstance && "tipTxSignature" in value && value["tipTxSignature"] !== void 0;
  isInstance = isInstance && "reactionValue" in value && value["reactionValue"] !== void 0;
  return isInstance;
}
function ReceiveTipNotificationActionDataFromJSON(json) {
  return ReceiveTipNotificationActionDataFromJSONTyped(json);
}
function ReceiveTipNotificationActionDataFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "amount": json["amount"],
    "senderUserId": json["sender_user_id"],
    "receiverUserId": json["receiver_user_id"],
    "tipTxSignature": json["tip_tx_signature"],
    "reactionValue": json["reaction_value"]
  };
}
function ReceiveTipNotificationActionDataToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "amount": value.amount,
    "sender_user_id": value.senderUserId,
    "receiver_user_id": value.receiverUserId,
    "tip_tx_signature": value.tipTxSignature,
    "reaction_value": value.reactionValue
  };
}
function instanceOfReceiveTipNotificationAction(value) {
  let isInstance = true;
  isInstance = isInstance && "specifier" in value && value["specifier"] !== void 0;
  isInstance = isInstance && "type" in value && value["type"] !== void 0;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== void 0;
  isInstance = isInstance && "data" in value && value["data"] !== void 0;
  return isInstance;
}
function ReceiveTipNotificationActionFromJSON(json) {
  return ReceiveTipNotificationActionFromJSONTyped(json);
}
function ReceiveTipNotificationActionFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "specifier": json["specifier"],
    "type": json["type"],
    "timestamp": json["timestamp"],
    "data": ReceiveTipNotificationActionDataFromJSON(json["data"])
  };
}
function ReceiveTipNotificationActionToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "specifier": value.specifier,
    "type": value.type,
    "timestamp": value.timestamp,
    "data": ReceiveTipNotificationActionDataToJSON(value.data)
  };
}
function instanceOfReceiveTipNotification(value) {
  let isInstance = true;
  isInstance = isInstance && "type" in value && value["type"] !== void 0;
  isInstance = isInstance && "groupId" in value && value["groupId"] !== void 0;
  isInstance = isInstance && "isSeen" in value && value["isSeen"] !== void 0;
  isInstance = isInstance && "actions" in value && value["actions"] !== void 0;
  return isInstance;
}
function ReceiveTipNotificationFromJSON(json) {
  return ReceiveTipNotificationFromJSONTyped(json);
}
function ReceiveTipNotificationFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "groupId": json["group_id"],
    "isSeen": json["is_seen"],
    "seenAt": !exists3(json, "seen_at") ? void 0 : json["seen_at"],
    "actions": json["actions"].map(ReceiveTipNotificationActionFromJSON)
  };
}
function ReceiveTipNotificationToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "group_id": value.groupId,
    "is_seen": value.isSeen,
    "seen_at": value.seenAt,
    "actions": value.actions.map(ReceiveTipNotificationActionToJSON)
  };
}
function instanceOfRemixNotificationActionData(value) {
  let isInstance = true;
  isInstance = isInstance && "parentTrackId" in value && value["parentTrackId"] !== void 0;
  isInstance = isInstance && "trackId" in value && value["trackId"] !== void 0;
  return isInstance;
}
function RemixNotificationActionDataFromJSON(json) {
  return RemixNotificationActionDataFromJSONTyped(json);
}
function RemixNotificationActionDataFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "parentTrackId": json["parent_track_id"],
    "trackId": json["track_id"]
  };
}
function RemixNotificationActionDataToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "parent_track_id": value.parentTrackId,
    "track_id": value.trackId
  };
}
function instanceOfRemixNotificationAction(value) {
  let isInstance = true;
  isInstance = isInstance && "specifier" in value && value["specifier"] !== void 0;
  isInstance = isInstance && "type" in value && value["type"] !== void 0;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== void 0;
  isInstance = isInstance && "data" in value && value["data"] !== void 0;
  return isInstance;
}
function RemixNotificationActionFromJSON(json) {
  return RemixNotificationActionFromJSONTyped(json);
}
function RemixNotificationActionFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "specifier": json["specifier"],
    "type": json["type"],
    "timestamp": json["timestamp"],
    "data": RemixNotificationActionDataFromJSON(json["data"])
  };
}
function RemixNotificationActionToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "specifier": value.specifier,
    "type": value.type,
    "timestamp": value.timestamp,
    "data": RemixNotificationActionDataToJSON(value.data)
  };
}
function instanceOfRemixNotification(value) {
  let isInstance = true;
  isInstance = isInstance && "type" in value && value["type"] !== void 0;
  isInstance = isInstance && "groupId" in value && value["groupId"] !== void 0;
  isInstance = isInstance && "isSeen" in value && value["isSeen"] !== void 0;
  isInstance = isInstance && "actions" in value && value["actions"] !== void 0;
  return isInstance;
}
function RemixNotificationFromJSON(json) {
  return RemixNotificationFromJSONTyped(json);
}
function RemixNotificationFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "groupId": json["group_id"],
    "isSeen": json["is_seen"],
    "seenAt": !exists3(json, "seen_at") ? void 0 : json["seen_at"],
    "actions": json["actions"].map(RemixNotificationActionFromJSON)
  };
}
function RemixNotificationToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "group_id": value.groupId,
    "is_seen": value.isSeen,
    "seen_at": value.seenAt,
    "actions": value.actions.map(RemixNotificationActionToJSON)
  };
}
var RepostNotificationActionDataTypeEnum = {
  Track: "track",
  Playlist: "playlist",
  Album: "album"
};
function instanceOfRepostNotificationActionData(value) {
  let isInstance = true;
  isInstance = isInstance && "type" in value && value["type"] !== void 0;
  isInstance = isInstance && "userId" in value && value["userId"] !== void 0;
  isInstance = isInstance && "repostItemId" in value && value["repostItemId"] !== void 0;
  return isInstance;
}
function RepostNotificationActionDataFromJSON(json) {
  return RepostNotificationActionDataFromJSONTyped(json);
}
function RepostNotificationActionDataFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "userId": json["user_id"],
    "repostItemId": json["repost_item_id"]
  };
}
function RepostNotificationActionDataToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "user_id": value.userId,
    "repost_item_id": value.repostItemId
  };
}
function instanceOfRepostNotificationAction(value) {
  let isInstance = true;
  isInstance = isInstance && "specifier" in value && value["specifier"] !== void 0;
  isInstance = isInstance && "type" in value && value["type"] !== void 0;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== void 0;
  isInstance = isInstance && "data" in value && value["data"] !== void 0;
  return isInstance;
}
function RepostNotificationActionFromJSON(json) {
  return RepostNotificationActionFromJSONTyped(json);
}
function RepostNotificationActionFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "specifier": json["specifier"],
    "type": json["type"],
    "timestamp": json["timestamp"],
    "data": RepostNotificationActionDataFromJSON(json["data"])
  };
}
function RepostNotificationActionToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "specifier": value.specifier,
    "type": value.type,
    "timestamp": value.timestamp,
    "data": RepostNotificationActionDataToJSON(value.data)
  };
}
function instanceOfRepostNotification(value) {
  let isInstance = true;
  isInstance = isInstance && "type" in value && value["type"] !== void 0;
  isInstance = isInstance && "groupId" in value && value["groupId"] !== void 0;
  isInstance = isInstance && "isSeen" in value && value["isSeen"] !== void 0;
  isInstance = isInstance && "actions" in value && value["actions"] !== void 0;
  return isInstance;
}
function RepostNotificationFromJSON(json) {
  return RepostNotificationFromJSONTyped(json);
}
function RepostNotificationFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "groupId": json["group_id"],
    "isSeen": json["is_seen"],
    "seenAt": !exists3(json, "seen_at") ? void 0 : json["seen_at"],
    "actions": json["actions"].map(RepostNotificationActionFromJSON)
  };
}
function RepostNotificationToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "group_id": value.groupId,
    "is_seen": value.isSeen,
    "seen_at": value.seenAt,
    "actions": value.actions.map(RepostNotificationActionToJSON)
  };
}
var RepostOfRepostNotificationActionDataTypeEnum = {
  Track: "track",
  Playlist: "playlist",
  Album: "album"
};
function instanceOfRepostOfRepostNotificationActionData(value) {
  let isInstance = true;
  isInstance = isInstance && "type" in value && value["type"] !== void 0;
  isInstance = isInstance && "userId" in value && value["userId"] !== void 0;
  isInstance = isInstance && "repostOfRepostItemId" in value && value["repostOfRepostItemId"] !== void 0;
  return isInstance;
}
function RepostOfRepostNotificationActionDataFromJSON(json) {
  return RepostOfRepostNotificationActionDataFromJSONTyped(json);
}
function RepostOfRepostNotificationActionDataFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "userId": json["user_id"],
    "repostOfRepostItemId": json["repost_of_repost_item_id"]
  };
}
function RepostOfRepostNotificationActionDataToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "user_id": value.userId,
    "repost_of_repost_item_id": value.repostOfRepostItemId
  };
}
function instanceOfRepostOfRepostNotificationAction(value) {
  let isInstance = true;
  isInstance = isInstance && "specifier" in value && value["specifier"] !== void 0;
  isInstance = isInstance && "type" in value && value["type"] !== void 0;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== void 0;
  isInstance = isInstance && "data" in value && value["data"] !== void 0;
  return isInstance;
}
function RepostOfRepostNotificationActionFromJSON(json) {
  return RepostOfRepostNotificationActionFromJSONTyped(json);
}
function RepostOfRepostNotificationActionFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "specifier": json["specifier"],
    "type": json["type"],
    "timestamp": json["timestamp"],
    "data": RepostOfRepostNotificationActionDataFromJSON(json["data"])
  };
}
function RepostOfRepostNotificationActionToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "specifier": value.specifier,
    "type": value.type,
    "timestamp": value.timestamp,
    "data": RepostOfRepostNotificationActionDataToJSON(value.data)
  };
}
function instanceOfRepostOfRepostNotification(value) {
  let isInstance = true;
  isInstance = isInstance && "type" in value && value["type"] !== void 0;
  isInstance = isInstance && "groupId" in value && value["groupId"] !== void 0;
  isInstance = isInstance && "isSeen" in value && value["isSeen"] !== void 0;
  isInstance = isInstance && "actions" in value && value["actions"] !== void 0;
  return isInstance;
}
function RepostOfRepostNotificationFromJSON(json) {
  return RepostOfRepostNotificationFromJSONTyped(json);
}
function RepostOfRepostNotificationFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "groupId": json["group_id"],
    "isSeen": json["is_seen"],
    "seenAt": !exists3(json, "seen_at") ? void 0 : json["seen_at"],
    "actions": json["actions"].map(RepostOfRepostNotificationActionFromJSON)
  };
}
function RepostOfRepostNotificationToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "group_id": value.groupId,
    "is_seen": value.isSeen,
    "seen_at": value.seenAt,
    "actions": value.actions.map(RepostOfRepostNotificationActionToJSON)
  };
}
function instanceOfRequestManagerNotificationActionData(value) {
  let isInstance = true;
  isInstance = isInstance && "userId" in value && value["userId"] !== void 0;
  isInstance = isInstance && "granteeUserId" in value && value["granteeUserId"] !== void 0;
  isInstance = isInstance && "granteeAddress" in value && value["granteeAddress"] !== void 0;
  return isInstance;
}
function RequestManagerNotificationActionDataFromJSON(json) {
  return RequestManagerNotificationActionDataFromJSONTyped(json);
}
function RequestManagerNotificationActionDataFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "userId": json["user_id"],
    "granteeUserId": json["grantee_user_id"],
    "granteeAddress": json["grantee_address"]
  };
}
function RequestManagerNotificationActionDataToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "user_id": value.userId,
    "grantee_user_id": value.granteeUserId,
    "grantee_address": value.granteeAddress
  };
}
function instanceOfRequestManagerNotificationAction(value) {
  let isInstance = true;
  isInstance = isInstance && "specifier" in value && value["specifier"] !== void 0;
  isInstance = isInstance && "type" in value && value["type"] !== void 0;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== void 0;
  isInstance = isInstance && "data" in value && value["data"] !== void 0;
  return isInstance;
}
function RequestManagerNotificationActionFromJSON(json) {
  return RequestManagerNotificationActionFromJSONTyped(json);
}
function RequestManagerNotificationActionFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "specifier": json["specifier"],
    "type": json["type"],
    "timestamp": json["timestamp"],
    "data": RequestManagerNotificationActionDataFromJSON(json["data"])
  };
}
function RequestManagerNotificationActionToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "specifier": value.specifier,
    "type": value.type,
    "timestamp": value.timestamp,
    "data": RequestManagerNotificationActionDataToJSON(value.data)
  };
}
function instanceOfRequestManagerNotification(value) {
  let isInstance = true;
  isInstance = isInstance && "type" in value && value["type"] !== void 0;
  isInstance = isInstance && "groupId" in value && value["groupId"] !== void 0;
  isInstance = isInstance && "isSeen" in value && value["isSeen"] !== void 0;
  isInstance = isInstance && "actions" in value && value["actions"] !== void 0;
  return isInstance;
}
function RequestManagerNotificationFromJSON(json) {
  return RequestManagerNotificationFromJSONTyped(json);
}
function RequestManagerNotificationFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "groupId": json["group_id"],
    "isSeen": json["is_seen"],
    "seenAt": !exists3(json, "seen_at") ? void 0 : json["seen_at"],
    "actions": json["actions"].map(RequestManagerNotificationActionFromJSON)
  };
}
function RequestManagerNotificationToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "group_id": value.groupId,
    "is_seen": value.isSeen,
    "seen_at": value.seenAt,
    "actions": value.actions.map(RequestManagerNotificationActionToJSON)
  };
}
var SaveNotificationActionDataTypeEnum = {
  Track: "track",
  Playlist: "playlist",
  Album: "album"
};
function instanceOfSaveNotificationActionData(value) {
  let isInstance = true;
  isInstance = isInstance && "type" in value && value["type"] !== void 0;
  isInstance = isInstance && "userId" in value && value["userId"] !== void 0;
  isInstance = isInstance && "saveItemId" in value && value["saveItemId"] !== void 0;
  return isInstance;
}
function SaveNotificationActionDataFromJSON(json) {
  return SaveNotificationActionDataFromJSONTyped(json);
}
function SaveNotificationActionDataFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "userId": json["user_id"],
    "saveItemId": json["save_item_id"]
  };
}
function SaveNotificationActionDataToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "user_id": value.userId,
    "save_item_id": value.saveItemId
  };
}
function instanceOfSaveNotificationAction(value) {
  let isInstance = true;
  isInstance = isInstance && "specifier" in value && value["specifier"] !== void 0;
  isInstance = isInstance && "type" in value && value["type"] !== void 0;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== void 0;
  isInstance = isInstance && "data" in value && value["data"] !== void 0;
  return isInstance;
}
function SaveNotificationActionFromJSON(json) {
  return SaveNotificationActionFromJSONTyped(json);
}
function SaveNotificationActionFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "specifier": json["specifier"],
    "type": json["type"],
    "timestamp": json["timestamp"],
    "data": SaveNotificationActionDataFromJSON(json["data"])
  };
}
function SaveNotificationActionToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "specifier": value.specifier,
    "type": value.type,
    "timestamp": value.timestamp,
    "data": SaveNotificationActionDataToJSON(value.data)
  };
}
function instanceOfSaveNotification(value) {
  let isInstance = true;
  isInstance = isInstance && "type" in value && value["type"] !== void 0;
  isInstance = isInstance && "groupId" in value && value["groupId"] !== void 0;
  isInstance = isInstance && "isSeen" in value && value["isSeen"] !== void 0;
  isInstance = isInstance && "actions" in value && value["actions"] !== void 0;
  return isInstance;
}
function SaveNotificationFromJSON(json) {
  return SaveNotificationFromJSONTyped(json);
}
function SaveNotificationFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "groupId": json["group_id"],
    "isSeen": json["is_seen"],
    "seenAt": !exists3(json, "seen_at") ? void 0 : json["seen_at"],
    "actions": json["actions"].map(SaveNotificationActionFromJSON)
  };
}
function SaveNotificationToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "group_id": value.groupId,
    "is_seen": value.isSeen,
    "seen_at": value.seenAt,
    "actions": value.actions.map(SaveNotificationActionToJSON)
  };
}
var SaveOfRepostNotificationActionDataTypeEnum = {
  Track: "track",
  Playlist: "playlist",
  Album: "album"
};
function instanceOfSaveOfRepostNotificationActionData(value) {
  let isInstance = true;
  isInstance = isInstance && "type" in value && value["type"] !== void 0;
  isInstance = isInstance && "userId" in value && value["userId"] !== void 0;
  isInstance = isInstance && "saveOfRepostItemId" in value && value["saveOfRepostItemId"] !== void 0;
  return isInstance;
}
function SaveOfRepostNotificationActionDataFromJSON(json) {
  return SaveOfRepostNotificationActionDataFromJSONTyped(json);
}
function SaveOfRepostNotificationActionDataFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "userId": json["user_id"],
    "saveOfRepostItemId": json["save_of_repost_item_id"]
  };
}
function SaveOfRepostNotificationActionDataToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "user_id": value.userId,
    "save_of_repost_item_id": value.saveOfRepostItemId
  };
}
function instanceOfSaveOfRepostNotificationAction(value) {
  let isInstance = true;
  isInstance = isInstance && "specifier" in value && value["specifier"] !== void 0;
  isInstance = isInstance && "type" in value && value["type"] !== void 0;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== void 0;
  isInstance = isInstance && "data" in value && value["data"] !== void 0;
  return isInstance;
}
function SaveOfRepostNotificationActionFromJSON(json) {
  return SaveOfRepostNotificationActionFromJSONTyped(json);
}
function SaveOfRepostNotificationActionFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "specifier": json["specifier"],
    "type": json["type"],
    "timestamp": json["timestamp"],
    "data": SaveOfRepostNotificationActionDataFromJSON(json["data"])
  };
}
function SaveOfRepostNotificationActionToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "specifier": value.specifier,
    "type": value.type,
    "timestamp": value.timestamp,
    "data": SaveOfRepostNotificationActionDataToJSON(value.data)
  };
}
function instanceOfSaveOfRepostNotification(value) {
  let isInstance = true;
  isInstance = isInstance && "type" in value && value["type"] !== void 0;
  isInstance = isInstance && "groupId" in value && value["groupId"] !== void 0;
  isInstance = isInstance && "isSeen" in value && value["isSeen"] !== void 0;
  isInstance = isInstance && "actions" in value && value["actions"] !== void 0;
  return isInstance;
}
function SaveOfRepostNotificationFromJSON(json) {
  return SaveOfRepostNotificationFromJSONTyped(json);
}
function SaveOfRepostNotificationFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "groupId": json["group_id"],
    "isSeen": json["is_seen"],
    "seenAt": !exists3(json, "seen_at") ? void 0 : json["seen_at"],
    "actions": json["actions"].map(SaveOfRepostNotificationActionFromJSON)
  };
}
function SaveOfRepostNotificationToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "group_id": value.groupId,
    "is_seen": value.isSeen,
    "seen_at": value.seenAt,
    "actions": value.actions.map(SaveOfRepostNotificationActionToJSON)
  };
}
function instanceOfSendTipNotificationActionData(value) {
  let isInstance = true;
  isInstance = isInstance && "amount" in value && value["amount"] !== void 0;
  isInstance = isInstance && "senderUserId" in value && value["senderUserId"] !== void 0;
  isInstance = isInstance && "receiverUserId" in value && value["receiverUserId"] !== void 0;
  isInstance = isInstance && "tipTxSignature" in value && value["tipTxSignature"] !== void 0;
  return isInstance;
}
function SendTipNotificationActionDataFromJSON(json) {
  return SendTipNotificationActionDataFromJSONTyped(json);
}
function SendTipNotificationActionDataFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "amount": json["amount"],
    "senderUserId": json["sender_user_id"],
    "receiverUserId": json["receiver_user_id"],
    "tipTxSignature": json["tip_tx_signature"]
  };
}
function SendTipNotificationActionDataToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "amount": value.amount,
    "sender_user_id": value.senderUserId,
    "receiver_user_id": value.receiverUserId,
    "tip_tx_signature": value.tipTxSignature
  };
}
function instanceOfSendTipNotificationAction(value) {
  let isInstance = true;
  isInstance = isInstance && "specifier" in value && value["specifier"] !== void 0;
  isInstance = isInstance && "type" in value && value["type"] !== void 0;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== void 0;
  isInstance = isInstance && "data" in value && value["data"] !== void 0;
  return isInstance;
}
function SendTipNotificationActionFromJSON(json) {
  return SendTipNotificationActionFromJSONTyped(json);
}
function SendTipNotificationActionFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "specifier": json["specifier"],
    "type": json["type"],
    "timestamp": json["timestamp"],
    "data": SendTipNotificationActionDataFromJSON(json["data"])
  };
}
function SendTipNotificationActionToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "specifier": value.specifier,
    "type": value.type,
    "timestamp": value.timestamp,
    "data": SendTipNotificationActionDataToJSON(value.data)
  };
}
function instanceOfSendTipNotification(value) {
  let isInstance = true;
  isInstance = isInstance && "type" in value && value["type"] !== void 0;
  isInstance = isInstance && "groupId" in value && value["groupId"] !== void 0;
  isInstance = isInstance && "isSeen" in value && value["isSeen"] !== void 0;
  isInstance = isInstance && "actions" in value && value["actions"] !== void 0;
  return isInstance;
}
function SendTipNotificationFromJSON(json) {
  return SendTipNotificationFromJSONTyped(json);
}
function SendTipNotificationFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "groupId": json["group_id"],
    "isSeen": json["is_seen"],
    "seenAt": !exists3(json, "seen_at") ? void 0 : json["seen_at"],
    "actions": json["actions"].map(SendTipNotificationActionFromJSON)
  };
}
function SendTipNotificationToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "group_id": value.groupId,
    "is_seen": value.isSeen,
    "seen_at": value.seenAt,
    "actions": value.actions.map(SendTipNotificationActionToJSON)
  };
}
function instanceOfSupporterDethronedNotificationActionData(value) {
  let isInstance = true;
  isInstance = isInstance && "dethronedUserId" in value && value["dethronedUserId"] !== void 0;
  isInstance = isInstance && "senderUserId" in value && value["senderUserId"] !== void 0;
  isInstance = isInstance && "receiverUserId" in value && value["receiverUserId"] !== void 0;
  return isInstance;
}
function SupporterDethronedNotificationActionDataFromJSON(json) {
  return SupporterDethronedNotificationActionDataFromJSONTyped(json);
}
function SupporterDethronedNotificationActionDataFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "dethronedUserId": json["dethroned_user_id"],
    "senderUserId": json["sender_user_id"],
    "receiverUserId": json["receiver_user_id"]
  };
}
function SupporterDethronedNotificationActionDataToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "dethroned_user_id": value.dethronedUserId,
    "sender_user_id": value.senderUserId,
    "receiver_user_id": value.receiverUserId
  };
}
function instanceOfSupporterDethronedNotificationAction(value) {
  let isInstance = true;
  isInstance = isInstance && "specifier" in value && value["specifier"] !== void 0;
  isInstance = isInstance && "type" in value && value["type"] !== void 0;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== void 0;
  isInstance = isInstance && "data" in value && value["data"] !== void 0;
  return isInstance;
}
function SupporterDethronedNotificationActionFromJSON(json) {
  return SupporterDethronedNotificationActionFromJSONTyped(json);
}
function SupporterDethronedNotificationActionFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "specifier": json["specifier"],
    "type": json["type"],
    "timestamp": json["timestamp"],
    "data": SupporterDethronedNotificationActionDataFromJSON(json["data"])
  };
}
function SupporterDethronedNotificationActionToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "specifier": value.specifier,
    "type": value.type,
    "timestamp": value.timestamp,
    "data": SupporterDethronedNotificationActionDataToJSON(value.data)
  };
}
function instanceOfSupporterDethronedNotification(value) {
  let isInstance = true;
  isInstance = isInstance && "type" in value && value["type"] !== void 0;
  isInstance = isInstance && "groupId" in value && value["groupId"] !== void 0;
  isInstance = isInstance && "isSeen" in value && value["isSeen"] !== void 0;
  isInstance = isInstance && "actions" in value && value["actions"] !== void 0;
  return isInstance;
}
function SupporterDethronedNotificationFromJSON(json) {
  return SupporterDethronedNotificationFromJSONTyped(json);
}
function SupporterDethronedNotificationFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "groupId": json["group_id"],
    "isSeen": json["is_seen"],
    "seenAt": !exists3(json, "seen_at") ? void 0 : json["seen_at"],
    "actions": json["actions"].map(SupporterDethronedNotificationActionFromJSON)
  };
}
function SupporterDethronedNotificationToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "group_id": value.groupId,
    "is_seen": value.isSeen,
    "seen_at": value.seenAt,
    "actions": value.actions.map(SupporterDethronedNotificationActionToJSON)
  };
}
function instanceOfSupporterRankUpNotificationActionData(value) {
  let isInstance = true;
  isInstance = isInstance && "rank" in value && value["rank"] !== void 0;
  isInstance = isInstance && "senderUserId" in value && value["senderUserId"] !== void 0;
  isInstance = isInstance && "receiverUserId" in value && value["receiverUserId"] !== void 0;
  return isInstance;
}
function SupporterRankUpNotificationActionDataFromJSON(json) {
  return SupporterRankUpNotificationActionDataFromJSONTyped(json);
}
function SupporterRankUpNotificationActionDataFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "rank": json["rank"],
    "senderUserId": json["sender_user_id"],
    "receiverUserId": json["receiver_user_id"]
  };
}
function SupporterRankUpNotificationActionDataToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "rank": value.rank,
    "sender_user_id": value.senderUserId,
    "receiver_user_id": value.receiverUserId
  };
}
function instanceOfSupporterRankUpNotificationAction(value) {
  let isInstance = true;
  isInstance = isInstance && "specifier" in value && value["specifier"] !== void 0;
  isInstance = isInstance && "type" in value && value["type"] !== void 0;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== void 0;
  isInstance = isInstance && "data" in value && value["data"] !== void 0;
  return isInstance;
}
function SupporterRankUpNotificationActionFromJSON(json) {
  return SupporterRankUpNotificationActionFromJSONTyped(json);
}
function SupporterRankUpNotificationActionFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "specifier": json["specifier"],
    "type": json["type"],
    "timestamp": json["timestamp"],
    "data": SupporterRankUpNotificationActionDataFromJSON(json["data"])
  };
}
function SupporterRankUpNotificationActionToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "specifier": value.specifier,
    "type": value.type,
    "timestamp": value.timestamp,
    "data": SupporterRankUpNotificationActionDataToJSON(value.data)
  };
}
function instanceOfSupporterRankUpNotification(value) {
  let isInstance = true;
  isInstance = isInstance && "type" in value && value["type"] !== void 0;
  isInstance = isInstance && "groupId" in value && value["groupId"] !== void 0;
  isInstance = isInstance && "isSeen" in value && value["isSeen"] !== void 0;
  isInstance = isInstance && "actions" in value && value["actions"] !== void 0;
  return isInstance;
}
function SupporterRankUpNotificationFromJSON(json) {
  return SupporterRankUpNotificationFromJSONTyped(json);
}
function SupporterRankUpNotificationFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "groupId": json["group_id"],
    "isSeen": json["is_seen"],
    "seenAt": !exists3(json, "seen_at") ? void 0 : json["seen_at"],
    "actions": json["actions"].map(SupporterRankUpNotificationActionFromJSON)
  };
}
function SupporterRankUpNotificationToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "group_id": value.groupId,
    "is_seen": value.isSeen,
    "seen_at": value.seenAt,
    "actions": value.actions.map(SupporterRankUpNotificationActionToJSON)
  };
}
function instanceOfTastemakerNotificationActionData(value) {
  let isInstance = true;
  isInstance = isInstance && "tastemakerItemOwnerId" in value && value["tastemakerItemOwnerId"] !== void 0;
  isInstance = isInstance && "tastemakerItemId" in value && value["tastemakerItemId"] !== void 0;
  isInstance = isInstance && "action" in value && value["action"] !== void 0;
  isInstance = isInstance && "tastemakerItemType" in value && value["tastemakerItemType"] !== void 0;
  isInstance = isInstance && "tastemakerUserId" in value && value["tastemakerUserId"] !== void 0;
  return isInstance;
}
function TastemakerNotificationActionDataFromJSON(json) {
  return TastemakerNotificationActionDataFromJSONTyped(json);
}
function TastemakerNotificationActionDataFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "tastemakerItemOwnerId": json["tastemaker_item_owner_id"],
    "tastemakerItemId": json["tastemaker_item_id"],
    "action": json["action"],
    "tastemakerItemType": json["tastemaker_item_type"],
    "tastemakerUserId": json["tastemaker_user_id"]
  };
}
function TastemakerNotificationActionDataToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "tastemaker_item_owner_id": value.tastemakerItemOwnerId,
    "tastemaker_item_id": value.tastemakerItemId,
    "action": value.action,
    "tastemaker_item_type": value.tastemakerItemType,
    "tastemaker_user_id": value.tastemakerUserId
  };
}
function instanceOfTastemakerNotificationAction(value) {
  let isInstance = true;
  isInstance = isInstance && "specifier" in value && value["specifier"] !== void 0;
  isInstance = isInstance && "type" in value && value["type"] !== void 0;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== void 0;
  isInstance = isInstance && "data" in value && value["data"] !== void 0;
  return isInstance;
}
function TastemakerNotificationActionFromJSON(json) {
  return TastemakerNotificationActionFromJSONTyped(json);
}
function TastemakerNotificationActionFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "specifier": json["specifier"],
    "type": json["type"],
    "timestamp": json["timestamp"],
    "data": TastemakerNotificationActionDataFromJSON(json["data"])
  };
}
function TastemakerNotificationActionToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "specifier": value.specifier,
    "type": value.type,
    "timestamp": value.timestamp,
    "data": TastemakerNotificationActionDataToJSON(value.data)
  };
}
function instanceOfTastemakerNotification(value) {
  let isInstance = true;
  isInstance = isInstance && "type" in value && value["type"] !== void 0;
  isInstance = isInstance && "groupId" in value && value["groupId"] !== void 0;
  isInstance = isInstance && "isSeen" in value && value["isSeen"] !== void 0;
  isInstance = isInstance && "actions" in value && value["actions"] !== void 0;
  return isInstance;
}
function TastemakerNotificationFromJSON(json) {
  return TastemakerNotificationFromJSONTyped(json);
}
function TastemakerNotificationFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "groupId": json["group_id"],
    "isSeen": json["is_seen"],
    "seenAt": !exists3(json, "seen_at") ? void 0 : json["seen_at"],
    "actions": json["actions"].map(TastemakerNotificationActionFromJSON)
  };
}
function TastemakerNotificationToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "group_id": value.groupId,
    "is_seen": value.isSeen,
    "seen_at": value.seenAt,
    "actions": value.actions.map(TastemakerNotificationActionToJSON)
  };
}
function instanceOfTierChangeNotificationActionData(value) {
  let isInstance = true;
  isInstance = isInstance && "newTier" in value && value["newTier"] !== void 0;
  isInstance = isInstance && "currentValue" in value && value["currentValue"] !== void 0;
  isInstance = isInstance && "newTierValue" in value && value["newTierValue"] !== void 0;
  return isInstance;
}
function TierChangeNotificationActionDataFromJSON(json) {
  return TierChangeNotificationActionDataFromJSONTyped(json);
}
function TierChangeNotificationActionDataFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "newTier": json["new_tier"],
    "currentValue": json["current_value"],
    "newTierValue": json["new_tier_value"]
  };
}
function TierChangeNotificationActionDataToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "new_tier": value.newTier,
    "current_value": value.currentValue,
    "new_tier_value": value.newTierValue
  };
}
function instanceOfTierChangeNotificationAction(value) {
  let isInstance = true;
  isInstance = isInstance && "specifier" in value && value["specifier"] !== void 0;
  isInstance = isInstance && "type" in value && value["type"] !== void 0;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== void 0;
  isInstance = isInstance && "data" in value && value["data"] !== void 0;
  return isInstance;
}
function TierChangeNotificationActionFromJSON(json) {
  return TierChangeNotificationActionFromJSONTyped(json);
}
function TierChangeNotificationActionFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "specifier": json["specifier"],
    "type": json["type"],
    "timestamp": json["timestamp"],
    "data": TierChangeNotificationActionDataFromJSON(json["data"])
  };
}
function TierChangeNotificationActionToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "specifier": value.specifier,
    "type": value.type,
    "timestamp": value.timestamp,
    "data": TierChangeNotificationActionDataToJSON(value.data)
  };
}
function instanceOfTierChangeNotification(value) {
  let isInstance = true;
  isInstance = isInstance && "type" in value && value["type"] !== void 0;
  isInstance = isInstance && "groupId" in value && value["groupId"] !== void 0;
  isInstance = isInstance && "isSeen" in value && value["isSeen"] !== void 0;
  isInstance = isInstance && "actions" in value && value["actions"] !== void 0;
  return isInstance;
}
function TierChangeNotificationFromJSON(json) {
  return TierChangeNotificationFromJSONTyped(json);
}
function TierChangeNotificationFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "groupId": json["group_id"],
    "isSeen": json["is_seen"],
    "seenAt": !exists3(json, "seen_at") ? void 0 : json["seen_at"],
    "actions": json["actions"].map(TierChangeNotificationActionFromJSON)
  };
}
function TierChangeNotificationToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "group_id": value.groupId,
    "is_seen": value.isSeen,
    "seen_at": value.seenAt,
    "actions": value.actions.map(TierChangeNotificationActionToJSON)
  };
}
function instanceOfTrackAddedToPlaylistNotificationActionData(value) {
  let isInstance = true;
  isInstance = isInstance && "trackId" in value && value["trackId"] !== void 0;
  isInstance = isInstance && "playlistId" in value && value["playlistId"] !== void 0;
  isInstance = isInstance && "playlistOwnerId" in value && value["playlistOwnerId"] !== void 0;
  return isInstance;
}
function TrackAddedToPlaylistNotificationActionDataFromJSON(json) {
  return TrackAddedToPlaylistNotificationActionDataFromJSONTyped(json);
}
function TrackAddedToPlaylistNotificationActionDataFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "trackId": json["track_id"],
    "playlistId": json["playlist_id"],
    "playlistOwnerId": json["playlist_owner_id"]
  };
}
function TrackAddedToPlaylistNotificationActionDataToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "track_id": value.trackId,
    "playlist_id": value.playlistId,
    "playlist_owner_id": value.playlistOwnerId
  };
}
function instanceOfTrackAddedToPlaylistNotificationAction(value) {
  let isInstance = true;
  isInstance = isInstance && "specifier" in value && value["specifier"] !== void 0;
  isInstance = isInstance && "type" in value && value["type"] !== void 0;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== void 0;
  isInstance = isInstance && "data" in value && value["data"] !== void 0;
  return isInstance;
}
function TrackAddedToPlaylistNotificationActionFromJSON(json) {
  return TrackAddedToPlaylistNotificationActionFromJSONTyped(json);
}
function TrackAddedToPlaylistNotificationActionFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "specifier": json["specifier"],
    "type": json["type"],
    "timestamp": json["timestamp"],
    "data": TrackAddedToPlaylistNotificationActionDataFromJSON(json["data"])
  };
}
function TrackAddedToPlaylistNotificationActionToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "specifier": value.specifier,
    "type": value.type,
    "timestamp": value.timestamp,
    "data": TrackAddedToPlaylistNotificationActionDataToJSON(value.data)
  };
}
function instanceOfTrackAddedToPlaylistNotification(value) {
  let isInstance = true;
  isInstance = isInstance && "type" in value && value["type"] !== void 0;
  isInstance = isInstance && "groupId" in value && value["groupId"] !== void 0;
  isInstance = isInstance && "isSeen" in value && value["isSeen"] !== void 0;
  isInstance = isInstance && "actions" in value && value["actions"] !== void 0;
  return isInstance;
}
function TrackAddedToPlaylistNotificationFromJSON(json) {
  return TrackAddedToPlaylistNotificationFromJSONTyped(json);
}
function TrackAddedToPlaylistNotificationFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "groupId": json["group_id"],
    "isSeen": json["is_seen"],
    "seenAt": !exists3(json, "seen_at") ? void 0 : json["seen_at"],
    "actions": json["actions"].map(TrackAddedToPlaylistNotificationActionFromJSON)
  };
}
function TrackAddedToPlaylistNotificationToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "group_id": value.groupId,
    "is_seen": value.isSeen,
    "seen_at": value.seenAt,
    "actions": value.actions.map(TrackAddedToPlaylistNotificationActionToJSON)
  };
}
function instanceOfTrackAddedToPurchasedAlbumNotificationActionData(value) {
  let isInstance = true;
  isInstance = isInstance && "trackId" in value && value["trackId"] !== void 0;
  isInstance = isInstance && "playlistId" in value && value["playlistId"] !== void 0;
  isInstance = isInstance && "playlistOwnerId" in value && value["playlistOwnerId"] !== void 0;
  return isInstance;
}
function TrackAddedToPurchasedAlbumNotificationActionDataFromJSON(json) {
  return TrackAddedToPurchasedAlbumNotificationActionDataFromJSONTyped(json);
}
function TrackAddedToPurchasedAlbumNotificationActionDataFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "trackId": json["track_id"],
    "playlistId": json["playlist_id"],
    "playlistOwnerId": json["playlist_owner_id"]
  };
}
function TrackAddedToPurchasedAlbumNotificationActionDataToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "track_id": value.trackId,
    "playlist_id": value.playlistId,
    "playlist_owner_id": value.playlistOwnerId
  };
}
function instanceOfTrackAddedToPurchasedAlbumNotificationAction(value) {
  let isInstance = true;
  isInstance = isInstance && "specifier" in value && value["specifier"] !== void 0;
  isInstance = isInstance && "type" in value && value["type"] !== void 0;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== void 0;
  isInstance = isInstance && "data" in value && value["data"] !== void 0;
  return isInstance;
}
function TrackAddedToPurchasedAlbumNotificationActionFromJSON(json) {
  return TrackAddedToPurchasedAlbumNotificationActionFromJSONTyped(json);
}
function TrackAddedToPurchasedAlbumNotificationActionFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "specifier": json["specifier"],
    "type": json["type"],
    "timestamp": json["timestamp"],
    "data": TrackAddedToPurchasedAlbumNotificationActionDataFromJSON(json["data"])
  };
}
function TrackAddedToPurchasedAlbumNotificationActionToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "specifier": value.specifier,
    "type": value.type,
    "timestamp": value.timestamp,
    "data": TrackAddedToPurchasedAlbumNotificationActionDataToJSON(value.data)
  };
}
function instanceOfTrackAddedToPurchasedAlbumNotification(value) {
  let isInstance = true;
  isInstance = isInstance && "type" in value && value["type"] !== void 0;
  isInstance = isInstance && "groupId" in value && value["groupId"] !== void 0;
  isInstance = isInstance && "isSeen" in value && value["isSeen"] !== void 0;
  isInstance = isInstance && "actions" in value && value["actions"] !== void 0;
  return isInstance;
}
function TrackAddedToPurchasedAlbumNotificationFromJSON(json) {
  return TrackAddedToPurchasedAlbumNotificationFromJSONTyped(json);
}
function TrackAddedToPurchasedAlbumNotificationFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "groupId": json["group_id"],
    "isSeen": json["is_seen"],
    "seenAt": !exists3(json, "seen_at") ? void 0 : json["seen_at"],
    "actions": json["actions"].map(TrackAddedToPurchasedAlbumNotificationActionFromJSON)
  };
}
function TrackAddedToPurchasedAlbumNotificationToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "group_id": value.groupId,
    "is_seen": value.isSeen,
    "seen_at": value.seenAt,
    "actions": value.actions.map(TrackAddedToPurchasedAlbumNotificationActionToJSON)
  };
}
var TrendingNotificationActionDataTimeRangeEnum = {
  Week: "week",
  Month: "month",
  Year: "year"
};
function instanceOfTrendingNotificationActionData(value) {
  let isInstance = true;
  isInstance = isInstance && "rank" in value && value["rank"] !== void 0;
  isInstance = isInstance && "genre" in value && value["genre"] !== void 0;
  isInstance = isInstance && "trackId" in value && value["trackId"] !== void 0;
  isInstance = isInstance && "timeRange" in value && value["timeRange"] !== void 0;
  return isInstance;
}
function TrendingNotificationActionDataFromJSON(json) {
  return TrendingNotificationActionDataFromJSONTyped(json);
}
function TrendingNotificationActionDataFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "rank": json["rank"],
    "genre": json["genre"],
    "trackId": json["track_id"],
    "timeRange": json["time_range"]
  };
}
function TrendingNotificationActionDataToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "rank": value.rank,
    "genre": value.genre,
    "track_id": value.trackId,
    "time_range": value.timeRange
  };
}
function instanceOfTrendingNotificationAction(value) {
  let isInstance = true;
  isInstance = isInstance && "specifier" in value && value["specifier"] !== void 0;
  isInstance = isInstance && "type" in value && value["type"] !== void 0;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== void 0;
  isInstance = isInstance && "data" in value && value["data"] !== void 0;
  return isInstance;
}
function TrendingNotificationActionFromJSON(json) {
  return TrendingNotificationActionFromJSONTyped(json);
}
function TrendingNotificationActionFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "specifier": json["specifier"],
    "type": json["type"],
    "timestamp": json["timestamp"],
    "data": TrendingNotificationActionDataFromJSON(json["data"])
  };
}
function TrendingNotificationActionToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "specifier": value.specifier,
    "type": value.type,
    "timestamp": value.timestamp,
    "data": TrendingNotificationActionDataToJSON(value.data)
  };
}
function instanceOfTrendingNotification(value) {
  let isInstance = true;
  isInstance = isInstance && "type" in value && value["type"] !== void 0;
  isInstance = isInstance && "groupId" in value && value["groupId"] !== void 0;
  isInstance = isInstance && "isSeen" in value && value["isSeen"] !== void 0;
  isInstance = isInstance && "actions" in value && value["actions"] !== void 0;
  return isInstance;
}
function TrendingNotificationFromJSON(json) {
  return TrendingNotificationFromJSONTyped(json);
}
function TrendingNotificationFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "groupId": json["group_id"],
    "isSeen": json["is_seen"],
    "seenAt": !exists3(json, "seen_at") ? void 0 : json["seen_at"],
    "actions": json["actions"].map(TrendingNotificationActionFromJSON)
  };
}
function TrendingNotificationToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "group_id": value.groupId,
    "is_seen": value.isSeen,
    "seen_at": value.seenAt,
    "actions": value.actions.map(TrendingNotificationActionToJSON)
  };
}
var TrendingPlaylistNotificationActionDataTimeRangeEnum = {
  Week: "week",
  Month: "month",
  Year: "year"
};
function instanceOfTrendingPlaylistNotificationActionData(value) {
  let isInstance = true;
  isInstance = isInstance && "rank" in value && value["rank"] !== void 0;
  isInstance = isInstance && "genre" in value && value["genre"] !== void 0;
  isInstance = isInstance && "playlistId" in value && value["playlistId"] !== void 0;
  isInstance = isInstance && "timeRange" in value && value["timeRange"] !== void 0;
  return isInstance;
}
function TrendingPlaylistNotificationActionDataFromJSON(json) {
  return TrendingPlaylistNotificationActionDataFromJSONTyped(json);
}
function TrendingPlaylistNotificationActionDataFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "rank": json["rank"],
    "genre": json["genre"],
    "playlistId": json["playlist_id"],
    "timeRange": json["time_range"]
  };
}
function TrendingPlaylistNotificationActionDataToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "rank": value.rank,
    "genre": value.genre,
    "playlist_id": value.playlistId,
    "time_range": value.timeRange
  };
}
function instanceOfTrendingPlaylistNotificationAction(value) {
  let isInstance = true;
  isInstance = isInstance && "specifier" in value && value["specifier"] !== void 0;
  isInstance = isInstance && "type" in value && value["type"] !== void 0;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== void 0;
  isInstance = isInstance && "data" in value && value["data"] !== void 0;
  return isInstance;
}
function TrendingPlaylistNotificationActionFromJSON(json) {
  return TrendingPlaylistNotificationActionFromJSONTyped(json);
}
function TrendingPlaylistNotificationActionFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "specifier": json["specifier"],
    "type": json["type"],
    "timestamp": json["timestamp"],
    "data": TrendingPlaylistNotificationActionDataFromJSON(json["data"])
  };
}
function TrendingPlaylistNotificationActionToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "specifier": value.specifier,
    "type": value.type,
    "timestamp": value.timestamp,
    "data": TrendingPlaylistNotificationActionDataToJSON(value.data)
  };
}
function instanceOfTrendingPlaylistNotification(value) {
  let isInstance = true;
  isInstance = isInstance && "type" in value && value["type"] !== void 0;
  isInstance = isInstance && "groupId" in value && value["groupId"] !== void 0;
  isInstance = isInstance && "isSeen" in value && value["isSeen"] !== void 0;
  isInstance = isInstance && "actions" in value && value["actions"] !== void 0;
  return isInstance;
}
function TrendingPlaylistNotificationFromJSON(json) {
  return TrendingPlaylistNotificationFromJSONTyped(json);
}
function TrendingPlaylistNotificationFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "groupId": json["group_id"],
    "isSeen": json["is_seen"],
    "seenAt": !exists3(json, "seen_at") ? void 0 : json["seen_at"],
    "actions": json["actions"].map(TrendingPlaylistNotificationActionFromJSON)
  };
}
function TrendingPlaylistNotificationToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "group_id": value.groupId,
    "is_seen": value.isSeen,
    "seen_at": value.seenAt,
    "actions": value.actions.map(TrendingPlaylistNotificationActionToJSON)
  };
}
var TrendingUndergroundNotificationActionDataTimeRangeEnum = {
  Week: "week",
  Month: "month",
  Year: "year"
};
function instanceOfTrendingUndergroundNotificationActionData(value) {
  let isInstance = true;
  isInstance = isInstance && "rank" in value && value["rank"] !== void 0;
  isInstance = isInstance && "genre" in value && value["genre"] !== void 0;
  isInstance = isInstance && "trackId" in value && value["trackId"] !== void 0;
  isInstance = isInstance && "timeRange" in value && value["timeRange"] !== void 0;
  return isInstance;
}
function TrendingUndergroundNotificationActionDataFromJSON(json) {
  return TrendingUndergroundNotificationActionDataFromJSONTyped(json);
}
function TrendingUndergroundNotificationActionDataFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "rank": json["rank"],
    "genre": json["genre"],
    "trackId": json["track_id"],
    "timeRange": json["time_range"]
  };
}
function TrendingUndergroundNotificationActionDataToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "rank": value.rank,
    "genre": value.genre,
    "track_id": value.trackId,
    "time_range": value.timeRange
  };
}
function instanceOfTrendingUndergroundNotificationAction(value) {
  let isInstance = true;
  isInstance = isInstance && "specifier" in value && value["specifier"] !== void 0;
  isInstance = isInstance && "type" in value && value["type"] !== void 0;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== void 0;
  isInstance = isInstance && "data" in value && value["data"] !== void 0;
  return isInstance;
}
function TrendingUndergroundNotificationActionFromJSON(json) {
  return TrendingUndergroundNotificationActionFromJSONTyped(json);
}
function TrendingUndergroundNotificationActionFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "specifier": json["specifier"],
    "type": json["type"],
    "timestamp": json["timestamp"],
    "data": TrendingUndergroundNotificationActionDataFromJSON(json["data"])
  };
}
function TrendingUndergroundNotificationActionToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "specifier": value.specifier,
    "type": value.type,
    "timestamp": value.timestamp,
    "data": TrendingUndergroundNotificationActionDataToJSON(value.data)
  };
}
function instanceOfTrendingUndergroundNotification(value) {
  let isInstance = true;
  isInstance = isInstance && "type" in value && value["type"] !== void 0;
  isInstance = isInstance && "groupId" in value && value["groupId"] !== void 0;
  isInstance = isInstance && "isSeen" in value && value["isSeen"] !== void 0;
  isInstance = isInstance && "actions" in value && value["actions"] !== void 0;
  return isInstance;
}
function TrendingUndergroundNotificationFromJSON(json) {
  return TrendingUndergroundNotificationFromJSONTyped(json);
}
function TrendingUndergroundNotificationFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "groupId": json["group_id"],
    "isSeen": json["is_seen"],
    "seenAt": !exists3(json, "seen_at") ? void 0 : json["seen_at"],
    "actions": json["actions"].map(TrendingUndergroundNotificationActionFromJSON)
  };
}
function TrendingUndergroundNotificationToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "group_id": value.groupId,
    "is_seen": value.isSeen,
    "seen_at": value.seenAt,
    "actions": value.actions.map(TrendingUndergroundNotificationActionToJSON)
  };
}
function instanceOfUsdcPurchaseBuyerNotificationActionData(value) {
  let isInstance = true;
  isInstance = isInstance && "contentType" in value && value["contentType"] !== void 0;
  isInstance = isInstance && "buyerUserId" in value && value["buyerUserId"] !== void 0;
  isInstance = isInstance && "sellerUserId" in value && value["sellerUserId"] !== void 0;
  isInstance = isInstance && "amount" in value && value["amount"] !== void 0;
  isInstance = isInstance && "extraAmount" in value && value["extraAmount"] !== void 0;
  isInstance = isInstance && "contentId" in value && value["contentId"] !== void 0;
  return isInstance;
}
function UsdcPurchaseBuyerNotificationActionDataFromJSON(json) {
  return UsdcPurchaseBuyerNotificationActionDataFromJSONTyped(json);
}
function UsdcPurchaseBuyerNotificationActionDataFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "contentType": json["content_type"],
    "buyerUserId": json["buyer_user_id"],
    "sellerUserId": json["seller_user_id"],
    "amount": json["amount"],
    "extraAmount": json["extra_amount"],
    "contentId": json["content_id"]
  };
}
function UsdcPurchaseBuyerNotificationActionDataToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "content_type": value.contentType,
    "buyer_user_id": value.buyerUserId,
    "seller_user_id": value.sellerUserId,
    "amount": value.amount,
    "extra_amount": value.extraAmount,
    "content_id": value.contentId
  };
}
function instanceOfUsdcPurchaseBuyerNotificationAction(value) {
  let isInstance = true;
  isInstance = isInstance && "specifier" in value && value["specifier"] !== void 0;
  isInstance = isInstance && "type" in value && value["type"] !== void 0;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== void 0;
  isInstance = isInstance && "data" in value && value["data"] !== void 0;
  return isInstance;
}
function UsdcPurchaseBuyerNotificationActionFromJSON(json) {
  return UsdcPurchaseBuyerNotificationActionFromJSONTyped(json);
}
function UsdcPurchaseBuyerNotificationActionFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "specifier": json["specifier"],
    "type": json["type"],
    "timestamp": json["timestamp"],
    "data": UsdcPurchaseBuyerNotificationActionDataFromJSON(json["data"])
  };
}
function UsdcPurchaseBuyerNotificationActionToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "specifier": value.specifier,
    "type": value.type,
    "timestamp": value.timestamp,
    "data": UsdcPurchaseBuyerNotificationActionDataToJSON(value.data)
  };
}
function instanceOfUsdcPurchaseBuyerNotification(value) {
  let isInstance = true;
  isInstance = isInstance && "type" in value && value["type"] !== void 0;
  isInstance = isInstance && "groupId" in value && value["groupId"] !== void 0;
  isInstance = isInstance && "isSeen" in value && value["isSeen"] !== void 0;
  isInstance = isInstance && "actions" in value && value["actions"] !== void 0;
  return isInstance;
}
function UsdcPurchaseBuyerNotificationFromJSON(json) {
  return UsdcPurchaseBuyerNotificationFromJSONTyped(json);
}
function UsdcPurchaseBuyerNotificationFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "groupId": json["group_id"],
    "isSeen": json["is_seen"],
    "seenAt": !exists3(json, "seen_at") ? void 0 : json["seen_at"],
    "actions": json["actions"].map(UsdcPurchaseBuyerNotificationActionFromJSON)
  };
}
function UsdcPurchaseBuyerNotificationToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "group_id": value.groupId,
    "is_seen": value.isSeen,
    "seen_at": value.seenAt,
    "actions": value.actions.map(UsdcPurchaseBuyerNotificationActionToJSON)
  };
}
function instanceOfUsdcPurchaseSellerNotificationActionData(value) {
  let isInstance = true;
  isInstance = isInstance && "contentType" in value && value["contentType"] !== void 0;
  isInstance = isInstance && "buyerUserId" in value && value["buyerUserId"] !== void 0;
  isInstance = isInstance && "sellerUserId" in value && value["sellerUserId"] !== void 0;
  isInstance = isInstance && "amount" in value && value["amount"] !== void 0;
  isInstance = isInstance && "extraAmount" in value && value["extraAmount"] !== void 0;
  isInstance = isInstance && "contentId" in value && value["contentId"] !== void 0;
  return isInstance;
}
function UsdcPurchaseSellerNotificationActionDataFromJSON(json) {
  return UsdcPurchaseSellerNotificationActionDataFromJSONTyped(json);
}
function UsdcPurchaseSellerNotificationActionDataFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "contentType": json["content_type"],
    "buyerUserId": json["buyer_user_id"],
    "sellerUserId": json["seller_user_id"],
    "amount": json["amount"],
    "extraAmount": json["extra_amount"],
    "contentId": json["content_id"]
  };
}
function UsdcPurchaseSellerNotificationActionDataToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "content_type": value.contentType,
    "buyer_user_id": value.buyerUserId,
    "seller_user_id": value.sellerUserId,
    "amount": value.amount,
    "extra_amount": value.extraAmount,
    "content_id": value.contentId
  };
}
function instanceOfUsdcPurchaseSellerNotificationAction(value) {
  let isInstance = true;
  isInstance = isInstance && "specifier" in value && value["specifier"] !== void 0;
  isInstance = isInstance && "type" in value && value["type"] !== void 0;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== void 0;
  isInstance = isInstance && "data" in value && value["data"] !== void 0;
  return isInstance;
}
function UsdcPurchaseSellerNotificationActionFromJSON(json) {
  return UsdcPurchaseSellerNotificationActionFromJSONTyped(json);
}
function UsdcPurchaseSellerNotificationActionFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "specifier": json["specifier"],
    "type": json["type"],
    "timestamp": json["timestamp"],
    "data": UsdcPurchaseSellerNotificationActionDataFromJSON(json["data"])
  };
}
function UsdcPurchaseSellerNotificationActionToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "specifier": value.specifier,
    "type": value.type,
    "timestamp": value.timestamp,
    "data": UsdcPurchaseSellerNotificationActionDataToJSON(value.data)
  };
}
function instanceOfUsdcPurchaseSellerNotification(value) {
  let isInstance = true;
  isInstance = isInstance && "type" in value && value["type"] !== void 0;
  isInstance = isInstance && "groupId" in value && value["groupId"] !== void 0;
  isInstance = isInstance && "isSeen" in value && value["isSeen"] !== void 0;
  isInstance = isInstance && "actions" in value && value["actions"] !== void 0;
  return isInstance;
}
function UsdcPurchaseSellerNotificationFromJSON(json) {
  return UsdcPurchaseSellerNotificationFromJSONTyped(json);
}
function UsdcPurchaseSellerNotificationFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "groupId": json["group_id"],
    "isSeen": json["is_seen"],
    "seenAt": !exists3(json, "seen_at") ? void 0 : json["seen_at"],
    "actions": json["actions"].map(UsdcPurchaseSellerNotificationActionFromJSON)
  };
}
function UsdcPurchaseSellerNotificationToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "group_id": value.groupId,
    "is_seen": value.isSeen,
    "seen_at": value.seenAt,
    "actions": value.actions.map(UsdcPurchaseSellerNotificationActionToJSON)
  };
}
function NotificationFromJSON(json) {
  return NotificationFromJSONTyped(json);
}
function NotificationFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  switch (json["type"]) {
    case "announcement":
      return {
        ...AnnouncementNotificationFromJSONTyped(json),
        type: "announcement"
      };
    case "approve_manager_request":
      return {
        ...ApproveManagerRequestNotificationFromJSONTyped(json),
        type: "approve_manager_request"
      };
    case "artist_remix_contest_ended":
      return {
        ...ArtistRemixContestEndedNotificationFromJSONTyped(json),
        type: "artist_remix_contest_ended"
      };
    case "artist_remix_contest_ending_soon":
      return {
        ...ArtistRemixContestEndingSoonNotificationFromJSONTyped(json),
        type: "artist_remix_contest_ending_soon"
      };
    case "artist_remix_contest_submissions":
      return {
        ...ArtistRemixContestSubmissionsNotificationFromJSONTyped(json),
        type: "artist_remix_contest_submissions"
      };
    case "challenge_reward":
      return {
        ...ChallengeRewardNotificationFromJSONTyped(json),
        type: "challenge_reward"
      };
    case "claimable_reward":
      return {
        ...ClaimableRewardNotificationFromJSONTyped(json),
        type: "claimable_reward"
      };
    case "comment":
      return {
        ...CommentNotificationFromJSONTyped(json),
        type: "comment"
      };
    case "comment_mention":
      return {
        ...CommentMentionNotificationFromJSONTyped(json),
        type: "comment_mention"
      };
    case "comment_reaction":
      return {
        ...CommentReactionNotificationFromJSONTyped(json),
        type: "comment_reaction"
      };
    case "comment_thread":
      return {
        ...CommentThreadNotificationFromJSONTyped(json),
        type: "comment_thread"
      };
    case "cosign":
      return {
        ...CosignNotificationFromJSONTyped(json),
        type: "cosign"
      };
    case "create":
      return {
        ...CreateNotificationFromJSONTyped(json),
        type: "create"
      };
    case "fan_remix_contest_ended":
      return {
        ...FanRemixContestEndedNotificationFromJSONTyped(json),
        type: "fan_remix_contest_ended"
      };
    case "fan_remix_contest_ending_soon":
      return {
        ...FanRemixContestEndingSoonNotificationFromJSONTyped(json),
        type: "fan_remix_contest_ending_soon"
      };
    case "fan_remix_contest_started":
      return {
        ...FanRemixContestStartedNotificationFromJSONTyped(json),
        type: "fan_remix_contest_started"
      };
    case "fan_remix_contest_winners_selected":
      return {
        ...FanRemixContestWinnersSelectedNotificationFromJSONTyped(json),
        type: "fan_remix_contest_winners_selected"
      };
    case "follow":
      return {
        ...FollowNotificationFromJSONTyped(json),
        type: "follow"
      };
    case "listen_streak_reminder":
      return {
        ...ListenStreakReminderNotificationFromJSONTyped(json),
        type: "listen_streak_reminder"
      };
    case "milestone":
      return {
        ...MilestoneNotificationFromJSONTyped(json),
        type: "milestone"
      };
    case "reaction":
      return {
        ...ReactionNotificationFromJSONTyped(json),
        type: "reaction"
      };
    case "remix":
      return {
        ...RemixNotificationFromJSONTyped(json),
        type: "remix"
      };
    case "repost":
      return {
        ...RepostNotificationFromJSONTyped(json),
        type: "repost"
      };
    case "repost_of_repost":
      return {
        ...RepostOfRepostNotificationFromJSONTyped(json),
        type: "repost_of_repost"
      };
    case "request_manager":
      return {
        ...RequestManagerNotificationFromJSONTyped(json),
        type: "request_manager"
      };
    case "save":
      return {
        ...SaveNotificationFromJSONTyped(json),
        type: "save"
      };
    case "save_of_repost":
      return {
        ...SaveOfRepostNotificationFromJSONTyped(json),
        type: "save_of_repost"
      };
    case "supporter_dethroned":
      return {
        ...SupporterDethronedNotificationFromJSONTyped(json),
        type: "supporter_dethroned"
      };
    case "supporter_rank_up":
      return {
        ...SupporterRankUpNotificationFromJSONTyped(json),
        type: "supporter_rank_up"
      };
    case "supporting_rank_up":
      return {
        ...SupporterRankUpNotificationFromJSONTyped(json),
        type: "supporting_rank_up"
      };
    case "tastemaker":
      return {
        ...TastemakerNotificationFromJSONTyped(json),
        type: "tastemaker"
      };
    case "tier_change":
      return {
        ...TierChangeNotificationFromJSONTyped(json),
        type: "tier_change"
      };
    case "tip_receive":
      return {
        ...ReceiveTipNotificationFromJSONTyped(json),
        type: "tip_receive"
      };
    case "tip_send":
      return {
        ...SendTipNotificationFromJSONTyped(json),
        type: "tip_send"
      };
    case "track_added_to_playlist":
      return {
        ...TrackAddedToPlaylistNotificationFromJSONTyped(json),
        type: "track_added_to_playlist"
      };
    case "track_added_to_purchased_album":
      return {
        ...TrackAddedToPurchasedAlbumNotificationFromJSONTyped(json),
        type: "track_added_to_purchased_album"
      };
    case "trending":
      return {
        ...TrendingNotificationFromJSONTyped(json),
        type: "trending"
      };
    case "trending_playlist":
      return {
        ...TrendingPlaylistNotificationFromJSONTyped(json),
        type: "trending_playlist"
      };
    case "trending_underground":
      return {
        ...TrendingUndergroundNotificationFromJSONTyped(json),
        type: "trending_underground"
      };
    case "usdc_purchase_buyer":
      return {
        ...UsdcPurchaseBuyerNotificationFromJSONTyped(json),
        type: "usdc_purchase_buyer"
      };
    case "usdc_purchase_seller":
      return {
        ...UsdcPurchaseSellerNotificationFromJSONTyped(json),
        type: "usdc_purchase_seller"
      };
    default:
      throw new Error(`No variant of Notification exists with 'type=${json["type"]}'`);
  }
}
function NotificationToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  switch (value["type"]) {
    case "announcement":
      return AnnouncementNotificationToJSON(value);
    case "approve_manager_request":
      return ApproveManagerRequestNotificationToJSON(value);
    case "artist_remix_contest_ended":
      return ArtistRemixContestEndedNotificationToJSON(value);
    case "artist_remix_contest_ending_soon":
      return ArtistRemixContestEndingSoonNotificationToJSON(value);
    case "artist_remix_contest_submissions":
      return ArtistRemixContestSubmissionsNotificationToJSON(value);
    case "challenge_reward":
      return ChallengeRewardNotificationToJSON(value);
    case "claimable_reward":
      return ClaimableRewardNotificationToJSON(value);
    case "comment":
      return CommentNotificationToJSON(value);
    case "comment_mention":
      return CommentMentionNotificationToJSON(value);
    case "comment_reaction":
      return CommentReactionNotificationToJSON(value);
    case "comment_thread":
      return CommentThreadNotificationToJSON(value);
    case "cosign":
      return CosignNotificationToJSON(value);
    case "create":
      return CreateNotificationToJSON(value);
    case "fan_remix_contest_ended":
      return FanRemixContestEndedNotificationToJSON(value);
    case "fan_remix_contest_ending_soon":
      return FanRemixContestEndingSoonNotificationToJSON(value);
    case "fan_remix_contest_started":
      return FanRemixContestStartedNotificationToJSON(value);
    case "fan_remix_contest_winners_selected":
      return FanRemixContestWinnersSelectedNotificationToJSON(value);
    case "follow":
      return FollowNotificationToJSON(value);
    case "listen_streak_reminder":
      return ListenStreakReminderNotificationToJSON(value);
    case "milestone":
      return MilestoneNotificationToJSON(value);
    case "reaction":
      return ReactionNotificationToJSON(value);
    case "remix":
      return RemixNotificationToJSON(value);
    case "repost":
      return RepostNotificationToJSON(value);
    case "repost_of_repost":
      return RepostOfRepostNotificationToJSON(value);
    case "request_manager":
      return RequestManagerNotificationToJSON(value);
    case "save":
      return SaveNotificationToJSON(value);
    case "save_of_repost":
      return SaveOfRepostNotificationToJSON(value);
    case "supporter_dethroned":
      return SupporterDethronedNotificationToJSON(value);
    case "supporter_rank_up":
      return SupporterRankUpNotificationToJSON(value);
    case "supporting_rank_up":
      return SupporterRankUpNotificationToJSON(value);
    case "tastemaker":
      return TastemakerNotificationToJSON(value);
    case "tier_change":
      return TierChangeNotificationToJSON(value);
    case "tip_receive":
      return ReceiveTipNotificationToJSON(value);
    case "tip_send":
      return SendTipNotificationToJSON(value);
    case "track_added_to_playlist":
      return TrackAddedToPlaylistNotificationToJSON(value);
    case "track_added_to_purchased_album":
      return TrackAddedToPurchasedAlbumNotificationToJSON(value);
    case "trending":
      return TrendingNotificationToJSON(value);
    case "trending_playlist":
      return TrendingPlaylistNotificationToJSON(value);
    case "trending_underground":
      return TrendingUndergroundNotificationToJSON(value);
    case "usdc_purchase_buyer":
      return UsdcPurchaseBuyerNotificationToJSON(value);
    case "usdc_purchase_seller":
      return UsdcPurchaseSellerNotificationToJSON(value);
    default:
      throw new Error(`No variant of Notification exists with 'type=${value["type"]}'`);
  }
}
function instanceOfNotifications(value) {
  let isInstance = true;
  isInstance = isInstance && "unreadCount" in value && value["unreadCount"] !== void 0;
  return isInstance;
}
function NotificationsFromJSON(json) {
  return NotificationsFromJSONTyped(json);
}
function NotificationsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "notifications": !exists3(json, "notifications") ? void 0 : json["notifications"].map(NotificationFromJSON),
    "unreadCount": json["unread_count"]
  };
}
function NotificationsToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "notifications": value.notifications === void 0 ? void 0 : value.notifications.map(NotificationToJSON),
    "unread_count": value.unreadCount
  };
}
function instanceOfNotificationsResponse(value) {
  let isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value && value["latestChainBlock"] !== void 0;
  isInstance = isInstance && "latestIndexedBlock" in value && value["latestIndexedBlock"] !== void 0;
  isInstance = isInstance && "latestChainSlotPlays" in value && value["latestChainSlotPlays"] !== void 0;
  isInstance = isInstance && "latestIndexedSlotPlays" in value && value["latestIndexedSlotPlays"] !== void 0;
  isInstance = isInstance && "signature" in value && value["signature"] !== void 0;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== void 0;
  isInstance = isInstance && "version" in value && value["version"] !== void 0;
  return isInstance;
}
function NotificationsResponseFromJSON(json) {
  return NotificationsResponseFromJSONTyped(json);
}
function NotificationsResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "latestChainBlock": json["latest_chain_block"],
    "latestIndexedBlock": json["latest_indexed_block"],
    "latestChainSlotPlays": json["latest_chain_slot_plays"],
    "latestIndexedSlotPlays": json["latest_indexed_slot_plays"],
    "signature": json["signature"],
    "timestamp": json["timestamp"],
    "version": VersionMetadataFromJSON(json["version"]),
    "data": !exists3(json, "data") ? void 0 : NotificationsFromJSON(json["data"])
  };
}
function NotificationsResponseToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "latest_chain_block": value.latestChainBlock,
    "latest_indexed_block": value.latestIndexedBlock,
    "latest_chain_slot_plays": value.latestChainSlotPlays,
    "latest_indexed_slot_plays": value.latestIndexedSlotPlays,
    "signature": value.signature,
    "timestamp": value.timestamp,
    "version": VersionMetadataToJSON(value.version),
    "data": NotificationsToJSON(value.data)
  };
}
function instanceOfPlaylistFeedItem(value) {
  let isInstance = true;
  isInstance = isInstance && "type" in value && value["type"] !== void 0;
  isInstance = isInstance && "item" in value && value["item"] !== void 0;
  return isInstance;
}
function PlaylistFeedItemFromJSON(json) {
  return PlaylistFeedItemFromJSONTyped(json);
}
function PlaylistFeedItemFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "item": PlaylistFullFromJSON(json["item"])
  };
}
function PlaylistFeedItemToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "item": PlaylistFullToJSON(value.item)
  };
}
function instanceOfPlaylistUpdate(value) {
  let isInstance = true;
  isInstance = isInstance && "playlistId" in value && value["playlistId"] !== void 0;
  isInstance = isInstance && "updatedAt" in value && value["updatedAt"] !== void 0;
  return isInstance;
}
function PlaylistUpdateFromJSON(json) {
  return PlaylistUpdateFromJSONTyped(json);
}
function PlaylistUpdateFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "playlistId": json["playlist_id"],
    "updatedAt": json["updated_at"],
    "lastSeenAt": !exists3(json, "last_seen_at") ? void 0 : json["last_seen_at"]
  };
}
function PlaylistUpdateToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "playlist_id": value.playlistId,
    "updated_at": value.updatedAt,
    "last_seen_at": value.lastSeenAt
  };
}
function instanceOfPlaylistUpdates(value) {
  let isInstance = true;
  return isInstance;
}
function PlaylistUpdatesFromJSON(json) {
  return PlaylistUpdatesFromJSONTyped(json);
}
function PlaylistUpdatesFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "playlistUpdates": !exists3(json, "playlist_updates") ? void 0 : json["playlist_updates"].map(PlaylistUpdateFromJSON)
  };
}
function PlaylistUpdatesToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "playlist_updates": value.playlistUpdates === void 0 ? void 0 : value.playlistUpdates.map(PlaylistUpdateToJSON)
  };
}
function instanceOfPlaylistUpdatesResponse(value) {
  let isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value && value["latestChainBlock"] !== void 0;
  isInstance = isInstance && "latestIndexedBlock" in value && value["latestIndexedBlock"] !== void 0;
  isInstance = isInstance && "latestChainSlotPlays" in value && value["latestChainSlotPlays"] !== void 0;
  isInstance = isInstance && "latestIndexedSlotPlays" in value && value["latestIndexedSlotPlays"] !== void 0;
  isInstance = isInstance && "signature" in value && value["signature"] !== void 0;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== void 0;
  isInstance = isInstance && "version" in value && value["version"] !== void 0;
  return isInstance;
}
function PlaylistUpdatesResponseFromJSON(json) {
  return PlaylistUpdatesResponseFromJSONTyped(json);
}
function PlaylistUpdatesResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "latestChainBlock": json["latest_chain_block"],
    "latestIndexedBlock": json["latest_indexed_block"],
    "latestChainSlotPlays": json["latest_chain_slot_plays"],
    "latestIndexedSlotPlays": json["latest_indexed_slot_plays"],
    "signature": json["signature"],
    "timestamp": json["timestamp"],
    "version": VersionMetadataFromJSON(json["version"]),
    "data": !exists3(json, "data") ? void 0 : PlaylistUpdatesFromJSON(json["data"])
  };
}
function PlaylistUpdatesResponseToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "latest_chain_block": value.latestChainBlock,
    "latest_indexed_block": value.latestIndexedBlock,
    "latest_chain_slot_plays": value.latestChainSlotPlays,
    "latest_indexed_slot_plays": value.latestIndexedSlotPlays,
    "signature": value.signature,
    "timestamp": value.timestamp,
    "version": VersionMetadataToJSON(value.version),
    "data": PlaylistUpdatesToJSON(value.data)
  };
}
function instanceOfPlaylistsResponseFull(value) {
  let isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value && value["latestChainBlock"] !== void 0;
  isInstance = isInstance && "latestIndexedBlock" in value && value["latestIndexedBlock"] !== void 0;
  isInstance = isInstance && "latestChainSlotPlays" in value && value["latestChainSlotPlays"] !== void 0;
  isInstance = isInstance && "latestIndexedSlotPlays" in value && value["latestIndexedSlotPlays"] !== void 0;
  isInstance = isInstance && "signature" in value && value["signature"] !== void 0;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== void 0;
  isInstance = isInstance && "version" in value && value["version"] !== void 0;
  return isInstance;
}
function PlaylistsResponseFullFromJSON(json) {
  return PlaylistsResponseFullFromJSONTyped(json);
}
function PlaylistsResponseFullFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "latestChainBlock": json["latest_chain_block"],
    "latestIndexedBlock": json["latest_indexed_block"],
    "latestChainSlotPlays": json["latest_chain_slot_plays"],
    "latestIndexedSlotPlays": json["latest_indexed_slot_plays"],
    "signature": json["signature"],
    "timestamp": json["timestamp"],
    "version": VersionMetadataFromJSON(json["version"]),
    "data": !exists3(json, "data") ? void 0 : json["data"].map(PlaylistFullWithoutTracksFromJSON)
  };
}
function PlaylistsResponseFullToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "latest_chain_block": value.latestChainBlock,
    "latest_indexed_block": value.latestIndexedBlock,
    "latest_chain_slot_plays": value.latestChainSlotPlays,
    "latest_indexed_slot_plays": value.latestIndexedSlotPlays,
    "signature": value.signature,
    "timestamp": value.timestamp,
    "version": VersionMetadataToJSON(value.version),
    "data": value.data === void 0 ? void 0 : value.data.map(PlaylistFullWithoutTracksToJSON)
  };
}
function instanceOfPurchaseSplit(value) {
  let isInstance = true;
  isInstance = isInstance && "payoutWallet" in value && value["payoutWallet"] !== void 0;
  isInstance = isInstance && "amount" in value && value["amount"] !== void 0;
  return isInstance;
}
function PurchaseSplitFromJSON(json) {
  return PurchaseSplitFromJSONTyped(json);
}
function PurchaseSplitFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "userId": !exists3(json, "user_id") ? void 0 : json["user_id"],
    "payoutWallet": json["payout_wallet"],
    "amount": json["amount"]
  };
}
function PurchaseSplitToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "user_id": value.userId,
    "payout_wallet": value.payoutWallet,
    "amount": value.amount
  };
}
function instanceOfPurchase(value) {
  let isInstance = true;
  isInstance = isInstance && "slot" in value && value["slot"] !== void 0;
  isInstance = isInstance && "signature" in value && value["signature"] !== void 0;
  isInstance = isInstance && "sellerUserId" in value && value["sellerUserId"] !== void 0;
  isInstance = isInstance && "buyerUserId" in value && value["buyerUserId"] !== void 0;
  isInstance = isInstance && "amount" in value && value["amount"] !== void 0;
  isInstance = isInstance && "extraAmount" in value && value["extraAmount"] !== void 0;
  isInstance = isInstance && "contentType" in value && value["contentType"] !== void 0;
  isInstance = isInstance && "contentId" in value && value["contentId"] !== void 0;
  isInstance = isInstance && "createdAt" in value && value["createdAt"] !== void 0;
  isInstance = isInstance && "updatedAt" in value && value["updatedAt"] !== void 0;
  isInstance = isInstance && "access" in value && value["access"] !== void 0;
  isInstance = isInstance && "splits" in value && value["splits"] !== void 0;
  return isInstance;
}
function PurchaseFromJSON(json) {
  return PurchaseFromJSONTyped(json);
}
function PurchaseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "slot": json["slot"],
    "signature": json["signature"],
    "sellerUserId": json["seller_user_id"],
    "buyerUserId": json["buyer_user_id"],
    "amount": json["amount"],
    "extraAmount": json["extra_amount"],
    "contentType": json["content_type"],
    "contentId": json["content_id"],
    "createdAt": json["created_at"],
    "updatedAt": json["updated_at"],
    "access": json["access"],
    "splits": json["splits"].map(PurchaseSplitFromJSON)
  };
}
function PurchaseToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "slot": value.slot,
    "signature": value.signature,
    "seller_user_id": value.sellerUserId,
    "buyer_user_id": value.buyerUserId,
    "amount": value.amount,
    "extra_amount": value.extraAmount,
    "content_type": value.contentType,
    "content_id": value.contentId,
    "created_at": value.createdAt,
    "updated_at": value.updatedAt,
    "access": value.access,
    "splits": value.splits.map(PurchaseSplitToJSON)
  };
}
function instanceOfPurchasersCountResponse(value) {
  let isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value && value["latestChainBlock"] !== void 0;
  isInstance = isInstance && "latestIndexedBlock" in value && value["latestIndexedBlock"] !== void 0;
  isInstance = isInstance && "latestChainSlotPlays" in value && value["latestChainSlotPlays"] !== void 0;
  isInstance = isInstance && "latestIndexedSlotPlays" in value && value["latestIndexedSlotPlays"] !== void 0;
  isInstance = isInstance && "signature" in value && value["signature"] !== void 0;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== void 0;
  isInstance = isInstance && "version" in value && value["version"] !== void 0;
  return isInstance;
}
function PurchasersCountResponseFromJSON(json) {
  return PurchasersCountResponseFromJSONTyped(json);
}
function PurchasersCountResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "latestChainBlock": json["latest_chain_block"],
    "latestIndexedBlock": json["latest_indexed_block"],
    "latestChainSlotPlays": json["latest_chain_slot_plays"],
    "latestIndexedSlotPlays": json["latest_indexed_slot_plays"],
    "signature": json["signature"],
    "timestamp": json["timestamp"],
    "version": VersionMetadataFromJSON(json["version"]),
    "data": !exists3(json, "data") ? void 0 : json["data"]
  };
}
function PurchasersCountResponseToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "latest_chain_block": value.latestChainBlock,
    "latest_indexed_block": value.latestIndexedBlock,
    "latest_chain_slot_plays": value.latestChainSlotPlays,
    "latest_indexed_slot_plays": value.latestIndexedSlotPlays,
    "signature": value.signature,
    "timestamp": value.timestamp,
    "version": VersionMetadataToJSON(value.version),
    "data": value.data
  };
}
function instanceOfPurchasesCountResponse(value) {
  let isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value && value["latestChainBlock"] !== void 0;
  isInstance = isInstance && "latestIndexedBlock" in value && value["latestIndexedBlock"] !== void 0;
  isInstance = isInstance && "latestChainSlotPlays" in value && value["latestChainSlotPlays"] !== void 0;
  isInstance = isInstance && "latestIndexedSlotPlays" in value && value["latestIndexedSlotPlays"] !== void 0;
  isInstance = isInstance && "signature" in value && value["signature"] !== void 0;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== void 0;
  isInstance = isInstance && "version" in value && value["version"] !== void 0;
  return isInstance;
}
function PurchasesCountResponseFromJSON(json) {
  return PurchasesCountResponseFromJSONTyped(json);
}
function PurchasesCountResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "latestChainBlock": json["latest_chain_block"],
    "latestIndexedBlock": json["latest_indexed_block"],
    "latestChainSlotPlays": json["latest_chain_slot_plays"],
    "latestIndexedSlotPlays": json["latest_indexed_slot_plays"],
    "signature": json["signature"],
    "timestamp": json["timestamp"],
    "version": VersionMetadataFromJSON(json["version"]),
    "data": !exists3(json, "data") ? void 0 : json["data"]
  };
}
function PurchasesCountResponseToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "latest_chain_block": value.latestChainBlock,
    "latest_indexed_block": value.latestIndexedBlock,
    "latest_chain_slot_plays": value.latestChainSlotPlays,
    "latest_indexed_slot_plays": value.latestIndexedSlotPlays,
    "signature": value.signature,
    "timestamp": value.timestamp,
    "version": VersionMetadataToJSON(value.version),
    "data": value.data
  };
}
function instanceOfPurchasesResponse(value) {
  let isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value && value["latestChainBlock"] !== void 0;
  isInstance = isInstance && "latestIndexedBlock" in value && value["latestIndexedBlock"] !== void 0;
  isInstance = isInstance && "latestChainSlotPlays" in value && value["latestChainSlotPlays"] !== void 0;
  isInstance = isInstance && "latestIndexedSlotPlays" in value && value["latestIndexedSlotPlays"] !== void 0;
  isInstance = isInstance && "signature" in value && value["signature"] !== void 0;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== void 0;
  isInstance = isInstance && "version" in value && value["version"] !== void 0;
  return isInstance;
}
function PurchasesResponseFromJSON(json) {
  return PurchasesResponseFromJSONTyped(json);
}
function PurchasesResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "latestChainBlock": json["latest_chain_block"],
    "latestIndexedBlock": json["latest_indexed_block"],
    "latestChainSlotPlays": json["latest_chain_slot_plays"],
    "latestIndexedSlotPlays": json["latest_indexed_slot_plays"],
    "signature": json["signature"],
    "timestamp": json["timestamp"],
    "version": VersionMetadataFromJSON(json["version"]),
    "data": !exists3(json, "data") ? void 0 : json["data"].map(PurchaseFromJSON)
  };
}
function PurchasesResponseToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "latest_chain_block": value.latestChainBlock,
    "latest_indexed_block": value.latestIndexedBlock,
    "latest_chain_slot_plays": value.latestChainSlotPlays,
    "latest_indexed_slot_plays": value.latestIndexedSlotPlays,
    "signature": value.signature,
    "timestamp": value.timestamp,
    "version": VersionMetadataToJSON(value.version),
    "data": value.data === void 0 ? void 0 : value.data.map(PurchaseToJSON)
  };
}
function instanceOfReaction(value) {
  let isInstance = true;
  isInstance = isInstance && "reactionValue" in value && value["reactionValue"] !== void 0;
  isInstance = isInstance && "reactionType" in value && value["reactionType"] !== void 0;
  isInstance = isInstance && "senderUserId" in value && value["senderUserId"] !== void 0;
  isInstance = isInstance && "reactedTo" in value && value["reactedTo"] !== void 0;
  return isInstance;
}
function ReactionFromJSON(json) {
  return ReactionFromJSONTyped(json);
}
function ReactionFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "reactionValue": json["reaction_value"],
    "reactionType": json["reaction_type"],
    "senderUserId": json["sender_user_id"],
    "reactedTo": json["reacted_to"]
  };
}
function ReactionToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "reaction_value": value.reactionValue,
    "reaction_type": value.reactionType,
    "sender_user_id": value.senderUserId,
    "reacted_to": value.reactedTo
  };
}
function instanceOfReactions(value) {
  let isInstance = true;
  return isInstance;
}
function ReactionsFromJSON(json) {
  return ReactionsFromJSONTyped(json);
}
function ReactionsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "data": !exists3(json, "data") ? void 0 : json["data"].map(ReactionFromJSON)
  };
}
function ReactionsToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "data": value.data === void 0 ? void 0 : value.data.map(ReactionToJSON)
  };
}
function instanceOfRelatedArtistResponseFull(value) {
  let isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value && value["latestChainBlock"] !== void 0;
  isInstance = isInstance && "latestIndexedBlock" in value && value["latestIndexedBlock"] !== void 0;
  isInstance = isInstance && "latestChainSlotPlays" in value && value["latestChainSlotPlays"] !== void 0;
  isInstance = isInstance && "latestIndexedSlotPlays" in value && value["latestIndexedSlotPlays"] !== void 0;
  isInstance = isInstance && "signature" in value && value["signature"] !== void 0;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== void 0;
  isInstance = isInstance && "version" in value && value["version"] !== void 0;
  return isInstance;
}
function RelatedArtistResponseFullFromJSON(json) {
  return RelatedArtistResponseFullFromJSONTyped(json);
}
function RelatedArtistResponseFullFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "latestChainBlock": json["latest_chain_block"],
    "latestIndexedBlock": json["latest_indexed_block"],
    "latestChainSlotPlays": json["latest_chain_slot_plays"],
    "latestIndexedSlotPlays": json["latest_indexed_slot_plays"],
    "signature": json["signature"],
    "timestamp": json["timestamp"],
    "version": VersionMetadataFromJSON(json["version"]),
    "data": !exists3(json, "data") ? void 0 : json["data"].map(UserFullFromJSON)
  };
}
function RelatedArtistResponseFullToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "latest_chain_block": value.latestChainBlock,
    "latest_indexed_block": value.latestIndexedBlock,
    "latest_chain_slot_plays": value.latestChainSlotPlays,
    "latest_indexed_slot_plays": value.latestIndexedSlotPlays,
    "signature": value.signature,
    "timestamp": value.timestamp,
    "version": VersionMetadataToJSON(value.version),
    "data": value.data === void 0 ? void 0 : value.data.map(UserFullToJSON)
  };
}
function instanceOfRemixablesResponse(value) {
  let isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value && value["latestChainBlock"] !== void 0;
  isInstance = isInstance && "latestIndexedBlock" in value && value["latestIndexedBlock"] !== void 0;
  isInstance = isInstance && "latestChainSlotPlays" in value && value["latestChainSlotPlays"] !== void 0;
  isInstance = isInstance && "latestIndexedSlotPlays" in value && value["latestIndexedSlotPlays"] !== void 0;
  isInstance = isInstance && "signature" in value && value["signature"] !== void 0;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== void 0;
  isInstance = isInstance && "version" in value && value["version"] !== void 0;
  return isInstance;
}
function RemixablesResponseFromJSON(json) {
  return RemixablesResponseFromJSONTyped(json);
}
function RemixablesResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "latestChainBlock": json["latest_chain_block"],
    "latestIndexedBlock": json["latest_indexed_block"],
    "latestChainSlotPlays": json["latest_chain_slot_plays"],
    "latestIndexedSlotPlays": json["latest_indexed_slot_plays"],
    "signature": json["signature"],
    "timestamp": json["timestamp"],
    "version": VersionMetadataFromJSON(json["version"]),
    "data": !exists3(json, "data") ? void 0 : json["data"].map(TrackFullFromJSON)
  };
}
function RemixablesResponseToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "latest_chain_block": value.latestChainBlock,
    "latest_indexed_block": value.latestIndexedBlock,
    "latest_chain_slot_plays": value.latestChainSlotPlays,
    "latest_indexed_slot_plays": value.latestIndexedSlotPlays,
    "signature": value.signature,
    "timestamp": value.timestamp,
    "version": VersionMetadataToJSON(value.version),
    "data": value.data === void 0 ? void 0 : value.data.map(TrackFullToJSON)
  };
}
function instanceOfRemixersCountResponse(value) {
  let isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value && value["latestChainBlock"] !== void 0;
  isInstance = isInstance && "latestIndexedBlock" in value && value["latestIndexedBlock"] !== void 0;
  isInstance = isInstance && "latestChainSlotPlays" in value && value["latestChainSlotPlays"] !== void 0;
  isInstance = isInstance && "latestIndexedSlotPlays" in value && value["latestIndexedSlotPlays"] !== void 0;
  isInstance = isInstance && "signature" in value && value["signature"] !== void 0;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== void 0;
  isInstance = isInstance && "version" in value && value["version"] !== void 0;
  return isInstance;
}
function RemixersCountResponseFromJSON(json) {
  return RemixersCountResponseFromJSONTyped(json);
}
function RemixersCountResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "latestChainBlock": json["latest_chain_block"],
    "latestIndexedBlock": json["latest_indexed_block"],
    "latestChainSlotPlays": json["latest_chain_slot_plays"],
    "latestIndexedSlotPlays": json["latest_indexed_slot_plays"],
    "signature": json["signature"],
    "timestamp": json["timestamp"],
    "version": VersionMetadataFromJSON(json["version"]),
    "data": !exists3(json, "data") ? void 0 : json["data"]
  };
}
function RemixersCountResponseToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "latest_chain_block": value.latestChainBlock,
    "latest_indexed_block": value.latestIndexedBlock,
    "latest_chain_slot_plays": value.latestChainSlotPlays,
    "latest_indexed_slot_plays": value.latestIndexedSlotPlays,
    "signature": value.signature,
    "timestamp": value.timestamp,
    "version": VersionMetadataToJSON(value.version),
    "data": value.data
  };
}
function instanceOfRemixesResponse(value) {
  let isInstance = true;
  isInstance = isInstance && "count" in value && value["count"] !== void 0;
  return isInstance;
}
function RemixesResponseFromJSON(json) {
  return RemixesResponseFromJSONTyped(json);
}
function RemixesResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "count": json["count"],
    "tracks": !exists3(json, "tracks") ? void 0 : json["tracks"].map(TrackFullFromJSON)
  };
}
function RemixesResponseToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "count": value.count,
    "tracks": value.tracks === void 0 ? void 0 : value.tracks.map(TrackFullToJSON)
  };
}
function instanceOfRemixesResponseFull(value) {
  let isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value && value["latestChainBlock"] !== void 0;
  isInstance = isInstance && "latestIndexedBlock" in value && value["latestIndexedBlock"] !== void 0;
  isInstance = isInstance && "latestChainSlotPlays" in value && value["latestChainSlotPlays"] !== void 0;
  isInstance = isInstance && "latestIndexedSlotPlays" in value && value["latestIndexedSlotPlays"] !== void 0;
  isInstance = isInstance && "signature" in value && value["signature"] !== void 0;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== void 0;
  isInstance = isInstance && "version" in value && value["version"] !== void 0;
  return isInstance;
}
function RemixesResponseFullFromJSON(json) {
  return RemixesResponseFullFromJSONTyped(json);
}
function RemixesResponseFullFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "latestChainBlock": json["latest_chain_block"],
    "latestIndexedBlock": json["latest_indexed_block"],
    "latestChainSlotPlays": json["latest_chain_slot_plays"],
    "latestIndexedSlotPlays": json["latest_indexed_slot_plays"],
    "signature": json["signature"],
    "timestamp": json["timestamp"],
    "version": VersionMetadataFromJSON(json["version"]),
    "data": !exists3(json, "data") ? void 0 : RemixesResponseFromJSON(json["data"])
  };
}
function RemixesResponseFullToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "latest_chain_block": value.latestChainBlock,
    "latest_indexed_block": value.latestIndexedBlock,
    "latest_chain_slot_plays": value.latestChainSlotPlays,
    "latest_indexed_slot_plays": value.latestIndexedSlotPlays,
    "signature": value.signature,
    "timestamp": value.timestamp,
    "version": VersionMetadataToJSON(value.version),
    "data": RemixesResponseToJSON(value.data)
  };
}
function instanceOfRemixingResponse(value) {
  let isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value && value["latestChainBlock"] !== void 0;
  isInstance = isInstance && "latestIndexedBlock" in value && value["latestIndexedBlock"] !== void 0;
  isInstance = isInstance && "latestChainSlotPlays" in value && value["latestChainSlotPlays"] !== void 0;
  isInstance = isInstance && "latestIndexedSlotPlays" in value && value["latestIndexedSlotPlays"] !== void 0;
  isInstance = isInstance && "signature" in value && value["signature"] !== void 0;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== void 0;
  isInstance = isInstance && "version" in value && value["version"] !== void 0;
  return isInstance;
}
function RemixingResponseFromJSON(json) {
  return RemixingResponseFromJSONTyped(json);
}
function RemixingResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "latestChainBlock": json["latest_chain_block"],
    "latestIndexedBlock": json["latest_indexed_block"],
    "latestChainSlotPlays": json["latest_chain_slot_plays"],
    "latestIndexedSlotPlays": json["latest_indexed_slot_plays"],
    "signature": json["signature"],
    "timestamp": json["timestamp"],
    "version": VersionMetadataFromJSON(json["version"]),
    "data": !exists3(json, "data") ? void 0 : json["data"].map(TrackFullFromJSON)
  };
}
function RemixingResponseToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "latest_chain_block": value.latestChainBlock,
    "latest_indexed_block": value.latestIndexedBlock,
    "latest_chain_slot_plays": value.latestChainSlotPlays,
    "latest_indexed_slot_plays": value.latestIndexedSlotPlays,
    "signature": value.signature,
    "timestamp": value.timestamp,
    "version": VersionMetadataToJSON(value.version),
    "data": value.data === void 0 ? void 0 : value.data.map(TrackFullToJSON)
  };
}
function instanceOfSearchPlaylistFull(value) {
  let isInstance = true;
  isInstance = isInstance && "permalink" in value && value["permalink"] !== void 0;
  isInstance = isInstance && "id" in value && value["id"] !== void 0;
  isInstance = isInstance && "isAlbum" in value && value["isAlbum"] !== void 0;
  isInstance = isInstance && "isImageAutogenerated" in value && value["isImageAutogenerated"] !== void 0;
  isInstance = isInstance && "playlistName" in value && value["playlistName"] !== void 0;
  isInstance = isInstance && "playlistContents" in value && value["playlistContents"] !== void 0;
  isInstance = isInstance && "repostCount" in value && value["repostCount"] !== void 0;
  isInstance = isInstance && "favoriteCount" in value && value["favoriteCount"] !== void 0;
  isInstance = isInstance && "totalPlayCount" in value && value["totalPlayCount"] !== void 0;
  isInstance = isInstance && "user" in value && value["user"] !== void 0;
  isInstance = isInstance && "access" in value && value["access"] !== void 0;
  isInstance = isInstance && "trackCount" in value && value["trackCount"] !== void 0;
  isInstance = isInstance && "blocknumber" in value && value["blocknumber"] !== void 0;
  isInstance = isInstance && "createdAt" in value && value["createdAt"] !== void 0;
  isInstance = isInstance && "hasCurrentUserReposted" in value && value["hasCurrentUserReposted"] !== void 0;
  isInstance = isInstance && "hasCurrentUserSaved" in value && value["hasCurrentUserSaved"] !== void 0;
  isInstance = isInstance && "isDelete" in value && value["isDelete"] !== void 0;
  isInstance = isInstance && "isPrivate" in value && value["isPrivate"] !== void 0;
  isInstance = isInstance && "updatedAt" in value && value["updatedAt"] !== void 0;
  isInstance = isInstance && "addedTimestamps" in value && value["addedTimestamps"] !== void 0;
  isInstance = isInstance && "userId" in value && value["userId"] !== void 0;
  isInstance = isInstance && "isStreamGated" in value && value["isStreamGated"] !== void 0;
  isInstance = isInstance && "isScheduledRelease" in value && value["isScheduledRelease"] !== void 0;
  return isInstance;
}
function SearchPlaylistFullFromJSON(json) {
  return SearchPlaylistFullFromJSONTyped(json);
}
function SearchPlaylistFullFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "artwork": !exists3(json, "artwork") ? void 0 : PlaylistArtworkFullFromJSON(json["artwork"]),
    "description": !exists3(json, "description") ? void 0 : json["description"],
    "permalink": json["permalink"],
    "id": json["id"],
    "isAlbum": json["is_album"],
    "isImageAutogenerated": json["is_image_autogenerated"],
    "playlistName": json["playlist_name"],
    "playlistContents": json["playlist_contents"].map(PlaylistAddedTimestampFromJSON),
    "repostCount": json["repost_count"],
    "favoriteCount": json["favorite_count"],
    "totalPlayCount": json["total_play_count"],
    "user": UserFullFromJSON(json["user"]),
    "ddexApp": !exists3(json, "ddex_app") ? void 0 : json["ddex_app"],
    "access": AccessFromJSON(json["access"]),
    "upc": !exists3(json, "upc") ? void 0 : json["upc"],
    "trackCount": json["track_count"],
    "blocknumber": json["blocknumber"],
    "createdAt": json["created_at"],
    "followeeReposts": !exists3(json, "followee_reposts") ? void 0 : json["followee_reposts"].map(RepostFromJSON),
    "followeeFavorites": !exists3(json, "followee_favorites") ? void 0 : json["followee_favorites"].map(FavoriteFromJSON),
    "hasCurrentUserReposted": json["has_current_user_reposted"],
    "hasCurrentUserSaved": json["has_current_user_saved"],
    "isDelete": json["is_delete"],
    "isPrivate": json["is_private"],
    "updatedAt": json["updated_at"],
    "addedTimestamps": json["added_timestamps"].map(PlaylistAddedTimestampFromJSON),
    "userId": json["user_id"],
    "tracks": !exists3(json, "tracks") ? void 0 : json["tracks"].map(TrackFullFromJSON),
    "coverArt": !exists3(json, "cover_art") ? void 0 : json["cover_art"],
    "coverArtSizes": !exists3(json, "cover_art_sizes") ? void 0 : json["cover_art_sizes"],
    "coverArtCids": !exists3(json, "cover_art_cids") ? void 0 : PlaylistArtworkFromJSON(json["cover_art_cids"]),
    "isStreamGated": json["is_stream_gated"],
    "streamConditions": !exists3(json, "stream_conditions") ? void 0 : AccessGateFromJSON(json["stream_conditions"]),
    "isScheduledRelease": json["is_scheduled_release"],
    "releaseDate": !exists3(json, "release_date") ? void 0 : json["release_date"],
    "ddexReleaseIds": !exists3(json, "ddex_release_ids") ? void 0 : json["ddex_release_ids"],
    "artists": !exists3(json, "artists") ? void 0 : json["artists"],
    "copyrightLine": !exists3(json, "copyright_line") ? void 0 : json["copyright_line"],
    "producerCopyrightLine": !exists3(json, "producer_copyright_line") ? void 0 : json["producer_copyright_line"],
    "parentalWarningType": !exists3(json, "parental_warning_type") ? void 0 : json["parental_warning_type"]
  };
}
function SearchPlaylistFullToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "artwork": PlaylistArtworkFullToJSON(value.artwork),
    "description": value.description,
    "permalink": value.permalink,
    "id": value.id,
    "is_album": value.isAlbum,
    "is_image_autogenerated": value.isImageAutogenerated,
    "playlist_name": value.playlistName,
    "playlist_contents": value.playlistContents.map(PlaylistAddedTimestampToJSON),
    "repost_count": value.repostCount,
    "favorite_count": value.favoriteCount,
    "total_play_count": value.totalPlayCount,
    "user": UserFullToJSON(value.user),
    "ddex_app": value.ddexApp,
    "access": AccessToJSON(value.access),
    "upc": value.upc,
    "track_count": value.trackCount,
    "blocknumber": value.blocknumber,
    "created_at": value.createdAt,
    "followee_reposts": value.followeeReposts === void 0 ? void 0 : value.followeeReposts.map(RepostToJSON),
    "followee_favorites": value.followeeFavorites === void 0 ? void 0 : value.followeeFavorites.map(FavoriteToJSON),
    "has_current_user_reposted": value.hasCurrentUserReposted,
    "has_current_user_saved": value.hasCurrentUserSaved,
    "is_delete": value.isDelete,
    "is_private": value.isPrivate,
    "updated_at": value.updatedAt,
    "added_timestamps": value.addedTimestamps.map(PlaylistAddedTimestampToJSON),
    "user_id": value.userId,
    "tracks": value.tracks === void 0 ? void 0 : value.tracks.map(TrackFullToJSON),
    "cover_art": value.coverArt,
    "cover_art_sizes": value.coverArtSizes,
    "cover_art_cids": PlaylistArtworkToJSON(value.coverArtCids),
    "is_stream_gated": value.isStreamGated,
    "stream_conditions": AccessGateToJSON(value.streamConditions),
    "is_scheduled_release": value.isScheduledRelease,
    "release_date": value.releaseDate,
    "ddex_release_ids": value.ddexReleaseIds,
    "artists": value.artists,
    "copyright_line": value.copyrightLine,
    "producer_copyright_line": value.producerCopyrightLine,
    "parental_warning_type": value.parentalWarningType
  };
}
function instanceOfSearchTrackFull(value) {
  let isInstance = true;
  isInstance = isInstance && "artwork" in value && value["artwork"] !== void 0;
  isInstance = isInstance && "genre" in value && value["genre"] !== void 0;
  isInstance = isInstance && "id" in value && value["id"] !== void 0;
  isInstance = isInstance && "isOriginalAvailable" in value && value["isOriginalAvailable"] !== void 0;
  isInstance = isInstance && "remixOf" in value && value["remixOf"] !== void 0;
  isInstance = isInstance && "repostCount" in value && value["repostCount"] !== void 0;
  isInstance = isInstance && "favoriteCount" in value && value["favoriteCount"] !== void 0;
  isInstance = isInstance && "commentCount" in value && value["commentCount"] !== void 0;
  isInstance = isInstance && "title" in value && value["title"] !== void 0;
  isInstance = isInstance && "user" in value && value["user"] !== void 0;
  isInstance = isInstance && "duration" in value && value["duration"] !== void 0;
  isInstance = isInstance && "isDownloadable" in value && value["isDownloadable"] !== void 0;
  isInstance = isInstance && "playCount" in value && value["playCount"] !== void 0;
  isInstance = isInstance && "permalink" in value && value["permalink"] !== void 0;
  isInstance = isInstance && "access" in value && value["access"] !== void 0;
  isInstance = isInstance && "blocknumber" in value && value["blocknumber"] !== void 0;
  isInstance = isInstance && "coverArtSizes" in value && value["coverArtSizes"] !== void 0;
  isInstance = isInstance && "createdAt" in value && value["createdAt"] !== void 0;
  isInstance = isInstance && "fieldVisibility" in value && value["fieldVisibility"] !== void 0;
  isInstance = isInstance && "hasCurrentUserReposted" in value && value["hasCurrentUserReposted"] !== void 0;
  isInstance = isInstance && "isScheduledRelease" in value && value["isScheduledRelease"] !== void 0;
  isInstance = isInstance && "isUnlisted" in value && value["isUnlisted"] !== void 0;
  isInstance = isInstance && "hasCurrentUserSaved" in value && value["hasCurrentUserSaved"] !== void 0;
  isInstance = isInstance && "routeId" in value && value["routeId"] !== void 0;
  isInstance = isInstance && "trackSegments" in value && value["trackSegments"] !== void 0;
  isInstance = isInstance && "updatedAt" in value && value["updatedAt"] !== void 0;
  isInstance = isInstance && "userId" in value && value["userId"] !== void 0;
  isInstance = isInstance && "isDelete" in value && value["isDelete"] !== void 0;
  isInstance = isInstance && "isAvailable" in value && value["isAvailable"] !== void 0;
  isInstance = isInstance && "isStreamGated" in value && value["isStreamGated"] !== void 0;
  isInstance = isInstance && "isDownloadGated" in value && value["isDownloadGated"] !== void 0;
  isInstance = isInstance && "isOwnedByUser" in value && value["isOwnedByUser"] !== void 0;
  isInstance = isInstance && "stream" in value && value["stream"] !== void 0;
  isInstance = isInstance && "download" in value && value["download"] !== void 0;
  isInstance = isInstance && "preview" in value && value["preview"] !== void 0;
  return isInstance;
}
function SearchTrackFullFromJSON(json) {
  return SearchTrackFullFromJSONTyped(json);
}
function SearchTrackFullFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "artwork": TrackArtworkFullFromJSON(json["artwork"]),
    "description": !exists3(json, "description") ? void 0 : json["description"],
    "genre": json["genre"],
    "id": json["id"],
    "trackCid": !exists3(json, "track_cid") ? void 0 : json["track_cid"],
    "previewCid": !exists3(json, "preview_cid") ? void 0 : json["preview_cid"],
    "origFileCid": !exists3(json, "orig_file_cid") ? void 0 : json["orig_file_cid"],
    "origFilename": !exists3(json, "orig_filename") ? void 0 : json["orig_filename"],
    "isOriginalAvailable": json["is_original_available"],
    "mood": !exists3(json, "mood") ? void 0 : json["mood"],
    "releaseDate": !exists3(json, "release_date") ? void 0 : json["release_date"],
    "remixOf": FullRemixParentFromJSON(json["remix_of"]),
    "repostCount": json["repost_count"],
    "favoriteCount": json["favorite_count"],
    "commentCount": json["comment_count"],
    "tags": !exists3(json, "tags") ? void 0 : json["tags"],
    "title": json["title"],
    "user": UserFullFromJSON(json["user"]),
    "duration": json["duration"],
    "isDownloadable": json["is_downloadable"],
    "playCount": json["play_count"],
    "permalink": json["permalink"],
    "isStreamable": !exists3(json, "is_streamable") ? void 0 : json["is_streamable"],
    "ddexApp": !exists3(json, "ddex_app") ? void 0 : json["ddex_app"],
    "playlistsContainingTrack": !exists3(json, "playlists_containing_track") ? void 0 : json["playlists_containing_track"],
    "pinnedCommentId": !exists3(json, "pinned_comment_id") ? void 0 : json["pinned_comment_id"],
    "albumBacklink": !exists3(json, "album_backlink") ? void 0 : AlbumBacklinkFromJSON(json["album_backlink"]),
    "access": AccessFromJSON(json["access"]),
    "blocknumber": json["blocknumber"],
    "createDate": !exists3(json, "create_date") ? void 0 : json["create_date"],
    "coverArtSizes": json["cover_art_sizes"],
    "coverArtCids": !exists3(json, "cover_art_cids") ? void 0 : CoverArtFromJSON(json["cover_art_cids"]),
    "createdAt": json["created_at"],
    "creditsSplits": !exists3(json, "credits_splits") ? void 0 : json["credits_splits"],
    "isrc": !exists3(json, "isrc") ? void 0 : json["isrc"],
    "license": !exists3(json, "license") ? void 0 : json["license"],
    "iswc": !exists3(json, "iswc") ? void 0 : json["iswc"],
    "fieldVisibility": FieldVisibilityFromJSON(json["field_visibility"]),
    "followeeReposts": !exists3(json, "followee_reposts") ? void 0 : json["followee_reposts"].map(RepostFromJSON),
    "hasCurrentUserReposted": json["has_current_user_reposted"],
    "isScheduledRelease": json["is_scheduled_release"],
    "isUnlisted": json["is_unlisted"],
    "hasCurrentUserSaved": json["has_current_user_saved"],
    "followeeFavorites": !exists3(json, "followee_favorites") ? void 0 : json["followee_favorites"].map(FavoriteFromJSON),
    "routeId": json["route_id"],
    "stemOf": !exists3(json, "stem_of") ? void 0 : StemParentFromJSON(json["stem_of"]),
    "trackSegments": json["track_segments"].map(TrackSegmentFromJSON),
    "updatedAt": json["updated_at"],
    "userId": json["user_id"],
    "isDelete": json["is_delete"],
    "coverArt": !exists3(json, "cover_art") ? void 0 : json["cover_art"],
    "isAvailable": json["is_available"],
    "aiAttributionUserId": !exists3(json, "ai_attribution_user_id") ? void 0 : json["ai_attribution_user_id"],
    "allowedApiKeys": !exists3(json, "allowed_api_keys") ? void 0 : json["allowed_api_keys"],
    "audioUploadId": !exists3(json, "audio_upload_id") ? void 0 : json["audio_upload_id"],
    "previewStartSeconds": !exists3(json, "preview_start_seconds") ? void 0 : json["preview_start_seconds"],
    "bpm": !exists3(json, "bpm") ? void 0 : json["bpm"],
    "isCustomBpm": !exists3(json, "is_custom_bpm") ? void 0 : json["is_custom_bpm"],
    "musicalKey": !exists3(json, "musical_key") ? void 0 : json["musical_key"],
    "isCustomMusicalKey": !exists3(json, "is_custom_musical_key") ? void 0 : json["is_custom_musical_key"],
    "audioAnalysisErrorCount": !exists3(json, "audio_analysis_error_count") ? void 0 : json["audio_analysis_error_count"],
    "commentsDisabled": !exists3(json, "comments_disabled") ? void 0 : json["comments_disabled"],
    "ddexReleaseIds": !exists3(json, "ddex_release_ids") ? void 0 : json["ddex_release_ids"],
    "artists": !exists3(json, "artists") ? void 0 : json["artists"],
    "resourceContributors": !exists3(json, "resource_contributors") ? void 0 : json["resource_contributors"],
    "indirectResourceContributors": !exists3(json, "indirect_resource_contributors") ? void 0 : json["indirect_resource_contributors"],
    "rightsController": !exists3(json, "rights_controller") ? void 0 : json["rights_controller"],
    "copyrightLine": !exists3(json, "copyright_line") ? void 0 : json["copyright_line"],
    "producerCopyrightLine": !exists3(json, "producer_copyright_line") ? void 0 : json["producer_copyright_line"],
    "parentalWarningType": !exists3(json, "parental_warning_type") ? void 0 : json["parental_warning_type"],
    "isStreamGated": json["is_stream_gated"],
    "streamConditions": !exists3(json, "stream_conditions") ? void 0 : AccessGateFromJSON(json["stream_conditions"]),
    "isDownloadGated": json["is_download_gated"],
    "downloadConditions": !exists3(json, "download_conditions") ? void 0 : AccessGateFromJSON(json["download_conditions"]),
    "coverOriginalSongTitle": !exists3(json, "cover_original_song_title") ? void 0 : json["cover_original_song_title"],
    "coverOriginalArtist": !exists3(json, "cover_original_artist") ? void 0 : json["cover_original_artist"],
    "isOwnedByUser": json["is_owned_by_user"],
    "stream": UrlWithMirrorsFromJSON(json["stream"]),
    "download": UrlWithMirrorsFromJSON(json["download"]),
    "preview": UrlWithMirrorsFromJSON(json["preview"])
  };
}
function SearchTrackFullToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "artwork": TrackArtworkFullToJSON(value.artwork),
    "description": value.description,
    "genre": value.genre,
    "id": value.id,
    "track_cid": value.trackCid,
    "preview_cid": value.previewCid,
    "orig_file_cid": value.origFileCid,
    "orig_filename": value.origFilename,
    "is_original_available": value.isOriginalAvailable,
    "mood": value.mood,
    "release_date": value.releaseDate,
    "remix_of": FullRemixParentToJSON(value.remixOf),
    "repost_count": value.repostCount,
    "favorite_count": value.favoriteCount,
    "comment_count": value.commentCount,
    "tags": value.tags,
    "title": value.title,
    "user": UserFullToJSON(value.user),
    "duration": value.duration,
    "is_downloadable": value.isDownloadable,
    "play_count": value.playCount,
    "permalink": value.permalink,
    "is_streamable": value.isStreamable,
    "ddex_app": value.ddexApp,
    "playlists_containing_track": value.playlistsContainingTrack,
    "pinned_comment_id": value.pinnedCommentId,
    "album_backlink": AlbumBacklinkToJSON(value.albumBacklink),
    "access": AccessToJSON(value.access),
    "blocknumber": value.blocknumber,
    "create_date": value.createDate,
    "cover_art_sizes": value.coverArtSizes,
    "cover_art_cids": CoverArtToJSON(value.coverArtCids),
    "created_at": value.createdAt,
    "credits_splits": value.creditsSplits,
    "isrc": value.isrc,
    "license": value.license,
    "iswc": value.iswc,
    "field_visibility": FieldVisibilityToJSON(value.fieldVisibility),
    "followee_reposts": value.followeeReposts === void 0 ? void 0 : value.followeeReposts.map(RepostToJSON),
    "has_current_user_reposted": value.hasCurrentUserReposted,
    "is_scheduled_release": value.isScheduledRelease,
    "is_unlisted": value.isUnlisted,
    "has_current_user_saved": value.hasCurrentUserSaved,
    "followee_favorites": value.followeeFavorites === void 0 ? void 0 : value.followeeFavorites.map(FavoriteToJSON),
    "route_id": value.routeId,
    "stem_of": StemParentToJSON(value.stemOf),
    "track_segments": value.trackSegments.map(TrackSegmentToJSON),
    "updated_at": value.updatedAt,
    "user_id": value.userId,
    "is_delete": value.isDelete,
    "cover_art": value.coverArt,
    "is_available": value.isAvailable,
    "ai_attribution_user_id": value.aiAttributionUserId,
    "allowed_api_keys": value.allowedApiKeys,
    "audio_upload_id": value.audioUploadId,
    "preview_start_seconds": value.previewStartSeconds,
    "bpm": value.bpm,
    "is_custom_bpm": value.isCustomBpm,
    "musical_key": value.musicalKey,
    "is_custom_musical_key": value.isCustomMusicalKey,
    "audio_analysis_error_count": value.audioAnalysisErrorCount,
    "comments_disabled": value.commentsDisabled,
    "ddex_release_ids": value.ddexReleaseIds,
    "artists": value.artists,
    "resource_contributors": value.resourceContributors,
    "indirect_resource_contributors": value.indirectResourceContributors,
    "rights_controller": value.rightsController,
    "copyright_line": value.copyrightLine,
    "producer_copyright_line": value.producerCopyrightLine,
    "parental_warning_type": value.parentalWarningType,
    "is_stream_gated": value.isStreamGated,
    "stream_conditions": AccessGateToJSON(value.streamConditions),
    "is_download_gated": value.isDownloadGated,
    "download_conditions": AccessGateToJSON(value.downloadConditions),
    "cover_original_song_title": value.coverOriginalSongTitle,
    "cover_original_artist": value.coverOriginalArtist,
    "is_owned_by_user": value.isOwnedByUser,
    "stream": UrlWithMirrorsToJSON(value.stream),
    "download": UrlWithMirrorsToJSON(value.download),
    "preview": UrlWithMirrorsToJSON(value.preview)
  };
}
function instanceOfSearchModel(value) {
  let isInstance = true;
  isInstance = isInstance && "users" in value && value["users"] !== void 0;
  isInstance = isInstance && "tracks" in value && value["tracks"] !== void 0;
  isInstance = isInstance && "playlists" in value && value["playlists"] !== void 0;
  isInstance = isInstance && "albums" in value && value["albums"] !== void 0;
  return isInstance;
}
function SearchModelFromJSON(json) {
  return SearchModelFromJSONTyped(json);
}
function SearchModelFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "users": json["users"].map(UserFullFromJSON),
    "followedUsers": !exists3(json, "followed_users") ? void 0 : json["followed_users"].map(UserFullFromJSON),
    "tracks": json["tracks"].map(SearchTrackFullFromJSON),
    "savedTracks": !exists3(json, "saved_tracks") ? void 0 : json["saved_tracks"].map(SearchTrackFullFromJSON),
    "playlists": json["playlists"].map(SearchPlaylistFullFromJSON),
    "savedPlaylists": !exists3(json, "saved_playlists") ? void 0 : json["saved_playlists"].map(SearchPlaylistFullFromJSON),
    "albums": json["albums"].map(SearchPlaylistFullFromJSON),
    "savedAlbums": !exists3(json, "saved_albums") ? void 0 : json["saved_albums"].map(SearchPlaylistFullFromJSON)
  };
}
function SearchModelToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "users": value.users.map(UserFullToJSON),
    "followed_users": value.followedUsers === void 0 ? void 0 : value.followedUsers.map(UserFullToJSON),
    "tracks": value.tracks.map(SearchTrackFullToJSON),
    "saved_tracks": value.savedTracks === void 0 ? void 0 : value.savedTracks.map(SearchTrackFullToJSON),
    "playlists": value.playlists.map(SearchPlaylistFullToJSON),
    "saved_playlists": value.savedPlaylists === void 0 ? void 0 : value.savedPlaylists.map(SearchPlaylistFullToJSON),
    "albums": value.albums.map(SearchPlaylistFullToJSON),
    "saved_albums": value.savedAlbums === void 0 ? void 0 : value.savedAlbums.map(SearchPlaylistFullToJSON)
  };
}
function instanceOfSearchAutocompleteResponse(value) {
  let isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value && value["latestChainBlock"] !== void 0;
  isInstance = isInstance && "latestIndexedBlock" in value && value["latestIndexedBlock"] !== void 0;
  isInstance = isInstance && "latestChainSlotPlays" in value && value["latestChainSlotPlays"] !== void 0;
  isInstance = isInstance && "latestIndexedSlotPlays" in value && value["latestIndexedSlotPlays"] !== void 0;
  isInstance = isInstance && "signature" in value && value["signature"] !== void 0;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== void 0;
  isInstance = isInstance && "version" in value && value["version"] !== void 0;
  return isInstance;
}
function SearchAutocompleteResponseFromJSON(json) {
  return SearchAutocompleteResponseFromJSONTyped(json);
}
function SearchAutocompleteResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "latestChainBlock": json["latest_chain_block"],
    "latestIndexedBlock": json["latest_indexed_block"],
    "latestChainSlotPlays": json["latest_chain_slot_plays"],
    "latestIndexedSlotPlays": json["latest_indexed_slot_plays"],
    "signature": json["signature"],
    "timestamp": json["timestamp"],
    "version": VersionMetadataFromJSON(json["version"]),
    "data": !exists3(json, "data") ? void 0 : SearchModelFromJSON(json["data"])
  };
}
function SearchAutocompleteResponseToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "latest_chain_block": value.latestChainBlock,
    "latest_indexed_block": value.latestIndexedBlock,
    "latest_chain_slot_plays": value.latestChainSlotPlays,
    "latest_indexed_slot_plays": value.latestIndexedSlotPlays,
    "signature": value.signature,
    "timestamp": value.timestamp,
    "version": VersionMetadataToJSON(value.version),
    "data": SearchModelToJSON(value.data)
  };
}
function instanceOfSearchFullResponse(value) {
  let isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value && value["latestChainBlock"] !== void 0;
  isInstance = isInstance && "latestIndexedBlock" in value && value["latestIndexedBlock"] !== void 0;
  isInstance = isInstance && "latestChainSlotPlays" in value && value["latestChainSlotPlays"] !== void 0;
  isInstance = isInstance && "latestIndexedSlotPlays" in value && value["latestIndexedSlotPlays"] !== void 0;
  isInstance = isInstance && "signature" in value && value["signature"] !== void 0;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== void 0;
  isInstance = isInstance && "version" in value && value["version"] !== void 0;
  return isInstance;
}
function SearchFullResponseFromJSON(json) {
  return SearchFullResponseFromJSONTyped(json);
}
function SearchFullResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "latestChainBlock": json["latest_chain_block"],
    "latestIndexedBlock": json["latest_indexed_block"],
    "latestChainSlotPlays": json["latest_chain_slot_plays"],
    "latestIndexedSlotPlays": json["latest_indexed_slot_plays"],
    "signature": json["signature"],
    "timestamp": json["timestamp"],
    "version": VersionMetadataFromJSON(json["version"]),
    "data": !exists3(json, "data") ? void 0 : SearchModelFromJSON(json["data"])
  };
}
function SearchFullResponseToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "latest_chain_block": value.latestChainBlock,
    "latest_indexed_block": value.latestIndexedBlock,
    "latest_chain_slot_plays": value.latestChainSlotPlays,
    "latest_indexed_slot_plays": value.latestIndexedSlotPlays,
    "signature": value.signature,
    "timestamp": value.timestamp,
    "version": VersionMetadataToJSON(value.version),
    "data": SearchModelToJSON(value.data)
  };
}
function instanceOfStemFull(value) {
  let isInstance = true;
  isInstance = isInstance && "id" in value && value["id"] !== void 0;
  isInstance = isInstance && "parentId" in value && value["parentId"] !== void 0;
  isInstance = isInstance && "category" in value && value["category"] !== void 0;
  isInstance = isInstance && "cid" in value && value["cid"] !== void 0;
  isInstance = isInstance && "userId" in value && value["userId"] !== void 0;
  isInstance = isInstance && "blocknumber" in value && value["blocknumber"] !== void 0;
  isInstance = isInstance && "origFilename" in value && value["origFilename"] !== void 0;
  return isInstance;
}
function StemFullFromJSON(json) {
  return StemFullFromJSONTyped(json);
}
function StemFullFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "id": json["id"],
    "parentId": json["parent_id"],
    "category": json["category"],
    "cid": json["cid"],
    "userId": json["user_id"],
    "blocknumber": json["blocknumber"],
    "origFilename": json["orig_filename"]
  };
}
function StemFullToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "id": value.id,
    "parent_id": value.parentId,
    "category": value.category,
    "cid": value.cid,
    "user_id": value.userId,
    "blocknumber": value.blocknumber,
    "orig_filename": value.origFilename
  };
}
function instanceOfStemsResponse(value) {
  let isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value && value["latestChainBlock"] !== void 0;
  isInstance = isInstance && "latestIndexedBlock" in value && value["latestIndexedBlock"] !== void 0;
  isInstance = isInstance && "latestChainSlotPlays" in value && value["latestChainSlotPlays"] !== void 0;
  isInstance = isInstance && "latestIndexedSlotPlays" in value && value["latestIndexedSlotPlays"] !== void 0;
  isInstance = isInstance && "signature" in value && value["signature"] !== void 0;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== void 0;
  isInstance = isInstance && "version" in value && value["version"] !== void 0;
  return isInstance;
}
function StemsResponseFromJSON(json) {
  return StemsResponseFromJSONTyped(json);
}
function StemsResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "latestChainBlock": json["latest_chain_block"],
    "latestIndexedBlock": json["latest_indexed_block"],
    "latestChainSlotPlays": json["latest_chain_slot_plays"],
    "latestIndexedSlotPlays": json["latest_indexed_slot_plays"],
    "signature": json["signature"],
    "timestamp": json["timestamp"],
    "version": VersionMetadataFromJSON(json["version"]),
    "data": !exists3(json, "data") ? void 0 : json["data"].map(StemFullFromJSON)
  };
}
function StemsResponseToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "latest_chain_block": value.latestChainBlock,
    "latest_indexed_block": value.latestIndexedBlock,
    "latest_chain_slot_plays": value.latestChainSlotPlays,
    "latest_indexed_slot_plays": value.latestIndexedSlotPlays,
    "signature": value.signature,
    "timestamp": value.timestamp,
    "version": VersionMetadataToJSON(value.version),
    "data": value.data === void 0 ? void 0 : value.data.map(StemFullToJSON)
  };
}
function instanceOfTopGenreUsersResponseFull(value) {
  let isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value && value["latestChainBlock"] !== void 0;
  isInstance = isInstance && "latestIndexedBlock" in value && value["latestIndexedBlock"] !== void 0;
  isInstance = isInstance && "latestChainSlotPlays" in value && value["latestChainSlotPlays"] !== void 0;
  isInstance = isInstance && "latestIndexedSlotPlays" in value && value["latestIndexedSlotPlays"] !== void 0;
  isInstance = isInstance && "signature" in value && value["signature"] !== void 0;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== void 0;
  isInstance = isInstance && "version" in value && value["version"] !== void 0;
  return isInstance;
}
function TopGenreUsersResponseFullFromJSON(json) {
  return TopGenreUsersResponseFullFromJSONTyped(json);
}
function TopGenreUsersResponseFullFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "latestChainBlock": json["latest_chain_block"],
    "latestIndexedBlock": json["latest_indexed_block"],
    "latestChainSlotPlays": json["latest_chain_slot_plays"],
    "latestIndexedSlotPlays": json["latest_indexed_slot_plays"],
    "signature": json["signature"],
    "timestamp": json["timestamp"],
    "version": VersionMetadataFromJSON(json["version"]),
    "data": !exists3(json, "data") ? void 0 : json["data"].map(UserFullFromJSON)
  };
}
function TopGenreUsersResponseFullToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "latest_chain_block": value.latestChainBlock,
    "latest_indexed_block": value.latestIndexedBlock,
    "latest_chain_slot_plays": value.latestChainSlotPlays,
    "latest_indexed_slot_plays": value.latestIndexedSlotPlays,
    "signature": value.signature,
    "timestamp": value.timestamp,
    "version": VersionMetadataToJSON(value.version),
    "data": value.data === void 0 ? void 0 : value.data.map(UserFullToJSON)
  };
}
function instanceOfTopUsersResponseFull(value) {
  let isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value && value["latestChainBlock"] !== void 0;
  isInstance = isInstance && "latestIndexedBlock" in value && value["latestIndexedBlock"] !== void 0;
  isInstance = isInstance && "latestChainSlotPlays" in value && value["latestChainSlotPlays"] !== void 0;
  isInstance = isInstance && "latestIndexedSlotPlays" in value && value["latestIndexedSlotPlays"] !== void 0;
  isInstance = isInstance && "signature" in value && value["signature"] !== void 0;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== void 0;
  isInstance = isInstance && "version" in value && value["version"] !== void 0;
  return isInstance;
}
function TopUsersResponseFullFromJSON(json) {
  return TopUsersResponseFullFromJSONTyped(json);
}
function TopUsersResponseFullFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "latestChainBlock": json["latest_chain_block"],
    "latestIndexedBlock": json["latest_indexed_block"],
    "latestChainSlotPlays": json["latest_chain_slot_plays"],
    "latestIndexedSlotPlays": json["latest_indexed_slot_plays"],
    "signature": json["signature"],
    "timestamp": json["timestamp"],
    "version": VersionMetadataFromJSON(json["version"]),
    "data": !exists3(json, "data") ? void 0 : json["data"].map(UserFullFromJSON)
  };
}
function TopUsersResponseFullToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "latest_chain_block": value.latestChainBlock,
    "latest_indexed_block": value.latestIndexedBlock,
    "latest_chain_slot_plays": value.latestChainSlotPlays,
    "latest_indexed_slot_plays": value.latestIndexedSlotPlays,
    "signature": value.signature,
    "timestamp": value.timestamp,
    "version": VersionMetadataToJSON(value.version),
    "data": value.data === void 0 ? void 0 : value.data.map(UserFullToJSON)
  };
}
function instanceOfTrackCommentsResponseFull(value) {
  let isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value && value["latestChainBlock"] !== void 0;
  isInstance = isInstance && "latestIndexedBlock" in value && value["latestIndexedBlock"] !== void 0;
  isInstance = isInstance && "latestChainSlotPlays" in value && value["latestChainSlotPlays"] !== void 0;
  isInstance = isInstance && "latestIndexedSlotPlays" in value && value["latestIndexedSlotPlays"] !== void 0;
  isInstance = isInstance && "signature" in value && value["signature"] !== void 0;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== void 0;
  isInstance = isInstance && "version" in value && value["version"] !== void 0;
  return isInstance;
}
function TrackCommentsResponseFullFromJSON(json) {
  return TrackCommentsResponseFullFromJSONTyped(json);
}
function TrackCommentsResponseFullFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "latestChainBlock": json["latest_chain_block"],
    "latestIndexedBlock": json["latest_indexed_block"],
    "latestChainSlotPlays": json["latest_chain_slot_plays"],
    "latestIndexedSlotPlays": json["latest_indexed_slot_plays"],
    "signature": json["signature"],
    "timestamp": json["timestamp"],
    "version": VersionMetadataFromJSON(json["version"]),
    "data": !exists3(json, "data") ? void 0 : json["data"].map(CommentFromJSON),
    "related": !exists3(json, "related") ? void 0 : RelatedFromJSON(json["related"])
  };
}
function TrackCommentsResponseFullToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "latest_chain_block": value.latestChainBlock,
    "latest_indexed_block": value.latestIndexedBlock,
    "latest_chain_slot_plays": value.latestChainSlotPlays,
    "latest_indexed_slot_plays": value.latestIndexedSlotPlays,
    "signature": value.signature,
    "timestamp": value.timestamp,
    "version": VersionMetadataToJSON(value.version),
    "data": value.data === void 0 ? void 0 : value.data.map(CommentToJSON),
    "related": RelatedToJSON(value.related)
  };
}
function instanceOfTrackFavoritesResponseFull(value) {
  let isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value && value["latestChainBlock"] !== void 0;
  isInstance = isInstance && "latestIndexedBlock" in value && value["latestIndexedBlock"] !== void 0;
  isInstance = isInstance && "latestChainSlotPlays" in value && value["latestChainSlotPlays"] !== void 0;
  isInstance = isInstance && "latestIndexedSlotPlays" in value && value["latestIndexedSlotPlays"] !== void 0;
  isInstance = isInstance && "signature" in value && value["signature"] !== void 0;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== void 0;
  isInstance = isInstance && "version" in value && value["version"] !== void 0;
  return isInstance;
}
function TrackFavoritesResponseFullFromJSON(json) {
  return TrackFavoritesResponseFullFromJSONTyped(json);
}
function TrackFavoritesResponseFullFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "latestChainBlock": json["latest_chain_block"],
    "latestIndexedBlock": json["latest_indexed_block"],
    "latestChainSlotPlays": json["latest_chain_slot_plays"],
    "latestIndexedSlotPlays": json["latest_indexed_slot_plays"],
    "signature": json["signature"],
    "timestamp": json["timestamp"],
    "version": VersionMetadataFromJSON(json["version"]),
    "data": !exists3(json, "data") ? void 0 : json["data"].map(UserFullFromJSON)
  };
}
function TrackFavoritesResponseFullToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "latest_chain_block": value.latestChainBlock,
    "latest_indexed_block": value.latestIndexedBlock,
    "latest_chain_slot_plays": value.latestChainSlotPlays,
    "latest_indexed_slot_plays": value.latestIndexedSlotPlays,
    "signature": value.signature,
    "timestamp": value.timestamp,
    "version": VersionMetadataToJSON(value.version),
    "data": value.data === void 0 ? void 0 : value.data.map(UserFullToJSON)
  };
}
function instanceOfTrackFeedItem(value) {
  let isInstance = true;
  isInstance = isInstance && "type" in value && value["type"] !== void 0;
  isInstance = isInstance && "item" in value && value["item"] !== void 0;
  return isInstance;
}
function TrackFeedItemFromJSON(json) {
  return TrackFeedItemFromJSONTyped(json);
}
function TrackFeedItemFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "item": TrackFullFromJSON(json["item"])
  };
}
function TrackFeedItemToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": value.type,
    "item": TrackFullToJSON(value.item)
  };
}
function instanceOfTrackId(value) {
  let isInstance = true;
  isInstance = isInstance && "id" in value && value["id"] !== void 0;
  return isInstance;
}
function TrackIdFromJSON(json) {
  return TrackIdFromJSONTyped(json);
}
function TrackIdFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "id": json["id"]
  };
}
function TrackIdToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "id": value.id
  };
}
function instanceOfTrackLibraryResponseFull(value) {
  let isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value && value["latestChainBlock"] !== void 0;
  isInstance = isInstance && "latestIndexedBlock" in value && value["latestIndexedBlock"] !== void 0;
  isInstance = isInstance && "latestChainSlotPlays" in value && value["latestChainSlotPlays"] !== void 0;
  isInstance = isInstance && "latestIndexedSlotPlays" in value && value["latestIndexedSlotPlays"] !== void 0;
  isInstance = isInstance && "signature" in value && value["signature"] !== void 0;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== void 0;
  isInstance = isInstance && "version" in value && value["version"] !== void 0;
  return isInstance;
}
function TrackLibraryResponseFullFromJSON(json) {
  return TrackLibraryResponseFullFromJSONTyped(json);
}
function TrackLibraryResponseFullFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "latestChainBlock": json["latest_chain_block"],
    "latestIndexedBlock": json["latest_indexed_block"],
    "latestChainSlotPlays": json["latest_chain_slot_plays"],
    "latestIndexedSlotPlays": json["latest_indexed_slot_plays"],
    "signature": json["signature"],
    "timestamp": json["timestamp"],
    "version": VersionMetadataFromJSON(json["version"]),
    "data": !exists3(json, "data") ? void 0 : json["data"].map(TrackActivityFullFromJSON)
  };
}
function TrackLibraryResponseFullToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "latest_chain_block": value.latestChainBlock,
    "latest_indexed_block": value.latestIndexedBlock,
    "latest_chain_slot_plays": value.latestChainSlotPlays,
    "latest_indexed_slot_plays": value.latestIndexedSlotPlays,
    "signature": value.signature,
    "timestamp": value.timestamp,
    "version": VersionMetadataToJSON(value.version),
    "data": value.data === void 0 ? void 0 : value.data.map(TrackActivityFullToJSON)
  };
}
function instanceOfTrackRepostsResponseFull(value) {
  let isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value && value["latestChainBlock"] !== void 0;
  isInstance = isInstance && "latestIndexedBlock" in value && value["latestIndexedBlock"] !== void 0;
  isInstance = isInstance && "latestChainSlotPlays" in value && value["latestChainSlotPlays"] !== void 0;
  isInstance = isInstance && "latestIndexedSlotPlays" in value && value["latestIndexedSlotPlays"] !== void 0;
  isInstance = isInstance && "signature" in value && value["signature"] !== void 0;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== void 0;
  isInstance = isInstance && "version" in value && value["version"] !== void 0;
  return isInstance;
}
function TrackRepostsResponseFullFromJSON(json) {
  return TrackRepostsResponseFullFromJSONTyped(json);
}
function TrackRepostsResponseFullFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "latestChainBlock": json["latest_chain_block"],
    "latestIndexedBlock": json["latest_indexed_block"],
    "latestChainSlotPlays": json["latest_chain_slot_plays"],
    "latestIndexedSlotPlays": json["latest_indexed_slot_plays"],
    "signature": json["signature"],
    "timestamp": json["timestamp"],
    "version": VersionMetadataFromJSON(json["version"]),
    "data": !exists3(json, "data") ? void 0 : json["data"].map(UserFullFromJSON)
  };
}
function TrackRepostsResponseFullToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "latest_chain_block": value.latestChainBlock,
    "latest_indexed_block": value.latestIndexedBlock,
    "latest_chain_slot_plays": value.latestChainSlotPlays,
    "latest_indexed_slot_plays": value.latestIndexedSlotPlays,
    "signature": value.signature,
    "timestamp": value.timestamp,
    "version": VersionMetadataToJSON(value.version),
    "data": value.data === void 0 ? void 0 : value.data.map(UserFullToJSON)
  };
}
function instanceOfTransactionDetails(value) {
  let isInstance = true;
  isInstance = isInstance && "transactionDate" in value && value["transactionDate"] !== void 0;
  isInstance = isInstance && "transactionType" in value && value["transactionType"] !== void 0;
  isInstance = isInstance && "method" in value && value["method"] !== void 0;
  isInstance = isInstance && "signature" in value && value["signature"] !== void 0;
  isInstance = isInstance && "userBank" in value && value["userBank"] !== void 0;
  isInstance = isInstance && "change" in value && value["change"] !== void 0;
  isInstance = isInstance && "balance" in value && value["balance"] !== void 0;
  isInstance = isInstance && "metadata" in value && value["metadata"] !== void 0;
  return isInstance;
}
function TransactionDetailsFromJSON(json) {
  return TransactionDetailsFromJSONTyped(json);
}
function TransactionDetailsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "transactionDate": json["transaction_date"],
    "transactionType": json["transaction_type"],
    "method": json["method"],
    "signature": json["signature"],
    "userBank": json["user_bank"],
    "change": json["change"],
    "balance": json["balance"],
    "metadata": json["metadata"]
  };
}
function TransactionDetailsToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "transaction_date": value.transactionDate,
    "transaction_type": value.transactionType,
    "method": value.method,
    "signature": value.signature,
    "user_bank": value.userBank,
    "change": value.change,
    "balance": value.balance,
    "metadata": value.metadata
  };
}
function instanceOfTransactionHistoryCountResponse(value) {
  let isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value && value["latestChainBlock"] !== void 0;
  isInstance = isInstance && "latestIndexedBlock" in value && value["latestIndexedBlock"] !== void 0;
  isInstance = isInstance && "latestChainSlotPlays" in value && value["latestChainSlotPlays"] !== void 0;
  isInstance = isInstance && "latestIndexedSlotPlays" in value && value["latestIndexedSlotPlays"] !== void 0;
  isInstance = isInstance && "signature" in value && value["signature"] !== void 0;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== void 0;
  isInstance = isInstance && "version" in value && value["version"] !== void 0;
  return isInstance;
}
function TransactionHistoryCountResponseFromJSON(json) {
  return TransactionHistoryCountResponseFromJSONTyped(json);
}
function TransactionHistoryCountResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "latestChainBlock": json["latest_chain_block"],
    "latestIndexedBlock": json["latest_indexed_block"],
    "latestChainSlotPlays": json["latest_chain_slot_plays"],
    "latestIndexedSlotPlays": json["latest_indexed_slot_plays"],
    "signature": json["signature"],
    "timestamp": json["timestamp"],
    "version": VersionMetadataFromJSON(json["version"]),
    "data": !exists3(json, "data") ? void 0 : json["data"]
  };
}
function TransactionHistoryCountResponseToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "latest_chain_block": value.latestChainBlock,
    "latest_indexed_block": value.latestIndexedBlock,
    "latest_chain_slot_plays": value.latestChainSlotPlays,
    "latest_indexed_slot_plays": value.latestIndexedSlotPlays,
    "signature": value.signature,
    "timestamp": value.timestamp,
    "version": VersionMetadataToJSON(value.version),
    "data": value.data
  };
}
function instanceOfTransactionHistoryResponse(value) {
  let isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value && value["latestChainBlock"] !== void 0;
  isInstance = isInstance && "latestIndexedBlock" in value && value["latestIndexedBlock"] !== void 0;
  isInstance = isInstance && "latestChainSlotPlays" in value && value["latestChainSlotPlays"] !== void 0;
  isInstance = isInstance && "latestIndexedSlotPlays" in value && value["latestIndexedSlotPlays"] !== void 0;
  isInstance = isInstance && "signature" in value && value["signature"] !== void 0;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== void 0;
  isInstance = isInstance && "version" in value && value["version"] !== void 0;
  return isInstance;
}
function TransactionHistoryResponseFromJSON(json) {
  return TransactionHistoryResponseFromJSONTyped(json);
}
function TransactionHistoryResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "latestChainBlock": json["latest_chain_block"],
    "latestIndexedBlock": json["latest_indexed_block"],
    "latestChainSlotPlays": json["latest_chain_slot_plays"],
    "latestIndexedSlotPlays": json["latest_indexed_slot_plays"],
    "signature": json["signature"],
    "timestamp": json["timestamp"],
    "version": VersionMetadataFromJSON(json["version"]),
    "data": !exists3(json, "data") ? void 0 : json["data"].map(TransactionDetailsFromJSON)
  };
}
function TransactionHistoryResponseToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "latest_chain_block": value.latestChainBlock,
    "latest_indexed_block": value.latestIndexedBlock,
    "latest_chain_slot_plays": value.latestChainSlotPlays,
    "latest_indexed_slot_plays": value.latestIndexedSlotPlays,
    "signature": value.signature,
    "timestamp": value.timestamp,
    "version": VersionMetadataToJSON(value.version),
    "data": value.data === void 0 ? void 0 : value.data.map(TransactionDetailsToJSON)
  };
}
function instanceOfTrendingTimesIds(value) {
  let isInstance = true;
  return isInstance;
}
function TrendingTimesIdsFromJSON(json) {
  return TrendingTimesIdsFromJSONTyped(json);
}
function TrendingTimesIdsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "week": !exists3(json, "week") ? void 0 : json["week"].map(TrackIdFromJSON),
    "month": !exists3(json, "month") ? void 0 : json["month"].map(TrackIdFromJSON),
    "year": !exists3(json, "year") ? void 0 : json["year"].map(TrackIdFromJSON)
  };
}
function TrendingTimesIdsToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "week": value.week === void 0 ? void 0 : value.week.map(TrackIdToJSON),
    "month": value.month === void 0 ? void 0 : value.month.map(TrackIdToJSON),
    "year": value.year === void 0 ? void 0 : value.year.map(TrackIdToJSON)
  };
}
function instanceOfTrendingIdsResponse(value) {
  let isInstance = true;
  return isInstance;
}
function TrendingIdsResponseFromJSON(json) {
  return TrendingIdsResponseFromJSONTyped(json);
}
function TrendingIdsResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "data": !exists3(json, "data") ? void 0 : TrendingTimesIdsFromJSON(json["data"])
  };
}
function TrendingIdsResponseToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "data": TrendingTimesIdsToJSON(value.data)
  };
}
function instanceOfUpdateCoinRequest(value) {
  let isInstance = true;
  return isInstance;
}
function UpdateCoinRequestFromJSON(json) {
  return UpdateCoinRequestFromJSONTyped(json);
}
function UpdateCoinRequestFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "description": !exists3(json, "description") ? void 0 : json["description"],
    "link1": !exists3(json, "link_1") ? void 0 : json["link_1"],
    "link2": !exists3(json, "link_2") ? void 0 : json["link_2"],
    "link3": !exists3(json, "link_3") ? void 0 : json["link_3"],
    "link4": !exists3(json, "link_4") ? void 0 : json["link_4"]
  };
}
function UpdateCoinRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "description": value.description,
    "link_1": value.link1,
    "link_2": value.link2,
    "link_3": value.link3,
    "link_4": value.link4
  };
}
function instanceOfUpdateCoinResponse(value) {
  let isInstance = true;
  return isInstance;
}
function UpdateCoinResponseFromJSON(json) {
  return UpdateCoinResponseFromJSONTyped(json);
}
function UpdateCoinResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "success": !exists3(json, "success") ? void 0 : json["success"]
  };
}
function UpdateCoinResponseToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "success": value.success
  };
}
function instanceOfUserAccountResponseFull(value) {
  let isInstance = true;
  return isInstance;
}
function UserAccountResponseFullFromJSON(json) {
  return UserAccountResponseFullFromJSONTyped(json);
}
function UserAccountResponseFullFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "data": !exists3(json, "data") ? void 0 : AccountFullFromJSON(json["data"])
  };
}
function UserAccountResponseFullToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "data": AccountFullToJSON(value.data)
  };
}
function instanceOfUserCommentsResponseFull(value) {
  let isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value && value["latestChainBlock"] !== void 0;
  isInstance = isInstance && "latestIndexedBlock" in value && value["latestIndexedBlock"] !== void 0;
  isInstance = isInstance && "latestChainSlotPlays" in value && value["latestChainSlotPlays"] !== void 0;
  isInstance = isInstance && "latestIndexedSlotPlays" in value && value["latestIndexedSlotPlays"] !== void 0;
  isInstance = isInstance && "signature" in value && value["signature"] !== void 0;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== void 0;
  isInstance = isInstance && "version" in value && value["version"] !== void 0;
  return isInstance;
}
function UserCommentsResponseFullFromJSON(json) {
  return UserCommentsResponseFullFromJSONTyped(json);
}
function UserCommentsResponseFullFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "latestChainBlock": json["latest_chain_block"],
    "latestIndexedBlock": json["latest_indexed_block"],
    "latestChainSlotPlays": json["latest_chain_slot_plays"],
    "latestIndexedSlotPlays": json["latest_indexed_slot_plays"],
    "signature": json["signature"],
    "timestamp": json["timestamp"],
    "version": VersionMetadataFromJSON(json["version"]),
    "data": !exists3(json, "data") ? void 0 : json["data"].map(CommentFromJSON),
    "related": !exists3(json, "related") ? void 0 : RelatedFromJSON(json["related"])
  };
}
function UserCommentsResponseFullToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "latest_chain_block": value.latestChainBlock,
    "latest_indexed_block": value.latestIndexedBlock,
    "latest_chain_slot_plays": value.latestChainSlotPlays,
    "latest_indexed_slot_plays": value.latestIndexedSlotPlays,
    "signature": value.signature,
    "timestamp": value.timestamp,
    "version": VersionMetadataToJSON(value.version),
    "data": value.data === void 0 ? void 0 : value.data.map(CommentToJSON),
    "related": RelatedToJSON(value.related)
  };
}
function UserFeedItemFromJSON(json) {
  return UserFeedItemFromJSONTyped(json);
}
function UserFeedItemFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  switch (json["type"]) {
    case "playlist":
      return {
        ...PlaylistFeedItemFromJSONTyped(json),
        type: "playlist"
      };
    case "track":
      return {
        ...TrackFeedItemFromJSONTyped(json),
        type: "track"
      };
    default:
      throw new Error(`No variant of UserFeedItem exists with 'type=${json["type"]}'`);
  }
}
function UserFeedItemToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  switch (value["type"]) {
    case "playlist":
      return PlaylistFeedItemToJSON(value);
    case "track":
      return TrackFeedItemToJSON(value);
    default:
      throw new Error(`No variant of UserFeedItem exists with 'type=${value["type"]}'`);
  }
}
function instanceOfUserFeedResponse(value) {
  let isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value && value["latestChainBlock"] !== void 0;
  isInstance = isInstance && "latestIndexedBlock" in value && value["latestIndexedBlock"] !== void 0;
  isInstance = isInstance && "latestChainSlotPlays" in value && value["latestChainSlotPlays"] !== void 0;
  isInstance = isInstance && "latestIndexedSlotPlays" in value && value["latestIndexedSlotPlays"] !== void 0;
  isInstance = isInstance && "signature" in value && value["signature"] !== void 0;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== void 0;
  isInstance = isInstance && "version" in value && value["version"] !== void 0;
  return isInstance;
}
function UserFeedResponseFromJSON(json) {
  return UserFeedResponseFromJSONTyped(json);
}
function UserFeedResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "latestChainBlock": json["latest_chain_block"],
    "latestIndexedBlock": json["latest_indexed_block"],
    "latestChainSlotPlays": json["latest_chain_slot_plays"],
    "latestIndexedSlotPlays": json["latest_indexed_slot_plays"],
    "signature": json["signature"],
    "timestamp": json["timestamp"],
    "version": VersionMetadataFromJSON(json["version"]),
    "data": !exists3(json, "data") ? void 0 : json["data"].map(UserFeedItemFromJSON)
  };
}
function UserFeedResponseToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "latest_chain_block": value.latestChainBlock,
    "latest_indexed_block": value.latestIndexedBlock,
    "latest_chain_slot_plays": value.latestChainSlotPlays,
    "latest_indexed_slot_plays": value.latestIndexedSlotPlays,
    "signature": value.signature,
    "timestamp": value.timestamp,
    "version": VersionMetadataToJSON(value.version),
    "data": value.data === void 0 ? void 0 : value.data.map(UserFeedItemToJSON)
  };
}
var ChallengesApi = class extends BaseAPI {
  /**
   * @hidden
   * Produces an attestation that a given user has completed a challenge, or errors.
   */
  async getChallengeAttestationRaw(params, initOverrides) {
    if (params.challengeId === null || params.challengeId === void 0) {
      throw new RequiredError("challengeId", "Required parameter params.challengeId was null or undefined when calling getChallengeAttestation.");
    }
    if (params.oracle === null || params.oracle === void 0) {
      throw new RequiredError("oracle", "Required parameter params.oracle was null or undefined when calling getChallengeAttestation.");
    }
    if (params.specifier === null || params.specifier === void 0) {
      throw new RequiredError("specifier", "Required parameter params.specifier was null or undefined when calling getChallengeAttestation.");
    }
    if (params.userId === null || params.userId === void 0) {
      throw new RequiredError("userId", "Required parameter params.userId was null or undefined when calling getChallengeAttestation.");
    }
    const queryParameters = {};
    if (params.oracle !== void 0) {
      queryParameters["oracle"] = params.oracle;
    }
    if (params.specifier !== void 0) {
      queryParameters["specifier"] = params.specifier;
    }
    if (params.userId !== void 0) {
      queryParameters["user_id"] = params.userId;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/challenges/{challenge_id}/attest`.replace(`{${"challenge_id"}}`, encodeURIComponent(String(params.challengeId))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => AttestationReponseFromJSON(jsonValue));
  }
  /**
   * Produces an attestation that a given user has completed a challenge, or errors.
   */
  async getChallengeAttestation(params, initOverrides) {
    const response = await this.getChallengeAttestationRaw(params, initOverrides);
    return await response.value();
  }
};
var CidDataApi = class extends BaseAPI {
  /**
   * @hidden
   * Get a metadata by CID
   */
  async getMetadataRaw(params, initOverrides) {
    if (params.metadataId === null || params.metadataId === void 0) {
      throw new RequiredError("metadataId", "Required parameter params.metadataId was null or undefined when calling getMetadata.");
    }
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/cid_data/{metadata_id}`.replace(`{${"metadata_id"}}`, encodeURIComponent(String(params.metadataId))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => CidDataResponseFromJSON(jsonValue));
  }
  /**
   * Get a metadata by CID
   */
  async getMetadata(params, initOverrides) {
    const response = await this.getMetadataRaw(params, initOverrides);
    return await response.value();
  }
};
var CoinsApi = class extends BaseAPI {
  /**
   * @hidden
   * Creates a new artist coin
   */
  async createCoinRaw(params, initOverrides) {
    if (params.userId === null || params.userId === void 0) {
      throw new RequiredError("userId", "Required parameter params.userId was null or undefined when calling createCoin.");
    }
    if (params.createCoinRequest === null || params.createCoinRequest === void 0) {
      throw new RequiredError("createCoinRequest", "Required parameter params.createCoinRequest was null or undefined when calling createCoin.");
    }
    const queryParameters = {};
    if (params.userId !== void 0) {
      queryParameters["user_id"] = params.userId;
    }
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/coins`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: CreateCoinRequestToJSON(params.createCoinRequest)
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => CreateCoinResponseFromJSON(jsonValue));
  }
  /**
   * Creates a new artist coin
   */
  async createCoin(params, initOverrides) {
    const response = await this.createCoinRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets information about a specific coin by its mint address
   */
  async getCoinRaw(params, initOverrides) {
    if (params.mint === null || params.mint === void 0) {
      throw new RequiredError("mint", "Required parameter params.mint was null or undefined when calling getCoin.");
    }
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/coins/{mint}`.replace(`{${"mint"}}`, encodeURIComponent(String(params.mint))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => CoinResponseFromJSON(jsonValue));
  }
  /**
   * Gets information about a specific coin by its mint address
   */
  async getCoin(params, initOverrides) {
    const response = await this.getCoinRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets information about a specific coin by its ticker
   */
  async getCoinByTickerRaw(params, initOverrides) {
    if (params.ticker === null || params.ticker === void 0) {
      throw new RequiredError("ticker", "Required parameter params.ticker was null or undefined when calling getCoinByTicker.");
    }
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/coins/ticker/{ticker}`.replace(`{${"ticker"}}`, encodeURIComponent(String(params.ticker))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => CoinResponseFromJSON(jsonValue));
  }
  /**
   * Gets information about a specific coin by its ticker
   */
  async getCoinByTicker(params, initOverrides) {
    const response = await this.getCoinByTickerRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets a list of coins with optional filtering
   */
  async getCoinsRaw(params, initOverrides) {
    const queryParameters = {};
    if (params.ticker) {
      queryParameters["ticker"] = params.ticker;
    }
    if (params.mint) {
      queryParameters["mint"] = params.mint;
    }
    if (params.ownerId) {
      queryParameters["owner_id"] = params.ownerId;
    }
    if (params.limit !== void 0) {
      queryParameters["limit"] = params.limit;
    }
    if (params.offset !== void 0) {
      queryParameters["offset"] = params.offset;
    }
    if (params.query !== void 0) {
      queryParameters["query"] = params.query;
    }
    if (params.sortMethod !== void 0) {
      queryParameters["sort_method"] = params.sortMethod;
    }
    if (params.sortDirection !== void 0) {
      queryParameters["sort_direction"] = params.sortDirection;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/coins`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => CoinsResponseFromJSON(jsonValue));
  }
  /**
   * Gets a list of coins with optional filtering
   */
  async getCoins() {
    let params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let initOverrides = arguments.length > 1 ? arguments[1] : void 0;
    const response = await this.getCoinsRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Updates information about a specific coin by its mint address
   */
  async updateCoinRaw(params, initOverrides) {
    if (params.mint === null || params.mint === void 0) {
      throw new RequiredError("mint", "Required parameter params.mint was null or undefined when calling updateCoin.");
    }
    if (params.userId === null || params.userId === void 0) {
      throw new RequiredError("userId", "Required parameter params.userId was null or undefined when calling updateCoin.");
    }
    if (params.updateCoinRequest === null || params.updateCoinRequest === void 0) {
      throw new RequiredError("updateCoinRequest", "Required parameter params.updateCoinRequest was null or undefined when calling updateCoin.");
    }
    const queryParameters = {};
    if (params.userId !== void 0) {
      queryParameters["user_id"] = params.userId;
    }
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/coins/{mint}`.replace(`{${"mint"}}`, encodeURIComponent(String(params.mint))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: UpdateCoinRequestToJSON(params.updateCoinRequest)
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => UpdateCoinResponseFromJSON(jsonValue));
  }
  /**
   * Updates information about a specific coin by its mint address
   */
  async updateCoin(params, initOverrides) {
    const response = await this.updateCoinRaw(params, initOverrides);
    return await response.value();
  }
};
var GetCoinsSortMethodEnum = {
  MarketCap: "market_cap",
  Price: "price",
  Volume: "volume",
  CreatedAt: "created_at",
  Holder: "holder"
};
var GetCoinsSortDirectionEnum = {
  Asc: "asc",
  Desc: "desc"
};
var CommentsApi = class extends BaseAPI {
  /**
   * @hidden
   * Gets a comment by ID
   */
  async getCommentRaw(params, initOverrides) {
    if (params.commentId === null || params.commentId === void 0) {
      throw new RequiredError("commentId", "Required parameter params.commentId was null or undefined when calling getComment.");
    }
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/comments/{comment_id}`.replace(`{${"comment_id"}}`, encodeURIComponent(String(params.commentId))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => CommentResponseFromJSON(jsonValue));
  }
  /**
   * Gets a comment by ID
   */
  async getComment(params, initOverrides) {
    const response = await this.getCommentRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets replies to a parent comment
   */
  async getCommentRepliesRaw(params, initOverrides) {
    if (params.commentId === null || params.commentId === void 0) {
      throw new RequiredError("commentId", "Required parameter params.commentId was null or undefined when calling getCommentReplies.");
    }
    const queryParameters = {};
    if (params.offset !== void 0) {
      queryParameters["offset"] = params.offset;
    }
    if (params.limit !== void 0) {
      queryParameters["limit"] = params.limit;
    }
    if (params.userId !== void 0) {
      queryParameters["user_id"] = params.userId;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/comments/{comment_id}/replies`.replace(`{${"comment_id"}}`, encodeURIComponent(String(params.commentId))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => CommentRepliesResponseFromJSON(jsonValue));
  }
  /**
   * Gets replies to a parent comment
   */
  async getCommentReplies(params, initOverrides) {
    const response = await this.getCommentRepliesRaw(params, initOverrides);
    return await response.value();
  }
};
var ExploreApi = class extends BaseAPI {
  /**
   * @hidden
   * Get best selling tracks and/or albums with related entities
   * Get best selling tracks and playlists with related entities
   */
  async getFullBestSellingRaw(params, initOverrides) {
    const queryParameters = {};
    if (params.offset !== void 0) {
      queryParameters["offset"] = params.offset;
    }
    if (params.limit !== void 0) {
      queryParameters["limit"] = params.limit;
    }
    if (params.userId !== void 0) {
      queryParameters["user_id"] = params.userId;
    }
    if (params.type !== void 0) {
      queryParameters["type"] = params.type;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/explore/best-selling`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => BestSellingFullResponseFromJSON(jsonValue));
  }
  /**
   * Get best selling tracks and/or albums with related entities
   * Get best selling tracks and playlists with related entities
   */
  async getFullBestSelling() {
    let params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let initOverrides = arguments.length > 1 ? arguments[1] : void 0;
    const response = await this.getFullBestSellingRaw(params, initOverrides);
    return await response.value();
  }
};
var GetFullBestSellingTypeEnum = {
  All: "all",
  Track: "track",
  Album: "album"
};
var NotificationsApi$1 = class extends BaseAPI {
  /**
   * @hidden
   * Get notifications for user ID
   */
  async getNotificationsRaw(params, initOverrides) {
    if (params.userId === null || params.userId === void 0) {
      throw new RequiredError("userId", "Required parameter params.userId was null or undefined when calling getNotifications.");
    }
    const queryParameters = {};
    if (params.timestamp !== void 0) {
      queryParameters["timestamp"] = params.timestamp;
    }
    if (params.groupId !== void 0) {
      queryParameters["group_id"] = params.groupId;
    }
    if (params.limit !== void 0) {
      queryParameters["limit"] = params.limit;
    }
    if (params.types) {
      queryParameters["types"] = params.types;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/notifications/{user_id}`.replace(`{${"user_id"}}`, encodeURIComponent(String(params.userId))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => NotificationsResponseFromJSON(jsonValue));
  }
  /**
   * Get notifications for user ID
   */
  async getNotifications(params, initOverrides) {
    const response = await this.getNotificationsRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Get playlists the user has saved that have been updated for user ID
   */
  async getPlaylistUpdatesRaw(params, initOverrides) {
    if (params.userId === null || params.userId === void 0) {
      throw new RequiredError("userId", "Required parameter params.userId was null or undefined when calling getPlaylistUpdates.");
    }
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/notifications/{user_id}/playlist_updates`.replace(`{${"user_id"}}`, encodeURIComponent(String(params.userId))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => PlaylistUpdatesResponseFromJSON(jsonValue));
  }
  /**
   * Get playlists the user has saved that have been updated for user ID
   */
  async getPlaylistUpdates(params, initOverrides) {
    const response = await this.getPlaylistUpdatesRaw(params, initOverrides);
    return await response.value();
  }
};
var GetNotificationsTypesEnum = {
  Announcement: "announcement",
  Follow: "follow",
  Repost: "repost",
  Save: "save",
  Remix: "remix",
  Cosign: "cosign",
  Create: "create",
  TipReceive: "tip_receive",
  TipSend: "tip_send",
  ChallengeReward: "challenge_reward",
  RepostOfRepost: "repost_of_repost",
  SaveOfRepost: "save_of_repost",
  Tastemaker: "tastemaker",
  Reaction: "reaction",
  SupporterDethroned: "supporter_dethroned",
  SupporterRankUp: "supporter_rank_up",
  SupportingRankUp: "supporting_rank_up",
  Milestone: "milestone",
  TrackMilestone: "track_milestone",
  TrackAddedToPlaylist: "track_added_to_playlist",
  PlaylistMilestone: "playlist_milestone",
  TierChange: "tier_change",
  Trending: "trending",
  TrendingPlaylist: "trending_playlist",
  TrendingUnderground: "trending_underground",
  UsdcPurchaseBuyer: "usdc_purchase_buyer",
  UsdcPurchaseSeller: "usdc_purchase_seller",
  TrackAddedToPurchasedAlbum: "track_added_to_purchased_album",
  RequestManager: "request_manager",
  ApproveManagerRequest: "approve_manager_request",
  ClaimableReward: "claimable_reward",
  Comment: "comment",
  CommentThread: "comment_thread",
  CommentMention: "comment_mention",
  CommentReaction: "comment_reaction",
  ListenStreakReminder: "listen_streak_reminder",
  FanRemixContestStarted: "fan_remix_contest_started",
  FanRemixContestEnded: "fan_remix_contest_ended",
  FanRemixContestEndingSoon: "fan_remix_contest_ending_soon",
  FanRemixContestWinnersSelected: "fan_remix_contest_winners_selected",
  ArtistRemixContestEnded: "artist_remix_contest_ended",
  ArtistRemixContestEndingSoon: "artist_remix_contest_ending_soon",
  ArtistRemixContestSubmissions: "artist_remix_contest_submissions"
};
var PlaylistsApi = class extends BaseAPI {
  /**
   * @hidden
   * Gets a list of playlists by ID
   */
  async getBulkPlaylistsRaw(params, initOverrides) {
    const queryParameters = {};
    if (params.userId !== void 0) {
      queryParameters["user_id"] = params.userId;
    }
    if (params.id) {
      queryParameters["id"] = params.id;
    }
    if (params.upc) {
      queryParameters["upc"] = params.upc;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/playlists`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => FullPlaylistResponseFromJSON(jsonValue));
  }
  /**
   * Gets a list of playlists by ID
   */
  async getBulkPlaylists() {
    let params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let initOverrides = arguments.length > 1 ? arguments[1] : void 0;
    const response = await this.getBulkPlaylistsRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Get a playlist by ID
   */
  async getPlaylistRaw(params, initOverrides) {
    if (params.playlistId === null || params.playlistId === void 0) {
      throw new RequiredError("playlistId", "Required parameter params.playlistId was null or undefined when calling getPlaylist.");
    }
    const queryParameters = {};
    if (params.userId !== void 0) {
      queryParameters["user_id"] = params.userId;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/playlists/{playlist_id}`.replace(`{${"playlist_id"}}`, encodeURIComponent(String(params.playlistId))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => FullPlaylistResponseFromJSON(jsonValue));
  }
  /**
   * Get a playlist by ID
   */
  async getPlaylist(params, initOverrides) {
    const response = await this.getPlaylistRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Get a playlist by handle and slug
   */
  async getPlaylistByHandleAndSlugRaw(params, initOverrides) {
    if (params.handle === null || params.handle === void 0) {
      throw new RequiredError("handle", "Required parameter params.handle was null or undefined when calling getPlaylistByHandleAndSlug.");
    }
    if (params.slug === null || params.slug === void 0) {
      throw new RequiredError("slug", "Required parameter params.slug was null or undefined when calling getPlaylistByHandleAndSlug.");
    }
    const queryParameters = {};
    if (params.userId !== void 0) {
      queryParameters["user_id"] = params.userId;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/playlists/by_permalink/{handle}/{slug}`.replace(`{${"handle"}}`, encodeURIComponent(String(params.handle))).replace(`{${"slug"}}`, encodeURIComponent(String(params.slug))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => FullPlaylistResponseFromJSON(jsonValue));
  }
  /**
   * Get a playlist by handle and slug
   */
  async getPlaylistByHandleAndSlug(params, initOverrides) {
    const response = await this.getPlaylistByHandleAndSlugRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Fetch tracks within a playlist.
   */
  async getPlaylistTracksRaw(params, initOverrides) {
    if (params.playlistId === null || params.playlistId === void 0) {
      throw new RequiredError("playlistId", "Required parameter params.playlistId was null or undefined when calling getPlaylistTracks.");
    }
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/playlists/{playlist_id}/tracks`.replace(`{${"playlist_id"}}`, encodeURIComponent(String(params.playlistId))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => FullPlaylistTracksResponseFromJSON(jsonValue));
  }
  /**
   * Fetch tracks within a playlist.
   */
  async getPlaylistTracks(params, initOverrides) {
    const response = await this.getPlaylistTracksRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Returns trending playlists for a time period
   */
  async getTrendingPlaylistsRaw(params, initOverrides) {
    const queryParameters = {};
    if (params.offset !== void 0) {
      queryParameters["offset"] = params.offset;
    }
    if (params.limit !== void 0) {
      queryParameters["limit"] = params.limit;
    }
    if (params.userId !== void 0) {
      queryParameters["user_id"] = params.userId;
    }
    if (params.time !== void 0) {
      queryParameters["time"] = params.time;
    }
    if (params.type !== void 0) {
      queryParameters["type"] = params.type;
    }
    if (params.omitTracks !== void 0) {
      queryParameters["omit_tracks"] = params.omitTracks;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/playlists/trending`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => FullTrendingPlaylistsResponseFromJSON(jsonValue));
  }
  /**
   * Returns trending playlists for a time period
   */
  async getTrendingPlaylists() {
    let params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let initOverrides = arguments.length > 1 ? arguments[1] : void 0;
    const response = await this.getTrendingPlaylistsRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Returns trending playlists for a time period based on the given trending version
   */
  async getTrendingPlaylistsWithVersionRaw(params, initOverrides) {
    if (params.version === null || params.version === void 0) {
      throw new RequiredError("version", "Required parameter params.version was null or undefined when calling getTrendingPlaylistsWithVersion.");
    }
    const queryParameters = {};
    if (params.offset !== void 0) {
      queryParameters["offset"] = params.offset;
    }
    if (params.limit !== void 0) {
      queryParameters["limit"] = params.limit;
    }
    if (params.userId !== void 0) {
      queryParameters["user_id"] = params.userId;
    }
    if (params.time !== void 0) {
      queryParameters["time"] = params.time;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/playlists/trending/{version}`.replace(`{${"version"}}`, encodeURIComponent(String(params.version))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => FullTrendingPlaylistsResponseFromJSON(jsonValue));
  }
  /**
   * Returns trending playlists for a time period based on the given trending version
   */
  async getTrendingPlaylistsWithVersion(params, initOverrides) {
    const response = await this.getTrendingPlaylistsWithVersionRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Get users that favorited a playlist
   */
  async getUsersFromPlaylistFavoritesRaw(params, initOverrides) {
    if (params.playlistId === null || params.playlistId === void 0) {
      throw new RequiredError("playlistId", "Required parameter params.playlistId was null or undefined when calling getUsersFromPlaylistFavorites.");
    }
    const queryParameters = {};
    if (params.offset !== void 0) {
      queryParameters["offset"] = params.offset;
    }
    if (params.limit !== void 0) {
      queryParameters["limit"] = params.limit;
    }
    if (params.userId !== void 0) {
      queryParameters["user_id"] = params.userId;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/playlists/{playlist_id}/favorites`.replace(`{${"playlist_id"}}`, encodeURIComponent(String(params.playlistId))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => FollowingResponseFromJSON(jsonValue));
  }
  /**
   * Get users that favorited a playlist
   */
  async getUsersFromPlaylistFavorites(params, initOverrides) {
    const response = await this.getUsersFromPlaylistFavoritesRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Get users that reposted a playlist
   */
  async getUsersFromPlaylistRepostsRaw(params, initOverrides) {
    if (params.playlistId === null || params.playlistId === void 0) {
      throw new RequiredError("playlistId", "Required parameter params.playlistId was null or undefined when calling getUsersFromPlaylistReposts.");
    }
    const queryParameters = {};
    if (params.offset !== void 0) {
      queryParameters["offset"] = params.offset;
    }
    if (params.limit !== void 0) {
      queryParameters["limit"] = params.limit;
    }
    if (params.userId !== void 0) {
      queryParameters["user_id"] = params.userId;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/playlists/{playlist_id}/reposts`.replace(`{${"playlist_id"}}`, encodeURIComponent(String(params.playlistId))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => FollowingResponseFromJSON(jsonValue));
  }
  /**
   * Get users that reposted a playlist
   */
  async getUsersFromPlaylistReposts(params, initOverrides) {
    const response = await this.getUsersFromPlaylistRepostsRaw(params, initOverrides);
    return await response.value();
  }
};
var GetTrendingPlaylistsTimeEnum = {
  Week: "week",
  Month: "month",
  Year: "year",
  AllTime: "allTime"
};
var GetTrendingPlaylistsTypeEnum = {
  Playlist: "playlist",
  Album: "album"
};
var GetTrendingPlaylistsWithVersionTimeEnum = {
  Week: "week",
  Month: "month",
  Year: "year",
  AllTime: "allTime"
};
var ReactionsApi = class extends BaseAPI {
  /**
   * @hidden
   * Gets reactions by reacted_to_id and type
   */
  async bulkGetReactionsRaw(params, initOverrides) {
    if (params.reactedToIds === null || params.reactedToIds === void 0) {
      throw new RequiredError("reactedToIds", "Required parameter params.reactedToIds was null or undefined when calling bulkGetReactions.");
    }
    const queryParameters = {};
    if (params.type !== void 0) {
      queryParameters["type"] = params.type;
    }
    if (params.reactedToIds) {
      queryParameters["reacted_to_ids"] = params.reactedToIds.join(COLLECTION_FORMATS["csv"]);
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/reactions`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => ReactionsFromJSON(jsonValue));
  }
  /**
   * Gets reactions by reacted_to_id and type
   */
  async bulkGetReactions(params, initOverrides) {
    const response = await this.bulkGetReactionsRaw(params, initOverrides);
    return await response.value();
  }
};
var SearchApi = class extends BaseAPI {
  /**
   * @hidden
   * Get Users/Tracks/Playlists/Albums that best match the search query
   */
  async searchRaw(params, initOverrides) {
    const queryParameters = {};
    if (params.offset !== void 0) {
      queryParameters["offset"] = params.offset;
    }
    if (params.limit !== void 0) {
      queryParameters["limit"] = params.limit;
    }
    if (params.userId !== void 0) {
      queryParameters["user_id"] = params.userId;
    }
    if (params.query !== void 0) {
      queryParameters["query"] = params.query;
    }
    if (params.kind !== void 0) {
      queryParameters["kind"] = params.kind;
    }
    if (params.includePurchaseable !== void 0) {
      queryParameters["includePurchaseable"] = params.includePurchaseable;
    }
    if (params.genre) {
      queryParameters["genre"] = params.genre;
    }
    if (params.mood) {
      queryParameters["mood"] = params.mood;
    }
    if (params.isVerified !== void 0) {
      queryParameters["is_verified"] = params.isVerified;
    }
    if (params.hasDownloads !== void 0) {
      queryParameters["has_downloads"] = params.hasDownloads;
    }
    if (params.isPurchaseable !== void 0) {
      queryParameters["is_purchaseable"] = params.isPurchaseable;
    }
    if (params.key) {
      queryParameters["key"] = params.key;
    }
    if (params.bpmMin !== void 0) {
      queryParameters["bpm_min"] = params.bpmMin;
    }
    if (params.bpmMax !== void 0) {
      queryParameters["bpm_max"] = params.bpmMax;
    }
    if (params.sortMethod !== void 0) {
      queryParameters["sort_method"] = params.sortMethod;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/search/full`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => SearchFullResponseFromJSON(jsonValue));
  }
  /**
   * Get Users/Tracks/Playlists/Albums that best match the search query
   */
  async search() {
    let params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let initOverrides = arguments.length > 1 ? arguments[1] : void 0;
    const response = await this.searchRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Same as search but optimized for quicker response at the cost of some entity information.
   * Get Users/Tracks/Playlists/Albums that best match the search query
   */
  async searchAutocompleteRaw(params, initOverrides) {
    const queryParameters = {};
    if (params.offset !== void 0) {
      queryParameters["offset"] = params.offset;
    }
    if (params.limit !== void 0) {
      queryParameters["limit"] = params.limit;
    }
    if (params.userId !== void 0) {
      queryParameters["user_id"] = params.userId;
    }
    if (params.query !== void 0) {
      queryParameters["query"] = params.query;
    }
    if (params.kind !== void 0) {
      queryParameters["kind"] = params.kind;
    }
    if (params.includePurchaseable !== void 0) {
      queryParameters["includePurchaseable"] = params.includePurchaseable;
    }
    if (params.genre) {
      queryParameters["genre"] = params.genre;
    }
    if (params.mood) {
      queryParameters["mood"] = params.mood;
    }
    if (params.isVerified !== void 0) {
      queryParameters["is_verified"] = params.isVerified;
    }
    if (params.hasDownloads !== void 0) {
      queryParameters["has_downloads"] = params.hasDownloads;
    }
    if (params.isPurchaseable !== void 0) {
      queryParameters["is_purchaseable"] = params.isPurchaseable;
    }
    if (params.key) {
      queryParameters["key"] = params.key;
    }
    if (params.bpmMin !== void 0) {
      queryParameters["bpm_min"] = params.bpmMin;
    }
    if (params.bpmMax !== void 0) {
      queryParameters["bpm_max"] = params.bpmMax;
    }
    if (params.sortMethod !== void 0) {
      queryParameters["sort_method"] = params.sortMethod;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/search/autocomplete`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => SearchAutocompleteResponseFromJSON(jsonValue));
  }
  /**
   * Same as search but optimized for quicker response at the cost of some entity information.
   * Get Users/Tracks/Playlists/Albums that best match the search query
   */
  async searchAutocomplete() {
    let params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let initOverrides = arguments.length > 1 ? arguments[1] : void 0;
    const response = await this.searchAutocompleteRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Get Users/Tracks/Playlists/Albums that best match the provided tag
   */
  async searchTagsRaw(params, initOverrides) {
    const queryParameters = {};
    if (params.offset !== void 0) {
      queryParameters["offset"] = params.offset;
    }
    if (params.limit !== void 0) {
      queryParameters["limit"] = params.limit;
    }
    if (params.userId !== void 0) {
      queryParameters["user_id"] = params.userId;
    }
    if (params.query !== void 0) {
      queryParameters["query"] = params.query;
    }
    if (params.kind !== void 0) {
      queryParameters["kind"] = params.kind;
    }
    if (params.includePurchaseable !== void 0) {
      queryParameters["includePurchaseable"] = params.includePurchaseable;
    }
    if (params.genre) {
      queryParameters["genre"] = params.genre;
    }
    if (params.mood) {
      queryParameters["mood"] = params.mood;
    }
    if (params.isVerified !== void 0) {
      queryParameters["is_verified"] = params.isVerified;
    }
    if (params.hasDownloads !== void 0) {
      queryParameters["has_downloads"] = params.hasDownloads;
    }
    if (params.isPurchaseable !== void 0) {
      queryParameters["is_purchaseable"] = params.isPurchaseable;
    }
    if (params.key) {
      queryParameters["key"] = params.key;
    }
    if (params.bpmMin !== void 0) {
      queryParameters["bpm_min"] = params.bpmMin;
    }
    if (params.bpmMax !== void 0) {
      queryParameters["bpm_max"] = params.bpmMax;
    }
    if (params.sortMethod !== void 0) {
      queryParameters["sort_method"] = params.sortMethod;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/search/tags`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => SearchFullResponseFromJSON(jsonValue));
  }
  /**
   * Get Users/Tracks/Playlists/Albums that best match the provided tag
   */
  async searchTags() {
    let params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let initOverrides = arguments.length > 1 ? arguments[1] : void 0;
    const response = await this.searchTagsRaw(params, initOverrides);
    return await response.value();
  }
};
var SearchKindEnum = {
  All: "all",
  Users: "users",
  Tracks: "tracks",
  Playlists: "playlists",
  Albums: "albums"
};
var SearchSortMethodEnum = {
  Relevant: "relevant",
  Popular: "popular",
  Recent: "recent"
};
var SearchAutocompleteKindEnum = {
  All: "all",
  Users: "users",
  Tracks: "tracks",
  Playlists: "playlists",
  Albums: "albums"
};
var SearchAutocompleteSortMethodEnum = {
  Relevant: "relevant",
  Popular: "popular",
  Recent: "recent"
};
var SearchTagsKindEnum = {
  All: "all",
  Users: "users",
  Tracks: "tracks",
  Playlists: "playlists",
  Albums: "albums"
};
var SearchTagsSortMethodEnum = {
  Relevant: "relevant",
  Popular: "popular",
  Recent: "recent"
};
var TipsApi = class extends BaseAPI {
  /**
   * @hidden
   * Gets the most recent tips on the network
   */
  async getTipsRaw(params, initOverrides) {
    const queryParameters = {};
    if (params.offset !== void 0) {
      queryParameters["offset"] = params.offset;
    }
    if (params.limit !== void 0) {
      queryParameters["limit"] = params.limit;
    }
    if (params.userId !== void 0) {
      queryParameters["user_id"] = params.userId;
    }
    if (params.receiverMinFollowers !== void 0) {
      queryParameters["receiver_min_followers"] = params.receiverMinFollowers;
    }
    if (params.receiverIsVerified !== void 0) {
      queryParameters["receiver_is_verified"] = params.receiverIsVerified;
    }
    if (params.currentUserFollows !== void 0) {
      queryParameters["current_user_follows"] = params.currentUserFollows;
    }
    if (params.uniqueBy !== void 0) {
      queryParameters["unique_by"] = params.uniqueBy;
    }
    if (params.minSlot !== void 0) {
      queryParameters["min_slot"] = params.minSlot;
    }
    if (params.maxSlot !== void 0) {
      queryParameters["max_slot"] = params.maxSlot;
    }
    if (params.txSignatures) {
      queryParameters["tx_signatures"] = params.txSignatures.join(COLLECTION_FORMATS["csv"]);
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/tips`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => GetTipsResponseFromJSON(jsonValue));
  }
  /**
   * Gets the most recent tips on the network
   */
  async getTips() {
    let params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let initOverrides = arguments.length > 1 ? arguments[1] : void 0;
    const response = await this.getTipsRaw(params, initOverrides);
    return await response.value();
  }
};
var GetTipsCurrentUserFollowsEnum = {
  Sender: "sender",
  Receiver: "receiver",
  SenderOrReceiver: "sender_or_receiver"
};
var GetTipsUniqueByEnum = {
  Sender: "sender",
  Receiver: "receiver"
};
var TracksApi$1 = class extends BaseAPI {
  /**
   * @hidden
   * Gets the tracks found on the \"Best New Releases\" smart playlist
   */
  async getBestNewReleasesRaw(params, initOverrides) {
    if (params.window === null || params.window === void 0) {
      throw new RequiredError("window", "Required parameter params.window was null or undefined when calling getBestNewReleases.");
    }
    const queryParameters = {};
    if (params.userId !== void 0) {
      queryParameters["user_id"] = params.userId;
    }
    if (params.window !== void 0) {
      queryParameters["window"] = params.window;
    }
    if (params.limit !== void 0) {
      queryParameters["limit"] = params.limit;
    }
    if (params.withUsers !== void 0) {
      queryParameters["with_users"] = params.withUsers;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/tracks/best_new_releases`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => FullTracksResponseFromJSON(jsonValue));
  }
  /**
   * Gets the tracks found on the \"Best New Releases\" smart playlist
   */
  async getBestNewReleases(params, initOverrides) {
    const response = await this.getBestNewReleasesRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets a list of tracks using their IDs or permalinks
   */
  async getBulkTracksRaw(params, initOverrides) {
    const queryParameters = {};
    if (params.userId !== void 0) {
      queryParameters["user_id"] = params.userId;
    }
    if (params.permalink) {
      queryParameters["permalink"] = params.permalink;
    }
    if (params.id) {
      queryParameters["id"] = params.id;
    }
    if (params.isrc) {
      queryParameters["isrc"] = params.isrc;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/tracks`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => FullTracksResponseFromJSON(jsonValue));
  }
  /**
   * Gets a list of tracks using their IDs or permalinks
   */
  async getBulkTracks() {
    let params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let initOverrides = arguments.length > 1 ? arguments[1] : void 0;
    const response = await this.getBulkTracksRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets random tracks found on the \"Feeling Lucky\" smart playlist
   */
  async getFeelingLuckyTracksRaw(params, initOverrides) {
    const queryParameters = {};
    if (params.userId !== void 0) {
      queryParameters["user_id"] = params.userId;
    }
    if (params.limit !== void 0) {
      queryParameters["limit"] = params.limit;
    }
    if (params.withUsers !== void 0) {
      queryParameters["with_users"] = params.withUsers;
    }
    if (params.minFollowers !== void 0) {
      queryParameters["min_followers"] = params.minFollowers;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/tracks/feeling-lucky`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => FullTracksResponseFromJSON(jsonValue));
  }
  /**
   * Gets random tracks found on the \"Feeling Lucky\" smart playlist
   */
  async getFeelingLuckyTracks() {
    let params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let initOverrides = arguments.length > 1 ? arguments[1] : void 0;
    const response = await this.getFeelingLuckyTracksRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets the tracks found on the \"Most Loved\" smart playlist
   */
  async getMostLovedTracksRaw(params, initOverrides) {
    const queryParameters = {};
    if (params.userId !== void 0) {
      queryParameters["user_id"] = params.userId;
    }
    if (params.limit !== void 0) {
      queryParameters["limit"] = params.limit;
    }
    if (params.withUsers !== void 0) {
      queryParameters["with_users"] = params.withUsers;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/tracks/most_loved`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => FullTracksResponseFromJSON(jsonValue));
  }
  /**
   * Gets the tracks found on the \"Most Loved\" smart playlist
   */
  async getMostLovedTracks() {
    let params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let initOverrides = arguments.length > 1 ? arguments[1] : void 0;
    const response = await this.getMostLovedTracksRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets the most shared tracks for a given time range
   */
  async getMostSharedTracksRaw(params, initOverrides) {
    const queryParameters = {};
    if (params.userId !== void 0) {
      queryParameters["user_id"] = params.userId;
    }
    if (params.limit !== void 0) {
      queryParameters["limit"] = params.limit;
    }
    if (params.offset !== void 0) {
      queryParameters["offset"] = params.offset;
    }
    if (params.timeRange !== void 0) {
      queryParameters["time_range"] = params.timeRange;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/tracks/most-shared`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => FullTracksResponseFromJSON(jsonValue));
  }
  /**
   * Gets the most shared tracks for a given time range
   */
  async getMostSharedTracks() {
    let params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let initOverrides = arguments.length > 1 ? arguments[1] : void 0;
    const response = await this.getMostSharedTracksRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets the most recently listed premium tracks
   */
  async getRecentPremiumTracksRaw(params, initOverrides) {
    const queryParameters = {};
    if (params.offset !== void 0) {
      queryParameters["offset"] = params.offset;
    }
    if (params.limit !== void 0) {
      queryParameters["limit"] = params.limit;
    }
    if (params.userId !== void 0) {
      queryParameters["user_id"] = params.userId;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/tracks/recent-premium`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => FullTracksResponseFromJSON(jsonValue));
  }
  /**
   * Gets the most recently listed premium tracks
   */
  async getRecentPremiumTracks() {
    let params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let initOverrides = arguments.length > 1 ? arguments[1] : void 0;
    const response = await this.getRecentPremiumTracksRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Get recommended tracks
   */
  async getRecommendedTracksRaw(params, initOverrides) {
    const queryParameters = {};
    if (params.limit !== void 0) {
      queryParameters["limit"] = params.limit;
    }
    if (params.genre !== void 0) {
      queryParameters["genre"] = params.genre;
    }
    if (params.time !== void 0) {
      queryParameters["time"] = params.time;
    }
    if (params.exclusionList) {
      queryParameters["exclusion_list"] = params.exclusionList;
    }
    if (params.userId !== void 0) {
      queryParameters["user_id"] = params.userId;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/tracks/recommended`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => FullTracksResponseFromJSON(jsonValue));
  }
  /**
   * Get recommended tracks
   */
  async getRecommendedTracks() {
    let params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let initOverrides = arguments.length > 1 ? arguments[1] : void 0;
    const response = await this.getRecommendedTracksRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Get recommended tracks using the given trending strategy version
   */
  async getRecommendedTracksWithVersionRaw(params, initOverrides) {
    if (params.version === null || params.version === void 0) {
      throw new RequiredError("version", "Required parameter params.version was null or undefined when calling getRecommendedTracksWithVersion.");
    }
    const queryParameters = {};
    if (params.limit !== void 0) {
      queryParameters["limit"] = params.limit;
    }
    if (params.genre !== void 0) {
      queryParameters["genre"] = params.genre;
    }
    if (params.time !== void 0) {
      queryParameters["time"] = params.time;
    }
    if (params.exclusionList) {
      queryParameters["exclusion_list"] = params.exclusionList;
    }
    if (params.userId !== void 0) {
      queryParameters["user_id"] = params.userId;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/tracks/recommended/{version}`.replace(`{${"version"}}`, encodeURIComponent(String(params.version))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => FullTracksResponseFromJSON(jsonValue));
  }
  /**
   * Get recommended tracks using the given trending strategy version
   */
  async getRecommendedTracksWithVersion(params, initOverrides) {
    const response = await this.getRecommendedTracksWithVersionRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets a list of tracks that have stems available for remixing
   */
  async getRemixableTracksRaw(params, initOverrides) {
    const queryParameters = {};
    if (params.limit !== void 0) {
      queryParameters["limit"] = params.limit;
    }
    if (params.userId !== void 0) {
      queryParameters["user_id"] = params.userId;
    }
    if (params.withUsers !== void 0) {
      queryParameters["with_users"] = params.withUsers;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/tracks/remixables`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => RemixablesResponseFromJSON(jsonValue));
  }
  /**
   * Gets a list of tracks that have stems available for remixing
   */
  async getRemixableTracks() {
    let params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let initOverrides = arguments.length > 1 ? arguments[1] : void 0;
    const response = await this.getRemixableTracksRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets a track by ID.
   */
  async getTrackRaw(params, initOverrides) {
    if (params.trackId === null || params.trackId === void 0) {
      throw new RequiredError("trackId", "Required parameter params.trackId was null or undefined when calling getTrack.");
    }
    const queryParameters = {};
    if (params.userId !== void 0) {
      queryParameters["user_id"] = params.userId;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/tracks/{track_id}`.replace(`{${"track_id"}}`, encodeURIComponent(String(params.trackId))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => FullTrackResponseFromJSON(jsonValue));
  }
  /**
   * Gets a track by ID.
   */
  async getTrack(params, initOverrides) {
    const response = await this.getTrackRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Get a list of comments for a track
   */
  async getTrackCommentsRaw(params, initOverrides) {
    if (params.trackId === null || params.trackId === void 0) {
      throw new RequiredError("trackId", "Required parameter params.trackId was null or undefined when calling getTrackComments.");
    }
    const queryParameters = {};
    if (params.offset !== void 0) {
      queryParameters["offset"] = params.offset;
    }
    if (params.limit !== void 0) {
      queryParameters["limit"] = params.limit;
    }
    if (params.userId !== void 0) {
      queryParameters["user_id"] = params.userId;
    }
    if (params.sortMethod !== void 0) {
      queryParameters["sort_method"] = params.sortMethod;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/tracks/{track_id}/comments`.replace(`{${"track_id"}}`, encodeURIComponent(String(params.trackId))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => TrackCommentsResponseFullFromJSON(jsonValue));
  }
  /**
   * Get a list of comments for a track
   */
  async getTrackComments(params, initOverrides) {
    const response = await this.getTrackCommentsRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets all the tracks that the given track remixes
   */
  async getTrackRemixParentsRaw(params, initOverrides) {
    if (params.trackId === null || params.trackId === void 0) {
      throw new RequiredError("trackId", "Required parameter params.trackId was null or undefined when calling getTrackRemixParents.");
    }
    const queryParameters = {};
    if (params.offset !== void 0) {
      queryParameters["offset"] = params.offset;
    }
    if (params.limit !== void 0) {
      queryParameters["limit"] = params.limit;
    }
    if (params.userId !== void 0) {
      queryParameters["user_id"] = params.userId;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/tracks/{track_id}/remixing`.replace(`{${"track_id"}}`, encodeURIComponent(String(params.trackId))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => RemixingResponseFromJSON(jsonValue));
  }
  /**
   * Gets all the tracks that the given track remixes
   */
  async getTrackRemixParents(params, initOverrides) {
    const response = await this.getTrackRemixParentsRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Get all tracks that remix the given track
   */
  async getTrackRemixesRaw(params, initOverrides) {
    if (params.trackId === null || params.trackId === void 0) {
      throw new RequiredError("trackId", "Required parameter params.trackId was null or undefined when calling getTrackRemixes.");
    }
    const queryParameters = {};
    if (params.offset !== void 0) {
      queryParameters["offset"] = params.offset;
    }
    if (params.limit !== void 0) {
      queryParameters["limit"] = params.limit;
    }
    if (params.userId !== void 0) {
      queryParameters["user_id"] = params.userId;
    }
    if (params.sortMethod !== void 0) {
      queryParameters["sort_method"] = params.sortMethod;
    }
    if (params.onlyCosigns !== void 0) {
      queryParameters["only_cosigns"] = params.onlyCosigns;
    }
    if (params.onlyContestEntries !== void 0) {
      queryParameters["only_contest_entries"] = params.onlyContestEntries;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/tracks/{track_id}/remixes`.replace(`{${"track_id"}}`, encodeURIComponent(String(params.trackId))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => RemixesResponseFullFromJSON(jsonValue));
  }
  /**
   * Get all tracks that remix the given track
   */
  async getTrackRemixes(params, initOverrides) {
    const response = await this.getTrackRemixesRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Get the remixable stems of a track
   */
  async getTrackStemsRaw(params, initOverrides) {
    if (params.trackId === null || params.trackId === void 0) {
      throw new RequiredError("trackId", "Required parameter params.trackId was null or undefined when calling getTrackStems.");
    }
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/tracks/{track_id}/stems`.replace(`{${"track_id"}}`, encodeURIComponent(String(params.trackId))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => StemsResponseFromJSON(jsonValue));
  }
  /**
   * Get the remixable stems of a track
   */
  async getTrackStems(params, initOverrides) {
    const response = await this.getTrackStemsRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Get the users that have listened to a track the most
   */
  async getTrackTopListenersRaw(params, initOverrides) {
    if (params.trackId === null || params.trackId === void 0) {
      throw new RequiredError("trackId", "Required parameter params.trackId was null or undefined when calling getTrackTopListeners.");
    }
    const queryParameters = {};
    if (params.offset !== void 0) {
      queryParameters["offset"] = params.offset;
    }
    if (params.limit !== void 0) {
      queryParameters["limit"] = params.limit;
    }
    if (params.userId !== void 0) {
      queryParameters["user_id"] = params.userId;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/tracks/{track_id}/top_listeners`.replace(`{${"track_id"}}`, encodeURIComponent(String(params.trackId))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => FullTopListenerFromJSON(jsonValue));
  }
  /**
   * Get the users that have listened to a track the most
   */
  async getTrackTopListeners(params, initOverrides) {
    const response = await this.getTrackTopListenersRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets the most recent tracks with active discussion
   */
  async getTracksWithRecentCommentsRaw(params, initOverrides) {
    const queryParameters = {};
    if (params.userId !== void 0) {
      queryParameters["user_id"] = params.userId;
    }
    if (params.limit !== void 0) {
      queryParameters["limit"] = params.limit;
    }
    if (params.offset !== void 0) {
      queryParameters["offset"] = params.offset;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/tracks/recent-comments`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => FullTracksResponseFromJSON(jsonValue));
  }
  /**
   * Gets the most recent tracks with active discussion
   */
  async getTracksWithRecentComments() {
    let params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let initOverrides = arguments.length > 1 ? arguments[1] : void 0;
    const response = await this.getTracksWithRecentCommentsRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets the track IDs of the top trending tracks on Audius
   */
  async getTrendingTrackIDsRaw(params, initOverrides) {
    const queryParameters = {};
    if (params.offset !== void 0) {
      queryParameters["offset"] = params.offset;
    }
    if (params.limit !== void 0) {
      queryParameters["limit"] = params.limit;
    }
    if (params.genre !== void 0) {
      queryParameters["genre"] = params.genre;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/tracks/trending/ids`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => TrendingIdsResponseFromJSON(jsonValue));
  }
  /**
   * Gets the track IDs of the top trending tracks on Audius
   */
  async getTrendingTrackIDs() {
    let params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let initOverrides = arguments.length > 1 ? arguments[1] : void 0;
    const response = await this.getTrendingTrackIDsRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets the top 100 trending (most popular) tracks on Audius
   */
  async getTrendingTracksRaw(params, initOverrides) {
    const queryParameters = {};
    if (params.offset !== void 0) {
      queryParameters["offset"] = params.offset;
    }
    if (params.limit !== void 0) {
      queryParameters["limit"] = params.limit;
    }
    if (params.userId !== void 0) {
      queryParameters["user_id"] = params.userId;
    }
    if (params.genre !== void 0) {
      queryParameters["genre"] = params.genre;
    }
    if (params.time !== void 0) {
      queryParameters["time"] = params.time;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/tracks/trending`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => FullTracksResponseFromJSON(jsonValue));
  }
  /**
   * Gets the top 100 trending (most popular) tracks on Audius
   */
  async getTrendingTracks() {
    let params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let initOverrides = arguments.length > 1 ? arguments[1] : void 0;
    const response = await this.getTrendingTracksRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets the track IDs of the top trending tracks on Audius based on the given trending strategy version
   */
  async getTrendingTracksIDsWithVersionRaw(params, initOverrides) {
    if (params.version === null || params.version === void 0) {
      throw new RequiredError("version", "Required parameter params.version was null or undefined when calling getTrendingTracksIDsWithVersion.");
    }
    const queryParameters = {};
    if (params.offset !== void 0) {
      queryParameters["offset"] = params.offset;
    }
    if (params.limit !== void 0) {
      queryParameters["limit"] = params.limit;
    }
    if (params.genre !== void 0) {
      queryParameters["genre"] = params.genre;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/tracks/trending/ids/{version}`.replace(`{${"version"}}`, encodeURIComponent(String(params.version))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => TrendingIdsResponseFromJSON(jsonValue));
  }
  /**
   * Gets the track IDs of the top trending tracks on Audius based on the given trending strategy version
   */
  async getTrendingTracksIDsWithVersion(params, initOverrides) {
    const response = await this.getTrendingTracksIDsWithVersionRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets the top 100 trending (most popular) tracks on Audius using a given trending strategy version
   */
  async getTrendingTracksWithVersionRaw(params, initOverrides) {
    if (params.version === null || params.version === void 0) {
      throw new RequiredError("version", "Required parameter params.version was null or undefined when calling getTrendingTracksWithVersion.");
    }
    const queryParameters = {};
    if (params.offset !== void 0) {
      queryParameters["offset"] = params.offset;
    }
    if (params.limit !== void 0) {
      queryParameters["limit"] = params.limit;
    }
    if (params.userId !== void 0) {
      queryParameters["user_id"] = params.userId;
    }
    if (params.genre !== void 0) {
      queryParameters["genre"] = params.genre;
    }
    if (params.time !== void 0) {
      queryParameters["time"] = params.time;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/tracks/trending/{version}`.replace(`{${"version"}}`, encodeURIComponent(String(params.version))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => FullTracksResponseFromJSON(jsonValue));
  }
  /**
   * Gets the top 100 trending (most popular) tracks on Audius using a given trending strategy version
   */
  async getTrendingTracksWithVersion(params, initOverrides) {
    const response = await this.getTrendingTracksWithVersionRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets the top trending (most popular) USDC purchase tracks on Audius
   */
  async getTrendingUSDCPurchaseTracksRaw(params, initOverrides) {
    const queryParameters = {};
    if (params.offset !== void 0) {
      queryParameters["offset"] = params.offset;
    }
    if (params.limit !== void 0) {
      queryParameters["limit"] = params.limit;
    }
    if (params.userId !== void 0) {
      queryParameters["user_id"] = params.userId;
    }
    if (params.genre !== void 0) {
      queryParameters["genre"] = params.genre;
    }
    if (params.time !== void 0) {
      queryParameters["time"] = params.time;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/tracks/usdc-purchase`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => FullTracksResponseFromJSON(jsonValue));
  }
  /**
   * Gets the top trending (most popular) USDC purchase tracks on Audius
   */
  async getTrendingUSDCPurchaseTracks() {
    let params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let initOverrides = arguments.length > 1 ? arguments[1] : void 0;
    const response = await this.getTrendingUSDCPurchaseTracksRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets the top trending (most popular) USDC purchase tracks on Audius using a given trending strategy version
   */
  async getTrendingUSDCPurchaseTracksWithVersionRaw(params, initOverrides) {
    if (params.version === null || params.version === void 0) {
      throw new RequiredError("version", "Required parameter params.version was null or undefined when calling getTrendingUSDCPurchaseTracksWithVersion.");
    }
    const queryParameters = {};
    if (params.offset !== void 0) {
      queryParameters["offset"] = params.offset;
    }
    if (params.limit !== void 0) {
      queryParameters["limit"] = params.limit;
    }
    if (params.userId !== void 0) {
      queryParameters["user_id"] = params.userId;
    }
    if (params.genre !== void 0) {
      queryParameters["genre"] = params.genre;
    }
    if (params.time !== void 0) {
      queryParameters["time"] = params.time;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/tracks/usdc-purchase/{version}`.replace(`{${"version"}}`, encodeURIComponent(String(params.version))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => FullTracksResponseFromJSON(jsonValue));
  }
  /**
   * Gets the top trending (most popular) USDC purchase tracks on Audius using a given trending strategy version
   */
  async getTrendingUSDCPurchaseTracksWithVersion(params, initOverrides) {
    const response = await this.getTrendingUSDCPurchaseTracksWithVersionRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets the tracks found on the \"Under the Radar\" smart playlist
   */
  async getUnderTheRadarTracksRaw(params, initOverrides) {
    const queryParameters = {};
    if (params.offset !== void 0) {
      queryParameters["offset"] = params.offset;
    }
    if (params.limit !== void 0) {
      queryParameters["limit"] = params.limit;
    }
    if (params.userId !== void 0) {
      queryParameters["user_id"] = params.userId;
    }
    if (params.filter !== void 0) {
      queryParameters["filter"] = params.filter;
    }
    if (params.tracksOnly !== void 0) {
      queryParameters["tracks_only"] = params.tracksOnly;
    }
    if (params.withUsers !== void 0) {
      queryParameters["with_users"] = params.withUsers;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/tracks/under_the_radar`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => FullTracksResponseFromJSON(jsonValue));
  }
  /**
   * Gets the tracks found on the \"Under the Radar\" smart playlist
   */
  async getUnderTheRadarTracks() {
    let params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let initOverrides = arguments.length > 1 ? arguments[1] : void 0;
    const response = await this.getUnderTheRadarTracksRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets the top 100 trending underground tracks on Audius
   */
  async getUndergroundTrendingTracksRaw(params, initOverrides) {
    const queryParameters = {};
    if (params.offset !== void 0) {
      queryParameters["offset"] = params.offset;
    }
    if (params.limit !== void 0) {
      queryParameters["limit"] = params.limit;
    }
    if (params.userId !== void 0) {
      queryParameters["user_id"] = params.userId;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/tracks/trending/underground`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => FullTracksResponseFromJSON(jsonValue));
  }
  /**
   * Gets the top 100 trending underground tracks on Audius
   */
  async getUndergroundTrendingTracks() {
    let params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let initOverrides = arguments.length > 1 ? arguments[1] : void 0;
    const response = await this.getUndergroundTrendingTracksRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets the top 100 trending underground tracks on Audius using a given trending strategy version
   */
  async getUndergroundTrendingTracksWithVersionRaw(params, initOverrides) {
    if (params.version === null || params.version === void 0) {
      throw new RequiredError("version", "Required parameter params.version was null or undefined when calling getUndergroundTrendingTracksWithVersion.");
    }
    const queryParameters = {};
    if (params.offset !== void 0) {
      queryParameters["offset"] = params.offset;
    }
    if (params.limit !== void 0) {
      queryParameters["limit"] = params.limit;
    }
    if (params.userId !== void 0) {
      queryParameters["user_id"] = params.userId;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/tracks/trending/underground/{version}`.replace(`{${"version"}}`, encodeURIComponent(String(params.version))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => FullTracksResponseFromJSON(jsonValue));
  }
  /**
   * Gets the top 100 trending underground tracks on Audius using a given trending strategy version
   */
  async getUndergroundTrendingTracksWithVersion(params, initOverrides) {
    const response = await this.getUndergroundTrendingTracksWithVersionRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Get users that favorited a track
   */
  async getUsersFromFavoritesRaw(params, initOverrides) {
    if (params.trackId === null || params.trackId === void 0) {
      throw new RequiredError("trackId", "Required parameter params.trackId was null or undefined when calling getUsersFromFavorites.");
    }
    const queryParameters = {};
    if (params.offset !== void 0) {
      queryParameters["offset"] = params.offset;
    }
    if (params.limit !== void 0) {
      queryParameters["limit"] = params.limit;
    }
    if (params.userId !== void 0) {
      queryParameters["user_id"] = params.userId;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/tracks/{track_id}/favorites`.replace(`{${"track_id"}}`, encodeURIComponent(String(params.trackId))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => TrackFavoritesResponseFullFromJSON(jsonValue));
  }
  /**
   * Get users that favorited a track
   */
  async getUsersFromFavorites(params, initOverrides) {
    const response = await this.getUsersFromFavoritesRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Get the users that reposted a track
   */
  async getUsersFromRepostsRaw(params, initOverrides) {
    if (params.trackId === null || params.trackId === void 0) {
      throw new RequiredError("trackId", "Required parameter params.trackId was null or undefined when calling getUsersFromReposts.");
    }
    const queryParameters = {};
    if (params.offset !== void 0) {
      queryParameters["offset"] = params.offset;
    }
    if (params.limit !== void 0) {
      queryParameters["limit"] = params.limit;
    }
    if (params.userId !== void 0) {
      queryParameters["user_id"] = params.userId;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/tracks/{track_id}/reposts`.replace(`{${"track_id"}}`, encodeURIComponent(String(params.trackId))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => TrackRepostsResponseFullFromJSON(jsonValue));
  }
  /**
   * Get the users that reposted a track
   */
  async getUsersFromReposts(params, initOverrides) {
    const response = await this.getUsersFromRepostsRaw(params, initOverrides);
    return await response.value();
  }
};
var GetBestNewReleasesWindowEnum = {
  Week: "week",
  Month: "month",
  Year: "year"
};
var GetMostSharedTracksTimeRangeEnum = {
  Week: "week",
  Month: "month",
  AllTime: "allTime"
};
var GetRecommendedTracksTimeEnum = {
  Week: "week",
  Month: "month",
  Year: "year",
  AllTime: "allTime"
};
var GetRecommendedTracksWithVersionTimeEnum = {
  Week: "week",
  Month: "month",
  Year: "year",
  AllTime: "allTime"
};
var GetTrackCommentsSortMethodEnum = {
  Top: "top",
  Newest: "newest",
  Timestamp: "timestamp"
};
var GetTrackRemixesSortMethodEnum = {
  Likes: "likes",
  Plays: "plays",
  Recent: "recent"
};
var GetTrendingTracksTimeEnum = {
  Week: "week",
  Month: "month",
  Year: "year",
  AllTime: "allTime"
};
var GetTrendingTracksWithVersionTimeEnum = {
  Week: "week",
  Month: "month",
  Year: "year",
  AllTime: "allTime"
};
var GetTrendingUSDCPurchaseTracksTimeEnum = {
  Week: "week",
  Month: "month",
  Year: "year",
  AllTime: "allTime"
};
var GetTrendingUSDCPurchaseTracksWithVersionTimeEnum = {
  Week: "week",
  Month: "month",
  Year: "year",
  AllTime: "allTime"
};
var GetUnderTheRadarTracksFilterEnum = {
  All: "all",
  Repost: "repost",
  Original: "original"
};
var TransactionsApi = class extends BaseAPI {
  /**
   * @hidden
   * @deprecated
   * Deprecated: Use `/users/{id}/transactions/audio` or `sdk.full.users.getAudioTransactions()` instead.
   * Gets the user\'s $AUDIO transaction history within the App
   */
  async getAudioTransactionHistoryRaw(params, initOverrides) {
    const queryParameters = {};
    if (params.offset !== void 0) {
      queryParameters["offset"] = params.offset;
    }
    if (params.limit !== void 0) {
      queryParameters["limit"] = params.limit;
    }
    if (params.sortMethod !== void 0) {
      queryParameters["sort_method"] = params.sortMethod;
    }
    if (params.sortDirection !== void 0) {
      queryParameters["sort_direction"] = params.sortDirection;
    }
    const headerParameters = {};
    if (params.encodedDataMessage !== void 0 && params.encodedDataMessage !== null) {
      headerParameters["Encoded-Data-Message"] = String(params.encodedDataMessage);
    }
    if (params.encodedDataSignature !== void 0 && params.encodedDataSignature !== null) {
      headerParameters["Encoded-Data-Signature"] = String(params.encodedDataSignature);
    }
    const response = await this.request({
      path: `/transactions`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => TransactionHistoryResponseFromJSON(jsonValue));
  }
  /**
   * @deprecated
   * Deprecated: Use `/users/{id}/transactions/audio` or `sdk.full.users.getAudioTransactions()` instead.
   * Gets the user\'s $AUDIO transaction history within the App
   */
  async getAudioTransactionHistory() {
    let params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let initOverrides = arguments.length > 1 ? arguments[1] : void 0;
    const response = await this.getAudioTransactionHistoryRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * @deprecated
   * Deprecated: Use `/users/{id}/transactions/audio/count` or `sdk.full.users.getAudioTransactionCount()` instead.
   * Gets the count of the user\'s $AUDIO transaction history within the App
   */
  async getAudioTransactionHistoryCountRaw(params, initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    if (params.encodedDataMessage !== void 0 && params.encodedDataMessage !== null) {
      headerParameters["Encoded-Data-Message"] = String(params.encodedDataMessage);
    }
    if (params.encodedDataSignature !== void 0 && params.encodedDataSignature !== null) {
      headerParameters["Encoded-Data-Signature"] = String(params.encodedDataSignature);
    }
    const response = await this.request({
      path: `/transactions/count`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => TransactionHistoryCountResponseFromJSON(jsonValue));
  }
  /**
   * @deprecated
   * Deprecated: Use `/users/{id}/transactions/audio/count` or `sdk.full.users.getAudioTransactionCount()` instead.
   * Gets the count of the user\'s $AUDIO transaction history within the App
   */
  async getAudioTransactionHistoryCount() {
    let params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let initOverrides = arguments.length > 1 ? arguments[1] : void 0;
    const response = await this.getAudioTransactionHistoryCountRaw(params, initOverrides);
    return await response.value();
  }
};
var GetAudioTransactionHistorySortMethodEnum = {
  Date: "date",
  TransactionType: "transaction_type"
};
var GetAudioTransactionHistorySortDirectionEnum = {
  Asc: "asc",
  Desc: "desc"
};
var UsersApi$1 = class extends BaseAPI {
  /**
   * @hidden
   * All users that subscribe to the provided users
   */
  async bulkGetSubscribersRaw(params, initOverrides) {
    if (params.ids === null || params.ids === void 0) {
      throw new RequiredError("ids", "Required parameter params.ids was null or undefined when calling bulkGetSubscribers.");
    }
    const queryParameters = {};
    if (params.ids) {
      queryParameters["ids"] = params.ids.join(COLLECTION_FORMATS["csv"]);
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/users/subscribers`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => FullBulkSubscribersResponseFromJSON(jsonValue));
  }
  /**
   * All users that subscribe to the provided users
   */
  async bulkGetSubscribers(params, initOverrides) {
    const response = await this.bulkGetSubscribersRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Get all users that subscribe to the users listed in the JSON request
   */
  async bulkGetSubscribersViaJSONRequestRaw(params, initOverrides) {
    if (params.ids === null || params.ids === void 0) {
      throw new RequiredError("ids", "Required parameter params.ids was null or undefined when calling bulkGetSubscribersViaJSONRequest.");
    }
    const queryParameters = {};
    if (params.ids) {
      queryParameters["ids"] = params.ids.join(COLLECTION_FORMATS["csv"]);
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/users/subscribers`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => FullBulkSubscribersResponseFromJSON(jsonValue));
  }
  /**
   * Get all users that subscribe to the users listed in the JSON request
   */
  async bulkGetSubscribersViaJSONRequest(params, initOverrides) {
    const response = await this.bulkGetSubscribersViaJSONRequestRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets the AI generated tracks attributed to a user using the user\'s handle
   */
  async getAIAttributedTracksByUserHandleRaw(params, initOverrides) {
    if (params.handle === null || params.handle === void 0) {
      throw new RequiredError("handle", "Required parameter params.handle was null or undefined when calling getAIAttributedTracksByUserHandle.");
    }
    const queryParameters = {};
    if (params.offset !== void 0) {
      queryParameters["offset"] = params.offset;
    }
    if (params.limit !== void 0) {
      queryParameters["limit"] = params.limit;
    }
    if (params.userId !== void 0) {
      queryParameters["user_id"] = params.userId;
    }
    if (params.sort !== void 0) {
      queryParameters["sort"] = params.sort;
    }
    if (params.query !== void 0) {
      queryParameters["query"] = params.query;
    }
    if (params.sortMethod !== void 0) {
      queryParameters["sort_method"] = params.sortMethod;
    }
    if (params.sortDirection !== void 0) {
      queryParameters["sort_direction"] = params.sortDirection;
    }
    if (params.filterTracks !== void 0) {
      queryParameters["filter_tracks"] = params.filterTracks;
    }
    const headerParameters = {};
    if (params.encodedDataMessage !== void 0 && params.encodedDataMessage !== null) {
      headerParameters["Encoded-Data-Message"] = String(params.encodedDataMessage);
    }
    if (params.encodedDataSignature !== void 0 && params.encodedDataSignature !== null) {
      headerParameters["Encoded-Data-Signature"] = String(params.encodedDataSignature);
    }
    const response = await this.request({
      path: `/users/handle/{handle}/tracks/ai_attributed`.replace(`{${"handle"}}`, encodeURIComponent(String(params.handle))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => FullTracksFromJSON(jsonValue));
  }
  /**
   * Gets the AI generated tracks attributed to a user using the user\'s handle
   */
  async getAIAttributedTracksByUserHandle(params, initOverrides) {
    const response = await this.getAIAttributedTracksByUserHandleRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets the albums created by a user using their user ID
   */
  async getAlbumsByUserRaw(params, initOverrides) {
    if (params.id === null || params.id === void 0) {
      throw new RequiredError("id", "Required parameter params.id was null or undefined when calling getAlbumsByUser.");
    }
    const queryParameters = {};
    if (params.offset !== void 0) {
      queryParameters["offset"] = params.offset;
    }
    if (params.limit !== void 0) {
      queryParameters["limit"] = params.limit;
    }
    if (params.userId !== void 0) {
      queryParameters["user_id"] = params.userId;
    }
    if (params.sortMethod !== void 0) {
      queryParameters["sort_method"] = params.sortMethod;
    }
    if (params.query !== void 0) {
      queryParameters["query"] = params.query;
    }
    const headerParameters = {};
    if (params.encodedDataMessage !== void 0 && params.encodedDataMessage !== null) {
      headerParameters["Encoded-Data-Message"] = String(params.encodedDataMessage);
    }
    if (params.encodedDataSignature !== void 0 && params.encodedDataSignature !== null) {
      headerParameters["Encoded-Data-Signature"] = String(params.encodedDataSignature);
    }
    const response = await this.request({
      path: `/users/{id}/albums`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => AlbumsResponseFullFromJSON(jsonValue));
  }
  /**
   * Gets the albums created by a user using their user ID
   */
  async getAlbumsByUser(params, initOverrides) {
    const response = await this.getAlbumsByUserRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets the count of the user\'s $AUDIO transaction history within the App
   */
  async getAudioTransactionCountRaw(params, initOverrides) {
    if (params.id === null || params.id === void 0) {
      throw new RequiredError("id", "Required parameter params.id was null or undefined when calling getAudioTransactionCount.");
    }
    const queryParameters = {};
    const headerParameters = {};
    if (params.encodedDataMessage !== void 0 && params.encodedDataMessage !== null) {
      headerParameters["Encoded-Data-Message"] = String(params.encodedDataMessage);
    }
    if (params.encodedDataSignature !== void 0 && params.encodedDataSignature !== null) {
      headerParameters["Encoded-Data-Signature"] = String(params.encodedDataSignature);
    }
    const response = await this.request({
      path: `/users/{id}/transactions/audio/count`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => TransactionHistoryCountResponseFromJSON(jsonValue));
  }
  /**
   * Gets the count of the user\'s $AUDIO transaction history within the App
   */
  async getAudioTransactionCount(params, initOverrides) {
    const response = await this.getAudioTransactionCountRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets the user\'s $AUDIO transaction history within the App
   */
  async getAudioTransactionsRaw(params, initOverrides) {
    if (params.id === null || params.id === void 0) {
      throw new RequiredError("id", "Required parameter params.id was null or undefined when calling getAudioTransactions.");
    }
    const queryParameters = {};
    if (params.offset !== void 0) {
      queryParameters["offset"] = params.offset;
    }
    if (params.limit !== void 0) {
      queryParameters["limit"] = params.limit;
    }
    if (params.sortMethod !== void 0) {
      queryParameters["sort_method"] = params.sortMethod;
    }
    if (params.sortDirection !== void 0) {
      queryParameters["sort_direction"] = params.sortDirection;
    }
    const headerParameters = {};
    if (params.encodedDataMessage !== void 0 && params.encodedDataMessage !== null) {
      headerParameters["Encoded-Data-Message"] = String(params.encodedDataMessage);
    }
    if (params.encodedDataSignature !== void 0 && params.encodedDataSignature !== null) {
      headerParameters["Encoded-Data-Signature"] = String(params.encodedDataSignature);
    }
    const response = await this.request({
      path: `/users/{id}/transactions/audio`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => TransactionHistoryResponseFromJSON(jsonValue));
  }
  /**
   * Gets the user\'s $AUDIO transaction history within the App
   */
  async getAudioTransactions(params, initOverrides) {
    const response = await this.getAudioTransactionsRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets a list of users by ID
   */
  async getBulkUsersRaw(params, initOverrides) {
    const queryParameters = {};
    if (params.userId !== void 0) {
      queryParameters["user_id"] = params.userId;
    }
    if (params.id) {
      queryParameters["id"] = params.id;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/users`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => FullUserResponseFromJSON(jsonValue));
  }
  /**
   * Gets a list of users by ID
   */
  async getBulkUsers() {
    let params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let initOverrides = arguments.length > 1 ? arguments[1] : void 0;
    const response = await this.getBulkUsersRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets a user\'s favorite tracks
   */
  async getFavoritesRaw(params, initOverrides) {
    if (params.id === null || params.id === void 0) {
      throw new RequiredError("id", "Required parameter params.id was null or undefined when calling getFavorites.");
    }
    const queryParameters = {};
    if (params.offset !== void 0) {
      queryParameters["offset"] = params.offset;
    }
    if (params.limit !== void 0) {
      queryParameters["limit"] = params.limit;
    }
    if (params.userId !== void 0) {
      queryParameters["user_id"] = params.userId;
    }
    if (params.query !== void 0) {
      queryParameters["query"] = params.query;
    }
    if (params.sortMethod !== void 0) {
      queryParameters["sort_method"] = params.sortMethod;
    }
    if (params.sortDirection !== void 0) {
      queryParameters["sort_direction"] = params.sortDirection;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/users/{id}/favorites/tracks`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => TrackLibraryResponseFullFromJSON(jsonValue));
  }
  /**
   * Gets a user\'s favorite tracks
   */
  async getFavorites(params, initOverrides) {
    const response = await this.getFavoritesRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * All users that follow the provided user
   */
  async getFollowersRaw(params, initOverrides) {
    if (params.id === null || params.id === void 0) {
      throw new RequiredError("id", "Required parameter params.id was null or undefined when calling getFollowers.");
    }
    const queryParameters = {};
    if (params.offset !== void 0) {
      queryParameters["offset"] = params.offset;
    }
    if (params.limit !== void 0) {
      queryParameters["limit"] = params.limit;
    }
    if (params.userId !== void 0) {
      queryParameters["user_id"] = params.userId;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/users/{id}/followers`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => FullFollowersResponseFromJSON(jsonValue));
  }
  /**
   * All users that follow the provided user
   */
  async getFollowers(params, initOverrides) {
    const response = await this.getFollowersRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * All users that the provided user follows
   */
  async getFollowingRaw(params, initOverrides) {
    if (params.id === null || params.id === void 0) {
      throw new RequiredError("id", "Required parameter params.id was null or undefined when calling getFollowing.");
    }
    const queryParameters = {};
    if (params.offset !== void 0) {
      queryParameters["offset"] = params.offset;
    }
    if (params.limit !== void 0) {
      queryParameters["limit"] = params.limit;
    }
    if (params.userId !== void 0) {
      queryParameters["user_id"] = params.userId;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/users/{id}/following`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => FollowingResponseFullFromJSON(jsonValue));
  }
  /**
   * All users that the provided user follows
   */
  async getFollowing(params, initOverrides) {
    const response = await this.getFollowingRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets a list of users managed by the given user
   */
  async getManagedUsersRaw(params, initOverrides) {
    if (params.id === null || params.id === void 0) {
      throw new RequiredError("id", "Required parameter params.id was null or undefined when calling getManagedUsers.");
    }
    const queryParameters = {};
    if (params.isApproved !== void 0) {
      queryParameters["is_approved"] = params.isApproved;
    }
    if (params.isRevoked !== void 0) {
      queryParameters["is_revoked"] = params.isRevoked;
    }
    const headerParameters = {};
    if (params.encodedDataMessage !== void 0 && params.encodedDataMessage !== null) {
      headerParameters["Encoded-Data-Message"] = String(params.encodedDataMessage);
    }
    if (params.encodedDataSignature !== void 0 && params.encodedDataSignature !== null) {
      headerParameters["Encoded-Data-Signature"] = String(params.encodedDataSignature);
    }
    const response = await this.request({
      path: `/users/{id}/managed_users`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => ManagedUsersResponseFromJSON(jsonValue));
  }
  /**
   * Gets a list of users managed by the given user
   */
  async getManagedUsers(params, initOverrides) {
    const response = await this.getManagedUsersRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets a list of users managing the given user
   */
  async getManagersRaw(params, initOverrides) {
    if (params.id === null || params.id === void 0) {
      throw new RequiredError("id", "Required parameter params.id was null or undefined when calling getManagers.");
    }
    const queryParameters = {};
    if (params.isApproved !== void 0) {
      queryParameters["is_approved"] = params.isApproved;
    }
    if (params.isRevoked !== void 0) {
      queryParameters["is_revoked"] = params.isRevoked;
    }
    const headerParameters = {};
    if (params.encodedDataMessage !== void 0 && params.encodedDataMessage !== null) {
      headerParameters["Encoded-Data-Message"] = String(params.encodedDataMessage);
    }
    if (params.encodedDataSignature !== void 0 && params.encodedDataSignature !== null) {
      headerParameters["Encoded-Data-Signature"] = String(params.encodedDataSignature);
    }
    const response = await this.request({
      path: `/users/{id}/managers`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => ManagersResponseFromJSON(jsonValue));
  }
  /**
   * Gets a list of users managing the given user
   */
  async getManagers(params, initOverrides) {
    const response = await this.getManagersRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets users muted by the given user
   */
  async getMutedUsersRaw(params, initOverrides) {
    if (params.id === null || params.id === void 0) {
      throw new RequiredError("id", "Required parameter params.id was null or undefined when calling getMutedUsers.");
    }
    const queryParameters = {};
    const headerParameters = {};
    if (params.encodedDataMessage !== void 0 && params.encodedDataMessage !== null) {
      headerParameters["Encoded-Data-Message"] = String(params.encodedDataMessage);
    }
    if (params.encodedDataSignature !== void 0 && params.encodedDataSignature !== null) {
      headerParameters["Encoded-Data-Signature"] = String(params.encodedDataSignature);
    }
    const response = await this.request({
      path: `/users/{id}/muted`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => FullUserResponseFromJSON(jsonValue));
  }
  /**
   * Gets users muted by the given user
   */
  async getMutedUsers(params, initOverrides) {
    const response = await this.getMutedUsersRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Get intersection of users that follow followeeUserId and users that are followed by followerUserId
   */
  async getMutualFollowersRaw(params, initOverrides) {
    if (params.id === null || params.id === void 0) {
      throw new RequiredError("id", "Required parameter params.id was null or undefined when calling getMutualFollowers.");
    }
    const queryParameters = {};
    if (params.offset !== void 0) {
      queryParameters["offset"] = params.offset;
    }
    if (params.limit !== void 0) {
      queryParameters["limit"] = params.limit;
    }
    if (params.userId !== void 0) {
      queryParameters["user_id"] = params.userId;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/users/{id}/mutuals`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => FullMutualFollowersResponseFromJSON(jsonValue));
  }
  /**
   * Get intersection of users that follow followeeUserId and users that are followed by followerUserId
   */
  async getMutualFollowers(params, initOverrides) {
    const response = await this.getMutualFollowersRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets the playlists created by a user using their user ID
   */
  async getPlaylistsByUserRaw(params, initOverrides) {
    if (params.id === null || params.id === void 0) {
      throw new RequiredError("id", "Required parameter params.id was null or undefined when calling getPlaylistsByUser.");
    }
    const queryParameters = {};
    if (params.offset !== void 0) {
      queryParameters["offset"] = params.offset;
    }
    if (params.limit !== void 0) {
      queryParameters["limit"] = params.limit;
    }
    if (params.userId !== void 0) {
      queryParameters["user_id"] = params.userId;
    }
    if (params.sortMethod !== void 0) {
      queryParameters["sort_method"] = params.sortMethod;
    }
    if (params.query !== void 0) {
      queryParameters["query"] = params.query;
    }
    const headerParameters = {};
    if (params.encodedDataMessage !== void 0 && params.encodedDataMessage !== null) {
      headerParameters["Encoded-Data-Message"] = String(params.encodedDataMessage);
    }
    if (params.encodedDataSignature !== void 0 && params.encodedDataSignature !== null) {
      headerParameters["Encoded-Data-Signature"] = String(params.encodedDataSignature);
    }
    const response = await this.request({
      path: `/users/{id}/playlists`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => PlaylistsResponseFullFromJSON(jsonValue));
  }
  /**
   * Gets the playlists created by a user using their user ID
   */
  async getPlaylistsByUser(params, initOverrides) {
    const response = await this.getPlaylistsByUserRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets the list of unique users who have purchased content by the given user
   */
  async getPurchasersRaw(params, initOverrides) {
    if (params.id === null || params.id === void 0) {
      throw new RequiredError("id", "Required parameter params.id was null or undefined when calling getPurchasers.");
    }
    const queryParameters = {};
    if (params.offset !== void 0) {
      queryParameters["offset"] = params.offset;
    }
    if (params.limit !== void 0) {
      queryParameters["limit"] = params.limit;
    }
    if (params.userId !== void 0) {
      queryParameters["user_id"] = params.userId;
    }
    if (params.contentType !== void 0) {
      queryParameters["content_type"] = params.contentType;
    }
    if (params.contentId !== void 0) {
      queryParameters["content_id"] = params.contentId;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/users/{id}/purchasers`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => FullPurchasersResponseFromJSON(jsonValue));
  }
  /**
   * Gets the list of unique users who have purchased content by the given user
   */
  async getPurchasers(params, initOverrides) {
    const response = await this.getPurchasersRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets the list of users who have purchased content by the given user
   */
  async getPurchasersCountRaw(params, initOverrides) {
    if (params.id === null || params.id === void 0) {
      throw new RequiredError("id", "Required parameter params.id was null or undefined when calling getPurchasersCount.");
    }
    const queryParameters = {};
    if (params.offset !== void 0) {
      queryParameters["offset"] = params.offset;
    }
    if (params.limit !== void 0) {
      queryParameters["limit"] = params.limit;
    }
    if (params.userId !== void 0) {
      queryParameters["user_id"] = params.userId;
    }
    if (params.contentType !== void 0) {
      queryParameters["content_type"] = params.contentType;
    }
    if (params.contentId !== void 0) {
      queryParameters["content_id"] = params.contentId;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/users/{id}/purchasers/count`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => PurchasersCountResponseFromJSON(jsonValue));
  }
  /**
   * Gets the list of users who have purchased content by the given user
   */
  async getPurchasersCount(params, initOverrides) {
    const response = await this.getPurchasersCountRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets the purchases the user has made
   */
  async getPurchasesRaw(params, initOverrides) {
    if (params.id === null || params.id === void 0) {
      throw new RequiredError("id", "Required parameter params.id was null or undefined when calling getPurchases.");
    }
    const queryParameters = {};
    if (params.offset !== void 0) {
      queryParameters["offset"] = params.offset;
    }
    if (params.limit !== void 0) {
      queryParameters["limit"] = params.limit;
    }
    if (params.userId !== void 0) {
      queryParameters["user_id"] = params.userId;
    }
    if (params.sortMethod !== void 0) {
      queryParameters["sort_method"] = params.sortMethod;
    }
    if (params.sortDirection !== void 0) {
      queryParameters["sort_direction"] = params.sortDirection;
    }
    if (params.contentIds) {
      queryParameters["content_ids"] = params.contentIds;
    }
    const headerParameters = {};
    if (params.encodedDataMessage !== void 0 && params.encodedDataMessage !== null) {
      headerParameters["Encoded-Data-Message"] = String(params.encodedDataMessage);
    }
    if (params.encodedDataSignature !== void 0 && params.encodedDataSignature !== null) {
      headerParameters["Encoded-Data-Signature"] = String(params.encodedDataSignature);
    }
    const response = await this.request({
      path: `/users/{id}/purchases`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => PurchasesResponseFromJSON(jsonValue));
  }
  /**
   * Gets the purchases the user has made
   */
  async getPurchases(params, initOverrides) {
    const response = await this.getPurchasesRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets the count of purchases the user has made
   */
  async getPurchasesCountRaw(params, initOverrides) {
    if (params.id === null || params.id === void 0) {
      throw new RequiredError("id", "Required parameter params.id was null or undefined when calling getPurchasesCount.");
    }
    const queryParameters = {};
    if (params.userId !== void 0) {
      queryParameters["user_id"] = params.userId;
    }
    if (params.contentIds) {
      queryParameters["content_ids"] = params.contentIds;
    }
    const headerParameters = {};
    if (params.encodedDataMessage !== void 0 && params.encodedDataMessage !== null) {
      headerParameters["Encoded-Data-Message"] = String(params.encodedDataMessage);
    }
    if (params.encodedDataSignature !== void 0 && params.encodedDataSignature !== null) {
      headerParameters["Encoded-Data-Signature"] = String(params.encodedDataSignature);
    }
    const response = await this.request({
      path: `/users/{id}/purchases/count`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => PurchasesCountResponseFromJSON(jsonValue));
  }
  /**
   * Gets the count of purchases the user has made
   */
  async getPurchasesCount(params, initOverrides) {
    const response = await this.getPurchasesCountRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets a list of users that might be of interest to followers of this user.
   */
  async getRelatedUsersRaw(params, initOverrides) {
    if (params.id === null || params.id === void 0) {
      throw new RequiredError("id", "Required parameter params.id was null or undefined when calling getRelatedUsers.");
    }
    const queryParameters = {};
    if (params.offset !== void 0) {
      queryParameters["offset"] = params.offset;
    }
    if (params.limit !== void 0) {
      queryParameters["limit"] = params.limit;
    }
    if (params.userId !== void 0) {
      queryParameters["user_id"] = params.userId;
    }
    if (params.filterFollowed !== void 0) {
      queryParameters["filter_followed"] = params.filterFollowed;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/users/{id}/related`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => RelatedArtistResponseFullFromJSON(jsonValue));
  }
  /**
   * Gets a list of users that might be of interest to followers of this user.
   */
  async getRelatedUsers(params, initOverrides) {
    const response = await this.getRelatedUsersRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets the list of unique users who have remixed tracks by the given user, or a specific track by that user if provided
   */
  async getRemixersRaw(params, initOverrides) {
    if (params.id === null || params.id === void 0) {
      throw new RequiredError("id", "Required parameter params.id was null or undefined when calling getRemixers.");
    }
    const queryParameters = {};
    if (params.offset !== void 0) {
      queryParameters["offset"] = params.offset;
    }
    if (params.limit !== void 0) {
      queryParameters["limit"] = params.limit;
    }
    if (params.userId !== void 0) {
      queryParameters["user_id"] = params.userId;
    }
    if (params.trackId !== void 0) {
      queryParameters["track_id"] = params.trackId;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/users/{id}/remixers`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => FullRemixersResponseFromJSON(jsonValue));
  }
  /**
   * Gets the list of unique users who have remixed tracks by the given user, or a specific track by that user if provided
   */
  async getRemixers(params, initOverrides) {
    const response = await this.getRemixersRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets the count of unique users who have remixed tracks by the given user, or a specific track by that user if provided
   */
  async getRemixersCountRaw(params, initOverrides) {
    if (params.id === null || params.id === void 0) {
      throw new RequiredError("id", "Required parameter params.id was null or undefined when calling getRemixersCount.");
    }
    const queryParameters = {};
    if (params.userId !== void 0) {
      queryParameters["user_id"] = params.userId;
    }
    if (params.trackId !== void 0) {
      queryParameters["track_id"] = params.trackId;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/users/{id}/remixers/count`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => RemixersCountResponseFromJSON(jsonValue));
  }
  /**
   * Gets the count of unique users who have remixed tracks by the given user, or a specific track by that user if provided
   */
  async getRemixersCount(params, initOverrides) {
    const response = await this.getRemixersCountRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets the given user\'s reposts
   */
  async getRepostsRaw(params, initOverrides) {
    if (params.id === null || params.id === void 0) {
      throw new RequiredError("id", "Required parameter params.id was null or undefined when calling getReposts.");
    }
    const queryParameters = {};
    if (params.offset !== void 0) {
      queryParameters["offset"] = params.offset;
    }
    if (params.limit !== void 0) {
      queryParameters["limit"] = params.limit;
    }
    if (params.userId !== void 0) {
      queryParameters["user_id"] = params.userId;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/users/{id}/reposts`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => FullRepostsFromJSON(jsonValue));
  }
  /**
   * Gets the given user\'s reposts
   */
  async getReposts(params, initOverrides) {
    const response = await this.getRepostsRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets the user\'s reposts by the user handle
   */
  async getRepostsByHandleRaw(params, initOverrides) {
    if (params.handle === null || params.handle === void 0) {
      throw new RequiredError("handle", "Required parameter params.handle was null or undefined when calling getRepostsByHandle.");
    }
    const queryParameters = {};
    if (params.offset !== void 0) {
      queryParameters["offset"] = params.offset;
    }
    if (params.limit !== void 0) {
      queryParameters["limit"] = params.limit;
    }
    if (params.userId !== void 0) {
      queryParameters["user_id"] = params.userId;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/users/handle/{handle}/reposts`.replace(`{${"handle"}}`, encodeURIComponent(String(params.handle))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => FullRepostsFromJSON(jsonValue));
  }
  /**
   * Gets the user\'s reposts by the user handle
   */
  async getRepostsByHandle(params, initOverrides) {
    const response = await this.getRepostsByHandleRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets the sales the user has made
   */
  async getSalesRaw(params, initOverrides) {
    if (params.id === null || params.id === void 0) {
      throw new RequiredError("id", "Required parameter params.id was null or undefined when calling getSales.");
    }
    const queryParameters = {};
    if (params.offset !== void 0) {
      queryParameters["offset"] = params.offset;
    }
    if (params.limit !== void 0) {
      queryParameters["limit"] = params.limit;
    }
    if (params.userId !== void 0) {
      queryParameters["user_id"] = params.userId;
    }
    if (params.sortMethod !== void 0) {
      queryParameters["sort_method"] = params.sortMethod;
    }
    if (params.sortDirection !== void 0) {
      queryParameters["sort_direction"] = params.sortDirection;
    }
    if (params.contentIds) {
      queryParameters["content_ids"] = params.contentIds;
    }
    const headerParameters = {};
    if (params.encodedDataMessage !== void 0 && params.encodedDataMessage !== null) {
      headerParameters["Encoded-Data-Message"] = String(params.encodedDataMessage);
    }
    if (params.encodedDataSignature !== void 0 && params.encodedDataSignature !== null) {
      headerParameters["Encoded-Data-Signature"] = String(params.encodedDataSignature);
    }
    const response = await this.request({
      path: `/users/{id}/sales`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => PurchasesResponseFromJSON(jsonValue));
  }
  /**
   * Gets the sales the user has made
   */
  async getSales(params, initOverrides) {
    const response = await this.getSalesRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets the count of sales the user has made
   */
  async getSalesCountRaw(params, initOverrides) {
    if (params.id === null || params.id === void 0) {
      throw new RequiredError("id", "Required parameter params.id was null or undefined when calling getSalesCount.");
    }
    const queryParameters = {};
    if (params.userId !== void 0) {
      queryParameters["user_id"] = params.userId;
    }
    if (params.contentIds) {
      queryParameters["content_ids"] = params.contentIds;
    }
    const headerParameters = {};
    if (params.encodedDataMessage !== void 0 && params.encodedDataMessage !== null) {
      headerParameters["Encoded-Data-Message"] = String(params.encodedDataMessage);
    }
    if (params.encodedDataSignature !== void 0 && params.encodedDataSignature !== null) {
      headerParameters["Encoded-Data-Signature"] = String(params.encodedDataSignature);
    }
    const response = await this.request({
      path: `/users/{id}/sales/count`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => PurchasesCountResponseFromJSON(jsonValue));
  }
  /**
   * Gets the count of sales the user has made
   */
  async getSalesCount(params, initOverrides) {
    const response = await this.getSalesCountRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * All users that subscribe to the provided user
   */
  async getSubscribersRaw(params, initOverrides) {
    if (params.id === null || params.id === void 0) {
      throw new RequiredError("id", "Required parameter params.id was null or undefined when calling getSubscribers.");
    }
    const queryParameters = {};
    if (params.offset !== void 0) {
      queryParameters["offset"] = params.offset;
    }
    if (params.limit !== void 0) {
      queryParameters["limit"] = params.limit;
    }
    if (params.userId !== void 0) {
      queryParameters["user_id"] = params.userId;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/users/{id}/subscribers`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => FullSubscribersResponseFromJSON(jsonValue));
  }
  /**
   * All users that subscribe to the provided user
   */
  async getSubscribers(params, initOverrides) {
    const response = await this.getSubscribersRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets the users that the given user supports
   */
  async getSupportedUsersRaw(params, initOverrides) {
    if (params.id === null || params.id === void 0) {
      throw new RequiredError("id", "Required parameter params.id was null or undefined when calling getSupportedUsers.");
    }
    const queryParameters = {};
    if (params.offset !== void 0) {
      queryParameters["offset"] = params.offset;
    }
    if (params.limit !== void 0) {
      queryParameters["limit"] = params.limit;
    }
    if (params.userId !== void 0) {
      queryParameters["user_id"] = params.userId;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/users/{id}/supporting`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => FullGetSupportedUsersFromJSON(jsonValue));
  }
  /**
   * Gets the users that the given user supports
   */
  async getSupportedUsers(params, initOverrides) {
    const response = await this.getSupportedUsersRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets the specified supporter of the given user
   */
  async getSupporterRaw(params, initOverrides) {
    if (params.id === null || params.id === void 0) {
      throw new RequiredError("id", "Required parameter params.id was null or undefined when calling getSupporter.");
    }
    if (params.supporterUserId === null || params.supporterUserId === void 0) {
      throw new RequiredError("supporterUserId", "Required parameter params.supporterUserId was null or undefined when calling getSupporter.");
    }
    const queryParameters = {};
    if (params.userId !== void 0) {
      queryParameters["user_id"] = params.userId;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/users/{id}/supporters/{supporter_user_id}`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))).replace(`{${"supporter_user_id"}}`, encodeURIComponent(String(params.supporterUserId))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => FullGetSupporterFromJSON(jsonValue));
  }
  /**
   * Gets the specified supporter of the given user
   */
  async getSupporter(params, initOverrides) {
    const response = await this.getSupporterRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets the supporters of the given user
   */
  async getSupportersRaw(params, initOverrides) {
    if (params.id === null || params.id === void 0) {
      throw new RequiredError("id", "Required parameter params.id was null or undefined when calling getSupporters.");
    }
    const queryParameters = {};
    if (params.offset !== void 0) {
      queryParameters["offset"] = params.offset;
    }
    if (params.limit !== void 0) {
      queryParameters["limit"] = params.limit;
    }
    if (params.userId !== void 0) {
      queryParameters["user_id"] = params.userId;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/users/{id}/supporters`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => FullGetSupportersFromJSON(jsonValue));
  }
  /**
   * Gets the supporters of the given user
   */
  async getSupporters(params, initOverrides) {
    const response = await this.getSupportersRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets the support from the given user to the supported user
   */
  async getSupportingRaw(params, initOverrides) {
    if (params.id === null || params.id === void 0) {
      throw new RequiredError("id", "Required parameter params.id was null or undefined when calling getSupporting.");
    }
    if (params.supportedUserId === null || params.supportedUserId === void 0) {
      throw new RequiredError("supportedUserId", "Required parameter params.supportedUserId was null or undefined when calling getSupporting.");
    }
    const queryParameters = {};
    if (params.userId !== void 0) {
      queryParameters["user_id"] = params.userId;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/users/{id}/supporting/{supported_user_id}`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))).replace(`{${"supported_user_id"}}`, encodeURIComponent(String(params.supportedUserId))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => FullGetSupportingFromJSON(jsonValue));
  }
  /**
   * Gets the support from the given user to the supported user
   */
  async getSupporting(params, initOverrides) {
    const response = await this.getSupportingRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Get the Top Users having at least one track by follower count
   */
  async getTopUsersRaw(params, initOverrides) {
    const queryParameters = {};
    if (params.offset !== void 0) {
      queryParameters["offset"] = params.offset;
    }
    if (params.limit !== void 0) {
      queryParameters["limit"] = params.limit;
    }
    if (params.userId !== void 0) {
      queryParameters["user_id"] = params.userId;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/users/top`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => TopUsersResponseFullFromJSON(jsonValue));
  }
  /**
   * Get the Top Users having at least one track by follower count
   */
  async getTopUsers() {
    let params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let initOverrides = arguments.length > 1 ? arguments[1] : void 0;
    const response = await this.getTopUsersRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Get the Top Users for a Given Genre
   */
  async getTopUsersInGenreRaw(params, initOverrides) {
    const queryParameters = {};
    if (params.offset !== void 0) {
      queryParameters["offset"] = params.offset;
    }
    if (params.limit !== void 0) {
      queryParameters["limit"] = params.limit;
    }
    if (params.genre) {
      queryParameters["genre"] = params.genre;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/users/genre/top`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => TopGenreUsersResponseFullFromJSON(jsonValue));
  }
  /**
   * Get the Top Users for a Given Genre
   */
  async getTopUsersInGenre() {
    let params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let initOverrides = arguments.length > 1 ? arguments[1] : void 0;
    const response = await this.getTopUsersInGenreRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets the tracks created by a user using their user ID
   */
  async getTracksByUserRaw(params, initOverrides) {
    if (params.id === null || params.id === void 0) {
      throw new RequiredError("id", "Required parameter params.id was null or undefined when calling getTracksByUser.");
    }
    const queryParameters = {};
    if (params.offset !== void 0) {
      queryParameters["offset"] = params.offset;
    }
    if (params.limit !== void 0) {
      queryParameters["limit"] = params.limit;
    }
    if (params.userId !== void 0) {
      queryParameters["user_id"] = params.userId;
    }
    if (params.sort !== void 0) {
      queryParameters["sort"] = params.sort;
    }
    if (params.query !== void 0) {
      queryParameters["query"] = params.query;
    }
    if (params.sortMethod !== void 0) {
      queryParameters["sort_method"] = params.sortMethod;
    }
    if (params.sortDirection !== void 0) {
      queryParameters["sort_direction"] = params.sortDirection;
    }
    if (params.filterTracks !== void 0) {
      queryParameters["filter_tracks"] = params.filterTracks;
    }
    const headerParameters = {};
    if (params.encodedDataMessage !== void 0 && params.encodedDataMessage !== null) {
      headerParameters["Encoded-Data-Message"] = String(params.encodedDataMessage);
    }
    if (params.encodedDataSignature !== void 0 && params.encodedDataSignature !== null) {
      headerParameters["Encoded-Data-Signature"] = String(params.encodedDataSignature);
    }
    const response = await this.request({
      path: `/users/{id}/tracks`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => FullTracksFromJSON(jsonValue));
  }
  /**
   * Gets the tracks created by a user using their user ID
   */
  async getTracksByUser(params, initOverrides) {
    const response = await this.getTracksByUserRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets the tracks created by a user using the user\'s handle
   */
  async getTracksByUserHandleRaw(params, initOverrides) {
    if (params.handle === null || params.handle === void 0) {
      throw new RequiredError("handle", "Required parameter params.handle was null or undefined when calling getTracksByUserHandle.");
    }
    const queryParameters = {};
    if (params.offset !== void 0) {
      queryParameters["offset"] = params.offset;
    }
    if (params.limit !== void 0) {
      queryParameters["limit"] = params.limit;
    }
    if (params.userId !== void 0) {
      queryParameters["user_id"] = params.userId;
    }
    if (params.sort !== void 0) {
      queryParameters["sort"] = params.sort;
    }
    if (params.query !== void 0) {
      queryParameters["query"] = params.query;
    }
    if (params.sortMethod !== void 0) {
      queryParameters["sort_method"] = params.sortMethod;
    }
    if (params.sortDirection !== void 0) {
      queryParameters["sort_direction"] = params.sortDirection;
    }
    if (params.filterTracks !== void 0) {
      queryParameters["filter_tracks"] = params.filterTracks;
    }
    const headerParameters = {};
    if (params.encodedDataMessage !== void 0 && params.encodedDataMessage !== null) {
      headerParameters["Encoded-Data-Message"] = String(params.encodedDataMessage);
    }
    if (params.encodedDataSignature !== void 0 && params.encodedDataSignature !== null) {
      headerParameters["Encoded-Data-Signature"] = String(params.encodedDataSignature);
    }
    const response = await this.request({
      path: `/users/handle/{handle}/tracks`.replace(`{${"handle"}}`, encodeURIComponent(String(params.handle))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => FullTracksFromJSON(jsonValue));
  }
  /**
   * Gets the tracks created by a user using the user\'s handle
   */
  async getTracksByUserHandle(params, initOverrides) {
    const response = await this.getTracksByUserHandleRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets the count of the user\'s $USDC transaction history within the App
   */
  async getUSDCTransactionCountRaw(params, initOverrides) {
    if (params.id === null || params.id === void 0) {
      throw new RequiredError("id", "Required parameter params.id was null or undefined when calling getUSDCTransactionCount.");
    }
    const queryParameters = {};
    if (params.type) {
      queryParameters["type"] = params.type;
    }
    if (params.includeSystemTransactions !== void 0) {
      queryParameters["include_system_transactions"] = params.includeSystemTransactions;
    }
    if (params.method !== void 0) {
      queryParameters["method"] = params.method;
    }
    const headerParameters = {};
    if (params.encodedDataMessage !== void 0 && params.encodedDataMessage !== null) {
      headerParameters["Encoded-Data-Message"] = String(params.encodedDataMessage);
    }
    if (params.encodedDataSignature !== void 0 && params.encodedDataSignature !== null) {
      headerParameters["Encoded-Data-Signature"] = String(params.encodedDataSignature);
    }
    const response = await this.request({
      path: `/users/{id}/transactions/usdc/count`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => TransactionHistoryCountResponseFromJSON(jsonValue));
  }
  /**
   * Gets the count of the user\'s $USDC transaction history within the App
   */
  async getUSDCTransactionCount(params, initOverrides) {
    const response = await this.getUSDCTransactionCountRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets the user\'s $USDC transaction history within the App
   */
  async getUSDCTransactionsRaw(params, initOverrides) {
    if (params.id === null || params.id === void 0) {
      throw new RequiredError("id", "Required parameter params.id was null or undefined when calling getUSDCTransactions.");
    }
    const queryParameters = {};
    if (params.offset !== void 0) {
      queryParameters["offset"] = params.offset;
    }
    if (params.limit !== void 0) {
      queryParameters["limit"] = params.limit;
    }
    if (params.sortMethod !== void 0) {
      queryParameters["sort_method"] = params.sortMethod;
    }
    if (params.sortDirection !== void 0) {
      queryParameters["sort_direction"] = params.sortDirection;
    }
    if (params.type) {
      queryParameters["type"] = params.type;
    }
    if (params.includeSystemTransactions !== void 0) {
      queryParameters["include_system_transactions"] = params.includeSystemTransactions;
    }
    if (params.method !== void 0) {
      queryParameters["method"] = params.method;
    }
    const headerParameters = {};
    if (params.encodedDataMessage !== void 0 && params.encodedDataMessage !== null) {
      headerParameters["Encoded-Data-Message"] = String(params.encodedDataMessage);
    }
    if (params.encodedDataSignature !== void 0 && params.encodedDataSignature !== null) {
      headerParameters["Encoded-Data-Signature"] = String(params.encodedDataSignature);
    }
    const response = await this.request({
      path: `/users/{id}/transactions/usdc`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => TransactionHistoryResponseFromJSON(jsonValue));
  }
  /**
   * Gets the user\'s $USDC transaction history within the App
   */
  async getUSDCTransactions(params, initOverrides) {
    const response = await this.getUSDCTransactionsRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets a single user by their user ID
   */
  async getUserRaw(params, initOverrides) {
    if (params.id === null || params.id === void 0) {
      throw new RequiredError("id", "Required parameter params.id was null or undefined when calling getUser.");
    }
    const queryParameters = {};
    if (params.userId !== void 0) {
      queryParameters["user_id"] = params.userId;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/users/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => FullUserResponseFromJSON(jsonValue));
  }
  /**
   * Gets a single user by their user ID
   */
  async getUser(params, initOverrides) {
    const response = await this.getUserRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets the account for a given user
   */
  async getUserAccountRaw(params, initOverrides) {
    if (params.wallet === null || params.wallet === void 0) {
      throw new RequiredError("wallet", "Required parameter params.wallet was null or undefined when calling getUserAccount.");
    }
    const queryParameters = {};
    const headerParameters = {};
    if (params.encodedDataMessage !== void 0 && params.encodedDataMessage !== null) {
      headerParameters["Encoded-Data-Message"] = String(params.encodedDataMessage);
    }
    if (params.encodedDataSignature !== void 0 && params.encodedDataSignature !== null) {
      headerParameters["Encoded-Data-Signature"] = String(params.encodedDataSignature);
    }
    const response = await this.request({
      path: `/users/account/{wallet}`.replace(`{${"wallet"}}`, encodeURIComponent(String(params.wallet))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => UserAccountResponseFullFromJSON(jsonValue));
  }
  /**
   * Gets the account for a given user
   */
  async getUserAccount(params, initOverrides) {
    const response = await this.getUserAccountRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets a single user by their handle
   */
  async getUserByHandleRaw(params, initOverrides) {
    if (params.handle === null || params.handle === void 0) {
      throw new RequiredError("handle", "Required parameter params.handle was null or undefined when calling getUserByHandle.");
    }
    const queryParameters = {};
    if (params.userId !== void 0) {
      queryParameters["user_id"] = params.userId;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/users/handle/{handle}`.replace(`{${"handle"}}`, encodeURIComponent(String(params.handle))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => FullUserResponseFromJSON(jsonValue));
  }
  /**
   * Gets a single user by their handle
   */
  async getUserByHandle(params, initOverrides) {
    const response = await this.getUserByHandleRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Get user comment history
   */
  async getUserCommentsRaw(params, initOverrides) {
    if (params.id === null || params.id === void 0) {
      throw new RequiredError("id", "Required parameter params.id was null or undefined when calling getUserComments.");
    }
    const queryParameters = {};
    if (params.offset !== void 0) {
      queryParameters["offset"] = params.offset;
    }
    if (params.limit !== void 0) {
      queryParameters["limit"] = params.limit;
    }
    if (params.userId !== void 0) {
      queryParameters["user_id"] = params.userId;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/users/{id}/comments`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => UserCommentsResponseFullFromJSON(jsonValue));
  }
  /**
   * Get user comment history
   */
  async getUserComments(params, initOverrides) {
    const response = await this.getUserCommentsRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets the feed for the user
   */
  async getUserFeedRaw(params, initOverrides) {
    if (params.id === null || params.id === void 0) {
      throw new RequiredError("id", "Required parameter params.id was null or undefined when calling getUserFeed.");
    }
    const queryParameters = {};
    if (params.offset !== void 0) {
      queryParameters["offset"] = params.offset;
    }
    if (params.limit !== void 0) {
      queryParameters["limit"] = params.limit;
    }
    if (params.userId !== void 0) {
      queryParameters["user_id"] = params.userId;
    }
    if (params.filter !== void 0) {
      queryParameters["filter"] = params.filter;
    }
    if (params.tracksOnly !== void 0) {
      queryParameters["tracks_only"] = params.tracksOnly;
    }
    if (params.withUsers !== void 0) {
      queryParameters["with_users"] = params.withUsers;
    }
    if (params.followeeUserId) {
      queryParameters["followee_user_id"] = params.followeeUserId;
    }
    const headerParameters = {};
    if (params.encodedDataMessage !== void 0 && params.encodedDataMessage !== null) {
      headerParameters["Encoded-Data-Message"] = String(params.encodedDataMessage);
    }
    if (params.encodedDataSignature !== void 0 && params.encodedDataSignature !== null) {
      headerParameters["Encoded-Data-Signature"] = String(params.encodedDataSignature);
    }
    const response = await this.request({
      path: `/users/{id}/feed`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => UserFeedResponseFromJSON(jsonValue));
  }
  /**
   * Gets the feed for the user
   */
  async getUserFeed(params, initOverrides) {
    const response = await this.getUserFeedRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets a user\'s saved/reposted/purchased/all albums
   * Fetch a user\'s full library playlists
   */
  async getUserLibraryAlbumsRaw(params, initOverrides) {
    if (params.id === null || params.id === void 0) {
      throw new RequiredError("id", "Required parameter params.id was null or undefined when calling getUserLibraryAlbums.");
    }
    const queryParameters = {};
    if (params.offset !== void 0) {
      queryParameters["offset"] = params.offset;
    }
    if (params.limit !== void 0) {
      queryParameters["limit"] = params.limit;
    }
    if (params.userId !== void 0) {
      queryParameters["user_id"] = params.userId;
    }
    if (params.query !== void 0) {
      queryParameters["query"] = params.query;
    }
    if (params.sortDirection !== void 0) {
      queryParameters["sort_direction"] = params.sortDirection;
    }
    if (params.type !== void 0) {
      queryParameters["type"] = params.type;
    }
    if (params.sortMethod !== void 0) {
      queryParameters["sort_method"] = params.sortMethod;
    }
    const headerParameters = {};
    if (params.encodedDataMessage !== void 0 && params.encodedDataMessage !== null) {
      headerParameters["Encoded-Data-Message"] = String(params.encodedDataMessage);
    }
    if (params.encodedDataSignature !== void 0 && params.encodedDataSignature !== null) {
      headerParameters["Encoded-Data-Signature"] = String(params.encodedDataSignature);
    }
    const response = await this.request({
      path: `/users/{id}/library/albums`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => CollectionLibraryResponseFullFromJSON(jsonValue));
  }
  /**
   * Gets a user\'s saved/reposted/purchased/all albums
   * Fetch a user\'s full library playlists
   */
  async getUserLibraryAlbums(params, initOverrides) {
    const response = await this.getUserLibraryAlbumsRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets a user\'s saved/reposted/purchased/all playlists
   * Fetch a user\'s full library playlists
   */
  async getUserLibraryPlaylistsRaw(params, initOverrides) {
    if (params.id === null || params.id === void 0) {
      throw new RequiredError("id", "Required parameter params.id was null or undefined when calling getUserLibraryPlaylists.");
    }
    const queryParameters = {};
    if (params.offset !== void 0) {
      queryParameters["offset"] = params.offset;
    }
    if (params.limit !== void 0) {
      queryParameters["limit"] = params.limit;
    }
    if (params.userId !== void 0) {
      queryParameters["user_id"] = params.userId;
    }
    if (params.query !== void 0) {
      queryParameters["query"] = params.query;
    }
    if (params.sortDirection !== void 0) {
      queryParameters["sort_direction"] = params.sortDirection;
    }
    if (params.type !== void 0) {
      queryParameters["type"] = params.type;
    }
    if (params.sortMethod !== void 0) {
      queryParameters["sort_method"] = params.sortMethod;
    }
    const headerParameters = {};
    if (params.encodedDataMessage !== void 0 && params.encodedDataMessage !== null) {
      headerParameters["Encoded-Data-Message"] = String(params.encodedDataMessage);
    }
    if (params.encodedDataSignature !== void 0 && params.encodedDataSignature !== null) {
      headerParameters["Encoded-Data-Signature"] = String(params.encodedDataSignature);
    }
    const response = await this.request({
      path: `/users/{id}/library/playlists`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => CollectionLibraryResponseFullFromJSON(jsonValue));
  }
  /**
   * Gets a user\'s saved/reposted/purchased/all playlists
   * Fetch a user\'s full library playlists
   */
  async getUserLibraryPlaylists(params, initOverrides) {
    const response = await this.getUserLibraryPlaylistsRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets a user\'s saved/reposted/purchased/all tracks
   * Fetch a user\'s full library tracks
   */
  async getUserLibraryTracksRaw(params, initOverrides) {
    if (params.id === null || params.id === void 0) {
      throw new RequiredError("id", "Required parameter params.id was null or undefined when calling getUserLibraryTracks.");
    }
    const queryParameters = {};
    if (params.offset !== void 0) {
      queryParameters["offset"] = params.offset;
    }
    if (params.limit !== void 0) {
      queryParameters["limit"] = params.limit;
    }
    if (params.userId !== void 0) {
      queryParameters["user_id"] = params.userId;
    }
    if (params.query !== void 0) {
      queryParameters["query"] = params.query;
    }
    if (params.sortMethod !== void 0) {
      queryParameters["sort_method"] = params.sortMethod;
    }
    if (params.sortDirection !== void 0) {
      queryParameters["sort_direction"] = params.sortDirection;
    }
    if (params.type !== void 0) {
      queryParameters["type"] = params.type;
    }
    const headerParameters = {};
    if (params.encodedDataMessage !== void 0 && params.encodedDataMessage !== null) {
      headerParameters["Encoded-Data-Message"] = String(params.encodedDataMessage);
    }
    if (params.encodedDataSignature !== void 0 && params.encodedDataSignature !== null) {
      headerParameters["Encoded-Data-Signature"] = String(params.encodedDataSignature);
    }
    const response = await this.request({
      path: `/users/{id}/library/tracks`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => TrackLibraryResponseFullFromJSON(jsonValue));
  }
  /**
   * Gets a user\'s saved/reposted/purchased/all tracks
   * Fetch a user\'s full library tracks
   */
  async getUserLibraryTracks(params, initOverrides) {
    const response = await this.getUserLibraryTracksRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets the recommended tracks for the user
   */
  async getUserRecommendedTracksRaw(params, initOverrides) {
    if (params.id === null || params.id === void 0) {
      throw new RequiredError("id", "Required parameter params.id was null or undefined when calling getUserRecommendedTracks.");
    }
    const queryParameters = {};
    if (params.offset !== void 0) {
      queryParameters["offset"] = params.offset;
    }
    if (params.limit !== void 0) {
      queryParameters["limit"] = params.limit;
    }
    if (params.userId !== void 0) {
      queryParameters["user_id"] = params.userId;
    }
    if (params.timeRange !== void 0) {
      queryParameters["time_range"] = params.timeRange;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/users/{id}/recommended-tracks`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => FullTracksFromJSON(jsonValue));
  }
  /**
   * Gets the recommended tracks for the user
   */
  async getUserRecommendedTracks(params, initOverrides) {
    const response = await this.getUserRecommendedTracksRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Get the tracks the user recently listened to.
   */
  async getUsersTrackHistoryRaw(params, initOverrides) {
    if (params.id === null || params.id === void 0) {
      throw new RequiredError("id", "Required parameter params.id was null or undefined when calling getUsersTrackHistory.");
    }
    const queryParameters = {};
    if (params.offset !== void 0) {
      queryParameters["offset"] = params.offset;
    }
    if (params.limit !== void 0) {
      queryParameters["limit"] = params.limit;
    }
    if (params.query !== void 0) {
      queryParameters["query"] = params.query;
    }
    if (params.sortMethod !== void 0) {
      queryParameters["sort_method"] = params.sortMethod;
    }
    if (params.sortDirection !== void 0) {
      queryParameters["sort_direction"] = params.sortDirection;
    }
    if (params.userId !== void 0) {
      queryParameters["user_id"] = params.userId;
    }
    const headerParameters = {};
    if (params.encodedDataMessage !== void 0 && params.encodedDataMessage !== null) {
      headerParameters["Encoded-Data-Message"] = String(params.encodedDataMessage);
    }
    if (params.encodedDataSignature !== void 0 && params.encodedDataSignature !== null) {
      headerParameters["Encoded-Data-Signature"] = String(params.encodedDataSignature);
    }
    const response = await this.request({
      path: `/users/{id}/history/tracks`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => HistoryResponseFullFromJSON(jsonValue));
  }
  /**
   * Get the tracks the user recently listened to.
   */
  async getUsersTrackHistory(params, initOverrides) {
    const response = await this.getUsersTrackHistoryRaw(params, initOverrides);
    return await response.value();
  }
};
var GetAIAttributedTracksByUserHandleSortEnum = {
  Date: "date",
  Plays: "plays"
};
var GetAIAttributedTracksByUserHandleSortMethodEnum = {
  Title: "title",
  ArtistName: "artist_name",
  ReleaseDate: "release_date",
  LastListenDate: "last_listen_date",
  AddedDate: "added_date",
  Plays: "plays",
  Reposts: "reposts",
  Saves: "saves",
  MostListensByUser: "most_listens_by_user"
};
var GetAIAttributedTracksByUserHandleSortDirectionEnum = {
  Asc: "asc",
  Desc: "desc"
};
var GetAIAttributedTracksByUserHandleFilterTracksEnum = {
  All: "all",
  Public: "public",
  Unlisted: "unlisted"
};
var GetAlbumsByUserSortMethodEnum = {
  Recent: "recent",
  Popular: "popular"
};
var GetAudioTransactionsSortMethodEnum = {
  Date: "date",
  TransactionType: "transaction_type"
};
var GetAudioTransactionsSortDirectionEnum = {
  Asc: "asc",
  Desc: "desc"
};
var GetFavoritesSortMethodEnum = {
  Title: "title",
  ArtistName: "artist_name",
  ReleaseDate: "release_date",
  LastListenDate: "last_listen_date",
  AddedDate: "added_date",
  Plays: "plays",
  Reposts: "reposts",
  Saves: "saves",
  MostListensByUser: "most_listens_by_user"
};
var GetFavoritesSortDirectionEnum = {
  Asc: "asc",
  Desc: "desc"
};
var GetPlaylistsByUserSortMethodEnum = {
  Recent: "recent",
  Popular: "popular"
};
var GetPurchasesSortMethodEnum = {
  ContentTitle: "content_title",
  ArtistName: "artist_name",
  BuyerName: "buyer_name",
  Date: "date"
};
var GetPurchasesSortDirectionEnum = {
  Asc: "asc",
  Desc: "desc"
};
var GetSalesSortMethodEnum = {
  ContentTitle: "content_title",
  ArtistName: "artist_name",
  BuyerName: "buyer_name",
  Date: "date"
};
var GetSalesSortDirectionEnum = {
  Asc: "asc",
  Desc: "desc"
};
var GetTracksByUserSortEnum = {
  Date: "date",
  Plays: "plays"
};
var GetTracksByUserSortMethodEnum = {
  Title: "title",
  ArtistName: "artist_name",
  ReleaseDate: "release_date",
  LastListenDate: "last_listen_date",
  AddedDate: "added_date",
  Plays: "plays",
  Reposts: "reposts",
  Saves: "saves",
  MostListensByUser: "most_listens_by_user"
};
var GetTracksByUserSortDirectionEnum = {
  Asc: "asc",
  Desc: "desc"
};
var GetTracksByUserFilterTracksEnum = {
  All: "all",
  Public: "public",
  Unlisted: "unlisted"
};
var GetTracksByUserHandleSortEnum = {
  Date: "date",
  Plays: "plays"
};
var GetTracksByUserHandleSortMethodEnum = {
  Title: "title",
  ArtistName: "artist_name",
  ReleaseDate: "release_date",
  LastListenDate: "last_listen_date",
  AddedDate: "added_date",
  Plays: "plays",
  Reposts: "reposts",
  Saves: "saves",
  MostListensByUser: "most_listens_by_user"
};
var GetTracksByUserHandleSortDirectionEnum = {
  Asc: "asc",
  Desc: "desc"
};
var GetTracksByUserHandleFilterTracksEnum = {
  All: "all",
  Public: "public",
  Unlisted: "unlisted"
};
var GetUSDCTransactionCountTypeEnum = {
  PurchaseContent: "purchase_content",
  Transfer: "transfer",
  InternalTransfer: "internal_transfer",
  PrepareWithdrawal: "prepare_withdrawal",
  RecoverWithdrawal: "recover_withdrawal",
  Withdrawal: "withdrawal",
  PurchaseStripe: "purchase_stripe"
};
var GetUSDCTransactionCountMethodEnum = {
  Send: "send",
  Receive: "receive"
};
var GetUSDCTransactionsSortMethodEnum = {
  Date: "date",
  TransactionType: "transaction_type"
};
var GetUSDCTransactionsSortDirectionEnum = {
  Asc: "asc",
  Desc: "desc"
};
var GetUSDCTransactionsTypeEnum = {
  PurchaseContent: "purchase_content",
  Transfer: "transfer",
  InternalTransfer: "internal_transfer",
  PrepareWithdrawal: "prepare_withdrawal",
  RecoverWithdrawal: "recover_withdrawal",
  Withdrawal: "withdrawal",
  PurchaseStripe: "purchase_stripe"
};
var GetUSDCTransactionsMethodEnum = {
  Send: "send",
  Receive: "receive"
};
var GetUserFeedFilterEnum = {
  All: "all",
  Repost: "repost",
  Original: "original"
};
var GetUserLibraryAlbumsSortDirectionEnum = {
  Asc: "asc",
  Desc: "desc"
};
var GetUserLibraryAlbumsTypeEnum = {
  All: "all",
  Repost: "repost",
  Favorite: "favorite",
  Purchase: "purchase"
};
var GetUserLibraryAlbumsSortMethodEnum = {
  AddedDate: "added_date",
  Reposts: "reposts",
  Saves: "saves"
};
var GetUserLibraryPlaylistsSortDirectionEnum = {
  Asc: "asc",
  Desc: "desc"
};
var GetUserLibraryPlaylistsTypeEnum = {
  All: "all",
  Repost: "repost",
  Favorite: "favorite",
  Purchase: "purchase"
};
var GetUserLibraryPlaylistsSortMethodEnum = {
  AddedDate: "added_date",
  Reposts: "reposts",
  Saves: "saves"
};
var GetUserLibraryTracksSortMethodEnum = {
  Title: "title",
  ArtistName: "artist_name",
  ReleaseDate: "release_date",
  LastListenDate: "last_listen_date",
  AddedDate: "added_date",
  Plays: "plays",
  Reposts: "reposts",
  Saves: "saves",
  MostListensByUser: "most_listens_by_user"
};
var GetUserLibraryTracksSortDirectionEnum = {
  Asc: "asc",
  Desc: "desc"
};
var GetUserLibraryTracksTypeEnum = {
  All: "all",
  Repost: "repost",
  Favorite: "favorite",
  Purchase: "purchase"
};
var GetUserRecommendedTracksTimeRangeEnum = {
  Week: "week",
  Month: "month",
  AllTime: "allTime"
};
var GetUsersTrackHistorySortMethodEnum = {
  Title: "title",
  ArtistName: "artist_name",
  ReleaseDate: "release_date",
  LastListenDate: "last_listen_date",
  AddedDate: "added_date",
  Plays: "plays",
  Reposts: "reposts",
  Saves: "saves",
  MostListensByUser: "most_listens_by_user"
};
var GetUsersTrackHistorySortDirectionEnum = {
  Asc: "asc",
  Desc: "desc"
};
var index3 = Object.freeze({
  __proto__: null,
  BASE_PATH,
  Configuration,
  DefaultConfig,
  BaseAPI,
  ResponseError,
  FetchError,
  RequiredError,
  COLLECTION_FORMATS,
  exists: exists3,
  querystring,
  mapValues,
  canConsumeForm,
  JSONApiResponse,
  VoidApiResponse,
  BlobApiResponse,
  TextApiResponse,
  ChallengesApi,
  CidDataApi,
  CoinsApi,
  GetCoinsSortMethodEnum,
  GetCoinsSortDirectionEnum,
  CommentsApi,
  ExploreApi,
  GetFullBestSellingTypeEnum,
  NotificationsApi: NotificationsApi$1,
  GetNotificationsTypesEnum,
  PlaylistsApi,
  GetTrendingPlaylistsTimeEnum,
  GetTrendingPlaylistsTypeEnum,
  GetTrendingPlaylistsWithVersionTimeEnum,
  ReactionsApi,
  SearchApi,
  SearchKindEnum,
  SearchSortMethodEnum,
  SearchAutocompleteKindEnum,
  SearchAutocompleteSortMethodEnum,
  SearchTagsKindEnum,
  SearchTagsSortMethodEnum,
  TipsApi,
  GetTipsCurrentUserFollowsEnum,
  GetTipsUniqueByEnum,
  TracksApi: TracksApi$1,
  GetBestNewReleasesWindowEnum,
  GetMostSharedTracksTimeRangeEnum,
  GetRecommendedTracksTimeEnum,
  GetRecommendedTracksWithVersionTimeEnum,
  GetTrackCommentsSortMethodEnum,
  GetTrackRemixesSortMethodEnum,
  GetTrendingTracksTimeEnum,
  GetTrendingTracksWithVersionTimeEnum,
  GetTrendingUSDCPurchaseTracksTimeEnum,
  GetTrendingUSDCPurchaseTracksWithVersionTimeEnum,
  GetUnderTheRadarTracksFilterEnum,
  TransactionsApi,
  GetAudioTransactionHistorySortMethodEnum,
  GetAudioTransactionHistorySortDirectionEnum,
  UsersApi: UsersApi$1,
  GetAIAttributedTracksByUserHandleSortEnum,
  GetAIAttributedTracksByUserHandleSortMethodEnum,
  GetAIAttributedTracksByUserHandleSortDirectionEnum,
  GetAIAttributedTracksByUserHandleFilterTracksEnum,
  GetAlbumsByUserSortMethodEnum,
  GetAudioTransactionsSortMethodEnum,
  GetAudioTransactionsSortDirectionEnum,
  GetFavoritesSortMethodEnum,
  GetFavoritesSortDirectionEnum,
  GetPlaylistsByUserSortMethodEnum,
  GetPurchasesSortMethodEnum,
  GetPurchasesSortDirectionEnum,
  GetSalesSortMethodEnum,
  GetSalesSortDirectionEnum,
  GetTracksByUserSortEnum,
  GetTracksByUserSortMethodEnum,
  GetTracksByUserSortDirectionEnum,
  GetTracksByUserFilterTracksEnum,
  GetTracksByUserHandleSortEnum,
  GetTracksByUserHandleSortMethodEnum,
  GetTracksByUserHandleSortDirectionEnum,
  GetTracksByUserHandleFilterTracksEnum,
  GetUSDCTransactionCountTypeEnum,
  GetUSDCTransactionCountMethodEnum,
  GetUSDCTransactionsSortMethodEnum,
  GetUSDCTransactionsSortDirectionEnum,
  GetUSDCTransactionsTypeEnum,
  GetUSDCTransactionsMethodEnum,
  GetUserFeedFilterEnum,
  GetUserLibraryAlbumsSortDirectionEnum,
  GetUserLibraryAlbumsTypeEnum,
  GetUserLibraryAlbumsSortMethodEnum,
  GetUserLibraryPlaylistsSortDirectionEnum,
  GetUserLibraryPlaylistsTypeEnum,
  GetUserLibraryPlaylistsSortMethodEnum,
  GetUserLibraryTracksSortMethodEnum,
  GetUserLibraryTracksSortDirectionEnum,
  GetUserLibraryTracksTypeEnum,
  GetUserRecommendedTracksTimeRangeEnum,
  GetUsersTrackHistorySortMethodEnum,
  GetUsersTrackHistorySortDirectionEnum,
  instanceOfAccess,
  AccessFromJSON,
  AccessFromJSONTyped,
  AccessToJSON,
  AccessGateFromJSON,
  AccessGateFromJSONTyped,
  AccessGateToJSON,
  instanceOfAccountCollection,
  AccountCollectionFromJSON,
  AccountCollectionFromJSONTyped,
  AccountCollectionToJSON,
  instanceOfAccountCollectionUser,
  AccountCollectionUserFromJSON,
  AccountCollectionUserFromJSONTyped,
  AccountCollectionUserToJSON,
  instanceOfAccountFull,
  AccountFullFromJSON,
  AccountFullFromJSONTyped,
  AccountFullToJSON,
  ActivityFullItemTypeEnum,
  instanceOfActivityFull,
  ActivityFullFromJSON,
  ActivityFullFromJSONTyped,
  ActivityFullToJSON,
  instanceOfAlbumBacklink,
  AlbumBacklinkFromJSON,
  AlbumBacklinkFromJSONTyped,
  AlbumBacklinkToJSON,
  instanceOfAlbumsResponseFull,
  AlbumsResponseFullFromJSON,
  AlbumsResponseFullFromJSONTyped,
  AlbumsResponseFullToJSON,
  instanceOfAnnouncementNotification,
  AnnouncementNotificationFromJSON,
  AnnouncementNotificationFromJSONTyped,
  AnnouncementNotificationToJSON,
  instanceOfAnnouncementNotificationAction,
  AnnouncementNotificationActionFromJSON,
  AnnouncementNotificationActionFromJSONTyped,
  AnnouncementNotificationActionToJSON,
  instanceOfAnnouncementNotificationActionData,
  AnnouncementNotificationActionDataFromJSON,
  AnnouncementNotificationActionDataFromJSONTyped,
  AnnouncementNotificationActionDataToJSON,
  instanceOfApproveManagerRequestNotification,
  ApproveManagerRequestNotificationFromJSON,
  ApproveManagerRequestNotificationFromJSONTyped,
  ApproveManagerRequestNotificationToJSON,
  instanceOfApproveManagerRequestNotificationAction,
  ApproveManagerRequestNotificationActionFromJSON,
  ApproveManagerRequestNotificationActionFromJSONTyped,
  ApproveManagerRequestNotificationActionToJSON,
  instanceOfApproveManagerRequestNotificationActionData,
  ApproveManagerRequestNotificationActionDataFromJSON,
  ApproveManagerRequestNotificationActionDataFromJSONTyped,
  ApproveManagerRequestNotificationActionDataToJSON,
  instanceOfArtistRemixContestEndedNotification,
  ArtistRemixContestEndedNotificationFromJSON,
  ArtistRemixContestEndedNotificationFromJSONTyped,
  ArtistRemixContestEndedNotificationToJSON,
  instanceOfArtistRemixContestEndedNotificationAction,
  ArtistRemixContestEndedNotificationActionFromJSON,
  ArtistRemixContestEndedNotificationActionFromJSONTyped,
  ArtistRemixContestEndedNotificationActionToJSON,
  instanceOfArtistRemixContestEndedNotificationActionData,
  ArtistRemixContestEndedNotificationActionDataFromJSON,
  ArtistRemixContestEndedNotificationActionDataFromJSONTyped,
  ArtistRemixContestEndedNotificationActionDataToJSON,
  instanceOfArtistRemixContestEndingSoonNotification,
  ArtistRemixContestEndingSoonNotificationFromJSON,
  ArtistRemixContestEndingSoonNotificationFromJSONTyped,
  ArtistRemixContestEndingSoonNotificationToJSON,
  instanceOfArtistRemixContestEndingSoonNotificationAction,
  ArtistRemixContestEndingSoonNotificationActionFromJSON,
  ArtistRemixContestEndingSoonNotificationActionFromJSONTyped,
  ArtistRemixContestEndingSoonNotificationActionToJSON,
  instanceOfArtistRemixContestEndingSoonNotificationActionData,
  ArtistRemixContestEndingSoonNotificationActionDataFromJSON,
  ArtistRemixContestEndingSoonNotificationActionDataFromJSONTyped,
  ArtistRemixContestEndingSoonNotificationActionDataToJSON,
  instanceOfArtistRemixContestSubmissionsNotification,
  ArtistRemixContestSubmissionsNotificationFromJSON,
  ArtistRemixContestSubmissionsNotificationFromJSONTyped,
  ArtistRemixContestSubmissionsNotificationToJSON,
  instanceOfArtistRemixContestSubmissionsNotificationAction,
  ArtistRemixContestSubmissionsNotificationActionFromJSON,
  ArtistRemixContestSubmissionsNotificationActionFromJSONTyped,
  ArtistRemixContestSubmissionsNotificationActionToJSON,
  instanceOfArtistRemixContestSubmissionsNotificationActionData,
  ArtistRemixContestSubmissionsNotificationActionDataFromJSON,
  ArtistRemixContestSubmissionsNotificationActionDataFromJSONTyped,
  ArtistRemixContestSubmissionsNotificationActionDataToJSON,
  instanceOfAttestation,
  AttestationFromJSON,
  AttestationFromJSONTyped,
  AttestationToJSON,
  instanceOfAttestationReponse,
  AttestationReponseFromJSON,
  AttestationReponseFromJSONTyped,
  AttestationReponseToJSON,
  instanceOfBestSellingFullResponse,
  BestSellingFullResponseFromJSON,
  BestSellingFullResponseFromJSONTyped,
  BestSellingFullResponseToJSON,
  BestSellingItemContentTypeEnum,
  instanceOfBestSellingItem,
  BestSellingItemFromJSON,
  BestSellingItemFromJSONTyped,
  BestSellingItemToJSON,
  instanceOfChallengeRewardNotification,
  ChallengeRewardNotificationFromJSON,
  ChallengeRewardNotificationFromJSONTyped,
  ChallengeRewardNotificationToJSON,
  instanceOfChallengeRewardNotificationAction,
  ChallengeRewardNotificationActionFromJSON,
  ChallengeRewardNotificationActionFromJSONTyped,
  ChallengeRewardNotificationActionToJSON,
  instanceOfChallengeRewardNotificationActionData,
  ChallengeRewardNotificationActionDataFromJSON,
  ChallengeRewardNotificationActionDataFromJSONTyped,
  ChallengeRewardNotificationActionDataToJSON,
  instanceOfCidData,
  CidDataFromJSON,
  CidDataFromJSONTyped,
  CidDataToJSON,
  instanceOfCidDataResponse,
  CidDataResponseFromJSON,
  CidDataResponseFromJSONTyped,
  CidDataResponseToJSON,
  instanceOfClaimableRewardNotification,
  ClaimableRewardNotificationFromJSON,
  ClaimableRewardNotificationFromJSONTyped,
  ClaimableRewardNotificationToJSON,
  instanceOfClaimableRewardNotificationAction,
  ClaimableRewardNotificationActionFromJSON,
  ClaimableRewardNotificationActionFromJSONTyped,
  ClaimableRewardNotificationActionToJSON,
  instanceOfClaimableRewardNotificationActionData,
  ClaimableRewardNotificationActionDataFromJSON,
  ClaimableRewardNotificationActionDataFromJSONTyped,
  ClaimableRewardNotificationActionDataToJSON,
  instanceOfCoin,
  CoinFromJSON,
  CoinFromJSONTyped,
  CoinToJSON,
  instanceOfCoinResponse,
  CoinResponseFromJSON,
  CoinResponseFromJSONTyped,
  CoinResponseToJSON,
  instanceOfCoinsResponse,
  CoinsResponseFromJSON,
  CoinsResponseFromJSONTyped,
  CoinsResponseToJSON,
  CollectionActivityFullItemTypeEnum,
  instanceOfCollectionActivityFull,
  CollectionActivityFullFromJSON,
  CollectionActivityFullFromJSONTyped,
  CollectionActivityFullToJSON,
  CollectionActivityFullWithoutTracksItemTypeEnum,
  instanceOfCollectionActivityFullWithoutTracks,
  CollectionActivityFullWithoutTracksFromJSON,
  CollectionActivityFullWithoutTracksFromJSONTyped,
  CollectionActivityFullWithoutTracksToJSON,
  instanceOfCollectionLibraryResponseFull,
  CollectionLibraryResponseFullFromJSON,
  CollectionLibraryResponseFullFromJSONTyped,
  CollectionLibraryResponseFullToJSON,
  instanceOfComment,
  CommentFromJSON,
  CommentFromJSONTyped,
  CommentToJSON,
  instanceOfCommentMention,
  CommentMentionFromJSON,
  CommentMentionFromJSONTyped,
  CommentMentionToJSON,
  instanceOfCommentMentionNotification,
  CommentMentionNotificationFromJSON,
  CommentMentionNotificationFromJSONTyped,
  CommentMentionNotificationToJSON,
  instanceOfCommentMentionNotificationAction,
  CommentMentionNotificationActionFromJSON,
  CommentMentionNotificationActionFromJSONTyped,
  CommentMentionNotificationActionToJSON,
  CommentMentionNotificationActionDataTypeEnum,
  instanceOfCommentMentionNotificationActionData,
  CommentMentionNotificationActionDataFromJSON,
  CommentMentionNotificationActionDataFromJSONTyped,
  CommentMentionNotificationActionDataToJSON,
  instanceOfCommentNotification,
  CommentNotificationFromJSON,
  CommentNotificationFromJSONTyped,
  CommentNotificationToJSON,
  instanceOfCommentNotificationAction,
  CommentNotificationActionFromJSON,
  CommentNotificationActionFromJSONTyped,
  CommentNotificationActionToJSON,
  CommentNotificationActionDataTypeEnum,
  instanceOfCommentNotificationActionData,
  CommentNotificationActionDataFromJSON,
  CommentNotificationActionDataFromJSONTyped,
  CommentNotificationActionDataToJSON,
  instanceOfCommentReactionNotification,
  CommentReactionNotificationFromJSON,
  CommentReactionNotificationFromJSONTyped,
  CommentReactionNotificationToJSON,
  instanceOfCommentReactionNotificationAction,
  CommentReactionNotificationActionFromJSON,
  CommentReactionNotificationActionFromJSONTyped,
  CommentReactionNotificationActionToJSON,
  CommentReactionNotificationActionDataTypeEnum,
  instanceOfCommentReactionNotificationActionData,
  CommentReactionNotificationActionDataFromJSON,
  CommentReactionNotificationActionDataFromJSONTyped,
  CommentReactionNotificationActionDataToJSON,
  instanceOfCommentRepliesResponse,
  CommentRepliesResponseFromJSON,
  CommentRepliesResponseFromJSONTyped,
  CommentRepliesResponseToJSON,
  instanceOfCommentResponse,
  CommentResponseFromJSON,
  CommentResponseFromJSONTyped,
  CommentResponseToJSON,
  instanceOfCommentThreadNotification,
  CommentThreadNotificationFromJSON,
  CommentThreadNotificationFromJSONTyped,
  CommentThreadNotificationToJSON,
  instanceOfCommentThreadNotificationAction,
  CommentThreadNotificationActionFromJSON,
  CommentThreadNotificationActionFromJSONTyped,
  CommentThreadNotificationActionToJSON,
  CommentThreadNotificationActionDataTypeEnum,
  instanceOfCommentThreadNotificationActionData,
  CommentThreadNotificationActionDataFromJSON,
  CommentThreadNotificationActionDataFromJSONTyped,
  CommentThreadNotificationActionDataToJSON,
  instanceOfCosignNotification,
  CosignNotificationFromJSON,
  CosignNotificationFromJSONTyped,
  CosignNotificationToJSON,
  instanceOfCosignNotificationAction,
  CosignNotificationActionFromJSON,
  CosignNotificationActionFromJSONTyped,
  CosignNotificationActionToJSON,
  instanceOfCosignNotificationActionData,
  CosignNotificationActionDataFromJSON,
  CosignNotificationActionDataFromJSONTyped,
  CosignNotificationActionDataToJSON,
  instanceOfCoverArt,
  CoverArtFromJSON,
  CoverArtFromJSONTyped,
  CoverArtToJSON,
  instanceOfCoverPhoto,
  CoverPhotoFromJSON,
  CoverPhotoFromJSONTyped,
  CoverPhotoToJSON,
  instanceOfCoverPhotoFull,
  CoverPhotoFullFromJSON,
  CoverPhotoFullFromJSONTyped,
  CoverPhotoFullToJSON,
  instanceOfCreateCoinRequest,
  CreateCoinRequestFromJSON,
  CreateCoinRequestFromJSONTyped,
  CreateCoinRequestToJSON,
  instanceOfCreateCoinResponse,
  CreateCoinResponseFromJSON,
  CreateCoinResponseFromJSONTyped,
  CreateCoinResponseToJSON,
  instanceOfCreateCoinResponseData,
  CreateCoinResponseDataFromJSON,
  CreateCoinResponseDataFromJSONTyped,
  CreateCoinResponseDataToJSON,
  instanceOfCreateNotification,
  CreateNotificationFromJSON,
  CreateNotificationFromJSONTyped,
  CreateNotificationToJSON,
  instanceOfCreateNotificationAction,
  CreateNotificationActionFromJSON,
  CreateNotificationActionFromJSONTyped,
  CreateNotificationActionToJSON,
  CreateNotificationActionDataFromJSON,
  CreateNotificationActionDataFromJSONTyped,
  CreateNotificationActionDataToJSON,
  instanceOfCreatePlaylistNotificationActionData,
  CreatePlaylistNotificationActionDataFromJSON,
  CreatePlaylistNotificationActionDataFromJSONTyped,
  CreatePlaylistNotificationActionDataToJSON,
  instanceOfCreateTrackNotificationActionData,
  CreateTrackNotificationActionDataFromJSON,
  CreateTrackNotificationActionDataFromJSONTyped,
  CreateTrackNotificationActionDataToJSON,
  instanceOfDataAndType,
  DataAndTypeFromJSON,
  DataAndTypeFromJSONTyped,
  DataAndTypeToJSON,
  instanceOfExtendedTokenGate,
  ExtendedTokenGateFromJSON,
  ExtendedTokenGateFromJSONTyped,
  ExtendedTokenGateToJSON,
  instanceOfFanRemixContestEndedNotification,
  FanRemixContestEndedNotificationFromJSON,
  FanRemixContestEndedNotificationFromJSONTyped,
  FanRemixContestEndedNotificationToJSON,
  instanceOfFanRemixContestEndedNotificationAction,
  FanRemixContestEndedNotificationActionFromJSON,
  FanRemixContestEndedNotificationActionFromJSONTyped,
  FanRemixContestEndedNotificationActionToJSON,
  instanceOfFanRemixContestEndedNotificationActionData,
  FanRemixContestEndedNotificationActionDataFromJSON,
  FanRemixContestEndedNotificationActionDataFromJSONTyped,
  FanRemixContestEndedNotificationActionDataToJSON,
  instanceOfFanRemixContestEndingSoonNotification,
  FanRemixContestEndingSoonNotificationFromJSON,
  FanRemixContestEndingSoonNotificationFromJSONTyped,
  FanRemixContestEndingSoonNotificationToJSON,
  instanceOfFanRemixContestEndingSoonNotificationAction,
  FanRemixContestEndingSoonNotificationActionFromJSON,
  FanRemixContestEndingSoonNotificationActionFromJSONTyped,
  FanRemixContestEndingSoonNotificationActionToJSON,
  instanceOfFanRemixContestEndingSoonNotificationActionData,
  FanRemixContestEndingSoonNotificationActionDataFromJSON,
  FanRemixContestEndingSoonNotificationActionDataFromJSONTyped,
  FanRemixContestEndingSoonNotificationActionDataToJSON,
  instanceOfFanRemixContestStartedNotification,
  FanRemixContestStartedNotificationFromJSON,
  FanRemixContestStartedNotificationFromJSONTyped,
  FanRemixContestStartedNotificationToJSON,
  instanceOfFanRemixContestStartedNotificationAction,
  FanRemixContestStartedNotificationActionFromJSON,
  FanRemixContestStartedNotificationActionFromJSONTyped,
  FanRemixContestStartedNotificationActionToJSON,
  instanceOfFanRemixContestStartedNotificationActionData,
  FanRemixContestStartedNotificationActionDataFromJSON,
  FanRemixContestStartedNotificationActionDataFromJSONTyped,
  FanRemixContestStartedNotificationActionDataToJSON,
  instanceOfFanRemixContestWinnersSelectedNotification,
  FanRemixContestWinnersSelectedNotificationFromJSON,
  FanRemixContestWinnersSelectedNotificationFromJSONTyped,
  FanRemixContestWinnersSelectedNotificationToJSON,
  instanceOfFanRemixContestWinnersSelectedNotificationAction,
  FanRemixContestWinnersSelectedNotificationActionFromJSON,
  FanRemixContestWinnersSelectedNotificationActionFromJSONTyped,
  FanRemixContestWinnersSelectedNotificationActionToJSON,
  instanceOfFanRemixContestWinnersSelectedNotificationActionData,
  FanRemixContestWinnersSelectedNotificationActionDataFromJSON,
  FanRemixContestWinnersSelectedNotificationActionDataFromJSONTyped,
  FanRemixContestWinnersSelectedNotificationActionDataToJSON,
  instanceOfFavorite,
  FavoriteFromJSON,
  FavoriteFromJSONTyped,
  FavoriteToJSON,
  instanceOfFieldVisibility,
  FieldVisibilityFromJSON,
  FieldVisibilityFromJSONTyped,
  FieldVisibilityToJSON,
  instanceOfFollowGate,
  FollowGateFromJSON,
  FollowGateFromJSONTyped,
  FollowGateToJSON,
  instanceOfFollowNotification,
  FollowNotificationFromJSON,
  FollowNotificationFromJSONTyped,
  FollowNotificationToJSON,
  instanceOfFollowNotificationAction,
  FollowNotificationActionFromJSON,
  FollowNotificationActionFromJSONTyped,
  FollowNotificationActionToJSON,
  instanceOfFollowNotificationActionData,
  FollowNotificationActionDataFromJSON,
  FollowNotificationActionDataFromJSONTyped,
  FollowNotificationActionDataToJSON,
  instanceOfFollowingResponse,
  FollowingResponseFromJSON,
  FollowingResponseFromJSONTyped,
  FollowingResponseToJSON,
  instanceOfFollowingResponseFull,
  FollowingResponseFullFromJSON,
  FollowingResponseFullFromJSONTyped,
  FollowingResponseFullToJSON,
  instanceOfFullBulkSubscribersResponse,
  FullBulkSubscribersResponseFromJSON,
  FullBulkSubscribersResponseFromJSONTyped,
  FullBulkSubscribersResponseToJSON,
  instanceOfFullFollowersResponse,
  FullFollowersResponseFromJSON,
  FullFollowersResponseFromJSONTyped,
  FullFollowersResponseToJSON,
  instanceOfFullGetSupportedUsers,
  FullGetSupportedUsersFromJSON,
  FullGetSupportedUsersFromJSONTyped,
  FullGetSupportedUsersToJSON,
  instanceOfFullGetSupporter,
  FullGetSupporterFromJSON,
  FullGetSupporterFromJSONTyped,
  FullGetSupporterToJSON,
  instanceOfFullGetSupporters,
  FullGetSupportersFromJSON,
  FullGetSupportersFromJSONTyped,
  FullGetSupportersToJSON,
  instanceOfFullGetSupporting,
  FullGetSupportingFromJSON,
  FullGetSupportingFromJSONTyped,
  FullGetSupportingToJSON,
  instanceOfFullMutualFollowersResponse,
  FullMutualFollowersResponseFromJSON,
  FullMutualFollowersResponseFromJSONTyped,
  FullMutualFollowersResponseToJSON,
  instanceOfFullPlaylistResponse,
  FullPlaylistResponseFromJSON,
  FullPlaylistResponseFromJSONTyped,
  FullPlaylistResponseToJSON,
  instanceOfFullPlaylistTracksResponse,
  FullPlaylistTracksResponseFromJSON,
  FullPlaylistTracksResponseFromJSONTyped,
  FullPlaylistTracksResponseToJSON,
  instanceOfFullPurchasersResponse,
  FullPurchasersResponseFromJSON,
  FullPurchasersResponseFromJSONTyped,
  FullPurchasersResponseToJSON,
  instanceOfFullRemix,
  FullRemixFromJSON,
  FullRemixFromJSONTyped,
  FullRemixToJSON,
  instanceOfFullRemixParent,
  FullRemixParentFromJSON,
  FullRemixParentFromJSONTyped,
  FullRemixParentToJSON,
  instanceOfFullRemixersResponse,
  FullRemixersResponseFromJSON,
  FullRemixersResponseFromJSONTyped,
  FullRemixersResponseToJSON,
  instanceOfFullReposts,
  FullRepostsFromJSON,
  FullRepostsFromJSONTyped,
  FullRepostsToJSON,
  instanceOfFullSubscribersResponse,
  FullSubscribersResponseFromJSON,
  FullSubscribersResponseFromJSONTyped,
  FullSubscribersResponseToJSON,
  instanceOfFullSupporter,
  FullSupporterFromJSON,
  FullSupporterFromJSONTyped,
  FullSupporterToJSON,
  instanceOfFullSupporting,
  FullSupportingFromJSON,
  FullSupportingFromJSONTyped,
  FullSupportingToJSON,
  instanceOfFullTip,
  FullTipFromJSON,
  FullTipFromJSONTyped,
  FullTipToJSON,
  instanceOfFullTopListener,
  FullTopListenerFromJSON,
  FullTopListenerFromJSONTyped,
  FullTopListenerToJSON,
  instanceOfFullTrackResponse,
  FullTrackResponseFromJSON,
  FullTrackResponseFromJSONTyped,
  FullTrackResponseToJSON,
  instanceOfFullTracks,
  FullTracksFromJSON,
  FullTracksFromJSONTyped,
  FullTracksToJSON,
  instanceOfFullTracksResponse,
  FullTracksResponseFromJSON,
  FullTracksResponseFromJSONTyped,
  FullTracksResponseToJSON,
  instanceOfFullTrendingPlaylistsResponse,
  FullTrendingPlaylistsResponseFromJSON,
  FullTrendingPlaylistsResponseFromJSONTyped,
  FullTrendingPlaylistsResponseToJSON,
  instanceOfFullUserResponse,
  FullUserResponseFromJSON,
  FullUserResponseFromJSONTyped,
  FullUserResponseToJSON,
  instanceOfGetTipsResponse,
  GetTipsResponseFromJSON,
  GetTipsResponseFromJSONTyped,
  GetTipsResponseToJSON,
  instanceOfGrant,
  GrantFromJSON,
  GrantFromJSONTyped,
  GrantToJSON,
  instanceOfHistoryResponseFull,
  HistoryResponseFullFromJSON,
  HistoryResponseFullFromJSONTyped,
  HistoryResponseFullToJSON,
  instanceOfListenStreakReminderNotification,
  ListenStreakReminderNotificationFromJSON,
  ListenStreakReminderNotificationFromJSONTyped,
  ListenStreakReminderNotificationToJSON,
  instanceOfListenStreakReminderNotificationAction,
  ListenStreakReminderNotificationActionFromJSON,
  ListenStreakReminderNotificationActionFromJSONTyped,
  ListenStreakReminderNotificationActionToJSON,
  instanceOfListenStreakReminderNotificationActionData,
  ListenStreakReminderNotificationActionDataFromJSON,
  ListenStreakReminderNotificationActionDataFromJSONTyped,
  ListenStreakReminderNotificationActionDataToJSON,
  instanceOfManagedUser,
  ManagedUserFromJSON,
  ManagedUserFromJSONTyped,
  ManagedUserToJSON,
  instanceOfManagedUsersResponse,
  ManagedUsersResponseFromJSON,
  ManagedUsersResponseFromJSONTyped,
  ManagedUsersResponseToJSON,
  instanceOfManagersResponse,
  ManagersResponseFromJSON,
  ManagersResponseFromJSONTyped,
  ManagersResponseToJSON,
  instanceOfMilestoneNotification,
  MilestoneNotificationFromJSON,
  MilestoneNotificationFromJSONTyped,
  MilestoneNotificationToJSON,
  instanceOfMilestoneNotificationAction,
  MilestoneNotificationActionFromJSON,
  MilestoneNotificationActionFromJSONTyped,
  MilestoneNotificationActionToJSON,
  MilestoneNotificationActionDataFromJSON,
  MilestoneNotificationActionDataFromJSONTyped,
  MilestoneNotificationActionDataToJSON,
  NftCollectionChainEnum,
  NftCollectionStandardEnum,
  instanceOfNftCollection,
  NftCollectionFromJSON,
  NftCollectionFromJSONTyped,
  NftCollectionToJSON,
  instanceOfNftGate,
  NftGateFromJSON,
  NftGateFromJSONTyped,
  NftGateToJSON,
  NotificationFromJSON,
  NotificationFromJSONTyped,
  NotificationToJSON,
  instanceOfNotifications,
  NotificationsFromJSON,
  NotificationsFromJSONTyped,
  NotificationsToJSON,
  instanceOfNotificationsResponse,
  NotificationsResponseFromJSON,
  NotificationsResponseFromJSONTyped,
  NotificationsResponseToJSON,
  instanceOfPlaylistAddedTimestamp,
  PlaylistAddedTimestampFromJSON,
  PlaylistAddedTimestampFromJSONTyped,
  PlaylistAddedTimestampToJSON,
  instanceOfPlaylistArtwork,
  PlaylistArtworkFromJSON,
  PlaylistArtworkFromJSONTyped,
  PlaylistArtworkToJSON,
  instanceOfPlaylistArtworkFull,
  PlaylistArtworkFullFromJSON,
  PlaylistArtworkFullFromJSONTyped,
  PlaylistArtworkFullToJSON,
  instanceOfPlaylistFeedItem,
  PlaylistFeedItemFromJSON,
  PlaylistFeedItemFromJSONTyped,
  PlaylistFeedItemToJSON,
  instanceOfPlaylistFull,
  PlaylistFullFromJSON,
  PlaylistFullFromJSONTyped,
  PlaylistFullToJSON,
  instanceOfPlaylistFullWithoutTracks,
  PlaylistFullWithoutTracksFromJSON,
  PlaylistFullWithoutTracksFromJSONTyped,
  PlaylistFullWithoutTracksToJSON,
  instanceOfPlaylistLibrary,
  PlaylistLibraryFromJSON,
  PlaylistLibraryFromJSONTyped,
  PlaylistLibraryToJSON,
  instanceOfPlaylistMilestoneNotificationActionData,
  PlaylistMilestoneNotificationActionDataFromJSON,
  PlaylistMilestoneNotificationActionDataFromJSONTyped,
  PlaylistMilestoneNotificationActionDataToJSON,
  instanceOfPlaylistUpdate,
  PlaylistUpdateFromJSON,
  PlaylistUpdateFromJSONTyped,
  PlaylistUpdateToJSON,
  instanceOfPlaylistUpdates,
  PlaylistUpdatesFromJSON,
  PlaylistUpdatesFromJSONTyped,
  PlaylistUpdatesToJSON,
  instanceOfPlaylistUpdatesResponse,
  PlaylistUpdatesResponseFromJSON,
  PlaylistUpdatesResponseFromJSONTyped,
  PlaylistUpdatesResponseToJSON,
  instanceOfPlaylistsResponseFull,
  PlaylistsResponseFullFromJSON,
  PlaylistsResponseFullFromJSONTyped,
  PlaylistsResponseFullToJSON,
  instanceOfProfilePicture,
  ProfilePictureFromJSON,
  ProfilePictureFromJSONTyped,
  ProfilePictureToJSON,
  instanceOfProfilePictureFull,
  ProfilePictureFullFromJSON,
  ProfilePictureFullFromJSONTyped,
  ProfilePictureFullToJSON,
  instanceOfPurchase,
  PurchaseFromJSON,
  PurchaseFromJSONTyped,
  PurchaseToJSON,
  instanceOfPurchaseGate,
  PurchaseGateFromJSON,
  PurchaseGateFromJSONTyped,
  PurchaseGateToJSON,
  instanceOfPurchaseSplit,
  PurchaseSplitFromJSON,
  PurchaseSplitFromJSONTyped,
  PurchaseSplitToJSON,
  instanceOfPurchasersCountResponse,
  PurchasersCountResponseFromJSON,
  PurchasersCountResponseFromJSONTyped,
  PurchasersCountResponseToJSON,
  instanceOfPurchasesCountResponse,
  PurchasesCountResponseFromJSON,
  PurchasesCountResponseFromJSONTyped,
  PurchasesCountResponseToJSON,
  instanceOfPurchasesResponse,
  PurchasesResponseFromJSON,
  PurchasesResponseFromJSONTyped,
  PurchasesResponseToJSON,
  instanceOfReaction,
  ReactionFromJSON,
  ReactionFromJSONTyped,
  ReactionToJSON,
  instanceOfReactionNotification,
  ReactionNotificationFromJSON,
  ReactionNotificationFromJSONTyped,
  ReactionNotificationToJSON,
  instanceOfReactionNotificationAction,
  ReactionNotificationActionFromJSON,
  ReactionNotificationActionFromJSONTyped,
  ReactionNotificationActionToJSON,
  instanceOfReactionNotificationActionData,
  ReactionNotificationActionDataFromJSON,
  ReactionNotificationActionDataFromJSONTyped,
  ReactionNotificationActionDataToJSON,
  instanceOfReactions,
  ReactionsFromJSON,
  ReactionsFromJSONTyped,
  ReactionsToJSON,
  instanceOfReceiveTipNotification,
  ReceiveTipNotificationFromJSON,
  ReceiveTipNotificationFromJSONTyped,
  ReceiveTipNotificationToJSON,
  instanceOfReceiveTipNotificationAction,
  ReceiveTipNotificationActionFromJSON,
  ReceiveTipNotificationActionFromJSONTyped,
  ReceiveTipNotificationActionToJSON,
  instanceOfReceiveTipNotificationActionData,
  ReceiveTipNotificationActionDataFromJSON,
  ReceiveTipNotificationActionDataFromJSONTyped,
  ReceiveTipNotificationActionDataToJSON,
  instanceOfRelated,
  RelatedFromJSON,
  RelatedFromJSONTyped,
  RelatedToJSON,
  instanceOfRelatedArtistResponseFull,
  RelatedArtistResponseFullFromJSON,
  RelatedArtistResponseFullFromJSONTyped,
  RelatedArtistResponseFullToJSON,
  instanceOfRemixNotification,
  RemixNotificationFromJSON,
  RemixNotificationFromJSONTyped,
  RemixNotificationToJSON,
  instanceOfRemixNotificationAction,
  RemixNotificationActionFromJSON,
  RemixNotificationActionFromJSONTyped,
  RemixNotificationActionToJSON,
  instanceOfRemixNotificationActionData,
  RemixNotificationActionDataFromJSON,
  RemixNotificationActionDataFromJSONTyped,
  RemixNotificationActionDataToJSON,
  instanceOfRemixablesResponse,
  RemixablesResponseFromJSON,
  RemixablesResponseFromJSONTyped,
  RemixablesResponseToJSON,
  instanceOfRemixersCountResponse,
  RemixersCountResponseFromJSON,
  RemixersCountResponseFromJSONTyped,
  RemixersCountResponseToJSON,
  instanceOfRemixesResponse,
  RemixesResponseFromJSON,
  RemixesResponseFromJSONTyped,
  RemixesResponseToJSON,
  instanceOfRemixesResponseFull,
  RemixesResponseFullFromJSON,
  RemixesResponseFullFromJSONTyped,
  RemixesResponseFullToJSON,
  instanceOfRemixingResponse,
  RemixingResponseFromJSON,
  RemixingResponseFromJSONTyped,
  RemixingResponseToJSON,
  instanceOfReplyComment,
  ReplyCommentFromJSON,
  ReplyCommentFromJSONTyped,
  ReplyCommentToJSON,
  instanceOfRepost,
  RepostFromJSON,
  RepostFromJSONTyped,
  RepostToJSON,
  instanceOfRepostNotification,
  RepostNotificationFromJSON,
  RepostNotificationFromJSONTyped,
  RepostNotificationToJSON,
  instanceOfRepostNotificationAction,
  RepostNotificationActionFromJSON,
  RepostNotificationActionFromJSONTyped,
  RepostNotificationActionToJSON,
  RepostNotificationActionDataTypeEnum,
  instanceOfRepostNotificationActionData,
  RepostNotificationActionDataFromJSON,
  RepostNotificationActionDataFromJSONTyped,
  RepostNotificationActionDataToJSON,
  instanceOfRepostOfRepostNotification,
  RepostOfRepostNotificationFromJSON,
  RepostOfRepostNotificationFromJSONTyped,
  RepostOfRepostNotificationToJSON,
  instanceOfRepostOfRepostNotificationAction,
  RepostOfRepostNotificationActionFromJSON,
  RepostOfRepostNotificationActionFromJSONTyped,
  RepostOfRepostNotificationActionToJSON,
  RepostOfRepostNotificationActionDataTypeEnum,
  instanceOfRepostOfRepostNotificationActionData,
  RepostOfRepostNotificationActionDataFromJSON,
  RepostOfRepostNotificationActionDataFromJSONTyped,
  RepostOfRepostNotificationActionDataToJSON,
  instanceOfRequestManagerNotification,
  RequestManagerNotificationFromJSON,
  RequestManagerNotificationFromJSONTyped,
  RequestManagerNotificationToJSON,
  instanceOfRequestManagerNotificationAction,
  RequestManagerNotificationActionFromJSON,
  RequestManagerNotificationActionFromJSONTyped,
  RequestManagerNotificationActionToJSON,
  instanceOfRequestManagerNotificationActionData,
  RequestManagerNotificationActionDataFromJSON,
  RequestManagerNotificationActionDataFromJSONTyped,
  RequestManagerNotificationActionDataToJSON,
  instanceOfSaveNotification,
  SaveNotificationFromJSON,
  SaveNotificationFromJSONTyped,
  SaveNotificationToJSON,
  instanceOfSaveNotificationAction,
  SaveNotificationActionFromJSON,
  SaveNotificationActionFromJSONTyped,
  SaveNotificationActionToJSON,
  SaveNotificationActionDataTypeEnum,
  instanceOfSaveNotificationActionData,
  SaveNotificationActionDataFromJSON,
  SaveNotificationActionDataFromJSONTyped,
  SaveNotificationActionDataToJSON,
  instanceOfSaveOfRepostNotification,
  SaveOfRepostNotificationFromJSON,
  SaveOfRepostNotificationFromJSONTyped,
  SaveOfRepostNotificationToJSON,
  instanceOfSaveOfRepostNotificationAction,
  SaveOfRepostNotificationActionFromJSON,
  SaveOfRepostNotificationActionFromJSONTyped,
  SaveOfRepostNotificationActionToJSON,
  SaveOfRepostNotificationActionDataTypeEnum,
  instanceOfSaveOfRepostNotificationActionData,
  SaveOfRepostNotificationActionDataFromJSON,
  SaveOfRepostNotificationActionDataFromJSONTyped,
  SaveOfRepostNotificationActionDataToJSON,
  instanceOfSearchAutocompleteResponse,
  SearchAutocompleteResponseFromJSON,
  SearchAutocompleteResponseFromJSONTyped,
  SearchAutocompleteResponseToJSON,
  instanceOfSearchFullResponse,
  SearchFullResponseFromJSON,
  SearchFullResponseFromJSONTyped,
  SearchFullResponseToJSON,
  instanceOfSearchModel,
  SearchModelFromJSON,
  SearchModelFromJSONTyped,
  SearchModelToJSON,
  instanceOfSearchPlaylistFull,
  SearchPlaylistFullFromJSON,
  SearchPlaylistFullFromJSONTyped,
  SearchPlaylistFullToJSON,
  instanceOfSearchTrackFull,
  SearchTrackFullFromJSON,
  SearchTrackFullFromJSONTyped,
  SearchTrackFullToJSON,
  instanceOfSendTipNotification,
  SendTipNotificationFromJSON,
  SendTipNotificationFromJSONTyped,
  SendTipNotificationToJSON,
  instanceOfSendTipNotificationAction,
  SendTipNotificationActionFromJSON,
  SendTipNotificationActionFromJSONTyped,
  SendTipNotificationActionToJSON,
  instanceOfSendTipNotificationActionData,
  SendTipNotificationActionDataFromJSON,
  SendTipNotificationActionDataFromJSONTyped,
  SendTipNotificationActionDataToJSON,
  instanceOfStemFull,
  StemFullFromJSON,
  StemFullFromJSONTyped,
  StemFullToJSON,
  instanceOfStemParent,
  StemParentFromJSON,
  StemParentFromJSONTyped,
  StemParentToJSON,
  instanceOfStemsResponse,
  StemsResponseFromJSON,
  StemsResponseFromJSONTyped,
  StemsResponseToJSON,
  instanceOfSupporterDethronedNotification,
  SupporterDethronedNotificationFromJSON,
  SupporterDethronedNotificationFromJSONTyped,
  SupporterDethronedNotificationToJSON,
  instanceOfSupporterDethronedNotificationAction,
  SupporterDethronedNotificationActionFromJSON,
  SupporterDethronedNotificationActionFromJSONTyped,
  SupporterDethronedNotificationActionToJSON,
  instanceOfSupporterDethronedNotificationActionData,
  SupporterDethronedNotificationActionDataFromJSON,
  SupporterDethronedNotificationActionDataFromJSONTyped,
  SupporterDethronedNotificationActionDataToJSON,
  instanceOfSupporterRankUpNotification,
  SupporterRankUpNotificationFromJSON,
  SupporterRankUpNotificationFromJSONTyped,
  SupporterRankUpNotificationToJSON,
  instanceOfSupporterRankUpNotificationAction,
  SupporterRankUpNotificationActionFromJSON,
  SupporterRankUpNotificationActionFromJSONTyped,
  SupporterRankUpNotificationActionToJSON,
  instanceOfSupporterRankUpNotificationActionData,
  SupporterRankUpNotificationActionDataFromJSON,
  SupporterRankUpNotificationActionDataFromJSONTyped,
  SupporterRankUpNotificationActionDataToJSON,
  instanceOfSupporterReference,
  SupporterReferenceFromJSON,
  SupporterReferenceFromJSONTyped,
  SupporterReferenceToJSON,
  instanceOfTastemakerNotification,
  TastemakerNotificationFromJSON,
  TastemakerNotificationFromJSONTyped,
  TastemakerNotificationToJSON,
  instanceOfTastemakerNotificationAction,
  TastemakerNotificationActionFromJSON,
  TastemakerNotificationActionFromJSONTyped,
  TastemakerNotificationActionToJSON,
  instanceOfTastemakerNotificationActionData,
  TastemakerNotificationActionDataFromJSON,
  TastemakerNotificationActionDataFromJSONTyped,
  TastemakerNotificationActionDataToJSON,
  instanceOfTierChangeNotification,
  TierChangeNotificationFromJSON,
  TierChangeNotificationFromJSONTyped,
  TierChangeNotificationToJSON,
  instanceOfTierChangeNotificationAction,
  TierChangeNotificationActionFromJSON,
  TierChangeNotificationActionFromJSONTyped,
  TierChangeNotificationActionToJSON,
  instanceOfTierChangeNotificationActionData,
  TierChangeNotificationActionDataFromJSON,
  TierChangeNotificationActionDataFromJSONTyped,
  TierChangeNotificationActionDataToJSON,
  instanceOfTipGate,
  TipGateFromJSON,
  TipGateFromJSONTyped,
  TipGateToJSON,
  instanceOfTokenGate,
  TokenGateFromJSON,
  TokenGateFromJSONTyped,
  TokenGateToJSON,
  instanceOfTopGenreUsersResponseFull,
  TopGenreUsersResponseFullFromJSON,
  TopGenreUsersResponseFullFromJSONTyped,
  TopGenreUsersResponseFullToJSON,
  instanceOfTopUsersResponseFull,
  TopUsersResponseFullFromJSON,
  TopUsersResponseFullFromJSONTyped,
  TopUsersResponseFullToJSON,
  TrackActivityFullItemTypeEnum,
  instanceOfTrackActivityFull,
  TrackActivityFullFromJSON,
  TrackActivityFullFromJSONTyped,
  TrackActivityFullToJSON,
  instanceOfTrackAddedToPlaylistNotification,
  TrackAddedToPlaylistNotificationFromJSON,
  TrackAddedToPlaylistNotificationFromJSONTyped,
  TrackAddedToPlaylistNotificationToJSON,
  instanceOfTrackAddedToPlaylistNotificationAction,
  TrackAddedToPlaylistNotificationActionFromJSON,
  TrackAddedToPlaylistNotificationActionFromJSONTyped,
  TrackAddedToPlaylistNotificationActionToJSON,
  instanceOfTrackAddedToPlaylistNotificationActionData,
  TrackAddedToPlaylistNotificationActionDataFromJSON,
  TrackAddedToPlaylistNotificationActionDataFromJSONTyped,
  TrackAddedToPlaylistNotificationActionDataToJSON,
  instanceOfTrackAddedToPurchasedAlbumNotification,
  TrackAddedToPurchasedAlbumNotificationFromJSON,
  TrackAddedToPurchasedAlbumNotificationFromJSONTyped,
  TrackAddedToPurchasedAlbumNotificationToJSON,
  instanceOfTrackAddedToPurchasedAlbumNotificationAction,
  TrackAddedToPurchasedAlbumNotificationActionFromJSON,
  TrackAddedToPurchasedAlbumNotificationActionFromJSONTyped,
  TrackAddedToPurchasedAlbumNotificationActionToJSON,
  instanceOfTrackAddedToPurchasedAlbumNotificationActionData,
  TrackAddedToPurchasedAlbumNotificationActionDataFromJSON,
  TrackAddedToPurchasedAlbumNotificationActionDataFromJSONTyped,
  TrackAddedToPurchasedAlbumNotificationActionDataToJSON,
  instanceOfTrackArtworkFull,
  TrackArtworkFullFromJSON,
  TrackArtworkFullFromJSONTyped,
  TrackArtworkFullToJSON,
  instanceOfTrackCommentsResponseFull,
  TrackCommentsResponseFullFromJSON,
  TrackCommentsResponseFullFromJSONTyped,
  TrackCommentsResponseFullToJSON,
  instanceOfTrackFavoritesResponseFull,
  TrackFavoritesResponseFullFromJSON,
  TrackFavoritesResponseFullFromJSONTyped,
  TrackFavoritesResponseFullToJSON,
  instanceOfTrackFeedItem,
  TrackFeedItemFromJSON,
  TrackFeedItemFromJSONTyped,
  TrackFeedItemToJSON,
  instanceOfTrackFull,
  TrackFullFromJSON,
  TrackFullFromJSONTyped,
  TrackFullToJSON,
  instanceOfTrackId,
  TrackIdFromJSON,
  TrackIdFromJSONTyped,
  TrackIdToJSON,
  instanceOfTrackLibraryResponseFull,
  TrackLibraryResponseFullFromJSON,
  TrackLibraryResponseFullFromJSONTyped,
  TrackLibraryResponseFullToJSON,
  instanceOfTrackMilestoneNotificationActionData,
  TrackMilestoneNotificationActionDataFromJSON,
  TrackMilestoneNotificationActionDataFromJSONTyped,
  TrackMilestoneNotificationActionDataToJSON,
  instanceOfTrackRepostsResponseFull,
  TrackRepostsResponseFullFromJSON,
  TrackRepostsResponseFullFromJSONTyped,
  TrackRepostsResponseFullToJSON,
  instanceOfTrackSegment,
  TrackSegmentFromJSON,
  TrackSegmentFromJSONTyped,
  TrackSegmentToJSON,
  instanceOfTransactionDetails,
  TransactionDetailsFromJSON,
  TransactionDetailsFromJSONTyped,
  TransactionDetailsToJSON,
  instanceOfTransactionHistoryCountResponse,
  TransactionHistoryCountResponseFromJSON,
  TransactionHistoryCountResponseFromJSONTyped,
  TransactionHistoryCountResponseToJSON,
  instanceOfTransactionHistoryResponse,
  TransactionHistoryResponseFromJSON,
  TransactionHistoryResponseFromJSONTyped,
  TransactionHistoryResponseToJSON,
  instanceOfTrendingIdsResponse,
  TrendingIdsResponseFromJSON,
  TrendingIdsResponseFromJSONTyped,
  TrendingIdsResponseToJSON,
  instanceOfTrendingNotification,
  TrendingNotificationFromJSON,
  TrendingNotificationFromJSONTyped,
  TrendingNotificationToJSON,
  instanceOfTrendingNotificationAction,
  TrendingNotificationActionFromJSON,
  TrendingNotificationActionFromJSONTyped,
  TrendingNotificationActionToJSON,
  TrendingNotificationActionDataTimeRangeEnum,
  instanceOfTrendingNotificationActionData,
  TrendingNotificationActionDataFromJSON,
  TrendingNotificationActionDataFromJSONTyped,
  TrendingNotificationActionDataToJSON,
  instanceOfTrendingPlaylistNotification,
  TrendingPlaylistNotificationFromJSON,
  TrendingPlaylistNotificationFromJSONTyped,
  TrendingPlaylistNotificationToJSON,
  instanceOfTrendingPlaylistNotificationAction,
  TrendingPlaylistNotificationActionFromJSON,
  TrendingPlaylistNotificationActionFromJSONTyped,
  TrendingPlaylistNotificationActionToJSON,
  TrendingPlaylistNotificationActionDataTimeRangeEnum,
  instanceOfTrendingPlaylistNotificationActionData,
  TrendingPlaylistNotificationActionDataFromJSON,
  TrendingPlaylistNotificationActionDataFromJSONTyped,
  TrendingPlaylistNotificationActionDataToJSON,
  instanceOfTrendingTimesIds,
  TrendingTimesIdsFromJSON,
  TrendingTimesIdsFromJSONTyped,
  TrendingTimesIdsToJSON,
  instanceOfTrendingUndergroundNotification,
  TrendingUndergroundNotificationFromJSON,
  TrendingUndergroundNotificationFromJSONTyped,
  TrendingUndergroundNotificationToJSON,
  instanceOfTrendingUndergroundNotificationAction,
  TrendingUndergroundNotificationActionFromJSON,
  TrendingUndergroundNotificationActionFromJSONTyped,
  TrendingUndergroundNotificationActionToJSON,
  TrendingUndergroundNotificationActionDataTimeRangeEnum,
  instanceOfTrendingUndergroundNotificationActionData,
  TrendingUndergroundNotificationActionDataFromJSON,
  TrendingUndergroundNotificationActionDataFromJSONTyped,
  TrendingUndergroundNotificationActionDataToJSON,
  instanceOfUpdateCoinRequest,
  UpdateCoinRequestFromJSON,
  UpdateCoinRequestFromJSONTyped,
  UpdateCoinRequestToJSON,
  instanceOfUpdateCoinResponse,
  UpdateCoinResponseFromJSON,
  UpdateCoinResponseFromJSONTyped,
  UpdateCoinResponseToJSON,
  instanceOfUrlWithMirrors,
  UrlWithMirrorsFromJSON,
  UrlWithMirrorsFromJSONTyped,
  UrlWithMirrorsToJSON,
  instanceOfUsdcGate,
  UsdcGateFromJSON,
  UsdcGateFromJSONTyped,
  UsdcGateToJSON,
  instanceOfUsdcPurchaseBuyerNotification,
  UsdcPurchaseBuyerNotificationFromJSON,
  UsdcPurchaseBuyerNotificationFromJSONTyped,
  UsdcPurchaseBuyerNotificationToJSON,
  instanceOfUsdcPurchaseBuyerNotificationAction,
  UsdcPurchaseBuyerNotificationActionFromJSON,
  UsdcPurchaseBuyerNotificationActionFromJSONTyped,
  UsdcPurchaseBuyerNotificationActionToJSON,
  instanceOfUsdcPurchaseBuyerNotificationActionData,
  UsdcPurchaseBuyerNotificationActionDataFromJSON,
  UsdcPurchaseBuyerNotificationActionDataFromJSONTyped,
  UsdcPurchaseBuyerNotificationActionDataToJSON,
  instanceOfUsdcPurchaseSellerNotification,
  UsdcPurchaseSellerNotificationFromJSON,
  UsdcPurchaseSellerNotificationFromJSONTyped,
  UsdcPurchaseSellerNotificationToJSON,
  instanceOfUsdcPurchaseSellerNotificationAction,
  UsdcPurchaseSellerNotificationActionFromJSON,
  UsdcPurchaseSellerNotificationActionFromJSONTyped,
  UsdcPurchaseSellerNotificationActionToJSON,
  instanceOfUsdcPurchaseSellerNotificationActionData,
  UsdcPurchaseSellerNotificationActionDataFromJSON,
  UsdcPurchaseSellerNotificationActionDataFromJSONTyped,
  UsdcPurchaseSellerNotificationActionDataToJSON,
  instanceOfUserAccountResponseFull,
  UserAccountResponseFullFromJSON,
  UserAccountResponseFullFromJSONTyped,
  UserAccountResponseFullToJSON,
  instanceOfUserCommentsResponseFull,
  UserCommentsResponseFullFromJSON,
  UserCommentsResponseFullFromJSONTyped,
  UserCommentsResponseFullToJSON,
  UserFeedItemFromJSON,
  UserFeedItemFromJSONTyped,
  UserFeedItemToJSON,
  instanceOfUserFeedResponse,
  UserFeedResponseFromJSON,
  UserFeedResponseFromJSONTyped,
  UserFeedResponseToJSON,
  instanceOfUserFull,
  UserFullFromJSON,
  UserFullFromJSONTyped,
  UserFullToJSON,
  instanceOfUserFullArtistCoinBadge,
  UserFullArtistCoinBadgeFromJSON,
  UserFullArtistCoinBadgeFromJSONTyped,
  UserFullArtistCoinBadgeToJSON,
  instanceOfUserManager,
  UserManagerFromJSON,
  UserManagerFromJSONTyped,
  UserManagerToJSON,
  instanceOfUserMilestoneNotificationActionData,
  UserMilestoneNotificationActionDataFromJSON,
  UserMilestoneNotificationActionDataFromJSONTyped,
  UserMilestoneNotificationActionDataToJSON,
  instanceOfUserSubscribers,
  UserSubscribersFromJSON,
  UserSubscribersFromJSONTyped,
  UserSubscribersToJSON,
  instanceOfVersionMetadata,
  VersionMetadataFromJSON,
  VersionMetadataFromJSONTyped,
  VersionMetadataToJSON
});
var CreateGrantSchema = z.object({
  userId: HashId,
  appApiKey: z.custom((data) => {
    return isApiKeyValid(data);
  })
});
var AddManagerSchema = z.object({
  userId: HashId,
  managerUserId: HashId
});
var RemoveManagerSchema = z.object({
  userId: HashId,
  managerUserId: HashId
});
var RevokeGrantSchema = z.object({
  userId: HashId,
  appApiKey: z.custom((data) => {
    return isApiKeyValid(data);
  })
});
var ApproveGrantSchema = z.object({
  userId: HashId,
  grantorUserId: HashId
});
var GrantsApi = class {
  // eslint-disable-next-line no-useless-constructor
  constructor(_config, entityManager, usersApi) {
    _defineProperty$1(this, "entityManager", void 0);
    _defineProperty$1(this, "usersApi", void 0);
    this.entityManager = entityManager;
    this.usersApi = usersApi;
  }
  /**
   * When user authorizes app to perform actions on their behalf.
   * For user-to-user grants, use `addManager`.
   */
  async createGrant(params) {
    const {
      userId,
      appApiKey
    } = await parseParams("createGrant", CreateGrantSchema)(params);
    return await this.entityManager.manageEntity({
      userId,
      entityType: EntityType.GRANT,
      entityId: 0,
      action: Action.CREATE,
      metadata: JSON.stringify({
        grantee_address: `0x${appApiKey}`
      })
    });
  }
  /**
   * When user authorizes another user to perform actions on their behalf.
   * The grant has to be approved by the proposed manager.
   */
  async addManager(params) {
    const {
      userId,
      managerUserId
    } = await parseParams("addManager", AddManagerSchema)(params);
    let managerUser;
    try {
      managerUser = (await this.usersApi.getUser({
        id: encodeHashId(managerUserId)
      })).data;
      if (!managerUser) {
        throw new Error();
      }
    } catch (e) {
      throw new Error("`managerUserId` passed to `addManager` method is invalid.");
    }
    return await this.entityManager.manageEntity({
      userId,
      entityType: EntityType.GRANT,
      entityId: 0,
      action: Action.CREATE,
      metadata: JSON.stringify({
        grantee_address: managerUser.ercWallet
      })
    });
  }
  /**
   * Revokes a user's manager access - can either be called by the manager user or the child user
   */
  async removeManager(params) {
    const {
      userId,
      managerUserId
    } = await parseParams("addManager", AddManagerSchema)(params);
    let managerUser;
    try {
      managerUser = (await this.usersApi.getUser({
        id: encodeHashId(managerUserId)
      })).data;
      if (!managerUser) {
        throw new Error();
      }
    } catch (e) {
      throw new Error("`managerUserId` passed to `removeManager` method is invalid.");
    }
    return await this.entityManager.manageEntity({
      userId,
      entityType: EntityType.GRANT,
      entityId: 0,
      action: Action.DELETE,
      metadata: JSON.stringify({
        grantee_address: managerUser.ercWallet
      })
    });
  }
  /**
   * When user revokes an app's authorization to perform actions on their behalf
   */
  async revokeGrant(params) {
    const {
      userId,
      appApiKey
    } = await parseParams("revokeGrant", RevokeGrantSchema)(params);
    return await this.entityManager.manageEntity({
      userId,
      entityType: EntityType.GRANT,
      entityId: 0,
      action: Action.DELETE,
      metadata: JSON.stringify({
        grantee_address: `0x${appApiKey}`
      })
    });
  }
  /**
   * Approve manager request
   */
  async approveGrant(params) {
    const {
      userId,
      grantorUserId
    } = await parseParams("approveGrant", ApproveGrantSchema)(params);
    return await this.entityManager.manageEntity({
      userId,
      entityType: EntityType.GRANT,
      entityId: 0,
      action: Action.APPROVE,
      metadata: JSON.stringify({
        grantor_user_id: grantorUserId
      })
    });
  }
};
var MarkAllNotificationsAsViewedSchema = z.object({
  userId: HashId
});
var UpdatePlaylistLastViewedAtSchema = z.object({
  playlistId: HashId,
  userId: HashId
});
z.object({
  data: z.any()
});
var NotificationsApi = class {
  // eslint-disable-next-line no-useless-constructor
  constructor(_config, entityManager) {
    _defineProperty$1(this, "entityManager", void 0);
    this.entityManager = entityManager;
  }
  /**
   * When a user views all of their notifications
   */
  async markAllNotificationsAsViewed(params) {
    const {
      userId
    } = await parseParams("markAllNotificationsAsViewed", MarkAllNotificationsAsViewedSchema)(params);
    return await this.entityManager.manageEntity({
      userId,
      entityType: EntityType.NOTIFICATION,
      // In this case, we are the entityId since we are marking our own notifications as viewed
      entityId: userId,
      action: Action.VIEW,
      metadata: ""
    });
  }
  /**
   * When a user views a playlist
   */
  async updatePlaylistLastViewedAt(params) {
    const {
      playlistId,
      userId
    } = await parseParams("updatePlaylistLastViewedAt", UpdatePlaylistLastViewedAtSchema)(params);
    return await this.entityManager.manageEntity({
      userId,
      entityType: EntityType.NOTIFICATION,
      entityId: playlistId,
      action: Action.VIEW_PLAYLIST,
      metadata: ""
    });
  }
};
var ipApi = "https://ipapi.co/json/";
var getLocation = async function() {
  let {
    logger
  } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  try {
    const res = await fetch(ipApi);
    const {
      city,
      region,
      country_name
    } = await res.json();
    return {
      city,
      region,
      // country from res is returned as ISO 2-alpha code and we want
      // full english name.
      country: country_name
    };
  } catch (e) {
    logger === null || logger === void 0 ? void 0 : logger.error(e);
    return null;
  }
};
var TracksApi = class extends TracksApi$2 {
  constructor(configuration, storage, entityManager, logger, claimableTokensClient, paymentRouterClient, solanaRelay, solanaClient) {
    super(configuration);
    _defineProperty$1(this, "storage", void 0);
    _defineProperty$1(this, "entityManager", void 0);
    _defineProperty$1(this, "logger", void 0);
    _defineProperty$1(this, "claimableTokensClient", void 0);
    _defineProperty$1(this, "paymentRouterClient", void 0);
    _defineProperty$1(this, "solanaRelay", void 0);
    _defineProperty$1(this, "solanaClient", void 0);
    _defineProperty$1(this, "trackUploadHelper", void 0);
    this.storage = storage;
    this.entityManager = entityManager;
    this.logger = logger;
    this.claimableTokensClient = claimableTokensClient;
    this.paymentRouterClient = paymentRouterClient;
    this.solanaRelay = solanaRelay;
    this.solanaClient = solanaClient;
    this.trackUploadHelper = new TrackUploadHelper(configuration);
    this.logger = logger.createPrefixedLogger("[tracks-api]");
  }
  /**
   * Get the url of the track's streamable mp3 file
   */
  async getTrackStreamUrl(params) {
    if (params.trackId === null || params.trackId === void 0) {
      throw new RequiredError$1("trackId", "Required parameter params.trackId was null or undefined when calling getTrack.");
    }
    const queryParams = new URLSearchParams();
    if (params.userId) queryParams.append("user_id", params.userId);
    if (params.preview !== void 0) queryParams.append("preview", String(params.preview));
    if (params.userSignature) queryParams.append("user_signature", params.userSignature);
    if (params.userData) queryParams.append("user_data", params.userData);
    if (params.nftAccessSignature) queryParams.append("nft_access_signature", params.nftAccessSignature);
    if (params.skipPlayCount !== void 0) queryParams.append("skip_play_count", String(params.skipPlayCount));
    if (params.apiKey) queryParams.append("api_key", params.apiKey);
    if (params.skipCheck !== void 0) queryParams.append("skip_check", String(params.skipCheck));
    if (params.noRedirect !== void 0) queryParams.append("no_redirect", String(params.noRedirect));
    const path = `/tracks/{track_id}/stream`.replace(`{${"track_id"}}`, encodeURIComponent(String(params.trackId)));
    const queryString = queryParams.toString();
    return `${this.configuration.basePath}${path}${queryString ? "?" + queryString : ""}`;
  }
  /**
   * Get the url of the track's downloadable file
   */
  async getTrackDownloadUrl(params) {
    if (params.trackId === null || params.trackId === void 0) {
      throw new RequiredError$1("trackId", "Required parameter params.trackId was null or undefined when calling getTrack.");
    }
    const queryParams = new URLSearchParams();
    if (params.userId) queryParams.append("user_id", params.userId);
    if (params.userSignature) queryParams.append("user_signature", params.userSignature);
    if (params.userData) queryParams.append("user_data", params.userData);
    if (params.nftAccessSignature) queryParams.append("nft_access_signature", params.nftAccessSignature);
    if (params.filename) queryParams.append("filename", params.filename);
    const path = `/tracks/{track_id}/download`.replace(`{${"track_id"}}`, encodeURIComponent(String(params.trackId)));
    const queryString = queryParams.toString();
    return `${this.configuration.basePath}${path}${queryString ? "?" + queryString : ""}`;
  }
  /** @hidden
   * Upload track files, does not write to chain
   */
  async uploadTrackFiles(params) {
    this.logger.info("Parsing inputs");
    const {
      userId,
      trackFile,
      coverArtFile,
      metadata: parsedMetadata,
      onProgress
    } = await parseParams("uploadTrackFiles", UploadTrackFilesSchema)(params);
    this.logger.info("Transforming metadata");
    const metadata = this.trackUploadHelper.transformTrackUploadMetadata(parsedMetadata, userId);
    this.logger.info("Uploading track audio and cover art");
    const [coverArtResponse, audioResponse] = await Promise.all([coverArtFile ? retry3(async () => await this.storage.uploadFile({
      file: coverArtFile,
      onProgress,
      template: "img_square"
    }), (e) => {
      this.logger.info("Retrying uploadTrackCoverArt", e);
    }) : Promise.resolve(void 0), retry3(async () => await this.storage.uploadFile({
      file: trackFile,
      onProgress,
      template: "audio",
      options: this.trackUploadHelper.extractMediorumUploadOptions(metadata)
    }), (e) => {
      this.logger.info("Retrying uploadTrackAudio", e);
    })]);
    return this.trackUploadHelper.populateTrackMetadataWithUploadResponse(metadata, audioResponse, coverArtResponse);
  }
  /** @hidden
   * Write track upload to chain
   */
  async writeTrackToChain(userId, metadata, advancedOptions) {
    var _decodeHashId;
    this.logger.info("Writing metadata to chain");
    const entityId = metadata.trackId || await this.trackUploadHelper.generateId("track");
    const decodedUserId = (_decodeHashId = decodeHashId(userId)) !== null && _decodeHashId !== void 0 ? _decodeHashId : void 0;
    if (!decodedUserId) {
      throw new Error("writeTrackToChain: userId could not be decoded");
    }
    const response = await this.entityManager.manageEntity({
      userId: decodedUserId,
      entityType: EntityType.TRACK,
      entityId,
      action: Action.CREATE,
      metadata: JSON.stringify({
        cid: "",
        data: {
          ...(0, import_snakecase_keys.default)(metadata),
          download_conditions: metadata.downloadConditions && (0, import_snakecase_keys.default)(metadata.downloadConditions),
          stream_conditions: metadata.streamConditions && (0, import_snakecase_keys.default)(metadata.streamConditions),
          stem_of: metadata.stemOf && (0, import_snakecase_keys.default)(metadata.stemOf)
        }
      }),
      ...advancedOptions
    });
    this.logger.info("Successfully uploaded track");
    return {
      ...response,
      trackId: encodeHashId(entityId)
    };
  }
  /** @hidden
   * Upload a track
   */
  async uploadTrack(params, advancedOptions) {
    await parseParams("uploadTrack", UploadTrackSchema)(params);
    const metadata = await this.uploadTrackFiles(params);
    return this.writeTrackToChain(params.userId, metadata, advancedOptions);
  }
  /** @hidden
   * Update a track
   */
  async updateTrack(params, advancedOptions) {
    const {
      userId,
      trackId,
      coverArtFile,
      metadata: parsedMetadata,
      onProgress,
      generatePreview
    } = await parseParams("updateTrack", UpdateTrackSchema)(params);
    const metadata = this.trackUploadHelper.transformTrackUploadMetadata(parsedMetadata, userId);
    const coverArtResp = coverArtFile && await retry3(async () => await this.storage.uploadFile({
      file: coverArtFile,
      onProgress,
      template: "img_square"
    }), (e) => {
      this.logger.info("Retrying uploadTrackCoverArt", e);
    });
    const updatedMetadata = {
      ...metadata,
      ...coverArtResp ? {
        coverArtSizes: coverArtResp.id
      } : {}
    };
    if (generatePreview) {
      if (updatedMetadata.previewStartSeconds === void 0) {
        throw new Error("No track preview start time specified");
      }
      if (!updatedMetadata.audioUploadId) {
        throw new Error("Missing required audio_upload_id");
      }
      const previewCid = await retry3(async () => await this.storage.generatePreview({
        cid: updatedMetadata.trackCid,
        secondOffset: updatedMetadata.previewStartSeconds
      }), (e) => {
        this.logger.info("Retrying generatePreview", e);
      });
      updatedMetadata.previewCid = previewCid;
    }
    return await this.entityManager.manageEntity({
      userId,
      entityType: EntityType.TRACK,
      entityId: trackId,
      action: Action.UPDATE,
      metadata: JSON.stringify({
        cid: "",
        data: {
          ...(0, import_snakecase_keys.default)(updatedMetadata),
          download_conditions: updatedMetadata.downloadConditions && (0, import_snakecase_keys.default)(updatedMetadata.downloadConditions),
          stream_conditions: updatedMetadata.streamConditions && (0, import_snakecase_keys.default)(updatedMetadata.streamConditions),
          stem_of: metadata.stemOf && (0, import_snakecase_keys.default)(metadata.stemOf)
        }
      }),
      ...advancedOptions
    });
  }
  /** @hidden
   * Delete a track
   */
  async deleteTrack(params, advancedOptions) {
    const {
      userId,
      trackId
    } = await parseParams("deleteTrack", DeleteTrackSchema)(params);
    return await this.entityManager.manageEntity({
      userId,
      entityType: EntityType.TRACK,
      entityId: trackId,
      action: Action.DELETE,
      ...advancedOptions
    });
  }
  /** @hidden
   * Favorite a track
   */
  async favoriteTrack(params, advancedOptions) {
    const {
      userId,
      trackId,
      metadata
    } = await parseParams("favoriteTrack", FavoriteTrackSchema)(params);
    return await this.entityManager.manageEntity({
      userId,
      entityType: EntityType.TRACK,
      entityId: trackId,
      action: Action.SAVE,
      metadata: metadata && JSON.stringify((0, import_snakecase_keys.default)(metadata)),
      ...advancedOptions
    });
  }
  /** @hidden
   * Unfavorite a track
   */
  async unfavoriteTrack(params, advancedOptions) {
    const {
      userId,
      trackId
    } = await parseParams("unfavoriteTrack", UnfavoriteTrackSchema)(params);
    return await this.entityManager.manageEntity({
      userId,
      entityType: EntityType.TRACK,
      entityId: trackId,
      action: Action.UNSAVE,
      ...advancedOptions
    });
  }
  /** @hidden
   * Share a track
   */
  async shareTrack(params, advancedOptions) {
    const {
      userId,
      trackId
    } = await parseParams("shareTrack", ShareTrackSchema)(params);
    return await this.entityManager.manageEntity({
      userId,
      entityType: EntityType.TRACK,
      entityId: trackId,
      action: Action.SHARE,
      ...advancedOptions
    });
  }
  /** @hidden
   * Repost a track
   */
  async repostTrack(params, advancedOptions) {
    const {
      userId,
      trackId,
      metadata
    } = await parseParams("respostTrack", RepostTrackSchema)(params);
    return await this.entityManager.manageEntity({
      userId,
      entityType: EntityType.TRACK,
      entityId: trackId,
      action: Action.REPOST,
      metadata: metadata && JSON.stringify((0, import_snakecase_keys.default)(metadata)),
      ...advancedOptions
    });
  }
  /** @hidden
   * Unrepost a track
   */
  async unrepostTrack(params, advancedOptions) {
    const {
      userId,
      trackId
    } = await parseParams("unrepostTrack", UnrepostTrackSchema)(params);
    return await this.entityManager.manageEntity({
      userId,
      entityType: EntityType.TRACK,
      entityId: trackId,
      action: Action.UNREPOST,
      ...advancedOptions
    });
  }
  /**
   * @hidden
   *
   * Records that a track was downloaded.
   */
  async recordTrackDownload(params, advancedOptions) {
    const {
      userId,
      trackId
    } = await parseParams("downloadTrack", RecordTrackDownloadSchema)(params);
    const location = await getLocation({
      logger: this.logger
    });
    return await this.entityManager.manageEntity({
      userId,
      entityType: EntityType.TRACK,
      entityId: trackId,
      action: Action.DOWNLOAD,
      metadata: location ? JSON.stringify({
        cid: "",
        data: {
          city: location.city,
          region: location.region,
          country: location.country
        }
      }) : void 0,
      ...advancedOptions
    });
  }
  /**
   * Gets the Solana instructions that purchase the track
   *
   * @hidden
   */
  async getPurchaseTrackInstructions(params) {
    var _track$access, _track$access2;
    const {
      userId,
      trackId,
      price: priceNumber,
      extraAmount: extraAmountNumber = 0
    } = await parseParams("getPurchaseTrackInstructions", GetPurchaseTrackInstructionsSchema)(params);
    const contentType = "track";
    const mint = "USDC";
    this.logger.debug("Fetching track purchase info...", {
      trackId
    });
    const {
      data: track
    } = await this.getTrackAccessInfo({
      trackId: params.trackId,
      userId: params.userId
      // use hashed userId
    });
    if (!track) {
      throw new Error("Track not found.");
    }
    if (!track.isStreamGated && !track.isDownloadGated) {
      throw new Error("Attempted to purchase free track.");
    }
    if (track.userId === params.userId) {
      throw new Error("Attempted to purchase own track.");
    }
    let numberSplits = [];
    let centPrice;
    let accessType = "stream";
    if (track.streamConditions && instanceOfExtendedPurchaseGate(track.streamConditions)) {
      centPrice = track.streamConditions.usdcPurchase.price;
      numberSplits = track.streamConditions.usdcPurchase.splits;
    } else if (track.downloadConditions && instanceOfExtendedPurchaseGate(track.downloadConditions)) {
      centPrice = track.downloadConditions.usdcPurchase.price;
      numberSplits = track.downloadConditions.usdcPurchase.splits;
      accessType = "download";
    } else {
      throw new Error("Track is not available for purchase.");
    }
    if (accessType === "download" && (_track$access = track.access) !== null && _track$access !== void 0 && _track$access.download || accessType === "stream" && (_track$access2 = track.access) !== null && _track$access2 !== void 0 && _track$access2.stream) {
      throw new Error("Track already purchased");
    }
    if (USDC(priceNumber).value < USDC(centPrice / 100).value) {
      throw new Error("Track price increased.");
    }
    const extraAmount = USDC(extraAmountNumber).value;
    const total = USDC(centPrice / 100).value + extraAmount;
    this.logger.debug("Purchase total:", total);
    const splits = await prepareSplits({
      splits: numberSplits,
      extraAmount,
      claimableTokensClient: this.claimableTokensClient,
      logger: this.logger
    });
    this.logger.debug("Calculated splits:", splits);
    const routeInstruction = await this.paymentRouterClient.createRouteInstruction({
      splits,
      total,
      mint
    });
    const memoInstruction = await this.paymentRouterClient.createPurchaseMemoInstruction({
      contentId: trackId,
      contentType,
      blockNumber: track.blocknumber,
      buyerUserId: userId,
      accessType
    });
    let locationMemoInstruction;
    try {
      locationMemoInstruction = await this.solanaRelay.getLocationInstruction();
    } catch (e) {
      this.logger.warn("Unable to compute location memo instruction");
    }
    return {
      instructions: {
        routeInstruction,
        memoInstruction,
        locationMemoInstruction
      },
      total
    };
  }
  /**
   * Purchases stream or download access to a track
   *
   * @hidden
   */
  async purchaseTrack(params) {
    const {
      wallet
    } = await parseParams("purchaseTrack", PurchaseTrackSchema)(params);
    const {
      // only send the base params to getPurchaseInstructions
      wallet: ignoredWallet,
      walletAdapter: ignoredWalletAdapter,
      ...baseParams
    } = params;
    const {
      instructions: {
        routeInstruction,
        memoInstruction,
        locationMemoInstruction
      },
      total
    } = await this.getPurchaseTrackInstructions(baseParams);
    let transaction;
    const mint = "USDC";
    if (wallet) {
      this.logger.debug("Using provided wallet to purchase...", {
        wallet: wallet.toBase58()
      });
      const transferInstruction = await this.paymentRouterClient.createTransferInstruction({
        sourceWallet: wallet,
        total,
        mint
      });
      transaction = await this.solanaClient.buildTransaction({
        feePayer: wallet,
        instructions: [transferInstruction, routeInstruction, memoInstruction, locationMemoInstruction].filter(Boolean)
      });
    } else {
      this.logger.debug(`Using userBank ${await this.claimableTokensClient.deriveUserBank({
        mint: "USDC"
      })} to purchase...`);
      const paymentRouterTokenAccount = await this.paymentRouterClient.getOrCreateProgramTokenAccount({
        mint
      });
      const transferSecpInstruction = await this.claimableTokensClient.createTransferSecpInstruction({
        destination: paymentRouterTokenAccount.address,
        mint,
        amount: total
      });
      const transferInstruction = await this.claimableTokensClient.createTransferInstruction({
        destination: paymentRouterTokenAccount.address,
        mint
      });
      transaction = await this.solanaClient.buildTransaction({
        feePayer: wallet,
        instructions: [transferSecpInstruction, transferInstruction, routeInstruction, memoInstruction, locationMemoInstruction].filter(Boolean)
      });
    }
    if (params.walletAdapter) {
      if (!params.walletAdapter.publicKey) {
        throw new Error("Param walletAdapter was specified, but no wallet selected");
      }
      return await params.walletAdapter.sendTransaction(transaction, this.solanaClient.connection);
    }
    return this.solanaClient.sendTransaction(transaction, {
      skipPreflight: true
    });
  }
  /**
   * Generates a new track ID
   *
   * @hidden
   */
  async generateTrackId() {
    return this.trackUploadHelper.generateId("track");
  }
};
function equals$1(aa, bb) {
  if (aa === bb) return true;
  if (aa.byteLength !== bb.byteLength) {
    return false;
  }
  for (let ii = 0; ii < aa.byteLength; ii++) {
    if (aa[ii] !== bb[ii]) {
      return false;
    }
  }
  return true;
}
function coerce3(o) {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array") return o;
  if (o instanceof ArrayBuffer) return new Uint8Array(o);
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
}
function base2(ALPHABET2, name) {
  if (ALPHABET2.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i = 0; i < ALPHABET2.length; i++) {
    var x = ALPHABET2.charAt(i);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i;
  }
  var BASE2 = ALPHABET2.length;
  var LEADER = ALPHABET2.charAt(0);
  var FACTOR = Math.log(BASE2) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE2);
  function encode4(source) {
    if (source instanceof Uint8Array) ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length2 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size4 = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size4);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i2 = 0;
      for (var it1 = size4 - 1; (carry !== 0 || i2 < length2) && it1 !== -1; it1--, i2++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE2 >>> 0;
        carry = carry / BASE2 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length2 = i2;
      pbegin++;
    }
    var it2 = size4 - length2;
    while (it2 !== size4 && b58[it2] === 0) {
      it2++;
    }
    var str2 = LEADER.repeat(zeroes);
    for (; it2 < size4; ++it2) {
      str2 += ALPHABET2.charAt(b58[it2]);
    }
    return str2;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length2 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size4 = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size4);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i2 = 0;
      for (var it3 = size4 - 1; (carry !== 0 || i2 < length2) && it3 !== -1; it3--, i2++) {
        carry += BASE2 * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length2 = i2;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size4 - length2;
    while (it4 !== size4 && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size4 - it4));
    var j2 = zeroes;
    while (it4 !== size4) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  function decode4(string3) {
    var buffer3 = decodeUnsafe(string3);
    if (buffer3) {
      return buffer3;
    }
    throw new Error(`Non-${name} character`);
  }
  return {
    encode: encode4,
    decodeUnsafe,
    decode: decode4
  };
}
var src = base2;
var _brrp__multiformats_scope_baseX = src;
var Encoder2 = class {
  constructor(name, prefix, baseEncode) {
    _defineProperty$1(this, "name", void 0);
    _defineProperty$1(this, "prefix", void 0);
    _defineProperty$1(this, "baseEncode", void 0);
    this.name = name;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  encode(bytes3) {
    if (bytes3 instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes3)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
var Decoder2 = class {
  constructor(name, prefix, baseDecode) {
    _defineProperty$1(this, "name", void 0);
    _defineProperty$1(this, "prefix", void 0);
    _defineProperty$1(this, "baseDecode", void 0);
    _defineProperty$1(this, "prefixCodePoint", void 0);
    this.name = name;
    this.prefix = prefix;
    const prefixCodePoint = prefix.codePointAt(0);
    if (prefixCodePoint === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = prefixCodePoint;
    this.baseDecode = baseDecode;
  }
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  or(decoder) {
    return or(this, decoder);
  }
};
var ComposedDecoder = class {
  constructor(decoders) {
    _defineProperty$1(this, "decoders", void 0);
    this.decoders = decoders;
  }
  or(decoder) {
    return or(this, decoder);
  }
  decode(input) {
    const prefix = input[0];
    const decoder = this.decoders[prefix];
    if (decoder != null) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
};
function or(left, right) {
  var _left$decoders, _right$decoders;
  return new ComposedDecoder({
    ...(_left$decoders = left.decoders) !== null && _left$decoders !== void 0 ? _left$decoders : {
      [left.prefix]: left
    },
    ...(_right$decoders = right.decoders) !== null && _right$decoders !== void 0 ? _right$decoders : {
      [right.prefix]: right
    }
  });
}
var Codec = class {
  constructor(name, prefix, baseEncode, baseDecode) {
    _defineProperty$1(this, "name", void 0);
    _defineProperty$1(this, "prefix", void 0);
    _defineProperty$1(this, "baseEncode", void 0);
    _defineProperty$1(this, "baseDecode", void 0);
    _defineProperty$1(this, "encoder", void 0);
    _defineProperty$1(this, "decoder", void 0);
    this.name = name;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder2(name, prefix, baseEncode);
    this.decoder = new Decoder2(name, prefix, baseDecode);
  }
  encode(input) {
    return this.encoder.encode(input);
  }
  decode(input) {
    return this.decoder.decode(input);
  }
};
function from$1(_ref) {
  let {
    name,
    prefix,
    encode: encode4,
    decode: decode4
  } = _ref;
  return new Codec(name, prefix, encode4, decode4);
}
function baseX(_ref2) {
  let {
    name,
    prefix,
    alphabet: alphabet2
  } = _ref2;
  const {
    encode: encode4,
    decode: decode4
  } = _brrp__multiformats_scope_baseX(alphabet2, name);
  return from$1({
    prefix,
    name,
    encode: encode4,
    decode: (text) => coerce3(decode4(text))
  });
}
function decode$32(string3, alphabet2, bitsPerChar, name) {
  const codes = {};
  for (let i = 0; i < alphabet2.length; ++i) {
    codes[alphabet2[i]] = i;
  }
  let end = string3.length;
  while (string3[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits = 0;
  let buffer3 = 0;
  let written = 0;
  for (let i = 0; i < end; ++i) {
    const value = codes[string3[i]];
    if (value === void 0) {
      throw new SyntaxError(`Non-${name} character`);
    }
    buffer3 = buffer3 << bitsPerChar | value;
    bits += bitsPerChar;
    if (bits >= 8) {
      bits -= 8;
      out[written++] = 255 & buffer3 >> bits;
    }
  }
  if (bits >= bitsPerChar || (255 & buffer3 << 8 - bits) !== 0) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
}
function encode$22(data, alphabet2, bitsPerChar) {
  const pad3 = alphabet2[alphabet2.length - 1] === "=";
  const mask3 = (1 << bitsPerChar) - 1;
  let out = "";
  let bits = 0;
  let buffer3 = 0;
  for (let i = 0; i < data.length; ++i) {
    buffer3 = buffer3 << 8 | data[i];
    bits += 8;
    while (bits > bitsPerChar) {
      bits -= bitsPerChar;
      out += alphabet2[mask3 & buffer3 >> bits];
    }
  }
  if (bits !== 0) {
    out += alphabet2[mask3 & buffer3 << bitsPerChar - bits];
  }
  if (pad3) {
    while ((out.length * bitsPerChar & 7) !== 0) {
      out += "=";
    }
  }
  return out;
}
function rfc4648(_ref3) {
  let {
    name,
    prefix,
    bitsPerChar,
    alphabet: alphabet2
  } = _ref3;
  return from$1({
    prefix,
    name,
    encode(input) {
      return encode$22(input, alphabet2, bitsPerChar);
    },
    decode(input) {
      return decode$32(input, alphabet2, bitsPerChar, name);
    }
  });
}
var base32 = rfc4648({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
rfc4648({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
rfc4648({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
rfc4648({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
rfc4648({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
rfc4648({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
rfc4648({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
rfc4648({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
rfc4648({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});
var base36 = baseX({
  prefix: "k",
  name: "base36",
  alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
});
baseX({
  prefix: "K",
  name: "base36upper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
});
var base58btc = baseX({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
baseX({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});
var encode_1 = encode$12;
var MSB = 128;
var REST = 127;
var MSBALL = ~REST;
var INT = Math.pow(2, 31);
function encode$12(num2, out, offset3) {
  out = out || [];
  offset3 = offset3 || 0;
  var oldOffset = offset3;
  while (num2 >= INT) {
    out[offset3++] = num2 & 255 | MSB;
    num2 /= 128;
  }
  while (num2 & MSBALL) {
    out[offset3++] = num2 & 255 | MSB;
    num2 >>>= 7;
  }
  out[offset3] = num2 | 0;
  encode$12.bytes = offset3 - oldOffset + 1;
  return out;
}
var decode$22 = read;
var MSB$1 = 128;
var REST$1 = 127;
function read(buf, offset3) {
  var res = 0, offset3 = offset3 || 0, shift = 0, counter = offset3, b, l = buf.length;
  do {
    if (counter >= l) {
      read.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf[counter++];
    res += shift < 28 ? (b & REST$1) << shift : (b & REST$1) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$1);
  read.bytes = counter - offset3;
  return res;
}
var N1 = Math.pow(2, 7);
var N2 = Math.pow(2, 14);
var N3 = Math.pow(2, 21);
var N4 = Math.pow(2, 28);
var N5 = Math.pow(2, 35);
var N6 = Math.pow(2, 42);
var N7 = Math.pow(2, 49);
var N8 = Math.pow(2, 56);
var N9 = Math.pow(2, 63);
var length = function(value) {
  return value < N1 ? 1 : value < N2 ? 2 : value < N3 ? 3 : value < N4 ? 4 : value < N5 ? 5 : value < N6 ? 6 : value < N7 ? 7 : value < N8 ? 8 : value < N9 ? 9 : 10;
};
var varint = {
  encode: encode_1,
  decode: decode$22,
  encodingLength: length
};
var _brrp_varint = varint;
function decode$12(data) {
  let offset3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  const code2 = _brrp_varint.decode(data, offset3);
  return [code2, _brrp_varint.decode.bytes];
}
function encodeTo(int, target) {
  let offset3 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
  _brrp_varint.encode(int, target, offset3);
  return target;
}
function encodingLength(int) {
  return _brrp_varint.encodingLength(int);
}
function create3(code2, digest) {
  const size4 = digest.byteLength;
  const sizeOffset = encodingLength(code2);
  const digestOffset = sizeOffset + encodingLength(size4);
  const bytes3 = new Uint8Array(digestOffset + size4);
  encodeTo(code2, bytes3, 0);
  encodeTo(size4, bytes3, sizeOffset);
  bytes3.set(digest, digestOffset);
  return new Digest(code2, size4, digest, bytes3);
}
function decode3(multihash) {
  const bytes3 = coerce3(multihash);
  const [code2, sizeOffset] = decode$12(bytes3);
  const [size4, digestOffset] = decode$12(bytes3.subarray(sizeOffset));
  const digest = bytes3.subarray(sizeOffset + digestOffset);
  if (digest.byteLength !== size4) {
    throw new Error("Incorrect length");
  }
  return new Digest(code2, size4, digest, bytes3);
}
function equals(a, b) {
  if (a === b) {
    return true;
  } else {
    const data = b;
    return a.code === data.code && a.size === data.size && data.bytes instanceof Uint8Array && equals$1(a.bytes, data.bytes);
  }
}
var Digest = class {
  /**
   * Creates a multihash digest.
   */
  constructor(code2, size4, digest, bytes3) {
    _defineProperty$1(this, "code", void 0);
    _defineProperty$1(this, "size", void 0);
    _defineProperty$1(this, "digest", void 0);
    _defineProperty$1(this, "bytes", void 0);
    this.code = code2;
    this.size = size4;
    this.digest = digest;
    this.bytes = bytes3;
  }
};
function format(link, base3) {
  const {
    bytes: bytes3,
    version: version3
  } = link;
  switch (version3) {
    case 0:
      return toStringV0(bytes3, baseCache(link), base3 !== null && base3 !== void 0 ? base3 : base58btc.encoder);
    default:
      return toStringV1(bytes3, baseCache(link), base3 !== null && base3 !== void 0 ? base3 : base32.encoder);
  }
}
var cache = /* @__PURE__ */ new WeakMap();
function baseCache(cid) {
  const baseCache2 = cache.get(cid);
  if (baseCache2 == null) {
    const baseCache3 = /* @__PURE__ */ new Map();
    cache.set(cid, baseCache3);
    return baseCache3;
  }
  return baseCache2;
}
var CID = class _CID {
  /**
   * @param version - Version of the CID
   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param multihash - (Multi)hash of the of the content.
   */
  constructor(version3, code2, multihash, bytes3) {
    _defineProperty$1(this, "code", void 0);
    _defineProperty$1(this, "version", void 0);
    _defineProperty$1(this, "multihash", void 0);
    _defineProperty$1(this, "bytes", void 0);
    _defineProperty$1(this, "/", void 0);
    _defineProperty$1(this, Symbol.toStringTag, "CID");
    this.code = code2;
    this.version = version3;
    this.multihash = multihash;
    this.bytes = bytes3;
    this["/"] = bytes3;
  }
  /**
   * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`
   * please either use `CID.asCID(cid)` or switch to new signalling mechanism
   *
   * @deprecated
   */
  get asCID() {
    return this;
  }
  // ArrayBufferView
  get byteOffset() {
    return this.bytes.byteOffset;
  }
  // ArrayBufferView
  get byteLength() {
    return this.bytes.byteLength;
  }
  toV0() {
    switch (this.version) {
      case 0: {
        return this;
      }
      case 1: {
        const {
          code: code2,
          multihash
        } = this;
        if (code2 !== DAG_PB_CODE) {
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        }
        if (multihash.code !== SHA_256_CODE) {
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        }
        return _CID.createV0(multihash);
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
      }
    }
  }
  toV1() {
    switch (this.version) {
      case 0: {
        const {
          code: code2,
          digest
        } = this.multihash;
        const multihash = create3(code2, digest);
        return _CID.createV1(this.code, multihash);
      }
      case 1: {
        return this;
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`);
      }
    }
  }
  equals(other) {
    return _CID.equals(this, other);
  }
  static equals(self2, other) {
    const unknown3 = other;
    return unknown3 != null && self2.code === unknown3.code && self2.version === unknown3.version && equals(self2.multihash, unknown3.multihash);
  }
  toString(base3) {
    return format(this, base3);
  }
  toJSON() {
    return {
      "/": format(this)
    };
  }
  link() {
    return this;
  }
  // Legacy
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `CID(${this.toString()})`;
  }
  /**
   * Takes any input `value` and returns a `CID` instance if it was
   * a `CID` otherwise returns `null`. If `value` is instanceof `CID`
   * it will return value back. If `value` is not instance of this CID
   * class, but is compatible CID it will return new instance of this
   * `CID` class. Otherwise returns null.
   *
   * This allows two different incompatible versions of CID library to
   * co-exist and interop as long as binary interface is compatible.
   */
  static asCID(input) {
    if (input == null) {
      return null;
    }
    const value = input;
    if (value instanceof _CID) {
      return value;
    } else if (value["/"] != null && value["/"] === value.bytes || value.asCID === value) {
      const {
        version: version3,
        code: code2,
        multihash,
        bytes: bytes3
      } = value;
      return new _CID(version3, code2, multihash, bytes3 !== null && bytes3 !== void 0 ? bytes3 : encodeCID(version3, code2, multihash.bytes));
    } else if (value[cidSymbol] === true) {
      const {
        version: version3,
        multihash,
        code: code2
      } = value;
      const digest = decode3(multihash);
      return _CID.create(version3, code2, digest);
    } else {
      return null;
    }
  }
  /**
   * @param version - Version of the CID
   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param digest - (Multi)hash of the of the content.
   */
  static create(version3, code2, digest) {
    if (typeof code2 !== "number") {
      throw new Error("String codecs are no longer supported");
    }
    if (!(digest.bytes instanceof Uint8Array)) {
      throw new Error("Invalid digest");
    }
    switch (version3) {
      case 0: {
        if (code2 !== DAG_PB_CODE) {
          throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`);
        } else {
          return new _CID(version3, code2, digest, digest.bytes);
        }
      }
      case 1: {
        const bytes3 = encodeCID(version3, code2, digest.bytes);
        return new _CID(version3, code2, digest, bytes3);
      }
      default: {
        throw new Error("Invalid version");
      }
    }
  }
  /**
   * Simplified version of `create` for CIDv0.
   */
  static createV0(digest) {
    return _CID.create(0, DAG_PB_CODE, digest);
  }
  /**
   * Simplified version of `create` for CIDv1.
   *
   * @param code - Content encoding format code.
   * @param digest - Multihash of the content.
   */
  static createV1(code2, digest) {
    return _CID.create(1, code2, digest);
  }
  /**
   * Decoded a CID from its binary representation. The byte array must contain
   * only the CID with no additional bytes.
   *
   * An error will be thrown if the bytes provided do not contain a valid
   * binary representation of a CID.
   */
  static decode(bytes3) {
    const [cid, remainder] = _CID.decodeFirst(bytes3);
    if (remainder.length !== 0) {
      throw new Error("Incorrect length");
    }
    return cid;
  }
  /**
   * Decoded a CID from its binary representation at the beginning of a byte
   * array.
   *
   * Returns an array with the first element containing the CID and the second
   * element containing the remainder of the original byte array. The remainder
   * will be a zero-length byte array if the provided bytes only contained a
   * binary CID representation.
   */
  static decodeFirst(bytes3) {
    const specs = _CID.inspectBytes(bytes3);
    const prefixSize = specs.size - specs.multihashSize;
    const multihashBytes = coerce3(bytes3.subarray(prefixSize, prefixSize + specs.multihashSize));
    if (multihashBytes.byteLength !== specs.multihashSize) {
      throw new Error("Incorrect length");
    }
    const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
    const digest = new Digest(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
    const cid = specs.version === 0 ? _CID.createV0(digest) : _CID.createV1(specs.codec, digest);
    return [cid, bytes3.subarray(specs.size)];
  }
  /**
   * Inspect the initial bytes of a CID to determine its properties.
   *
   * Involves decoding up to 4 varints. Typically this will require only 4 to 6
   * bytes but for larger multicodec code values and larger multihash digest
   * lengths these varints can be quite large. It is recommended that at least
   * 10 bytes be made available in the `initialBytes` argument for a complete
   * inspection.
   */
  static inspectBytes(initialBytes) {
    let offset3 = 0;
    const next = () => {
      const [i, length2] = decode$12(initialBytes.subarray(offset3));
      offset3 += length2;
      return i;
    };
    let version3 = next();
    let codec = DAG_PB_CODE;
    if (version3 === 18) {
      version3 = 0;
      offset3 = 0;
    } else {
      codec = next();
    }
    if (version3 !== 0 && version3 !== 1) {
      throw new RangeError(`Invalid CID version ${version3}`);
    }
    const prefixSize = offset3;
    const multihashCode = next();
    const digestSize = next();
    const size4 = offset3 + digestSize;
    const multihashSize = size4 - prefixSize;
    return {
      version: version3,
      codec,
      multihashCode,
      digestSize,
      multihashSize,
      size: size4
    };
  }
  /**
   * Takes cid in a string representation and creates an instance. If `base`
   * decoder is not provided will use a default from the configuration. It will
   * throw an error if encoding of the CID is not compatible with supplied (or
   * a default decoder).
   */
  static parse(source, base3) {
    const [prefix, bytes3] = parseCIDtoBytes(source, base3);
    const cid = _CID.decode(bytes3);
    if (cid.version === 0 && source[0] !== "Q") {
      throw Error("Version 0 CID string must not include multibase prefix");
    }
    baseCache(cid).set(prefix, source);
    return cid;
  }
};
function parseCIDtoBytes(source, base3) {
  switch (source[0]) {
    // CIDv0 is parsed differently
    case "Q": {
      const decoder = base3 !== null && base3 !== void 0 ? base3 : base58btc;
      return [base58btc.prefix, decoder.decode(`${base58btc.prefix}${source}`)];
    }
    case base58btc.prefix: {
      const decoder = base3 !== null && base3 !== void 0 ? base3 : base58btc;
      return [base58btc.prefix, decoder.decode(source)];
    }
    case base32.prefix: {
      const decoder = base3 !== null && base3 !== void 0 ? base3 : base32;
      return [base32.prefix, decoder.decode(source)];
    }
    case base36.prefix: {
      const decoder = base3 !== null && base3 !== void 0 ? base3 : base36;
      return [base36.prefix, decoder.decode(source)];
    }
    default: {
      if (base3 == null) {
        throw Error("To parse non base32, base36 or base58btc encoded CID multibase decoder must be provided");
      }
      return [source[0], base3.decode(source)];
    }
  }
}
function toStringV0(bytes3, cache2, base3) {
  const {
    prefix
  } = base3;
  if (prefix !== base58btc.prefix) {
    throw Error(`Cannot string encode V0 in ${base3.name} encoding`);
  }
  const cid = cache2.get(prefix);
  if (cid == null) {
    const cid2 = base3.encode(bytes3).slice(1);
    cache2.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
}
function toStringV1(bytes3, cache2, base3) {
  const {
    prefix
  } = base3;
  const cid = cache2.get(prefix);
  if (cid == null) {
    const cid2 = base3.encode(bytes3);
    cache2.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
}
var DAG_PB_CODE = 112;
var SHA_256_CODE = 18;
function encodeCID(version3, code2, multihash) {
  const codeOffset = encodingLength(version3);
  const hashOffset = codeOffset + encodingLength(code2);
  const bytes3 = new Uint8Array(hashOffset + multihash.byteLength);
  encodeTo(version3, bytes3, 0);
  encodeTo(code2, bytes3, codeOffset);
  bytes3.set(multihash, hashOffset);
  return bytes3;
}
var cidSymbol = Symbol.for("@ipld/js-cid/CID");
var textEncoder = new TextEncoder();
new TextDecoder();
var code = 512;
function encode3(node) {
  return textEncoder.encode(JSON.stringify(node));
}
function from(_ref) {
  let {
    name,
    code: code2,
    encode: encode4
  } = _ref;
  return new Hasher(name, code2, encode4);
}
var Hasher = class {
  constructor(name, code2, encode4) {
    _defineProperty$1(this, "name", void 0);
    _defineProperty$1(this, "code", void 0);
    _defineProperty$1(this, "encode", void 0);
    this.name = name;
    this.code = code2;
    this.encode = encode4;
  }
  digest(input) {
    if (input instanceof Uint8Array) {
      const result = this.encode(input);
      return result instanceof Uint8Array ? create3(this.code, result) : result.then((digest) => create3(this.code, digest));
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
var sha2569 = from({
  name: "sha2-256",
  code: 18,
  encode: (input) => coerce3(crypto$3.createHash("sha256").update(input).digest())
});
from({
  name: "sha2-512",
  code: 19,
  encode: (input) => coerce3(crypto$3.createHash("sha512").update(input).digest())
});
var generateMetadataCidV1 = async (metadata) => {
  const bytes3 = encode3(metadata);
  const hash3 = await sha2569.digest(bytes3);
  return CID.create(1, code, hash3);
};
var SolanaAddressSchema = z.string().regex(/^[1-9A-HJ-NP-Za-km-z]+$/, "Solana address must only contain base58 characters").min(32, "Solana address must be at least 32 characters").max(44, "Solana address must not exceed 44 characters").refine((val) => {
  try {
    const ignored = new PublicKey(val);
    return true;
  } catch (err2) {
    console.debug(err2);
    return false;
  }
});
var reactionsMap = {
  "😍": 1,
  "🔥": 2,
  "🥳": 3,
  "🤯": 4
};
function getReaction(reaction) {
  if (typeof reaction === "number") {
    return Object.keys(reactionsMap).find((key) => reactionsMap[key] === reaction);
  }
  return reactionsMap[reaction];
}
var UserEventsSchema = z.object({
  referrer: z.optional(HashId),
  isMobileUser: z.optional(z.boolean())
});
var CreateUserSchema = z.object({
  profilePictureFile: z.optional(ImageFile),
  coverArtFile: z.optional(ImageFile),
  onProgress: z.optional(z.function()),
  metadata: z.object({
    allowAiAttribution: z.optional(z.boolean()),
    bio: z.optional(z.string()),
    coverPhotoSizes: z.optional(z.string()),
    donation: z.optional(z.string()),
    handle: z.optional(z.string()),
    events: z.optional(UserEventsSchema),
    location: z.optional(z.string()),
    name: z.optional(z.string()),
    profilePictureSizes: z.optional(z.string()),
    splUsdcPayoutWallet: z.optional(z.string()),
    wallet: z.string(),
    website: z.optional(z.string())
  }).strict()
});
var CreateAssociatedWalletsSchema = z.record(z.string(), z.object({
  signature: z.string()
}));
var CollectiblesMetadataSchema = z.union([z.object({
  order: z.array(z.string())
}).catchall(z.object({})), z.null()]);
var PlaylistIdentifierSchema = z.object({
  type: z.literal("playlist"),
  playlist_id: z.number()
});
var ExplorePlaylistIdentifierSchema = z.object({
  type: z.literal("explore_playlist"),
  playlist_id: z.string()
});
var PlaylistLibraryIdentifierSchema = z.union([PlaylistIdentifierSchema, ExplorePlaylistIdentifierSchema]);
var PlaylistLibraryFolderSchema = z.object({
  id: z.string(),
  type: z.literal("folder"),
  name: z.string(),
  contents: z.array(z.lazy(() => z.union([PlaylistLibraryFolderSchema, PlaylistLibraryIdentifierSchema])))
});
var PlaylistLibrarySchema = z.object({
  contents: z.array(z.union([PlaylistLibraryFolderSchema, PlaylistLibraryIdentifierSchema]))
});
var UpdateProfileSchema = z.object({
  userId: HashId,
  events: z.optional(UserEventsSchema),
  profilePictureFile: z.optional(ImageFile),
  coverArtFile: z.optional(ImageFile),
  onProgress: z.optional(z.function()),
  metadata: z.object({
    name: z.optional(z.string()),
    handle: z.optional(z.string()),
    bio: z.optional(z.string()),
    website: z.optional(z.string()),
    donation: z.optional(z.string()),
    location: z.optional(z.string()),
    profileType: z.optional(z.enum(["label"]).nullable()),
    metadataMultihash: z.optional(z.string()),
    events: z.optional(UserEventsSchema),
    isDeactivated: z.optional(z.boolean()),
    artistPickTrackId: z.optional(HashId),
    allowAiAttribution: z.optional(z.boolean()),
    playlistLibrary: z.optional(PlaylistLibrarySchema),
    twitterHandle: z.optional(z.string()),
    instagramHandle: z.optional(z.string()),
    tiktokHandle: z.optional(z.string()),
    splUsdcPayoutWallet: z.optional(SolanaAddressSchema).nullable()
  }).strict()
}).strict();
var FollowUserSchema = z.object({
  userId: HashId,
  followeeUserId: HashId
}).strict();
var UnfollowUserSchema = z.object({
  userId: HashId,
  followeeUserId: HashId
}).strict();
var SubscribeToUserSchema = z.object({
  userId: HashId,
  subscribeeUserId: HashId
}).strict();
var UnsubscribeFromUserSchema = z.object({
  userId: HashId,
  subscribeeUserId: HashId
}).strict();
var SendTipSchema = z.object({
  amount: z.number().positive().int(),
  senderUserId: HashId,
  receiverUserId: HashId
}).strict();
var ReactionTypeSchema = z.custom((value) => {
  const validReactions = Object.keys(reactionsMap);
  return validReactions.includes(value);
}, {
  message: "Invalid reaction type"
}).transform((data, ctx) => {
  const value = getReaction(data);
  if (value === void 0) {
    ctx.addIssue({
      code: z.ZodIssueCode.custom,
      message: "reactionValue invalid"
    });
    return z.NEVER;
  }
  return value;
});
var SendTipReactionRequestSchema = z.object({
  userId: HashId,
  metadata: z.object({
    reactedTo: z.string().nonempty(),
    reactionValue: ReactionTypeSchema
  })
});
var EmailSchema = z.object({
  emailOwnerUserId: z.number(),
  receivingUserId: z.number(),
  initialEmailEncryptionUuid: z.number(),
  granteeUserIds: z.array(z.string()).optional(),
  email: z.string()
});
var WalletSchema = z.discriminatedUnion("chain", [z.object({
  address: SolanaAddressSchema,
  chain: z.literal("sol")
}), z.object({
  // Relaxing type here so we can pass in a string and use EthAddressSchema to validate at runtime
  address: z.string().pipe(EthAddressSchema),
  chain: z.literal("eth")
})]);
var AddAssociatedWalletSchema = z.object({
  userId: HashId,
  wallet: WalletSchema,
  signature: z.string()
});
var RemoveAssociatedWalletSchema = z.object({
  userId: HashId,
  wallet: WalletSchema
});
var UpdateCollectiblesSchema = z.object({
  userId: HashId,
  collectibles: CollectiblesMetadataSchema
});
var UsersApi = class extends UsersApi$2 {
  constructor(configuration, storage, entityManager, logger, claimableTokens, solanaClient, emailEncryption) {
    super(configuration);
    _defineProperty$1(this, "storage", void 0);
    _defineProperty$1(this, "entityManager", void 0);
    _defineProperty$1(this, "logger", void 0);
    _defineProperty$1(this, "claimableTokens", void 0);
    _defineProperty$1(this, "solanaClient", void 0);
    _defineProperty$1(this, "emailEncryption", void 0);
    this.storage = storage;
    this.entityManager = entityManager;
    this.logger = logger;
    this.claimableTokens = claimableTokens;
    this.solanaClient = solanaClient;
    this.emailEncryption = emailEncryption;
    this.logger = logger.createPrefixedLogger("[users-api]");
  }
  /** @hidden
   * Generate a new user id for use in creation flow
   */
  async generateUserId() {
    const response = new JSONApiResponse$1(await this.request({
      path: "/users/unclaimed_id",
      method: "GET",
      headers: {},
      query: {
        noCache: Math.floor(Math.random() * 1e3).toString()
      }
    }));
    return await response.value();
  }
  /** @hidden
   * Create a user
   */
  async createUser(params, advancedOptions) {
    const {
      onProgress,
      profilePictureFile,
      coverArtFile,
      metadata
    } = await parseParams("createUser", CreateUserSchema)(params);
    const {
      data
    } = await this.generateUserId();
    if (!data) {
      throw new Error("Failed to generate userId");
    }
    const userId = HashId.parse(data);
    const [profilePictureResp, coverArtResp] = await Promise.all([profilePictureFile && retry3(async () => await this.storage.uploadFile({
      file: profilePictureFile,
      onProgress,
      template: "img_square"
    }), (e) => {
      this.logger.info("Retrying uploadProfilePicture", e);
    }), coverArtFile && retry3(async () => await this.storage.uploadFile({
      file: coverArtFile,
      onProgress,
      template: "img_backdrop"
    }), (e) => {
      this.logger.info("Retrying uploadProfileCoverArt", e);
    })]);
    const updatedMetadata = {
      ...metadata,
      userId,
      ...profilePictureResp ? {
        profilePicture: profilePictureResp === null || profilePictureResp === void 0 ? void 0 : profilePictureResp.id,
        profilePictureSizes: profilePictureResp === null || profilePictureResp === void 0 ? void 0 : profilePictureResp.id
      } : {},
      ...coverArtResp ? {
        coverPhoto: coverArtResp === null || coverArtResp === void 0 ? void 0 : coverArtResp.id,
        coverPhotoSizes: coverArtResp === null || coverArtResp === void 0 ? void 0 : coverArtResp.id
      } : {}
    };
    const entityMetadata = (0, import_snakecase_keys.default)(updatedMetadata);
    const cid = (await generateMetadataCidV1(entityMetadata)).toString();
    const {
      blockHash,
      blockNumber
    } = await this.entityManager.manageEntity({
      userId,
      entityType: EntityType.USER,
      entityId: userId,
      action: Action.CREATE,
      metadata: JSON.stringify({
        cid,
        data: entityMetadata
      }),
      ...advancedOptions
    });
    return {
      blockHash,
      blockNumber,
      metadata: updatedMetadata
    };
  }
  /** @hidden
   * Creates a guest for guest checkout
   */
  async createGuestAccount(advancedOptions) {
    const {
      data
    } = await this.generateUserId();
    if (!data) {
      throw new Error("Failed to generate userId");
    }
    const userId = HashId.parse(data);
    const metadata = {
      userId
    };
    const {
      blockHash,
      blockNumber
    } = await this.entityManager.manageEntity({
      userId,
      entityType: EntityType.USER,
      entityId: userId,
      action: Action.CREATE,
      metadata: JSON.stringify({
        cid: null,
        data: null
      }),
      ...advancedOptions
    });
    return {
      blockHash,
      blockNumber,
      metadata
    };
  }
  /** @hidden
   * Update a user profile
   */
  async updateProfile(params, advancedOptions) {
    const {
      onProgress,
      profilePictureFile,
      coverArtFile,
      userId,
      metadata
    } = await parseParams("updateProfile", UpdateProfileSchema)(params);
    const [profilePictureResp, coverArtResp] = await Promise.all([profilePictureFile && retry3(async () => await this.storage.uploadFile({
      file: profilePictureFile,
      onProgress,
      template: "img_square"
    }), (e) => {
      this.logger.info("Retrying uploadProfilePicture", e);
    }), coverArtFile && retry3(async () => await this.storage.uploadFile({
      file: coverArtFile,
      onProgress,
      template: "img_backdrop"
    }), (e) => {
      this.logger.info("Retrying uploadProfileCoverArt", e);
    })]);
    const updatedMetadata = (0, import_snakecase_keys.default)({
      ...metadata,
      ...profilePictureResp ? {
        profilePicture: profilePictureResp === null || profilePictureResp === void 0 ? void 0 : profilePictureResp.id,
        profilePictureSizes: profilePictureResp === null || profilePictureResp === void 0 ? void 0 : profilePictureResp.id
      } : {},
      ...coverArtResp ? {
        coverPhoto: coverArtResp === null || coverArtResp === void 0 ? void 0 : coverArtResp.id,
        coverPhotoSizes: coverArtResp === null || coverArtResp === void 0 ? void 0 : coverArtResp.id
      } : {}
    });
    const cid = (await generateMetadataCidV1(updatedMetadata)).toString();
    return await this.entityManager.manageEntity({
      userId,
      entityType: EntityType.USER,
      entityId: userId,
      action: Action.UPDATE,
      metadata: JSON.stringify({
        cid,
        data: updatedMetadata
      }),
      ...advancedOptions
    });
  }
  /** @hidden
   * Follow a user
   */
  async followUser(params, advancedOptions) {
    const {
      userId,
      followeeUserId
    } = await parseParams("followUser", FollowUserSchema)(params);
    return await this.entityManager.manageEntity({
      userId,
      entityType: EntityType.USER,
      entityId: followeeUserId,
      action: Action.FOLLOW,
      ...advancedOptions
    });
  }
  /** @hidden
   * Unfollow a user
   */
  async unfollowUser(params, advancedOptions) {
    const {
      userId,
      followeeUserId
    } = await parseParams("unfollowUser", UnfollowUserSchema)(params);
    return await this.entityManager.manageEntity({
      userId,
      entityType: EntityType.USER,
      entityId: followeeUserId,
      action: Action.UNFOLLOW,
      ...advancedOptions
    });
  }
  /** @hidden
   * Subscribe to a user
   */
  async subscribeToUser(params, advancedOptions) {
    const {
      userId,
      subscribeeUserId
    } = await parseParams("subscribeToUser", SubscribeToUserSchema)(params);
    return await this.entityManager.manageEntity({
      userId,
      entityType: EntityType.USER,
      entityId: subscribeeUserId,
      action: Action.SUBSCRIBE,
      ...advancedOptions
    });
  }
  /** @hidden
   * Unsubscribe from a user
   */
  async unsubscribeFromUser(params, advancedOptions) {
    const {
      userId,
      subscribeeUserId
    } = await parseParams("unsubscribeFromUser", UnsubscribeFromUserSchema)(params);
    return await this.entityManager.manageEntity({
      userId,
      entityType: EntityType.USER,
      entityId: subscribeeUserId,
      action: Action.UNSUBSCRIBE,
      ...advancedOptions
    });
  }
  /**
   * Downloads the sales the user has made as a CSV file.
   * Similar to generated raw method, but forced response type as blob
   */
  async downloadSalesAsCSVBlob(params) {
    if (params.id === null || params.id === void 0) {
      throw new RequiredError$1("id", "Required parameter params.id was null or undefined when calling downloadSalesAsCSV.");
    }
    const queryParameters = {};
    if (params.userId !== void 0) {
      queryParameters.user_id = params.userId;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/users/{id}/sales/download`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    });
    return await new BlobApiResponse$1(response).value();
  }
  /**
   * Downloads the purchases the user has made as a CSV file.
   * Similar to generated raw method, but forced response type as blob
   */
  async downloadPurchasesAsCSVBlob(params) {
    if (params.id === null || params.id === void 0) {
      throw new RequiredError$1("id", "Required parameter params.id was null or undefined when calling downloadPurchasesAsCSV.");
    }
    const queryParameters = {};
    if (params.userId !== void 0) {
      queryParameters.user_id = params.userId;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/users/{id}/purchases/download`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    });
    return await new BlobApiResponse$1(response).value();
  }
  /**
   * Downloads the USDC withdrawals the user has made as a CSV file
   * Similar to generated raw method, but forced response type as blob
   */
  async downloadUSDCWithdrawalsAsCSVBlob(params) {
    if (params.id === null || params.id === void 0) {
      throw new RequiredError$1("id", "Required parameter params.id was null or undefined when calling downloadUSDCWithdrawalsAsCSV.");
    }
    const queryParameters = {};
    if (params.userId !== void 0) {
      queryParameters.user_id = params.userId;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/users/{id}/withdrawals/download`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    });
    return await new BlobApiResponse$1(response).value();
  }
  /**
   * Sends a wAUDIO tip from one user to another.
   * @hidden subject to change
   */
  async sendTip(request) {
    const {
      amount
    } = await parseParams("sendTip", SendTipSchema)(request);
    const {
      ethWallet
    } = await this.getWalletAndUserBank(request.senderUserId);
    const {
      ethWallet: receiverEthWallet,
      userBank: destination
    } = await this.getWalletAndUserBank(request.receiverUserId);
    if (!ethWallet) {
      throw new Error("Invalid sender: No Ethereum wallet found.");
    }
    if (!receiverEthWallet) {
      throw new Error("Invalid recipient: No Ethereum wallet found.");
    }
    if (!destination) {
      throw new Error("Invalid recipient: No user bank found.");
    }
    const secp = await this.claimableTokens.createTransferSecpInstruction({
      ethWallet,
      destination,
      amount: wAUDIO(amount).value,
      mint: "wAUDIO"
    });
    const transfer = await this.claimableTokens.createTransferInstruction({
      ethWallet,
      destination,
      mint: "wAUDIO"
    });
    const transaction = await this.solanaClient.buildTransaction({
      instructions: [secp, transfer]
    });
    return await this.claimableTokens.sendTransaction(transaction);
  }
  /**
   * Submits a reaction to a tip being received.
   * @hidden
   */
  async sendTipReaction(params, advancedOptions) {
    const {
      userId,
      metadata
    } = await parseParams("sendTipReaction", SendTipReactionRequestSchema)(params);
    return await this.entityManager.manageEntity({
      userId,
      entityType: EntityType.TIP,
      entityId: userId,
      action: Action.UPDATE,
      metadata: JSON.stringify({
        cid: "",
        data: (0, import_snakecase_keys.default)(metadata)
      }),
      ...advancedOptions
    });
  }
  /**
   * Helper function for sendTip that gets the user wallet and creates
   * or gets the wAUDIO user bank for given user ID.
   */
  async getWalletAndUserBank(id) {
    var _res$data;
    const res = await this.getUser({
      id
    });
    const ethWallet = (_res$data = res.data) === null || _res$data === void 0 ? void 0 : _res$data.ercWallet;
    if (!ethWallet) {
      return {
        ethWallet: null,
        userBank: null
      };
    }
    const {
      userBank
    } = await this.claimableTokens.getOrCreateUserBank({
      ethWallet,
      mint: "wAUDIO"
    });
    return {
      ethWallet,
      userBank
    };
  }
  /** @hidden
   * Share an encrypted email with a user
   */
  async shareEmail(params, advancedOptions) {
    const {
      emailOwnerUserId,
      receivingUserId,
      email,
      granteeUserIds,
      initialEmailEncryptionUuid
    } = await parseParams("shareEmail", EmailSchema)(params);
    let symmetricKey;
    const emailOwnerUserIdHash = encodeHashId(emailOwnerUserId);
    const receivingUserIdHash = encodeHashId(receivingUserId);
    const initialEmailEncryptionUuidHash = encodeHashId(initialEmailEncryptionUuid);
    if (!emailOwnerUserIdHash || !receivingUserIdHash || !initialEmailEncryptionUuidHash) {
      throw new Error("Email owner user ID and receiving user ID are required");
    }
    const accessGrants = [];
    const {
      data: {
        encryptedKey: emailOwnerKey,
        isInitial
      } = {
        encryptedKey: "",
        isInitial: false
      }
    } = await this.getUserEmailKey({
      receivingUserId: emailOwnerUserIdHash,
      grantorUserId: emailOwnerUserIdHash
    });
    let action, entityType;
    if (emailOwnerKey) {
      symmetricKey = await this.emailEncryption.decryptSymmetricKey(emailOwnerKey, isInitial ? initialEmailEncryptionUuidHash : emailOwnerUserIdHash);
      action = Action.UPDATE;
      entityType = EntityType.EMAIL_ACCESS;
    } else {
      symmetricKey = this.emailEncryption.createSymmetricKey();
      const ownerEncryptedKey = await this.emailEncryption.encryptSymmetricKey(emailOwnerUserIdHash, symmetricKey);
      accessGrants.push({
        receiving_user_id: emailOwnerUserId,
        grantor_user_id: emailOwnerUserId,
        encrypted_key: ownerEncryptedKey
      });
      action = Action.ADD_EMAIL;
      entityType = EntityType.ENCRYPTED_EMAIL;
    }
    const encryptedEmail = await this.emailEncryption.encryptEmail(email, symmetricKey);
    const receiverEncryptedKey = await this.emailEncryption.encryptSymmetricKey(receivingUserIdHash, symmetricKey);
    accessGrants.push({
      receiving_user_id: receivingUserId,
      grantor_user_id: emailOwnerUserId,
      encrypted_key: receiverEncryptedKey
    });
    if (granteeUserIds !== null && granteeUserIds !== void 0 && granteeUserIds.length) {
      await Promise.all(granteeUserIds.map(async (granteeUserIdHash) => {
        const granteeEncryptedKey = await this.emailEncryption.encryptSymmetricKey(granteeUserIdHash, symmetricKey);
        accessGrants.push({
          receiving_user_id: decodeHashId(granteeUserIdHash),
          grantor_user_id: receivingUserId,
          encrypted_key: granteeEncryptedKey
        });
      }));
    }
    const metadata = {
      email_owner_user_id: emailOwnerUserId,
      encrypted_email: encryptedEmail,
      access_grants: accessGrants
    };
    return await this.entityManager.manageEntity({
      userId: emailOwnerUserId,
      entityType,
      entityId: emailOwnerUserId,
      action,
      metadata: JSON.stringify({
        cid: "",
        data: metadata
      }),
      ...advancedOptions
    });
  }
  /** @hidden
   * Associate a new wallet with a user
   */
  async addAssociatedWallet(params, advancedOptions) {
    const {
      userId,
      wallet: {
        address: wallet_address,
        chain: chain2
      },
      signature: signature2
    } = await parseParams("addAssociatedWallet", AddAssociatedWalletSchema)(params);
    return await this.entityManager.manageEntity({
      userId,
      entityType: EntityType.ASSOCIATED_WALLET,
      entityId: 0,
      action: Action.CREATE,
      metadata: JSON.stringify({
        cid: "",
        data: {
          wallet_address,
          chain: chain2,
          signature: signature2
        }
      }),
      ...advancedOptions
    });
  }
  /** @hidden
   * Remove a wallet from a user
   */
  async removeAssociatedWallet(params) {
    const {
      userId,
      wallet: {
        address: wallet_address,
        chain: chain2
      }
    } = await parseParams("removeAssociatedWallet", RemoveAssociatedWalletSchema)(params);
    return await this.entityManager.manageEntity({
      userId,
      entityType: EntityType.ASSOCIATED_WALLET,
      entityId: 0,
      action: Action.DELETE,
      metadata: JSON.stringify({
        cid: "",
        data: {
          wallet_address,
          chain: chain2
        }
      })
    });
  }
  /** @hidden
   * Update user collectibles preferences
   */
  async updateCollectibles(params) {
    const {
      userId,
      collectibles
    } = await parseParams("updateCollectibles", UpdateCollectiblesSchema)(params);
    return await this.entityManager.manageEntity({
      userId,
      entityType: EntityType.COLLECTIBLES,
      entityId: 0,
      action: Action.UPDATE,
      metadata: JSON.stringify({
        cid: "",
        data: {
          collectibles: collectibles !== null && collectibles !== void 0 ? collectibles : {}
        }
      })
    });
  }
};
var developmentConfig = {
  network: {
    minVersion: "0.0.0",
    apiEndpoint: "http://audius-api",
    storageNodes: [{
      delegateOwnerWallet: "0x0D38e653eC28bdea5A2296fD5940aaB2D0B8875c",
      endpoint: "http://audius-creator-node-1"
    }],
    antiAbuseOracleNodes: {
      endpoints: ["http://audius-anti-abuse-oracle-1:8000"],
      registeredAddresses: ["0xF0D5BC18421fa04D0a2A2ef540ba5A9f04014BE3"]
    },
    identityService: "http://audius-identity-service-1"
  },
  acdc: {
    entityManagerContractAddress: "0x254dffcd3277C0b1660F6d42EFbB754edaBAbC2B",
    chainId: 1337
  },
  solana: {
    claimableTokensProgramAddress: "testHKV1B56fbvop4w6f2cTGEub9dRQ2Euta5VmqdX9",
    rewardManagerProgramAddress: "testLsJKtyABc9UXJF8JWFKf1YH4LmqCWBC42c6akPb",
    rewardManagerStateAddress: "DJPzVothq58SmkpRb1ATn5ddN2Rpv1j2TcGvM3XsHf1c",
    paymentRouterProgramAddress: "apaySbqV1XAmuiGszeN4NyWrXkkMrnuJVoNhzmS1AMa",
    stakingBridgeProgramAddress: "",
    rpcEndpoint: "http://audius-solana-test-validator-1",
    usdcTokenMint: "26Q7gP8UfkDzi7GMFEQxTJaNJ8D2ybCUjex58M5MLu8y",
    wAudioTokenMint: "37RCjhgV1qGV2Q54EHFScdxZ22ydRMdKMtVgod47fDP3",
    bonkTokenMint: "DezXAZ8z7PnrnRJjz3wXBoRgixCa6xjnB7YaB1pPB263",
    rewardManagerLookupTableAddress: "GNHKVSmHvoRBt1JJCxz7RSMfzDQGDGhGEjmhHyxb3K5J"
  },
  ethereum: {
    rpcEndpoint: "http://audius-eth-ganache-1",
    addresses: {
      ethRewardsManagerAddress: "0x",
      serviceProviderFactoryAddress: "0x",
      serviceTypeManagerAddress: "0x",
      audiusTokenAddress: "0xdcB2fC9469808630DD0744b0adf97C0003fC29B2",
      audiusWormholeAddress: "0x",
      delegateManagerAddress: "0x",
      stakingAddress: "0x"
    }
  }
};
var stagingConfig = {
  network: {
    minVersion: "0.6.0",
    apiEndpoint: "https://api.staging.audius.co",
    storageNodes: [{
      endpoint: "https://creatornode12.staging.audius.co",
      delegateOwnerWallet: "0x6b52969934076318863243fb92E9C4b3A08267b5"
    }, {
      endpoint: "https://creatornode5.staging.audius.co",
      delegateOwnerWallet: "0xDC2BDF1F23381CA2eC9e9c70D4FD96CD8645D090"
    }, {
      endpoint: "https://creatornode6.staging.audius.co",
      delegateOwnerWallet: "0x68039d001D87E7A5E6B06fe0825EA7871C1Cd6C2"
    }, {
      endpoint: "https://creatornode7.staging.audius.co",
      delegateOwnerWallet: "0x1F8e7aF58086992Ef4c4fc0371446974BBbC0D9F"
    }, {
      endpoint: "https://creatornode9.staging.audius.co",
      delegateOwnerWallet: "0x140eD283b33be2145ed7d9d15f1fE7bF1E0B2Ac3"
    }, {
      endpoint: "https://creatornode11.staging.audius.co",
      delegateOwnerWallet: "0x4c88d2c0f4c4586b41621aD6e98882ae904B98f6"
    }],
    antiAbuseOracleNodes: {
      endpoints: ["https://discoveryprovider.staging.audius.co"],
      registeredAddresses: ["0x00b6462e955dA5841b6D9e1E2529B830F00f31Bf", "0x57B57efFA54ba37DBF8A06B9c42E7611e84BDe6F", "0xF617bbc0913bAE0a13f6D4A19eCDE5Aa07B0fF0A"]
    },
    identityService: "https://identityservice.staging.audius.co"
  },
  acdc: {
    entityManagerContractAddress: "0x1Cd8a543596D499B9b6E7a6eC15ECd2B7857Fd64",
    chainId: 1056801
  },
  solana: {
    claimableTokensProgramAddress: "2sjQNmUfkV6yKKi4dPR8gWRgtyma5aiymE3aXL2RAZww",
    rewardManagerProgramAddress: "CDpzvz7DfgbF95jSSCHLX3ERkugyfgn9Fw8ypNZ1hfXp",
    rewardManagerStateAddress: "GaiG9LDYHfZGqeNaoGRzFEnLiwUT7WiC6sA6FDJX9ZPq",
    paymentRouterProgramAddress: "sp28KA2bTnTA4oSZ3r9tTSKfmiXZtZQHnYYQqWfUyVa",
    stakingBridgeProgramAddress: "stkuyR7dTzxV1YnoDo5tfuBmkuKn7zDatimYRDTmQvj",
    rpcEndpoint: "https://audius-fe.rpcpool.com",
    usdcTokenMint: "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v",
    wAudioTokenMint: "BELGiMZQ34SDE6x2FUaML2UHDAgBLS64xvhXjX5tBBZo",
    bonkTokenMint: "DezXAZ8z7PnrnRJjz3wXBoRgixCa6xjnB7YaB1pPB263",
    rewardManagerLookupTableAddress: "ChFCWjeFxM6SRySTfT46zXn2K7m89TJsft4HWzEtkB4J"
  },
  ethereum: {
    rpcEndpoint: "https://eth-client.staging.audius.co",
    addresses: {
      ethRewardsManagerAddress: "0x563483ccD66a49Ca730275F8cf37Dd3E6Da864f1",
      serviceProviderFactoryAddress: "0x377BE01aD31360d0DFB16035A4515954395A8185",
      serviceTypeManagerAddress: "0x9fd76d2cD48022526F3a164541E6552291F4a862",
      audiusTokenAddress: "0x1376180Ee935AA64A27780F4BE97726Df7B0e2B2",
      audiusWormholeAddress: "0xf6f45e4d836da1d4ecd43bb1074620bfb0b7e0d7",
      delegateManagerAddress: "0xDA74d6FfbF268Ac441404f5a61f01103451E8697",
      stakingAddress: "0x5bcF21A4D5Bab9B0869B9c55D233f80135C814C6"
    }
  }
};
var appName;
var apiKey;
var addAppInfoMiddleware = (_ref) => {
  let {
    apiKey: providedApiKey,
    appName: providedAppName,
    services,
    basePath
  } = _ref;
  apiKey = providedApiKey;
  appName = providedAppName;
  return {
    pre: async (context) => {
      var _appName, _apiKey;
      if (!providedAppName) {
        const apiClientConfig = new Configuration$1({
          fetchApi: fetch$1,
          basePath
        });
        const developerApps = new DeveloperAppsApi(apiClientConfig, services.entityManager);
        apiKey = providedApiKey !== null && providedApiKey !== void 0 ? providedApiKey : (await services.audiusWalletClient.getAddresses())[0];
        if (apiKey) {
          var _await$developerApps$;
          appName = (_await$developerApps$ = (await developerApps.getDeveloperApp({
            address: apiKey
          })).data) === null || _await$developerApps$ === void 0 ? void 0 : _await$developerApps$.name;
        }
      }
      if (!appName && !apiKey) {
        throw new Error("No appName or apiKey provided");
      }
      return {
        ...context,
        url: context.url + (context.url.includes("?") ? "&" : "?") + querystring$1({
          app_name: (_appName = appName) !== null && _appName !== void 0 ? _appName : "",
          api_key: (_apiKey = apiKey) !== null && _apiKey !== void 0 ? _apiKey : ""
        }),
        init: {
          ...context.init
        }
      };
    }
  };
};
var SIGNATURE_EXPIRY_MS = 24 * 60 * 60 * 1e3;
var MESSAGE_HEADER = "Encoded-Data-Message";
var SIGNATURE_HEADER = "Encoded-Data-Signature";
var addRequestSignatureMiddleware = (_ref) => {
  let {
    services,
    apiKey: apiKey2,
    apiSecret
  } = _ref;
  const mutex = new Mutex();
  let message = null;
  let signatureAddress = null;
  let signature2 = null;
  let timestamp = null;
  let appWalletClient = null;
  const getSignature = async () => {
    return mutex.runExclusive(async () => {
      const {
        audiusWalletClient,
        logger
      } = services;
      try {
        if (apiSecret && !audiusWalletClient) {
          appWalletClient = createAppWalletClient({
            apiKey: apiKey2 !== null && apiKey2 !== void 0 ? apiKey2 : "0x0000000000000000000000000000000000000000",
            apiSecret
          });
        }
        const signingClient = audiusWalletClient !== null && audiusWalletClient !== void 0 ? audiusWalletClient : appWalletClient;
        const [currentAddress] = await signingClient.getAddresses();
        const currentTimestamp = (/* @__PURE__ */ new Date()).getTime();
        const isExpired = !timestamp || timestamp + SIGNATURE_EXPIRY_MS < currentTimestamp;
        const needsUpdate = !message || !signature2 || isExpired || signatureAddress !== currentAddress;
        if (needsUpdate) {
          if (!currentAddress) {
            throw new Error("Could not get a wallet address.");
          }
          signatureAddress = currentAddress;
          const m = `signature:${currentTimestamp}`;
          signature2 = await signingClient.signMessage({
            message: m
          });
          message = m;
          timestamp = currentTimestamp;
        }
      } catch (e) {
        if (!(e instanceof HedgehogWalletNotFoundError)) {
          logger.warn(`Unable to add request signature: ${e}`);
        }
      }
      return {
        message,
        signature: signature2
      };
    });
  };
  return {
    pre: async (context) => {
      const existingHeaders = context.init.headers;
      if (existingHeaders[MESSAGE_HEADER] && existingHeaders[SIGNATURE_HEADER]) {
        return context;
      }
      const {
        message: message2,
        signature: signature3
      } = await getSignature();
      return !!message2 && !!signature3 ? {
        ...context,
        url: context.url,
        init: {
          ...context.init,
          headers: {
            ...context.init.headers,
            [MESSAGE_HEADER]: message2,
            [SIGNATURE_HEADER]: signature3
          }
        }
      } : context;
    }
  };
};
var isOAuthScopeValid = (scope) => {
  const validScopes = new Set(OAUTH_SCOPE_OPTIONS);
  return scope.findIndex((s) => !validScopes.has(s)) === -1;
};
var isWriteOnceParams = (object) => {
  return "tx" in object && object.tx === "connect_dashboard_wallet" && "wallet" in object || object.tx === "disconnect_dashboard_wallet" && "wallet" in object;
};
var IsWriteAccessGrantedSchema = z.object({
  userId: z.string(),
  apiKey: z.optional(z.custom((data) => {
    return isApiKeyValid(data);
  }))
});
var OAUTH_SCOPE_OPTIONS = ["read", "write", "write_once"];
var OAUTH_URL = {
  production: "https://audius.co/oauth/auth",
  staging: "https://staging.audius.co/oauth/auth"
};
var CSS = `
.audiusLoginButton {
  cursor: pointer;
  font-family: Helvetica, Arial, sans-serif;
  text-align: center;
  color: #FFFFFF;
  font-weight: 700;
  font-size: 14px;
  line-height: 100%;
  align-items: center;
  display: flex;
  border: 0;
  height: 28px;
  justify-content: center;
  padding: 0px 16px;
  background: #CC0FE0;
  border-radius: 4px;
  transition: all 0.07s ease-in-out;
}

.audiusLoginButton:hover {
  background: #D127E3;
  transform: perspective(1px) scale3d(1.04, 1.04, 1.04);
}

.audiusLoginButton.disableHoverGrow:hover {
  transform: none;
}

.audiusLoginButton:active {
  background: #A30CB3;
}

.audiusLoginButton.pill {
  border-radius: 99px;
}

.audiusLoginButton.fullWidth {
  width: 100%;
}

.audiusLoginButton.small {
  height: 20px;
  font-size: 11px;
  padding: 0px 32px;
}

.audiusLoginButton.large {
  height: 40px;
  font-size: 18px;
  padding: 0px 18px;
}
`;
var generateId = () => {
  const arr = new Uint8Array(40 / 2);
  (window.crypto || window.msCrypto).getRandomValues(arr);
  return Array.from(arr, function dec2hex(dec) {
    return dec.toString(16).padStart(2, "0");
  }).join("");
};
var generateAudiusLogoSvg = (size4) => {
  let height;
  let paddingRight;
  if (size4 === "small") {
    height = 16;
    paddingRight = 5;
  } else if (size4 === "medium") {
    height = 18;
    paddingRight = 5;
  } else {
    height = 24;
    paddingRight = 10;
  }
  return `<svg width="${height}px" height="${height}px" viewBox="0 0 56 48" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" style="padding-right: ${paddingRight}px;">
<g id="Assets" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
    <g id="assets" transform="translate(-1555.000000, -2588.000000)">
        <g id="audiusLogoGlyph" transform="translate(1555.000000, 2588.000000)">
            <path d="M55.8191698,46.0362519 L42.4551012,23.3458831 L36.1870263,12.7036635 L29.0910326,0.65551431 C28.5766233,-0.217848954 27.2890668,-0.218676884 26.7734944,0.654065432 L13.3787621,23.3270477 L7.90582764,32.5909699 C7.39025522,33.4637122 8.03324043,34.5553386 9.06332791,34.5560631 L19.4031138,34.56279 C19.881044,34.5631005 20.3230236,34.3136864 20.5623059,33.9087249 L25.9362708,24.8122516 L26.7580568,23.4212248 C26.790518,23.3662709 26.8260456,23.3149392 26.8641108,23.2669192 C27.4325516,22.5520012 28.5935412,22.6041608 29.0755951,23.4226737 L34.6514114,32.8894388 L35.682239,34.6396841 C35.7412402,34.7399672 35.7843808,34.8430445 35.813987,34.9470533 C36.0430129,35.7492145 35.4339691,36.6039494 34.5220954,36.6034319 L22.3586676,36.5954631 C21.8806317,36.5951526 21.4387578,36.8445667 21.1994756,37.2496317 L16.0236614,46.0105861 C15.5080889,46.8833284 16.1510741,47.9749548 17.1810559,47.9756793 L27.9002253,47.9827167 L41.2664086,47.9913065 L54.6590261,47.9999997 C55.6892193,48.0006207 56.3335791,46.9096152 55.8191698,46.0362519" id="Audius-Logo" fill="#ffffff" fill-rule="evenodd"></path>
            <rect id="bound" x="0" y="0" width="56" height="48"></rect>
        </g>
    </g>
</g>
</svg>`;
};
var CSRF_TOKEN_KEY = "audiusOauthState";
var OAuth = class {
  constructor(config) {
    var _config$apiKey;
    _defineProperty$1(this, "config", void 0);
    _defineProperty$1(this, "activePopupWindow", void 0);
    _defineProperty$1(this, "popupCheckInterval", void 0);
    _defineProperty$1(this, "loginSuccessCallback", void 0);
    _defineProperty$1(this, "loginErrorCallback", void 0);
    _defineProperty$1(this, "apiKey", void 0);
    _defineProperty$1(this, "env", "production");
    _defineProperty$1(this, "logger", void 0);
    this.config = config;
    if (typeof window === "undefined") {
      throw new Error("Audius OAuth SDK functions are only available in browser. Refer to our documentation to learn how to implement Audius OAuth manually: https://docs.audius.org/developers/log-in-with-audius#manual-implementation.");
    }
    this.apiKey = (_config$apiKey = config.apiKey) !== null && _config$apiKey !== void 0 ? _config$apiKey : null;
    this.activePopupWindow = null;
    this.loginSuccessCallback = null;
    this.loginErrorCallback = null;
    this.popupCheckInterval = null;
    this.logger = config.logger.createPrefixedLogger("[oauth]");
  }
  init(_ref) {
    let {
      successCallback,
      errorCallback,
      env = "production"
    } = _ref;
    this.loginSuccessCallback = successCallback;
    this.loginErrorCallback = errorCallback !== null && errorCallback !== void 0 ? errorCallback : null;
    this.env = env;
    window.addEventListener("message", (e) => {
      this._receiveMessage(e);
    }, false);
  }
  async isWriteAccessGranted(params) {
    var _authorizedApps$data;
    const {
      userId,
      apiKey: apiKey2
    } = await parseParams("isWriteAccessGranted", IsWriteAccessGrantedSchema)(params);
    if (!this.apiKey && !apiKey2) {
      this._surfaceError("Need to init Audius SDK with API key or pass in API Key directly to oauth.isWriteAccessGranted.");
    }
    const authorizedApps = await this.config.usersApi.getAuthorizedApps({
      id: userId
    });
    const foundIndex = (_authorizedApps$data = authorizedApps.data) === null || _authorizedApps$data === void 0 ? void 0 : _authorizedApps$data.findIndex((a) => a.address.toLowerCase() === `0x${(apiKey2 || this.apiKey).toLowerCase()}`);
    return foundIndex !== void 0 && foundIndex > -1;
  }
  login(_ref2) {
    let {
      scope = "read",
      params,
      redirectUri = "postMessage",
      display = "popup",
      responseMode = "fragment"
    } = _ref2;
    const scopeFormatted = typeof scope === "string" ? [scope] : scope;
    if (!this.config.appName && !this.apiKey) {
      this._surfaceError("App name not set (set with `init` method).");
      return;
    }
    if (scopeFormatted.includes("write") && !this.apiKey) {
      this._surfaceError("The 'write' scope requires Audius SDK to be initialized with an API key");
    }
    if (!this.loginSuccessCallback) {
      this._surfaceError("Login success callback not set (set with `init` method).");
      return;
    }
    if (!isOAuthScopeValid(scopeFormatted)) {
      this._surfaceError("Scope must be `read` or `write`.");
      return;
    }
    const effectiveScope = scopeFormatted.includes("write") ? "write" : scopeFormatted.includes("write_once") ? "write_once" : "read";
    if (effectiveScope === "write_once" && !isWriteOnceParams(params)) {
      this._surfaceError("Missing correct params for `oauth.login`.");
      return;
    }
    const csrfToken = generateId();
    window.localStorage.setItem(CSRF_TOKEN_KEY, csrfToken);
    const windowOptions = "toolbar=no, location=no, directories=no, status=no, menubar=no, scrollbars=no, resizable=no, copyhistory=no, width=375, height=785, top=100, left=100";
    const originURISafe = encodeURIComponent(window.location.origin);
    const appIdURISafe = encodeURIComponent(this.apiKey || this.config.appName);
    const writeOnceParams = effectiveScope !== "write_once" ? "" : `&tx=${encodeURIComponent(params.tx)}&wallet=${encodeURIComponent(params.wallet)}`;
    const appIdURIParam = `${this.apiKey ? "api_key" : "app_name"}=${appIdURISafe}`;
    const responseModeParam = `response_mode=${responseMode}`;
    const fullOauthUrl = `${OAUTH_URL[this.env]}?scope=${effectiveScope}&state=${csrfToken}&redirect_uri=${redirectUri}&origin=${originURISafe}&${responseModeParam}&${appIdURIParam}${writeOnceParams}&display=${display}`;
    if (redirectUri === "postMessage") {
      this.activePopupWindow = window.open(fullOauthUrl, "", windowOptions);
      this._clearPopupCheckInterval();
      this.popupCheckInterval = setInterval(() => {
        var _this$activePopupWind;
        if ((_this$activePopupWind = this.activePopupWindow) !== null && _this$activePopupWind !== void 0 && _this$activePopupWind.closed) {
          this._surfaceError("The login popup was closed prematurely.");
          if (this.popupCheckInterval) {
            clearInterval(this.popupCheckInterval);
          }
        }
      }, 500);
    } else {
      window.location.href = fullOauthUrl;
    }
  }
  renderButton(_ref3) {
    var _buttonOptions$size, _buttonOptions$custom;
    let {
      element,
      scope = "read",
      buttonOptions
    } = _ref3;
    if (!element) {
      this.logger.error("Target element for Audius OAuth button is empty.");
    }
    const style = document.createElement("style");
    style.textContent = CSS;
    document.head.appendChild(style);
    const button = document.createElement("button");
    button.id = "audius-login-button";
    button.classList.add("audiusLoginButton");
    if ((buttonOptions === null || buttonOptions === void 0 ? void 0 : buttonOptions.corners) === "pill") {
      button.classList.add("pill");
    }
    if ((buttonOptions === null || buttonOptions === void 0 ? void 0 : buttonOptions.size) === "small") {
      button.classList.add("small");
    }
    if ((buttonOptions === null || buttonOptions === void 0 ? void 0 : buttonOptions.size) === "large") {
      button.classList.add("large");
    }
    if (buttonOptions !== null && buttonOptions !== void 0 && buttonOptions.fullWidth) {
      button.classList.add("fullWidth");
    }
    if (buttonOptions !== null && buttonOptions !== void 0 && buttonOptions.disableHoverGrow) {
      button.classList.add("disableHoverGrow");
    }
    button.innerHTML = `${generateAudiusLogoSvg((_buttonOptions$size = buttonOptions === null || buttonOptions === void 0 ? void 0 : buttonOptions.size) !== null && _buttonOptions$size !== void 0 ? _buttonOptions$size : "medium")} ${(_buttonOptions$custom = buttonOptions === null || buttonOptions === void 0 ? void 0 : buttonOptions.customText) !== null && _buttonOptions$custom !== void 0 ? _buttonOptions$custom : "Continue With Audius"}`;
    button.onclick = () => {
      this.login({
        scope
      });
    };
    element.replaceWith(button);
  }
  /**
   * Verify if the given jwt ID token was signed by the subject (user) in the payload
   * @deprecated see `UsersApi.verifyIDToken`
   * @param token the token to verify
   * @returns
   */
  async verifyToken(token2) {
    return await this.config.usersApi.verifyIDToken({
      token: token2
    });
  }
  getCsrfToken() {
    return window.localStorage.getItem(CSRF_TOKEN_KEY);
  }
  /* ------- INTERNAL FUNCTIONS ------- */
  _surfaceError(errorMessage) {
    if (this.loginErrorCallback) {
      this.loginErrorCallback(errorMessage);
    } else {
      this.logger.error(errorMessage);
    }
  }
  _clearPopupCheckInterval() {
    if (this.popupCheckInterval) {
      clearInterval(this.popupCheckInterval);
    }
  }
  async _receiveMessage(event) {
    const oauthOrigin = new URL(OAUTH_URL[this.env]).origin;
    if (event.origin !== oauthOrigin || event.source !== this.activePopupWindow || !event.data.state || !event.data.token) {
      return;
    }
    this._clearPopupCheckInterval();
    if (this.activePopupWindow) {
      if (!this.activePopupWindow.closed) {
        this.activePopupWindow.close();
      }
      this.activePopupWindow = null;
    }
    if (this.getCsrfToken() !== event.data.state) {
      this._surfaceError("State mismatch.");
    }
    const decodedJwt = await this.verifyToken(event.data.token);
    if (decodedJwt !== null && decodedJwt !== void 0 && decodedJwt.data) {
      if (this.loginSuccessCallback) {
        this.loginSuccessCallback(decodedJwt.data, event.data.token);
      }
    } else {
      this._surfaceError("The token was invalid.");
    }
  }
};
var DevAppSchema = z.object({
  /**
   * Your app name
   */
  appName: z.optional(z.string()),
  /**
   * Services injection
   */
  services: z.optional(z.custom()),
  /**
   * API key, required for writes
   */
  apiKey: z.string().min(1),
  /**
   * API secret, required for writes
   */
  apiSecret: z.optional(z.string().min(1)),
  /**
   * Target environment
   * @internal
   */
  environment: z.enum(["development", "staging", "production"]).optional()
});
var CustomAppSchema = z.object({
  /**
   * Your app name
   */
  appName: z.string().min(1),
  /**
   * Services injection
   */
  services: z.optional(z.custom()),
  /**
   * API key, required for writes
   */
  apiKey: z.optional(z.string().min(1)),
  /**
   * API secret, required for writes
   */
  apiSecret: z.optional(z.string().min(1)),
  /**
   * Target environment
   * @internal
   */
  environment: z.enum(["development", "staging", "production"]).optional()
});
var SdkConfigSchema = z.union([DevAppSchema, CustomAppSchema]);
var sdk = (config) => {
  SdkConfigSchema.parse(config);
  const {
    appName: appName2,
    apiKey: apiKey2
  } = config;
  const services = initializeServices(config);
  const apis = initializeApis({
    config,
    apiKey: apiKey2,
    appName: appName2,
    services
  });
  const oauth = typeof window !== "undefined" ? new OAuth({
    appName: appName2,
    apiKey: apiKey2,
    usersApi: apis.users,
    logger: services.logger
  }) : void 0;
  return {
    oauth,
    ...apis
  };
};
var initializeServices = (config) => {
  var _config$services$logg, _config$services, _config$services$audi, _config$services2, _config$apiKey, _config$services$ethP, _config$services3, _config$services$ethW, _config$services4, _config$services$stor, _config$services5, _config$services$enti, _config$services6, _config$services$stor2, _config$services7, _config$services$anti, _config$services8, _config$services$anti2, _config$services9, _config$services0, _config$services1, _config$services$emai, _config$services10, _config$services$sola, _config$services11, _config$services$sola2, _config$services12, _config$services$clai, _config$services13, _config$services$rewa, _config$services14, _config$services$paym, _config$services15, _config$services$audi2, _config$services16, _config$services$clai2, _config$services17, _config$services$dele, _config$services18, _config$services$stak, _config$services19, _config$services$trus, _config$services20, _config$services$audi3, _config$services21, _config$services$regi, _config$services22, _config$services$gove, _config$services23, _config$services$serv, _config$services24, _config$services$serv2, _config$services25, _config$services$ethR, _config$services26;
  const servicesConfig = config.environment === "development" ? developmentConfig : config.environment === "staging" ? stagingConfig : productionConfig;
  const defaultLogger = new Logger({
    logLevel: config.environment !== "production" ? "debug" : void 0
  });
  const logger = (_config$services$logg = (_config$services = config.services) === null || _config$services === void 0 ? void 0 : _config$services.logger) !== null && _config$services$logg !== void 0 ? _config$services$logg : defaultLogger;
  const isBrowser = typeof window !== "undefined" && typeof window.document !== "undefined";
  if (config.apiSecret && isBrowser) {
    logger.warn("apiSecret should only be provided server side so that it isn't exposed");
  }
  const audiusWalletClient = (_config$services$audi = (_config$services2 = config.services) === null || _config$services2 === void 0 ? void 0 : _config$services2.audiusWalletClient) !== null && _config$services$audi !== void 0 ? _config$services$audi : createAppWalletClient({
    // Allow undefined apiKey for now, use dummy wallet
    apiKey: (_config$apiKey = config.apiKey) !== null && _config$apiKey !== void 0 ? _config$apiKey : "0x0000000000000000000000000000000000000000",
    apiSecret: config.apiSecret
  });
  const ethPublicClient = (_config$services$ethP = (_config$services3 = config.services) === null || _config$services3 === void 0 ? void 0 : _config$services3.ethPublicClient) !== null && _config$services$ethP !== void 0 ? _config$services$ethP : createPublicClient({
    chain: mainnet,
    transport: http(servicesConfig.ethereum.rpcEndpoint)
  });
  const ethWalletClient = (_config$services$ethW = (_config$services4 = config.services) === null || _config$services4 === void 0 ? void 0 : _config$services4.ethWalletClient) !== null && _config$services$ethW !== void 0 ? _config$services$ethW : createWalletClient({
    chain: mainnet,
    transport: http(servicesConfig.ethereum.rpcEndpoint)
  });
  const storageNodeSelector = (_config$services$stor = (_config$services5 = config.services) === null || _config$services5 === void 0 ? void 0 : _config$services5.storageNodeSelector) !== null && _config$services$stor !== void 0 ? _config$services$stor : new StorageNodeSelector({
    ...getDefaultStorageNodeSelectorConfig(servicesConfig),
    logger
  });
  const entityManager = (_config$services$enti = (_config$services6 = config.services) === null || _config$services6 === void 0 ? void 0 : _config$services6.entityManager) !== null && _config$services$enti !== void 0 ? _config$services$enti : new EntityManagerClient({
    ...getDefaultEntityManagerConfig(servicesConfig),
    audiusWalletClient,
    logger
  });
  const storage = (_config$services$stor2 = (_config$services7 = config.services) === null || _config$services7 === void 0 ? void 0 : _config$services7.storage) !== null && _config$services$stor2 !== void 0 ? _config$services$stor2 : new Storage({
    ...getDefaultStorageServiceConfig(),
    storageNodeSelector,
    logger
  });
  const antiAbuseOracleSelector = (_config$services$anti = (_config$services8 = config.services) === null || _config$services8 === void 0 ? void 0 : _config$services8.antiAbuseOracleSelector) !== null && _config$services$anti !== void 0 ? _config$services$anti : new AntiAbuseOracleSelector({
    ...getDefaultAntiAbuseOracleSelectorConfig(servicesConfig),
    logger
  });
  const antiAbuseOracle = (_config$services$anti2 = (_config$services9 = config.services) === null || _config$services9 === void 0 ? void 0 : _config$services9.antiAbuseOracle) !== null && _config$services$anti2 !== void 0 ? _config$services$anti2 : new AntiAbuseOracle({
    antiAbuseOracleSelector
  });
  const middleware = [addRequestSignatureMiddleware({
    services: {
      audiusWalletClient,
      logger
    },
    apiKey: config.apiKey,
    apiSecret: config.apiSecret
  })];
  const solanaRelay = (_config$services0 = config.services) !== null && _config$services0 !== void 0 && _config$services0.solanaRelay ? config.services.solanaRelay.withMiddleware(addRequestSignatureMiddleware({
    services: {
      audiusWalletClient,
      logger
    },
    apiKey: config.apiKey,
    apiSecret: config.apiSecret
  })) : new SolanaRelay(new Configuration$1({
    middleware
  }));
  const archiverService = (_config$services1 = config.services) !== null && _config$services1 !== void 0 && _config$services1.archiverService ? config.services.archiverService.withMiddleware(addRequestSignatureMiddleware({
    services: {
      audiusWalletClient,
      logger
    },
    apiKey: config.apiKey,
    apiSecret: config.apiSecret
  })) : void 0;
  const emailEncryptionService = (_config$services$emai = (_config$services10 = config.services) === null || _config$services10 === void 0 ? void 0 : _config$services10.emailEncryptionService) !== null && _config$services$emai !== void 0 ? _config$services$emai : new EmailEncryptionService(new Configuration$1({
    fetchApi: fetch$1,
    basePath: "",
    middleware
  }), audiusWalletClient);
  const solanaWalletAdapter = (_config$services$sola = (_config$services11 = config.services) === null || _config$services11 === void 0 ? void 0 : _config$services11.solanaWalletAdapter) !== null && _config$services$sola !== void 0 ? _config$services$sola : new SolanaRelayWalletAdapter({
    solanaRelay
  });
  const solanaClient = (_config$services$sola2 = (_config$services12 = config.services) === null || _config$services12 === void 0 ? void 0 : _config$services12.solanaClient) !== null && _config$services$sola2 !== void 0 ? _config$services$sola2 : new SolanaClient({
    ...getDefaultSolanaClientConfig(servicesConfig),
    solanaWalletAdapter,
    logger
  });
  const claimableTokensClient = (_config$services$clai = (_config$services13 = config.services) === null || _config$services13 === void 0 ? void 0 : _config$services13.claimableTokensClient) !== null && _config$services$clai !== void 0 ? _config$services$clai : new ClaimableTokensClient({
    ...getDefaultClaimableTokensConfig(servicesConfig),
    solanaClient,
    audiusWalletClient,
    logger
  });
  const rewardManagerClient = (_config$services$rewa = (_config$services14 = config.services) === null || _config$services14 === void 0 ? void 0 : _config$services14.rewardManagerClient) !== null && _config$services$rewa !== void 0 ? _config$services$rewa : new RewardManagerClient({
    ...getDefaultRewardManagerClentConfig(servicesConfig),
    solanaClient,
    logger
  });
  const paymentRouterClient = (_config$services$paym = (_config$services15 = config.services) === null || _config$services15 === void 0 ? void 0 : _config$services15.paymentRouterClient) !== null && _config$services$paym !== void 0 ? _config$services$paym : new PaymentRouterClient({
    ...getDefaultPaymentRouterClientConfig(servicesConfig),
    solanaClient
  });
  const audiusTokenClient = (_config$services$audi2 = (_config$services16 = config.services) === null || _config$services16 === void 0 ? void 0 : _config$services16.audiusTokenClient) !== null && _config$services$audi2 !== void 0 ? _config$services$audi2 : new AudiusTokenClient({
    audiusWalletClient,
    ethPublicClient,
    ethWalletClient,
    ...getDefaultAudiusTokenConfig(servicesConfig)
  });
  const claimsManagerClient = (_config$services$clai2 = (_config$services17 = config.services) === null || _config$services17 === void 0 ? void 0 : _config$services17.claimsManagerClient) !== null && _config$services$clai2 !== void 0 ? _config$services$clai2 : new ClaimsManagerClient({
    ...getDefaultClaimsManagerConfig(servicesConfig)
  });
  const delegateManagerClient = (_config$services$dele = (_config$services18 = config.services) === null || _config$services18 === void 0 ? void 0 : _config$services18.delegateManagerClient) !== null && _config$services$dele !== void 0 ? _config$services$dele : new DelegateManagerClient({
    audiusWalletClient,
    ethPublicClient,
    ethWalletClient,
    ...getDefaultDelegateManagerConfig(servicesConfig)
  });
  const stakingClient = (_config$services$stak = (_config$services19 = config.services) === null || _config$services19 === void 0 ? void 0 : _config$services19.stakingClient) !== null && _config$services$stak !== void 0 ? _config$services$stak : new StakingClient({
    audiusWalletClient,
    ethPublicClient,
    ethWalletClient,
    ...getDefaultStakingConfig(servicesConfig)
  });
  const trustedNotifierManagerClient = (_config$services$trus = (_config$services20 = config.services) === null || _config$services20 === void 0 ? void 0 : _config$services20.trustedNotifierManagerClient) !== null && _config$services$trus !== void 0 ? _config$services$trus : new TrustedNotifierManagerClient({
    ...getDefaultTrustedNotifierManagerConfig(servicesConfig)
  });
  const audiusWormholeClient = (_config$services$audi3 = (_config$services21 = config.services) === null || _config$services21 === void 0 ? void 0 : _config$services21.audiusWormholeClient) !== null && _config$services$audi3 !== void 0 ? _config$services$audi3 : new AudiusWormholeClient({
    audiusWalletClient,
    ethPublicClient,
    ethWalletClient,
    ...getDefaultWormholeConfig(servicesConfig)
  });
  const registryClient = (_config$services$regi = (_config$services22 = config.services) === null || _config$services22 === void 0 ? void 0 : _config$services22.registryClient) !== null && _config$services$regi !== void 0 ? _config$services$regi : new RegistryClient({
    ...getDefaultRegistryConfig(servicesConfig)
  });
  const governanceClient = (_config$services$gove = (_config$services23 = config.services) === null || _config$services23 === void 0 ? void 0 : _config$services23.governanceClient) !== null && _config$services$gove !== void 0 ? _config$services$gove : new GovernanceClient({
    ...getDefaultGovernanceConfig(servicesConfig)
  });
  const serviceTypeManagerClient = (_config$services$serv = (_config$services24 = config.services) === null || _config$services24 === void 0 ? void 0 : _config$services24.serviceTypeManagerClient) !== null && _config$services$serv !== void 0 ? _config$services$serv : new ServiceTypeManagerClient({
    ...getDefaultServiceTypeManagerConfig(servicesConfig)
  });
  const serviceProviderFactoryClient = (_config$services$serv2 = (_config$services25 = config.services) === null || _config$services25 === void 0 ? void 0 : _config$services25.serviceProviderFactoryClient) !== null && _config$services$serv2 !== void 0 ? _config$services$serv2 : new ServiceProviderFactoryClient({
    ...getDefaultServiceProviderFactoryConfig(servicesConfig)
  });
  const ethRewardsManagerClient = (_config$services$ethR = (_config$services26 = config.services) === null || _config$services26 === void 0 ? void 0 : _config$services26.ethRewardsManagerClient) !== null && _config$services$ethR !== void 0 ? _config$services$ethR : new EthRewardsManagerClient({
    ...getDefaultEthRewardsManagerConfig(servicesConfig)
  });
  const services = {
    storageNodeSelector,
    antiAbuseOracleSelector,
    entityManager,
    storage,
    audiusWalletClient,
    ethPublicClient,
    ethWalletClient,
    claimableTokensClient,
    rewardManagerClient,
    paymentRouterClient,
    solanaClient,
    solanaWalletAdapter,
    solanaRelay,
    antiAbuseOracle,
    audiusTokenClient,
    claimsManagerClient,
    delegateManagerClient,
    stakingClient,
    trustedNotifierManagerClient,
    audiusWormholeClient,
    registryClient,
    governanceClient,
    serviceTypeManagerClient,
    serviceProviderFactoryClient,
    ethRewardsManagerClient,
    emailEncryptionService,
    archiverService,
    logger
  };
  return services;
};
var initializeApis = (_ref) => {
  let {
    config,
    apiKey: apiKey2,
    appName: appName2,
    services
  } = _ref;
  const apiEndpoint = config.environment === "development" ? developmentConfig.network.apiEndpoint : config.environment === "staging" ? stagingConfig.network.apiEndpoint : productionConfig.network.apiEndpoint;
  const basePath = `${apiEndpoint}/v1`;
  const middleware = [addAppInfoMiddleware({
    apiKey: apiKey2,
    appName: appName2,
    services,
    basePath
  }), addRequestSignatureMiddleware({
    services,
    apiKey: apiKey2,
    apiSecret: config.apiSecret
  })];
  const apiClientConfig = new Configuration$1({
    fetchApi: fetch$1,
    middleware,
    basePath
  });
  const tracks = new TracksApi(apiClientConfig, services.storage, services.entityManager, services.logger, services.claimableTokensClient, services.paymentRouterClient, services.solanaRelay, services.solanaClient);
  const users = new UsersApi(apiClientConfig, services.storage, services.entityManager, services.logger, services.claimableTokensClient, services.solanaClient, services.emailEncryptionService);
  const albums = new AlbumsApi(apiClientConfig, services.storage, services.entityManager, services.logger, services.claimableTokensClient, services.paymentRouterClient, services.solanaRelay, services.solanaClient);
  const playlists = new PlaylistsApi$1(apiClientConfig, services.storage, services.entityManager, services.logger);
  const comments = new CommentsApi$1(apiClientConfig, services.entityManager, services.logger);
  const challenges = new ChallengesApi$1(apiClientConfig);
  const coins = new CoinsApi$1(apiClientConfig);
  const tips = new TipsApi$1(apiClientConfig);
  const resolveApi = new ResolveApi(apiClientConfig);
  const rewards = new RewardsApi(apiClientConfig);
  const resolve2 = resolveApi.resolve.bind(resolveApi);
  const chats = new ChatsApi(new Configuration$1({
    basePath: apiEndpoint,
    fetchApi: fetch$1,
    middleware
  }), services.audiusWalletClient, services.logger);
  const grants = new GrantsApi(apiClientConfig, services.entityManager, users);
  const developerApps = new DeveloperAppsApi(apiClientConfig, services.entityManager);
  const dashboardWalletUsers = new DashboardWalletUsersApi(apiClientConfig, services.entityManager);
  const notifications = new NotificationsApi(apiClientConfig, services.entityManager);
  const generatedApiClientConfigFull = new Configuration({
    basePath: `${basePath}/full`,
    fetchApi: fetch$1,
    middleware
  });
  const events2 = new EventsApi(apiClientConfig, services.entityManager, services.logger);
  const explore = new ExploreApi$1(apiClientConfig);
  const full = {
    tracks: new TracksApi$1(generatedApiClientConfigFull),
    users: new UsersApi$1(generatedApiClientConfigFull),
    search: new SearchApi(generatedApiClientConfigFull),
    playlists: new PlaylistsApi(generatedApiClientConfigFull),
    reactions: new ReactionsApi(generatedApiClientConfigFull),
    tips: new TipsApi(generatedApiClientConfigFull),
    transactions: new TransactionsApi(generatedApiClientConfigFull),
    notifications: new NotificationsApi$1(generatedApiClientConfigFull),
    cidData: new CidDataApi(generatedApiClientConfigFull),
    comments: new CommentsApi(generatedApiClientConfigFull),
    explore: new ExploreApi(generatedApiClientConfigFull)
  };
  return {
    tracks,
    users,
    albums,
    playlists,
    tips,
    resolve: resolve2,
    full,
    chats,
    grants,
    developerApps,
    dashboardWalletUsers,
    rewards,
    services,
    comments,
    notifications,
    events: events2,
    explore,
    coins,
    challenges
  };
};
var MissingOtpUserAuthError = class _MissingOtpUserAuthError extends Error {
  constructor(message) {
    super(message);
    Object.setPrototypeOf(this, _MissingOtpUserAuthError.prototype);
  }
};
var AntiAbuseOracleAttestationError = class _AntiAbuseOracleAttestationError extends Error {
  constructor(code2, message) {
    super(message);
    _defineProperty$1(this, "code", void 0);
    _defineProperty$1(this, "name", "AntiAbuseOracleAttestationError");
    this.code = code2;
    Object.setPrototypeOf(this, _AntiAbuseOracleAttestationError.prototype);
  }
};
var errors = Object.freeze({
  __proto__: null,
  MissingOtpUserAuthError,
  AntiAbuseOracleAttestationError
});
export {
  ALLOWED_AUDIO_MIME_TYPES_REGEX,
  ALLOWED_IMAGE_MIME_TYPES,
  AccessFromJSON$1 as AccessFromJSON,
  AccessFromJSONTyped$1 as AccessFromJSONTyped,
  AccessInfoResponseFromJSON,
  AccessInfoResponseFromJSONTyped,
  AccessInfoResponseToJSON,
  AccessToJSON$1 as AccessToJSON,
  ActivityFromJSON,
  ActivityFromJSONTyped,
  ActivityItemTypeEnum,
  ActivityToJSON,
  AddAssociatedWalletSchema,
  AddManagerSchema,
  AddTrackToPlaylistSchema,
  AlbumBacklinkFromJSON$1 as AlbumBacklinkFromJSON,
  AlbumBacklinkFromJSONTyped$1 as AlbumBacklinkFromJSONTyped,
  AlbumBacklinkToJSON$1 as AlbumBacklinkToJSON,
  AlbumsApi,
  AlbumsResponseFromJSON,
  AlbumsResponseFromJSONTyped,
  AlbumsResponseToJSON,
  AntiAbuseOracle,
  AntiAbuseOracleSelector,
  ApproveGrantSchema,
  ArchiverService,
  AudioFile,
  AudiusTokenClient,
  AudiusWormholeClient,
  AuthorizedAppFromJSON,
  AuthorizedAppFromJSONTyped,
  AuthorizedAppToJSON,
  AuthorizedAppsFromJSON,
  AuthorizedAppsFromJSONTyped,
  AuthorizedAppsToJSON,
  BASE_PATH$1 as BASE_PATH,
  BaseAPI$1 as BaseAPI,
  BestSellingItemContentTypeEnum$1 as BestSellingItemContentTypeEnum,
  BestSellingItemFromJSON$1 as BestSellingItemFromJSON,
  BestSellingItemFromJSONTyped$1 as BestSellingItemFromJSONTyped,
  BestSellingItemToJSON$1 as BestSellingItemToJSON,
  BestSellingResponseFromJSON,
  BestSellingResponseFromJSONTyped,
  BestSellingResponseToJSON,
  BlobApiResponse$1 as BlobApiResponse,
  BlobInfoFromJSON,
  BlobInfoFromJSONTyped,
  BlobInfoToJSON,
  COLLECTION_FORMATS$1 as COLLECTION_FORMATS,
  ChallengeId,
  ChallengeResponseFromJSON,
  ChallengeResponseFromJSONTyped,
  ChallengeResponseToJSON,
  ChallengesApi$1 as ChallengesApi,
  ChatBlastAudience,
  ChatBlastMessageRequestSchema,
  ChatBlockRequestSchema,
  ChatCreateRequestSchema,
  ChatDeleteRequestSchema,
  ChatGetAllRequestSchema,
  ChatGetBlockersRequestSchema,
  ChatGetMessagesRequestSchema,
  ChatGetPermissionRequestSchema,
  ChatGetRequestSchema,
  ChatGetUnreadCountRequestSchema,
  ChatInviteRequestSchema,
  ChatMessageRequestSchema,
  ChatPermission,
  ChatPermitRequestSchema,
  ChatReactRequestSchema,
  ChatReadRequestSchema,
  ChatUnfurlRequestSchema,
  ChatValidateCanCreateRequestSchema,
  ClaimRewardsRequestFromJSON,
  ClaimRewardsRequestFromJSONTyped,
  ClaimRewardsRequestToJSON,
  ClaimRewardsResponseDataInnerFromJSON,
  ClaimRewardsResponseDataInnerFromJSONTyped,
  ClaimRewardsResponseDataInnerToJSON,
  ClaimRewardsResponseFromJSON,
  ClaimRewardsResponseFromJSONTyped,
  ClaimRewardsResponseToJSON,
  ClaimableTokensClient,
  ClaimsManagerClient,
  CoinDynamicBondingCurveFromJSON,
  CoinDynamicBondingCurveFromJSONTyped,
  CoinDynamicBondingCurveToJSON,
  CoinExtensionsFromJSON,
  CoinExtensionsFromJSONTyped,
  CoinExtensionsToJSON,
  CoinFromJSON$1 as CoinFromJSON,
  CoinFromJSONTyped$1 as CoinFromJSONTyped,
  CoinInsightsFromJSON,
  CoinInsightsFromJSONTyped,
  CoinInsightsResponseFromJSON,
  CoinInsightsResponseFromJSONTyped,
  CoinInsightsResponseToJSON,
  CoinInsightsToJSON,
  CoinMemberFromJSON,
  CoinMemberFromJSONTyped,
  CoinMemberToJSON,
  CoinMembersResponseFromJSON,
  CoinMembersResponseFromJSONTyped,
  CoinMembersResponseToJSON,
  CoinResponseFromJSON$1 as CoinResponseFromJSON,
  CoinResponseFromJSONTyped$1 as CoinResponseFromJSONTyped,
  CoinResponseToJSON$1 as CoinResponseToJSON,
  CoinToJSON$1 as CoinToJSON,
  CoinsApi$1 as CoinsApi,
  CoinsResponseFromJSON$1 as CoinsResponseFromJSON,
  CoinsResponseFromJSONTyped$1 as CoinsResponseFromJSONTyped,
  CoinsResponseToJSON$1 as CoinsResponseToJSON,
  CollectibleGatedConditions,
  CollectiblesFromJSON,
  CollectiblesFromJSONTyped,
  CollectiblesResponseFromJSON,
  CollectiblesResponseFromJSONTyped,
  CollectiblesResponseToJSON,
  CollectiblesToJSON,
  CollectionActivityFromJSON,
  CollectionActivityFromJSONTyped,
  CollectionActivityItemTypeEnum,
  CollectionActivityToJSON,
  CommentFromJSON$1 as CommentFromJSON,
  CommentFromJSONTyped$1 as CommentFromJSONTyped,
  CommentMentionFromJSON$1 as CommentMentionFromJSON,
  CommentMentionFromJSONTyped$1 as CommentMentionFromJSONTyped,
  CommentMentionToJSON$1 as CommentMentionToJSON,
  CommentNotificationSettingFromJSON,
  CommentNotificationSettingFromJSONTyped,
  CommentNotificationSettingToJSON,
  CommentRepliesResponseFromJSON$1 as CommentRepliesResponseFromJSON,
  CommentRepliesResponseFromJSONTyped$1 as CommentRepliesResponseFromJSONTyped,
  CommentRepliesResponseToJSON$1 as CommentRepliesResponseToJSON,
  CommentResponseFromJSON$1 as CommentResponseFromJSON,
  CommentResponseFromJSONTyped$1 as CommentResponseFromJSONTyped,
  CommentResponseToJSON$1 as CommentResponseToJSON,
  CommentToJSON$1 as CommentToJSON,
  CommentsApi$1 as CommentsApi,
  Configuration$1 as Configuration,
  ConnectedWalletsFromJSON,
  ConnectedWalletsFromJSONTyped,
  ConnectedWalletsResponseFromJSON,
  ConnectedWalletsResponseFromJSONTyped,
  ConnectedWalletsResponseToJSON,
  ConnectedWalletsToJSON,
  CoverPhotoFromJSON$1 as CoverPhotoFromJSON,
  CoverPhotoFromJSONTyped$1 as CoverPhotoFromJSONTyped,
  CoverPhotoToJSON$1 as CoverPhotoToJSON,
  CreateAlbumMetadataSchema,
  CreateAlbumSchema,
  CreateAssociatedWalletsSchema,
  CreateCoinRequestFromJSON$1 as CreateCoinRequestFromJSON,
  CreateCoinRequestFromJSONTyped$1 as CreateCoinRequestFromJSONTyped,
  CreateCoinRequestToJSON$1 as CreateCoinRequestToJSON,
  CreateCoinResponseDataFromJSON$1 as CreateCoinResponseDataFromJSON,
  CreateCoinResponseDataFromJSONTyped$1 as CreateCoinResponseDataFromJSONTyped,
  CreateCoinResponseDataToJSON$1 as CreateCoinResponseDataToJSON,
  CreateCoinResponseFromJSON$1 as CreateCoinResponseFromJSON,
  CreateCoinResponseFromJSONTyped$1 as CreateCoinResponseFromJSONTyped,
  CreateCoinResponseToJSON$1 as CreateCoinResponseToJSON,
  CreateDashboardWalletUser,
  CreateDeveloperAppSchema,
  CreateGrantSchema,
  CreateMemoInstructionSchema,
  CreatePlaylistSchema,
  CreatePurchaseContentInstructionsSchema,
  CreateRouteInstructionSchema,
  CreateTransferInstructionSchema,
  CreateUserSchema,
  CrossPlatformFileSchema,
  DashboardWalletUserFromJSON,
  DashboardWalletUserFromJSONTyped,
  DashboardWalletUserToJSON,
  DashboardWalletUsersApi,
  DashboardWalletUsersResponseFromJSON,
  DashboardWalletUsersResponseFromJSONTyped,
  DashboardWalletUsersResponseToJSON,
  DecodedUserTokenFromJSON,
  DecodedUserTokenFromJSONTyped,
  DecodedUserTokenToJSON,
  DefaultConfig$1 as DefaultConfig,
  DelegateManagerClient,
  DeleteAlbumSchema,
  DeleteDashboardWalletUserSchema,
  DeleteDeveloperAppSchema,
  DeletePlaylistSchema,
  DeleteTrackSchema,
  DeveloperAppFromJSON,
  DeveloperAppFromJSONTyped,
  DeveloperAppResponseFromJSON,
  DeveloperAppResponseFromJSONTyped,
  DeveloperAppResponseToJSON,
  DeveloperAppToJSON,
  DeveloperAppsApi,
  DeveloperAppsFromJSON,
  DeveloperAppsFromJSONTyped,
  DeveloperAppsToJSON,
  EmailAccessFromJSON,
  EmailAccessFromJSONTyped,
  EmailAccessResponseFromJSON,
  EmailAccessResponseFromJSONTyped,
  EmailAccessResponseToJSON,
  EmailAccessToJSON,
  EmailEncryptionService,
  EmailSchema,
  Action as EntityManagerAction,
  EntityManagerClient,
  EntityType,
  errors as Errors,
  EthCollectibleGatedConditions,
  EthRewardsManagerClient,
  EventEntityTypeEnum,
  EventEventTypeEnum,
  EventFromJSON,
  EventFromJSONTyped,
  EventToJSON,
  EventsApi,
  EventsResponseFromJSON,
  EventsResponseFromJSONTyped,
  EventsResponseToJSON,
  ExploreApi$1 as ExploreApi,
  ExtendedAccessGateFromJSON,
  ExtendedAccessGateFromJSONTyped,
  ExtendedAccessGateToJSON,
  ExtendedPaymentSplitFromJSON,
  ExtendedPaymentSplitFromJSONTyped,
  ExtendedPaymentSplitToJSON,
  ExtendedPurchaseGateFromJSON,
  ExtendedPurchaseGateFromJSONTyped,
  ExtendedPurchaseGateToJSON,
  ExtendedTokenGateFromJSON$1 as ExtendedTokenGateFromJSON,
  ExtendedTokenGateFromJSONTyped$1 as ExtendedTokenGateFromJSONTyped,
  ExtendedTokenGateToJSON$1 as ExtendedTokenGateToJSON,
  ExtendedUsdcGateFromJSON,
  ExtendedUsdcGateFromJSONTyped,
  ExtendedUsdcGateToJSON,
  FavoriteAlbumSchema,
  FavoriteFromJSON$1 as FavoriteFromJSON,
  FavoriteFromJSONTyped$1 as FavoriteFromJSONTyped,
  FavoritePlaylistSchema,
  FavoriteToJSON$1 as FavoriteToJSON,
  FavoriteTrackSchema,
  FavoritesResponseFromJSON,
  FavoritesResponseFromJSONTyped,
  FavoritesResponseToJSON,
  FetchError$1 as FetchError,
  FollowGateFromJSON$1 as FollowGateFromJSON,
  FollowGateFromJSONTyped$1 as FollowGateFromJSONTyped,
  FollowGateToJSON$1 as FollowGateToJSON,
  FollowGatedConditions,
  FollowUserSchema,
  FollowersResponseFromJSON,
  FollowersResponseFromJSONTyped,
  FollowersResponseToJSON,
  FollowingResponseFromJSON$1 as FollowingResponseFromJSON,
  FollowingResponseFromJSONTyped$1 as FollowingResponseFromJSONTyped,
  FollowingResponseToJSON$1 as FollowingResponseToJSON,
  Genre,
  GetAIAttributedTracksByUserHandleFilterTracksEnum$1 as GetAIAttributedTracksByUserHandleFilterTracksEnum,
  GetAIAttributedTracksByUserHandleSortDirectionEnum$1 as GetAIAttributedTracksByUserHandleSortDirectionEnum,
  GetAIAttributedTracksByUserHandleSortEnum$1 as GetAIAttributedTracksByUserHandleSortEnum,
  GetAIAttributedTracksByUserHandleSortMethodEnum$1 as GetAIAttributedTracksByUserHandleSortMethodEnum,
  GetAlbumsByUserSortMethodEnum$1 as GetAlbumsByUserSortMethodEnum,
  GetAllEventsEventTypeEnum,
  GetAllEventsSortMethodEnum,
  GetAudioTransactionHistorySortDirectionEnum,
  GetAudioTransactionHistorySortMethodEnum,
  GetBestSellingTypeEnum,
  GetBulkEventsEventTypeEnum,
  GetChallengesFromJSON,
  GetChallengesFromJSONTyped,
  GetChallengesToJSON,
  GetCoinMembersSortDirectionEnum,
  GetCoinsSortDirectionEnum$1 as GetCoinsSortDirectionEnum,
  GetCoinsSortMethodEnum$1 as GetCoinsSortMethodEnum,
  GetEntityEventsEntityTypeEnum,
  GetMostSharedTracksTimeRangeEnum$1 as GetMostSharedTracksTimeRangeEnum,
  GetNotificationsTypesEnum,
  GetOrCreateProgramTokenAccountSchema,
  GetPlaylistsByUserSortMethodEnum$1 as GetPlaylistsByUserSortMethodEnum,
  GetPurchaseAlbumInstructionsSchema,
  GetPurchaseTrackInstructionsSchema,
  GetSupportedUsersFromJSON,
  GetSupportedUsersFromJSONTyped,
  GetSupportedUsersToJSON,
  GetSupportersFromJSON,
  GetSupportersFromJSONTyped,
  GetSupportersToJSON,
  GetTipsCurrentUserFollowsEnum$1 as GetTipsCurrentUserFollowsEnum,
  GetTipsResponseFromJSON$1 as GetTipsResponseFromJSON,
  GetTipsResponseFromJSONTyped$1 as GetTipsResponseFromJSONTyped,
  GetTipsResponseToJSON$1 as GetTipsResponseToJSON,
  GetTipsUniqueByEnum$1 as GetTipsUniqueByEnum,
  GetTrackCommentsSortMethodEnum$1 as GetTrackCommentsSortMethodEnum,
  GetTracksByUserFilterTracksEnum$1 as GetTracksByUserFilterTracksEnum,
  GetTracksByUserSortDirectionEnum$1 as GetTracksByUserSortDirectionEnum,
  GetTracksByUserSortEnum$1 as GetTracksByUserSortEnum,
  GetTracksByUserSortMethodEnum$1 as GetTracksByUserSortMethodEnum,
  GetTrendingPlaylistsTimeEnum$1 as GetTrendingPlaylistsTimeEnum,
  GetTrendingPlaylistsTypeEnum$1 as GetTrendingPlaylistsTypeEnum,
  GetTrendingTracksTimeEnum$1 as GetTrendingTracksTimeEnum,
  GetUserRecommendedTracksTimeRangeEnum$1 as GetUserRecommendedTracksTimeRangeEnum,
  GetUsersTrackHistorySortDirectionEnum$1 as GetUsersTrackHistorySortDirectionEnum,
  GetUsersTrackHistorySortMethodEnum$1 as GetUsersTrackHistorySortMethodEnum,
  GovernanceClient,
  GrantsApi,
  HashId,
  HedgehogWalletNotFoundError,
  HistoryResponseFromJSON,
  HistoryResponseFromJSONTyped,
  HistoryResponseToJSON,
  Id2 as Id,
  ImageFile,
  IsWriteAccessGrantedSchema,
  JSONApiResponse$1 as JSONApiResponse,
  LaunchCoinSchema,
  ListenCountFromJSON,
  ListenCountFromJSONTyped,
  ListenCountToJSON,
  Logger,
  MAX_DESCRIPTION_LENGTH,
  MintSchema,
  MonthlyAggregatePlayFromJSON,
  MonthlyAggregatePlayFromJSONTyped,
  MonthlyAggregatePlayToJSON,
  Mood,
  MutualFollowersResponseFromJSON,
  MutualFollowersResponseFromJSONTyped,
  MutualFollowersResponseToJSON,
  NftCollectionChainEnum$1 as NftCollectionChainEnum,
  NftCollectionFromJSON$1 as NftCollectionFromJSON,
  NftCollectionFromJSONTyped$1 as NftCollectionFromJSONTyped,
  NftCollectionStandardEnum$1 as NftCollectionStandardEnum,
  NftCollectionToJSON$1 as NftCollectionToJSON,
  NftGateFromJSON$1 as NftGateFromJSON,
  NftGateFromJSONTyped$1 as NftGateFromJSONTyped,
  NftGateToJSON$1 as NftGateToJSON,
  OAUTH_SCOPE_OPTIONS,
  OAUTH_URL,
  OptionalHashId,
  OptionalId,
  ParseRequestError,
  PaymentRouterClient,
  PlaylistAddedTimestampFromJSON$1 as PlaylistAddedTimestampFromJSON,
  PlaylistAddedTimestampFromJSONTyped$1 as PlaylistAddedTimestampFromJSONTyped,
  PlaylistAddedTimestampToJSON$1 as PlaylistAddedTimestampToJSON,
  PlaylistArtworkFromJSON$1 as PlaylistArtworkFromJSON,
  PlaylistArtworkFromJSONTyped$1 as PlaylistArtworkFromJSONTyped,
  PlaylistArtworkToJSON$1 as PlaylistArtworkToJSON,
  PlaylistFromJSON,
  PlaylistFromJSONTyped,
  PlaylistResponseFromJSON,
  PlaylistResponseFromJSONTyped,
  PlaylistResponseToJSON,
  PlaylistSearchResultFromJSON,
  PlaylistSearchResultFromJSONTyped,
  PlaylistSearchResultToJSON,
  PlaylistToJSON,
  PlaylistTracksResponseFromJSON,
  PlaylistTracksResponseFromJSONTyped,
  PlaylistTracksResponseToJSON,
  PlaylistsApi$1 as PlaylistsApi,
  PlaylistsResponseFromJSON,
  PlaylistsResponseFromJSONTyped,
  PlaylistsResponseToJSON,
  ProfilePictureFromJSON$1 as ProfilePictureFromJSON,
  ProfilePictureFromJSONTyped$1 as ProfilePictureFromJSONTyped,
  ProfilePictureToJSON$1 as ProfilePictureToJSON,
  PublicKeySchema,
  PublishPlaylistSchema,
  PurchaseAlbumSchema,
  PurchaseTrackSchema,
  PurchasersResponseFromJSON,
  PurchasersResponseFromJSONTyped,
  PurchasersResponseToJSON,
  RecordTrackDownloadSchema,
  RegistryClient,
  RelatedArtistResponseFromJSON,
  RelatedArtistResponseFromJSONTyped,
  RelatedArtistResponseToJSON,
  RelaySchema,
  RemixParentFromJSON,
  RemixParentFromJSONTyped,
  RemixParentToJSON,
  RemixedTrackAggregateFromJSON,
  RemixedTrackAggregateFromJSONTyped,
  RemixedTrackAggregateToJSON,
  RemixersResponseFromJSON,
  RemixersResponseFromJSONTyped,
  RemixersResponseToJSON,
  RemoveAssociatedWalletSchema,
  RemoveManagerSchema,
  RemoveTrackFromPlaylistSchema,
  RendezvousHash,
  ReplyCommentFromJSON$1 as ReplyCommentFromJSON,
  ReplyCommentFromJSONTyped$1 as ReplyCommentFromJSONTyped,
  ReplyCommentToJSON$1 as ReplyCommentToJSON,
  RepostAlbumSchema,
  RepostPlaylistSchema,
  RepostTrackSchema,
  RepostsFromJSON,
  RepostsFromJSONTyped,
  RepostsToJSON,
  RequiredError$1 as RequiredError,
  ResolveApi,
  ResponseError$1 as ResponseError,
  RevokeGrantSchema,
  RewardManagerClient,
  RewardManagerError,
  RewardsApi,
  SaleJsonFromJSON,
  SaleJsonFromJSONTyped,
  SaleJsonToJSON,
  SalesAggregateFromJSON,
  SalesAggregateFromJSONTyped,
  SalesAggregateResponseFromJSON,
  SalesAggregateResponseFromJSONTyped,
  SalesAggregateResponseToJSON,
  SalesAggregateToJSON,
  SalesJsonContentFromJSON,
  SalesJsonContentFromJSONTyped,
  SalesJsonContentToJSON,
  SalesJsonResponseFromJSON,
  SalesJsonResponseFromJSONTyped,
  SalesJsonResponseToJSON,
  SearchPlaylistsSortMethodEnum,
  SearchTracksSortMethodEnum,
  SearchUsersSortMethodEnum,
  SendTipReactionRequestSchema,
  SendTipSchema,
  ServiceProviderFactoryClient,
  ServiceTypeManagerClient,
  SharePlaylistSchema,
  ShareTrackSchema,
  SolCollectibleGatedConditions,
  SolanaClient,
  SolanaRelay,
  SolanaRelayWalletAdapter,
  StakingClient,
  StemCategory,
  StemFromJSON,
  StemFromJSONTyped,
  StemToJSON,
  StemsResponseFromJSON$1 as StemsResponseFromJSON,
  StemsResponseFromJSONTyped$1 as StemsResponseFromJSONTyped,
  StemsResponseToJSON$1 as StemsResponseToJSON,
  Storage,
  StorageNodeSelector,
  StreamUrlResponseFromJSON,
  StreamUrlResponseFromJSONTyped,
  StreamUrlResponseToJSON,
  SubscribeToUserSchema,
  SubscribersResponseFromJSON,
  SubscribersResponseFromJSONTyped,
  SubscribersResponseToJSON,
  SupporterFromJSON,
  SupporterFromJSONTyped,
  SupporterToJSON,
  SupportingFromJSON,
  SupportingFromJSONTyped,
  SupportingToJSON,
  TagsResponseFromJSON,
  TagsResponseFromJSONTyped,
  TagsResponseToJSON,
  TextApiResponse$1 as TextApiResponse,
  TipFromJSON,
  TipFromJSONTyped,
  TipGateFromJSON$1 as TipGateFromJSON,
  TipGateFromJSONTyped$1 as TipGateFromJSONTyped,
  TipGateToJSON$1 as TipGateToJSON,
  TipGatedConditions,
  TipToJSON,
  TipsApi$1 as TipsApi,
  TokenGateFromJSON$1 as TokenGateFromJSON,
  TokenGateFromJSONTyped$1 as TokenGateFromJSONTyped,
  TokenGateToJSON$1 as TokenGateToJSON,
  TokenGatedConditions,
  TokenNameSchema,
  TopListenerFromJSON,
  TopListenerFromJSONTyped,
  TopListenerToJSON,
  TrackAccessInfoFromJSON,
  TrackAccessInfoFromJSONTyped,
  TrackAccessInfoToJSON,
  TrackActivityFromJSON,
  TrackActivityFromJSONTyped,
  TrackActivityItemTypeEnum,
  TrackActivityToJSON,
  TrackArtworkFromJSON,
  TrackArtworkFromJSONTyped,
  TrackArtworkToJSON,
  TrackCommentCountResponseFromJSON,
  TrackCommentCountResponseFromJSONTyped,
  TrackCommentCountResponseToJSON,
  TrackCommentNotificationResponseFromJSON,
  TrackCommentNotificationResponseFromJSONTyped,
  TrackCommentNotificationResponseToJSON,
  TrackCommentsResponseFromJSON,
  TrackCommentsResponseFromJSONTyped,
  TrackCommentsResponseToJSON,
  TrackElementFromJSON,
  TrackElementFromJSONTyped,
  TrackElementToJSON,
  TrackFromJSON,
  TrackFromJSONTyped,
  TrackInspectFromJSON,
  TrackInspectFromJSONTyped,
  TrackInspectListFromJSON,
  TrackInspectListFromJSONTyped,
  TrackInspectListToJSON,
  TrackInspectToJSON,
  TrackResponseFromJSON,
  TrackResponseFromJSONTyped,
  TrackResponseToJSON,
  TrackSearchFromJSON,
  TrackSearchFromJSONTyped,
  TrackSearchToJSON,
  TrackToJSON,
  TracksApi,
  TracksResponseFromJSON,
  TracksResponseFromJSONTyped,
  TracksResponseToJSON,
  TrendingPlaylistsResponseFromJSON,
  TrendingPlaylistsResponseFromJSONTyped,
  TrendingPlaylistsResponseToJSON,
  TrustedNotifierManagerClient,
  USDCPurchaseConditions,
  UnclaimedIdResponseFromJSON,
  UnclaimedIdResponseFromJSONTyped,
  UnclaimedIdResponseToJSON,
  UndisbursedChallengeFromJSON,
  UndisbursedChallengeFromJSONTyped,
  UndisbursedChallengeToJSON,
  UndisbursedChallengesFromJSON,
  UndisbursedChallengesFromJSONTyped,
  UndisbursedChallengesToJSON,
  UnfavoriteAlbumSchema,
  UnfavoritePlaylistSchema,
  UnfavoriteTrackSchema,
  UnfollowUserSchema,
  UnrepostAlbumSchema,
  UnrepostPlaylistSchema,
  UnrepostTrackSchema,
  UnsubscribeFromUserSchema,
  UpdateAlbumMetadataSchema,
  UpdateAlbumSchema,
  UpdateCoinRequestFromJSON$1 as UpdateCoinRequestFromJSON,
  UpdateCoinRequestFromJSONTyped$1 as UpdateCoinRequestFromJSONTyped,
  UpdateCoinRequestToJSON$1 as UpdateCoinRequestToJSON,
  UpdateCoinResponseFromJSON$1 as UpdateCoinResponseFromJSON,
  UpdateCoinResponseFromJSONTyped$1 as UpdateCoinResponseFromJSONTyped,
  UpdateCoinResponseToJSON$1 as UpdateCoinResponseToJSON,
  UpdateCollectiblesSchema,
  UpdateDeveloperAppSchema,
  UpdatePlaylistMetadataSchema,
  UpdatePlaylistSchema,
  UpdateProfileSchema,
  UpdateTrackSchema,
  UploadAlbumMetadataSchema,
  UploadAlbumSchema,
  UploadPlaylistMetadataSchema,
  UploadPlaylistSchema,
  UploadTrackFilesSchema,
  UploadTrackMetadataSchema,
  UploadTrackSchema,
  UserCoinAccountFromJSON,
  UserCoinAccountFromJSONTyped,
  UserCoinAccountToJSON,
  UserCoinFromJSON,
  UserCoinFromJSONTyped,
  UserCoinResponseFromJSON,
  UserCoinResponseFromJSONTyped,
  UserCoinResponseToJSON,
  UserCoinToJSON,
  UserCoinWithAccountsFromJSON,
  UserCoinWithAccountsFromJSONTyped,
  UserCoinWithAccountsToJSON,
  UserCoinsResponseFromJSON,
  UserCoinsResponseFromJSONTyped,
  UserCoinsResponseToJSON,
  UserCommentsResponseFromJSON,
  UserCommentsResponseFromJSONTyped,
  UserCommentsResponseToJSON,
  UserEventsSchema,
  UserFromJSON,
  UserFromJSONTyped,
  UserIdAddressFromJSON,
  UserIdAddressFromJSONTyped,
  UserIdAddressToJSON,
  UserIdsAddressesResponseFromJSON,
  UserIdsAddressesResponseFromJSONTyped,
  UserIdsAddressesResponseToJSON,
  UserResponseFromJSON,
  UserResponseFromJSONTyped,
  UserResponseToJSON,
  UserSearchFromJSON,
  UserSearchFromJSONTyped,
  UserSearchToJSON,
  UserToJSON,
  UserTrackListenCountsResponseFromJSON,
  UserTrackListenCountsResponseFromJSONTyped,
  UserTrackListenCountsResponseToJSON,
  UserTracksRemixedResponseFromJSON,
  UserTracksRemixedResponseFromJSONTyped,
  UserTracksRemixedResponseToJSON,
  UsersApi,
  UsersResponseFromJSON,
  UsersResponseFromJSONTyped,
  UsersResponseToJSON,
  VerifyTokenFromJSON,
  VerifyTokenFromJSONTyped,
  VerifyTokenToJSON,
  VoidApiResponse$1 as VoidApiResponse,
  WalletSchema,
  addAppInfoMiddleware,
  addRequestSignatureMiddleware,
  audiusWalletActions,
  canConsumeForm$1 as canConsumeForm,
  createAppWalletClient,
  createHedgehogWalletClient,
  decodeHashId,
  developmentConfig,
  encodeHashId,
  exists$2 as exists,
  index3 as full,
  getAlbumSchema,
  getAlbumTracksSchema,
  getAlbumsSchema,
  getDefaultAntiAbuseOracleSelectorConfig,
  getDefaultAudiusTokenConfig,
  getDefaultClaimableTokensConfig,
  getDefaultClaimsManagerConfig,
  getDefaultDelegateManagerConfig,
  getDefaultEntityManagerConfig,
  getDefaultEthRewardsManagerConfig,
  getDefaultGovernanceConfig,
  getDefaultPaymentRouterClientConfig,
  getDefaultRegistryConfig,
  getDefaultRewardManagerClentConfig,
  getDefaultServiceProviderFactoryConfig,
  getDefaultServiceTypeManagerConfig,
  getDefaultStakingConfig,
  getDefaultStorageNodeSelectorConfig,
  getDefaultStorageServiceConfig,
  getDefaultTrustedNotifierManagerConfig,
  getDefaultWormholeConfig,
  instanceOfAccess$1 as instanceOfAccess,
  instanceOfAccessInfoResponse,
  instanceOfActivity,
  instanceOfAlbumBacklink$1 as instanceOfAlbumBacklink,
  instanceOfAlbumsResponse,
  instanceOfAuthorizedApp,
  instanceOfAuthorizedApps,
  instanceOfBestSellingItem$1 as instanceOfBestSellingItem,
  instanceOfBestSellingResponse,
  instanceOfBlobInfo,
  instanceOfChallengeResponse,
  instanceOfClaimRewardsRequest,
  instanceOfClaimRewardsResponse,
  instanceOfClaimRewardsResponseDataInner,
  instanceOfCoin$1 as instanceOfCoin,
  instanceOfCoinDynamicBondingCurve,
  instanceOfCoinExtensions,
  instanceOfCoinInsights,
  instanceOfCoinInsightsResponse,
  instanceOfCoinMember,
  instanceOfCoinMembersResponse,
  instanceOfCoinResponse$1 as instanceOfCoinResponse,
  instanceOfCoinsResponse$1 as instanceOfCoinsResponse,
  instanceOfCollectibles,
  instanceOfCollectiblesResponse,
  instanceOfCollectionActivity,
  instanceOfComment$1 as instanceOfComment,
  instanceOfCommentMention$1 as instanceOfCommentMention,
  instanceOfCommentNotificationSetting,
  instanceOfCommentRepliesResponse$1 as instanceOfCommentRepliesResponse,
  instanceOfCommentResponse$1 as instanceOfCommentResponse,
  instanceOfConnectedWallets,
  instanceOfConnectedWalletsResponse,
  instanceOfCoverPhoto$1 as instanceOfCoverPhoto,
  instanceOfCreateCoinRequest$1 as instanceOfCreateCoinRequest,
  instanceOfCreateCoinResponse$1 as instanceOfCreateCoinResponse,
  instanceOfCreateCoinResponseData$1 as instanceOfCreateCoinResponseData,
  instanceOfDashboardWalletUser,
  instanceOfDashboardWalletUsersResponse,
  instanceOfDecodedUserToken,
  instanceOfDeveloperApp,
  instanceOfDeveloperAppResponse,
  instanceOfDeveloperApps,
  instanceOfEmailAccess,
  instanceOfEmailAccessResponse,
  instanceOfEvent,
  instanceOfEventsResponse,
  instanceOfExtendedPaymentSplit,
  instanceOfExtendedPurchaseGate,
  instanceOfExtendedTokenGate$1 as instanceOfExtendedTokenGate,
  instanceOfExtendedUsdcGate,
  instanceOfFavorite$1 as instanceOfFavorite,
  instanceOfFavoritesResponse,
  instanceOfFollowGate$1 as instanceOfFollowGate,
  instanceOfFollowersResponse,
  instanceOfFollowingResponse$1 as instanceOfFollowingResponse,
  instanceOfGetChallenges,
  instanceOfGetSupportedUsers,
  instanceOfGetSupporters,
  instanceOfGetTipsResponse$1 as instanceOfGetTipsResponse,
  instanceOfHistoryResponse,
  instanceOfListenCount,
  instanceOfMonthlyAggregatePlay,
  instanceOfMutualFollowersResponse,
  instanceOfNftCollection$1 as instanceOfNftCollection,
  instanceOfNftGate$1 as instanceOfNftGate,
  instanceOfPlaylist,
  instanceOfPlaylistAddedTimestamp$1 as instanceOfPlaylistAddedTimestamp,
  instanceOfPlaylistArtwork$1 as instanceOfPlaylistArtwork,
  instanceOfPlaylistResponse,
  instanceOfPlaylistSearchResult,
  instanceOfPlaylistTracksResponse,
  instanceOfPlaylistsResponse,
  instanceOfProfilePicture$1 as instanceOfProfilePicture,
  instanceOfPurchasersResponse,
  instanceOfRelatedArtistResponse,
  instanceOfRemixParent,
  instanceOfRemixedTrackAggregate,
  instanceOfRemixersResponse,
  instanceOfReplyComment$1 as instanceOfReplyComment,
  instanceOfReposts,
  instanceOfSaleJson,
  instanceOfSalesAggregate,
  instanceOfSalesAggregateResponse,
  instanceOfSalesJsonContent,
  instanceOfSalesJsonResponse,
  instanceOfStem,
  instanceOfStemsResponse$1 as instanceOfStemsResponse,
  instanceOfStreamUrlResponse,
  instanceOfSubscribersResponse,
  instanceOfSupporter,
  instanceOfSupporting,
  instanceOfTagsResponse,
  instanceOfTip,
  instanceOfTipGate$1 as instanceOfTipGate,
  instanceOfTokenGate$1 as instanceOfTokenGate,
  instanceOfTopListener,
  instanceOfTrack,
  instanceOfTrackAccessInfo,
  instanceOfTrackActivity,
  instanceOfTrackArtwork,
  instanceOfTrackCommentCountResponse,
  instanceOfTrackCommentNotificationResponse,
  instanceOfTrackCommentsResponse,
  instanceOfTrackElement,
  instanceOfTrackInspect,
  instanceOfTrackInspectList,
  instanceOfTrackResponse,
  instanceOfTrackSearch,
  instanceOfTracksResponse,
  instanceOfTrendingPlaylistsResponse,
  instanceOfUnclaimedIdResponse,
  instanceOfUndisbursedChallenge,
  instanceOfUndisbursedChallenges,
  instanceOfUpdateCoinRequest$1 as instanceOfUpdateCoinRequest,
  instanceOfUpdateCoinResponse$1 as instanceOfUpdateCoinResponse,
  instanceOfUser,
  instanceOfUserCoin,
  instanceOfUserCoinAccount,
  instanceOfUserCoinResponse,
  instanceOfUserCoinWithAccounts,
  instanceOfUserCoinsResponse,
  instanceOfUserCommentsResponse,
  instanceOfUserIdAddress,
  instanceOfUserIdsAddressesResponse,
  instanceOfUserResponse,
  instanceOfUserSearch,
  instanceOfUserTrackListenCountsResponse,
  instanceOfUserTracksRemixedResponse,
  instanceOfUsersResponse,
  instanceOfVerifyToken,
  isNativeFile,
  isNodeFile,
  mapValues$1 as mapValues,
  productionConfig,
  querystring$1 as querystring,
  sdk,
  stagingConfig
};
/*! Bundled license information:

lodash/lodash.js:
  (**
   * @license
   * Lodash <https://lodash.com/>
   * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   *)

@noble/hashes/esm/utils.js:
@noble/hashes/esm/utils.js:
@noble/hashes/esm/utils.js:
@noble/hashes/esm/utils.js:
@audius/sdk/dist/index.browser.esm.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/utils.js:
@noble/curves/esm/abstract/modular.js:
@noble/curves/esm/abstract/curve.js:
@noble/curves/esm/abstract/edwards.js:
@noble/curves/esm/abstract/montgomery.js:
@noble/curves/esm/ed25519.js:
@noble/curves/esm/abstract/weierstrass.js:
@noble/curves/esm/_shortw_utils.js:
@noble/curves/esm/secp256k1.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@solana/buffer-layout/lib/Layout.js:
  (**
   * Support for translating between Uint8Array instances and JavaScript
   * native types.
   *
   * {@link module:Layout~Layout|Layout} is the basis of a class
   * hierarchy that associates property names with sequences of encoded
   * bytes.
   *
   * Layouts are supported for these scalar (numeric) types:
   * * {@link module:Layout~UInt|Unsigned integers in little-endian
   *   format} with {@link module:Layout.u8|8-bit}, {@link
   *   module:Layout.u16|16-bit}, {@link module:Layout.u24|24-bit},
   *   {@link module:Layout.u32|32-bit}, {@link
   *   module:Layout.u40|40-bit}, and {@link module:Layout.u48|48-bit}
   *   representation ranges;
   * * {@link module:Layout~UIntBE|Unsigned integers in big-endian
   *   format} with {@link module:Layout.u16be|16-bit}, {@link
   *   module:Layout.u24be|24-bit}, {@link module:Layout.u32be|32-bit},
   *   {@link module:Layout.u40be|40-bit}, and {@link
   *   module:Layout.u48be|48-bit} representation ranges;
   * * {@link module:Layout~Int|Signed integers in little-endian
   *   format} with {@link module:Layout.s8|8-bit}, {@link
   *   module:Layout.s16|16-bit}, {@link module:Layout.s24|24-bit},
   *   {@link module:Layout.s32|32-bit}, {@link
   *   module:Layout.s40|40-bit}, and {@link module:Layout.s48|48-bit}
   *   representation ranges;
   * * {@link module:Layout~IntBE|Signed integers in big-endian format}
   *   with {@link module:Layout.s16be|16-bit}, {@link
   *   module:Layout.s24be|24-bit}, {@link module:Layout.s32be|32-bit},
   *   {@link module:Layout.s40be|40-bit}, and {@link
   *   module:Layout.s48be|48-bit} representation ranges;
   * * 64-bit integral values that decode to an exact (if magnitude is
   *   less than 2^53) or nearby integral Number in {@link
   *   module:Layout.nu64|unsigned little-endian}, {@link
   *   module:Layout.nu64be|unsigned big-endian}, {@link
   *   module:Layout.ns64|signed little-endian}, and {@link
   *   module:Layout.ns64be|unsigned big-endian} encodings;
   * * 32-bit floating point values with {@link
   *   module:Layout.f32|little-endian} and {@link
   *   module:Layout.f32be|big-endian} representations;
   * * 64-bit floating point values with {@link
   *   module:Layout.f64|little-endian} and {@link
   *   module:Layout.f64be|big-endian} representations;
   * * {@link module:Layout.const|Constants} that take no space in the
   *   encoded expression.
   *
   * and for these aggregate types:
   * * {@link module:Layout.seq|Sequence}s of instances of a {@link
   *   module:Layout~Layout|Layout}, with JavaScript representation as
   *   an Array and constant or data-dependent {@link
   *   module:Layout~Sequence#count|length};
   * * {@link module:Layout.struct|Structure}s that aggregate a
   *   heterogeneous sequence of {@link module:Layout~Layout|Layout}
   *   instances, with JavaScript representation as an Object;
   * * {@link module:Layout.union|Union}s that support multiple {@link
   *   module:Layout~VariantLayout|variant layouts} over a fixed
   *   (padded) or variable (not padded) span of bytes, using an
   *   unsigned integer at the start of the data or a separate {@link
   *   module:Layout.unionLayoutDiscriminator|layout element} to
   *   determine which layout to use when interpreting the buffer
   *   contents;
   * * {@link module:Layout.bits|BitStructure}s that contain a sequence
   *   of individual {@link
   *   module:Layout~BitStructure#addField|BitField}s packed into an 8,
   *   16, 24, or 32-bit unsigned integer starting at the least- or
   *   most-significant bit;
   * * {@link module:Layout.cstr|C strings} of varying length;
   * * {@link module:Layout.blob|Blobs} of fixed- or variable-{@link
   *   module:Layout~Blob#length|length} raw data.
   *
   * All {@link module:Layout~Layout|Layout} instances are immutable
   * after construction, to prevent internal state from becoming
   * inconsistent.
   *
   * @local Layout
   * @local ExternalLayout
   * @local GreedyCount
   * @local OffsetLayout
   * @local UInt
   * @local UIntBE
   * @local Int
   * @local IntBE
   * @local NearUInt64
   * @local NearUInt64BE
   * @local NearInt64
   * @local NearInt64BE
   * @local Float
   * @local FloatBE
   * @local Double
   * @local DoubleBE
   * @local Sequence
   * @local Structure
   * @local UnionDiscriminator
   * @local UnionLayoutDiscriminator
   * @local Union
   * @local VariantLayout
   * @local BitStructure
   * @local BitField
   * @local Boolean
   * @local Blob
   * @local CString
   * @local Constant
   * @local bindConstructorLayout
   * @module Layout
   * @license MIT
   * @author Peter A. Bigot
   * @see {@link https://github.com/pabigot/buffer-layout|buffer-layout on GitHub}
   *)

buffer-layout/lib/Layout.js:
  (**
   * Support for translating between Buffer instances and JavaScript
   * native types.
   *
   * {@link module:Layout~Layout|Layout} is the basis of a class
   * hierarchy that associates property names with sequences of encoded
   * bytes.
   *
   * Layouts are supported for these scalar (numeric) types:
   * * {@link module:Layout~UInt|Unsigned integers in little-endian
   *   format} with {@link module:Layout.u8|8-bit}, {@link
   *   module:Layout.u16|16-bit}, {@link module:Layout.u24|24-bit},
   *   {@link module:Layout.u32|32-bit}, {@link
   *   module:Layout.u40|40-bit}, and {@link module:Layout.u48|48-bit}
   *   representation ranges;
   * * {@link module:Layout~UIntBE|Unsigned integers in big-endian
   *   format} with {@link module:Layout.u16be|16-bit}, {@link
   *   module:Layout.u24be|24-bit}, {@link module:Layout.u32be|32-bit},
   *   {@link module:Layout.u40be|40-bit}, and {@link
   *   module:Layout.u48be|48-bit} representation ranges;
   * * {@link module:Layout~Int|Signed integers in little-endian
   *   format} with {@link module:Layout.s8|8-bit}, {@link
   *   module:Layout.s16|16-bit}, {@link module:Layout.s24|24-bit},
   *   {@link module:Layout.s32|32-bit}, {@link
   *   module:Layout.s40|40-bit}, and {@link module:Layout.s48|48-bit}
   *   representation ranges;
   * * {@link module:Layout~IntBE|Signed integers in big-endian format}
   *   with {@link module:Layout.s16be|16-bit}, {@link
   *   module:Layout.s24be|24-bit}, {@link module:Layout.s32be|32-bit},
   *   {@link module:Layout.s40be|40-bit}, and {@link
   *   module:Layout.s48be|48-bit} representation ranges;
   * * 64-bit integral values that decode to an exact (if magnitude is
   *   less than 2^53) or nearby integral Number in {@link
   *   module:Layout.nu64|unsigned little-endian}, {@link
   *   module:Layout.nu64be|unsigned big-endian}, {@link
   *   module:Layout.ns64|signed little-endian}, and {@link
   *   module:Layout.ns64be|unsigned big-endian} encodings;
   * * 32-bit floating point values with {@link
   *   module:Layout.f32|little-endian} and {@link
   *   module:Layout.f32be|big-endian} representations;
   * * 64-bit floating point values with {@link
   *   module:Layout.f64|little-endian} and {@link
   *   module:Layout.f64be|big-endian} representations;
   * * {@link module:Layout.const|Constants} that take no space in the
   *   encoded expression.
   *
   * and for these aggregate types:
   * * {@link module:Layout.seq|Sequence}s of instances of a {@link
   *   module:Layout~Layout|Layout}, with JavaScript representation as
   *   an Array and constant or data-dependent {@link
   *   module:Layout~Sequence#count|length};
   * * {@link module:Layout.struct|Structure}s that aggregate a
   *   heterogeneous sequence of {@link module:Layout~Layout|Layout}
   *   instances, with JavaScript representation as an Object;
   * * {@link module:Layout.union|Union}s that support multiple {@link
   *   module:Layout~VariantLayout|variant layouts} over a fixed
   *   (padded) or variable (not padded) span of bytes, using an
   *   unsigned integer at the start of the data or a separate {@link
   *   module:Layout.unionLayoutDiscriminator|layout element} to
   *   determine which layout to use when interpreting the buffer
   *   contents;
   * * {@link module:Layout.bits|BitStructure}s that contain a sequence
   *   of individual {@link
   *   module:Layout~BitStructure#addField|BitField}s packed into an 8,
   *   16, 24, or 32-bit unsigned integer starting at the least- or
   *   most-significant bit;
   * * {@link module:Layout.cstr|C strings} of varying length;
   * * {@link module:Layout.blob|Blobs} of fixed- or variable-{@link
   *   module:Layout~Blob#length|length} raw data.
   *
   * All {@link module:Layout~Layout|Layout} instances are immutable
   * after construction, to prevent internal state from becoming
   * inconsistent.
   *
   * @local Layout
   * @local ExternalLayout
   * @local GreedyCount
   * @local OffsetLayout
   * @local UInt
   * @local UIntBE
   * @local Int
   * @local IntBE
   * @local NearUInt64
   * @local NearUInt64BE
   * @local NearInt64
   * @local NearInt64BE
   * @local Float
   * @local FloatBE
   * @local Double
   * @local DoubleBE
   * @local Sequence
   * @local Structure
   * @local UnionDiscriminator
   * @local UnionLayoutDiscriminator
   * @local Union
   * @local VariantLayout
   * @local BitStructure
   * @local BitField
   * @local Boolean
   * @local Blob
   * @local CString
   * @local Constant
   * @local bindConstructorLayout
   * @module Layout
   * @license MIT
   * @author Peter A. Bigot
   * @see {@link https://github.com/pabigot/buffer-layout|buffer-layout on GitHub}
   *)

@noble/secp256k1/lib/esm/index.js:
  (*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) *)

pako/dist/pako.esm.mjs:
  (*! pako 2.1.0 https://github.com/nodeca/pako @license (MIT AND Zlib) *)

@audius/sdk/dist/index.browser.esm.js:
  (*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)
*/
//# sourceMappingURL=@audius_sdk.js.map
