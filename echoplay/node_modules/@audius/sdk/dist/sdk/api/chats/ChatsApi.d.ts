import type TypedEmitter from 'typed-emitter';
import type { AudiusWalletClient } from '../../services/AudiusWalletClient';
import type { LoggerService } from '../../services/Logger';
import type { EventEmitterTarget } from '../../utils/EventEmitterTarget';
import { BaseAPI, Configuration } from '../generated/default';
import { ChatBlastMessageRequest, ChatBlockRequest, ChatCreateRequest, ChatDeleteRequest, ChatEvents, ChatGetAllRequest, ChatGetBlockersRequest, ChatGetMessagesRequest, ChatGetPermissionRequest, ChatGetRequest, ChatGetUnreadCountRequest, ChatInviteRequest, ChatMessageRequest, ChatPermitRequest, ChatReactRequest, ChatReadRequest, ChatUnfurlRequest, TypedCommsResponse, UnfurlResponse } from './clientTypes';
import { type ChatCreateRPC, type ChatMessage, type RPCPayloadRequest, type UpgradableChatBlast, type UserChat, type ValidatedChatPermissions } from './serverTypes';
export declare class ChatsApi extends BaseAPI implements EventEmitterTarget<ChatEvents> {
    private readonly audiusWalletClient;
    private readonly logger;
    /**
     * A map of chatId => chatSecret so we don't have to repeatedly fetch it
     */
    private chatSecrets;
    /**
     * A map of userId => publicKey promise to cache and deduplicate public key requests
     */
    private publicKeyCache;
    /**
     * An event emitter that's used for consumers to listen for chat events
     */
    private readonly eventEmitter;
    /**
     * Proxy to the event emitter addListener
     */
    addEventListener: <E extends keyof ChatEvents>(event: E, listener: ChatEvents[E]) => TypedEmitter<ChatEvents>;
    /**
     * Proxy to the event emitter removeListener
     */
    removeEventListener: <E extends keyof ChatEvents>(event: E, listener: ChatEvents[E]) => TypedEmitter<ChatEvents>;
    constructor(config: Configuration, audiusWalletClient: AudiusWalletClient, logger: LoggerService);
    /**
     * Establishes a websocket connection for listening to chat events.
     * @param params.currentUserId the user to listen for chat events for
     */
    listen(): Promise<void>;
    /**
     * Gets a single chat
     * @param params.chatId the chat to get
     * @param params.currentUserId the user to act on behalf of
     * @returns the chat response
     */
    get(params: ChatGetRequest): Promise<{
        data: UserChat;
        health: {
            is_healthy: boolean;
        };
        summary?: {
            prev_cursor: string;
            prev_count: number;
            next_cursor: string;
            next_count: number;
            total_count: number;
        } | undefined;
    }>;
    /**
     * Gets a list of chats
     * @param params.limit the max number of chats to get
     * @param params.before a timestamp cursor for pagination
     * @param params.after a timestamp cursor for pagination
     * @param params.userId the user to act on behalf of
     * @returns the chat list response
     */
    getAll(params?: ChatGetAllRequest): Promise<{
        data: UserChat[];
        health: {
            is_healthy: boolean;
        };
        summary?: {
            prev_cursor: string;
            prev_count: number;
            next_cursor: string;
            next_count: number;
            total_count: number;
        } | undefined;
    }>;
    /**
     * Gets a list of messages
     * @param params.chatId the chat to get messages for
     * @param params.before a timestamp cursor for pagination
     * @param params.after a timestamp cursor for pagination
     * @param params.currentUserId the user to act on behalf of
     * @returns the messages list response
     */
    getMessages(params: ChatGetMessagesRequest): Promise<TypedCommsResponse<ChatMessage[]>>;
    /**
     * Gets a list of chat blasts for which chats haven't been created yet
     * @returns the blast messages list response
     */
    getBlasts(): Promise<TypedCommsResponse<UpgradableChatBlast[]>>;
    /**
     * Gets the total unread message count for a user
     * @param params.currentUserId the user to act on behalf of
     * @returns the unread count response
     */
    getUnreadCount(params?: ChatGetUnreadCountRequest): Promise<TypedCommsResponse<number>>;
    /**
     * Gets the permission settings of the given users
     * @param params.userIds the users to fetch permissions of
     * @param params.currentUserId the user to act on behalf of
     * @returns the permissions response
     */
    getPermissions(params: ChatGetPermissionRequest): Promise<TypedCommsResponse<ValidatedChatPermissions[]>>;
    /**
     * Gets the user ids that have blocked the current user
     * @param params.currentUserId the user to act on behalf of
     * @returns the blockers response
     */
    getBlockers(params?: ChatGetBlockersRequest): Promise<TypedCommsResponse<string[]>>;
    /**
     * Gets the user ids the current user has blocked
     * @param params.currentUserId the user to act on behalf of
     * @returns
     */
    getBlockees(params?: ChatGetBlockersRequest): Promise<TypedCommsResponse<string[]>>;
    /**
     * Gets URL metadata useful for link previews
     * @param params.content the urls to get metadata for
     * @returns the unfurl response
     */
    unfurl(params: ChatUnfurlRequest): Promise<UnfurlResponse[]>;
    /**
     * Creates a chat between users
     * @param params.userId the user id who is creating the chat
     * @param params.invitedUserIds the user ids to add to the chat
     * @param params.currentUserId the user to act on behalf of
     * @returns the rpc object
     */
    create(params: ChatCreateRequest): Promise<ChatCreateRPC>;
    /**
     * Invites other users to an existing chat
     * @param params.chatId the chat id of the chat to invite to
     * @param params.userId the user id who is creating the chat
     * @param params.invitedUserIds the user ids to add to the chat
     * @param params.currentUserId the user to act on behalf of
     * @returns the rpc object
     */
    invite(params: ChatInviteRequest): Promise<RPCPayloadRequest & {
        current_user_id?: string | undefined;
    }>;
    /**
     * Sends a message to a user in a chat
     * @param params.message the message
     * @param params.chatId the chat to send a message in
     * @param params.messageId the id of the message
     * @param params.currentUserId the user to act on behalf of
     * @returns the rpc object
     */
    message(params: ChatMessageRequest): Promise<RPCPayloadRequest & {
        current_user_id?: string | undefined;
    }>;
    /**
     * Sends a blast message to a set of users
     * @param params.message the message
     * @param params.blastId the id of the message
     * @param params.audience the audience to send the message to
     * @param params.audienceTrackId for targeting remixers/purchasers of a specific track
     * @param params.currentUserId the user to act on behalf of
     * @returns the rpc object
     */
    messageBlast(params: ChatBlastMessageRequest): Promise<RPCPayloadRequest & {
        current_user_id?: string | undefined;
    }>;
    /**
     * Reacts to a message
     * @param params.reaction the reaction
     * @param params.chatId the chat to send a reaction in
     * @param params.messageId the id of the message to react to
     * @param params.currentUserId the user to act on behalf of
     * @returns the rpc object
     */
    react(params: ChatReactRequest): Promise<RPCPayloadRequest & {
        current_user_id?: string | undefined;
    }>;
    /**
     * Marks a chat as read
     * @param params.chatId the chat to mark as read
     * @param params.currentUserId the user to act on behalf of
     * @returns the rpc object
     */
    read(params: ChatReadRequest): Promise<RPCPayloadRequest & {
        current_user_id?: string | undefined;
    }>;
    /**
     * Blocks a user from sending messages to the current user
     * @param params.userId the user to block
     * @param params.currentUserId the user to act on behalf of
     * @returns the rpc object
     */
    block(params: ChatBlockRequest): Promise<RPCPayloadRequest & {
        current_user_id?: string | undefined;
    }>;
    /**
     * Unblocks a user from sending messages to the current user
     * @param params.userId the user to unblock
     * @param params.currentUserId the user to act on behalf of
     * @returns the rpc object
     */
    unblock(params: ChatBlockRequest): Promise<RPCPayloadRequest & {
        current_user_id?: string | undefined;
    }>;
    /**
     * Clears a chat's history for the current user
     * @param params.chatId the chat to clear
     * @param params.currentUserId the user to act on behalf of
     * @returns the rpc object
     */
    delete(params: ChatDeleteRequest): Promise<RPCPayloadRequest & {
        current_user_id?: string | undefined;
    }>;
    /**
     * Sets the inbox settings permissions of the current user
     * @param params.permit the permission to set
     * @param params.currentUserId the user to act on behalf of
     * @returns the rpc object
     */
    permit(params: ChatPermitRequest): Promise<RPCPayloadRequest & {
        current_user_id?: string | undefined;
    }>;
    private createInvites;
    private createInviteCode;
    private readInviteCode;
    private decryptLastChatMessage;
    private getRaw;
    private getChatSecret;
    private getPublicKey;
    private fetchPublicKey;
    private upgradeBlasts;
    private getSignatureHeader;
    private signAndSendRequest;
    private sendRpc;
    private createWebsocket;
}
