import { hexToBytes as hexToBytes$2, createClient, custom, encodeFunctionData, decodeFunctionData, recoverTypedDataAddress, createPublicClient, http, hexToString, parseSignature, createWalletClient } from 'viem';
import { USDC, wAUDIO } from '@audius/fixed-decimal';
import { pick, uniqBy, range as range$1 } from 'lodash';
import snakecaseKeys from 'snakecase-keys';
import Hashids from 'hashids';
import retry from 'async-retry';
import { z } from 'zod';
import * as fileType from 'file-type';
import { PublicKey, TransactionInstruction, SendTransactionError, AddressLookupTableAccount, Connection, ComputeBudgetProgram, TransactionMessage, VersionedTransaction, Secp256k1Program } from '@solana/web3.js';
import { ClaimableTokensProgram, ClaimableTokensInstruction, ClaimableTokensErrorMessages, ClaimableTokensErrorCode, RewardManagerErrorMessages, RewardManagerErrorCode, RewardManagerProgram, RewardManagerInstruction, PaymentRouterProgram } from '@audius/spl';
import { getAssociatedTokenAddressSync, createTransferInstruction, getAccount, TokenAccountNotFoundError, createAssociatedTokenAccountIdempotentInstruction, TokenInvalidMintError, TokenInvalidOwnerError } from '@solana/spl-token';
import require$$0 from 'events';
import * as secp256k1$1 from '@noble/secp256k1';
import { base64 } from '@scure/base';
import WebSocket from 'isomorphic-ws';
import { ulid } from 'ulid';
import * as aes from 'micro-aes-gcm';
import crossFetch, { Headers } from 'cross-fetch';
import { concatBytes as concatBytes$2, randomBytes, bytesToHex as bytesToHex$2 } from '@noble/hashes/utils';
import axios from 'axios';
import FormData$1 from 'form-data';
import { Buffer as Buffer$1 } from 'buffer';
import { ServiceTypeManager, ServiceProviderFactory, EthRewardsManager, AudiusToken, ClaimsManager, DelegateManager, Staking, TrustedNotifierManager, AudiusWormhole, Registry, Governance } from '@audius/eth';
import crypto$1 from 'crypto';
import { Mutex } from 'async-mutex';

function defineChain(chain) {
  return {
    formatters: undefined,
    fees: undefined,
    serializers: undefined,
    ...chain
  };
}

const version = '2.21.21';

let errorConfig = {
  getDocsUrl: _ref => {
    let {
      docsBaseUrl,
      docsPath = '',
      docsSlug
    } = _ref;
    return docsPath ? `${docsBaseUrl !== null && docsBaseUrl !== void 0 ? docsBaseUrl : 'https://viem.sh'}${docsPath}${docsSlug ? `#${docsSlug}` : ''}` : undefined;
  },
  version
};
class BaseError extends Error {
  constructor(shortMessage) {
    var _errorConfig$getDocsU, _errorConfig, _args$name;
    let args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    const details = (_args$cause => {
      if (args.cause instanceof BaseError) return args.cause.details;
      if ((_args$cause = args.cause) !== null && _args$cause !== void 0 && _args$cause.message) return args.cause.message;
      return args.details;
    })();
    const docsPath = (() => {
      if (args.cause instanceof BaseError) return args.cause.docsPath || args.docsPath;
      return args.docsPath;
    })();
    const docsUrl = (_errorConfig$getDocsU = (_errorConfig = errorConfig).getDocsUrl) === null || _errorConfig$getDocsU === void 0 ? void 0 : _errorConfig$getDocsU.call(_errorConfig, {
      ...args,
      docsPath
    });
    const message = [shortMessage || 'An error occurred.', '', ...(args.metaMessages ? [...args.metaMessages, ''] : []), ...(docsUrl ? [`Docs: ${docsUrl}`] : []), ...(details ? [`Details: ${details}`] : []), ...(errorConfig.version ? [`Version: ${errorConfig.version}`] : [])].join('\n');
    super(message, args.cause ? {
      cause: args.cause
    } : undefined);
    Object.defineProperty(this, "details", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "docsPath", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "metaMessages", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "shortMessage", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "version", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 'BaseError'
    });
    this.details = details;
    this.docsPath = docsPath;
    this.metaMessages = args.metaMessages;
    this.name = (_args$name = args.name) !== null && _args$name !== void 0 ? _args$name : this.name;
    this.shortMessage = shortMessage;
    this.version = version;
  }
  walk(fn) {
    return walk(this, fn);
  }
}
function walk(err, fn) {
  if (fn !== null && fn !== void 0 && fn(err)) return err;
  if (err && typeof err === 'object' && 'cause' in err) return walk(err.cause, fn);
  return fn ? null : err;
}

class IntegerOutOfRangeError extends BaseError {
  constructor(_ref) {
    let {
      max,
      min,
      signed,
      size,
      value
    } = _ref;
    super(`Number "${value}" is not in safe ${size ? `${size * 8}-bit ${signed ? 'signed' : 'unsigned'} ` : ''}integer range ${max ? `(${min} to ${max})` : `(above ${min})`}`, {
      name: 'IntegerOutOfRangeError'
    });
  }
}
class InvalidBytesBooleanError extends BaseError {
  constructor(bytes) {
    super(`Bytes value "${bytes}" is not a valid boolean. The bytes array must contain a single byte of either a 0 or 1 value.`, {
      name: 'InvalidBytesBooleanError'
    });
  }
}
class InvalidHexBooleanError extends BaseError {
  constructor(hex) {
    super(`Hex value "${hex}" is not a valid boolean. The hex value must be "0x0" (false) or "0x1" (true).`, {
      name: 'InvalidHexBooleanError'
    });
  }
}
class InvalidHexValueError extends BaseError {
  constructor(value) {
    super(`Hex value "${value}" is an odd length (${value.length}). It must be an even length.`, {
      name: 'InvalidHexValueError'
    });
  }
}
class SizeOverflowError extends BaseError {
  constructor(_ref2) {
    let {
      givenSize,
      maxSize
    } = _ref2;
    super(`Size cannot exceed ${maxSize} bytes. Given size: ${givenSize} bytes.`, {
      name: 'SizeOverflowError'
    });
  }
}

function isHex(value) {
  let {
    strict = true
  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  if (!value) return false;
  if (typeof value !== 'string') return false;
  return strict ? /^0x[0-9a-fA-F]*$/.test(value) : value.startsWith('0x');
}

/**
 * @description Retrieves the size of the value (in bytes).
 *
 * @param value The value (hex or byte array) to retrieve the size of.
 * @returns The size of the value (in bytes).
 */
function size(value) {
  if (isHex(value, {
    strict: false
  })) return Math.ceil((value.length - 2) / 2);
  return value.length;
}

function trim(hexOrBytes) {
  let {
    dir = 'left'
  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  let data = typeof hexOrBytes === 'string' ? hexOrBytes.replace('0x', '') : hexOrBytes;
  let sliceLength = 0;
  for (let i = 0; i < data.length - 1; i++) {
    if (data[dir === 'left' ? i : data.length - i - 1].toString() === '0') sliceLength++;else break;
  }
  data = dir === 'left' ? data.slice(sliceLength) : data.slice(0, data.length - sliceLength);
  if (typeof hexOrBytes === 'string') {
    if (data.length === 1 && dir === 'right') data = `${data}0`;
    return `0x${data.length % 2 === 1 ? `0${data}` : data}`;
  }
  return data;
}

class SliceOffsetOutOfBoundsError extends BaseError {
  constructor(_ref) {
    let {
      offset,
      position,
      size
    } = _ref;
    super(`Slice ${position === 'start' ? 'starting' : 'ending'} at offset "${offset}" is out-of-bounds (size: ${size}).`, {
      name: 'SliceOffsetOutOfBoundsError'
    });
  }
}
class SizeExceedsPaddingSizeError extends BaseError {
  constructor(_ref2) {
    let {
      size,
      targetSize,
      type
    } = _ref2;
    super(`${type.charAt(0).toUpperCase()}${type.slice(1).toLowerCase()} size (${size}) exceeds padding size (${targetSize}).`, {
      name: 'SizeExceedsPaddingSizeError'
    });
  }
}

function pad(hexOrBytes) {
  let {
    dir,
    size = 32
  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  if (typeof hexOrBytes === 'string') return padHex(hexOrBytes, {
    dir,
    size
  });
  return padBytes(hexOrBytes, {
    dir,
    size
  });
}
function padHex(hex_) {
  let {
    dir,
    size = 32
  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  if (size === null) return hex_;
  const hex = hex_.replace('0x', '');
  if (hex.length > size * 2) throw new SizeExceedsPaddingSizeError({
    size: Math.ceil(hex.length / 2),
    targetSize: size,
    type: 'hex'
  });
  return `0x${hex[dir === 'right' ? 'padEnd' : 'padStart'](size * 2, '0')}`;
}
function padBytes(bytes) {
  let {
    dir,
    size = 32
  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  if (size === null) return bytes;
  if (bytes.length > size) throw new SizeExceedsPaddingSizeError({
    size: bytes.length,
    targetSize: size,
    type: 'bytes'
  });
  const paddedBytes = new Uint8Array(size);
  for (let i = 0; i < size; i++) {
    const padEnd = dir === 'right';
    paddedBytes[padEnd ? i : size - i - 1] = bytes[padEnd ? i : bytes.length - i - 1];
  }
  return paddedBytes;
}

const hexes$1 = /*#__PURE__*/Array.from({
  length: 256
}, (_v, i) => i.toString(16).padStart(2, '0'));
/**
 * Encodes a string, number, bigint, or ByteArray into a hex string
 *
 * - Docs: https://viem.sh/docs/utilities/toHex
 * - Example: https://viem.sh/docs/utilities/toHex#usage
 *
 * @param value Value to encode.
 * @param opts Options.
 * @returns Hex value.
 *
 * @example
 * import { toHex } from 'viem'
 * const data = toHex('Hello world')
 * // '0x48656c6c6f20776f726c6421'
 *
 * @example
 * import { toHex } from 'viem'
 * const data = toHex(420)
 * // '0x1a4'
 *
 * @example
 * import { toHex } from 'viem'
 * const data = toHex('Hello world', { size: 32 })
 * // '0x48656c6c6f20776f726c64210000000000000000000000000000000000000000'
 */
function toHex(value) {
  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  if (typeof value === 'number' || typeof value === 'bigint') return numberToHex(value, opts);
  if (typeof value === 'string') {
    return stringToHex(value, opts);
  }
  if (typeof value === 'boolean') return boolToHex(value, opts);
  return bytesToHex$1(value, opts);
}
/**
 * Encodes a boolean into a hex string
 *
 * - Docs: https://viem.sh/docs/utilities/toHex#booltohex
 *
 * @param value Value to encode.
 * @param opts Options.
 * @returns Hex value.
 *
 * @example
 * import { boolToHex } from 'viem'
 * const data = boolToHex(true)
 * // '0x1'
 *
 * @example
 * import { boolToHex } from 'viem'
 * const data = boolToHex(false)
 * // '0x0'
 *
 * @example
 * import { boolToHex } from 'viem'
 * const data = boolToHex(true, { size: 32 })
 * // '0x0000000000000000000000000000000000000000000000000000000000000001'
 */
function boolToHex(value) {
  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  const hex = `0x${Number(value)}`;
  if (typeof opts.size === 'number') {
    assertSize(hex, {
      size: opts.size
    });
    return pad(hex, {
      size: opts.size
    });
  }
  return hex;
}
/**
 * Encodes a bytes array into a hex string
 *
 * - Docs: https://viem.sh/docs/utilities/toHex#bytestohex
 *
 * @param value Value to encode.
 * @param opts Options.
 * @returns Hex value.
 *
 * @example
 * import { bytesToHex } from 'viem'
 * const data = bytesToHex(Uint8Array.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])
 * // '0x48656c6c6f20576f726c6421'
 *
 * @example
 * import { bytesToHex } from 'viem'
 * const data = bytesToHex(Uint8Array.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]), { size: 32 })
 * // '0x48656c6c6f20576f726c64210000000000000000000000000000000000000000'
 */
function bytesToHex$1(value) {
  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  let string = '';
  for (let i = 0; i < value.length; i++) {
    string += hexes$1[value[i]];
  }
  const hex = `0x${string}`;
  if (typeof opts.size === 'number') {
    assertSize(hex, {
      size: opts.size
    });
    return pad(hex, {
      dir: 'right',
      size: opts.size
    });
  }
  return hex;
}
/**
 * Encodes a number or bigint into a hex string
 *
 * - Docs: https://viem.sh/docs/utilities/toHex#numbertohex
 *
 * @param value Value to encode.
 * @param opts Options.
 * @returns Hex value.
 *
 * @example
 * import { numberToHex } from 'viem'
 * const data = numberToHex(420)
 * // '0x1a4'
 *
 * @example
 * import { numberToHex } from 'viem'
 * const data = numberToHex(420, { size: 32 })
 * // '0x00000000000000000000000000000000000000000000000000000000000001a4'
 */
function numberToHex(value_) {
  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  const {
    signed,
    size
  } = opts;
  const value = BigInt(value_);
  let maxValue;
  if (size) {
    if (signed) maxValue = (1n << BigInt(size) * 8n - 1n) - 1n;else maxValue = 2n ** (BigInt(size) * 8n) - 1n;
  } else if (typeof value_ === 'number') {
    maxValue = BigInt(Number.MAX_SAFE_INTEGER);
  }
  const minValue = typeof maxValue === 'bigint' && signed ? -maxValue - 1n : 0;
  if (maxValue && value > maxValue || value < minValue) {
    const suffix = typeof value_ === 'bigint' ? 'n' : '';
    throw new IntegerOutOfRangeError({
      max: maxValue ? `${maxValue}${suffix}` : undefined,
      min: `${minValue}${suffix}`,
      signed,
      size,
      value: `${value_}${suffix}`
    });
  }
  const hex = `0x${(signed && value < 0 ? (1n << BigInt(size * 8)) + BigInt(value) : value).toString(16)}`;
  if (size) return pad(hex, {
    size
  });
  return hex;
}
const encoder$1 = /*#__PURE__*/new TextEncoder();
/**
 * Encodes a UTF-8 string into a hex string
 *
 * - Docs: https://viem.sh/docs/utilities/toHex#stringtohex
 *
 * @param value Value to encode.
 * @param opts Options.
 * @returns Hex value.
 *
 * @example
 * import { stringToHex } from 'viem'
 * const data = stringToHex('Hello World!')
 * // '0x48656c6c6f20576f726c6421'
 *
 * @example
 * import { stringToHex } from 'viem'
 * const data = stringToHex('Hello World!', { size: 32 })
 * // '0x48656c6c6f20576f726c64210000000000000000000000000000000000000000'
 */
function stringToHex(value_) {
  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  const value = encoder$1.encode(value_);
  return bytesToHex$1(value, opts);
}

const encoder = /*#__PURE__*/new TextEncoder();
/**
 * Encodes a UTF-8 string, hex value, bigint, number or boolean to a byte array.
 *
 * - Docs: https://viem.sh/docs/utilities/toBytes
 * - Example: https://viem.sh/docs/utilities/toBytes#usage
 *
 * @param value Value to encode.
 * @param opts Options.
 * @returns Byte array value.
 *
 * @example
 * import { toBytes } from 'viem'
 * const data = toBytes('Hello world')
 * // Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])
 *
 * @example
 * import { toBytes } from 'viem'
 * const data = toBytes(420)
 * // Uint8Array([1, 164])
 *
 * @example
 * import { toBytes } from 'viem'
 * const data = toBytes(420, { size: 4 })
 * // Uint8Array([0, 0, 1, 164])
 */
function toBytes$2(value) {
  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  if (typeof value === 'number' || typeof value === 'bigint') return numberToBytes(value, opts);
  if (typeof value === 'boolean') return boolToBytes(value, opts);
  if (isHex(value)) return hexToBytes$1(value, opts);
  return stringToBytes(value, opts);
}
/**
 * Encodes a boolean into a byte array.
 *
 * - Docs: https://viem.sh/docs/utilities/toBytes#booltobytes
 *
 * @param value Boolean value to encode.
 * @param opts Options.
 * @returns Byte array value.
 *
 * @example
 * import { boolToBytes } from 'viem'
 * const data = boolToBytes(true)
 * // Uint8Array([1])
 *
 * @example
 * import { boolToBytes } from 'viem'
 * const data = boolToBytes(true, { size: 32 })
 * // Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1])
 */
function boolToBytes(value) {
  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  const bytes = new Uint8Array(1);
  bytes[0] = Number(value);
  if (typeof opts.size === 'number') {
    assertSize(bytes, {
      size: opts.size
    });
    return pad(bytes, {
      size: opts.size
    });
  }
  return bytes;
}
// We use very optimized technique to convert hex string to byte array
const charCodeMap = {
  zero: 48,
  nine: 57,
  A: 65,
  F: 70,
  a: 97,
  f: 102
};
function charCodeToBase16(char) {
  if (char >= charCodeMap.zero && char <= charCodeMap.nine) return char - charCodeMap.zero;
  if (char >= charCodeMap.A && char <= charCodeMap.F) return char - (charCodeMap.A - 10);
  if (char >= charCodeMap.a && char <= charCodeMap.f) return char - (charCodeMap.a - 10);
  return undefined;
}
/**
 * Encodes a hex string into a byte array.
 *
 * - Docs: https://viem.sh/docs/utilities/toBytes#hextobytes
 *
 * @param hex Hex string to encode.
 * @param opts Options.
 * @returns Byte array value.
 *
 * @example
 * import { hexToBytes } from 'viem'
 * const data = hexToBytes('0x48656c6c6f20776f726c6421')
 * // Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])
 *
 * @example
 * import { hexToBytes } from 'viem'
 * const data = hexToBytes('0x48656c6c6f20776f726c6421', { size: 32 })
 * // Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])
 */
function hexToBytes$1(hex_) {
  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  let hex = hex_;
  if (opts.size) {
    assertSize(hex, {
      size: opts.size
    });
    hex = pad(hex, {
      dir: 'right',
      size: opts.size
    });
  }
  let hexString = hex.slice(2);
  if (hexString.length % 2) hexString = `0${hexString}`;
  const length = hexString.length / 2;
  const bytes = new Uint8Array(length);
  for (let index = 0, j = 0; index < length; index++) {
    const nibbleLeft = charCodeToBase16(hexString.charCodeAt(j++));
    const nibbleRight = charCodeToBase16(hexString.charCodeAt(j++));
    if (nibbleLeft === undefined || nibbleRight === undefined) {
      throw new BaseError(`Invalid byte sequence ("${hexString[j - 2]}${hexString[j - 1]}" in "${hexString}").`);
    }
    bytes[index] = nibbleLeft * 16 + nibbleRight;
  }
  return bytes;
}
/**
 * Encodes a number into a byte array.
 *
 * - Docs: https://viem.sh/docs/utilities/toBytes#numbertobytes
 *
 * @param value Number to encode.
 * @param opts Options.
 * @returns Byte array value.
 *
 * @example
 * import { numberToBytes } from 'viem'
 * const data = numberToBytes(420)
 * // Uint8Array([1, 164])
 *
 * @example
 * import { numberToBytes } from 'viem'
 * const data = numberToBytes(420, { size: 4 })
 * // Uint8Array([0, 0, 1, 164])
 */
function numberToBytes(value, opts) {
  const hex = numberToHex(value, opts);
  return hexToBytes$1(hex);
}
/**
 * Encodes a UTF-8 string into a byte array.
 *
 * - Docs: https://viem.sh/docs/utilities/toBytes#stringtobytes
 *
 * @param value String to encode.
 * @param opts Options.
 * @returns Byte array value.
 *
 * @example
 * import { stringToBytes } from 'viem'
 * const data = stringToBytes('Hello world!')
 * // Uint8Array([72, 101, 108, 108, 111, 32, 119, 111, 114, 108, 100, 33])
 *
 * @example
 * import { stringToBytes } from 'viem'
 * const data = stringToBytes('Hello world!', { size: 32 })
 * // Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])
 */
function stringToBytes(value) {
  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  const bytes = encoder.encode(value);
  if (typeof opts.size === 'number') {
    assertSize(bytes, {
      size: opts.size
    });
    return pad(bytes, {
      dir: 'right',
      size: opts.size
    });
  }
  return bytes;
}

function assertSize(hexOrBytes, _ref) {
  let {
    size: size$1
  } = _ref;
  if (size(hexOrBytes) > size$1) throw new SizeOverflowError({
    givenSize: size(hexOrBytes),
    maxSize: size$1
  });
}
/**
 * Decodes a hex value into a bigint.
 *
 * - Docs: https://viem.sh/docs/utilities/fromHex#hextobigint
 *
 * @param hex Hex value to decode.
 * @param opts Options.
 * @returns BigInt value.
 *
 * @example
 * import { hexToBigInt } from 'viem'
 * const data = hexToBigInt('0x1a4', { signed: true })
 * // 420n
 *
 * @example
 * import { hexToBigInt } from 'viem'
 * const data = hexToBigInt('0x00000000000000000000000000000000000000000000000000000000000001a4', { size: 32 })
 * // 420n
 */
function hexToBigInt(hex) {
  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  const {
    signed
  } = opts;
  if (opts.size) assertSize(hex, {
    size: opts.size
  });
  const value = BigInt(hex);
  if (!signed) return value;
  const size = (hex.length - 2) / 2;
  const max = (1n << BigInt(size) * 8n - 1n) - 1n;
  if (value <= max) return value;
  return value - BigInt(`0x${'f'.padStart(size * 2, 'f')}`) - 1n;
}
/**
 * Decodes a hex string into a number.
 *
 * - Docs: https://viem.sh/docs/utilities/fromHex#hextonumber
 *
 * @param hex Hex value to decode.
 * @param opts Options.
 * @returns Number value.
 *
 * @example
 * import { hexToNumber } from 'viem'
 * const data = hexToNumber('0x1a4')
 * // 420
 *
 * @example
 * import { hexToNumber } from 'viem'
 * const data = hexToBigInt('0x00000000000000000000000000000000000000000000000000000000000001a4', { size: 32 })
 * // 420
 */
function hexToNumber$1(hex) {
  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  return Number(hexToBigInt(hex, opts));
}

const maxUint256 = 2n ** 256n - 1n;

function concat(values) {
  if (typeof values[0] === 'string') return concatHex(values);
  return concatBytes$1(values);
}
function concatBytes$1(values) {
  let length = 0;
  for (const arr of values) {
    length += arr.length;
  }
  const result = new Uint8Array(length);
  let offset = 0;
  for (const arr of values) {
    result.set(arr, offset);
    offset += arr.length;
  }
  return result;
}
function concatHex(values) {
  return `0x${values.reduce((acc, x) => acc + x.replace('0x', ''), '')}`;
}

class NegativeOffsetError extends BaseError {
  constructor(_ref) {
    let {
      offset
    } = _ref;
    super(`Offset \`${offset}\` cannot be negative.`, {
      name: 'NegativeOffsetError'
    });
  }
}
class PositionOutOfBoundsError extends BaseError {
  constructor(_ref2) {
    let {
      length,
      position
    } = _ref2;
    super(`Position \`${position}\` is out of bounds (\`0 < position < ${length}\`).`, {
      name: 'PositionOutOfBoundsError'
    });
  }
}
class RecursiveReadLimitExceededError extends BaseError {
  constructor(_ref3) {
    let {
      count,
      limit
    } = _ref3;
    super(`Recursive read limit of \`${limit}\` exceeded (recursive read count: \`${count}\`).`, {
      name: 'RecursiveReadLimitExceededError'
    });
  }
}

const staticCursor = {
  bytes: new Uint8Array(),
  dataView: new DataView(new ArrayBuffer(0)),
  position: 0,
  positionReadCount: new Map(),
  recursiveReadCount: 0,
  recursiveReadLimit: Number.POSITIVE_INFINITY,
  assertReadLimit() {
    if (this.recursiveReadCount >= this.recursiveReadLimit) throw new RecursiveReadLimitExceededError({
      count: this.recursiveReadCount + 1,
      limit: this.recursiveReadLimit
    });
  },
  assertPosition(position) {
    if (position < 0 || position > this.bytes.length - 1) throw new PositionOutOfBoundsError({
      length: this.bytes.length,
      position
    });
  },
  decrementPosition(offset) {
    if (offset < 0) throw new NegativeOffsetError({
      offset
    });
    const position = this.position - offset;
    this.assertPosition(position);
    this.position = position;
  },
  getReadCount(position) {
    return this.positionReadCount.get(position || this.position) || 0;
  },
  incrementPosition(offset) {
    if (offset < 0) throw new NegativeOffsetError({
      offset
    });
    const position = this.position + offset;
    this.assertPosition(position);
    this.position = position;
  },
  inspectByte(position_) {
    const position = position_ !== null && position_ !== void 0 ? position_ : this.position;
    this.assertPosition(position);
    return this.bytes[position];
  },
  inspectBytes(length, position_) {
    const position = position_ !== null && position_ !== void 0 ? position_ : this.position;
    this.assertPosition(position + length - 1);
    return this.bytes.subarray(position, position + length);
  },
  inspectUint8(position_) {
    const position = position_ !== null && position_ !== void 0 ? position_ : this.position;
    this.assertPosition(position);
    return this.bytes[position];
  },
  inspectUint16(position_) {
    const position = position_ !== null && position_ !== void 0 ? position_ : this.position;
    this.assertPosition(position + 1);
    return this.dataView.getUint16(position);
  },
  inspectUint24(position_) {
    const position = position_ !== null && position_ !== void 0 ? position_ : this.position;
    this.assertPosition(position + 2);
    return (this.dataView.getUint16(position) << 8) + this.dataView.getUint8(position + 2);
  },
  inspectUint32(position_) {
    const position = position_ !== null && position_ !== void 0 ? position_ : this.position;
    this.assertPosition(position + 3);
    return this.dataView.getUint32(position);
  },
  pushByte(byte) {
    this.assertPosition(this.position);
    this.bytes[this.position] = byte;
    this.position++;
  },
  pushBytes(bytes) {
    this.assertPosition(this.position + bytes.length - 1);
    this.bytes.set(bytes, this.position);
    this.position += bytes.length;
  },
  pushUint8(value) {
    this.assertPosition(this.position);
    this.bytes[this.position] = value;
    this.position++;
  },
  pushUint16(value) {
    this.assertPosition(this.position + 1);
    this.dataView.setUint16(this.position, value);
    this.position += 2;
  },
  pushUint24(value) {
    this.assertPosition(this.position + 2);
    this.dataView.setUint16(this.position, value >> 8);
    this.dataView.setUint8(this.position + 2, value & ~4294967040);
    this.position += 3;
  },
  pushUint32(value) {
    this.assertPosition(this.position + 3);
    this.dataView.setUint32(this.position, value);
    this.position += 4;
  },
  readByte() {
    this.assertReadLimit();
    this._touch();
    const value = this.inspectByte();
    this.position++;
    return value;
  },
  readBytes(length, size) {
    this.assertReadLimit();
    this._touch();
    const value = this.inspectBytes(length);
    this.position += size !== null && size !== void 0 ? size : length;
    return value;
  },
  readUint8() {
    this.assertReadLimit();
    this._touch();
    const value = this.inspectUint8();
    this.position += 1;
    return value;
  },
  readUint16() {
    this.assertReadLimit();
    this._touch();
    const value = this.inspectUint16();
    this.position += 2;
    return value;
  },
  readUint24() {
    this.assertReadLimit();
    this._touch();
    const value = this.inspectUint24();
    this.position += 3;
    return value;
  },
  readUint32() {
    this.assertReadLimit();
    this._touch();
    const value = this.inspectUint32();
    this.position += 4;
    return value;
  },
  get remaining() {
    return this.bytes.length - this.position;
  },
  setPosition(position) {
    const oldPosition = this.position;
    this.assertPosition(position);
    this.position = position;
    return () => this.position = oldPosition;
  },
  _touch() {
    if (this.recursiveReadLimit === Number.POSITIVE_INFINITY) return;
    const count = this.getReadCount();
    this.positionReadCount.set(this.position, count + 1);
    if (count > 0) this.recursiveReadCount++;
  }
};
function createCursor(bytes) {
  let {
    recursiveReadLimit = 8192
  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  const cursor = Object.create(staticCursor);
  cursor.bytes = bytes;
  cursor.dataView = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);
  cursor.positionReadCount = new Map();
  cursor.recursiveReadLimit = recursiveReadLimit;
  return cursor;
}

function toRlp(bytes) {
  let to = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'hex';
  const encodable = getEncodable(bytes);
  const cursor = createCursor(new Uint8Array(encodable.length));
  encodable.encode(cursor);
  if (to === 'hex') return bytesToHex$1(cursor.bytes);
  return cursor.bytes;
}
function getEncodable(bytes) {
  if (Array.isArray(bytes)) return getEncodableList(bytes.map(x => getEncodable(x)));
  return getEncodableBytes(bytes);
}
function getEncodableList(list) {
  const bodyLength = list.reduce((acc, x) => acc + x.length, 0);
  const sizeOfBodyLength = getSizeOfLength(bodyLength);
  const length = (() => {
    if (bodyLength <= 55) return 1 + bodyLength;
    return 1 + sizeOfBodyLength + bodyLength;
  })();
  return {
    length,
    encode(cursor) {
      if (bodyLength <= 55) {
        cursor.pushByte(0xc0 + bodyLength);
      } else {
        cursor.pushByte(0xc0 + 55 + sizeOfBodyLength);
        if (sizeOfBodyLength === 1) cursor.pushUint8(bodyLength);else if (sizeOfBodyLength === 2) cursor.pushUint16(bodyLength);else if (sizeOfBodyLength === 3) cursor.pushUint24(bodyLength);else cursor.pushUint32(bodyLength);
      }
      for (const {
        encode
      } of list) {
        encode(cursor);
      }
    }
  };
}
function getEncodableBytes(bytesOrHex) {
  const bytes = typeof bytesOrHex === 'string' ? hexToBytes$1(bytesOrHex) : bytesOrHex;
  const sizeOfBytesLength = getSizeOfLength(bytes.length);
  const length = (() => {
    if (bytes.length === 1 && bytes[0] < 0x80) return 1;
    if (bytes.length <= 55) return 1 + bytes.length;
    return 1 + sizeOfBytesLength + bytes.length;
  })();
  return {
    length,
    encode(cursor) {
      if (bytes.length === 1 && bytes[0] < 0x80) {
        cursor.pushBytes(bytes);
      } else if (bytes.length <= 55) {
        cursor.pushByte(0x80 + bytes.length);
        cursor.pushBytes(bytes);
      } else {
        cursor.pushByte(0x80 + 55 + sizeOfBytesLength);
        if (sizeOfBytesLength === 1) cursor.pushUint8(bytes.length);else if (sizeOfBytesLength === 2) cursor.pushUint16(bytes.length);else if (sizeOfBytesLength === 3) cursor.pushUint24(bytes.length);else cursor.pushUint32(bytes.length);
        cursor.pushBytes(bytes);
      }
    }
  };
}
function getSizeOfLength(length) {
  if (length < 2 ** 8) return 1;
  if (length < 2 ** 16) return 2;
  if (length < 2 ** 24) return 3;
  if (length < 2 ** 32) return 4;
  throw new BaseError('Length is too large.');
}

const gweiUnits = {
  ether: -9,
  wei: 9
};

/**
 *  Divides a number by a given exponent of base 10 (10exponent), and formats it into a string representation of the number..
 *
 * - Docs: https://viem.sh/docs/utilities/formatUnits
 *
 * @example
 * import { formatUnits } from 'viem'
 *
 * formatUnits(420000000000n, 9)
 * // '420'
 */
function formatUnits(value, decimals) {
  let display = value.toString();
  const negative = display.startsWith('-');
  if (negative) display = display.slice(1);
  display = display.padStart(decimals, '0');
  let [integer, fraction] = [display.slice(0, display.length - decimals), display.slice(display.length - decimals)];
  fraction = fraction.replace(/(0+)$/, '');
  return `${negative ? '-' : ''}${integer || '0'}${fraction ? `.${fraction}` : ''}`;
}

/**
 * Converts numerical wei to a string representation of gwei.
 *
 * - Docs: https://viem.sh/docs/utilities/formatGwei
 *
 * @example
 * import { formatGwei } from 'viem'
 *
 * formatGwei(1000000000n)
 * // '1'
 */
function formatGwei(wei) {
  let unit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'wei';
  return formatUnits(wei, gweiUnits[unit]);
}

function prettyPrint(args) {
  const entries = Object.entries(args).map(_ref => {
    let [key, value] = _ref;
    if (value === undefined || value === false) return null;
    return [key, value];
  }).filter(Boolean);
  const maxLength = entries.reduce((acc, _ref2) => {
    let [key] = _ref2;
    return Math.max(acc, key.length);
  }, 0);
  return entries.map(_ref3 => {
    let [key, value] = _ref3;
    return `  ${`${key}:`.padEnd(maxLength + 1)}  ${value}`;
  }).join('\n');
}
class InvalidLegacyVError extends BaseError {
  constructor(_ref4) {
    let {
      v
    } = _ref4;
    super(`Invalid \`v\` value "${v}". Expected 27 or 28.`, {
      name: 'InvalidLegacyVError'
    });
  }
}
class InvalidSerializableTransactionError extends BaseError {
  constructor(_ref5) {
    let {
      transaction
    } = _ref5;
    super('Cannot infer a transaction type from provided transaction.', {
      metaMessages: ['Provided Transaction:', '{', prettyPrint(transaction), '}', '', 'To infer the type, either provide:', '- a `type` to the Transaction, or', '- an EIP-1559 Transaction with `maxFeePerGas`, or', '- an EIP-2930 Transaction with `gasPrice` & `accessList`, or', '- an EIP-4844 Transaction with `blobs`, `blobVersionedHashes`, `sidecars`, or', '- an EIP-7702 Transaction with `authorizationList`, or', '- a Legacy Transaction with `gasPrice`'],
      name: 'InvalidSerializableTransactionError'
    });
  }
}
class InvalidStorageKeySizeError extends BaseError {
  constructor(_ref9) {
    let {
      storageKey
    } = _ref9;
    super(`Size for storage key "${storageKey}" is invalid. Expected 32 bytes. Got ${Math.floor((storageKey.length - 2) / 2)} bytes.`, {
      name: 'InvalidStorageKeySizeError'
    });
  }
}

/**
 * Compute commitments from a list of blobs.
 *
 * @example
 * ```ts
 * import { blobsToCommitments, toBlobs } from 'viem'
 * import { kzg } from './kzg'
 *
 * const blobs = toBlobs({ data: '0x1234' })
 * const commitments = blobsToCommitments({ blobs, kzg })
 * ```
 */
function blobsToCommitments(parameters) {
  var _parameters$to;
  const {
    kzg
  } = parameters;
  const to = (_parameters$to = parameters.to) !== null && _parameters$to !== void 0 ? _parameters$to : typeof parameters.blobs[0] === 'string' ? 'hex' : 'bytes';
  const blobs = typeof parameters.blobs[0] === 'string' ? parameters.blobs.map(x => hexToBytes$1(x)) : parameters.blobs;
  const commitments = [];
  for (const blob of blobs) commitments.push(Uint8Array.from(kzg.blobToKzgCommitment(blob)));
  return to === 'bytes' ? commitments : commitments.map(x => bytesToHex$1(x));
}

/**
 * Compute the proofs for a list of blobs and their commitments.
 *
 * @example
 * ```ts
 * import {
 *   blobsToCommitments,
 *   toBlobs
 * } from 'viem'
 * import { kzg } from './kzg'
 *
 * const blobs = toBlobs({ data: '0x1234' })
 * const commitments = blobsToCommitments({ blobs, kzg })
 * const proofs = blobsToProofs({ blobs, commitments, kzg })
 * ```
 */
function blobsToProofs(parameters) {
  var _parameters$to;
  const {
    kzg
  } = parameters;
  const to = (_parameters$to = parameters.to) !== null && _parameters$to !== void 0 ? _parameters$to : typeof parameters.blobs[0] === 'string' ? 'hex' : 'bytes';
  const blobs = typeof parameters.blobs[0] === 'string' ? parameters.blobs.map(x => hexToBytes$1(x)) : parameters.blobs;
  const commitments = typeof parameters.commitments[0] === 'string' ? parameters.commitments.map(x => hexToBytes$1(x)) : parameters.commitments;
  const proofs = [];
  for (let i = 0; i < blobs.length; i++) {
    const blob = blobs[i];
    const commitment = commitments[i];
    proofs.push(Uint8Array.from(kzg.computeBlobKzgProof(blob, commitment)));
  }
  return to === 'bytes' ? proofs : proofs.map(x => bytesToHex$1(x));
}

function number$1(n) {
  if (!Number.isSafeInteger(n) || n < 0) throw new Error(`positive integer expected, not ${n}`);
}
// copied from utils
function isBytes$1(a) {
  return a instanceof Uint8Array || a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array';
}
function bytes$1(b) {
  if (!isBytes$1(b)) throw new Error('Uint8Array expected');
  for (var _len = arguments.length, lengths = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    lengths[_key - 1] = arguments[_key];
  }
  if (lengths.length > 0 && !lengths.includes(b.length)) throw new Error(`Uint8Array expected of length ${lengths}, not of length=${b.length}`);
}
function hash$1(h) {
  if (typeof h !== 'function' || typeof h.create !== 'function') throw new Error('Hash should be wrapped by utils.wrapConstructor');
  number$1(h.outputLen);
  number$1(h.blockLen);
}
function exists$3(instance) {
  let checkFinished = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  if (instance.destroyed) throw new Error('Hash instance has been destroyed');
  if (checkFinished && instance.finished) throw new Error('Hash#digest() has already been called');
}
function output$1(out, instance) {
  bytes$1(out);
  const min = instance.outputLen;
  if (out.length < min) {
    throw new Error(`digestInto() expects output buffer of length at least ${min}`);
  }
}

/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const u32$1 = arr => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
// Cast array to view
const createView$1 = arr => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
// The rotate right (circular right shift) operation for uint32
const rotr$1 = (word, shift) => word << 32 - shift | word >>> shift;
const isLE$1 = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;
// The byte swap operation for uint32
const byteSwap = word => word << 24 & 0xff000000 | word << 8 & 0xff0000 | word >>> 8 & 0xff00 | word >>> 24 & 0xff;
// In place byte swap for Uint32Array
function byteSwap32(arr) {
  for (let i = 0; i < arr.length; i++) {
    arr[i] = byteSwap(arr[i]);
  }
}
/**
 * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])
 */
function utf8ToBytes$2(str) {
  if (typeof str !== 'string') throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
  return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809
}
/**
 * Normalizes (non-hex) string or Uint8Array to Uint8Array.
 * Warning: when Uint8Array is passed, it would NOT get copied.
 * Keep in mind for future mutable operations.
 */
function toBytes$1(data) {
  if (typeof data === 'string') data = utf8ToBytes$2(data);
  bytes$1(data);
  return data;
}
// For runtime check if class implements interface
class Hash$3 {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
}
function wrapConstructor$1(hashCons) {
  const hashC = msg => hashCons().update(toBytes$1(msg)).digest();
  const tmp = hashCons();
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = () => hashCons();
  return hashC;
}

/**
 * Polyfill for Safari 14
 */
function setBigUint64$1(view, byteOffset, value, isLE) {
  if (typeof view.setBigUint64 === 'function') return view.setBigUint64(byteOffset, value, isLE);
  const _32n = BigInt(32);
  const _u32_max = BigInt(0xffffffff);
  const wh = Number(value >> _32n & _u32_max);
  const wl = Number(value & _u32_max);
  const h = isLE ? 4 : 0;
  const l = isLE ? 0 : 4;
  view.setUint32(byteOffset + h, wh, isLE);
  view.setUint32(byteOffset + l, wl, isLE);
}
/**
 * Choice: a ? b : c
 */
const Chi$1 = (a, b, c) => a & b ^ ~a & c;
/**
 * Majority function, true if any two inputs is true
 */
const Maj$1 = (a, b, c) => a & b ^ a & c ^ b & c;
/**
 * Merkle-Damgard hash construction base class.
 * Could be used to create MD5, RIPEMD, SHA1, SHA2.
 */
class HashMD extends Hash$3 {
  constructor(blockLen, outputLen, padOffset, isLE) {
    super();
    this.blockLen = blockLen;
    this.outputLen = outputLen;
    this.padOffset = padOffset;
    this.isLE = isLE;
    this.finished = false;
    this.length = 0;
    this.pos = 0;
    this.destroyed = false;
    this.buffer = new Uint8Array(blockLen);
    this.view = createView$1(this.buffer);
  }
  update(data) {
    exists$3(this);
    const {
      view,
      buffer,
      blockLen
    } = this;
    data = toBytes$1(data);
    const len = data.length;
    for (let pos = 0; pos < len;) {
      const take = Math.min(blockLen - this.pos, len - pos);
      // Fast path: we have at least one block in input, cast it to view and process
      if (take === blockLen) {
        const dataView = createView$1(data);
        for (; blockLen <= len - pos; pos += blockLen) this.process(dataView, pos);
        continue;
      }
      buffer.set(data.subarray(pos, pos + take), this.pos);
      this.pos += take;
      pos += take;
      if (this.pos === blockLen) {
        this.process(view, 0);
        this.pos = 0;
      }
    }
    this.length += data.length;
    this.roundClean();
    return this;
  }
  digestInto(out) {
    exists$3(this);
    output$1(out, this);
    this.finished = true;
    // Padding
    // We can avoid allocation of buffer for padding completely if it
    // was previously not allocated here. But it won't change performance.
    const {
      buffer,
      view,
      blockLen,
      isLE
    } = this;
    let {
      pos
    } = this;
    // append the bit '1' to the message
    buffer[pos++] = 0b10000000;
    this.buffer.subarray(pos).fill(0);
    // we have less than padOffset left in buffer, so we cannot put length in
    // current block, need process it and pad again
    if (this.padOffset > blockLen - pos) {
      this.process(view, 0);
      pos = 0;
    }
    // Pad until full block byte with zeros
    for (let i = pos; i < blockLen; i++) buffer[i] = 0;
    // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that
    // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.
    // So we just write lowest 64 bits of that value.
    setBigUint64$1(view, blockLen - 8, BigInt(this.length * 8), isLE);
    this.process(view, 0);
    const oview = createView$1(out);
    const len = this.outputLen;
    // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT
    if (len % 4) throw new Error('_sha2: outputLen should be aligned to 32bit');
    const outLen = len / 4;
    const state = this.get();
    if (outLen > state.length) throw new Error('_sha2: outputLen bigger than state');
    for (let i = 0; i < outLen; i++) oview.setUint32(4 * i, state[i], isLE);
  }
  digest() {
    const {
      buffer,
      outputLen
    } = this;
    this.digestInto(buffer);
    const res = buffer.slice(0, outputLen);
    this.destroy();
    return res;
  }
  _cloneInto(to) {
    to || (to = new this.constructor());
    to.set(...this.get());
    const {
      blockLen,
      buffer,
      length,
      finished,
      destroyed,
      pos
    } = this;
    to.length = length;
    to.pos = pos;
    to.finished = finished;
    to.destroyed = destroyed;
    if (length % blockLen) to.buffer.set(buffer);
    return to;
  }
}

// SHA2-256 need to try 2^128 hashes to execute birthday attack.
// BTC network is doing 2^67 hashes/sec as per early 2023.
// Round constants:
// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)
// prettier-ignore
const SHA256_K$1 = /* @__PURE__ */new Uint32Array([0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2]);
// Initial state:
// first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19
// prettier-ignore
const SHA256_IV = /* @__PURE__ */new Uint32Array([0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19]);
// Temporary buffer, not used to store anything between runs
// Named this way because it matches specification.
const SHA256_W$1 = /* @__PURE__ */new Uint32Array(64);
class SHA256$1 extends HashMD {
  constructor() {
    super(64, 32, 8, false);
    // We cannot use array here since array allows indexing by variable
    // which means optimizer/compiler cannot use registers.
    this.A = SHA256_IV[0] | 0;
    this.B = SHA256_IV[1] | 0;
    this.C = SHA256_IV[2] | 0;
    this.D = SHA256_IV[3] | 0;
    this.E = SHA256_IV[4] | 0;
    this.F = SHA256_IV[5] | 0;
    this.G = SHA256_IV[6] | 0;
    this.H = SHA256_IV[7] | 0;
  }
  get() {
    const {
      A,
      B,
      C,
      D,
      E,
      F,
      G,
      H
    } = this;
    return [A, B, C, D, E, F, G, H];
  }
  // prettier-ignore
  set(A, B, C, D, E, F, G, H) {
    this.A = A | 0;
    this.B = B | 0;
    this.C = C | 0;
    this.D = D | 0;
    this.E = E | 0;
    this.F = F | 0;
    this.G = G | 0;
    this.H = H | 0;
  }
  process(view, offset) {
    // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array
    for (let i = 0; i < 16; i++, offset += 4) SHA256_W$1[i] = view.getUint32(offset, false);
    for (let i = 16; i < 64; i++) {
      const W15 = SHA256_W$1[i - 15];
      const W2 = SHA256_W$1[i - 2];
      const s0 = rotr$1(W15, 7) ^ rotr$1(W15, 18) ^ W15 >>> 3;
      const s1 = rotr$1(W2, 17) ^ rotr$1(W2, 19) ^ W2 >>> 10;
      SHA256_W$1[i] = s1 + SHA256_W$1[i - 7] + s0 + SHA256_W$1[i - 16] | 0;
    }
    // Compression function main loop, 64 rounds
    let {
      A,
      B,
      C,
      D,
      E,
      F,
      G,
      H
    } = this;
    for (let i = 0; i < 64; i++) {
      const sigma1 = rotr$1(E, 6) ^ rotr$1(E, 11) ^ rotr$1(E, 25);
      const T1 = H + sigma1 + Chi$1(E, F, G) + SHA256_K$1[i] + SHA256_W$1[i] | 0;
      const sigma0 = rotr$1(A, 2) ^ rotr$1(A, 13) ^ rotr$1(A, 22);
      const T2 = sigma0 + Maj$1(A, B, C) | 0;
      H = G;
      G = F;
      F = E;
      E = D + T1 | 0;
      D = C;
      C = B;
      B = A;
      A = T1 + T2 | 0;
    }
    // Add the compressed chunk to the current hash value
    A = A + this.A | 0;
    B = B + this.B | 0;
    C = C + this.C | 0;
    D = D + this.D | 0;
    E = E + this.E | 0;
    F = F + this.F | 0;
    G = G + this.G | 0;
    H = H + this.H | 0;
    this.set(A, B, C, D, E, F, G, H);
  }
  roundClean() {
    SHA256_W$1.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0);
    this.buffer.fill(0);
  }
}
/**
 * SHA2-256 hash function
 * @param message - data that would be hashed
 */
const sha256$3 = /* @__PURE__ */wrapConstructor$1(() => new SHA256$1());

function sha256$2(value, to_) {
  const to = to_ || 'hex';
  const bytes = sha256$3(isHex(value, {
    strict: false
  }) ? toBytes$2(value) : value);
  if (to === 'bytes') return bytes;
  return toHex(bytes);
}

/**
 * Transform a commitment to it's versioned hash.
 *
 * @example
 * ```ts
 * import {
 *   blobsToCommitments,
 *   commitmentToVersionedHash,
 *   toBlobs
 * } from 'viem'
 * import { kzg } from './kzg'
 *
 * const blobs = toBlobs({ data: '0x1234' })
 * const [commitment] = blobsToCommitments({ blobs, kzg })
 * const versionedHash = commitmentToVersionedHash({ commitment })
 * ```
 */
function commitmentToVersionedHash(parameters) {
  var _parameters$to;
  const {
    commitment,
    version = 1
  } = parameters;
  const to = (_parameters$to = parameters.to) !== null && _parameters$to !== void 0 ? _parameters$to : typeof commitment === 'string' ? 'hex' : 'bytes';
  const versionedHash = sha256$2(commitment, 'bytes');
  versionedHash.set([version], 0);
  return to === 'bytes' ? versionedHash : bytesToHex$1(versionedHash);
}

/**
 * Transform a list of commitments to their versioned hashes.
 *
 * @example
 * ```ts
 * import {
 *   blobsToCommitments,
 *   commitmentsToVersionedHashes,
 *   toBlobs
 * } from 'viem'
 * import { kzg } from './kzg'
 *
 * const blobs = toBlobs({ data: '0x1234' })
 * const commitments = blobsToCommitments({ blobs, kzg })
 * const versionedHashes = commitmentsToVersionedHashes({ commitments })
 * ```
 */
function commitmentsToVersionedHashes(parameters) {
  var _parameters$to;
  const {
    commitments,
    version
  } = parameters;
  const to = (_parameters$to = parameters.to) !== null && _parameters$to !== void 0 ? _parameters$to : typeof commitments[0] === 'string' ? 'hex' : 'bytes';
  const hashes = [];
  for (const commitment of commitments) {
    hashes.push(commitmentToVersionedHash({
      commitment,
      to,
      version
    }));
  }
  return hashes;
}

// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-4844.md#parameters
/** Blob limit per transaction. */
const blobsPerTransaction = 6;
/** The number of bytes in a BLS scalar field element. */
const bytesPerFieldElement = 32;
/** The number of field elements in a blob. */
const fieldElementsPerBlob = 4096;
/** The number of bytes in a blob. */
const bytesPerBlob = bytesPerFieldElement * fieldElementsPerBlob;
/** Blob bytes limit per transaction. */
const maxBytesPerTransaction = bytesPerBlob * blobsPerTransaction -
// terminator byte (0x80).
1 -
// zero byte (0x00) appended to each field element.
1 * fieldElementsPerBlob * blobsPerTransaction;

// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-4844.md#parameters
const versionedHashVersionKzg = 1;

class BlobSizeTooLargeError extends BaseError {
  constructor(_ref) {
    let {
      maxSize,
      size
    } = _ref;
    super('Blob size is too large.', {
      metaMessages: [`Max: ${maxSize} bytes`, `Given: ${size} bytes`],
      name: 'BlobSizeTooLargeError'
    });
  }
}
class EmptyBlobError extends BaseError {
  constructor() {
    super('Blob data must not be empty.', {
      name: 'EmptyBlobError'
    });
  }
}
class InvalidVersionedHashSizeError extends BaseError {
  constructor(_ref2) {
    let {
      hash,
      size
    } = _ref2;
    super(`Versioned hash "${hash}" size is invalid.`, {
      metaMessages: ['Expected: 32', `Received: ${size}`],
      name: 'InvalidVersionedHashSizeError'
    });
  }
}
class InvalidVersionedHashVersionError extends BaseError {
  constructor(_ref3) {
    let {
      hash,
      version
    } = _ref3;
    super(`Versioned hash "${hash}" version is invalid.`, {
      metaMessages: [`Expected: ${versionedHashVersionKzg}`, `Received: ${version}`],
      name: 'InvalidVersionedHashVersionError'
    });
  }
}

/**
 * Transforms arbitrary data to blobs.
 *
 * @example
 * ```ts
 * import { toBlobs, stringToHex } from 'viem'
 *
 * const blobs = toBlobs({ data: stringToHex('hello world') })
 * ```
 */
function toBlobs(parameters) {
  var _parameters$to;
  const to = (_parameters$to = parameters.to) !== null && _parameters$to !== void 0 ? _parameters$to : typeof parameters.data === 'string' ? 'hex' : 'bytes';
  const data = typeof parameters.data === 'string' ? hexToBytes$1(parameters.data) : parameters.data;
  const size_ = size(data);
  if (!size_) throw new EmptyBlobError();
  if (size_ > maxBytesPerTransaction) throw new BlobSizeTooLargeError({
    maxSize: maxBytesPerTransaction,
    size: size_
  });
  const blobs = [];
  let active = true;
  let position = 0;
  while (active) {
    const blob = createCursor(new Uint8Array(bytesPerBlob));
    let size = 0;
    while (size < fieldElementsPerBlob) {
      const bytes = data.slice(position, position + (bytesPerFieldElement - 1));
      // Push a zero byte so the field element doesn't overflow the BLS modulus.
      blob.pushByte(0x00);
      // Push the current segment of data bytes.
      blob.pushBytes(bytes);
      // If we detect that the current segment of data bytes is less than 31 bytes,
      // we can stop processing and push a terminator byte to indicate the end of the blob.
      if (bytes.length < 31) {
        blob.pushByte(0x80);
        active = false;
        break;
      }
      size++;
      position += 31;
    }
    blobs.push(blob);
  }
  return to === 'bytes' ? blobs.map(x => x.bytes) : blobs.map(x => bytesToHex$1(x.bytes));
}

/**
 * Transforms arbitrary data (or blobs, commitments, & proofs) into a sidecar array.
 *
 * @example
 * ```ts
 * import { toBlobSidecars, stringToHex } from 'viem'
 *
 * const sidecars = toBlobSidecars({ data: stringToHex('hello world') })
 * ```
 *
 * @example
 * ```ts
 * import {
 *   blobsToCommitments,
 *   toBlobs,
 *   blobsToProofs,
 *   toBlobSidecars,
 *   stringToHex
 * } from 'viem'
 *
 * const blobs = toBlobs({ data: stringToHex('hello world') })
 * const commitments = blobsToCommitments({ blobs, kzg })
 * const proofs = blobsToProofs({ blobs, commitments, kzg })
 *
 * const sidecars = toBlobSidecars({ blobs, commitments, proofs })
 * ```
 */
function toBlobSidecars(parameters) {
  var _parameters$blobs, _parameters$commitmen, _parameters$proofs;
  const {
    data,
    kzg,
    to
  } = parameters;
  const blobs = (_parameters$blobs = parameters.blobs) !== null && _parameters$blobs !== void 0 ? _parameters$blobs : toBlobs({
    data: data,
    to
  });
  const commitments = (_parameters$commitmen = parameters.commitments) !== null && _parameters$commitmen !== void 0 ? _parameters$commitmen : blobsToCommitments({
    blobs,
    kzg: kzg,
    to
  });
  const proofs = (_parameters$proofs = parameters.proofs) !== null && _parameters$proofs !== void 0 ? _parameters$proofs : blobsToProofs({
    blobs,
    commitments,
    kzg: kzg,
    to
  });
  const sidecars = [];
  for (let i = 0; i < blobs.length; i++) sidecars.push({
    blob: blobs[i],
    commitment: commitments[i],
    proof: proofs[i]
  });
  return sidecars;
}

/*
 * Serializes an EIP-7702 authorization list.
 */
function serializeAuthorizationList(authorizationList) {
  if (!authorizationList || authorizationList.length === 0) return [];
  const serializedAuthorizationList = [];
  for (const authorization of authorizationList) {
    const {
      contractAddress,
      chainId,
      nonce,
      ...signature
    } = authorization;
    serializedAuthorizationList.push([toHex(chainId), contractAddress, nonce ? toHex(nonce) : '0x', ...toYParitySignatureArray({}, signature)]);
  }
  return serializedAuthorizationList;
}

class InvalidAddressError extends BaseError {
  constructor(_ref) {
    let {
      address
    } = _ref;
    super(`Address "${address}" is invalid.`, {
      metaMessages: ['- Address must be a hex value of 20 bytes (40 hex characters).', '- Address must match its checksum counterpart.'],
      name: 'InvalidAddressError'
    });
  }
}

class InvalidChainIdError extends BaseError {
  constructor(_ref3) {
    let {
      chainId
    } = _ref3;
    super(typeof chainId === 'number' ? `Chain ID "${chainId}" is invalid.` : 'Chain ID is invalid.', {
      name: 'InvalidChainIdError'
    });
  }
}

class ExecutionRevertedError extends BaseError {
  constructor() {
    var _message$replace;
    let {
      cause,
      message
    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const reason = message === null || message === void 0 ? void 0 : (_message$replace = message.replace('execution reverted: ', '')) === null || _message$replace === void 0 ? void 0 : _message$replace.replace('execution reverted', '');
    super(`Execution reverted ${reason ? `with reason: ${reason}` : 'for an unknown reason'}.`, {
      cause,
      name: 'ExecutionRevertedError'
    });
  }
}
Object.defineProperty(ExecutionRevertedError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: 3
});
Object.defineProperty(ExecutionRevertedError, "nodeMessage", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /execution reverted/
});
class FeeCapTooHighError extends BaseError {
  constructor() {
    let {
      cause,
      maxFeePerGas
    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    super(`The fee cap (\`maxFeePerGas\`${maxFeePerGas ? ` = ${formatGwei(maxFeePerGas)} gwei` : ''}) cannot be higher than the maximum allowed value (2^256-1).`, {
      cause,
      name: 'FeeCapTooHighError'
    });
  }
}
Object.defineProperty(FeeCapTooHighError, "nodeMessage", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /max fee per gas higher than 2\^256-1|fee cap higher than 2\^256-1/
});
class FeeCapTooLowError extends BaseError {
  constructor() {
    let {
      cause,
      maxFeePerGas
    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    super(`The fee cap (\`maxFeePerGas\`${maxFeePerGas ? ` = ${formatGwei(maxFeePerGas)}` : ''} gwei) cannot be lower than the block base fee.`, {
      cause,
      name: 'FeeCapTooLowError'
    });
  }
}
Object.defineProperty(FeeCapTooLowError, "nodeMessage", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /max fee per gas less than block base fee|fee cap less than block base fee|transaction is outdated/
});
class NonceTooHighError extends BaseError {
  constructor() {
    let {
      cause,
      nonce
    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    super(`Nonce provided for the transaction ${nonce ? `(${nonce}) ` : ''}is higher than the next one expected.`, {
      cause,
      name: 'NonceTooHighError'
    });
  }
}
Object.defineProperty(NonceTooHighError, "nodeMessage", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /nonce too high/
});
class NonceTooLowError extends BaseError {
  constructor() {
    let {
      cause,
      nonce
    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    super([`Nonce provided for the transaction ${nonce ? `(${nonce}) ` : ''}is lower than the current nonce of the account.`, 'Try increasing the nonce or find the latest nonce with `getTransactionCount`.'].join('\n'), {
      cause,
      name: 'NonceTooLowError'
    });
  }
}
Object.defineProperty(NonceTooLowError, "nodeMessage", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /nonce too low|transaction already imported|already known/
});
class NonceMaxValueError extends BaseError {
  constructor() {
    let {
      cause,
      nonce
    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    super(`Nonce provided for the transaction ${nonce ? `(${nonce}) ` : ''}exceeds the maximum allowed nonce.`, {
      cause,
      name: 'NonceMaxValueError'
    });
  }
}
Object.defineProperty(NonceMaxValueError, "nodeMessage", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /nonce has max value/
});
class InsufficientFundsError extends BaseError {
  constructor() {
    let {
      cause
    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    super(['The total cost (gas * gas fee + value) of executing this transaction exceeds the balance of the account.'].join('\n'), {
      cause,
      metaMessages: ['This error could arise when the account does not have enough funds to:', ' - pay for the total gas fee,', ' - pay for the value to send.', ' ', 'The cost of the transaction is calculated as `gas * gas fee + value`, where:', ' - `gas` is the amount of gas needed for transaction to execute,', ' - `gas fee` is the gas fee,', ' - `value` is the amount of ether to send to the recipient.'],
      name: 'InsufficientFundsError'
    });
  }
}
Object.defineProperty(InsufficientFundsError, "nodeMessage", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /insufficient funds|exceeds transaction sender account balance/
});
class IntrinsicGasTooHighError extends BaseError {
  constructor() {
    let {
      cause,
      gas
    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    super(`The amount of gas ${gas ? `(${gas}) ` : ''}provided for the transaction exceeds the limit allowed for the block.`, {
      cause,
      name: 'IntrinsicGasTooHighError'
    });
  }
}
Object.defineProperty(IntrinsicGasTooHighError, "nodeMessage", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /intrinsic gas too high|gas limit reached/
});
class IntrinsicGasTooLowError extends BaseError {
  constructor() {
    let {
      cause,
      gas
    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    super(`The amount of gas ${gas ? `(${gas}) ` : ''}provided for the transaction is too low.`, {
      cause,
      name: 'IntrinsicGasTooLowError'
    });
  }
}
Object.defineProperty(IntrinsicGasTooLowError, "nodeMessage", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /intrinsic gas too low/
});
class TransactionTypeNotSupportedError extends BaseError {
  constructor(_ref) {
    let {
      cause
    } = _ref;
    super('The transaction type is not supported for this chain.', {
      cause,
      name: 'TransactionTypeNotSupportedError'
    });
  }
}
Object.defineProperty(TransactionTypeNotSupportedError, "nodeMessage", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /transaction type not valid/
});
class TipAboveFeeCapError extends BaseError {
  constructor() {
    let {
      cause,
      maxPriorityFeePerGas,
      maxFeePerGas
    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    super([`The provided tip (\`maxPriorityFeePerGas\`${maxPriorityFeePerGas ? ` = ${formatGwei(maxPriorityFeePerGas)} gwei` : ''}) cannot be higher than the fee cap (\`maxFeePerGas\`${maxFeePerGas ? ` = ${formatGwei(maxFeePerGas)} gwei` : ''}).`].join('\n'), {
      cause,
      name: 'TipAboveFeeCapError'
    });
  }
}
Object.defineProperty(TipAboveFeeCapError, "nodeMessage", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /max priority fee per gas higher than max fee per gas|tip higher than fee cap/
});

/**
 * Map with a LRU (Least recently used) policy.
 *
 * @link https://en.wikipedia.org/wiki/Cache_replacement_policies#LRU
 */
class LruMap extends Map {
  constructor(size) {
    super();
    Object.defineProperty(this, "maxSize", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.maxSize = size;
  }
  get(key) {
    const value = super.get(key);
    if (super.has(key) && value !== undefined) {
      this.delete(key);
      super.set(key, value);
    }
    return value;
  }
  set(key, value) {
    super.set(key, value);
    if (this.maxSize && this.size > this.maxSize) {
      const firstKey = this.keys().next().value;
      if (firstKey) this.delete(firstKey);
    }
    return this;
  }
}

const U32_MASK64$1 = /* @__PURE__ */BigInt(2 ** 32 - 1);
const _32n$1 = /* @__PURE__ */BigInt(32);
// We are not using BigUint64Array, because they are extremely slow as per 2022
function fromBig$1(n) {
  let le = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  if (le) return {
    h: Number(n & U32_MASK64$1),
    l: Number(n >> _32n$1 & U32_MASK64$1)
  };
  return {
    h: Number(n >> _32n$1 & U32_MASK64$1) | 0,
    l: Number(n & U32_MASK64$1) | 0
  };
}
function split$1(lst) {
  let le = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  let Ah = new Uint32Array(lst.length);
  let Al = new Uint32Array(lst.length);
  for (let i = 0; i < lst.length; i++) {
    const {
      h,
      l
    } = fromBig$1(lst[i], le);
    [Ah[i], Al[i]] = [h, l];
  }
  return [Ah, Al];
}
// Left rotate for Shift in [1, 32)
const rotlSH$1 = (h, l, s) => h << s | l >>> 32 - s;
const rotlSL$1 = (h, l, s) => l << s | h >>> 32 - s;
// Left rotate for Shift in (32, 64), NOTE: 32 is special case.
const rotlBH$1 = (h, l, s) => l << s - 32 | h >>> 64 - s;
const rotlBL$1 = (h, l, s) => h << s - 32 | l >>> 64 - s;

// SHA3 (keccak) is based on a new design: basically, the internal state is bigger than output size.
// It's called a sponge function.
// Various per round constants calculations
const SHA3_PI$1 = [];
const SHA3_ROTL$1 = [];
const _SHA3_IOTA$1 = [];
const _0n$5 = /* @__PURE__ */BigInt(0);
const _1n$6 = /* @__PURE__ */BigInt(1);
const _2n$4 = /* @__PURE__ */BigInt(2);
const _7n$1 = /* @__PURE__ */BigInt(7);
const _256n$1 = /* @__PURE__ */BigInt(256);
const _0x71n$1 = /* @__PURE__ */BigInt(0x71);
for (let round = 0, R = _1n$6, x = 1, y = 0; round < 24; round++) {
  // Pi
  [x, y] = [y, (2 * x + 3 * y) % 5];
  SHA3_PI$1.push(2 * (5 * y + x));
  // Rotational
  SHA3_ROTL$1.push((round + 1) * (round + 2) / 2 % 64);
  // Iota
  let t = _0n$5;
  for (let j = 0; j < 7; j++) {
    R = (R << _1n$6 ^ (R >> _7n$1) * _0x71n$1) % _256n$1;
    if (R & _2n$4) t ^= _1n$6 << (_1n$6 << /* @__PURE__ */BigInt(j)) - _1n$6;
  }
  _SHA3_IOTA$1.push(t);
}
const [SHA3_IOTA_H$1, SHA3_IOTA_L$1] = /* @__PURE__ */split$1(_SHA3_IOTA$1, true);
// Left rotation (without 0, 32, 64)
const rotlH$1 = (h, l, s) => s > 32 ? rotlBH$1(h, l, s) : rotlSH$1(h, l, s);
const rotlL$1 = (h, l, s) => s > 32 ? rotlBL$1(h, l, s) : rotlSL$1(h, l, s);
// Same as keccakf1600, but allows to skip some rounds
function keccakP$1(s) {
  let rounds = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 24;
  const B = new Uint32Array(5 * 2);
  // NOTE: all indices are x2 since we store state as u32 instead of u64 (bigints to slow in js)
  for (let round = 24 - rounds; round < 24; round++) {
    // Theta 
    for (let x = 0; x < 10; x++) B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
    for (let x = 0; x < 10; x += 2) {
      const idx1 = (x + 8) % 10;
      const idx0 = (x + 2) % 10;
      const B0 = B[idx0];
      const B1 = B[idx0 + 1];
      const Th = rotlH$1(B0, B1, 1) ^ B[idx1];
      const Tl = rotlL$1(B0, B1, 1) ^ B[idx1 + 1];
      for (let y = 0; y < 50; y += 10) {
        s[x + y] ^= Th;
        s[x + y + 1] ^= Tl;
      }
    }
    // Rho () and Pi ()
    let curH = s[2];
    let curL = s[3];
    for (let t = 0; t < 24; t++) {
      const shift = SHA3_ROTL$1[t];
      const Th = rotlH$1(curH, curL, shift);
      const Tl = rotlL$1(curH, curL, shift);
      const PI = SHA3_PI$1[t];
      curH = s[PI];
      curL = s[PI + 1];
      s[PI] = Th;
      s[PI + 1] = Tl;
    }
    // Chi ()
    for (let y = 0; y < 50; y += 10) {
      for (let x = 0; x < 10; x++) B[x] = s[y + x];
      for (let x = 0; x < 10; x++) s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
    }
    // Iota ()
    s[0] ^= SHA3_IOTA_H$1[round];
    s[1] ^= SHA3_IOTA_L$1[round];
  }
  B.fill(0);
}
class Keccak$1 extends Hash$3 {
  // NOTE: we accept arguments in bytes instead of bits here.
  constructor(blockLen, suffix, outputLen) {
    let enableXOF = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
    let rounds = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 24;
    super();
    this.blockLen = blockLen;
    this.suffix = suffix;
    this.outputLen = outputLen;
    this.enableXOF = enableXOF;
    this.rounds = rounds;
    this.pos = 0;
    this.posOut = 0;
    this.finished = false;
    this.destroyed = false;
    // Can be passed from user as dkLen
    number$1(outputLen);
    // 1600 = 5x5 matrix of 64bit.  1600 bits === 200 bytes
    if (0 >= this.blockLen || this.blockLen >= 200) throw new Error('Sha3 supports only keccak-f1600 function');
    this.state = new Uint8Array(200);
    this.state32 = u32$1(this.state);
  }
  keccak() {
    if (!isLE$1) byteSwap32(this.state32);
    keccakP$1(this.state32, this.rounds);
    if (!isLE$1) byteSwap32(this.state32);
    this.posOut = 0;
    this.pos = 0;
  }
  update(data) {
    exists$3(this);
    const {
      blockLen,
      state
    } = this;
    data = toBytes$1(data);
    const len = data.length;
    for (let pos = 0; pos < len;) {
      const take = Math.min(blockLen - this.pos, len - pos);
      for (let i = 0; i < take; i++) state[this.pos++] ^= data[pos++];
      if (this.pos === blockLen) this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished) return;
    this.finished = true;
    const {
      state,
      suffix,
      pos,
      blockLen
    } = this;
    // Do the padding
    state[pos] ^= suffix;
    if ((suffix & 0x80) !== 0 && pos === blockLen - 1) this.keccak();
    state[blockLen - 1] ^= 0x80;
    this.keccak();
  }
  writeInto(out) {
    exists$3(this, false);
    bytes$1(out);
    this.finish();
    const bufferOut = this.state;
    const {
      blockLen
    } = this;
    for (let pos = 0, len = out.length; pos < len;) {
      if (this.posOut >= blockLen) this.keccak();
      const take = Math.min(blockLen - this.posOut, len - pos);
      out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
      this.posOut += take;
      pos += take;
    }
    return out;
  }
  xofInto(out) {
    // Sha3/Keccak usage with XOF is probably mistake, only SHAKE instances can do XOF
    if (!this.enableXOF) throw new Error('XOF is not possible for this instance');
    return this.writeInto(out);
  }
  xof(bytes) {
    number$1(bytes);
    return this.xofInto(new Uint8Array(bytes));
  }
  digestInto(out) {
    output$1(out, this);
    if (this.finished) throw new Error('digest() was already called');
    this.writeInto(out);
    this.destroy();
    return out;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = true;
    this.state.fill(0);
  }
  _cloneInto(to) {
    const {
      blockLen,
      suffix,
      outputLen,
      rounds,
      enableXOF
    } = this;
    to || (to = new Keccak$1(blockLen, suffix, outputLen, enableXOF, rounds));
    to.state32.set(this.state32);
    to.pos = this.pos;
    to.posOut = this.posOut;
    to.finished = this.finished;
    to.rounds = rounds;
    // Suffix can change in cSHAKE
    to.suffix = suffix;
    to.outputLen = outputLen;
    to.enableXOF = enableXOF;
    to.destroyed = this.destroyed;
    return to;
  }
}
const gen$1 = (suffix, blockLen, outputLen) => wrapConstructor$1(() => new Keccak$1(blockLen, suffix, outputLen));
/**
 * keccak-256 hash function. Different from SHA3-256.
 * @param message - that would be hashed
 */
const keccak_256$1 = /* @__PURE__ */gen$1(0x01, 136, 256 / 8);

function keccak256(value, to_) {
  const to = to_ || 'hex';
  const bytes = keccak_256$1(isHex(value, {
    strict: false
  }) ? toBytes$2(value) : value);
  if (to === 'bytes') return bytes;
  return toHex(bytes);
}

const checksumAddressCache = /*#__PURE__*/new LruMap(8192);
function checksumAddress(address_,
/**
 * Warning: EIP-1191 checksum addresses are generally not backwards compatible with the
 * wider Ethereum ecosystem, meaning it will break when validated against an application/tool
 * that relies on EIP-55 checksum encoding (checksum without chainId).
 *
 * It is highly recommended to not use this feature unless you
 * know what you are doing.
 *
 * See more: https://github.com/ethereum/EIPs/issues/1121
 */
chainId) {
  if (checksumAddressCache.has(`${address_}.${chainId}`)) return checksumAddressCache.get(`${address_}.${chainId}`);
  const hexAddress = chainId ? `${chainId}${address_.toLowerCase()}` : address_.substring(2).toLowerCase();
  const hash = keccak256(stringToBytes(hexAddress), 'bytes');
  const address = (chainId ? hexAddress.substring(`${chainId}0x`.length) : hexAddress).split('');
  for (let i = 0; i < 40; i += 2) {
    if (hash[i >> 1] >> 4 >= 8 && address[i]) {
      address[i] = address[i].toUpperCase();
    }
    if ((hash[i >> 1] & 0x0f) >= 8 && address[i + 1]) {
      address[i + 1] = address[i + 1].toUpperCase();
    }
  }
  const result = `0x${address.join('')}`;
  checksumAddressCache.set(`${address_}.${chainId}`, result);
  return result;
}

const addressRegex = /^0x[a-fA-F0-9]{40}$/;
/** @internal */
const isAddressCache = /*#__PURE__*/new LruMap(8192);
function isAddress(address, options) {
  const {
    strict = true
  } = options !== null && options !== void 0 ? options : {};
  const cacheKey = `${address}.${strict}`;
  if (isAddressCache.has(cacheKey)) return isAddressCache.get(cacheKey);
  const result = (() => {
    if (!addressRegex.test(address)) return false;
    if (address.toLowerCase() === address) return true;
    if (strict) return checksumAddress(address) === address;
    return true;
  })();
  isAddressCache.set(cacheKey, result);
  return result;
}

/**
 * @description Returns a section of the hex or byte array given a start/end bytes offset.
 *
 * @param value The hex or byte array to slice.
 * @param start The start offset (in bytes).
 * @param end The end offset (in bytes).
 */
function slice(value, start, end) {
  let {
    strict
  } = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  if (isHex(value, {
    strict: false
  })) return sliceHex(value, start, end, {
    strict
  });
  return sliceBytes(value, start, end, {
    strict
  });
}
function assertStartOffset(value, start) {
  if (typeof start === 'number' && start > 0 && start > size(value) - 1) throw new SliceOffsetOutOfBoundsError({
    offset: start,
    position: 'start',
    size: size(value)
  });
}
function assertEndOffset(value, start, end) {
  if (typeof start === 'number' && typeof end === 'number' && size(value) !== end - start) {
    throw new SliceOffsetOutOfBoundsError({
      offset: end,
      position: 'end',
      size: size(value)
    });
  }
}
/**
 * @description Returns a section of the byte array given a start/end bytes offset.
 *
 * @param value The byte array to slice.
 * @param start The start offset (in bytes).
 * @param end The end offset (in bytes).
 */
function sliceBytes(value_, start, end) {
  let {
    strict
  } = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  assertStartOffset(value_, start);
  const value = value_.slice(start, end);
  if (strict) assertEndOffset(value, start, end);
  return value;
}
/**
 * @description Returns a section of the hex value given a start/end bytes offset.
 *
 * @param value The hex value to slice.
 * @param start The start offset (in bytes).
 * @param end The end offset (in bytes).
 */
function sliceHex(value_, start, end) {
  let {
    strict
  } = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  assertStartOffset(value_, start);
  const value = `0x${value_.replace('0x', '').slice((start !== null && start !== void 0 ? start : 0) * 2, (end !== null && end !== void 0 ? end : value_.length) * 2)}`;
  if (strict) assertEndOffset(value, start, end);
  return value;
}

function assertTransactionEIP7702(transaction) {
  const {
    authorizationList
  } = transaction;
  if (authorizationList) {
    for (const authorization of authorizationList) {
      const {
        contractAddress,
        chainId
      } = authorization;
      if (!isAddress(contractAddress)) throw new InvalidAddressError({
        address: contractAddress
      });
      if (chainId <= 0) throw new InvalidChainIdError({
        chainId
      });
    }
  }
  assertTransactionEIP1559(transaction);
}
function assertTransactionEIP4844(transaction) {
  const {
    blobVersionedHashes
  } = transaction;
  if (blobVersionedHashes) {
    if (blobVersionedHashes.length === 0) throw new EmptyBlobError();
    for (const hash of blobVersionedHashes) {
      const size_ = size(hash);
      const version = hexToNumber$1(slice(hash, 0, 1));
      if (size_ !== 32) throw new InvalidVersionedHashSizeError({
        hash,
        size: size_
      });
      if (version !== versionedHashVersionKzg) throw new InvalidVersionedHashVersionError({
        hash,
        version
      });
    }
  }
  assertTransactionEIP1559(transaction);
}
function assertTransactionEIP1559(transaction) {
  const {
    chainId,
    maxPriorityFeePerGas,
    maxFeePerGas,
    to
  } = transaction;
  if (chainId <= 0) throw new InvalidChainIdError({
    chainId
  });
  if (to && !isAddress(to)) throw new InvalidAddressError({
    address: to
  });
  if (maxFeePerGas && maxFeePerGas > maxUint256) throw new FeeCapTooHighError({
    maxFeePerGas
  });
  if (maxPriorityFeePerGas && maxFeePerGas && maxPriorityFeePerGas > maxFeePerGas) throw new TipAboveFeeCapError({
    maxFeePerGas,
    maxPriorityFeePerGas
  });
}
function assertTransactionEIP2930(transaction) {
  const {
    chainId,
    maxPriorityFeePerGas,
    gasPrice,
    maxFeePerGas,
    to
  } = transaction;
  if (chainId <= 0) throw new InvalidChainIdError({
    chainId
  });
  if (to && !isAddress(to)) throw new InvalidAddressError({
    address: to
  });
  if (maxPriorityFeePerGas || maxFeePerGas) throw new BaseError('`maxFeePerGas`/`maxPriorityFeePerGas` is not a valid EIP-2930 Transaction attribute.');
  if (gasPrice && gasPrice > maxUint256) throw new FeeCapTooHighError({
    maxFeePerGas: gasPrice
  });
}
function assertTransactionLegacy(transaction) {
  const {
    chainId,
    maxPriorityFeePerGas,
    gasPrice,
    maxFeePerGas,
    to
  } = transaction;
  if (to && !isAddress(to)) throw new InvalidAddressError({
    address: to
  });
  if (typeof chainId !== 'undefined' && chainId <= 0) throw new InvalidChainIdError({
    chainId
  });
  if (maxPriorityFeePerGas || maxFeePerGas) throw new BaseError('`maxFeePerGas`/`maxPriorityFeePerGas` is not a valid Legacy Transaction attribute.');
  if (gasPrice && gasPrice > maxUint256) throw new FeeCapTooHighError({
    maxFeePerGas: gasPrice
  });
}

function getTransactionType(transaction) {
  if (transaction.type) return transaction.type;
  if (typeof transaction.authorizationList !== 'undefined') return 'eip7702';
  if (typeof transaction.blobs !== 'undefined' || typeof transaction.blobVersionedHashes !== 'undefined' || typeof transaction.maxFeePerBlobGas !== 'undefined' || typeof transaction.sidecars !== 'undefined') return 'eip4844';
  if (typeof transaction.maxFeePerGas !== 'undefined' || typeof transaction.maxPriorityFeePerGas !== 'undefined') {
    return 'eip1559';
  }
  if (typeof transaction.gasPrice !== 'undefined') {
    if (typeof transaction.accessList !== 'undefined') return 'eip2930';
    return 'legacy';
  }
  throw new InvalidSerializableTransactionError({
    transaction
  });
}

/*
 * Serialize an  EIP-2930 access list
 * @remarks
 * Use to create a transaction serializer with support for EIP-2930 access lists
 *
 * @param accessList - Array of objects of address and arrays of Storage Keys
 * @throws InvalidAddressError, InvalidStorageKeySizeError
 * @returns Array of hex strings
 */
function serializeAccessList(accessList) {
  if (!accessList || accessList.length === 0) return [];
  const serializedAccessList = [];
  for (let i = 0; i < accessList.length; i++) {
    const {
      address,
      storageKeys
    } = accessList[i];
    for (let j = 0; j < storageKeys.length; j++) {
      if (storageKeys[j].length - 2 !== 64) {
        throw new InvalidStorageKeySizeError({
          storageKey: storageKeys[j]
        });
      }
    }
    if (!isAddress(address, {
      strict: false
    })) {
      throw new InvalidAddressError({
        address
      });
    }
    serializedAccessList.push([address, storageKeys]);
  }
  return serializedAccessList;
}

function serializeTransaction(transaction, signature) {
  const type = getTransactionType(transaction);
  if (type === 'eip1559') return serializeTransactionEIP1559(transaction, signature);
  if (type === 'eip2930') return serializeTransactionEIP2930(transaction, signature);
  if (type === 'eip4844') return serializeTransactionEIP4844(transaction, signature);
  if (type === 'eip7702') return serializeTransactionEIP7702(transaction, signature);
  return serializeTransactionLegacy(transaction, signature);
}
function serializeTransactionEIP7702(transaction, signature) {
  const {
    authorizationList,
    chainId,
    gas,
    nonce,
    to,
    value,
    maxFeePerGas,
    maxPriorityFeePerGas,
    accessList,
    data
  } = transaction;
  assertTransactionEIP7702(transaction);
  const serializedAccessList = serializeAccessList(accessList);
  const serializedAuthorizationList = serializeAuthorizationList(authorizationList);
  return concatHex(['0x04', toRlp([toHex(chainId), nonce ? toHex(nonce) : '0x', maxPriorityFeePerGas ? toHex(maxPriorityFeePerGas) : '0x', maxFeePerGas ? toHex(maxFeePerGas) : '0x', gas ? toHex(gas) : '0x', to !== null && to !== void 0 ? to : '0x', value ? toHex(value) : '0x', data !== null && data !== void 0 ? data : '0x', serializedAccessList, serializedAuthorizationList, ...toYParitySignatureArray(transaction, signature)])]);
}
function serializeTransactionEIP4844(transaction, signature) {
  var _blobVersionedHashes;
  const {
    chainId,
    gas,
    nonce,
    to,
    value,
    maxFeePerBlobGas,
    maxFeePerGas,
    maxPriorityFeePerGas,
    accessList,
    data
  } = transaction;
  assertTransactionEIP4844(transaction);
  let blobVersionedHashes = transaction.blobVersionedHashes;
  let sidecars = transaction.sidecars;
  // If `blobs` are passed, we will need to compute the KZG commitments & proofs.
  if (transaction.blobs && (typeof blobVersionedHashes === 'undefined' || typeof sidecars === 'undefined')) {
    const blobs = typeof transaction.blobs[0] === 'string' ? transaction.blobs : transaction.blobs.map(x => bytesToHex$1(x));
    const kzg = transaction.kzg;
    const commitments = blobsToCommitments({
      blobs,
      kzg
    });
    if (typeof blobVersionedHashes === 'undefined') blobVersionedHashes = commitmentsToVersionedHashes({
      commitments
    });
    if (typeof sidecars === 'undefined') {
      const proofs = blobsToProofs({
        blobs,
        commitments,
        kzg
      });
      sidecars = toBlobSidecars({
        blobs,
        commitments,
        proofs
      });
    }
  }
  const serializedAccessList = serializeAccessList(accessList);
  const serializedTransaction = [toHex(chainId), nonce ? toHex(nonce) : '0x', maxPriorityFeePerGas ? toHex(maxPriorityFeePerGas) : '0x', maxFeePerGas ? toHex(maxFeePerGas) : '0x', gas ? toHex(gas) : '0x', to !== null && to !== void 0 ? to : '0x', value ? toHex(value) : '0x', data !== null && data !== void 0 ? data : '0x', serializedAccessList, maxFeePerBlobGas ? toHex(maxFeePerBlobGas) : '0x', (_blobVersionedHashes = blobVersionedHashes) !== null && _blobVersionedHashes !== void 0 ? _blobVersionedHashes : [], ...toYParitySignatureArray(transaction, signature)];
  const blobs = [];
  const commitments = [];
  const proofs = [];
  if (sidecars) for (let i = 0; i < sidecars.length; i++) {
    const {
      blob,
      commitment,
      proof
    } = sidecars[i];
    blobs.push(blob);
    commitments.push(commitment);
    proofs.push(proof);
  }
  return concatHex(['0x03', sidecars ?
  // If sidecars are enabled, envelope turns into a "wrapper":
  toRlp([serializedTransaction, blobs, commitments, proofs]) :
  // If sidecars are disabled, standard envelope is used:
  toRlp(serializedTransaction)]);
}
function serializeTransactionEIP1559(transaction, signature) {
  const {
    chainId,
    gas,
    nonce,
    to,
    value,
    maxFeePerGas,
    maxPriorityFeePerGas,
    accessList,
    data
  } = transaction;
  assertTransactionEIP1559(transaction);
  const serializedAccessList = serializeAccessList(accessList);
  const serializedTransaction = [toHex(chainId), nonce ? toHex(nonce) : '0x', maxPriorityFeePerGas ? toHex(maxPriorityFeePerGas) : '0x', maxFeePerGas ? toHex(maxFeePerGas) : '0x', gas ? toHex(gas) : '0x', to !== null && to !== void 0 ? to : '0x', value ? toHex(value) : '0x', data !== null && data !== void 0 ? data : '0x', serializedAccessList, ...toYParitySignatureArray(transaction, signature)];
  return concatHex(['0x02', toRlp(serializedTransaction)]);
}
function serializeTransactionEIP2930(transaction, signature) {
  const {
    chainId,
    gas,
    data,
    nonce,
    to,
    value,
    accessList,
    gasPrice
  } = transaction;
  assertTransactionEIP2930(transaction);
  const serializedAccessList = serializeAccessList(accessList);
  const serializedTransaction = [toHex(chainId), nonce ? toHex(nonce) : '0x', gasPrice ? toHex(gasPrice) : '0x', gas ? toHex(gas) : '0x', to !== null && to !== void 0 ? to : '0x', value ? toHex(value) : '0x', data !== null && data !== void 0 ? data : '0x', serializedAccessList, ...toYParitySignatureArray(transaction, signature)];
  return concatHex(['0x01', toRlp(serializedTransaction)]);
}
function serializeTransactionLegacy(transaction, signature) {
  const {
    chainId = 0,
    gas,
    data,
    nonce,
    to,
    value,
    gasPrice
  } = transaction;
  assertTransactionLegacy(transaction);
  let serializedTransaction = [nonce ? toHex(nonce) : '0x', gasPrice ? toHex(gasPrice) : '0x', gas ? toHex(gas) : '0x', to !== null && to !== void 0 ? to : '0x', value ? toHex(value) : '0x', data !== null && data !== void 0 ? data : '0x'];
  if (signature) {
    const v = (() => {
      // EIP-155 (inferred chainId)
      if (signature.v >= 35n) {
        const inferredChainId = (signature.v - 35n) / 2n;
        if (inferredChainId > 0) return signature.v;
        return 27n + (signature.v === 35n ? 0n : 1n);
      }
      // EIP-155 (explicit chainId)
      if (chainId > 0) return BigInt(chainId * 2) + BigInt(35n + signature.v - 27n);
      // Pre-EIP-155 (no chainId)
      const v = 27n + (signature.v === 27n ? 0n : 1n);
      if (signature.v !== v) throw new InvalidLegacyVError({
        v: signature.v
      });
      return v;
    })();
    const r = trim(signature.r);
    const s = trim(signature.s);
    serializedTransaction = [...serializedTransaction, toHex(v), r === '0x00' ? '0x' : r, s === '0x00' ? '0x' : s];
  } else if (chainId > 0) {
    serializedTransaction = [...serializedTransaction, toHex(chainId), '0x', '0x'];
  }
  return toRlp(serializedTransaction);
}
function toYParitySignatureArray(transaction, signature_) {
  const signature = signature_ !== null && signature_ !== void 0 ? signature_ : transaction;
  const {
    v,
    yParity
  } = signature;
  if (typeof signature.r === 'undefined') return [];
  if (typeof signature.s === 'undefined') return [];
  if (typeof v === 'undefined' && typeof yParity === 'undefined') return [];
  const r = trim(signature.r);
  const s = trim(signature.s);
  const yParity_ = (() => {
    if (typeof yParity === 'number') return yParity ? toHex(1) : '0x';
    if (v === 0n) return '0x';
    if (v === 1n) return toHex(1);
    return v === 27n ? '0x' : toHex(1);
  })();
  return [yParity_, r === '0x00' ? '0x' : r, s === '0x00' ? '0x' : s];
}

function parseAccount(account) {
  if (typeof account === 'string') return {
    address: account,
    type: 'json-rpc'
  };
  return account;
}

/**
 * @description Converts an ECDSA public key to an address.
 *
 * @param publicKey The public key to convert.
 *
 * @returns The address.
 */
function publicKeyToAddress(publicKey) {
  const address = keccak256(`0x${publicKey.substring(4)}`).substring(26);
  return checksumAddress(`0x${address}`);
}

/**
 * Computes an Authorization hash in [EIP-7702 format](https://eips.ethereum.org/EIPS/eip-7702): `keccak256('0x05' || rlp([chain_id, address, nonce]))`.
 */
function hashAuthorization(parameters) {
  const {
    chainId,
    contractAddress,
    nonce,
    to
  } = parameters;
  const hash = keccak256(concatHex(['0x05', toRlp([numberToHex(chainId), contractAddress, nonce ? numberToHex(nonce) : '0x'])]));
  if (to === 'bytes') return hexToBytes$1(hash);
  return hash;
}

const stringify = (value, replacer, space) => JSON.stringify(value, (key, value_) => {
  const value = typeof value_ === 'bigint' ? value_.toString() : value_;
  return typeof replacer === 'function' ? replacer(key, value) : value;
}, space);

class AccountNotFoundError extends BaseError {
  constructor() {
    let {
      docsPath
    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    super(['Could not find an Account to execute with this Action.', 'Please provide an Account with the `account` argument on the Action, or by supplying an `account` to the Client.'].join('\n'), {
      docsPath,
      docsSlug: 'account',
      name: 'AccountNotFoundError'
    });
  }
}
class AccountTypeNotSupportedError extends BaseError {
  constructor(_ref) {
    let {
      docsPath,
      metaMessages,
      type
    } = _ref;
    super(`Account type "${type}" is not supported.`, {
      docsPath,
      metaMessages,
      name: 'AccountTypeNotSupportedError'
    });
  }
}

class AbiEncodingArrayLengthMismatchError extends BaseError {
  constructor(_ref5) {
    let {
      expectedLength,
      givenLength,
      type
    } = _ref5;
    super([`ABI encoding array length mismatch for type ${type}.`, `Expected length: ${expectedLength}`, `Given length: ${givenLength}`].join('\n'), {
      name: 'AbiEncodingArrayLengthMismatchError'
    });
  }
}
class AbiEncodingBytesSizeMismatchError extends BaseError {
  constructor(_ref6) {
    let {
      expectedSize,
      value
    } = _ref6;
    super(`Size of bytes "${value}" (bytes${size(value)}) does not match expected size (bytes${expectedSize}).`, {
      name: 'AbiEncodingBytesSizeMismatchError'
    });
  }
}
class AbiEncodingLengthMismatchError extends BaseError {
  constructor(_ref7) {
    let {
      expectedLength,
      givenLength
    } = _ref7;
    super(['ABI encoding params/values length mismatch.', `Expected length (params): ${expectedLength}`, `Given length (values): ${givenLength}`].join('\n'), {
      name: 'AbiEncodingLengthMismatchError'
    });
  }
}
class BytesSizeMismatchError extends BaseError {
  constructor(_ref12) {
    let {
      expectedSize,
      givenSize
    } = _ref12;
    super(`Expected bytes${expectedSize}, got bytes${givenSize}.`, {
      name: 'BytesSizeMismatchError'
    });
  }
}
class InvalidAbiEncodingTypeError extends BaseError {
  constructor(type, _ref15) {
    let {
      docsPath
    } = _ref15;
    super([`Type "${type}" is not a valid encoding type.`, 'Please provide a valid ABI type.'].join('\n'), {
      docsPath,
      name: 'InvalidAbiEncodingType'
    });
  }
}
class InvalidArrayError extends BaseError {
  constructor(value) {
    super([`Value "${value}" is not a valid array.`].join('\n'), {
      name: 'InvalidArrayError'
    });
  }
}

function _defineProperty$1(e, r, t) {
  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
    value: t,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[r] = t, e;
}
function _toPrimitive(t, r) {
  if ("object" != typeof t || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r || "default");
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
function _toPropertyKey(t) {
  var i = _toPrimitive(t, "string");
  return "symbol" == typeof i ? i : i + "";
}

/**
 * @description Encodes a list of primitive values into an ABI-encoded hex value.
 *
 * - Docs: https://viem.sh/docs/abi/encodeAbiParameters#encodeabiparameters
 *
 *   Generates ABI encoded data using the [ABI specification](https://docs.soliditylang.org/en/latest/abi-spec), given a set of ABI parameters (inputs/outputs) and their corresponding values.
 *
 * @param params - a set of ABI Parameters (params), that can be in the shape of the inputs or outputs attribute of an ABI Item.
 * @param values - a set of values (values) that correspond to the given params.
 * @example
 * ```typescript
 * import { encodeAbiParameters } from 'viem'
 *
 * const encodedData = encodeAbiParameters(
 *   [
 *     { name: 'x', type: 'string' },
 *     { name: 'y', type: 'uint' },
 *     { name: 'z', type: 'bool' }
 *   ],
 *   ['wagmi', 420n, true]
 * )
 * ```
 *
 * You can also pass in Human Readable parameters with the parseAbiParameters utility.
 *
 * @example
 * ```typescript
 * import { encodeAbiParameters, parseAbiParameters } from 'viem'
 *
 * const encodedData = encodeAbiParameters(
 *   parseAbiParameters('string x, uint y, bool z'),
 *   ['wagmi', 420n, true]
 * )
 * ```
 */
function encodeAbiParameters(params, values) {
  if (params.length !== values.length) throw new AbiEncodingLengthMismatchError({
    expectedLength: params.length,
    givenLength: values.length
  });
  // Prepare the parameters to determine dynamic types to encode.
  const preparedParams = prepareParams({
    params: params,
    values: values
  });
  const data = encodeParams(preparedParams);
  if (data.length === 0) return '0x';
  return data;
}
function prepareParams(_ref) {
  let {
    params,
    values
  } = _ref;
  const preparedParams = [];
  for (let i = 0; i < params.length; i++) {
    preparedParams.push(prepareParam({
      param: params[i],
      value: values[i]
    }));
  }
  return preparedParams;
}
function prepareParam(_ref2) {
  let {
    param,
    value
  } = _ref2;
  const arrayComponents = getArrayComponents(param.type);
  if (arrayComponents) {
    const [length, type] = arrayComponents;
    return encodeArray(value, {
      length,
      param: {
        ...param,
        type
      }
    });
  }
  if (param.type === 'tuple') {
    return encodeTuple(value, {
      param: param
    });
  }
  if (param.type === 'address') {
    return encodeAddress(value);
  }
  if (param.type === 'bool') {
    return encodeBool(value);
  }
  if (param.type.startsWith('uint') || param.type.startsWith('int')) {
    const signed = param.type.startsWith('int');
    return encodeNumber(value, {
      signed
    });
  }
  if (param.type.startsWith('bytes')) {
    return encodeBytes(value, {
      param
    });
  }
  if (param.type === 'string') {
    return encodeString(value);
  }
  throw new InvalidAbiEncodingTypeError(param.type, {
    docsPath: '/docs/contract/encodeAbiParameters'
  });
}
function encodeParams(preparedParams) {
  // 1. Compute the size of the static part of the parameters.
  let staticSize = 0;
  for (let i = 0; i < preparedParams.length; i++) {
    const {
      dynamic,
      encoded
    } = preparedParams[i];
    if (dynamic) staticSize += 32;else staticSize += size(encoded);
  }
  // 2. Split the parameters into static and dynamic parts.
  const staticParams = [];
  const dynamicParams = [];
  let dynamicSize = 0;
  for (let i = 0; i < preparedParams.length; i++) {
    const {
      dynamic,
      encoded
    } = preparedParams[i];
    if (dynamic) {
      staticParams.push(numberToHex(staticSize + dynamicSize, {
        size: 32
      }));
      dynamicParams.push(encoded);
      dynamicSize += size(encoded);
    } else {
      staticParams.push(encoded);
    }
  }
  // 3. Concatenate static and dynamic parts.
  return concat([...staticParams, ...dynamicParams]);
}
function encodeAddress(value) {
  if (!isAddress(value)) throw new InvalidAddressError({
    address: value
  });
  return {
    dynamic: false,
    encoded: padHex(value.toLowerCase())
  };
}
function encodeArray(value, _ref3) {
  let {
    length,
    param
  } = _ref3;
  const dynamic = length === null;
  if (!Array.isArray(value)) throw new InvalidArrayError(value);
  if (!dynamic && value.length !== length) throw new AbiEncodingArrayLengthMismatchError({
    expectedLength: length,
    givenLength: value.length,
    type: `${param.type}[${length}]`
  });
  let dynamicChild = false;
  const preparedParams = [];
  for (let i = 0; i < value.length; i++) {
    const preparedParam = prepareParam({
      param,
      value: value[i]
    });
    if (preparedParam.dynamic) dynamicChild = true;
    preparedParams.push(preparedParam);
  }
  if (dynamic || dynamicChild) {
    const data = encodeParams(preparedParams);
    if (dynamic) {
      const length = numberToHex(preparedParams.length, {
        size: 32
      });
      return {
        dynamic: true,
        encoded: preparedParams.length > 0 ? concat([length, data]) : length
      };
    }
    if (dynamicChild) return {
      dynamic: true,
      encoded: data
    };
  }
  return {
    dynamic: false,
    encoded: concat(preparedParams.map(_ref4 => {
      let {
        encoded
      } = _ref4;
      return encoded;
    }))
  };
}
function encodeBytes(value, _ref5) {
  let {
    param
  } = _ref5;
  const [, paramSize] = param.type.split('bytes');
  const bytesSize = size(value);
  if (!paramSize) {
    let value_ = value;
    // If the size is not divisible by 32 bytes, pad the end
    // with empty bytes to the ceiling 32 bytes.
    if (bytesSize % 32 !== 0) value_ = padHex(value_, {
      dir: 'right',
      size: Math.ceil((value.length - 2) / 2 / 32) * 32
    });
    return {
      dynamic: true,
      encoded: concat([padHex(numberToHex(bytesSize, {
        size: 32
      })), value_])
    };
  }
  if (bytesSize !== Number.parseInt(paramSize)) throw new AbiEncodingBytesSizeMismatchError({
    expectedSize: Number.parseInt(paramSize),
    value
  });
  return {
    dynamic: false,
    encoded: padHex(value, {
      dir: 'right'
    })
  };
}
function encodeBool(value) {
  if (typeof value !== 'boolean') throw new BaseError(`Invalid boolean value: "${value}" (type: ${typeof value}). Expected: \`true\` or \`false\`.`);
  return {
    dynamic: false,
    encoded: padHex(boolToHex(value))
  };
}
function encodeNumber(value, _ref6) {
  let {
    signed
  } = _ref6;
  return {
    dynamic: false,
    encoded: numberToHex(value, {
      size: 32,
      signed
    })
  };
}
function encodeString(value) {
  const hexValue = stringToHex(value);
  const partsLength = Math.ceil(size(hexValue) / 32);
  const parts = [];
  for (let i = 0; i < partsLength; i++) {
    parts.push(padHex(slice(hexValue, i * 32, (i + 1) * 32), {
      dir: 'right'
    }));
  }
  return {
    dynamic: true,
    encoded: concat([padHex(numberToHex(size(hexValue), {
      size: 32
    })), ...parts])
  };
}
function encodeTuple(value, _ref7) {
  let {
    param
  } = _ref7;
  let dynamic = false;
  const preparedParams = [];
  for (let i = 0; i < param.components.length; i++) {
    const param_ = param.components[i];
    const index = Array.isArray(value) ? i : param_.name;
    const preparedParam = prepareParam({
      param: param_,
      value: value[index]
    });
    preparedParams.push(preparedParam);
    if (preparedParam.dynamic) dynamic = true;
  }
  return {
    dynamic,
    encoded: dynamic ? encodeParams(preparedParams) : concat(preparedParams.map(_ref8 => {
      let {
        encoded
      } = _ref8;
      return encoded;
    }))
  };
}
function getArrayComponents(type) {
  const matches = type.match(/^(.*)\[(\d+)?\]$/);
  return matches ?
  // Return `null` if the array is dynamic.
  [matches[2] ? Number(matches[2]) : null, matches[1]] : undefined;
}

const mainnet = /*#__PURE__*/defineChain({
  id: 1,
  name: 'Ethereum',
  nativeCurrency: {
    name: 'Ether',
    symbol: 'ETH',
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ['https://cloudflare-eth.com']
    }
  },
  blockExplorers: {
    default: {
      name: 'Etherscan',
      url: 'https://etherscan.io',
      apiUrl: 'https://api.etherscan.io/api'
    }
  },
  contracts: {
    ensRegistry: {
      address: '0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e'
    },
    ensUniversalResolver: {
      address: '0xce01f8eee7E479C928F8919abD53E553a36CeF67',
      blockCreated: 19258213
    },
    multicall3: {
      address: '0xca11bde05977b3631167028862be2a173976ca11',
      blockCreated: 14353601
    }
  }
});

/* tslint:disable */
/* eslint-disable */
/**
 * API
 * Audius V1 API
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
const BASE_PATH$1 = "/v1".replace(/\/+$/, "");
class Configuration$1 {
  constructor() {
    let configuration = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    _defineProperty$1(this, "configuration", void 0);
    this.configuration = configuration;
  }
  set config(configuration) {
    this.configuration = configuration;
  }
  get basePath() {
    return this.configuration.basePath != null ? this.configuration.basePath : BASE_PATH$1;
  }
  get fetchApi() {
    return this.configuration.fetchApi;
  }
  get middleware() {
    return this.configuration.middleware || [];
  }
  get queryParamsStringify() {
    return this.configuration.queryParamsStringify || querystring$1;
  }
  get username() {
    return this.configuration.username;
  }
  get password() {
    return this.configuration.password;
  }
  get apiKey() {
    const apiKey = this.configuration.apiKey;
    if (apiKey) {
      return typeof apiKey === 'function' ? apiKey : () => apiKey;
    }
    return undefined;
  }
  get accessToken() {
    const accessToken = this.configuration.accessToken;
    if (accessToken) {
      return typeof accessToken === 'function' ? accessToken : async () => accessToken;
    }
    return undefined;
  }
  get headers() {
    return this.configuration.headers;
  }
  get credentials() {
    return this.configuration.credentials;
  }
}
const DefaultConfig$1 = new Configuration$1();
/**
 * This is the base class for all generated API classes.
 */
class BaseAPI$1 {
  constructor() {
    let configuration = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DefaultConfig$1;
    _defineProperty$1(this, "configuration", void 0);
    _defineProperty$1(this, "middleware", void 0);
    _defineProperty$1(this, "fetchApi", async (url, init) => {
      let fetchParams = {
        url,
        init
      };
      for (const middleware of this.middleware) {
        if (middleware.pre) {
          fetchParams = (await middleware.pre({
            fetch: this.fetchApi,
            ...fetchParams
          })) || fetchParams;
        }
      }
      let response = undefined;
      try {
        response = await (this.configuration.fetchApi || fetch)(fetchParams.url, fetchParams.init);
      } catch (e) {
        for (const middleware of this.middleware) {
          if (middleware.onError) {
            response = (await middleware.onError({
              fetch: this.fetchApi,
              url: fetchParams.url,
              init: fetchParams.init,
              error: e,
              response: response ? response.clone() : undefined
            })) || response;
          }
        }
        if (response === undefined) {
          if (e instanceof Error) {
            throw new FetchError$1(e, 'The request failed and the interceptors did not return an alternative response');
          } else {
            throw e;
          }
        }
      }
      for (const middleware of this.middleware) {
        if (middleware.post) {
          response = (await middleware.post({
            fetch: this.fetchApi,
            url: fetchParams.url,
            init: fetchParams.init,
            response: response.clone()
          })) || response;
        }
      }
      return response;
    });
    this.configuration = configuration;
    this.middleware = configuration.middleware;
  }
  /** @hidden */
  withMiddleware() {
    const next = this.clone();
    next.middleware = next.middleware.concat(...arguments);
    return next;
  }
  /** @hidden */
  withPreMiddleware() {
    for (var _len = arguments.length, preMiddlewares = new Array(_len), _key = 0; _key < _len; _key++) {
      preMiddlewares[_key] = arguments[_key];
    }
    const middlewares = preMiddlewares.map(pre => ({
      pre
    }));
    return this.withMiddleware(...middlewares);
  }
  /** @hidden */
  withPostMiddleware() {
    for (var _len2 = arguments.length, postMiddlewares = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      postMiddlewares[_key2] = arguments[_key2];
    }
    const middlewares = postMiddlewares.map(post => ({
      post
    }));
    return this.withMiddleware(...middlewares);
  }
  /** @hidden */
  async request(context, initOverrides) {
    const {
      url,
      init
    } = await this.createFetchParams(context, initOverrides);
    const response = await this.fetchApi(url, init);
    if (response && response.status >= 200 && response.status < 300) {
      return response;
    }
    throw new ResponseError$1(response, 'Response returned an error code');
  }
  async createFetchParams(context, initOverrides) {
    let url = this.configuration.basePath + context.path;
    if (context.query !== undefined && Object.keys(context.query).length !== 0) {
      // only add the querystring to the URL if there are query parameters.
      // this is done to avoid urls ending with a "?" character which buggy webservers
      // do not handle correctly sometimes.
      url += '?' + this.configuration.queryParamsStringify(context.query);
    }
    const headers = Object.assign({}, this.configuration.headers, context.headers);
    Object.keys(headers).forEach(key => headers[key] === undefined ? delete headers[key] : {});
    const initOverrideFn = typeof initOverrides === "function" ? initOverrides : async () => initOverrides;
    const initParams = {
      method: context.method,
      headers,
      body: context.body,
      credentials: this.configuration.credentials
    };
    const overriddenInit = {
      ...initParams,
      ...(await initOverrideFn({
        init: initParams,
        context
      }))
    };
    const init = {
      ...overriddenInit,
      body: isFormData$1(overriddenInit.body) || overriddenInit.body instanceof URLSearchParams || isBlob$1(overriddenInit.body) || isString$1(overriddenInit.body) ? overriddenInit.body : JSON.stringify(overriddenInit.body)
    };
    return {
      url,
      init
    };
  }
  /**
   * Create a shallow clone of `this` by constructing a new instance
   * and then shallow cloning data members.
   */
  clone() {
    const constructor = this.constructor;
    const next = new constructor(this.configuration);
    next.middleware = this.middleware.slice();
    return next;
  }
}
function isBlob$1(value) {
  return typeof Blob !== 'undefined' && value instanceof Blob;
}
function isFormData$1(value) {
  return typeof FormData !== "undefined" && value instanceof FormData;
}
function isString$1(value) {
  return typeof value === 'string';
}
class ResponseError$1 extends Error {
  constructor(response, msg) {
    super(msg);
    _defineProperty$1(this, "response", void 0);
    _defineProperty$1(this, "name", "ResponseError");
    this.response = response;
  }
}
class FetchError$1 extends Error {
  constructor(cause, msg) {
    super(msg, {
      cause
    });
    _defineProperty$1(this, "name", "FetchError");
  }
}
class RequiredError$1 extends Error {
  constructor(field, msg) {
    super(msg);
    _defineProperty$1(this, "field", void 0);
    _defineProperty$1(this, "name", "RequiredError");
    this.field = field;
  }
}
const COLLECTION_FORMATS$1 = {
  csv: ",",
  ssv: " ",
  tsv: "\t",
  pipes: "|"
};
function exists$2(json, key) {
  const value = json[key];
  return value !== null && value !== undefined;
}
function querystring$1(params) {
  let prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  return Object.keys(params).sort().map(key => querystringSingleKey$1(key, params[key], prefix)).filter(part => part.length > 0).join('&');
}
function querystringSingleKey$1(key, value) {
  let keyPrefix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
  const fullKey = keyPrefix + (keyPrefix.length ? `[${key}]` : key);
  if (value instanceof Array) {
    const multiValue = value.map(singleValue => encodeURIComponent(String(singleValue))).join(`&${encodeURIComponent(fullKey)}=`);
    return `${encodeURIComponent(fullKey)}=${multiValue}`;
  }
  if (value instanceof Set) {
    const valueAsArray = Array.from(value);
    return querystringSingleKey$1(key, valueAsArray, keyPrefix);
  }
  if (value instanceof Date) {
    return `${encodeURIComponent(fullKey)}=${encodeURIComponent(value.toISOString())}`;
  }
  if (value instanceof Object) {
    return querystring$1(value, fullKey);
  }
  return `${encodeURIComponent(fullKey)}=${encodeURIComponent(String(value))}`;
}
function mapValues$1(data, fn) {
  return Object.keys(data).reduce((acc, key) => ({
    ...acc,
    [key]: fn(data[key])
  }), {});
}
function canConsumeForm$1(consumes) {
  for (const consume of consumes) {
    if ('multipart/form-data' === consume.contentType) {
      return true;
    }
  }
  return false;
}
class JSONApiResponse$1 {
  constructor(raw) {
    let transformer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : jsonValue => jsonValue;
    _defineProperty$1(this, "raw", void 0);
    _defineProperty$1(this, "transformer", void 0);
    this.raw = raw;
    this.transformer = transformer;
  }
  async value() {
    return this.transformer(await this.raw.json());
  }
}
class VoidApiResponse$1 {
  constructor(raw) {
    _defineProperty$1(this, "raw", void 0);
    this.raw = raw;
  }
  async value() {
    return undefined;
  }
}
class BlobApiResponse$1 {
  constructor(raw) {
    _defineProperty$1(this, "raw", void 0);
    this.raw = raw;
  }
  async value() {
    return await this.raw.blob();
  }
}
class TextApiResponse$1 {
  constructor(raw) {
    _defineProperty$1(this, "raw", void 0);
    this.raw = raw;
  }
  async value() {
    return await this.raw.text();
  }
}

/* tslint:disable */
/* eslint-disable */
// @ts-nocheck
/**
 * API
 * Audius V1 API
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * Check if a given object implements the Access interface.
 */
function instanceOfAccess$1(value) {
  let isInstance = true;
  isInstance = isInstance && "stream" in value && value["stream"] !== undefined;
  isInstance = isInstance && "download" in value && value["download"] !== undefined;
  return isInstance;
}
function AccessFromJSON$1(json) {
  return AccessFromJSONTyped$1(json);
}
function AccessFromJSONTyped$1(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'stream': json['stream'],
    'download': json['download']
  };
}
function AccessToJSON$1(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'stream': value.stream,
    'download': value.download
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the ExtendedPaymentSplit interface.
 */
function instanceOfExtendedPaymentSplit(value) {
  let isInstance = true;
  isInstance = isInstance && "percentage" in value && value["percentage"] !== undefined;
  isInstance = isInstance && "payoutWallet" in value && value["payoutWallet"] !== undefined;
  isInstance = isInstance && "amount" in value && value["amount"] !== undefined;
  return isInstance;
}
function ExtendedPaymentSplitFromJSON(json) {
  return ExtendedPaymentSplitFromJSONTyped(json);
}
function ExtendedPaymentSplitFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'userId': !exists$2(json, 'user_id') ? undefined : json['user_id'],
    'percentage': json['percentage'],
    'ethWallet': !exists$2(json, 'eth_wallet') ? undefined : json['eth_wallet'],
    'payoutWallet': json['payout_wallet'],
    'amount': json['amount']
  };
}
function ExtendedPaymentSplitToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'user_id': value.userId,
    'percentage': value.percentage,
    'eth_wallet': value.ethWallet,
    'payout_wallet': value.payoutWallet,
    'amount': value.amount
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the ExtendedUsdcGate interface.
 */
function instanceOfExtendedUsdcGate(value) {
  let isInstance = true;
  isInstance = isInstance && "price" in value && value["price"] !== undefined;
  isInstance = isInstance && "splits" in value && value["splits"] !== undefined;
  return isInstance;
}
function ExtendedUsdcGateFromJSON(json) {
  return ExtendedUsdcGateFromJSONTyped(json);
}
function ExtendedUsdcGateFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'price': json['price'],
    'splits': json['splits'].map(ExtendedPaymentSplitFromJSON)
  };
}
function ExtendedUsdcGateToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'price': value.price,
    'splits': value.splits.map(ExtendedPaymentSplitToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the ExtendedPurchaseGate interface.
 */
function instanceOfExtendedPurchaseGate(value) {
  let isInstance = true;
  isInstance = isInstance && "usdcPurchase" in value && value["usdcPurchase"] !== undefined;
  return isInstance;
}
function ExtendedPurchaseGateFromJSON(json) {
  return ExtendedPurchaseGateFromJSONTyped(json);
}
function ExtendedPurchaseGateFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'usdcPurchase': ExtendedUsdcGateFromJSON(json['usdc_purchase'])
  };
}
function ExtendedPurchaseGateToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'usdc_purchase': ExtendedUsdcGateToJSON(value.usdcPurchase)
  };
}

/* tslint:disable */
/* eslint-disable */
// @ts-nocheck
/**
 * API
 * Audius V1 API
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * Check if a given object implements the FollowGate interface.
 */
function instanceOfFollowGate$1(value) {
  let isInstance = true;
  isInstance = isInstance && "followUserId" in value && value["followUserId"] !== undefined;
  return isInstance;
}
function FollowGateFromJSON$1(json) {
  return FollowGateFromJSONTyped$1(json);
}
function FollowGateFromJSONTyped$1(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'followUserId': json['follow_user_id']
  };
}
function FollowGateToJSON$1(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'follow_user_id': value.followUserId
  };
}

/* tslint:disable */
/**
 * @export
 */
const NftCollectionChainEnum$1 = {
  Eth: 'eth',
  Sol: 'sol'
};
/**
 * @export
 */
const NftCollectionStandardEnum$1 = {
  Erc721: 'ERC721',
  Erc1155: 'ERC1155'
};
/**
 * Check if a given object implements the NftCollection interface.
 */
function instanceOfNftCollection$1(value) {
  let isInstance = true;
  isInstance = isInstance && "chain" in value && value["chain"] !== undefined;
  isInstance = isInstance && "address" in value && value["address"] !== undefined;
  isInstance = isInstance && "name" in value && value["name"] !== undefined;
  return isInstance;
}
function NftCollectionFromJSON$1(json) {
  return NftCollectionFromJSONTyped$1(json);
}
function NftCollectionFromJSONTyped$1(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'chain': json['chain'],
    'standard': !exists$2(json, 'standard') ? undefined : json['standard'],
    'address': json['address'],
    'name': json['name'],
    'imageUrl': !exists$2(json, 'imageUrl') ? undefined : json['imageUrl'],
    'externalLink': !exists$2(json, 'externalLink') ? undefined : json['externalLink']
  };
}
function NftCollectionToJSON$1(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'chain': value.chain,
    'standard': value.standard,
    'address': value.address,
    'name': value.name,
    'imageUrl': value.imageUrl,
    'externalLink': value.externalLink
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the NftGate interface.
 */
function instanceOfNftGate$1(value) {
  let isInstance = true;
  isInstance = isInstance && "nftCollection" in value && value["nftCollection"] !== undefined;
  return isInstance;
}
function NftGateFromJSON$1(json) {
  return NftGateFromJSONTyped$1(json);
}
function NftGateFromJSONTyped$1(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'nftCollection': NftCollectionFromJSON$1(json['nft_collection'])
  };
}
function NftGateToJSON$1(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'nft_collection': NftCollectionToJSON$1(value.nftCollection)
  };
}

/* tslint:disable */
/* eslint-disable */
// @ts-nocheck
/**
 * API
 * Audius V1 API
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * Check if a given object implements the TipGate interface.
 */
function instanceOfTipGate$1(value) {
  let isInstance = true;
  isInstance = isInstance && "tipUserId" in value && value["tipUserId"] !== undefined;
  return isInstance;
}
function TipGateFromJSON$1(json) {
  return TipGateFromJSONTyped$1(json);
}
function TipGateFromJSONTyped$1(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'tipUserId': json['tip_user_id']
  };
}
function TipGateToJSON$1(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'tip_user_id': value.tipUserId
  };
}

/* tslint:disable */
/* eslint-disable */
// @ts-nocheck
/**
 * API
 * Audius V1 API
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * Check if a given object implements the ExtendedTokenGate interface.
 */
function instanceOfExtendedTokenGate$1(value) {
  let isInstance = true;
  isInstance = isInstance && "tokenMint" in value && value["tokenMint"] !== undefined;
  isInstance = isInstance && "tokenAmount" in value && value["tokenAmount"] !== undefined;
  return isInstance;
}
function ExtendedTokenGateFromJSON$1(json) {
  return ExtendedTokenGateFromJSONTyped$1(json);
}
function ExtendedTokenGateFromJSONTyped$1(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'tokenMint': json['token_mint'],
    'tokenAmount': json['token_amount']
  };
}
function ExtendedTokenGateToJSON$1(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'token_mint': value.tokenMint,
    'token_amount': value.tokenAmount
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the TokenGate interface.
 */
function instanceOfTokenGate$1(value) {
  let isInstance = true;
  isInstance = isInstance && "tokenGate" in value && value["tokenGate"] !== undefined;
  return isInstance;
}
function TokenGateFromJSON$1(json) {
  return TokenGateFromJSONTyped$1(json);
}
function TokenGateFromJSONTyped$1(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'tokenGate': ExtendedTokenGateFromJSON$1(json['token_gate'])
  };
}
function TokenGateToJSON$1(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'token_gate': ExtendedTokenGateToJSON$1(value.tokenGate)
  };
}

/* tslint:disable */
function ExtendedAccessGateFromJSON(json) {
  return ExtendedAccessGateFromJSONTyped(json);
}
function ExtendedAccessGateFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    ...ExtendedPurchaseGateFromJSONTyped(json),
    ...FollowGateFromJSONTyped$1(json),
    ...NftGateFromJSONTyped$1(json),
    ...TipGateFromJSONTyped$1(json),
    ...TokenGateFromJSONTyped$1(json)
  };
}
function ExtendedAccessGateToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  if (instanceOfExtendedPurchaseGate(value)) {
    return ExtendedPurchaseGateToJSON(value);
  }
  if (instanceOfFollowGate$1(value)) {
    return FollowGateToJSON$1(value);
  }
  if (instanceOfNftGate$1(value)) {
    return NftGateToJSON$1(value);
  }
  if (instanceOfTipGate$1(value)) {
    return TipGateToJSON$1(value);
  }
  if (instanceOfTokenGate$1(value)) {
    return TokenGateToJSON$1(value);
  }
  return {};
}

/* tslint:disable */
/**
 * Check if a given object implements the TrackAccessInfo interface.
 */
function instanceOfTrackAccessInfo(value) {
  let isInstance = true;
  isInstance = isInstance && "userId" in value && value["userId"] !== undefined;
  isInstance = isInstance && "blocknumber" in value && value["blocknumber"] !== undefined;
  return isInstance;
}
function TrackAccessInfoFromJSON(json) {
  return TrackAccessInfoFromJSONTyped(json);
}
function TrackAccessInfoFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'access': !exists$2(json, 'access') ? undefined : AccessFromJSON$1(json['access']),
    'userId': json['user_id'],
    'blocknumber': json['blocknumber'],
    'isStreamGated': !exists$2(json, 'is_stream_gated') ? undefined : json['is_stream_gated'],
    'streamConditions': !exists$2(json, 'stream_conditions') ? undefined : ExtendedAccessGateFromJSON(json['stream_conditions']),
    'isDownloadGated': !exists$2(json, 'is_download_gated') ? undefined : json['is_download_gated'],
    'downloadConditions': !exists$2(json, 'download_conditions') ? undefined : ExtendedAccessGateFromJSON(json['download_conditions'])
  };
}
function TrackAccessInfoToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'access': AccessToJSON$1(value.access),
    'user_id': value.userId,
    'blocknumber': value.blocknumber,
    'is_stream_gated': value.isStreamGated,
    'stream_conditions': ExtendedAccessGateToJSON(value.streamConditions),
    'is_download_gated': value.isDownloadGated,
    'download_conditions': ExtendedAccessGateToJSON(value.downloadConditions)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the AccessInfoResponse interface.
 */
function instanceOfAccessInfoResponse(value) {
  let isInstance = true;
  return isInstance;
}
function AccessInfoResponseFromJSON(json) {
  return AccessInfoResponseFromJSONTyped(json);
}
function AccessInfoResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'data': !exists$2(json, 'data') ? undefined : TrackAccessInfoFromJSON(json['data'])
  };
}
function AccessInfoResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'data': TrackAccessInfoToJSON(value.data)
  };
}

/* tslint:disable */
/**
 * @export
 */
const ActivityItemTypeEnum = {
  Track: 'track',
  Playlist: 'playlist'
};
/**
 * Check if a given object implements the Activity interface.
 */
function instanceOfActivity(value) {
  let isInstance = true;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== undefined;
  isInstance = isInstance && "itemType" in value && value["itemType"] !== undefined;
  isInstance = isInstance && "item" in value && value["item"] !== undefined;
  isInstance = isInstance && "_class" in value && value["_class"] !== undefined;
  return isInstance;
}
function ActivityFromJSON(json) {
  return ActivityFromJSONTyped(json, false);
}
function ActivityFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  if (!ignoreDiscriminator) {
    if (json['_class'] === 'collection_activity') {
      return CollectionActivityFromJSONTyped(json, true);
    }
    if (json['_class'] === 'track_activity') {
      return TrackActivityFromJSONTyped(json, true);
    }
  }
  return {
    'timestamp': json['timestamp'],
    'itemType': json['item_type'],
    'item': json['item'],
    '_class': json['class']
  };
}
function ActivityToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'timestamp': value.timestamp,
    'item_type': value.itemType,
    'item': value.item,
    'class': value._class
  };
}

/* tslint:disable */
/* eslint-disable */
// @ts-nocheck
/**
 * API
 * Audius V1 API
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * Check if a given object implements the AlbumBacklink interface.
 */
function instanceOfAlbumBacklink$1(value) {
  let isInstance = true;
  isInstance = isInstance && "playlistId" in value && value["playlistId"] !== undefined;
  isInstance = isInstance && "playlistName" in value && value["playlistName"] !== undefined;
  isInstance = isInstance && "permalink" in value && value["permalink"] !== undefined;
  return isInstance;
}
function AlbumBacklinkFromJSON$1(json) {
  return AlbumBacklinkFromJSONTyped$1(json);
}
function AlbumBacklinkFromJSONTyped$1(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'playlistId': json['playlist_id'],
    'playlistName': json['playlist_name'],
    'permalink': json['permalink']
  };
}
function AlbumBacklinkToJSON$1(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'playlist_id': value.playlistId,
    'playlist_name': value.playlistName,
    'permalink': value.permalink
  };
}

/* tslint:disable */
/* eslint-disable */
// @ts-nocheck
/**
 * API
 * Audius V1 API
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * Check if a given object implements the PlaylistAddedTimestamp interface.
 */
function instanceOfPlaylistAddedTimestamp$1(value) {
  let isInstance = true;
  isInstance = isInstance && "metadataTimestamp" in value && value["metadataTimestamp"] !== undefined;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== undefined;
  isInstance = isInstance && "trackId" in value && value["trackId"] !== undefined;
  return isInstance;
}
function PlaylistAddedTimestampFromJSON$1(json) {
  return PlaylistAddedTimestampFromJSONTyped$1(json);
}
function PlaylistAddedTimestampFromJSONTyped$1(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'metadataTimestamp': json['metadata_timestamp'],
    'timestamp': json['timestamp'],
    'trackId': json['track_id']
  };
}
function PlaylistAddedTimestampToJSON$1(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'metadata_timestamp': value.metadataTimestamp,
    'timestamp': value.timestamp,
    'track_id': value.trackId
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the PlaylistArtwork interface.
 */
function instanceOfPlaylistArtwork$1(value) {
  let isInstance = true;
  return isInstance;
}
function PlaylistArtworkFromJSON$1(json) {
  return PlaylistArtworkFromJSONTyped$1(json);
}
function PlaylistArtworkFromJSONTyped$1(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    '_150x150': !exists$2(json, '150x150') ? undefined : json['150x150'],
    '_480x480': !exists$2(json, '480x480') ? undefined : json['480x480'],
    '_1000x1000': !exists$2(json, '1000x1000') ? undefined : json['1000x1000']
  };
}
function PlaylistArtworkToJSON$1(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    '150x150': value._150x150,
    '480x480': value._480x480,
    '1000x1000': value._1000x1000
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the CoverPhoto interface.
 */
function instanceOfCoverPhoto$1(value) {
  let isInstance = true;
  return isInstance;
}
function CoverPhotoFromJSON$1(json) {
  return CoverPhotoFromJSONTyped$1(json);
}
function CoverPhotoFromJSONTyped$1(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    '_640x': !exists$2(json, '640x') ? undefined : json['640x'],
    '_2000x': !exists$2(json, '2000x') ? undefined : json['2000x']
  };
}
function CoverPhotoToJSON$1(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    '640x': value._640x,
    '2000x': value._2000x
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the ProfilePicture interface.
 */
function instanceOfProfilePicture$1(value) {
  let isInstance = true;
  return isInstance;
}
function ProfilePictureFromJSON$1(json) {
  return ProfilePictureFromJSONTyped$1(json);
}
function ProfilePictureFromJSONTyped$1(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    '_150x150': !exists$2(json, '150x150') ? undefined : json['150x150'],
    '_480x480': !exists$2(json, '480x480') ? undefined : json['480x480'],
    '_1000x1000': !exists$2(json, '1000x1000') ? undefined : json['1000x1000']
  };
}
function ProfilePictureToJSON$1(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    '150x150': value._150x150,
    '480x480': value._480x480,
    '1000x1000': value._1000x1000
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the User interface.
 */
function instanceOfUser(value) {
  let isInstance = true;
  isInstance = isInstance && "albumCount" in value && value["albumCount"] !== undefined;
  isInstance = isInstance && "followeeCount" in value && value["followeeCount"] !== undefined;
  isInstance = isInstance && "followerCount" in value && value["followerCount"] !== undefined;
  isInstance = isInstance && "handle" in value && value["handle"] !== undefined;
  isInstance = isInstance && "id" in value && value["id"] !== undefined;
  isInstance = isInstance && "isVerified" in value && value["isVerified"] !== undefined;
  isInstance = isInstance && "verifiedWithTwitter" in value && value["verifiedWithTwitter"] !== undefined;
  isInstance = isInstance && "verifiedWithInstagram" in value && value["verifiedWithInstagram"] !== undefined;
  isInstance = isInstance && "verifiedWithTiktok" in value && value["verifiedWithTiktok"] !== undefined;
  isInstance = isInstance && "name" in value && value["name"] !== undefined;
  isInstance = isInstance && "playlistCount" in value && value["playlistCount"] !== undefined;
  isInstance = isInstance && "repostCount" in value && value["repostCount"] !== undefined;
  isInstance = isInstance && "trackCount" in value && value["trackCount"] !== undefined;
  isInstance = isInstance && "isDeactivated" in value && value["isDeactivated"] !== undefined;
  isInstance = isInstance && "isAvailable" in value && value["isAvailable"] !== undefined;
  isInstance = isInstance && "ercWallet" in value && value["ercWallet"] !== undefined;
  isInstance = isInstance && "splWallet" in value && value["splWallet"] !== undefined;
  isInstance = isInstance && "splUsdcWallet" in value && value["splUsdcWallet"] !== undefined;
  isInstance = isInstance && "supporterCount" in value && value["supporterCount"] !== undefined;
  isInstance = isInstance && "supportingCount" in value && value["supportingCount"] !== undefined;
  isInstance = isInstance && "totalAudioBalance" in value && value["totalAudioBalance"] !== undefined;
  isInstance = isInstance && "wallet" in value && value["wallet"] !== undefined;
  return isInstance;
}
function UserFromJSON(json) {
  return UserFromJSONTyped(json);
}
function UserFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'albumCount': json['album_count'],
    'artistPickTrackId': !exists$2(json, 'artist_pick_track_id') ? undefined : json['artist_pick_track_id'],
    'bio': !exists$2(json, 'bio') ? undefined : json['bio'],
    'coverPhoto': !exists$2(json, 'cover_photo') ? undefined : CoverPhotoFromJSON$1(json['cover_photo']),
    'followeeCount': json['followee_count'],
    'followerCount': json['follower_count'],
    'handle': json['handle'],
    'id': json['id'],
    'isVerified': json['is_verified'],
    'twitterHandle': !exists$2(json, 'twitter_handle') ? undefined : json['twitter_handle'],
    'instagramHandle': !exists$2(json, 'instagram_handle') ? undefined : json['instagram_handle'],
    'tiktokHandle': !exists$2(json, 'tiktok_handle') ? undefined : json['tiktok_handle'],
    'verifiedWithTwitter': json['verified_with_twitter'],
    'verifiedWithInstagram': json['verified_with_instagram'],
    'verifiedWithTiktok': json['verified_with_tiktok'],
    'website': !exists$2(json, 'website') ? undefined : json['website'],
    'donation': !exists$2(json, 'donation') ? undefined : json['donation'],
    'location': !exists$2(json, 'location') ? undefined : json['location'],
    'name': json['name'],
    'playlistCount': json['playlist_count'],
    'profilePicture': !exists$2(json, 'profile_picture') ? undefined : ProfilePictureFromJSON$1(json['profile_picture']),
    'repostCount': json['repost_count'],
    'trackCount': json['track_count'],
    'isDeactivated': json['is_deactivated'],
    'isAvailable': json['is_available'],
    'ercWallet': json['erc_wallet'],
    'splWallet': json['spl_wallet'],
    'splUsdcWallet': json['spl_usdc_wallet'],
    'splUsdcPayoutWallet': !exists$2(json, 'spl_usdc_payout_wallet') ? undefined : json['spl_usdc_payout_wallet'],
    'supporterCount': json['supporter_count'],
    'supportingCount': json['supporting_count'],
    'totalAudioBalance': json['total_audio_balance'],
    'wallet': json['wallet']
  };
}
function UserToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'album_count': value.albumCount,
    'artist_pick_track_id': value.artistPickTrackId,
    'bio': value.bio,
    'cover_photo': CoverPhotoToJSON$1(value.coverPhoto),
    'followee_count': value.followeeCount,
    'follower_count': value.followerCount,
    'handle': value.handle,
    'id': value.id,
    'is_verified': value.isVerified,
    'twitter_handle': value.twitterHandle,
    'instagram_handle': value.instagramHandle,
    'tiktok_handle': value.tiktokHandle,
    'verified_with_twitter': value.verifiedWithTwitter,
    'verified_with_instagram': value.verifiedWithInstagram,
    'verified_with_tiktok': value.verifiedWithTiktok,
    'website': value.website,
    'donation': value.donation,
    'location': value.location,
    'name': value.name,
    'playlist_count': value.playlistCount,
    'profile_picture': ProfilePictureToJSON$1(value.profilePicture),
    'repost_count': value.repostCount,
    'track_count': value.trackCount,
    'is_deactivated': value.isDeactivated,
    'is_available': value.isAvailable,
    'erc_wallet': value.ercWallet,
    'spl_wallet': value.splWallet,
    'spl_usdc_wallet': value.splUsdcWallet,
    'spl_usdc_payout_wallet': value.splUsdcPayoutWallet,
    'supporter_count': value.supporterCount,
    'supporting_count': value.supportingCount,
    'total_audio_balance': value.totalAudioBalance,
    'wallet': value.wallet
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the Playlist interface.
 */
function instanceOfPlaylist(value) {
  let isInstance = true;
  isInstance = isInstance && "permalink" in value && value["permalink"] !== undefined;
  isInstance = isInstance && "id" in value && value["id"] !== undefined;
  isInstance = isInstance && "isAlbum" in value && value["isAlbum"] !== undefined;
  isInstance = isInstance && "isImageAutogenerated" in value && value["isImageAutogenerated"] !== undefined;
  isInstance = isInstance && "playlistName" in value && value["playlistName"] !== undefined;
  isInstance = isInstance && "playlistContents" in value && value["playlistContents"] !== undefined;
  isInstance = isInstance && "repostCount" in value && value["repostCount"] !== undefined;
  isInstance = isInstance && "favoriteCount" in value && value["favoriteCount"] !== undefined;
  isInstance = isInstance && "totalPlayCount" in value && value["totalPlayCount"] !== undefined;
  isInstance = isInstance && "user" in value && value["user"] !== undefined;
  isInstance = isInstance && "access" in value && value["access"] !== undefined;
  isInstance = isInstance && "trackCount" in value && value["trackCount"] !== undefined;
  return isInstance;
}
function PlaylistFromJSON(json) {
  return PlaylistFromJSONTyped(json);
}
function PlaylistFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'artwork': !exists$2(json, 'artwork') ? undefined : PlaylistArtworkFromJSON$1(json['artwork']),
    'description': !exists$2(json, 'description') ? undefined : json['description'],
    'permalink': json['permalink'],
    'id': json['id'],
    'isAlbum': json['is_album'],
    'isImageAutogenerated': json['is_image_autogenerated'],
    'playlistName': json['playlist_name'],
    'playlistContents': json['playlist_contents'].map(PlaylistAddedTimestampFromJSON$1),
    'repostCount': json['repost_count'],
    'favoriteCount': json['favorite_count'],
    'totalPlayCount': json['total_play_count'],
    'user': UserFromJSON(json['user']),
    'ddexApp': !exists$2(json, 'ddex_app') ? undefined : json['ddex_app'],
    'access': AccessFromJSON$1(json['access']),
    'upc': !exists$2(json, 'upc') ? undefined : json['upc'],
    'trackCount': json['track_count']
  };
}
function PlaylistToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'artwork': PlaylistArtworkToJSON$1(value.artwork),
    'description': value.description,
    'permalink': value.permalink,
    'id': value.id,
    'is_album': value.isAlbum,
    'is_image_autogenerated': value.isImageAutogenerated,
    'playlist_name': value.playlistName,
    'playlist_contents': value.playlistContents.map(PlaylistAddedTimestampToJSON$1),
    'repost_count': value.repostCount,
    'favorite_count': value.favoriteCount,
    'total_play_count': value.totalPlayCount,
    'user': UserToJSON(value.user),
    'ddex_app': value.ddexApp,
    'access': AccessToJSON$1(value.access),
    'upc': value.upc,
    'track_count': value.trackCount
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the AlbumsResponse interface.
 */
function instanceOfAlbumsResponse(value) {
  let isInstance = true;
  return isInstance;
}
function AlbumsResponseFromJSON(json) {
  return AlbumsResponseFromJSONTyped(json);
}
function AlbumsResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'data': !exists$2(json, 'data') ? undefined : json['data'].map(PlaylistFromJSON)
  };
}
function AlbumsResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'data': value.data === undefined ? undefined : value.data.map(PlaylistToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the AuthorizedApp interface.
 */
function instanceOfAuthorizedApp(value) {
  let isInstance = true;
  isInstance = isInstance && "address" in value && value["address"] !== undefined;
  isInstance = isInstance && "name" in value && value["name"] !== undefined;
  isInstance = isInstance && "grantorUserId" in value && value["grantorUserId"] !== undefined;
  isInstance = isInstance && "grantCreatedAt" in value && value["grantCreatedAt"] !== undefined;
  isInstance = isInstance && "grantUpdatedAt" in value && value["grantUpdatedAt"] !== undefined;
  return isInstance;
}
function AuthorizedAppFromJSON(json) {
  return AuthorizedAppFromJSONTyped(json);
}
function AuthorizedAppFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'address': json['address'],
    'name': json['name'],
    'description': !exists$2(json, 'description') ? undefined : json['description'],
    'imageUrl': !exists$2(json, 'image_url') ? undefined : json['image_url'],
    'grantorUserId': json['grantor_user_id'],
    'grantCreatedAt': json['grant_created_at'],
    'grantUpdatedAt': json['grant_updated_at']
  };
}
function AuthorizedAppToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'address': value.address,
    'name': value.name,
    'description': value.description,
    'image_url': value.imageUrl,
    'grantor_user_id': value.grantorUserId,
    'grant_created_at': value.grantCreatedAt,
    'grant_updated_at': value.grantUpdatedAt
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the AuthorizedApps interface.
 */
function instanceOfAuthorizedApps(value) {
  let isInstance = true;
  return isInstance;
}
function AuthorizedAppsFromJSON(json) {
  return AuthorizedAppsFromJSONTyped(json);
}
function AuthorizedAppsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'data': !exists$2(json, 'data') ? undefined : json['data'].map(AuthorizedAppFromJSON)
  };
}
function AuthorizedAppsToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'data': value.data === undefined ? undefined : value.data.map(AuthorizedAppToJSON)
  };
}

/* tslint:disable */
/**
 * @export
 */
const BestSellingItemContentTypeEnum$1 = {
  Track: 'track',
  Album: 'album'
};
/**
 * Check if a given object implements the BestSellingItem interface.
 */
function instanceOfBestSellingItem$1(value) {
  let isInstance = true;
  isInstance = isInstance && "contentId" in value && value["contentId"] !== undefined;
  isInstance = isInstance && "title" in value && value["title"] !== undefined;
  isInstance = isInstance && "ownerId" in value && value["ownerId"] !== undefined;
  return isInstance;
}
function BestSellingItemFromJSON$1(json) {
  return BestSellingItemFromJSONTyped$1(json);
}
function BestSellingItemFromJSONTyped$1(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'contentId': json['content_id'],
    'contentType': !exists$2(json, 'content_type') ? undefined : json['content_type'],
    'title': json['title'],
    'ownerId': json['owner_id']
  };
}
function BestSellingItemToJSON$1(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'content_id': value.contentId,
    'content_type': value.contentType,
    'title': value.title,
    'owner_id': value.ownerId
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the BestSellingResponse interface.
 */
function instanceOfBestSellingResponse(value) {
  let isInstance = true;
  return isInstance;
}
function BestSellingResponseFromJSON(json) {
  return BestSellingResponseFromJSONTyped(json);
}
function BestSellingResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'data': !exists$2(json, 'data') ? undefined : json['data'].map(BestSellingItemFromJSON$1)
  };
}
function BestSellingResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'data': value.data === undefined ? undefined : value.data.map(BestSellingItemToJSON$1)
  };
}

/* tslint:disable */
/* eslint-disable */
// @ts-nocheck
/**
 * API
 * Audius V1 API
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * Check if a given object implements the BlobInfo interface.
 */
function instanceOfBlobInfo(value) {
  let isInstance = true;
  isInstance = isInstance && "size" in value && value["size"] !== undefined;
  isInstance = isInstance && "contentType" in value && value["contentType"] !== undefined;
  return isInstance;
}
function BlobInfoFromJSON(json) {
  return BlobInfoFromJSONTyped(json);
}
function BlobInfoFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'size': json['size'],
    'contentType': json['content_type']
  };
}
function BlobInfoToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'size': value.size,
    'content_type': value.contentType
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the ChallengeResponse interface.
 */
function instanceOfChallengeResponse(value) {
  let isInstance = true;
  isInstance = isInstance && "challengeId" in value && value["challengeId"] !== undefined;
  isInstance = isInstance && "userId" in value && value["userId"] !== undefined;
  isInstance = isInstance && "isComplete" in value && value["isComplete"] !== undefined;
  isInstance = isInstance && "isActive" in value && value["isActive"] !== undefined;
  isInstance = isInstance && "isDisbursed" in value && value["isDisbursed"] !== undefined;
  isInstance = isInstance && "challengeType" in value && value["challengeType"] !== undefined;
  isInstance = isInstance && "amount" in value && value["amount"] !== undefined;
  isInstance = isInstance && "disbursedAmount" in value && value["disbursedAmount"] !== undefined;
  isInstance = isInstance && "metadata" in value && value["metadata"] !== undefined;
  return isInstance;
}
function ChallengeResponseFromJSON(json) {
  return ChallengeResponseFromJSONTyped(json);
}
function ChallengeResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'challengeId': json['challenge_id'],
    'userId': json['user_id'],
    'specifier': !exists$2(json, 'specifier') ? undefined : json['specifier'],
    'isComplete': json['is_complete'],
    'isActive': json['is_active'],
    'isDisbursed': json['is_disbursed'],
    'currentStepCount': !exists$2(json, 'current_step_count') ? undefined : json['current_step_count'],
    'maxSteps': !exists$2(json, 'max_steps') ? undefined : json['max_steps'],
    'challengeType': json['challenge_type'],
    'amount': json['amount'],
    'disbursedAmount': json['disbursed_amount'],
    'cooldownDays': !exists$2(json, 'cooldown_days') ? undefined : json['cooldown_days'],
    'metadata': json['metadata']
  };
}
function ChallengeResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'challenge_id': value.challengeId,
    'user_id': value.userId,
    'specifier': value.specifier,
    'is_complete': value.isComplete,
    'is_active': value.isActive,
    'is_disbursed': value.isDisbursed,
    'current_step_count': value.currentStepCount,
    'max_steps': value.maxSteps,
    'challenge_type': value.challengeType,
    'amount': value.amount,
    'disbursed_amount': value.disbursedAmount,
    'cooldown_days': value.cooldownDays,
    'metadata': value.metadata
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the ClaimRewardsRequest interface.
 */
function instanceOfClaimRewardsRequest(value) {
  let isInstance = true;
  isInstance = isInstance && "userId" in value && value["userId"] !== undefined;
  return isInstance;
}
function ClaimRewardsRequestFromJSON(json) {
  return ClaimRewardsRequestFromJSONTyped(json);
}
function ClaimRewardsRequestFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'challengeId': !exists$2(json, 'challengeId') ? undefined : json['challengeId'],
    'specifier': !exists$2(json, 'specifier') ? undefined : json['specifier'],
    'userId': json['userId']
  };
}
function ClaimRewardsRequestToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'challengeId': value.challengeId,
    'specifier': value.specifier,
    'userId': value.userId
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the ClaimRewardsResponseDataInner interface.
 */
function instanceOfClaimRewardsResponseDataInner(value) {
  let isInstance = true;
  isInstance = isInstance && "challengeId" in value && value["challengeId"] !== undefined;
  isInstance = isInstance && "specifier" in value && value["specifier"] !== undefined;
  return isInstance;
}
function ClaimRewardsResponseDataInnerFromJSON(json) {
  return ClaimRewardsResponseDataInnerFromJSONTyped(json);
}
function ClaimRewardsResponseDataInnerFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'challengeId': json['challengeId'],
    'specifier': json['specifier'],
    'amount': !exists$2(json, 'amount') ? undefined : json['amount'],
    'signatures': !exists$2(json, 'signatures') ? undefined : json['signatures'],
    'error': !exists$2(json, 'error') ? undefined : json['error']
  };
}
function ClaimRewardsResponseDataInnerToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'challengeId': value.challengeId,
    'specifier': value.specifier,
    'amount': value.amount,
    'signatures': value.signatures,
    'error': value.error
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the ClaimRewardsResponse interface.
 */
function instanceOfClaimRewardsResponse(value) {
  let isInstance = true;
  isInstance = isInstance && "data" in value && value["data"] !== undefined;
  return isInstance;
}
function ClaimRewardsResponseFromJSON(json) {
  return ClaimRewardsResponseFromJSONTyped(json);
}
function ClaimRewardsResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'data': json['data'].map(ClaimRewardsResponseDataInnerFromJSON)
  };
}
function ClaimRewardsResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'data': value.data.map(ClaimRewardsResponseDataInnerToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the CoinDynamicBondingCurve interface.
 */
function instanceOfCoinDynamicBondingCurve(value) {
  let isInstance = true;
  isInstance = isInstance && "address" in value && value["address"] !== undefined;
  isInstance = isInstance && "price" in value && value["price"] !== undefined;
  isInstance = isInstance && "priceUSD" in value && value["priceUSD"] !== undefined;
  isInstance = isInstance && "curveProgress" in value && value["curveProgress"] !== undefined;
  isInstance = isInstance && "creatorQuoteFee" in value && value["creatorQuoteFee"] !== undefined;
  isInstance = isInstance && "totalTradingQuoteFee" in value && value["totalTradingQuoteFee"] !== undefined;
  return isInstance;
}
function CoinDynamicBondingCurveFromJSON(json) {
  return CoinDynamicBondingCurveFromJSONTyped(json);
}
function CoinDynamicBondingCurveFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'address': json['address'],
    'price': json['price'],
    'priceUSD': json['priceUSD'],
    'curveProgress': json['curveProgress'],
    'isMigrated': !exists$2(json, 'isMigrated') ? undefined : json['isMigrated'],
    'creatorQuoteFee': json['creatorQuoteFee'],
    'totalTradingQuoteFee': json['totalTradingQuoteFee']
  };
}
function CoinDynamicBondingCurveToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'address': value.address,
    'price': value.price,
    'priceUSD': value.priceUSD,
    'curveProgress': value.curveProgress,
    'isMigrated': value.isMigrated,
    'creatorQuoteFee': value.creatorQuoteFee,
    'totalTradingQuoteFee': value.totalTradingQuoteFee
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the CoinExtensions interface.
 */
function instanceOfCoinExtensions(value) {
  let isInstance = true;
  return isInstance;
}
function CoinExtensionsFromJSON(json) {
  return CoinExtensionsFromJSONTyped(json);
}
function CoinExtensionsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'coingeckoId': !exists$2(json, 'coingeckoId') ? undefined : json['coingeckoId'],
    'description': !exists$2(json, 'description') ? undefined : json['description'],
    'twitter': !exists$2(json, 'twitter') ? undefined : json['twitter'],
    'website': !exists$2(json, 'website') ? undefined : json['website'],
    'discord': !exists$2(json, 'discord') ? undefined : json['discord']
  };
}
function CoinExtensionsToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'coingeckoId': value.coingeckoId,
    'description': value.description,
    'twitter': value.twitter,
    'website': value.website,
    'discord': value.discord
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the Coin interface.
 */
function instanceOfCoin$1(value) {
  let isInstance = true;
  isInstance = isInstance && "name" in value && value["name"] !== undefined;
  isInstance = isInstance && "mint" in value && value["mint"] !== undefined;
  isInstance = isInstance && "decimals" in value && value["decimals"] !== undefined;
  isInstance = isInstance && "ownerId" in value && value["ownerId"] !== undefined;
  isInstance = isInstance && "hasDiscord" in value && value["hasDiscord"] !== undefined;
  isInstance = isInstance && "createdAt" in value && value["createdAt"] !== undefined;
  isInstance = isInstance && "marketCap" in value && value["marketCap"] !== undefined;
  isInstance = isInstance && "fdv" in value && value["fdv"] !== undefined;
  isInstance = isInstance && "liquidity" in value && value["liquidity"] !== undefined;
  isInstance = isInstance && "lastTradeUnixTime" in value && value["lastTradeUnixTime"] !== undefined;
  isInstance = isInstance && "lastTradeHumanTime" in value && value["lastTradeHumanTime"] !== undefined;
  isInstance = isInstance && "price" in value && value["price"] !== undefined;
  isInstance = isInstance && "history24hPrice" in value && value["history24hPrice"] !== undefined;
  isInstance = isInstance && "priceChange24hPercent" in value && value["priceChange24hPercent"] !== undefined;
  isInstance = isInstance && "uniqueWallet24h" in value && value["uniqueWallet24h"] !== undefined;
  isInstance = isInstance && "uniqueWalletHistory24h" in value && value["uniqueWalletHistory24h"] !== undefined;
  isInstance = isInstance && "uniqueWallet24hChangePercent" in value && value["uniqueWallet24hChangePercent"] !== undefined;
  isInstance = isInstance && "totalSupply" in value && value["totalSupply"] !== undefined;
  isInstance = isInstance && "circulatingSupply" in value && value["circulatingSupply"] !== undefined;
  isInstance = isInstance && "holder" in value && value["holder"] !== undefined;
  isInstance = isInstance && "trade24h" in value && value["trade24h"] !== undefined;
  isInstance = isInstance && "tradeHistory24h" in value && value["tradeHistory24h"] !== undefined;
  isInstance = isInstance && "trade24hChangePercent" in value && value["trade24hChangePercent"] !== undefined;
  isInstance = isInstance && "sell24h" in value && value["sell24h"] !== undefined;
  isInstance = isInstance && "sellHistory24h" in value && value["sellHistory24h"] !== undefined;
  isInstance = isInstance && "sell24hChangePercent" in value && value["sell24hChangePercent"] !== undefined;
  isInstance = isInstance && "buy24h" in value && value["buy24h"] !== undefined;
  isInstance = isInstance && "buyHistory24h" in value && value["buyHistory24h"] !== undefined;
  isInstance = isInstance && "buy24hChangePercent" in value && value["buy24hChangePercent"] !== undefined;
  isInstance = isInstance && "v24h" in value && value["v24h"] !== undefined;
  isInstance = isInstance && "v24hUSD" in value && value["v24hUSD"] !== undefined;
  isInstance = isInstance && "vHistory24h" in value && value["vHistory24h"] !== undefined;
  isInstance = isInstance && "dynamicBondingCurve" in value && value["dynamicBondingCurve"] !== undefined;
  return isInstance;
}
function CoinFromJSON$1(json) {
  return CoinFromJSONTyped$1(json);
}
function CoinFromJSONTyped$1(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'name': json['name'],
    'ticker': !exists$2(json, 'ticker') ? undefined : json['ticker'],
    'mint': json['mint'],
    'decimals': json['decimals'],
    'ownerId': json['owner_id'],
    'logoUri': !exists$2(json, 'logo_uri') ? undefined : json['logo_uri'],
    'description': !exists$2(json, 'description') ? undefined : json['description'],
    'website': !exists$2(json, 'website') ? undefined : json['website'],
    'link1': !exists$2(json, 'link_1') ? undefined : json['link_1'],
    'link2': !exists$2(json, 'link_2') ? undefined : json['link_2'],
    'link3': !exists$2(json, 'link_3') ? undefined : json['link_3'],
    'link4': !exists$2(json, 'link_4') ? undefined : json['link_4'],
    'hasDiscord': json['has_discord'],
    'createdAt': json['created_at'],
    'address': !exists$2(json, 'address') ? undefined : json['address'],
    'symbol': !exists$2(json, 'symbol') ? undefined : json['symbol'],
    'marketCap': json['marketCap'],
    'fdv': json['fdv'],
    'extensions': !exists$2(json, 'extensions') ? undefined : CoinExtensionsFromJSON(json['extensions']),
    'liquidity': json['liquidity'],
    'lastTradeUnixTime': json['lastTradeUnixTime'],
    'lastTradeHumanTime': json['lastTradeHumanTime'],
    'price': json['price'],
    'history24hPrice': json['history24hPrice'],
    'priceChange24hPercent': json['priceChange24hPercent'],
    'uniqueWallet24h': json['uniqueWallet24h'],
    'uniqueWalletHistory24h': json['uniqueWalletHistory24h'],
    'uniqueWallet24hChangePercent': json['uniqueWallet24hChangePercent'],
    'totalSupply': json['totalSupply'],
    'circulatingSupply': json['circulatingSupply'],
    'holder': json['holder'],
    'trade24h': json['trade24h'],
    'tradeHistory24h': json['tradeHistory24h'],
    'trade24hChangePercent': json['trade24hChangePercent'],
    'sell24h': json['sell24h'],
    'sellHistory24h': json['sellHistory24h'],
    'sell24hChangePercent': json['sell24hChangePercent'],
    'buy24h': json['buy24h'],
    'buyHistory24h': json['buyHistory24h'],
    'buy24hChangePercent': json['buy24hChangePercent'],
    'v24h': json['v24h'],
    'v24hUSD': json['v24hUSD'],
    'vHistory24h': json['vHistory24h'],
    'vHistory24hUSD': !exists$2(json, 'vHistory24hUSD') ? undefined : json['vHistory24hUSD'],
    'v24hChangePercent': !exists$2(json, 'v24hChangePercent') ? undefined : json['v24hChangePercent'],
    'vBuy24h': !exists$2(json, 'vBuy24h') ? undefined : json['vBuy24h'],
    'vBuy24hUSD': !exists$2(json, 'vBuy24hUSD') ? undefined : json['vBuy24hUSD'],
    'vBuyHistory24h': !exists$2(json, 'vBuyHistory24h') ? undefined : json['vBuyHistory24h'],
    'vBuyHistory24hUSD': !exists$2(json, 'vBuyHistory24hUSD') ? undefined : json['vBuyHistory24hUSD'],
    'vBuy24hChangePercent': !exists$2(json, 'vBuy24hChangePercent') ? undefined : json['vBuy24hChangePercent'],
    'vSell24h': !exists$2(json, 'vSell24h') ? undefined : json['vSell24h'],
    'vSell24hUSD': !exists$2(json, 'vSell24hUSD') ? undefined : json['vSell24hUSD'],
    'vSellHistory24h': !exists$2(json, 'vSellHistory24h') ? undefined : json['vSellHistory24h'],
    'vSellHistory24hUSD': !exists$2(json, 'vSellHistory24hUSD') ? undefined : json['vSellHistory24hUSD'],
    'vSell24hChangePercent': !exists$2(json, 'vSell24hChangePercent') ? undefined : json['vSell24hChangePercent'],
    'numberMarkets': !exists$2(json, 'numberMarkets') ? undefined : json['numberMarkets'],
    'dynamicBondingCurve': CoinDynamicBondingCurveFromJSON(json['dynamicBondingCurve'])
  };
}
function CoinToJSON$1(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'name': value.name,
    'ticker': value.ticker,
    'mint': value.mint,
    'decimals': value.decimals,
    'owner_id': value.ownerId,
    'logo_uri': value.logoUri,
    'description': value.description,
    'website': value.website,
    'link_1': value.link1,
    'link_2': value.link2,
    'link_3': value.link3,
    'link_4': value.link4,
    'has_discord': value.hasDiscord,
    'created_at': value.createdAt,
    'address': value.address,
    'symbol': value.symbol,
    'marketCap': value.marketCap,
    'fdv': value.fdv,
    'extensions': CoinExtensionsToJSON(value.extensions),
    'liquidity': value.liquidity,
    'lastTradeUnixTime': value.lastTradeUnixTime,
    'lastTradeHumanTime': value.lastTradeHumanTime,
    'price': value.price,
    'history24hPrice': value.history24hPrice,
    'priceChange24hPercent': value.priceChange24hPercent,
    'uniqueWallet24h': value.uniqueWallet24h,
    'uniqueWalletHistory24h': value.uniqueWalletHistory24h,
    'uniqueWallet24hChangePercent': value.uniqueWallet24hChangePercent,
    'totalSupply': value.totalSupply,
    'circulatingSupply': value.circulatingSupply,
    'holder': value.holder,
    'trade24h': value.trade24h,
    'tradeHistory24h': value.tradeHistory24h,
    'trade24hChangePercent': value.trade24hChangePercent,
    'sell24h': value.sell24h,
    'sellHistory24h': value.sellHistory24h,
    'sell24hChangePercent': value.sell24hChangePercent,
    'buy24h': value.buy24h,
    'buyHistory24h': value.buyHistory24h,
    'buy24hChangePercent': value.buy24hChangePercent,
    'v24h': value.v24h,
    'v24hUSD': value.v24hUSD,
    'vHistory24h': value.vHistory24h,
    'vHistory24hUSD': value.vHistory24hUSD,
    'v24hChangePercent': value.v24hChangePercent,
    'vBuy24h': value.vBuy24h,
    'vBuy24hUSD': value.vBuy24hUSD,
    'vBuyHistory24h': value.vBuyHistory24h,
    'vBuyHistory24hUSD': value.vBuyHistory24hUSD,
    'vBuy24hChangePercent': value.vBuy24hChangePercent,
    'vSell24h': value.vSell24h,
    'vSell24hUSD': value.vSell24hUSD,
    'vSellHistory24h': value.vSellHistory24h,
    'vSellHistory24hUSD': value.vSellHistory24hUSD,
    'vSell24hChangePercent': value.vSell24hChangePercent,
    'numberMarkets': value.numberMarkets,
    'dynamicBondingCurve': CoinDynamicBondingCurveToJSON(value.dynamicBondingCurve)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the CoinInsights interface.
 */
function instanceOfCoinInsights(value) {
  let isInstance = true;
  isInstance = isInstance && "marketCap" in value && value["marketCap"] !== undefined;
  isInstance = isInstance && "fdv" in value && value["fdv"] !== undefined;
  isInstance = isInstance && "liquidity" in value && value["liquidity"] !== undefined;
  isInstance = isInstance && "lastTradeUnixTime" in value && value["lastTradeUnixTime"] !== undefined;
  isInstance = isInstance && "lastTradeHumanTime" in value && value["lastTradeHumanTime"] !== undefined;
  isInstance = isInstance && "price" in value && value["price"] !== undefined;
  isInstance = isInstance && "history24hPrice" in value && value["history24hPrice"] !== undefined;
  isInstance = isInstance && "priceChange24hPercent" in value && value["priceChange24hPercent"] !== undefined;
  isInstance = isInstance && "uniqueWallet24h" in value && value["uniqueWallet24h"] !== undefined;
  isInstance = isInstance && "uniqueWalletHistory24h" in value && value["uniqueWalletHistory24h"] !== undefined;
  isInstance = isInstance && "uniqueWallet24hChangePercent" in value && value["uniqueWallet24hChangePercent"] !== undefined;
  isInstance = isInstance && "totalSupply" in value && value["totalSupply"] !== undefined;
  isInstance = isInstance && "circulatingSupply" in value && value["circulatingSupply"] !== undefined;
  isInstance = isInstance && "holder" in value && value["holder"] !== undefined;
  isInstance = isInstance && "trade24h" in value && value["trade24h"] !== undefined;
  isInstance = isInstance && "tradeHistory24h" in value && value["tradeHistory24h"] !== undefined;
  isInstance = isInstance && "trade24hChangePercent" in value && value["trade24hChangePercent"] !== undefined;
  isInstance = isInstance && "sell24h" in value && value["sell24h"] !== undefined;
  isInstance = isInstance && "sellHistory24h" in value && value["sellHistory24h"] !== undefined;
  isInstance = isInstance && "sell24hChangePercent" in value && value["sell24hChangePercent"] !== undefined;
  isInstance = isInstance && "buy24h" in value && value["buy24h"] !== undefined;
  isInstance = isInstance && "buyHistory24h" in value && value["buyHistory24h"] !== undefined;
  isInstance = isInstance && "buy24hChangePercent" in value && value["buy24hChangePercent"] !== undefined;
  isInstance = isInstance && "v24h" in value && value["v24h"] !== undefined;
  isInstance = isInstance && "v24hUSD" in value && value["v24hUSD"] !== undefined;
  isInstance = isInstance && "vHistory24h" in value && value["vHistory24h"] !== undefined;
  isInstance = isInstance && "dynamicBondingCurve" in value && value["dynamicBondingCurve"] !== undefined;
  return isInstance;
}
function CoinInsightsFromJSON(json) {
  return CoinInsightsFromJSONTyped(json);
}
function CoinInsightsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'address': !exists$2(json, 'address') ? undefined : json['address'],
    'decimals': !exists$2(json, 'decimals') ? undefined : json['decimals'],
    'symbol': !exists$2(json, 'symbol') ? undefined : json['symbol'],
    'name': !exists$2(json, 'name') ? undefined : json['name'],
    'marketCap': json['marketCap'],
    'fdv': json['fdv'],
    'extensions': !exists$2(json, 'extensions') ? undefined : CoinExtensionsFromJSON(json['extensions']),
    'liquidity': json['liquidity'],
    'lastTradeUnixTime': json['lastTradeUnixTime'],
    'lastTradeHumanTime': json['lastTradeHumanTime'],
    'price': json['price'],
    'history24hPrice': json['history24hPrice'],
    'priceChange24hPercent': json['priceChange24hPercent'],
    'uniqueWallet24h': json['uniqueWallet24h'],
    'uniqueWalletHistory24h': json['uniqueWalletHistory24h'],
    'uniqueWallet24hChangePercent': json['uniqueWallet24hChangePercent'],
    'totalSupply': json['totalSupply'],
    'circulatingSupply': json['circulatingSupply'],
    'holder': json['holder'],
    'trade24h': json['trade24h'],
    'tradeHistory24h': json['tradeHistory24h'],
    'trade24hChangePercent': json['trade24hChangePercent'],
    'sell24h': json['sell24h'],
    'sellHistory24h': json['sellHistory24h'],
    'sell24hChangePercent': json['sell24hChangePercent'],
    'buy24h': json['buy24h'],
    'buyHistory24h': json['buyHistory24h'],
    'buy24hChangePercent': json['buy24hChangePercent'],
    'v24h': json['v24h'],
    'v24hUSD': json['v24hUSD'],
    'vHistory24h': json['vHistory24h'],
    'vHistory24hUSD': !exists$2(json, 'vHistory24hUSD') ? undefined : json['vHistory24hUSD'],
    'v24hChangePercent': !exists$2(json, 'v24hChangePercent') ? undefined : json['v24hChangePercent'],
    'vBuy24h': !exists$2(json, 'vBuy24h') ? undefined : json['vBuy24h'],
    'vBuy24hUSD': !exists$2(json, 'vBuy24hUSD') ? undefined : json['vBuy24hUSD'],
    'vBuyHistory24h': !exists$2(json, 'vBuyHistory24h') ? undefined : json['vBuyHistory24h'],
    'vBuyHistory24hUSD': !exists$2(json, 'vBuyHistory24hUSD') ? undefined : json['vBuyHistory24hUSD'],
    'vBuy24hChangePercent': !exists$2(json, 'vBuy24hChangePercent') ? undefined : json['vBuy24hChangePercent'],
    'vSell24h': !exists$2(json, 'vSell24h') ? undefined : json['vSell24h'],
    'vSell24hUSD': !exists$2(json, 'vSell24hUSD') ? undefined : json['vSell24hUSD'],
    'vSellHistory24h': !exists$2(json, 'vSellHistory24h') ? undefined : json['vSellHistory24h'],
    'vSellHistory24hUSD': !exists$2(json, 'vSellHistory24hUSD') ? undefined : json['vSellHistory24hUSD'],
    'vSell24hChangePercent': !exists$2(json, 'vSell24hChangePercent') ? undefined : json['vSell24hChangePercent'],
    'numberMarkets': !exists$2(json, 'numberMarkets') ? undefined : json['numberMarkets'],
    'dynamicBondingCurve': CoinDynamicBondingCurveFromJSON(json['dynamicBondingCurve'])
  };
}
function CoinInsightsToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'address': value.address,
    'decimals': value.decimals,
    'symbol': value.symbol,
    'name': value.name,
    'marketCap': value.marketCap,
    'fdv': value.fdv,
    'extensions': CoinExtensionsToJSON(value.extensions),
    'liquidity': value.liquidity,
    'lastTradeUnixTime': value.lastTradeUnixTime,
    'lastTradeHumanTime': value.lastTradeHumanTime,
    'price': value.price,
    'history24hPrice': value.history24hPrice,
    'priceChange24hPercent': value.priceChange24hPercent,
    'uniqueWallet24h': value.uniqueWallet24h,
    'uniqueWalletHistory24h': value.uniqueWalletHistory24h,
    'uniqueWallet24hChangePercent': value.uniqueWallet24hChangePercent,
    'totalSupply': value.totalSupply,
    'circulatingSupply': value.circulatingSupply,
    'holder': value.holder,
    'trade24h': value.trade24h,
    'tradeHistory24h': value.tradeHistory24h,
    'trade24hChangePercent': value.trade24hChangePercent,
    'sell24h': value.sell24h,
    'sellHistory24h': value.sellHistory24h,
    'sell24hChangePercent': value.sell24hChangePercent,
    'buy24h': value.buy24h,
    'buyHistory24h': value.buyHistory24h,
    'buy24hChangePercent': value.buy24hChangePercent,
    'v24h': value.v24h,
    'v24hUSD': value.v24hUSD,
    'vHistory24h': value.vHistory24h,
    'vHistory24hUSD': value.vHistory24hUSD,
    'v24hChangePercent': value.v24hChangePercent,
    'vBuy24h': value.vBuy24h,
    'vBuy24hUSD': value.vBuy24hUSD,
    'vBuyHistory24h': value.vBuyHistory24h,
    'vBuyHistory24hUSD': value.vBuyHistory24hUSD,
    'vBuy24hChangePercent': value.vBuy24hChangePercent,
    'vSell24h': value.vSell24h,
    'vSell24hUSD': value.vSell24hUSD,
    'vSellHistory24h': value.vSellHistory24h,
    'vSellHistory24hUSD': value.vSellHistory24hUSD,
    'vSell24hChangePercent': value.vSell24hChangePercent,
    'numberMarkets': value.numberMarkets,
    'dynamicBondingCurve': CoinDynamicBondingCurveToJSON(value.dynamicBondingCurve)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the CoinInsightsResponse interface.
 */
function instanceOfCoinInsightsResponse(value) {
  let isInstance = true;
  return isInstance;
}
function CoinInsightsResponseFromJSON(json) {
  return CoinInsightsResponseFromJSONTyped(json);
}
function CoinInsightsResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'data': !exists$2(json, 'data') ? undefined : CoinInsightsFromJSON(json['data'])
  };
}
function CoinInsightsResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'data': CoinInsightsToJSON(value.data)
  };
}

/* tslint:disable */
/* eslint-disable */
// @ts-nocheck
/**
 * API
 * Audius V1 API
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * Check if a given object implements the CoinMember interface.
 */
function instanceOfCoinMember(value) {
  let isInstance = true;
  isInstance = isInstance && "balance" in value && value["balance"] !== undefined;
  isInstance = isInstance && "userId" in value && value["userId"] !== undefined;
  return isInstance;
}
function CoinMemberFromJSON(json) {
  return CoinMemberFromJSONTyped(json);
}
function CoinMemberFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'balance': json['balance'],
    'userId': json['user_id']
  };
}
function CoinMemberToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'balance': value.balance,
    'user_id': value.userId
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the CoinMembersResponse interface.
 */
function instanceOfCoinMembersResponse(value) {
  let isInstance = true;
  isInstance = isInstance && "data" in value && value["data"] !== undefined;
  return isInstance;
}
function CoinMembersResponseFromJSON(json) {
  return CoinMembersResponseFromJSONTyped(json);
}
function CoinMembersResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'data': json['data'].map(CoinMemberFromJSON)
  };
}
function CoinMembersResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'data': value.data.map(CoinMemberToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the CoinResponse interface.
 */
function instanceOfCoinResponse$1(value) {
  let isInstance = true;
  return isInstance;
}
function CoinResponseFromJSON$1(json) {
  return CoinResponseFromJSONTyped$1(json);
}
function CoinResponseFromJSONTyped$1(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'data': !exists$2(json, 'data') ? undefined : CoinFromJSON$1(json['data'])
  };
}
function CoinResponseToJSON$1(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'data': CoinToJSON$1(value.data)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the CoinsResponse interface.
 */
function instanceOfCoinsResponse$1(value) {
  let isInstance = true;
  isInstance = isInstance && "data" in value && value["data"] !== undefined;
  return isInstance;
}
function CoinsResponseFromJSON$1(json) {
  return CoinsResponseFromJSONTyped$1(json);
}
function CoinsResponseFromJSONTyped$1(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'data': json['data'].map(CoinFromJSON$1)
  };
}
function CoinsResponseToJSON$1(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'data': value.data.map(CoinToJSON$1)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the Collectibles interface.
 */
function instanceOfCollectibles(value) {
  let isInstance = true;
  return isInstance;
}
function CollectiblesFromJSON(json) {
  return CollectiblesFromJSONTyped(json);
}
function CollectiblesFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'data': !exists$2(json, 'data') ? undefined : json['data']
  };
}
function CollectiblesToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'data': value.data
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the CollectiblesResponse interface.
 */
function instanceOfCollectiblesResponse(value) {
  let isInstance = true;
  return isInstance;
}
function CollectiblesResponseFromJSON(json) {
  return CollectiblesResponseFromJSONTyped(json);
}
function CollectiblesResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'data': !exists$2(json, 'data') ? undefined : CollectiblesFromJSON(json['data'])
  };
}
function CollectiblesResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'data': CollectiblesToJSON(value.data)
  };
}

/* tslint:disable */
/**
 * @export
 */
const CollectionActivityItemTypeEnum = {
  Playlist: 'playlist'
};
/**
 * Check if a given object implements the CollectionActivity interface.
 */
function instanceOfCollectionActivity(value) {
  let isInstance = true;
  isInstance = isInstance && "itemType" in value && value["itemType"] !== undefined;
  isInstance = isInstance && "item" in value && value["item"] !== undefined;
  return isInstance;
}
function CollectionActivityFromJSON(json) {
  return CollectionActivityFromJSONTyped(json, false);
}
function CollectionActivityFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    ...ActivityFromJSONTyped(json, ignoreDiscriminator),
    'timestamp': !exists$2(json, 'timestamp') ? undefined : json['timestamp'],
    'itemType': json['item_type'],
    'item': PlaylistFromJSON(json['item'])
  };
}
function CollectionActivityToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    ...ActivityToJSON(value),
    'timestamp': value.timestamp,
    'item_type': value.itemType,
    'item': PlaylistToJSON(value.item)
  };
}

/* tslint:disable */
/* eslint-disable */
// @ts-nocheck
/**
 * API
 * Audius V1 API
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * Check if a given object implements the CommentMention interface.
 */
function instanceOfCommentMention$1(value) {
  let isInstance = true;
  isInstance = isInstance && "userId" in value && value["userId"] !== undefined;
  isInstance = isInstance && "handle" in value && value["handle"] !== undefined;
  return isInstance;
}
function CommentMentionFromJSON$1(json) {
  return CommentMentionFromJSONTyped$1(json);
}
function CommentMentionFromJSONTyped$1(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'userId': json['user_id'],
    'handle': json['handle']
  };
}
function CommentMentionToJSON$1(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'user_id': value.userId,
    'handle': value.handle
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the ReplyComment interface.
 */
function instanceOfReplyComment$1(value) {
  let isInstance = true;
  isInstance = isInstance && "id" in value && value["id"] !== undefined;
  isInstance = isInstance && "entityId" in value && value["entityId"] !== undefined;
  isInstance = isInstance && "entityType" in value && value["entityType"] !== undefined;
  isInstance = isInstance && "userId" in value && value["userId"] !== undefined;
  isInstance = isInstance && "message" in value && value["message"] !== undefined;
  isInstance = isInstance && "reactCount" in value && value["reactCount"] !== undefined;
  isInstance = isInstance && "isEdited" in value && value["isEdited"] !== undefined;
  isInstance = isInstance && "createdAt" in value && value["createdAt"] !== undefined;
  return isInstance;
}
function ReplyCommentFromJSON$1(json) {
  return ReplyCommentFromJSONTyped$1(json);
}
function ReplyCommentFromJSONTyped$1(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'id': json['id'],
    'entityId': json['entity_id'],
    'entityType': json['entity_type'],
    'userId': json['user_id'],
    'message': json['message'],
    'mentions': !exists$2(json, 'mentions') ? undefined : json['mentions'].map(CommentMentionFromJSON$1),
    'trackTimestampS': !exists$2(json, 'track_timestamp_s') ? undefined : json['track_timestamp_s'],
    'reactCount': json['react_count'],
    'isEdited': json['is_edited'],
    'isCurrentUserReacted': !exists$2(json, 'is_current_user_reacted') ? undefined : json['is_current_user_reacted'],
    'isArtistReacted': !exists$2(json, 'is_artist_reacted') ? undefined : json['is_artist_reacted'],
    'createdAt': json['created_at'],
    'updatedAt': !exists$2(json, 'updated_at') ? undefined : json['updated_at'],
    'parentCommentId': !exists$2(json, 'parent_comment_id') ? undefined : json['parent_comment_id']
  };
}
function ReplyCommentToJSON$1(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'id': value.id,
    'entity_id': value.entityId,
    'entity_type': value.entityType,
    'user_id': value.userId,
    'message': value.message,
    'mentions': value.mentions === undefined ? undefined : value.mentions.map(CommentMentionToJSON$1),
    'track_timestamp_s': value.trackTimestampS,
    'react_count': value.reactCount,
    'is_edited': value.isEdited,
    'is_current_user_reacted': value.isCurrentUserReacted,
    'is_artist_reacted': value.isArtistReacted,
    'created_at': value.createdAt,
    'updated_at': value.updatedAt,
    'parent_comment_id': value.parentCommentId
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the Comment interface.
 */
function instanceOfComment$1(value) {
  let isInstance = true;
  isInstance = isInstance && "id" in value && value["id"] !== undefined;
  isInstance = isInstance && "entityId" in value && value["entityId"] !== undefined;
  isInstance = isInstance && "entityType" in value && value["entityType"] !== undefined;
  isInstance = isInstance && "message" in value && value["message"] !== undefined;
  isInstance = isInstance && "reactCount" in value && value["reactCount"] !== undefined;
  isInstance = isInstance && "replyCount" in value && value["replyCount"] !== undefined;
  isInstance = isInstance && "isEdited" in value && value["isEdited"] !== undefined;
  isInstance = isInstance && "createdAt" in value && value["createdAt"] !== undefined;
  return isInstance;
}
function CommentFromJSON$1(json) {
  return CommentFromJSONTyped$1(json);
}
function CommentFromJSONTyped$1(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'id': json['id'],
    'entityId': json['entity_id'],
    'entityType': json['entity_type'],
    'userId': !exists$2(json, 'user_id') ? undefined : json['user_id'],
    'message': json['message'],
    'mentions': !exists$2(json, 'mentions') ? undefined : json['mentions'].map(CommentMentionFromJSON$1),
    'trackTimestampS': !exists$2(json, 'track_timestamp_s') ? undefined : json['track_timestamp_s'],
    'reactCount': json['react_count'],
    'replyCount': json['reply_count'],
    'isEdited': json['is_edited'],
    'isCurrentUserReacted': !exists$2(json, 'is_current_user_reacted') ? undefined : json['is_current_user_reacted'],
    'isArtistReacted': !exists$2(json, 'is_artist_reacted') ? undefined : json['is_artist_reacted'],
    'isTombstone': !exists$2(json, 'is_tombstone') ? undefined : json['is_tombstone'],
    'isMuted': !exists$2(json, 'is_muted') ? undefined : json['is_muted'],
    'createdAt': json['created_at'],
    'updatedAt': !exists$2(json, 'updated_at') ? undefined : json['updated_at'],
    'replies': !exists$2(json, 'replies') ? undefined : json['replies'].map(ReplyCommentFromJSON$1),
    'parentCommentId': !exists$2(json, 'parent_comment_id') ? undefined : json['parent_comment_id']
  };
}
function CommentToJSON$1(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'id': value.id,
    'entity_id': value.entityId,
    'entity_type': value.entityType,
    'user_id': value.userId,
    'message': value.message,
    'mentions': value.mentions === undefined ? undefined : value.mentions.map(CommentMentionToJSON$1),
    'track_timestamp_s': value.trackTimestampS,
    'react_count': value.reactCount,
    'reply_count': value.replyCount,
    'is_edited': value.isEdited,
    'is_current_user_reacted': value.isCurrentUserReacted,
    'is_artist_reacted': value.isArtistReacted,
    'is_tombstone': value.isTombstone,
    'is_muted': value.isMuted,
    'created_at': value.createdAt,
    'updated_at': value.updatedAt,
    'replies': value.replies === undefined ? undefined : value.replies.map(ReplyCommentToJSON$1),
    'parent_comment_id': value.parentCommentId
  };
}

/* tslint:disable */
/* eslint-disable */
// @ts-nocheck
/**
 * API
 * Audius V1 API
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * Check if a given object implements the CommentNotificationSetting interface.
 */
function instanceOfCommentNotificationSetting(value) {
  let isInstance = true;
  isInstance = isInstance && "isMuted" in value && value["isMuted"] !== undefined;
  return isInstance;
}
function CommentNotificationSettingFromJSON(json) {
  return CommentNotificationSettingFromJSONTyped(json);
}
function CommentNotificationSettingFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'isMuted': json['is_muted']
  };
}
function CommentNotificationSettingToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'is_muted': value.isMuted
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the CommentRepliesResponse interface.
 */
function instanceOfCommentRepliesResponse$1(value) {
  let isInstance = true;
  return isInstance;
}
function CommentRepliesResponseFromJSON$1(json) {
  return CommentRepliesResponseFromJSONTyped$1(json);
}
function CommentRepliesResponseFromJSONTyped$1(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'data': !exists$2(json, 'data') ? undefined : json['data'].map(ReplyCommentFromJSON$1)
  };
}
function CommentRepliesResponseToJSON$1(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'data': value.data === undefined ? undefined : value.data.map(ReplyCommentToJSON$1)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the CommentResponse interface.
 */
function instanceOfCommentResponse$1(value) {
  let isInstance = true;
  return isInstance;
}
function CommentResponseFromJSON$1(json) {
  return CommentResponseFromJSONTyped$1(json);
}
function CommentResponseFromJSONTyped$1(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'data': !exists$2(json, 'data') ? undefined : json['data'].map(CommentFromJSON$1)
  };
}
function CommentResponseToJSON$1(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'data': value.data === undefined ? undefined : value.data.map(CommentToJSON$1)
  };
}

/* tslint:disable */
/* eslint-disable */
// @ts-nocheck
/**
 * API
 * Audius V1 API
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * Check if a given object implements the ConnectedWallets interface.
 */
function instanceOfConnectedWallets(value) {
  let isInstance = true;
  isInstance = isInstance && "ercWallets" in value && value["ercWallets"] !== undefined;
  isInstance = isInstance && "splWallets" in value && value["splWallets"] !== undefined;
  return isInstance;
}
function ConnectedWalletsFromJSON(json) {
  return ConnectedWalletsFromJSONTyped(json);
}
function ConnectedWalletsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'ercWallets': json['erc_wallets'],
    'splWallets': json['spl_wallets']
  };
}
function ConnectedWalletsToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'erc_wallets': value.ercWallets,
    'spl_wallets': value.splWallets
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the ConnectedWalletsResponse interface.
 */
function instanceOfConnectedWalletsResponse(value) {
  let isInstance = true;
  return isInstance;
}
function ConnectedWalletsResponseFromJSON(json) {
  return ConnectedWalletsResponseFromJSONTyped(json);
}
function ConnectedWalletsResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'data': !exists$2(json, 'data') ? undefined : ConnectedWalletsFromJSON(json['data'])
  };
}
function ConnectedWalletsResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'data': ConnectedWalletsToJSON(value.data)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the CreateCoinRequest interface.
 */
function instanceOfCreateCoinRequest$1(value) {
  let isInstance = true;
  isInstance = isInstance && "mint" in value && value["mint"] !== undefined;
  isInstance = isInstance && "ticker" in value && value["ticker"] !== undefined;
  isInstance = isInstance && "decimals" in value && value["decimals"] !== undefined;
  isInstance = isInstance && "name" in value && value["name"] !== undefined;
  return isInstance;
}
function CreateCoinRequestFromJSON$1(json) {
  return CreateCoinRequestFromJSONTyped$1(json);
}
function CreateCoinRequestFromJSONTyped$1(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'mint': json['mint'],
    'ticker': json['ticker'],
    'decimals': json['decimals'],
    'name': json['name'],
    'logoUri': !exists$2(json, 'logo_uri') ? undefined : json['logo_uri'],
    'description': !exists$2(json, 'description') ? undefined : json['description']
  };
}
function CreateCoinRequestToJSON$1(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'mint': value.mint,
    'ticker': value.ticker,
    'decimals': value.decimals,
    'name': value.name,
    'logo_uri': value.logoUri,
    'description': value.description
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the CreateCoinResponseData interface.
 */
function instanceOfCreateCoinResponseData$1(value) {
  let isInstance = true;
  isInstance = isInstance && "mint" in value && value["mint"] !== undefined;
  isInstance = isInstance && "ticker" in value && value["ticker"] !== undefined;
  isInstance = isInstance && "userId" in value && value["userId"] !== undefined;
  isInstance = isInstance && "decimals" in value && value["decimals"] !== undefined;
  isInstance = isInstance && "name" in value && value["name"] !== undefined;
  isInstance = isInstance && "createdAt" in value && value["createdAt"] !== undefined;
  return isInstance;
}
function CreateCoinResponseDataFromJSON$1(json) {
  return CreateCoinResponseDataFromJSONTyped$1(json);
}
function CreateCoinResponseDataFromJSONTyped$1(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'mint': json['mint'],
    'ticker': json['ticker'],
    'userId': json['user_id'],
    'decimals': json['decimals'],
    'name': json['name'],
    'logoUri': !exists$2(json, 'logo_uri') ? undefined : json['logo_uri'],
    'createdAt': new Date(json['created_at'])
  };
}
function CreateCoinResponseDataToJSON$1(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'mint': value.mint,
    'ticker': value.ticker,
    'user_id': value.userId,
    'decimals': value.decimals,
    'name': value.name,
    'logo_uri': value.logoUri,
    'created_at': value.createdAt.toISOString()
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the CreateCoinResponse interface.
 */
function instanceOfCreateCoinResponse$1(value) {
  let isInstance = true;
  return isInstance;
}
function CreateCoinResponseFromJSON$1(json) {
  return CreateCoinResponseFromJSONTyped$1(json);
}
function CreateCoinResponseFromJSONTyped$1(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'data': !exists$2(json, 'data') ? undefined : CreateCoinResponseDataFromJSON$1(json['data'])
  };
}
function CreateCoinResponseToJSON$1(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'data': CreateCoinResponseDataToJSON$1(value.data)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the DashboardWalletUser interface.
 */
function instanceOfDashboardWalletUser(value) {
  let isInstance = true;
  isInstance = isInstance && "wallet" in value && value["wallet"] !== undefined;
  isInstance = isInstance && "user" in value && value["user"] !== undefined;
  return isInstance;
}
function DashboardWalletUserFromJSON(json) {
  return DashboardWalletUserFromJSONTyped(json);
}
function DashboardWalletUserFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'wallet': json['wallet'],
    'user': UserFromJSON(json['user'])
  };
}
function DashboardWalletUserToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'wallet': value.wallet,
    'user': UserToJSON(value.user)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the DashboardWalletUsersResponse interface.
 */
function instanceOfDashboardWalletUsersResponse(value) {
  let isInstance = true;
  return isInstance;
}
function DashboardWalletUsersResponseFromJSON(json) {
  return DashboardWalletUsersResponseFromJSONTyped(json);
}
function DashboardWalletUsersResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'data': !exists$2(json, 'data') ? undefined : json['data'].map(DashboardWalletUserFromJSON)
  };
}
function DashboardWalletUsersResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'data': value.data === undefined ? undefined : value.data.map(DashboardWalletUserToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the DecodedUserToken interface.
 */
function instanceOfDecodedUserToken(value) {
  let isInstance = true;
  isInstance = isInstance && "apiKey" in value && value["apiKey"] !== undefined;
  isInstance = isInstance && "userId" in value && value["userId"] !== undefined;
  isInstance = isInstance && "email" in value && value["email"] !== undefined;
  isInstance = isInstance && "name" in value && value["name"] !== undefined;
  isInstance = isInstance && "handle" in value && value["handle"] !== undefined;
  isInstance = isInstance && "verified" in value && value["verified"] !== undefined;
  isInstance = isInstance && "sub" in value && value["sub"] !== undefined;
  isInstance = isInstance && "iat" in value && value["iat"] !== undefined;
  return isInstance;
}
function DecodedUserTokenFromJSON(json) {
  return DecodedUserTokenFromJSONTyped(json);
}
function DecodedUserTokenFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'apiKey': json['apiKey'],
    'userId': json['userId'],
    'email': json['email'],
    'name': json['name'],
    'handle': json['handle'],
    'verified': json['verified'],
    'profilePicture': !exists$2(json, 'profilePicture') ? undefined : ProfilePictureFromJSON$1(json['profilePicture']),
    'sub': json['sub'],
    'iat': json['iat']
  };
}
function DecodedUserTokenToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'apiKey': value.apiKey,
    'userId': value.userId,
    'email': value.email,
    'name': value.name,
    'handle': value.handle,
    'verified': value.verified,
    'profilePicture': ProfilePictureToJSON$1(value.profilePicture),
    'sub': value.sub,
    'iat': value.iat
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the DeveloperApp interface.
 */
function instanceOfDeveloperApp(value) {
  let isInstance = true;
  isInstance = isInstance && "address" in value && value["address"] !== undefined;
  isInstance = isInstance && "userId" in value && value["userId"] !== undefined;
  isInstance = isInstance && "name" in value && value["name"] !== undefined;
  return isInstance;
}
function DeveloperAppFromJSON(json) {
  return DeveloperAppFromJSONTyped(json);
}
function DeveloperAppFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'address': json['address'],
    'userId': json['user_id'],
    'name': json['name'],
    'description': !exists$2(json, 'description') ? undefined : json['description'],
    'imageUrl': !exists$2(json, 'image_url') ? undefined : json['image_url']
  };
}
function DeveloperAppToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'address': value.address,
    'user_id': value.userId,
    'name': value.name,
    'description': value.description,
    'image_url': value.imageUrl
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the DeveloperAppResponse interface.
 */
function instanceOfDeveloperAppResponse(value) {
  let isInstance = true;
  return isInstance;
}
function DeveloperAppResponseFromJSON(json) {
  return DeveloperAppResponseFromJSONTyped(json);
}
function DeveloperAppResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'data': !exists$2(json, 'data') ? undefined : DeveloperAppFromJSON(json['data'])
  };
}
function DeveloperAppResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'data': DeveloperAppToJSON(value.data)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the DeveloperApps interface.
 */
function instanceOfDeveloperApps(value) {
  let isInstance = true;
  return isInstance;
}
function DeveloperAppsFromJSON(json) {
  return DeveloperAppsFromJSONTyped(json);
}
function DeveloperAppsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'data': !exists$2(json, 'data') ? undefined : json['data'].map(DeveloperAppFromJSON)
  };
}
function DeveloperAppsToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'data': value.data === undefined ? undefined : value.data.map(DeveloperAppToJSON)
  };
}

/* tslint:disable */
/* eslint-disable */
// @ts-nocheck
/**
 * API
 * Audius V1 API
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * Check if a given object implements the EmailAccess interface.
 */
function instanceOfEmailAccess(value) {
  let isInstance = true;
  isInstance = isInstance && "id" in value && value["id"] !== undefined;
  isInstance = isInstance && "emailOwnerUserId" in value && value["emailOwnerUserId"] !== undefined;
  isInstance = isInstance && "receivingUserId" in value && value["receivingUserId"] !== undefined;
  isInstance = isInstance && "grantorUserId" in value && value["grantorUserId"] !== undefined;
  isInstance = isInstance && "encryptedKey" in value && value["encryptedKey"] !== undefined;
  isInstance = isInstance && "isInitial" in value && value["isInitial"] !== undefined;
  isInstance = isInstance && "createdAt" in value && value["createdAt"] !== undefined;
  isInstance = isInstance && "updatedAt" in value && value["updatedAt"] !== undefined;
  return isInstance;
}
function EmailAccessFromJSON(json) {
  return EmailAccessFromJSONTyped(json);
}
function EmailAccessFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'id': json['id'],
    'emailOwnerUserId': json['email_owner_user_id'],
    'receivingUserId': json['receiving_user_id'],
    'grantorUserId': json['grantor_user_id'],
    'encryptedKey': json['encrypted_key'],
    'isInitial': json['is_initial'],
    'createdAt': json['created_at'],
    'updatedAt': json['updated_at']
  };
}
function EmailAccessToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'id': value.id,
    'email_owner_user_id': value.emailOwnerUserId,
    'receiving_user_id': value.receivingUserId,
    'grantor_user_id': value.grantorUserId,
    'encrypted_key': value.encryptedKey,
    'is_initial': value.isInitial,
    'created_at': value.createdAt,
    'updated_at': value.updatedAt
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the EmailAccessResponse interface.
 */
function instanceOfEmailAccessResponse(value) {
  let isInstance = true;
  return isInstance;
}
function EmailAccessResponseFromJSON(json) {
  return EmailAccessResponseFromJSONTyped(json);
}
function EmailAccessResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'data': !exists$2(json, 'data') ? undefined : EmailAccessFromJSON(json['data'])
  };
}
function EmailAccessResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'data': EmailAccessToJSON(value.data)
  };
}

/* tslint:disable */
/**
 * @export
 */
const EventEventTypeEnum = {
  RemixContest: 'remix_contest',
  LiveEvent: 'live_event',
  NewRelease: 'new_release'
};
/**
 * @export
 */
const EventEntityTypeEnum = {
  Track: 'track',
  Collection: 'collection',
  User: 'user'
};
/**
 * Check if a given object implements the Event interface.
 */
function instanceOfEvent(value) {
  let isInstance = true;
  isInstance = isInstance && "eventId" in value && value["eventId"] !== undefined;
  isInstance = isInstance && "eventType" in value && value["eventType"] !== undefined;
  isInstance = isInstance && "userId" in value && value["userId"] !== undefined;
  isInstance = isInstance && "createdAt" in value && value["createdAt"] !== undefined;
  isInstance = isInstance && "updatedAt" in value && value["updatedAt"] !== undefined;
  isInstance = isInstance && "eventData" in value && value["eventData"] !== undefined;
  return isInstance;
}
function EventFromJSON(json) {
  return EventFromJSONTyped(json);
}
function EventFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'eventId': json['event_id'],
    'eventType': json['event_type'],
    'userId': json['user_id'],
    'entityType': !exists$2(json, 'entity_type') ? undefined : json['entity_type'],
    'entityId': !exists$2(json, 'entity_id') ? undefined : json['entity_id'],
    'endDate': !exists$2(json, 'end_date') ? undefined : json['end_date'],
    'isDeleted': !exists$2(json, 'is_deleted') ? undefined : json['is_deleted'],
    'createdAt': json['created_at'],
    'updatedAt': json['updated_at'],
    'eventData': json['event_data']
  };
}
function EventToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'event_id': value.eventId,
    'event_type': value.eventType,
    'user_id': value.userId,
    'entity_type': value.entityType,
    'entity_id': value.entityId,
    'end_date': value.endDate,
    'is_deleted': value.isDeleted,
    'created_at': value.createdAt,
    'updated_at': value.updatedAt,
    'event_data': value.eventData
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the EventsResponse interface.
 */
function instanceOfEventsResponse(value) {
  let isInstance = true;
  return isInstance;
}
function EventsResponseFromJSON(json) {
  return EventsResponseFromJSONTyped(json);
}
function EventsResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'data': !exists$2(json, 'data') ? undefined : json['data'].map(EventFromJSON)
  };
}
function EventsResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'data': value.data === undefined ? undefined : value.data.map(EventToJSON)
  };
}

/* tslint:disable */
/* eslint-disable */
// @ts-nocheck
/**
 * API
 * Audius V1 API
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * Check if a given object implements the Favorite interface.
 */
function instanceOfFavorite$1(value) {
  let isInstance = true;
  isInstance = isInstance && "favoriteItemId" in value && value["favoriteItemId"] !== undefined;
  isInstance = isInstance && "favoriteType" in value && value["favoriteType"] !== undefined;
  isInstance = isInstance && "userId" in value && value["userId"] !== undefined;
  isInstance = isInstance && "createdAt" in value && value["createdAt"] !== undefined;
  return isInstance;
}
function FavoriteFromJSON$1(json) {
  return FavoriteFromJSONTyped$1(json);
}
function FavoriteFromJSONTyped$1(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'favoriteItemId': json['favorite_item_id'],
    'favoriteType': json['favorite_type'],
    'userId': json['user_id'],
    'createdAt': json['created_at']
  };
}
function FavoriteToJSON$1(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'favorite_item_id': value.favoriteItemId,
    'favorite_type': value.favoriteType,
    'user_id': value.userId,
    'created_at': value.createdAt
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the FavoritesResponse interface.
 */
function instanceOfFavoritesResponse(value) {
  let isInstance = true;
  return isInstance;
}
function FavoritesResponseFromJSON(json) {
  return FavoritesResponseFromJSONTyped(json);
}
function FavoritesResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'data': !exists$2(json, 'data') ? undefined : json['data'].map(FavoriteFromJSON$1)
  };
}
function FavoritesResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'data': value.data === undefined ? undefined : value.data.map(FavoriteToJSON$1)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the FollowersResponse interface.
 */
function instanceOfFollowersResponse(value) {
  let isInstance = true;
  return isInstance;
}
function FollowersResponseFromJSON(json) {
  return FollowersResponseFromJSONTyped(json);
}
function FollowersResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'data': !exists$2(json, 'data') ? undefined : json['data'].map(UserFromJSON)
  };
}
function FollowersResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'data': value.data === undefined ? undefined : value.data.map(UserToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the FollowingResponse interface.
 */
function instanceOfFollowingResponse$1(value) {
  let isInstance = true;
  return isInstance;
}
function FollowingResponseFromJSON$1(json) {
  return FollowingResponseFromJSONTyped$1(json);
}
function FollowingResponseFromJSONTyped$1(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'data': !exists$2(json, 'data') ? undefined : json['data'].map(UserFromJSON)
  };
}
function FollowingResponseToJSON$1(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'data': value.data === undefined ? undefined : value.data.map(UserToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the GetChallenges interface.
 */
function instanceOfGetChallenges(value) {
  let isInstance = true;
  return isInstance;
}
function GetChallengesFromJSON(json) {
  return GetChallengesFromJSONTyped(json);
}
function GetChallengesFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'data': !exists$2(json, 'data') ? undefined : json['data'].map(ChallengeResponseFromJSON)
  };
}
function GetChallengesToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'data': value.data === undefined ? undefined : value.data.map(ChallengeResponseToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the Supporting interface.
 */
function instanceOfSupporting(value) {
  let isInstance = true;
  isInstance = isInstance && "rank" in value && value["rank"] !== undefined;
  isInstance = isInstance && "amount" in value && value["amount"] !== undefined;
  isInstance = isInstance && "receiver" in value && value["receiver"] !== undefined;
  return isInstance;
}
function SupportingFromJSON(json) {
  return SupportingFromJSONTyped(json);
}
function SupportingFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'rank': json['rank'],
    'amount': json['amount'],
    'receiver': UserFromJSON(json['receiver'])
  };
}
function SupportingToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'rank': value.rank,
    'amount': value.amount,
    'receiver': UserToJSON(value.receiver)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the GetSupportedUsers interface.
 */
function instanceOfGetSupportedUsers(value) {
  let isInstance = true;
  return isInstance;
}
function GetSupportedUsersFromJSON(json) {
  return GetSupportedUsersFromJSONTyped(json);
}
function GetSupportedUsersFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'data': !exists$2(json, 'data') ? undefined : json['data'].map(SupportingFromJSON)
  };
}
function GetSupportedUsersToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'data': value.data === undefined ? undefined : value.data.map(SupportingToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the Supporter interface.
 */
function instanceOfSupporter(value) {
  let isInstance = true;
  isInstance = isInstance && "rank" in value && value["rank"] !== undefined;
  isInstance = isInstance && "amount" in value && value["amount"] !== undefined;
  isInstance = isInstance && "sender" in value && value["sender"] !== undefined;
  return isInstance;
}
function SupporterFromJSON(json) {
  return SupporterFromJSONTyped(json);
}
function SupporterFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'rank': json['rank'],
    'amount': json['amount'],
    'sender': UserFromJSON(json['sender'])
  };
}
function SupporterToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'rank': value.rank,
    'amount': value.amount,
    'sender': UserToJSON(value.sender)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the GetSupporters interface.
 */
function instanceOfGetSupporters(value) {
  let isInstance = true;
  return isInstance;
}
function GetSupportersFromJSON(json) {
  return GetSupportersFromJSONTyped(json);
}
function GetSupportersFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'data': !exists$2(json, 'data') ? undefined : json['data'].map(SupporterFromJSON)
  };
}
function GetSupportersToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'data': value.data === undefined ? undefined : value.data.map(SupporterToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the Tip interface.
 */
function instanceOfTip(value) {
  let isInstance = true;
  isInstance = isInstance && "amount" in value && value["amount"] !== undefined;
  isInstance = isInstance && "createdAt" in value && value["createdAt"] !== undefined;
  return isInstance;
}
function TipFromJSON(json) {
  return TipFromJSONTyped(json);
}
function TipFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'amount': json['amount'],
    'sender': !exists$2(json, 'sender') ? undefined : UserFromJSON(json['sender']),
    'receiver': !exists$2(json, 'receiver') ? undefined : UserFromJSON(json['receiver']),
    'createdAt': json['created_at']
  };
}
function TipToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'amount': value.amount,
    'sender': UserToJSON(value.sender),
    'receiver': UserToJSON(value.receiver),
    'created_at': value.createdAt
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the GetTipsResponse interface.
 */
function instanceOfGetTipsResponse$1(value) {
  let isInstance = true;
  return isInstance;
}
function GetTipsResponseFromJSON$1(json) {
  return GetTipsResponseFromJSONTyped$1(json);
}
function GetTipsResponseFromJSONTyped$1(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'data': !exists$2(json, 'data') ? undefined : json['data'].map(TipFromJSON)
  };
}
function GetTipsResponseToJSON$1(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'data': value.data === undefined ? undefined : value.data.map(TipToJSON)
  };
}

/* tslint:disable */
/* eslint-disable */
// @ts-nocheck
/**
 * API
 * Audius V1 API
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * Check if a given object implements the TrackElement interface.
 */
function instanceOfTrackElement(value) {
  let isInstance = true;
  isInstance = isInstance && "parentTrackId" in value && value["parentTrackId"] !== undefined;
  return isInstance;
}
function TrackElementFromJSON(json) {
  return TrackElementFromJSONTyped(json);
}
function TrackElementFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'parentTrackId': json['parent_track_id']
  };
}
function TrackElementToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'parent_track_id': value.parentTrackId
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the RemixParent interface.
 */
function instanceOfRemixParent(value) {
  let isInstance = true;
  return isInstance;
}
function RemixParentFromJSON(json) {
  return RemixParentFromJSONTyped(json);
}
function RemixParentFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'tracks': !exists$2(json, 'tracks') ? undefined : json['tracks'].map(TrackElementFromJSON)
  };
}
function RemixParentToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'tracks': value.tracks === undefined ? undefined : value.tracks.map(TrackElementToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the TrackArtwork interface.
 */
function instanceOfTrackArtwork(value) {
  let isInstance = true;
  return isInstance;
}
function TrackArtworkFromJSON(json) {
  return TrackArtworkFromJSONTyped(json);
}
function TrackArtworkFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    '_150x150': !exists$2(json, '150x150') ? undefined : json['150x150'],
    '_480x480': !exists$2(json, '480x480') ? undefined : json['480x480'],
    '_1000x1000': !exists$2(json, '1000x1000') ? undefined : json['1000x1000']
  };
}
function TrackArtworkToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    '150x150': value._150x150,
    '480x480': value._480x480,
    '1000x1000': value._1000x1000
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the Track interface.
 */
function instanceOfTrack(value) {
  let isInstance = true;
  isInstance = isInstance && "artwork" in value && value["artwork"] !== undefined;
  isInstance = isInstance && "genre" in value && value["genre"] !== undefined;
  isInstance = isInstance && "id" in value && value["id"] !== undefined;
  isInstance = isInstance && "isOriginalAvailable" in value && value["isOriginalAvailable"] !== undefined;
  isInstance = isInstance && "repostCount" in value && value["repostCount"] !== undefined;
  isInstance = isInstance && "favoriteCount" in value && value["favoriteCount"] !== undefined;
  isInstance = isInstance && "commentCount" in value && value["commentCount"] !== undefined;
  isInstance = isInstance && "title" in value && value["title"] !== undefined;
  isInstance = isInstance && "user" in value && value["user"] !== undefined;
  isInstance = isInstance && "duration" in value && value["duration"] !== undefined;
  isInstance = isInstance && "isDownloadable" in value && value["isDownloadable"] !== undefined;
  isInstance = isInstance && "playCount" in value && value["playCount"] !== undefined;
  isInstance = isInstance && "permalink" in value && value["permalink"] !== undefined;
  return isInstance;
}
function TrackFromJSON(json) {
  return TrackFromJSONTyped(json);
}
function TrackFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'artwork': TrackArtworkFromJSON(json['artwork']),
    'description': !exists$2(json, 'description') ? undefined : json['description'],
    'genre': json['genre'],
    'id': json['id'],
    'trackCid': !exists$2(json, 'track_cid') ? undefined : json['track_cid'],
    'previewCid': !exists$2(json, 'preview_cid') ? undefined : json['preview_cid'],
    'origFileCid': !exists$2(json, 'orig_file_cid') ? undefined : json['orig_file_cid'],
    'origFilename': !exists$2(json, 'orig_filename') ? undefined : json['orig_filename'],
    'isOriginalAvailable': json['is_original_available'],
    'mood': !exists$2(json, 'mood') ? undefined : json['mood'],
    'releaseDate': !exists$2(json, 'release_date') ? undefined : json['release_date'],
    'isrc': !exists$2(json, 'isrc') ? undefined : json['isrc'],
    'remixOf': !exists$2(json, 'remix_of') ? undefined : RemixParentFromJSON(json['remix_of']),
    'repostCount': json['repost_count'],
    'favoriteCount': json['favorite_count'],
    'commentCount': json['comment_count'],
    'tags': !exists$2(json, 'tags') ? undefined : json['tags'],
    'title': json['title'],
    'user': UserFromJSON(json['user']),
    'duration': json['duration'],
    'isDownloadable': json['is_downloadable'],
    'playCount': json['play_count'],
    'permalink': json['permalink'],
    'isStreamable': !exists$2(json, 'is_streamable') ? undefined : json['is_streamable'],
    'ddexApp': !exists$2(json, 'ddex_app') ? undefined : json['ddex_app'],
    'playlistsContainingTrack': !exists$2(json, 'playlists_containing_track') ? undefined : json['playlists_containing_track'],
    'pinnedCommentId': !exists$2(json, 'pinned_comment_id') ? undefined : json['pinned_comment_id'],
    'albumBacklink': !exists$2(json, 'album_backlink') ? undefined : AlbumBacklinkFromJSON$1(json['album_backlink'])
  };
}
function TrackToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'artwork': TrackArtworkToJSON(value.artwork),
    'description': value.description,
    'genre': value.genre,
    'id': value.id,
    'track_cid': value.trackCid,
    'preview_cid': value.previewCid,
    'orig_file_cid': value.origFileCid,
    'orig_filename': value.origFilename,
    'is_original_available': value.isOriginalAvailable,
    'mood': value.mood,
    'release_date': value.releaseDate,
    'isrc': value.isrc,
    'remix_of': RemixParentToJSON(value.remixOf),
    'repost_count': value.repostCount,
    'favorite_count': value.favoriteCount,
    'comment_count': value.commentCount,
    'tags': value.tags,
    'title': value.title,
    'user': UserToJSON(value.user),
    'duration': value.duration,
    'is_downloadable': value.isDownloadable,
    'play_count': value.playCount,
    'permalink': value.permalink,
    'is_streamable': value.isStreamable,
    'ddex_app': value.ddexApp,
    'playlists_containing_track': value.playlistsContainingTrack,
    'pinned_comment_id': value.pinnedCommentId,
    'album_backlink': AlbumBacklinkToJSON$1(value.albumBacklink)
  };
}

/* tslint:disable */
/**
 * @export
 */
const TrackActivityItemTypeEnum = {
  Track: 'track'
};
/**
 * Check if a given object implements the TrackActivity interface.
 */
function instanceOfTrackActivity(value) {
  let isInstance = true;
  isInstance = isInstance && "itemType" in value && value["itemType"] !== undefined;
  isInstance = isInstance && "item" in value && value["item"] !== undefined;
  return isInstance;
}
function TrackActivityFromJSON(json) {
  return TrackActivityFromJSONTyped(json, false);
}
function TrackActivityFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    ...ActivityFromJSONTyped(json, ignoreDiscriminator),
    'itemType': json['item_type'],
    'item': TrackFromJSON(json['item'])
  };
}
function TrackActivityToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    ...ActivityToJSON(value),
    'item_type': value.itemType,
    'item': TrackToJSON(value.item)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the HistoryResponse interface.
 */
function instanceOfHistoryResponse(value) {
  let isInstance = true;
  return isInstance;
}
function HistoryResponseFromJSON(json) {
  return HistoryResponseFromJSONTyped(json);
}
function HistoryResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'data': !exists$2(json, 'data') ? undefined : json['data'].map(TrackActivityFromJSON)
  };
}
function HistoryResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'data': value.data === undefined ? undefined : value.data.map(TrackActivityToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the ListenCount interface.
 */
function instanceOfListenCount(value) {
  let isInstance = true;
  return isInstance;
}
function ListenCountFromJSON(json) {
  return ListenCountFromJSONTyped(json);
}
function ListenCountFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'trackId': !exists$2(json, 'trackId') ? undefined : json['trackId'],
    'date': !exists$2(json, 'date') ? undefined : json['date'],
    'listens': !exists$2(json, 'listens') ? undefined : json['listens']
  };
}
function ListenCountToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'trackId': value.trackId,
    'date': value.date,
    'listens': value.listens
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the MonthlyAggregatePlay interface.
 */
function instanceOfMonthlyAggregatePlay(value) {
  let isInstance = true;
  return isInstance;
}
function MonthlyAggregatePlayFromJSON(json) {
  return MonthlyAggregatePlayFromJSONTyped(json);
}
function MonthlyAggregatePlayFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'totalListens': !exists$2(json, 'totalListens') ? undefined : json['totalListens'],
    'trackIds': !exists$2(json, 'trackIds') ? undefined : json['trackIds'],
    'listenCounts': !exists$2(json, 'listenCounts') ? undefined : json['listenCounts'].map(ListenCountFromJSON)
  };
}
function MonthlyAggregatePlayToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'totalListens': value.totalListens,
    'trackIds': value.trackIds,
    'listenCounts': value.listenCounts === undefined ? undefined : value.listenCounts.map(ListenCountToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the MutualFollowersResponse interface.
 */
function instanceOfMutualFollowersResponse(value) {
  let isInstance = true;
  return isInstance;
}
function MutualFollowersResponseFromJSON(json) {
  return MutualFollowersResponseFromJSONTyped(json);
}
function MutualFollowersResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'data': !exists$2(json, 'data') ? undefined : json['data'].map(UserFromJSON)
  };
}
function MutualFollowersResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'data': value.data === undefined ? undefined : value.data.map(UserToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the PlaylistResponse interface.
 */
function instanceOfPlaylistResponse(value) {
  let isInstance = true;
  return isInstance;
}
function PlaylistResponseFromJSON(json) {
  return PlaylistResponseFromJSONTyped(json);
}
function PlaylistResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'data': !exists$2(json, 'data') ? undefined : json['data'].map(PlaylistFromJSON)
  };
}
function PlaylistResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'data': value.data === undefined ? undefined : value.data.map(PlaylistToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the PlaylistSearchResult interface.
 */
function instanceOfPlaylistSearchResult(value) {
  let isInstance = true;
  return isInstance;
}
function PlaylistSearchResultFromJSON(json) {
  return PlaylistSearchResultFromJSONTyped(json);
}
function PlaylistSearchResultFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'data': !exists$2(json, 'data') ? undefined : json['data'].map(PlaylistFromJSON)
  };
}
function PlaylistSearchResultToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'data': value.data === undefined ? undefined : value.data.map(PlaylistToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the PlaylistTracksResponse interface.
 */
function instanceOfPlaylistTracksResponse(value) {
  let isInstance = true;
  return isInstance;
}
function PlaylistTracksResponseFromJSON(json) {
  return PlaylistTracksResponseFromJSONTyped(json);
}
function PlaylistTracksResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'data': !exists$2(json, 'data') ? undefined : json['data'].map(TrackFromJSON)
  };
}
function PlaylistTracksResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'data': value.data === undefined ? undefined : value.data.map(TrackToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the PlaylistsResponse interface.
 */
function instanceOfPlaylistsResponse(value) {
  let isInstance = true;
  return isInstance;
}
function PlaylistsResponseFromJSON(json) {
  return PlaylistsResponseFromJSONTyped(json);
}
function PlaylistsResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'data': !exists$2(json, 'data') ? undefined : json['data'].map(PlaylistFromJSON)
  };
}
function PlaylistsResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'data': value.data === undefined ? undefined : value.data.map(PlaylistToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the PurchasersResponse interface.
 */
function instanceOfPurchasersResponse(value) {
  let isInstance = true;
  return isInstance;
}
function PurchasersResponseFromJSON(json) {
  return PurchasersResponseFromJSONTyped(json);
}
function PurchasersResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'data': !exists$2(json, 'data') ? undefined : json['data'].map(UserFromJSON)
  };
}
function PurchasersResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'data': value.data === undefined ? undefined : value.data.map(UserToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the RelatedArtistResponse interface.
 */
function instanceOfRelatedArtistResponse(value) {
  let isInstance = true;
  return isInstance;
}
function RelatedArtistResponseFromJSON(json) {
  return RelatedArtistResponseFromJSONTyped(json);
}
function RelatedArtistResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'data': !exists$2(json, 'data') ? undefined : json['data'].map(UserFromJSON)
  };
}
function RelatedArtistResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'data': value.data === undefined ? undefined : value.data.map(UserToJSON)
  };
}

/* tslint:disable */
/* eslint-disable */
// @ts-nocheck
/**
 * API
 * Audius V1 API
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * Check if a given object implements the RemixedTrackAggregate interface.
 */
function instanceOfRemixedTrackAggregate(value) {
  let isInstance = true;
  isInstance = isInstance && "trackId" in value && value["trackId"] !== undefined;
  isInstance = isInstance && "title" in value && value["title"] !== undefined;
  isInstance = isInstance && "remixCount" in value && value["remixCount"] !== undefined;
  return isInstance;
}
function RemixedTrackAggregateFromJSON(json) {
  return RemixedTrackAggregateFromJSONTyped(json);
}
function RemixedTrackAggregateFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'trackId': json['track_id'],
    'title': json['title'],
    'remixCount': json['remix_count']
  };
}
function RemixedTrackAggregateToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'track_id': value.trackId,
    'title': value.title,
    'remix_count': value.remixCount
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the RemixersResponse interface.
 */
function instanceOfRemixersResponse(value) {
  let isInstance = true;
  return isInstance;
}
function RemixersResponseFromJSON(json) {
  return RemixersResponseFromJSONTyped(json);
}
function RemixersResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'data': !exists$2(json, 'data') ? undefined : json['data'].map(UserFromJSON)
  };
}
function RemixersResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'data': value.data === undefined ? undefined : value.data.map(UserToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the Reposts interface.
 */
function instanceOfReposts(value) {
  let isInstance = true;
  return isInstance;
}
function RepostsFromJSON(json) {
  return RepostsFromJSONTyped(json);
}
function RepostsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'data': !exists$2(json, 'data') ? undefined : json['data'].map(ActivityFromJSON)
  };
}
function RepostsToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'data': value.data === undefined ? undefined : value.data.map(ActivityToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the SaleJson interface.
 */
function instanceOfSaleJson(value) {
  let isInstance = true;
  return isInstance;
}
function SaleJsonFromJSON(json) {
  return SaleJsonFromJSONTyped(json);
}
function SaleJsonFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'title': !exists$2(json, 'title') ? undefined : json['title'],
    'link': !exists$2(json, 'link') ? undefined : json['link'],
    'purchasedBy': !exists$2(json, 'purchased_by') ? undefined : json['purchased_by'],
    'buyerUserId': !exists$2(json, 'buyer_user_id') ? undefined : json['buyer_user_id'],
    'date': !exists$2(json, 'date') ? undefined : json['date'],
    'salePrice': !exists$2(json, 'sale_price') ? undefined : json['sale_price'],
    'networkFee': !exists$2(json, 'network_fee') ? undefined : json['network_fee'],
    'payExtra': !exists$2(json, 'pay_extra') ? undefined : json['pay_extra'],
    'total': !exists$2(json, 'total') ? undefined : json['total'],
    'country': !exists$2(json, 'country') ? undefined : json['country'],
    'encryptedEmail': !exists$2(json, 'encrypted_email') ? undefined : json['encrypted_email'],
    'encryptedKey': !exists$2(json, 'encrypted_key') ? undefined : json['encrypted_key'],
    'isInitial': !exists$2(json, 'is_initial') ? undefined : json['is_initial'],
    'pubkeyBase64': !exists$2(json, 'pubkey_base64') ? undefined : json['pubkey_base64']
  };
}
function SaleJsonToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'title': value.title,
    'link': value.link,
    'purchased_by': value.purchasedBy,
    'buyer_user_id': value.buyerUserId,
    'date': value.date,
    'sale_price': value.salePrice,
    'network_fee': value.networkFee,
    'pay_extra': value.payExtra,
    'total': value.total,
    'country': value.country,
    'encrypted_email': value.encryptedEmail,
    'encrypted_key': value.encryptedKey,
    'is_initial': value.isInitial,
    'pubkey_base64': value.pubkeyBase64
  };
}

/* tslint:disable */
/* eslint-disable */
// @ts-nocheck
/**
 * API
 * Audius V1 API
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * Check if a given object implements the SalesAggregate interface.
 */
function instanceOfSalesAggregate(value) {
  let isInstance = true;
  isInstance = isInstance && "contentType" in value && value["contentType"] !== undefined;
  isInstance = isInstance && "contentId" in value && value["contentId"] !== undefined;
  isInstance = isInstance && "purchaseCount" in value && value["purchaseCount"] !== undefined;
  return isInstance;
}
function SalesAggregateFromJSON(json) {
  return SalesAggregateFromJSONTyped(json);
}
function SalesAggregateFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'contentType': json['content_type'],
    'contentId': json['content_id'],
    'purchaseCount': json['purchase_count']
  };
}
function SalesAggregateToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'content_type': value.contentType,
    'content_id': value.contentId,
    'purchase_count': value.purchaseCount
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the SalesAggregateResponse interface.
 */
function instanceOfSalesAggregateResponse(value) {
  let isInstance = true;
  return isInstance;
}
function SalesAggregateResponseFromJSON(json) {
  return SalesAggregateResponseFromJSONTyped(json);
}
function SalesAggregateResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'data': !exists$2(json, 'data') ? undefined : json['data'].map(SalesAggregateFromJSON)
  };
}
function SalesAggregateResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'data': value.data === undefined ? undefined : value.data.map(SalesAggregateToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the SalesJsonContent interface.
 */
function instanceOfSalesJsonContent(value) {
  let isInstance = true;
  return isInstance;
}
function SalesJsonContentFromJSON(json) {
  return SalesJsonContentFromJSONTyped(json);
}
function SalesJsonContentFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'sales': !exists$2(json, 'sales') ? undefined : json['sales'].map(SaleJsonFromJSON)
  };
}
function SalesJsonContentToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'sales': value.sales === undefined ? undefined : value.sales.map(SaleJsonToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the SalesJsonResponse interface.
 */
function instanceOfSalesJsonResponse(value) {
  let isInstance = true;
  return isInstance;
}
function SalesJsonResponseFromJSON(json) {
  return SalesJsonResponseFromJSONTyped(json);
}
function SalesJsonResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'data': !exists$2(json, 'data') ? undefined : SalesJsonContentFromJSON(json['data'])
  };
}
function SalesJsonResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'data': SalesJsonContentToJSON(value.data)
  };
}

/* tslint:disable */
/* eslint-disable */
// @ts-nocheck
/**
 * API
 * Audius V1 API
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * Check if a given object implements the Stem interface.
 */
function instanceOfStem(value) {
  let isInstance = true;
  isInstance = isInstance && "id" in value && value["id"] !== undefined;
  isInstance = isInstance && "parentId" in value && value["parentId"] !== undefined;
  isInstance = isInstance && "category" in value && value["category"] !== undefined;
  isInstance = isInstance && "cid" in value && value["cid"] !== undefined;
  isInstance = isInstance && "userId" in value && value["userId"] !== undefined;
  isInstance = isInstance && "blocknumber" in value && value["blocknumber"] !== undefined;
  isInstance = isInstance && "origFilename" in value && value["origFilename"] !== undefined;
  return isInstance;
}
function StemFromJSON(json) {
  return StemFromJSONTyped(json);
}
function StemFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'id': json['id'],
    'parentId': json['parent_id'],
    'category': json['category'],
    'cid': json['cid'],
    'userId': json['user_id'],
    'blocknumber': json['blocknumber'],
    'origFilename': json['orig_filename']
  };
}
function StemToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'id': value.id,
    'parent_id': value.parentId,
    'category': value.category,
    'cid': value.cid,
    'user_id': value.userId,
    'blocknumber': value.blocknumber,
    'orig_filename': value.origFilename
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the StemsResponse interface.
 */
function instanceOfStemsResponse$1(value) {
  let isInstance = true;
  return isInstance;
}
function StemsResponseFromJSON$1(json) {
  return StemsResponseFromJSONTyped$1(json);
}
function StemsResponseFromJSONTyped$1(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'data': !exists$2(json, 'data') ? undefined : json['data'].map(StemFromJSON)
  };
}
function StemsResponseToJSON$1(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'data': value.data === undefined ? undefined : value.data.map(StemToJSON)
  };
}

/* tslint:disable */
/* eslint-disable */
// @ts-nocheck
/**
 * API
 * Audius V1 API
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * Check if a given object implements the StreamUrlResponse interface.
 */
function instanceOfStreamUrlResponse(value) {
  let isInstance = true;
  isInstance = isInstance && "data" in value && value["data"] !== undefined;
  return isInstance;
}
function StreamUrlResponseFromJSON(json) {
  return StreamUrlResponseFromJSONTyped(json);
}
function StreamUrlResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'data': json['data']
  };
}
function StreamUrlResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'data': value.data
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the SubscribersResponse interface.
 */
function instanceOfSubscribersResponse(value) {
  let isInstance = true;
  return isInstance;
}
function SubscribersResponseFromJSON(json) {
  return SubscribersResponseFromJSONTyped(json);
}
function SubscribersResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'data': !exists$2(json, 'data') ? undefined : json['data'].map(UserFromJSON)
  };
}
function SubscribersResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'data': value.data === undefined ? undefined : value.data.map(UserToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the TagsResponse interface.
 */
function instanceOfTagsResponse(value) {
  let isInstance = true;
  return isInstance;
}
function TagsResponseFromJSON(json) {
  return TagsResponseFromJSONTyped(json);
}
function TagsResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'data': !exists$2(json, 'data') ? undefined : json['data']
  };
}
function TagsResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'data': value.data
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the TopListener interface.
 */
function instanceOfTopListener(value) {
  let isInstance = true;
  return isInstance;
}
function TopListenerFromJSON(json) {
  return TopListenerFromJSONTyped(json);
}
function TopListenerFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'data': !exists$2(json, 'data') ? undefined : json['data'].map(TopListenerFromJSON)
  };
}
function TopListenerToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'data': value.data === undefined ? undefined : value.data.map(TopListenerToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the TrackCommentCountResponse interface.
 */
function instanceOfTrackCommentCountResponse(value) {
  let isInstance = true;
  return isInstance;
}
function TrackCommentCountResponseFromJSON(json) {
  return TrackCommentCountResponseFromJSONTyped(json);
}
function TrackCommentCountResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'data': !exists$2(json, 'data') ? undefined : json['data']
  };
}
function TrackCommentCountResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'data': value.data
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the TrackCommentNotificationResponse interface.
 */
function instanceOfTrackCommentNotificationResponse(value) {
  let isInstance = true;
  return isInstance;
}
function TrackCommentNotificationResponseFromJSON(json) {
  return TrackCommentNotificationResponseFromJSONTyped(json);
}
function TrackCommentNotificationResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'data': !exists$2(json, 'data') ? undefined : CommentNotificationSettingFromJSON(json['data'])
  };
}
function TrackCommentNotificationResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'data': CommentNotificationSettingToJSON(value.data)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the TrackCommentsResponse interface.
 */
function instanceOfTrackCommentsResponse(value) {
  let isInstance = true;
  return isInstance;
}
function TrackCommentsResponseFromJSON(json) {
  return TrackCommentsResponseFromJSONTyped(json);
}
function TrackCommentsResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'data': !exists$2(json, 'data') ? undefined : json['data'].map(CommentFromJSON$1)
  };
}
function TrackCommentsResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'data': value.data === undefined ? undefined : value.data.map(CommentToJSON$1)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the TrackInspect interface.
 */
function instanceOfTrackInspect(value) {
  let isInstance = true;
  return isInstance;
}
function TrackInspectFromJSON(json) {
  return TrackInspectFromJSONTyped(json);
}
function TrackInspectFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'data': !exists$2(json, 'data') ? undefined : BlobInfoFromJSON(json['data'])
  };
}
function TrackInspectToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'data': BlobInfoToJSON(value.data)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the TrackInspectList interface.
 */
function instanceOfTrackInspectList(value) {
  let isInstance = true;
  return isInstance;
}
function TrackInspectListFromJSON(json) {
  return TrackInspectListFromJSONTyped(json);
}
function TrackInspectListFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'data': !exists$2(json, 'data') ? undefined : json['data'].map(BlobInfoFromJSON)
  };
}
function TrackInspectListToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'data': value.data === undefined ? undefined : value.data.map(BlobInfoToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the TrackResponse interface.
 */
function instanceOfTrackResponse(value) {
  let isInstance = true;
  return isInstance;
}
function TrackResponseFromJSON(json) {
  return TrackResponseFromJSONTyped(json);
}
function TrackResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'data': !exists$2(json, 'data') ? undefined : TrackFromJSON(json['data'])
  };
}
function TrackResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'data': TrackToJSON(value.data)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the TrackSearch interface.
 */
function instanceOfTrackSearch(value) {
  let isInstance = true;
  return isInstance;
}
function TrackSearchFromJSON(json) {
  return TrackSearchFromJSONTyped(json);
}
function TrackSearchFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'data': !exists$2(json, 'data') ? undefined : json['data'].map(TrackFromJSON)
  };
}
function TrackSearchToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'data': value.data === undefined ? undefined : value.data.map(TrackToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the TracksResponse interface.
 */
function instanceOfTracksResponse(value) {
  let isInstance = true;
  return isInstance;
}
function TracksResponseFromJSON(json) {
  return TracksResponseFromJSONTyped(json);
}
function TracksResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'data': !exists$2(json, 'data') ? undefined : json['data'].map(TrackFromJSON)
  };
}
function TracksResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'data': value.data === undefined ? undefined : value.data.map(TrackToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the TrendingPlaylistsResponse interface.
 */
function instanceOfTrendingPlaylistsResponse(value) {
  let isInstance = true;
  return isInstance;
}
function TrendingPlaylistsResponseFromJSON(json) {
  return TrendingPlaylistsResponseFromJSONTyped(json);
}
function TrendingPlaylistsResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'data': !exists$2(json, 'data') ? undefined : json['data'].map(PlaylistFromJSON)
  };
}
function TrendingPlaylistsResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'data': value.data === undefined ? undefined : value.data.map(PlaylistToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the UnclaimedIdResponse interface.
 */
function instanceOfUnclaimedIdResponse(value) {
  let isInstance = true;
  return isInstance;
}
function UnclaimedIdResponseFromJSON(json) {
  return UnclaimedIdResponseFromJSONTyped(json);
}
function UnclaimedIdResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'data': !exists$2(json, 'data') ? undefined : json['data']
  };
}
function UnclaimedIdResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'data': value.data
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the UndisbursedChallenge interface.
 */
function instanceOfUndisbursedChallenge(value) {
  let isInstance = true;
  isInstance = isInstance && "challengeId" in value && value["challengeId"] !== undefined;
  isInstance = isInstance && "userId" in value && value["userId"] !== undefined;
  isInstance = isInstance && "specifier" in value && value["specifier"] !== undefined;
  isInstance = isInstance && "amount" in value && value["amount"] !== undefined;
  isInstance = isInstance && "completedBlocknumber" in value && value["completedBlocknumber"] !== undefined;
  isInstance = isInstance && "handle" in value && value["handle"] !== undefined;
  isInstance = isInstance && "wallet" in value && value["wallet"] !== undefined;
  isInstance = isInstance && "createdAt" in value && value["createdAt"] !== undefined;
  isInstance = isInstance && "completedAt" in value && value["completedAt"] !== undefined;
  return isInstance;
}
function UndisbursedChallengeFromJSON(json) {
  return UndisbursedChallengeFromJSONTyped(json);
}
function UndisbursedChallengeFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'challengeId': json['challenge_id'],
    'userId': json['user_id'],
    'specifier': json['specifier'],
    'amount': json['amount'],
    'completedBlocknumber': json['completed_blocknumber'],
    'handle': json['handle'],
    'wallet': json['wallet'],
    'createdAt': json['created_at'],
    'completedAt': json['completed_at'],
    'cooldownDays': !exists$2(json, 'cooldown_days') ? undefined : json['cooldown_days']
  };
}
function UndisbursedChallengeToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'challenge_id': value.challengeId,
    'user_id': value.userId,
    'specifier': value.specifier,
    'amount': value.amount,
    'completed_blocknumber': value.completedBlocknumber,
    'handle': value.handle,
    'wallet': value.wallet,
    'created_at': value.createdAt,
    'completed_at': value.completedAt,
    'cooldown_days': value.cooldownDays
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the UndisbursedChallenges interface.
 */
function instanceOfUndisbursedChallenges(value) {
  let isInstance = true;
  return isInstance;
}
function UndisbursedChallengesFromJSON(json) {
  return UndisbursedChallengesFromJSONTyped(json);
}
function UndisbursedChallengesFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'data': !exists$2(json, 'data') ? undefined : json['data'].map(UndisbursedChallengeFromJSON)
  };
}
function UndisbursedChallengesToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'data': value.data === undefined ? undefined : value.data.map(UndisbursedChallengeToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the UpdateCoinRequest interface.
 */
function instanceOfUpdateCoinRequest$1(value) {
  let isInstance = true;
  return isInstance;
}
function UpdateCoinRequestFromJSON$1(json) {
  return UpdateCoinRequestFromJSONTyped$1(json);
}
function UpdateCoinRequestFromJSONTyped$1(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'description': !exists$2(json, 'description') ? undefined : json['description'],
    'link1': !exists$2(json, 'link_1') ? undefined : json['link_1'],
    'link2': !exists$2(json, 'link_2') ? undefined : json['link_2'],
    'link3': !exists$2(json, 'link_3') ? undefined : json['link_3'],
    'link4': !exists$2(json, 'link_4') ? undefined : json['link_4']
  };
}
function UpdateCoinRequestToJSON$1(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'description': value.description,
    'link_1': value.link1,
    'link_2': value.link2,
    'link_3': value.link3,
    'link_4': value.link4
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the UpdateCoinResponse interface.
 */
function instanceOfUpdateCoinResponse$1(value) {
  let isInstance = true;
  return isInstance;
}
function UpdateCoinResponseFromJSON$1(json) {
  return UpdateCoinResponseFromJSONTyped$1(json);
}
function UpdateCoinResponseFromJSONTyped$1(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'success': !exists$2(json, 'success') ? undefined : json['success']
  };
}
function UpdateCoinResponseToJSON$1(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'success': value.success
  };
}

/* tslint:disable */
/* eslint-disable */
// @ts-nocheck
/**
 * API
 * Audius V1 API
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * Check if a given object implements the UserCoin interface.
 */
function instanceOfUserCoin(value) {
  let isInstance = true;
  isInstance = isInstance && "mint" in value && value["mint"] !== undefined;
  isInstance = isInstance && "ticker" in value && value["ticker"] !== undefined;
  isInstance = isInstance && "decimals" in value && value["decimals"] !== undefined;
  isInstance = isInstance && "ownerId" in value && value["ownerId"] !== undefined;
  isInstance = isInstance && "hasDiscord" in value && value["hasDiscord"] !== undefined;
  isInstance = isInstance && "balance" in value && value["balance"] !== undefined;
  isInstance = isInstance && "balanceUsd" in value && value["balanceUsd"] !== undefined;
  return isInstance;
}
function UserCoinFromJSON(json) {
  return UserCoinFromJSONTyped(json);
}
function UserCoinFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'mint': json['mint'],
    'ticker': json['ticker'],
    'decimals': json['decimals'],
    'ownerId': json['owner_id'],
    'hasDiscord': json['has_discord'],
    'balance': json['balance'],
    'balanceUsd': json['balance_usd']
  };
}
function UserCoinToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'mint': value.mint,
    'ticker': value.ticker,
    'decimals': value.decimals,
    'owner_id': value.ownerId,
    'has_discord': value.hasDiscord,
    'balance': value.balance,
    'balance_usd': value.balanceUsd
  };
}

/* tslint:disable */
/* eslint-disable */
// @ts-nocheck
/**
 * API
 * Audius V1 API
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * Check if a given object implements the UserCoinAccount interface.
 */
function instanceOfUserCoinAccount(value) {
  let isInstance = true;
  isInstance = isInstance && "account" in value && value["account"] !== undefined;
  isInstance = isInstance && "owner" in value && value["owner"] !== undefined;
  isInstance = isInstance && "balance" in value && value["balance"] !== undefined;
  isInstance = isInstance && "balanceUsd" in value && value["balanceUsd"] !== undefined;
  isInstance = isInstance && "isInAppWallet" in value && value["isInAppWallet"] !== undefined;
  return isInstance;
}
function UserCoinAccountFromJSON(json) {
  return UserCoinAccountFromJSONTyped(json);
}
function UserCoinAccountFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'account': json['account'],
    'owner': json['owner'],
    'balance': json['balance'],
    'balanceUsd': json['balance_usd'],
    'isInAppWallet': json['is_in_app_wallet']
  };
}
function UserCoinAccountToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'account': value.account,
    'owner': value.owner,
    'balance': value.balance,
    'balance_usd': value.balanceUsd,
    'is_in_app_wallet': value.isInAppWallet
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the UserCoinWithAccounts interface.
 */
function instanceOfUserCoinWithAccounts(value) {
  let isInstance = true;
  isInstance = isInstance && "mint" in value && value["mint"] !== undefined;
  isInstance = isInstance && "ticker" in value && value["ticker"] !== undefined;
  isInstance = isInstance && "decimals" in value && value["decimals"] !== undefined;
  isInstance = isInstance && "balance" in value && value["balance"] !== undefined;
  isInstance = isInstance && "balanceUsd" in value && value["balanceUsd"] !== undefined;
  isInstance = isInstance && "accounts" in value && value["accounts"] !== undefined;
  return isInstance;
}
function UserCoinWithAccountsFromJSON(json) {
  return UserCoinWithAccountsFromJSONTyped(json);
}
function UserCoinWithAccountsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'mint': json['mint'],
    'ticker': json['ticker'],
    'decimals': json['decimals'],
    'balance': json['balance'],
    'balanceUsd': json['balance_usd'],
    'accounts': json['accounts'].map(UserCoinAccountFromJSON)
  };
}
function UserCoinWithAccountsToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'mint': value.mint,
    'ticker': value.ticker,
    'decimals': value.decimals,
    'balance': value.balance,
    'balance_usd': value.balanceUsd,
    'accounts': value.accounts.map(UserCoinAccountToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the UserCoinResponse interface.
 */
function instanceOfUserCoinResponse(value) {
  let isInstance = true;
  return isInstance;
}
function UserCoinResponseFromJSON(json) {
  return UserCoinResponseFromJSONTyped(json);
}
function UserCoinResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'data': !exists$2(json, 'data') ? undefined : UserCoinWithAccountsFromJSON(json['data'])
  };
}
function UserCoinResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'data': UserCoinWithAccountsToJSON(value.data)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the UserCoinsResponse interface.
 */
function instanceOfUserCoinsResponse(value) {
  let isInstance = true;
  isInstance = isInstance && "data" in value && value["data"] !== undefined;
  return isInstance;
}
function UserCoinsResponseFromJSON(json) {
  return UserCoinsResponseFromJSONTyped(json);
}
function UserCoinsResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'data': json['data'].map(UserCoinFromJSON)
  };
}
function UserCoinsResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'data': value.data.map(UserCoinToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the UserCommentsResponse interface.
 */
function instanceOfUserCommentsResponse(value) {
  let isInstance = true;
  return isInstance;
}
function UserCommentsResponseFromJSON(json) {
  return UserCommentsResponseFromJSONTyped(json);
}
function UserCommentsResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'data': !exists$2(json, 'data') ? undefined : json['data'].map(CommentFromJSON$1)
  };
}
function UserCommentsResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'data': value.data === undefined ? undefined : value.data.map(CommentToJSON$1)
  };
}

/* tslint:disable */
/* eslint-disable */
// @ts-nocheck
/**
 * API
 * Audius V1 API
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * Check if a given object implements the UserIdAddress interface.
 */
function instanceOfUserIdAddress(value) {
  let isInstance = true;
  isInstance = isInstance && "userId" in value && value["userId"] !== undefined;
  isInstance = isInstance && "address" in value && value["address"] !== undefined;
  return isInstance;
}
function UserIdAddressFromJSON(json) {
  return UserIdAddressFromJSONTyped(json);
}
function UserIdAddressFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'userId': json['user_id'],
    'address': json['address']
  };
}
function UserIdAddressToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'user_id': value.userId,
    'address': value.address
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the UserIdsAddressesResponse interface.
 */
function instanceOfUserIdsAddressesResponse(value) {
  let isInstance = true;
  return isInstance;
}
function UserIdsAddressesResponseFromJSON(json) {
  return UserIdsAddressesResponseFromJSONTyped(json);
}
function UserIdsAddressesResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'data': !exists$2(json, 'data') ? undefined : json['data'].map(UserIdAddressFromJSON)
  };
}
function UserIdsAddressesResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'data': value.data === undefined ? undefined : value.data.map(UserIdAddressToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the UserResponse interface.
 */
function instanceOfUserResponse(value) {
  let isInstance = true;
  return isInstance;
}
function UserResponseFromJSON(json) {
  return UserResponseFromJSONTyped(json);
}
function UserResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'data': !exists$2(json, 'data') ? undefined : UserFromJSON(json['data'])
  };
}
function UserResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'data': UserToJSON(value.data)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the UserSearch interface.
 */
function instanceOfUserSearch(value) {
  let isInstance = true;
  return isInstance;
}
function UserSearchFromJSON(json) {
  return UserSearchFromJSONTyped(json);
}
function UserSearchFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'data': !exists$2(json, 'data') ? undefined : json['data'].map(UserFromJSON)
  };
}
function UserSearchToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'data': value.data === undefined ? undefined : value.data.map(UserToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the UserTrackListenCountsResponse interface.
 */
function instanceOfUserTrackListenCountsResponse(value) {
  let isInstance = true;
  return isInstance;
}
function UserTrackListenCountsResponseFromJSON(json) {
  return UserTrackListenCountsResponseFromJSONTyped(json);
}
function UserTrackListenCountsResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'data': !exists$2(json, 'data') ? undefined : mapValues$1(json['data'], MonthlyAggregatePlayFromJSON)
  };
}
function UserTrackListenCountsResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'data': value.data === undefined ? undefined : mapValues$1(value.data, MonthlyAggregatePlayToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the UserTracksRemixedResponse interface.
 */
function instanceOfUserTracksRemixedResponse(value) {
  let isInstance = true;
  return isInstance;
}
function UserTracksRemixedResponseFromJSON(json) {
  return UserTracksRemixedResponseFromJSONTyped(json);
}
function UserTracksRemixedResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'data': !exists$2(json, 'data') ? undefined : json['data'].map(RemixedTrackAggregateFromJSON)
  };
}
function UserTracksRemixedResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'data': value.data === undefined ? undefined : value.data.map(RemixedTrackAggregateToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the UsersResponse interface.
 */
function instanceOfUsersResponse(value) {
  let isInstance = true;
  return isInstance;
}
function UsersResponseFromJSON(json) {
  return UsersResponseFromJSONTyped(json);
}
function UsersResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'data': !exists$2(json, 'data') ? undefined : json['data'].map(UserFromJSON)
  };
}
function UsersResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'data': value.data === undefined ? undefined : value.data.map(UserToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the VerifyToken interface.
 */
function instanceOfVerifyToken(value) {
  let isInstance = true;
  return isInstance;
}
function VerifyTokenFromJSON(json) {
  return VerifyTokenFromJSONTyped(json);
}
function VerifyTokenFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'data': !exists$2(json, 'data') ? undefined : DecodedUserTokenFromJSON(json['data'])
  };
}
function VerifyTokenToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'data': DecodedUserTokenToJSON(value.data)
  };
}

/* tslint:disable */
/**
 *
 */
class ChallengesApi$1 extends BaseAPI$1 {
  /**
   * @hidden
   * Get all undisbursed challenges
   */
  async getUndisbursedChallengesRaw(params, initOverrides) {
    const queryParameters = {};
    if (params.offset !== undefined) {
      queryParameters['offset'] = params.offset;
    }
    if (params.limit !== undefined) {
      queryParameters['limit'] = params.limit;
    }
    if (params.userId !== undefined) {
      queryParameters['user_id'] = params.userId;
    }
    if (params.completedBlocknumber !== undefined) {
      queryParameters['completed_blocknumber'] = params.completedBlocknumber;
    }
    if (params.challengeId !== undefined) {
      queryParameters['challenge_id'] = params.challengeId;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/challenges/undisbursed`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, jsonValue => UndisbursedChallengesFromJSON(jsonValue));
  }
  /**
   * Get all undisbursed challenges
   */
  async getUndisbursedChallenges() {
    let params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let initOverrides = arguments.length > 1 ? arguments[1] : undefined;
    const response = await this.getUndisbursedChallengesRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Get all undisbursed challenges for a user
   */
  async getUndisbursedChallengesForUserRaw(params, initOverrides) {
    if (params.userId === null || params.userId === undefined) {
      throw new RequiredError$1('userId', 'Required parameter params.userId was null or undefined when calling getUndisbursedChallengesForUser.');
    }
    const queryParameters = {};
    if (params.offset !== undefined) {
      queryParameters['offset'] = params.offset;
    }
    if (params.limit !== undefined) {
      queryParameters['limit'] = params.limit;
    }
    if (params.completedBlocknumber !== undefined) {
      queryParameters['completed_blocknumber'] = params.completedBlocknumber;
    }
    if (params.challengeId !== undefined) {
      queryParameters['challenge_id'] = params.challengeId;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/challenges/undisbursed/{user_id}`.replace(`{${"user_id"}}`, encodeURIComponent(String(params.userId))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, jsonValue => UndisbursedChallengesFromJSON(jsonValue));
  }
  /**
   * Get all undisbursed challenges for a user
   */
  async getUndisbursedChallengesForUser(params, initOverrides) {
    const response = await this.getUndisbursedChallengesForUserRaw(params, initOverrides);
    return await response.value();
  }
}

/* tslint:disable */
/**
 *
 */
class CoinsApi$1 extends BaseAPI$1 {
  /**
   * @hidden
   * Creates a new artist coin
   */
  async createCoinRaw(params, initOverrides) {
    if (params.userId === null || params.userId === undefined) {
      throw new RequiredError$1('userId', 'Required parameter params.userId was null or undefined when calling createCoin.');
    }
    if (params.createCoinRequest === null || params.createCoinRequest === undefined) {
      throw new RequiredError$1('createCoinRequest', 'Required parameter params.createCoinRequest was null or undefined when calling createCoin.');
    }
    const queryParameters = {};
    if (params.userId !== undefined) {
      queryParameters['user_id'] = params.userId;
    }
    const headerParameters = {};
    headerParameters['Content-Type'] = 'application/json';
    const response = await this.request({
      path: `/coins`,
      method: 'POST',
      headers: headerParameters,
      query: queryParameters,
      body: CreateCoinRequestToJSON$1(params.createCoinRequest)
    }, initOverrides);
    return new JSONApiResponse$1(response, jsonValue => CreateCoinResponseFromJSON$1(jsonValue));
  }
  /**
   * Creates a new artist coin
   */
  async createCoin(params, initOverrides) {
    const response = await this.createCoinRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets information about a specific coin by its mint address
   */
  async getCoinRaw(params, initOverrides) {
    if (params.mint === null || params.mint === undefined) {
      throw new RequiredError$1('mint', 'Required parameter params.mint was null or undefined when calling getCoin.');
    }
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/coins/{mint}`.replace(`{${"mint"}}`, encodeURIComponent(String(params.mint))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, jsonValue => CoinResponseFromJSON$1(jsonValue));
  }
  /**
   * Gets information about a specific coin by its mint address
   */
  async getCoin(params, initOverrides) {
    const response = await this.getCoinRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets information about a specific coin by its ticker
   */
  async getCoinByTickerRaw(params, initOverrides) {
    if (params.ticker === null || params.ticker === undefined) {
      throw new RequiredError$1('ticker', 'Required parameter params.ticker was null or undefined when calling getCoinByTicker.');
    }
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/coins/ticker/{ticker}`.replace(`{${"ticker"}}`, encodeURIComponent(String(params.ticker))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, jsonValue => CoinResponseFromJSON$1(jsonValue));
  }
  /**
   * Gets information about a specific coin by its ticker
   */
  async getCoinByTicker(params, initOverrides) {
    const response = await this.getCoinByTickerRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets insights about a specific coin by its mint address
   */
  async getCoinInsightsRaw(params, initOverrides) {
    if (params.mint === null || params.mint === undefined) {
      throw new RequiredError$1('mint', 'Required parameter params.mint was null or undefined when calling getCoinInsights.');
    }
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/coins/{mint}/insights`.replace(`{${"mint"}}`, encodeURIComponent(String(params.mint))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, jsonValue => CoinInsightsResponseFromJSON(jsonValue));
  }
  /**
   * Gets insights about a specific coin by its mint address
   */
  async getCoinInsights(params, initOverrides) {
    const response = await this.getCoinInsightsRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets a list of Audius users with a non-zero balance of a specific coin
   */
  async getCoinMembersRaw(params, initOverrides) {
    if (params.mint === null || params.mint === undefined) {
      throw new RequiredError$1('mint', 'Required parameter params.mint was null or undefined when calling getCoinMembers.');
    }
    const queryParameters = {};
    if (params.offset !== undefined) {
      queryParameters['offset'] = params.offset;
    }
    if (params.limit !== undefined) {
      queryParameters['limit'] = params.limit;
    }
    if (params.sortDirection !== undefined) {
      queryParameters['sort_direction'] = params.sortDirection;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/coins/{mint}/members`.replace(`{${"mint"}}`, encodeURIComponent(String(params.mint))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, jsonValue => CoinMembersResponseFromJSON(jsonValue));
  }
  /**
   * Gets a list of Audius users with a non-zero balance of a specific coin
   */
  async getCoinMembers(params, initOverrides) {
    const response = await this.getCoinMembersRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets information about coins
   */
  async getCoinsRaw(params, initOverrides) {
    const queryParameters = {};
    if (params.mint) {
      queryParameters['mint'] = params.mint;
    }
    if (params.ownerId) {
      queryParameters['owner_id'] = params.ownerId;
    }
    if (params.ticker) {
      queryParameters['ticker'] = params.ticker;
    }
    if (params.query !== undefined) {
      queryParameters['query'] = params.query;
    }
    if (params.offset !== undefined) {
      queryParameters['offset'] = params.offset;
    }
    if (params.limit !== undefined) {
      queryParameters['limit'] = params.limit;
    }
    if (params.sortMethod !== undefined) {
      queryParameters['sort_method'] = params.sortMethod;
    }
    if (params.sortDirection !== undefined) {
      queryParameters['sort_direction'] = params.sortDirection;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/coins`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, jsonValue => CoinsResponseFromJSON$1(jsonValue));
  }
  /**
   * Gets information about coins
   */
  async getCoins() {
    let params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let initOverrides = arguments.length > 1 ? arguments[1] : undefined;
    const response = await this.getCoinsRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Updates information about a specific coin by its mint address
   */
  async updateCoinRaw(params, initOverrides) {
    if (params.mint === null || params.mint === undefined) {
      throw new RequiredError$1('mint', 'Required parameter params.mint was null or undefined when calling updateCoin.');
    }
    if (params.userId === null || params.userId === undefined) {
      throw new RequiredError$1('userId', 'Required parameter params.userId was null or undefined when calling updateCoin.');
    }
    if (params.updateCoinRequest === null || params.updateCoinRequest === undefined) {
      throw new RequiredError$1('updateCoinRequest', 'Required parameter params.updateCoinRequest was null or undefined when calling updateCoin.');
    }
    const queryParameters = {};
    if (params.userId !== undefined) {
      queryParameters['user_id'] = params.userId;
    }
    const headerParameters = {};
    headerParameters['Content-Type'] = 'application/json';
    const response = await this.request({
      path: `/coins/{mint}`.replace(`{${"mint"}}`, encodeURIComponent(String(params.mint))),
      method: 'POST',
      headers: headerParameters,
      query: queryParameters,
      body: UpdateCoinRequestToJSON$1(params.updateCoinRequest)
    }, initOverrides);
    return new JSONApiResponse$1(response, jsonValue => UpdateCoinResponseFromJSON$1(jsonValue));
  }
  /**
   * Updates information about a specific coin by its mint address
   */
  async updateCoin(params, initOverrides) {
    const response = await this.updateCoinRaw(params, initOverrides);
    return await response.value();
  }
}
/**
 * @export
 */
const GetCoinMembersSortDirectionEnum = {
  Asc: 'asc',
  Desc: 'desc'
};
/**
 * @export
 */
const GetCoinsSortMethodEnum$1 = {
  MarketCap: 'market_cap',
  Volume: 'volume',
  Price: 'price',
  CreatedAt: 'created_at',
  Holder: 'holder'
};
/**
 * @export
 */
const GetCoinsSortDirectionEnum$1 = {
  Asc: 'asc',
  Desc: 'desc'
};

/* tslint:disable */
/**
 *
 */
class CommentsApi$2 extends BaseAPI$1 {
  /**
   * @hidden
   * Gets a comment by ID
   */
  async getCommentRaw(params, initOverrides) {
    if (params.commentId === null || params.commentId === undefined) {
      throw new RequiredError$1('commentId', 'Required parameter params.commentId was null or undefined when calling getComment.');
    }
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/comments/{comment_id}`.replace(`{${"comment_id"}}`, encodeURIComponent(String(params.commentId))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, jsonValue => CommentResponseFromJSON$1(jsonValue));
  }
  /**
   * Gets a comment by ID
   */
  async getComment(params, initOverrides) {
    const response = await this.getCommentRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets replies to a parent comment
   */
  async getCommentRepliesRaw(params, initOverrides) {
    if (params.commentId === null || params.commentId === undefined) {
      throw new RequiredError$1('commentId', 'Required parameter params.commentId was null or undefined when calling getCommentReplies.');
    }
    const queryParameters = {};
    if (params.offset !== undefined) {
      queryParameters['offset'] = params.offset;
    }
    if (params.limit !== undefined) {
      queryParameters['limit'] = params.limit;
    }
    if (params.userId !== undefined) {
      queryParameters['user_id'] = params.userId;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/comments/{comment_id}/replies`.replace(`{${"comment_id"}}`, encodeURIComponent(String(params.commentId))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, jsonValue => CommentRepliesResponseFromJSON$1(jsonValue));
  }
  /**
   * Gets replies to a parent comment
   */
  async getCommentReplies(params, initOverrides) {
    const response = await this.getCommentRepliesRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets an unclaimed blockchain comment ID
   */
  async getUnclaimedCommentIDRaw(initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/comments/unclaimed_id`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, jsonValue => UnclaimedIdResponseFromJSON(jsonValue));
  }
  /**
   * Gets an unclaimed blockchain comment ID
   */
  async getUnclaimedCommentID(initOverrides) {
    const response = await this.getUnclaimedCommentIDRaw(initOverrides);
    return await response.value();
  }
}

/* tslint:disable */
/**
 *
 */
class DashboardWalletUsersApi$1 extends BaseAPI$1 {
  /**
   * @hidden
   * Gets Audius user profiles connected to given dashboard wallet addresses
   */
  async bulkGetDashboardWalletUsersRaw(params, initOverrides) {
    if (params.wallets === null || params.wallets === undefined) {
      throw new RequiredError$1('wallets', 'Required parameter params.wallets was null or undefined when calling bulkGetDashboardWalletUsers.');
    }
    const queryParameters = {};
    if (params.wallets) {
      queryParameters['wallets'] = params.wallets.join(COLLECTION_FORMATS$1["csv"]);
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/dashboard_wallet_users`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, jsonValue => DashboardWalletUsersResponseFromJSON(jsonValue));
  }
  /**
   * Gets Audius user profiles connected to given dashboard wallet addresses
   */
  async bulkGetDashboardWalletUsers(params, initOverrides) {
    const response = await this.bulkGetDashboardWalletUsersRaw(params, initOverrides);
    return await response.value();
  }
}

/* tslint:disable */
/**
 *
 */
class DeveloperAppsApi$1 extends BaseAPI$1 {
  /**
   * @hidden
   * Gets developer app matching given address (API key)
   */
  async getDeveloperAppRaw(params, initOverrides) {
    if (params.address === null || params.address === undefined) {
      throw new RequiredError$1('address', 'Required parameter params.address was null or undefined when calling getDeveloperApp.');
    }
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/developer_apps/{address}`.replace(`{${"address"}}`, encodeURIComponent(String(params.address))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, jsonValue => DeveloperAppResponseFromJSON(jsonValue));
  }
  /**
   * Gets developer app matching given address (API key)
   */
  async getDeveloperApp(params, initOverrides) {
    const response = await this.getDeveloperAppRaw(params, initOverrides);
    return await response.value();
  }
}

/* tslint:disable */
/**
 *
 */
class EventsApi$1 extends BaseAPI$1 {
  /**
   * @hidden
   * Get all events
   * Get all events
   */
  async getAllEventsRaw(params, initOverrides) {
    const queryParameters = {};
    if (params.offset !== undefined) {
      queryParameters['offset'] = params.offset;
    }
    if (params.limit !== undefined) {
      queryParameters['limit'] = params.limit;
    }
    if (params.userId !== undefined) {
      queryParameters['user_id'] = params.userId;
    }
    if (params.sortMethod !== undefined) {
      queryParameters['sort_method'] = params.sortMethod;
    }
    if (params.eventType !== undefined) {
      queryParameters['event_type'] = params.eventType;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/events/all`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, jsonValue => EventsResponseFromJSON(jsonValue));
  }
  /**
   * Get all events
   * Get all events
   */
  async getAllEvents() {
    let params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let initOverrides = arguments.length > 1 ? arguments[1] : undefined;
    const response = await this.getAllEventsRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Get a list of events by ID
   */
  async getBulkEventsRaw(params, initOverrides) {
    const queryParameters = {};
    if (params.userId !== undefined) {
      queryParameters['user_id'] = params.userId;
    }
    if (params.id) {
      queryParameters['id'] = params.id;
    }
    if (params.eventType !== undefined) {
      queryParameters['event_type'] = params.eventType;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/events`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, jsonValue => EventsResponseFromJSON(jsonValue));
  }
  /**
   * Get a list of events by ID
   */
  async getBulkEvents() {
    let params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let initOverrides = arguments.length > 1 ? arguments[1] : undefined;
    const response = await this.getBulkEventsRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Get events for a specific entity
   * Get events for a specific entity
   */
  async getEntityEventsRaw(params, initOverrides) {
    if (params.entityId === null || params.entityId === undefined) {
      throw new RequiredError$1('entityId', 'Required parameter params.entityId was null or undefined when calling getEntityEvents.');
    }
    const queryParameters = {};
    if (params.offset !== undefined) {
      queryParameters['offset'] = params.offset;
    }
    if (params.limit !== undefined) {
      queryParameters['limit'] = params.limit;
    }
    if (params.userId !== undefined) {
      queryParameters['user_id'] = params.userId;
    }
    if (params.entityId) {
      queryParameters['entity_id'] = params.entityId;
    }
    if (params.entityType !== undefined) {
      queryParameters['entity_type'] = params.entityType;
    }
    if (params.filterDeleted !== undefined) {
      queryParameters['filter_deleted'] = params.filterDeleted;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/events/entity`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, jsonValue => EventsResponseFromJSON(jsonValue));
  }
  /**
   * Get events for a specific entity
   * Get events for a specific entity
   */
  async getEntityEvents(params, initOverrides) {
    const response = await this.getEntityEventsRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets an unclaimed blockchain event ID
   */
  async getUnclaimedEventIDRaw(initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/events/unclaimed_id`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, jsonValue => UnclaimedIdResponseFromJSON(jsonValue));
  }
  /**
   * Gets an unclaimed blockchain event ID
   */
  async getUnclaimedEventID(initOverrides) {
    const response = await this.getUnclaimedEventIDRaw(initOverrides);
    return await response.value();
  }
}
/**
 * @export
 */
const GetAllEventsSortMethodEnum = {
  Newest: 'newest',
  Timestamp: 'timestamp'
};
/**
 * @export
 */
const GetAllEventsEventTypeEnum = {
  RemixContest: 'remix_contest',
  LiveEvent: 'live_event',
  NewRelease: 'new_release'
};
/**
 * @export
 */
const GetBulkEventsEventTypeEnum = {
  RemixContest: 'remix_contest',
  LiveEvent: 'live_event',
  NewRelease: 'new_release'
};
/**
 * @export
 */
const GetEntityEventsEntityTypeEnum = {
  Track: 'track',
  Collection: 'collection',
  User: 'user'
};

/* tslint:disable */
/**
 *
 */
class ExploreApi$1 extends BaseAPI$1 {
  /**
   * @hidden
   * Get best selling tracks and playlists
   * Get best selling tracks and/or albums
   */
  async getBestSellingRaw(params, initOverrides) {
    const queryParameters = {};
    if (params.offset !== undefined) {
      queryParameters['offset'] = params.offset;
    }
    if (params.limit !== undefined) {
      queryParameters['limit'] = params.limit;
    }
    if (params.userId !== undefined) {
      queryParameters['user_id'] = params.userId;
    }
    if (params.type !== undefined) {
      queryParameters['type'] = params.type;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/explore/best-selling`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, jsonValue => BestSellingResponseFromJSON(jsonValue));
  }
  /**
   * Get best selling tracks and playlists
   * Get best selling tracks and/or albums
   */
  async getBestSelling() {
    let params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let initOverrides = arguments.length > 1 ? arguments[1] : undefined;
    const response = await this.getBestSellingRaw(params, initOverrides);
    return await response.value();
  }
}
/**
 * @export
 */
const GetBestSellingTypeEnum = {
  All: 'all',
  Track: 'track',
  Album: 'album'
};

/* tslint:disable */
/**
 *
 */
class PlaylistsApi$2 extends BaseAPI$1 {
  /**
   * @hidden
   * Gets a list of playlists by ID
   */
  async getBulkPlaylistsRaw(params, initOverrides) {
    const queryParameters = {};
    if (params.userId !== undefined) {
      queryParameters['user_id'] = params.userId;
    }
    if (params.id) {
      queryParameters['id'] = params.id;
    }
    if (params.upc) {
      queryParameters['upc'] = params.upc;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/playlists`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, jsonValue => PlaylistResponseFromJSON(jsonValue));
  }
  /**
   * Gets a list of playlists by ID
   */
  async getBulkPlaylists() {
    let params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let initOverrides = arguments.length > 1 ? arguments[1] : undefined;
    const response = await this.getBulkPlaylistsRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Get a playlist by ID
   */
  async getPlaylistRaw(params, initOverrides) {
    if (params.playlistId === null || params.playlistId === undefined) {
      throw new RequiredError$1('playlistId', 'Required parameter params.playlistId was null or undefined when calling getPlaylist.');
    }
    const queryParameters = {};
    if (params.userId !== undefined) {
      queryParameters['user_id'] = params.userId;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/playlists/{playlist_id}`.replace(`{${"playlist_id"}}`, encodeURIComponent(String(params.playlistId))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, jsonValue => PlaylistResponseFromJSON(jsonValue));
  }
  /**
   * Get a playlist by ID
   */
  async getPlaylist(params, initOverrides) {
    const response = await this.getPlaylistRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets the information necessary to access the playlist and what access the given user has.
   */
  async getPlaylistAccessInfoRaw(params, initOverrides) {
    if (params.playlistId === null || params.playlistId === undefined) {
      throw new RequiredError$1('playlistId', 'Required parameter params.playlistId was null or undefined when calling getPlaylistAccessInfo.');
    }
    const queryParameters = {};
    if (params.userId !== undefined) {
      queryParameters['user_id'] = params.userId;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/playlists/{playlist_id}/access-info`.replace(`{${"playlist_id"}}`, encodeURIComponent(String(params.playlistId))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, jsonValue => AccessInfoResponseFromJSON(jsonValue));
  }
  /**
   * Gets the information necessary to access the playlist and what access the given user has.
   */
  async getPlaylistAccessInfo(params, initOverrides) {
    const response = await this.getPlaylistAccessInfoRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Get a playlist by handle and slug
   */
  async getPlaylistByHandleAndSlugRaw(params, initOverrides) {
    if (params.handle === null || params.handle === undefined) {
      throw new RequiredError$1('handle', 'Required parameter params.handle was null or undefined when calling getPlaylistByHandleAndSlug.');
    }
    if (params.slug === null || params.slug === undefined) {
      throw new RequiredError$1('slug', 'Required parameter params.slug was null or undefined when calling getPlaylistByHandleAndSlug.');
    }
    const queryParameters = {};
    if (params.userId !== undefined) {
      queryParameters['user_id'] = params.userId;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/playlists/by_permalink/{handle}/{slug}`.replace(`{${"handle"}}`, encodeURIComponent(String(params.handle))).replace(`{${"slug"}}`, encodeURIComponent(String(params.slug))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, jsonValue => PlaylistResponseFromJSON(jsonValue));
  }
  /**
   * Get a playlist by handle and slug
   */
  async getPlaylistByHandleAndSlug(params, initOverrides) {
    const response = await this.getPlaylistByHandleAndSlugRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Fetch tracks within a playlist.
   */
  async getPlaylistTracksRaw(params, initOverrides) {
    if (params.playlistId === null || params.playlistId === undefined) {
      throw new RequiredError$1('playlistId', 'Required parameter params.playlistId was null or undefined when calling getPlaylistTracks.');
    }
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/playlists/{playlist_id}/tracks`.replace(`{${"playlist_id"}}`, encodeURIComponent(String(params.playlistId))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, jsonValue => PlaylistTracksResponseFromJSON(jsonValue));
  }
  /**
   * Fetch tracks within a playlist.
   */
  async getPlaylistTracks(params, initOverrides) {
    const response = await this.getPlaylistTracksRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets trending playlists for a time period
   */
  async getTrendingPlaylistsRaw(params, initOverrides) {
    const queryParameters = {};
    if (params.offset !== undefined) {
      queryParameters['offset'] = params.offset;
    }
    if (params.limit !== undefined) {
      queryParameters['limit'] = params.limit;
    }
    if (params.time !== undefined) {
      queryParameters['time'] = params.time;
    }
    if (params.type !== undefined) {
      queryParameters['type'] = params.type;
    }
    if (params.omitTracks !== undefined) {
      queryParameters['omit_tracks'] = params.omitTracks;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/playlists/trending`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, jsonValue => TrendingPlaylistsResponseFromJSON(jsonValue));
  }
  /**
   * Gets trending playlists for a time period
   */
  async getTrendingPlaylists() {
    let params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let initOverrides = arguments.length > 1 ? arguments[1] : undefined;
    const response = await this.getTrendingPlaylistsRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Search for a playlist
   */
  async searchPlaylistsRaw(params, initOverrides) {
    const queryParameters = {};
    if (params.offset !== undefined) {
      queryParameters['offset'] = params.offset;
    }
    if (params.limit !== undefined) {
      queryParameters['limit'] = params.limit;
    }
    if (params.query !== undefined) {
      queryParameters['query'] = params.query;
    }
    if (params.genre) {
      queryParameters['genre'] = params.genre;
    }
    if (params.sortMethod !== undefined) {
      queryParameters['sort_method'] = params.sortMethod;
    }
    if (params.mood) {
      queryParameters['mood'] = params.mood;
    }
    if (params.includePurchaseable !== undefined) {
      queryParameters['includePurchaseable'] = params.includePurchaseable;
    }
    if (params.hasDownloads !== undefined) {
      queryParameters['has_downloads'] = params.hasDownloads;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/playlists/search`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, jsonValue => PlaylistSearchResultFromJSON(jsonValue));
  }
  /**
   * Search for a playlist
   */
  async searchPlaylists() {
    let params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let initOverrides = arguments.length > 1 ? arguments[1] : undefined;
    const response = await this.searchPlaylistsRaw(params, initOverrides);
    return await response.value();
  }
}
/**
 * @export
 */
const GetTrendingPlaylistsTimeEnum$1 = {
  Week: 'week',
  Month: 'month',
  Year: 'year',
  AllTime: 'allTime'
};
/**
 * @export
 */
const GetTrendingPlaylistsTypeEnum$1 = {
  Playlist: 'playlist',
  Album: 'album'
};
/**
 * @export
 */
const SearchPlaylistsSortMethodEnum = {
  Relevant: 'relevant',
  Popular: 'popular',
  Recent: 'recent'
};

/* tslint:disable */
/**
 *
 */
class RewardsApi extends BaseAPI$1 {
  /**
   * @hidden
   * Claims all the filtered undisbursed rewards for a user
   */
  async claimRewardsRaw(params, initOverrides) {
    if (params.claimRewardsRequest === null || params.claimRewardsRequest === undefined) {
      throw new RequiredError$1('claimRewardsRequest', 'Required parameter params.claimRewardsRequest was null or undefined when calling claimRewards.');
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters['Content-Type'] = 'application/json';
    const response = await this.request({
      path: `/rewards/claim`,
      method: 'POST',
      headers: headerParameters,
      query: queryParameters,
      body: ClaimRewardsRequestToJSON(params.claimRewardsRequest)
    }, initOverrides);
    return new JSONApiResponse$1(response, jsonValue => ClaimRewardsResponseFromJSON(jsonValue));
  }
  /**
   * Claims all the filtered undisbursed rewards for a user
   */
  async claimRewards(params, initOverrides) {
    const response = await this.claimRewardsRaw(params, initOverrides);
    return await response.value();
  }
}

/* tslint:disable */
/**
 *
 */
class TipsApi$1 extends BaseAPI$1 {
  /**
   * @hidden
   * Gets the most recent tips on the network
   */
  async getTipsRaw(params, initOverrides) {
    const queryParameters = {};
    if (params.offset !== undefined) {
      queryParameters['offset'] = params.offset;
    }
    if (params.limit !== undefined) {
      queryParameters['limit'] = params.limit;
    }
    if (params.userId !== undefined) {
      queryParameters['user_id'] = params.userId;
    }
    if (params.receiverMinFollowers !== undefined) {
      queryParameters['receiver_min_followers'] = params.receiverMinFollowers;
    }
    if (params.receiverIsVerified !== undefined) {
      queryParameters['receiver_is_verified'] = params.receiverIsVerified;
    }
    if (params.currentUserFollows !== undefined) {
      queryParameters['current_user_follows'] = params.currentUserFollows;
    }
    if (params.uniqueBy !== undefined) {
      queryParameters['unique_by'] = params.uniqueBy;
    }
    if (params.minSlot !== undefined) {
      queryParameters['min_slot'] = params.minSlot;
    }
    if (params.maxSlot !== undefined) {
      queryParameters['max_slot'] = params.maxSlot;
    }
    if (params.txSignatures) {
      queryParameters['tx_signatures'] = params.txSignatures.join(COLLECTION_FORMATS$1["csv"]);
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/tips`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, jsonValue => GetTipsResponseFromJSON$1(jsonValue));
  }
  /**
   * Gets the most recent tips on the network
   */
  async getTips() {
    let params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let initOverrides = arguments.length > 1 ? arguments[1] : undefined;
    const response = await this.getTipsRaw(params, initOverrides);
    return await response.value();
  }
}
/**
 * @export
 */
const GetTipsCurrentUserFollowsEnum$1 = {
  Sender: 'sender',
  Receiver: 'receiver',
  SenderOrReceiver: 'sender_or_receiver'
};
/**
 * @export
 */
const GetTipsUniqueByEnum$1 = {
  Sender: 'sender',
  Receiver: 'receiver'
};

/* tslint:disable */
/**
 *
 */
class TracksApi$2 extends BaseAPI$1 {
  /**
   * @hidden
   * Download an original or mp3 track
   * Download the original or MP3 file of a track
   */
  async downloadTrackRaw(params, initOverrides) {
    if (params.trackId === null || params.trackId === undefined) {
      throw new RequiredError$1('trackId', 'Required parameter params.trackId was null or undefined when calling downloadTrack.');
    }
    const queryParameters = {};
    if (params.userId !== undefined) {
      queryParameters['user_id'] = params.userId;
    }
    if (params.userSignature !== undefined) {
      queryParameters['user_signature'] = params.userSignature;
    }
    if (params.userData !== undefined) {
      queryParameters['user_data'] = params.userData;
    }
    if (params.nftAccessSignature !== undefined) {
      queryParameters['nft_access_signature'] = params.nftAccessSignature;
    }
    if (params.filename !== undefined) {
      queryParameters['filename'] = params.filename;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/tracks/{track_id}/download`.replace(`{${"track_id"}}`, encodeURIComponent(String(params.trackId))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new VoidApiResponse$1(response);
  }
  /**
   * Download an original or mp3 track
   * Download the original or MP3 file of a track
   */
  async downloadTrack(params, initOverrides) {
    await this.downloadTrackRaw(params, initOverrides);
  }
  /**
   * @hidden
   * Gets a list of tracks using their IDs or permalinks
   */
  async getBulkTracksRaw(params, initOverrides) {
    const queryParameters = {};
    if (params.permalink) {
      queryParameters['permalink'] = params.permalink;
    }
    if (params.id) {
      queryParameters['id'] = params.id;
    }
    if (params.isrc) {
      queryParameters['isrc'] = params.isrc;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/tracks`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, jsonValue => TracksResponseFromJSON(jsonValue));
  }
  /**
   * Gets a list of tracks using their IDs or permalinks
   */
  async getBulkTracks() {
    let params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let initOverrides = arguments.length > 1 ? arguments[1] : undefined;
    const response = await this.getBulkTracksRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets random tracks found on the \"Feeling Lucky\" smart playlist
   */
  async getFeelingLuckyTracksRaw(params, initOverrides) {
    const queryParameters = {};
    if (params.userId !== undefined) {
      queryParameters['user_id'] = params.userId;
    }
    if (params.limit !== undefined) {
      queryParameters['limit'] = params.limit;
    }
    if (params.minFollowers !== undefined) {
      queryParameters['min_followers'] = params.minFollowers;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/tracks/feeling-lucky`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, jsonValue => TracksResponseFromJSON(jsonValue));
  }
  /**
   * Gets random tracks found on the \"Feeling Lucky\" smart playlist
   */
  async getFeelingLuckyTracks() {
    let params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let initOverrides = arguments.length > 1 ? arguments[1] : undefined;
    const response = await this.getFeelingLuckyTracksRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets the most shared tracks for a given time range
   */
  async getMostSharedTracksRaw(params, initOverrides) {
    const queryParameters = {};
    if (params.userId !== undefined) {
      queryParameters['user_id'] = params.userId;
    }
    if (params.limit !== undefined) {
      queryParameters['limit'] = params.limit;
    }
    if (params.offset !== undefined) {
      queryParameters['offset'] = params.offset;
    }
    if (params.timeRange !== undefined) {
      queryParameters['time_range'] = params.timeRange;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/tracks/most-shared`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, jsonValue => TracksResponseFromJSON(jsonValue));
  }
  /**
   * Gets the most shared tracks for a given time range
   */
  async getMostSharedTracks() {
    let params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let initOverrides = arguments.length > 1 ? arguments[1] : undefined;
    const response = await this.getMostSharedTracksRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets the most recently listed premium tracks
   */
  async getRecentPremiumTracksRaw(params, initOverrides) {
    const queryParameters = {};
    if (params.offset !== undefined) {
      queryParameters['offset'] = params.offset;
    }
    if (params.limit !== undefined) {
      queryParameters['limit'] = params.limit;
    }
    if (params.userId !== undefined) {
      queryParameters['user_id'] = params.userId;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/tracks/recent-premium`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, jsonValue => TracksResponseFromJSON(jsonValue));
  }
  /**
   * Gets the most recently listed premium tracks
   */
  async getRecentPremiumTracks() {
    let params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let initOverrides = arguments.length > 1 ? arguments[1] : undefined;
    const response = await this.getRecentPremiumTracksRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets a track by ID
   */
  async getTrackRaw(params, initOverrides) {
    if (params.trackId === null || params.trackId === undefined) {
      throw new RequiredError$1('trackId', 'Required parameter params.trackId was null or undefined when calling getTrack.');
    }
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/tracks/{track_id}`.replace(`{${"track_id"}}`, encodeURIComponent(String(params.trackId))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, jsonValue => TrackResponseFromJSON(jsonValue));
  }
  /**
   * Gets a track by ID
   */
  async getTrack(params, initOverrides) {
    const response = await this.getTrackRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets the information necessary to access the track and what access the given user has.
   */
  async getTrackAccessInfoRaw(params, initOverrides) {
    if (params.trackId === null || params.trackId === undefined) {
      throw new RequiredError$1('trackId', 'Required parameter params.trackId was null or undefined when calling getTrackAccessInfo.');
    }
    const queryParameters = {};
    if (params.userId !== undefined) {
      queryParameters['user_id'] = params.userId;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/tracks/{track_id}/access-info`.replace(`{${"track_id"}}`, encodeURIComponent(String(params.trackId))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, jsonValue => AccessInfoResponseFromJSON(jsonValue));
  }
  /**
   * Gets the information necessary to access the track and what access the given user has.
   */
  async getTrackAccessInfo(params, initOverrides) {
    const response = await this.getTrackAccessInfoRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Get the comment count for a track
   */
  async getTrackCommentCountRaw(params, initOverrides) {
    if (params.trackId === null || params.trackId === undefined) {
      throw new RequiredError$1('trackId', 'Required parameter params.trackId was null or undefined when calling getTrackCommentCount.');
    }
    const queryParameters = {};
    if (params.userId !== undefined) {
      queryParameters['user_id'] = params.userId;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/tracks/{track_id}/comment_count`.replace(`{${"track_id"}}`, encodeURIComponent(String(params.trackId))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, jsonValue => TrackCommentCountResponseFromJSON(jsonValue));
  }
  /**
   * Get the comment count for a track
   */
  async getTrackCommentCount(params, initOverrides) {
    const response = await this.getTrackCommentCountRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Get the comment notification setting for a track
   */
  async getTrackCommentNotificationSettingRaw(params, initOverrides) {
    if (params.trackId === null || params.trackId === undefined) {
      throw new RequiredError$1('trackId', 'Required parameter params.trackId was null or undefined when calling getTrackCommentNotificationSetting.');
    }
    const queryParameters = {};
    if (params.userId !== undefined) {
      queryParameters['user_id'] = params.userId;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/tracks/{track_id}/comment_notification_setting`.replace(`{${"track_id"}}`, encodeURIComponent(String(params.trackId))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, jsonValue => TrackCommentNotificationResponseFromJSON(jsonValue));
  }
  /**
   * Get the comment notification setting for a track
   */
  async getTrackCommentNotificationSetting(params, initOverrides) {
    const response = await this.getTrackCommentNotificationSettingRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Get a list of comments for a track
   */
  async getTrackCommentsRaw(params, initOverrides) {
    if (params.trackId === null || params.trackId === undefined) {
      throw new RequiredError$1('trackId', 'Required parameter params.trackId was null or undefined when calling getTrackComments.');
    }
    const queryParameters = {};
    if (params.offset !== undefined) {
      queryParameters['offset'] = params.offset;
    }
    if (params.limit !== undefined) {
      queryParameters['limit'] = params.limit;
    }
    if (params.userId !== undefined) {
      queryParameters['user_id'] = params.userId;
    }
    if (params.sortMethod !== undefined) {
      queryParameters['sort_method'] = params.sortMethod;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/tracks/{track_id}/comments`.replace(`{${"track_id"}}`, encodeURIComponent(String(params.trackId))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, jsonValue => TrackCommentsResponseFromJSON(jsonValue));
  }
  /**
   * Get a list of comments for a track
   */
  async getTrackComments(params, initOverrides) {
    const response = await this.getTrackCommentsRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Get the remixable stems of a track
   */
  async getTrackStemsRaw(params, initOverrides) {
    if (params.trackId === null || params.trackId === undefined) {
      throw new RequiredError$1('trackId', 'Required parameter params.trackId was null or undefined when calling getTrackStems.');
    }
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/tracks/{track_id}/stems`.replace(`{${"track_id"}}`, encodeURIComponent(String(params.trackId))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, jsonValue => StemsResponseFromJSON$1(jsonValue));
  }
  /**
   * Get the remixable stems of a track
   */
  async getTrackStems(params, initOverrides) {
    const response = await this.getTrackStemsRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Get the users that have listened to a track the most
   */
  async getTrackTopListenersRaw(params, initOverrides) {
    if (params.trackId === null || params.trackId === undefined) {
      throw new RequiredError$1('trackId', 'Required parameter params.trackId was null or undefined when calling getTrackTopListeners.');
    }
    const queryParameters = {};
    if (params.offset !== undefined) {
      queryParameters['offset'] = params.offset;
    }
    if (params.limit !== undefined) {
      queryParameters['limit'] = params.limit;
    }
    if (params.userId !== undefined) {
      queryParameters['user_id'] = params.userId;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/tracks/{track_id}/top_listeners`.replace(`{${"track_id"}}`, encodeURIComponent(String(params.trackId))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, jsonValue => TopListenerFromJSON(jsonValue));
  }
  /**
   * Get the users that have listened to a track the most
   */
  async getTrackTopListeners(params, initOverrides) {
    const response = await this.getTrackTopListenersRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets the most recent tracks with active discussion
   */
  async getTracksWithRecentCommentsRaw(params, initOverrides) {
    const queryParameters = {};
    if (params.userId !== undefined) {
      queryParameters['user_id'] = params.userId;
    }
    if (params.limit !== undefined) {
      queryParameters['limit'] = params.limit;
    }
    if (params.offset !== undefined) {
      queryParameters['offset'] = params.offset;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/tracks/recent-comments`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, jsonValue => TracksResponseFromJSON(jsonValue));
  }
  /**
   * Gets the most recent tracks with active discussion
   */
  async getTracksWithRecentComments() {
    let params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let initOverrides = arguments.length > 1 ? arguments[1] : undefined;
    const response = await this.getTracksWithRecentCommentsRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets the top 100 trending (most popular) tracks on Audius
   */
  async getTrendingTracksRaw(params, initOverrides) {
    const queryParameters = {};
    if (params.offset !== undefined) {
      queryParameters['offset'] = params.offset;
    }
    if (params.limit !== undefined) {
      queryParameters['limit'] = params.limit;
    }
    if (params.genre !== undefined) {
      queryParameters['genre'] = params.genre;
    }
    if (params.time !== undefined) {
      queryParameters['time'] = params.time;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/tracks/trending`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, jsonValue => TracksResponseFromJSON(jsonValue));
  }
  /**
   * Gets the top 100 trending (most popular) tracks on Audius
   */
  async getTrendingTracks() {
    let params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let initOverrides = arguments.length > 1 ? arguments[1] : undefined;
    const response = await this.getTrendingTracksRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets the top 100 trending underground tracks on Audius
   */
  async getUndergroundTrendingTracksRaw(params, initOverrides) {
    const queryParameters = {};
    if (params.offset !== undefined) {
      queryParameters['offset'] = params.offset;
    }
    if (params.limit !== undefined) {
      queryParameters['limit'] = params.limit;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/tracks/trending/underground`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, jsonValue => TracksResponseFromJSON(jsonValue));
  }
  /**
   * Gets the top 100 trending underground tracks on Audius
   */
  async getUndergroundTrendingTracks() {
    let params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let initOverrides = arguments.length > 1 ? arguments[1] : undefined;
    const response = await this.getUndergroundTrendingTracksRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Inspect a track
   * Inspects the details of the file for a track
   */
  async inspectTrackRaw(params, initOverrides) {
    if (params.trackId === null || params.trackId === undefined) {
      throw new RequiredError$1('trackId', 'Required parameter params.trackId was null or undefined when calling inspectTrack.');
    }
    const queryParameters = {};
    if (params.original !== undefined) {
      queryParameters['original'] = params.original;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/tracks/{track_id}/inspect`.replace(`{${"track_id"}}`, encodeURIComponent(String(params.trackId))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, jsonValue => TrackInspectFromJSON(jsonValue));
  }
  /**
   * Inspect a track
   * Inspects the details of the file for a track
   */
  async inspectTrack(params, initOverrides) {
    const response = await this.inspectTrackRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Inspect multiple tracks
   * Inspects the details of the files for multiple tracks
   */
  async inspectTracksRaw(params, initOverrides) {
    if (params.id === null || params.id === undefined) {
      throw new RequiredError$1('id', 'Required parameter params.id was null or undefined when calling inspectTracks.');
    }
    const queryParameters = {};
    if (params.id) {
      queryParameters['id'] = params.id;
    }
    if (params.original !== undefined) {
      queryParameters['original'] = params.original;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/tracks/inspect`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, jsonValue => TrackInspectListFromJSON(jsonValue));
  }
  /**
   * Inspect multiple tracks
   * Inspects the details of the files for multiple tracks
   */
  async inspectTracks(params, initOverrides) {
    const response = await this.inspectTracksRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Search for a track or tracks
   */
  async searchTracksRaw(params, initOverrides) {
    const queryParameters = {};
    if (params.offset !== undefined) {
      queryParameters['offset'] = params.offset;
    }
    if (params.limit !== undefined) {
      queryParameters['limit'] = params.limit;
    }
    if (params.query !== undefined) {
      queryParameters['query'] = params.query;
    }
    if (params.genre) {
      queryParameters['genre'] = params.genre;
    }
    if (params.sortMethod !== undefined) {
      queryParameters['sort_method'] = params.sortMethod;
    }
    if (params.mood) {
      queryParameters['mood'] = params.mood;
    }
    if (params.onlyDownloadable !== undefined) {
      queryParameters['only_downloadable'] = params.onlyDownloadable;
    }
    if (params.includePurchaseable !== undefined) {
      queryParameters['includePurchaseable'] = params.includePurchaseable;
    }
    if (params.isPurchaseable !== undefined) {
      queryParameters['is_purchaseable'] = params.isPurchaseable;
    }
    if (params.hasDownloads !== undefined) {
      queryParameters['has_downloads'] = params.hasDownloads;
    }
    if (params.key) {
      queryParameters['key'] = params.key;
    }
    if (params.bpmMin !== undefined) {
      queryParameters['bpm_min'] = params.bpmMin;
    }
    if (params.bpmMax !== undefined) {
      queryParameters['bpm_max'] = params.bpmMax;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/tracks/search`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, jsonValue => TrackSearchFromJSON(jsonValue));
  }
  /**
   * Search for a track or tracks
   */
  async searchTracks() {
    let params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let initOverrides = arguments.length > 1 ? arguments[1] : undefined;
    const response = await this.searchTracksRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Stream an mp3 track This endpoint accepts the Range header for streaming. https://developer.mozilla.org/en-US/docs/Web/HTTP/Range_requests
   * Get the streamable MP3 file of a track
   */
  async streamTrackRaw(params, initOverrides) {
    if (params.trackId === null || params.trackId === undefined) {
      throw new RequiredError$1('trackId', 'Required parameter params.trackId was null or undefined when calling streamTrack.');
    }
    const queryParameters = {};
    if (params.userId !== undefined) {
      queryParameters['user_id'] = params.userId;
    }
    if (params.preview !== undefined) {
      queryParameters['preview'] = params.preview;
    }
    if (params.userSignature !== undefined) {
      queryParameters['user_signature'] = params.userSignature;
    }
    if (params.userData !== undefined) {
      queryParameters['user_data'] = params.userData;
    }
    if (params.nftAccessSignature !== undefined) {
      queryParameters['nft_access_signature'] = params.nftAccessSignature;
    }
    if (params.skipPlayCount !== undefined) {
      queryParameters['skip_play_count'] = params.skipPlayCount;
    }
    if (params.apiKey !== undefined) {
      queryParameters['api_key'] = params.apiKey;
    }
    if (params.skipCheck !== undefined) {
      queryParameters['skip_check'] = params.skipCheck;
    }
    if (params.noRedirect !== undefined) {
      queryParameters['no_redirect'] = params.noRedirect;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/tracks/{track_id}/stream`.replace(`{${"track_id"}}`, encodeURIComponent(String(params.trackId))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, jsonValue => StreamUrlResponseFromJSON(jsonValue));
  }
  /**
   * Stream an mp3 track This endpoint accepts the Range header for streaming. https://developer.mozilla.org/en-US/docs/Web/HTTP/Range_requests
   * Get the streamable MP3 file of a track
   */
  async streamTrack(params, initOverrides) {
    const response = await this.streamTrackRaw(params, initOverrides);
    return await response.value();
  }
}
/**
 * @export
 */
const GetMostSharedTracksTimeRangeEnum$1 = {
  Week: 'week',
  Month: 'month',
  AllTime: 'allTime'
};
/**
 * @export
 */
const GetTrackCommentsSortMethodEnum$1 = {
  Top: 'top',
  Newest: 'newest',
  Timestamp: 'timestamp'
};
/**
 * @export
 */
const GetTrendingTracksTimeEnum$1 = {
  Week: 'week',
  Month: 'month',
  Year: 'year',
  AllTime: 'allTime'
};
/**
 * @export
 */
const SearchTracksSortMethodEnum = {
  Relevant: 'relevant',
  Popular: 'popular',
  Recent: 'recent'
};

/* tslint:disable */
/**
 *
 */
class UsersApi$2 extends BaseAPI$1 {
  /**
   * @hidden
   * Downloads the purchases the user has made as a CSV file
   */
  async downloadPurchasesAsCSVRaw(params, initOverrides) {
    if (params.id === null || params.id === undefined) {
      throw new RequiredError$1('id', 'Required parameter params.id was null or undefined when calling downloadPurchasesAsCSV.');
    }
    const queryParameters = {};
    if (params.userId !== undefined) {
      queryParameters['user_id'] = params.userId;
    }
    const headerParameters = {};
    if (params.encodedDataMessage !== undefined && params.encodedDataMessage !== null) {
      headerParameters['Encoded-Data-Message'] = String(params.encodedDataMessage);
    }
    if (params.encodedDataSignature !== undefined && params.encodedDataSignature !== null) {
      headerParameters['Encoded-Data-Signature'] = String(params.encodedDataSignature);
    }
    const response = await this.request({
      path: `/users/{id}/purchases/download`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new VoidApiResponse$1(response);
  }
  /**
   * Downloads the purchases the user has made as a CSV file
   */
  async downloadPurchasesAsCSV(params, initOverrides) {
    await this.downloadPurchasesAsCSVRaw(params, initOverrides);
  }
  /**
   * @hidden
   * Downloads the sales the user has made as a CSV file
   */
  async downloadSalesAsCSVRaw(params, initOverrides) {
    if (params.id === null || params.id === undefined) {
      throw new RequiredError$1('id', 'Required parameter params.id was null or undefined when calling downloadSalesAsCSV.');
    }
    const queryParameters = {};
    if (params.userId !== undefined) {
      queryParameters['user_id'] = params.userId;
    }
    const headerParameters = {};
    if (params.encodedDataMessage !== undefined && params.encodedDataMessage !== null) {
      headerParameters['Encoded-Data-Message'] = String(params.encodedDataMessage);
    }
    if (params.encodedDataSignature !== undefined && params.encodedDataSignature !== null) {
      headerParameters['Encoded-Data-Signature'] = String(params.encodedDataSignature);
    }
    const response = await this.request({
      path: `/users/{id}/sales/download`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new VoidApiResponse$1(response);
  }
  /**
   * Downloads the sales the user has made as a CSV file
   */
  async downloadSalesAsCSV(params, initOverrides) {
    await this.downloadSalesAsCSVRaw(params, initOverrides);
  }
  /**
   * @hidden
   * Gets the sales data for the user in JSON format
   */
  async downloadSalesAsJSONRaw(params, initOverrides) {
    if (params.id === null || params.id === undefined) {
      throw new RequiredError$1('id', 'Required parameter params.id was null or undefined when calling downloadSalesAsJSON.');
    }
    const queryParameters = {};
    if (params.userId !== undefined) {
      queryParameters['user_id'] = params.userId;
    }
    if (params.granteeUserId !== undefined) {
      queryParameters['grantee_user_id'] = params.granteeUserId;
    }
    const headerParameters = {};
    if (params.encodedDataMessage !== undefined && params.encodedDataMessage !== null) {
      headerParameters['Encoded-Data-Message'] = String(params.encodedDataMessage);
    }
    if (params.encodedDataSignature !== undefined && params.encodedDataSignature !== null) {
      headerParameters['Encoded-Data-Signature'] = String(params.encodedDataSignature);
    }
    const response = await this.request({
      path: `/users/{id}/sales/download/json`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, jsonValue => SalesJsonResponseFromJSON(jsonValue));
  }
  /**
   * Gets the sales data for the user in JSON format
   */
  async downloadSalesAsJSON(params, initOverrides) {
    const response = await this.downloadSalesAsJSONRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Downloads the USDC withdrawals the user has made as a CSV file
   */
  async downloadUSDCWithdrawalsAsCSVRaw(params, initOverrides) {
    if (params.id === null || params.id === undefined) {
      throw new RequiredError$1('id', 'Required parameter params.id was null or undefined when calling downloadUSDCWithdrawalsAsCSV.');
    }
    const queryParameters = {};
    if (params.userId !== undefined) {
      queryParameters['user_id'] = params.userId;
    }
    const headerParameters = {};
    if (params.encodedDataMessage !== undefined && params.encodedDataMessage !== null) {
      headerParameters['Encoded-Data-Message'] = String(params.encodedDataMessage);
    }
    if (params.encodedDataSignature !== undefined && params.encodedDataSignature !== null) {
      headerParameters['Encoded-Data-Signature'] = String(params.encodedDataSignature);
    }
    const response = await this.request({
      path: `/users/{id}/withdrawals/download`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new VoidApiResponse$1(response);
  }
  /**
   * Downloads the USDC withdrawals the user has made as a CSV file
   */
  async downloadUSDCWithdrawalsAsCSV(params, initOverrides) {
    await this.downloadUSDCWithdrawalsAsCSVRaw(params, initOverrides);
  }
  /**
   * @hidden
   * Gets the AI generated tracks attributed to a user using the user\'s handle
   */
  async getAIAttributedTracksByUserHandleRaw(params, initOverrides) {
    if (params.handle === null || params.handle === undefined) {
      throw new RequiredError$1('handle', 'Required parameter params.handle was null or undefined when calling getAIAttributedTracksByUserHandle.');
    }
    const queryParameters = {};
    if (params.offset !== undefined) {
      queryParameters['offset'] = params.offset;
    }
    if (params.limit !== undefined) {
      queryParameters['limit'] = params.limit;
    }
    if (params.userId !== undefined) {
      queryParameters['user_id'] = params.userId;
    }
    if (params.sort !== undefined) {
      queryParameters['sort'] = params.sort;
    }
    if (params.query !== undefined) {
      queryParameters['query'] = params.query;
    }
    if (params.sortMethod !== undefined) {
      queryParameters['sort_method'] = params.sortMethod;
    }
    if (params.sortDirection !== undefined) {
      queryParameters['sort_direction'] = params.sortDirection;
    }
    if (params.filterTracks !== undefined) {
      queryParameters['filter_tracks'] = params.filterTracks;
    }
    const headerParameters = {};
    if (params.encodedDataMessage !== undefined && params.encodedDataMessage !== null) {
      headerParameters['Encoded-Data-Message'] = String(params.encodedDataMessage);
    }
    if (params.encodedDataSignature !== undefined && params.encodedDataSignature !== null) {
      headerParameters['Encoded-Data-Signature'] = String(params.encodedDataSignature);
    }
    const response = await this.request({
      path: `/users/handle/{handle}/tracks/ai_attributed`.replace(`{${"handle"}}`, encodeURIComponent(String(params.handle))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, jsonValue => TracksResponseFromJSON(jsonValue));
  }
  /**
   * Gets the AI generated tracks attributed to a user using the user\'s handle
   */
  async getAIAttributedTracksByUserHandle(params, initOverrides) {
    const response = await this.getAIAttributedTracksByUserHandleRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets the albums created by a user using their user ID
   */
  async getAlbumsByUserRaw(params, initOverrides) {
    if (params.id === null || params.id === undefined) {
      throw new RequiredError$1('id', 'Required parameter params.id was null or undefined when calling getAlbumsByUser.');
    }
    const queryParameters = {};
    if (params.offset !== undefined) {
      queryParameters['offset'] = params.offset;
    }
    if (params.limit !== undefined) {
      queryParameters['limit'] = params.limit;
    }
    if (params.userId !== undefined) {
      queryParameters['user_id'] = params.userId;
    }
    if (params.sortMethod !== undefined) {
      queryParameters['sort_method'] = params.sortMethod;
    }
    if (params.query !== undefined) {
      queryParameters['query'] = params.query;
    }
    const headerParameters = {};
    if (params.encodedDataMessage !== undefined && params.encodedDataMessage !== null) {
      headerParameters['Encoded-Data-Message'] = String(params.encodedDataMessage);
    }
    if (params.encodedDataSignature !== undefined && params.encodedDataSignature !== null) {
      headerParameters['Encoded-Data-Signature'] = String(params.encodedDataSignature);
    }
    const response = await this.request({
      path: `/users/{id}/albums`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, jsonValue => AlbumsResponseFromJSON(jsonValue));
  }
  /**
   * Gets the albums created by a user using their user ID
   */
  async getAlbumsByUser(params, initOverrides) {
    const response = await this.getAlbumsByUserRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Get the apps that user has authorized to write to their account
   */
  async getAuthorizedAppsRaw(params, initOverrides) {
    if (params.id === null || params.id === undefined) {
      throw new RequiredError$1('id', 'Required parameter params.id was null or undefined when calling getAuthorizedApps.');
    }
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/users/{id}/authorized_apps`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, jsonValue => AuthorizedAppsFromJSON(jsonValue));
  }
  /**
   * Get the apps that user has authorized to write to their account
   */
  async getAuthorizedApps(params, initOverrides) {
    const response = await this.getAuthorizedAppsRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets a list of users by ID
   */
  async getBulkUsersRaw(params, initOverrides) {
    const queryParameters = {};
    if (params.userId !== undefined) {
      queryParameters['user_id'] = params.userId;
    }
    if (params.id) {
      queryParameters['id'] = params.id;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/users`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, jsonValue => UsersResponseFromJSON(jsonValue));
  }
  /**
   * Gets a list of users by ID
   */
  async getBulkUsers() {
    let params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let initOverrides = arguments.length > 1 ? arguments[1] : undefined;
    const response = await this.getBulkUsersRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Get the User\'s ERC and SPL connected wallets
   */
  async getConnectedWalletsRaw(params, initOverrides) {
    if (params.id === null || params.id === undefined) {
      throw new RequiredError$1('id', 'Required parameter params.id was null or undefined when calling getConnectedWallets.');
    }
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/users/{id}/connected_wallets`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, jsonValue => ConnectedWalletsResponseFromJSON(jsonValue));
  }
  /**
   * Get the User\'s ERC and SPL connected wallets
   */
  async getConnectedWallets(params, initOverrides) {
    const response = await this.getConnectedWalletsRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets the developer apps that the user owns
   */
  async getDeveloperAppsRaw(params, initOverrides) {
    if (params.id === null || params.id === undefined) {
      throw new RequiredError$1('id', 'Required parameter params.id was null or undefined when calling getDeveloperApps.');
    }
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/users/{id}/developer_apps`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, jsonValue => DeveloperAppsFromJSON(jsonValue));
  }
  /**
   * Gets the developer apps that the user owns
   */
  async getDeveloperApps(params, initOverrides) {
    const response = await this.getDeveloperAppsRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets a user\'s favorite tracks
   */
  async getFavoritesRaw(params, initOverrides) {
    if (params.id === null || params.id === undefined) {
      throw new RequiredError$1('id', 'Required parameter params.id was null or undefined when calling getFavorites.');
    }
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/users/{id}/favorites`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, jsonValue => FavoritesResponseFromJSON(jsonValue));
  }
  /**
   * Gets a user\'s favorite tracks
   */
  async getFavorites(params, initOverrides) {
    const response = await this.getFavoritesRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * All users that follow the provided user
   */
  async getFollowersRaw(params, initOverrides) {
    if (params.id === null || params.id === undefined) {
      throw new RequiredError$1('id', 'Required parameter params.id was null or undefined when calling getFollowers.');
    }
    const queryParameters = {};
    if (params.offset !== undefined) {
      queryParameters['offset'] = params.offset;
    }
    if (params.limit !== undefined) {
      queryParameters['limit'] = params.limit;
    }
    if (params.userId !== undefined) {
      queryParameters['user_id'] = params.userId;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/users/{id}/followers`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, jsonValue => FollowersResponseFromJSON(jsonValue));
  }
  /**
   * All users that follow the provided user
   */
  async getFollowers(params, initOverrides) {
    const response = await this.getFollowersRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * All users that the provided user follows
   */
  async getFollowingRaw(params, initOverrides) {
    if (params.id === null || params.id === undefined) {
      throw new RequiredError$1('id', 'Required parameter params.id was null or undefined when calling getFollowing.');
    }
    const queryParameters = {};
    if (params.offset !== undefined) {
      queryParameters['offset'] = params.offset;
    }
    if (params.limit !== undefined) {
      queryParameters['limit'] = params.limit;
    }
    if (params.userId !== undefined) {
      queryParameters['user_id'] = params.userId;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/users/{id}/following`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, jsonValue => FollowingResponseFromJSON$1(jsonValue));
  }
  /**
   * All users that the provided user follows
   */
  async getFollowing(params, initOverrides) {
    const response = await this.getFollowingRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets users muted by the given user
   */
  async getMutedUsersRaw(params, initOverrides) {
    if (params.id === null || params.id === undefined) {
      throw new RequiredError$1('id', 'Required parameter params.id was null or undefined when calling getMutedUsers.');
    }
    const queryParameters = {};
    const headerParameters = {};
    if (params.encodedDataMessage !== undefined && params.encodedDataMessage !== null) {
      headerParameters['Encoded-Data-Message'] = String(params.encodedDataMessage);
    }
    if (params.encodedDataSignature !== undefined && params.encodedDataSignature !== null) {
      headerParameters['Encoded-Data-Signature'] = String(params.encodedDataSignature);
    }
    const response = await this.request({
      path: `/users/{id}/muted`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, jsonValue => UsersResponseFromJSON(jsonValue));
  }
  /**
   * Gets users muted by the given user
   */
  async getMutedUsers(params, initOverrides) {
    const response = await this.getMutedUsersRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Get intersection of users that follow followeeUserId and users that are followed by followerUserId
   */
  async getMutualFollowersRaw(params, initOverrides) {
    if (params.id === null || params.id === undefined) {
      throw new RequiredError$1('id', 'Required parameter params.id was null or undefined when calling getMutualFollowers.');
    }
    const queryParameters = {};
    if (params.offset !== undefined) {
      queryParameters['offset'] = params.offset;
    }
    if (params.limit !== undefined) {
      queryParameters['limit'] = params.limit;
    }
    if (params.userId !== undefined) {
      queryParameters['user_id'] = params.userId;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/users/{id}/mutuals`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, jsonValue => MutualFollowersResponseFromJSON(jsonValue));
  }
  /**
   * Get intersection of users that follow followeeUserId and users that are followed by followerUserId
   */
  async getMutualFollowers(params, initOverrides) {
    const response = await this.getMutualFollowersRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets the playlists created by a user using their user ID
   */
  async getPlaylistsByUserRaw(params, initOverrides) {
    if (params.id === null || params.id === undefined) {
      throw new RequiredError$1('id', 'Required parameter params.id was null or undefined when calling getPlaylistsByUser.');
    }
    const queryParameters = {};
    if (params.offset !== undefined) {
      queryParameters['offset'] = params.offset;
    }
    if (params.limit !== undefined) {
      queryParameters['limit'] = params.limit;
    }
    if (params.userId !== undefined) {
      queryParameters['user_id'] = params.userId;
    }
    if (params.sortMethod !== undefined) {
      queryParameters['sort_method'] = params.sortMethod;
    }
    if (params.query !== undefined) {
      queryParameters['query'] = params.query;
    }
    const headerParameters = {};
    if (params.encodedDataMessage !== undefined && params.encodedDataMessage !== null) {
      headerParameters['Encoded-Data-Message'] = String(params.encodedDataMessage);
    }
    if (params.encodedDataSignature !== undefined && params.encodedDataSignature !== null) {
      headerParameters['Encoded-Data-Signature'] = String(params.encodedDataSignature);
    }
    const response = await this.request({
      path: `/users/{id}/playlists`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, jsonValue => PlaylistsResponseFromJSON(jsonValue));
  }
  /**
   * Gets the playlists created by a user using their user ID
   */
  async getPlaylistsByUser(params, initOverrides) {
    const response = await this.getPlaylistsByUserRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets the list of unique users who have purchased content by the given user
   */
  async getPurchasersRaw(params, initOverrides) {
    if (params.id === null || params.id === undefined) {
      throw new RequiredError$1('id', 'Required parameter params.id was null or undefined when calling getPurchasers.');
    }
    const queryParameters = {};
    if (params.offset !== undefined) {
      queryParameters['offset'] = params.offset;
    }
    if (params.limit !== undefined) {
      queryParameters['limit'] = params.limit;
    }
    if (params.userId !== undefined) {
      queryParameters['user_id'] = params.userId;
    }
    if (params.contentType !== undefined) {
      queryParameters['content_type'] = params.contentType;
    }
    if (params.contentId !== undefined) {
      queryParameters['content_id'] = params.contentId;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/users/{id}/purchasers`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, jsonValue => PurchasersResponseFromJSON(jsonValue));
  }
  /**
   * Gets the list of unique users who have purchased content by the given user
   */
  async getPurchasers(params, initOverrides) {
    const response = await this.getPurchasersRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets a list of users that might be of interest to followers of this user.
   */
  async getRelatedUsersRaw(params, initOverrides) {
    if (params.id === null || params.id === undefined) {
      throw new RequiredError$1('id', 'Required parameter params.id was null or undefined when calling getRelatedUsers.');
    }
    const queryParameters = {};
    if (params.offset !== undefined) {
      queryParameters['offset'] = params.offset;
    }
    if (params.limit !== undefined) {
      queryParameters['limit'] = params.limit;
    }
    if (params.userId !== undefined) {
      queryParameters['user_id'] = params.userId;
    }
    if (params.filterFollowed !== undefined) {
      queryParameters['filter_followed'] = params.filterFollowed;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/users/{id}/related`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, jsonValue => RelatedArtistResponseFromJSON(jsonValue));
  }
  /**
   * Gets a list of users that might be of interest to followers of this user.
   */
  async getRelatedUsers(params, initOverrides) {
    const response = await this.getRelatedUsersRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets the list of unique users who have remixed tracks by the given user, or a specific track by that user if provided
   */
  async getRemixersRaw(params, initOverrides) {
    if (params.id === null || params.id === undefined) {
      throw new RequiredError$1('id', 'Required parameter params.id was null or undefined when calling getRemixers.');
    }
    const queryParameters = {};
    if (params.offset !== undefined) {
      queryParameters['offset'] = params.offset;
    }
    if (params.limit !== undefined) {
      queryParameters['limit'] = params.limit;
    }
    if (params.userId !== undefined) {
      queryParameters['user_id'] = params.userId;
    }
    if (params.trackId !== undefined) {
      queryParameters['track_id'] = params.trackId;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/users/{id}/remixers`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, jsonValue => RemixersResponseFromJSON(jsonValue));
  }
  /**
   * Gets the list of unique users who have remixed tracks by the given user, or a specific track by that user if provided
   */
  async getRemixers(params, initOverrides) {
    const response = await this.getRemixersRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets the given user\'s reposts
   */
  async getRepostsRaw(params, initOverrides) {
    if (params.id === null || params.id === undefined) {
      throw new RequiredError$1('id', 'Required parameter params.id was null or undefined when calling getReposts.');
    }
    const queryParameters = {};
    if (params.offset !== undefined) {
      queryParameters['offset'] = params.offset;
    }
    if (params.limit !== undefined) {
      queryParameters['limit'] = params.limit;
    }
    if (params.userId !== undefined) {
      queryParameters['user_id'] = params.userId;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/users/{id}/reposts`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, jsonValue => RepostsFromJSON(jsonValue));
  }
  /**
   * Gets the given user\'s reposts
   */
  async getReposts(params, initOverrides) {
    const response = await this.getRepostsRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets the aggregated sales data for the user
   */
  async getSalesAggregateRaw(params, initOverrides) {
    if (params.id === null || params.id === undefined) {
      throw new RequiredError$1('id', 'Required parameter params.id was null or undefined when calling getSalesAggregate.');
    }
    const queryParameters = {};
    if (params.offset !== undefined) {
      queryParameters['offset'] = params.offset;
    }
    if (params.limit !== undefined) {
      queryParameters['limit'] = params.limit;
    }
    if (params.userId !== undefined) {
      queryParameters['user_id'] = params.userId;
    }
    const headerParameters = {};
    if (params.encodedDataMessage !== undefined && params.encodedDataMessage !== null) {
      headerParameters['Encoded-Data-Message'] = String(params.encodedDataMessage);
    }
    if (params.encodedDataSignature !== undefined && params.encodedDataSignature !== null) {
      headerParameters['Encoded-Data-Signature'] = String(params.encodedDataSignature);
    }
    const response = await this.request({
      path: `/users/{id}/sales/aggregate`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, jsonValue => SalesAggregateResponseFromJSON(jsonValue));
  }
  /**
   * Gets the aggregated sales data for the user
   */
  async getSalesAggregate(params, initOverrides) {
    const response = await this.getSalesAggregateRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * All users that subscribe to the provided user
   */
  async getSubscribersRaw(params, initOverrides) {
    if (params.id === null || params.id === undefined) {
      throw new RequiredError$1('id', 'Required parameter params.id was null or undefined when calling getSubscribers.');
    }
    const queryParameters = {};
    if (params.offset !== undefined) {
      queryParameters['offset'] = params.offset;
    }
    if (params.limit !== undefined) {
      queryParameters['limit'] = params.limit;
    }
    if (params.userId !== undefined) {
      queryParameters['user_id'] = params.userId;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/users/{id}/subscribers`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, jsonValue => SubscribersResponseFromJSON(jsonValue));
  }
  /**
   * All users that subscribe to the provided user
   */
  async getSubscribers(params, initOverrides) {
    const response = await this.getSubscribersRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets the users that the given user supports
   */
  async getSupportedUsersRaw(params, initOverrides) {
    if (params.id === null || params.id === undefined) {
      throw new RequiredError$1('id', 'Required parameter params.id was null or undefined when calling getSupportedUsers.');
    }
    const queryParameters = {};
    if (params.offset !== undefined) {
      queryParameters['offset'] = params.offset;
    }
    if (params.limit !== undefined) {
      queryParameters['limit'] = params.limit;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/users/{id}/supporting`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, jsonValue => GetSupportedUsersFromJSON(jsonValue));
  }
  /**
   * Gets the users that the given user supports
   */
  async getSupportedUsers(params, initOverrides) {
    const response = await this.getSupportedUsersRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets the supporters of the given user
   */
  async getSupportersRaw(params, initOverrides) {
    if (params.id === null || params.id === undefined) {
      throw new RequiredError$1('id', 'Required parameter params.id was null or undefined when calling getSupporters.');
    }
    const queryParameters = {};
    if (params.offset !== undefined) {
      queryParameters['offset'] = params.offset;
    }
    if (params.limit !== undefined) {
      queryParameters['limit'] = params.limit;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/users/{id}/supporters`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, jsonValue => GetSupportersFromJSON(jsonValue));
  }
  /**
   * Gets the supporters of the given user
   */
  async getSupporters(params, initOverrides) {
    const response = await this.getSupportersRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets the most used track tags by a user.
   * Fetch most used tags in a user\'s tracks
   */
  async getTopTrackTagsRaw(params, initOverrides) {
    if (params.id === null || params.id === undefined) {
      throw new RequiredError$1('id', 'Required parameter params.id was null or undefined when calling getTopTrackTags.');
    }
    const queryParameters = {};
    if (params.limit !== undefined) {
      queryParameters['limit'] = params.limit;
    }
    if (params.userId !== undefined) {
      queryParameters['user_id'] = params.userId;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/users/{id}/tags`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, jsonValue => TagsResponseFromJSON(jsonValue));
  }
  /**
   * Gets the most used track tags by a user.
   * Fetch most used tags in a user\'s tracks
   */
  async getTopTrackTags(params, initOverrides) {
    const response = await this.getTopTrackTagsRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets the tracks created by a user using their user ID
   */
  async getTracksByUserRaw(params, initOverrides) {
    if (params.id === null || params.id === undefined) {
      throw new RequiredError$1('id', 'Required parameter params.id was null or undefined when calling getTracksByUser.');
    }
    const queryParameters = {};
    if (params.offset !== undefined) {
      queryParameters['offset'] = params.offset;
    }
    if (params.limit !== undefined) {
      queryParameters['limit'] = params.limit;
    }
    if (params.userId !== undefined) {
      queryParameters['user_id'] = params.userId;
    }
    if (params.sort !== undefined) {
      queryParameters['sort'] = params.sort;
    }
    if (params.query !== undefined) {
      queryParameters['query'] = params.query;
    }
    if (params.sortMethod !== undefined) {
      queryParameters['sort_method'] = params.sortMethod;
    }
    if (params.sortDirection !== undefined) {
      queryParameters['sort_direction'] = params.sortDirection;
    }
    if (params.filterTracks !== undefined) {
      queryParameters['filter_tracks'] = params.filterTracks;
    }
    const headerParameters = {};
    if (params.encodedDataMessage !== undefined && params.encodedDataMessage !== null) {
      headerParameters['Encoded-Data-Message'] = String(params.encodedDataMessage);
    }
    if (params.encodedDataSignature !== undefined && params.encodedDataSignature !== null) {
      headerParameters['Encoded-Data-Signature'] = String(params.encodedDataSignature);
    }
    const response = await this.request({
      path: `/users/{id}/tracks`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, jsonValue => TracksResponseFromJSON(jsonValue));
  }
  /**
   * Gets the tracks created by a user using their user ID
   */
  async getTracksByUser(params, initOverrides) {
    const response = await this.getTracksByUserRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets a single user by their user ID
   */
  async getUserRaw(params, initOverrides) {
    if (params.id === null || params.id === undefined) {
      throw new RequiredError$1('id', 'Required parameter params.id was null or undefined when calling getUser.');
    }
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/users/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, jsonValue => UserResponseFromJSON(jsonValue));
  }
  /**
   * Gets a single user by their user ID
   */
  async getUser(params, initOverrides) {
    const response = await this.getUserRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets a single user by their handle
   */
  async getUserByHandleRaw(params, initOverrides) {
    if (params.handle === null || params.handle === undefined) {
      throw new RequiredError$1('handle', 'Required parameter params.handle was null or undefined when calling getUserByHandle.');
    }
    const queryParameters = {};
    if (params.userId !== undefined) {
      queryParameters['user_id'] = params.userId;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/users/handle/{handle}`.replace(`{${"handle"}}`, encodeURIComponent(String(params.handle))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, jsonValue => UserResponseFromJSON(jsonValue));
  }
  /**
   * Gets a single user by their handle
   */
  async getUserByHandle(params, initOverrides) {
    const response = await this.getUserByHandleRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets all challenges for the given user
   */
  async getUserChallengesRaw(params, initOverrides) {
    if (params.id === null || params.id === undefined) {
      throw new RequiredError$1('id', 'Required parameter params.id was null or undefined when calling getUserChallenges.');
    }
    const queryParameters = {};
    if (params.showHistorical !== undefined) {
      queryParameters['show_historical'] = params.showHistorical;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/users/{id}/challenges`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, jsonValue => GetChallengesFromJSON(jsonValue));
  }
  /**
   * Gets all challenges for the given user
   */
  async getUserChallenges(params, initOverrides) {
    const response = await this.getUserChallengesRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets information about a specific coin owned by the user and their wallets
   */
  async getUserCoinRaw(params, initOverrides) {
    if (params.id === null || params.id === undefined) {
      throw new RequiredError$1('id', 'Required parameter params.id was null or undefined when calling getUserCoin.');
    }
    if (params.mint === null || params.mint === undefined) {
      throw new RequiredError$1('mint', 'Required parameter params.mint was null or undefined when calling getUserCoin.');
    }
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/users/{id}/coins/{mint}`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))).replace(`{${"mint"}}`, encodeURIComponent(String(params.mint))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, jsonValue => UserCoinResponseFromJSON(jsonValue));
  }
  /**
   * Gets information about a specific coin owned by the user and their wallets
   */
  async getUserCoin(params, initOverrides) {
    const response = await this.getUserCoinRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets a list of the coins owned by the user and their balances
   */
  async getUserCoinsRaw(params, initOverrides) {
    if (params.id === null || params.id === undefined) {
      throw new RequiredError$1('id', 'Required parameter params.id was null or undefined when calling getUserCoins.');
    }
    const queryParameters = {};
    if (params.offset !== undefined) {
      queryParameters['offset'] = params.offset;
    }
    if (params.limit !== undefined) {
      queryParameters['limit'] = params.limit;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/users/{id}/coins`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, jsonValue => UserCoinsResponseFromJSON(jsonValue));
  }
  /**
   * Gets a list of the coins owned by the user and their balances
   */
  async getUserCoins(params, initOverrides) {
    const response = await this.getUserCoinsRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Get the User\'s indexed collectibles data
   */
  async getUserCollectiblesRaw(params, initOverrides) {
    if (params.id === null || params.id === undefined) {
      throw new RequiredError$1('id', 'Required parameter params.id was null or undefined when calling getUserCollectibles.');
    }
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/users/{id}/collectibles`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, jsonValue => CollectiblesResponseFromJSON(jsonValue));
  }
  /**
   * Get the User\'s indexed collectibles data
   */
  async getUserCollectibles(params, initOverrides) {
    const response = await this.getUserCollectiblesRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Get user comment history
   */
  async getUserCommentsRaw(params, initOverrides) {
    if (params.id === null || params.id === undefined) {
      throw new RequiredError$1('id', 'Required parameter params.id was null or undefined when calling getUserComments.');
    }
    const queryParameters = {};
    if (params.offset !== undefined) {
      queryParameters['offset'] = params.offset;
    }
    if (params.limit !== undefined) {
      queryParameters['limit'] = params.limit;
    }
    if (params.userId !== undefined) {
      queryParameters['user_id'] = params.userId;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/users/{id}/comments`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, jsonValue => UserCommentsResponseFromJSON(jsonValue));
  }
  /**
   * Get user comment history
   */
  async getUserComments(params, initOverrides) {
    const response = await this.getUserCommentsRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets the encrypted key for email access between the receiving user and granting user.
   */
  async getUserEmailKeyRaw(params, initOverrides) {
    if (params.receivingUserId === null || params.receivingUserId === undefined) {
      throw new RequiredError$1('receivingUserId', 'Required parameter params.receivingUserId was null or undefined when calling getUserEmailKey.');
    }
    if (params.grantorUserId === null || params.grantorUserId === undefined) {
      throw new RequiredError$1('grantorUserId', 'Required parameter params.grantorUserId was null or undefined when calling getUserEmailKey.');
    }
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/users/{receiving_user_id}/emails/{grantor_user_id}/key`.replace(`{${"receiving_user_id"}}`, encodeURIComponent(String(params.receivingUserId))).replace(`{${"grantor_user_id"}}`, encodeURIComponent(String(params.grantorUserId))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, jsonValue => EmailAccessResponseFromJSON(jsonValue));
  }
  /**
   * Gets the encrypted key for email access between the receiving user and granting user.
   */
  async getUserEmailKey(params, initOverrides) {
    const response = await this.getUserEmailKeyRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets User IDs from any Ethereum wallet address or Solana account address associated with their Audius account.
   */
  async getUserIDsByAddressesRaw(params, initOverrides) {
    if (params.address === null || params.address === undefined) {
      throw new RequiredError$1('address', 'Required parameter params.address was null or undefined when calling getUserIDsByAddresses.');
    }
    const queryParameters = {};
    if (params.address) {
      queryParameters['address'] = params.address;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/users/address`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, jsonValue => UserIdsAddressesResponseFromJSON(jsonValue));
  }
  /**
   * Gets User IDs from any Ethereum wallet address or Solana account address associated with their Audius account.
   */
  async getUserIDsByAddresses(params, initOverrides) {
    const response = await this.getUserIDsByAddressesRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets the listen data for a user by month and track within a given time frame.
   */
  async getUserMonthlyTrackListensRaw(params, initOverrides) {
    if (params.id === null || params.id === undefined) {
      throw new RequiredError$1('id', 'Required parameter params.id was null or undefined when calling getUserMonthlyTrackListens.');
    }
    if (params.startTime === null || params.startTime === undefined) {
      throw new RequiredError$1('startTime', 'Required parameter params.startTime was null or undefined when calling getUserMonthlyTrackListens.');
    }
    if (params.endTime === null || params.endTime === undefined) {
      throw new RequiredError$1('endTime', 'Required parameter params.endTime was null or undefined when calling getUserMonthlyTrackListens.');
    }
    const queryParameters = {};
    if (params.startTime !== undefined) {
      queryParameters['start_time'] = params.startTime;
    }
    if (params.endTime !== undefined) {
      queryParameters['end_time'] = params.endTime;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/users/{id}/listen_counts_monthly`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, jsonValue => UserTrackListenCountsResponseFromJSON(jsonValue));
  }
  /**
   * Gets the listen data for a user by month and track within a given time frame.
   */
  async getUserMonthlyTrackListens(params, initOverrides) {
    const response = await this.getUserMonthlyTrackListensRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets the recommended tracks for the user
   */
  async getUserRecommendedTracksRaw(params, initOverrides) {
    if (params.id === null || params.id === undefined) {
      throw new RequiredError$1('id', 'Required parameter params.id was null or undefined when calling getUserRecommendedTracks.');
    }
    const queryParameters = {};
    if (params.offset !== undefined) {
      queryParameters['offset'] = params.offset;
    }
    if (params.limit !== undefined) {
      queryParameters['limit'] = params.limit;
    }
    if (params.userId !== undefined) {
      queryParameters['user_id'] = params.userId;
    }
    if (params.timeRange !== undefined) {
      queryParameters['time_range'] = params.timeRange;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/users/{id}/recommended-tracks`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, jsonValue => TracksResponseFromJSON(jsonValue));
  }
  /**
   * Gets the recommended tracks for the user
   */
  async getUserRecommendedTracks(params, initOverrides) {
    const response = await this.getUserRecommendedTracksRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets tracks owned by the user which have been remixed by another track
   */
  async getUserTracksRemixedRaw(params, initOverrides) {
    if (params.id === null || params.id === undefined) {
      throw new RequiredError$1('id', 'Required parameter params.id was null or undefined when calling getUserTracksRemixed.');
    }
    const queryParameters = {};
    if (params.offset !== undefined) {
      queryParameters['offset'] = params.offset;
    }
    if (params.limit !== undefined) {
      queryParameters['limit'] = params.limit;
    }
    if (params.userId !== undefined) {
      queryParameters['user_id'] = params.userId;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/users/{id}/tracks/remixed`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, jsonValue => UserTracksRemixedResponseFromJSON(jsonValue));
  }
  /**
   * Gets tracks owned by the user which have been remixed by another track
   */
  async getUserTracksRemixed(params, initOverrides) {
    const response = await this.getUserTracksRemixedRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Get the tracks the user recently listened to.
   */
  async getUsersTrackHistoryRaw(params, initOverrides) {
    if (params.id === null || params.id === undefined) {
      throw new RequiredError$1('id', 'Required parameter params.id was null or undefined when calling getUsersTrackHistory.');
    }
    const queryParameters = {};
    if (params.offset !== undefined) {
      queryParameters['offset'] = params.offset;
    }
    if (params.limit !== undefined) {
      queryParameters['limit'] = params.limit;
    }
    if (params.query !== undefined) {
      queryParameters['query'] = params.query;
    }
    if (params.sortMethod !== undefined) {
      queryParameters['sort_method'] = params.sortMethod;
    }
    if (params.sortDirection !== undefined) {
      queryParameters['sort_direction'] = params.sortDirection;
    }
    if (params.userId !== undefined) {
      queryParameters['user_id'] = params.userId;
    }
    const headerParameters = {};
    if (params.encodedDataMessage !== undefined && params.encodedDataMessage !== null) {
      headerParameters['Encoded-Data-Message'] = String(params.encodedDataMessage);
    }
    if (params.encodedDataSignature !== undefined && params.encodedDataSignature !== null) {
      headerParameters['Encoded-Data-Signature'] = String(params.encodedDataSignature);
    }
    const response = await this.request({
      path: `/users/{id}/history/tracks`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, jsonValue => HistoryResponseFromJSON(jsonValue));
  }
  /**
   * Get the tracks the user recently listened to.
   */
  async getUsersTrackHistory(params, initOverrides) {
    const response = await this.getUsersTrackHistoryRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Search for users that match the given query
   */
  async searchUsersRaw(params, initOverrides) {
    const queryParameters = {};
    if (params.offset !== undefined) {
      queryParameters['offset'] = params.offset;
    }
    if (params.limit !== undefined) {
      queryParameters['limit'] = params.limit;
    }
    if (params.query !== undefined) {
      queryParameters['query'] = params.query;
    }
    if (params.genre) {
      queryParameters['genre'] = params.genre;
    }
    if (params.sortMethod !== undefined) {
      queryParameters['sort_method'] = params.sortMethod;
    }
    if (params.isVerified !== undefined) {
      queryParameters['is_verified'] = params.isVerified;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/users/search`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, jsonValue => UserSearchFromJSON(jsonValue));
  }
  /**
   * Search for users that match the given query
   */
  async searchUsers() {
    let params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let initOverrides = arguments.length > 1 ? arguments[1] : undefined;
    const response = await this.searchUsersRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Verify if the given jwt ID token was signed by the subject (user) in the payload
   */
  async verifyIDTokenRaw(params, initOverrides) {
    if (params.token === null || params.token === undefined) {
      throw new RequiredError$1('token', 'Required parameter params.token was null or undefined when calling verifyIDToken.');
    }
    const queryParameters = {};
    if (params.token !== undefined) {
      queryParameters['token'] = params.token;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/users/verify_token`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse$1(response, jsonValue => VerifyTokenFromJSON(jsonValue));
  }
  /**
   * Verify if the given jwt ID token was signed by the subject (user) in the payload
   */
  async verifyIDToken(params, initOverrides) {
    const response = await this.verifyIDTokenRaw(params, initOverrides);
    return await response.value();
  }
}
/**
 * @export
 */
const GetAIAttributedTracksByUserHandleSortEnum$1 = {
  Date: 'date',
  Plays: 'plays'
};
/**
 * @export
 */
const GetAIAttributedTracksByUserHandleSortMethodEnum$1 = {
  Title: 'title',
  ArtistName: 'artist_name',
  ReleaseDate: 'release_date',
  LastListenDate: 'last_listen_date',
  AddedDate: 'added_date',
  Plays: 'plays',
  Reposts: 'reposts',
  Saves: 'saves',
  MostListensByUser: 'most_listens_by_user'
};
/**
 * @export
 */
const GetAIAttributedTracksByUserHandleSortDirectionEnum$1 = {
  Asc: 'asc',
  Desc: 'desc'
};
/**
 * @export
 */
const GetAIAttributedTracksByUserHandleFilterTracksEnum$1 = {
  All: 'all',
  Public: 'public',
  Unlisted: 'unlisted'
};
/**
 * @export
 */
const GetAlbumsByUserSortMethodEnum$1 = {
  Recent: 'recent',
  Popular: 'popular'
};
/**
 * @export
 */
const GetPlaylistsByUserSortMethodEnum$1 = {
  Recent: 'recent',
  Popular: 'popular'
};
/**
 * @export
 */
const GetTracksByUserSortEnum$1 = {
  Date: 'date',
  Plays: 'plays'
};
/**
 * @export
 */
const GetTracksByUserSortMethodEnum$1 = {
  Title: 'title',
  ArtistName: 'artist_name',
  ReleaseDate: 'release_date',
  LastListenDate: 'last_listen_date',
  AddedDate: 'added_date',
  Plays: 'plays',
  Reposts: 'reposts',
  Saves: 'saves',
  MostListensByUser: 'most_listens_by_user'
};
/**
 * @export
 */
const GetTracksByUserSortDirectionEnum$1 = {
  Asc: 'asc',
  Desc: 'desc'
};
/**
 * @export
 */
const GetTracksByUserFilterTracksEnum$1 = {
  All: 'all',
  Public: 'public',
  Unlisted: 'unlisted'
};
/**
 * @export
 */
const GetUserRecommendedTracksTimeRangeEnum$1 = {
  Week: 'week',
  Month: 'month',
  AllTime: 'allTime'
};
/**
 * @export
 */
const GetUsersTrackHistorySortMethodEnum$1 = {
  Title: 'title',
  ArtistName: 'artist_name',
  ReleaseDate: 'release_date',
  LastListenDate: 'last_listen_date',
  AddedDate: 'added_date',
  Plays: 'plays',
  Reposts: 'reposts',
  Saves: 'saves',
  MostListensByUser: 'most_listens_by_user'
};
/**
 * @export
 */
const GetUsersTrackHistorySortDirectionEnum$1 = {
  Asc: 'asc',
  Desc: 'desc'
};
/**
 * @export
 */
const SearchUsersSortMethodEnum = {
  Relevant: 'relevant',
  Popular: 'popular',
  Recent: 'recent'
};

// Extend that new class
class ResolveApi extends BaseAPI$1 {
  /**
   * Resolves a provided Audius app URL to the API resource it represents
   */
  async resolveRaw(params) {
    if (params.url === null || params.url === undefined) {
      throw new RequiredError$1('url', 'Required parameter params.url was null or undefined when calling resolve.');
    }
    const queryParameters = {};
    if (params.url !== undefined) {
      queryParameters.url = params.url;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/resolve`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    });
    return new JSONApiResponse$1(response, json => {
      var _json$data;
      const data = (_json$data = json === null || json === void 0 ? void 0 : json.data) !== null && _json$data !== void 0 ? _json$data : {};
      if (instanceOfTrack(TrackFromJSONTyped(data))) {
        return TrackResponseFromJSON(json);
      } else if (Array.isArray(data) && data.length > 0 && instanceOfPlaylist(PlaylistFromJSONTyped(data[0]))) {
        return PlaylistResponseFromJSON(json);
      } else if (instanceOfUser(UserFromJSONTyped(data))) {
        return UserResponseFromJSON(json);
      } else {
        throw new ResponseError$1(response, 'Invalid response type');
      }
    });
  }
  /**
   * Resolves a provided Audius app URL to the API resource it represents
   */
  async resolve(params) {
    return await (await this.resolveRaw(params)).value();
  }
  /**
   * Typeguard to check if a resolve response is a track
   */
  static instanceOfTrackResponse(response) {
    return !!response.data && instanceOfTrack(response.data);
  }
  /**
   * Typeguard to check if a resolve response is a playlist
   */
  static instanceOfPlaylistResponse(response) {
    return !!response.data && Array.isArray(response.data) && !!response.data[0] && instanceOfPlaylist(response.data[0]);
  }
  /**
   * Typeguard to check if a resolve response is a user
   */
  static instanceOfUserResponse(response) {
    return !!response.data && instanceOfUser(response.data);
  }
}

class ParseRequestError extends Error {
  constructor(method, innerError) {
    super(`'${method}' => ${innerError.message}`);
    _defineProperty$1(this, "method", void 0);
    _defineProperty$1(this, "innerError", void 0);
    _defineProperty$1(this, "name", 'ParseRequestError');
    this.method = method;
    this.innerError = innerError;
  }
}
/**
 * @param name Name of the method for which the parameters are being parsed
 * @param schema Zod schema that defines the shape of the request parameters
 * @returns The parsed data or throws an error
 */
const parseParams = (name, schema) => async params => {
  const result = await schema.safeParseAsync(params);
  if (!result.success) {
    throw new ParseRequestError(name, result.error);
  }
  return result.data;
};

/**
 * 1. Converts amounts to bigints
 * 2. Spreads the extraAmount to each split
 * 3. Creates user banks for recipients as necessary
 * 4. Returns a simplified splits structure, a list of account/amount pairs
 */
const prepareSplits = async _ref => {
  let {
    splits,
    extraAmount,
    claimableTokensClient,
    logger
  } = _ref;
  const userSplits = splits.filter(s => !!s.userId);
  const userSplitCount = userSplits.length;
  const networkSplit = splits.filter(s => !s.userId);
  logger.debug(`Splitting the extra ${extraAmount} between ${userSplitCount} user(s)...`);
  // Convert splits to big int and spread extra amount to every split
  let amountSplits = userSplits.map((split, index) => {
    const amountToAdd = extraAmount / BigInt(userSplitCount - index);
    extraAmount = USDC(extraAmount - amountToAdd).value;
    return {
      ...split,
      amount: BigInt(split.amount) + amountToAdd
    };
  });
  // Add network split if it exists
  amountSplits = amountSplits.concat(networkSplit.map(split => ({
    ...split,
    amount: BigInt(split.amount)
  })));
  if (extraAmount > 0) {
    logger.debug('Calculated splits after extra amount:', amountSplits);
  }
  // Check for user banks as needed
  amountSplits = await Promise.all(amountSplits.map(async split => {
    if (!split.payoutWallet && split.ethWallet) {
      logger.debug('Deriving user bank for user...', {
        userId: split.userId
      });
      const {
        userBank,
        didExist
      } = await claimableTokensClient.getOrCreateUserBank({
        ethWallet: split.ethWallet,
        mint: 'USDC'
      });
      if (!didExist) {
        logger.debug('Created user bank', {
          userId: split.userId,
          userBank: userBank.toBase58()
        });
      }
      split.payoutWallet = userBank.toBase58();
    }
    return split;
  }));
  return amountSplits.map(split => ({
    wallet: split.payoutWallet,
    amount: split.amount
  }));
};

var Action;
(function (Action) {
  Action["CREATE"] = "Create";
  Action["UPDATE"] = "Update";
  Action["DELETE"] = "Delete";
  Action["VERIFY"] = "Verify";
  Action["FOLLOW"] = "Follow";
  Action["UNFOLLOW"] = "Unfollow";
  Action["SAVE"] = "Save";
  Action["SHARE"] = "Share";
  Action["UNSAVE"] = "Unsave";
  Action["REPOST"] = "Repost";
  Action["UNREPOST"] = "Unrepost";
  Action["SUBSCRIBE"] = "Subscribe";
  Action["UNSUBSCRIBE"] = "Unsubscribe";
  Action["VIEW"] = "View";
  Action["VIEW_PLAYLIST"] = "ViewPlaylist";
  Action["APPROVE"] = "Approve";
  Action["REJECT"] = "Reject";
  Action["DOWNLOAD"] = "Download";
  Action["REACT"] = "React";
  Action["UNREACT"] = "Unreact";
  Action["REPORT"] = "Report";
  Action["PIN"] = "Pin";
  Action["UNPIN"] = "Unpin";
  Action["MUTE"] = "Mute";
  Action["UNMUTE"] = "Unmute";
  Action["ADD_EMAIL"] = "AddEmail";
  Action["GRANT_ACCESS"] = "GrantAccess";
})(Action || (Action = {}));
var EntityType;
(function (EntityType) {
  EntityType["PLAYLIST"] = "Playlist";
  EntityType["TRACK"] = "Track";
  EntityType["USER"] = "User";
  EntityType["USER_REPLICA_SET"] = "UserReplicaSet";
  EntityType["NOTIFICATION"] = "Notification";
  EntityType["DEVELOPER_APP"] = "DeveloperApp";
  EntityType["GRANT"] = "Grant";
  EntityType["DASHBOARD_WALLET_USER"] = "DashboardWalletUser";
  EntityType["TIP"] = "Tip";
  EntityType["COMMENT"] = "Comment";
  EntityType["ENCRYPTED_EMAIL"] = "EncryptedEmail";
  EntityType["EMAIL_ACCESS"] = "EmailAccess";
  EntityType["ASSOCIATED_WALLET"] = "AssociatedWallet";
  EntityType["COLLECTIBLES"] = "Collectibles";
  EntityType["EVENT"] = "Event";
})(EntityType || (EntityType = {}));
var BlockConfirmation;
(function (BlockConfirmation) {
  BlockConfirmation["CONFIRMED"] = "CONFIRMED";
  BlockConfirmation["DENIED"] = "DENIED";
  BlockConfirmation["UNKNOWN"] = "UNKNOWN";
})(BlockConfirmation || (BlockConfirmation = {}));

const HASH_SALT = 'azowernasdfoia';
const MIN_LENGTH = 5;
const hashids = new Hashids(HASH_SALT, MIN_LENGTH);
/**
 * Decodes a string id into an int. Returns null if an invalid ID.
 */
const decodeHashId = id => {
  try {
    const ids = hashids.decode(id);
    if (!ids.length) return null;
    const num = Number(ids[0]);
    if (isNaN(num)) return null;
    return num;
  } catch (e) {
    return null;
  }
};
/**
 * Encodes an int to a string based hashid
 */
const encodeHashId = id => {
  try {
    if (id === null) return null;
    const encodedId = hashids.encode(id);
    return encodedId;
  } catch (e) {
    return null;
  }
};

/**
 * Calls fn and then retries once after 500ms, again after 1500ms, and again after 4000ms
 */
const retry3 = async function (fn) {
  let onRetry = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _err => {};
  return await retry(fn, {
    minTimeout: 500,
    maxTimeout: 4000,
    factor: 3,
    retries: 3,
    onRetry
  });
};

class TrackUploadHelper extends BaseAPI$1 {
  async generateId(type) {
    const response = await this.request({
      path: `/${type}s/unclaimed_id`,
      method: 'GET',
      headers: {},
      query: {
        noCache: Math.floor(Math.random() * 1000).toString()
      }
    });
    const {
      data
    } = await response.json();
    const id = decodeHashId(data);
    if (id === null) {
      throw new Error(`Could not generate ${type} id`);
    }
    return id;
  }
  transformTrackUploadMetadata(inputMetadata, userId) {
    var _metadata$streamCondi;
    const metadata = {
      ...inputMetadata,
      ownerId: userId
    };
    const isStreamGated = metadata.isStreamGated;
    const isUsdcGated = 'usdc_purchase' in ((_metadata$streamCondi = metadata.streamConditions) !== null && _metadata$streamCondi !== void 0 ? _metadata$streamCondi : {});
    const isUnlisted = metadata.isUnlisted;
    // If track is stream gated and not usdc purchase gated, set remixes to false
    if (isStreamGated && !isUsdcGated && metadata.fieldVisibility) {
      metadata.fieldVisibility.remixes = false;
    }
    // If track is public, set required visibility fields to true
    if (!isUnlisted) {
      metadata.fieldVisibility = {
        ...metadata.fieldVisibility,
        genre: true,
        mood: true,
        tags: true,
        share: true,
        playCount: true
      };
    }
    return metadata;
  }
  populateTrackMetadataWithUploadResponse(trackMetadata, audioResponse, coverArtResponse) {
    var _audioResponse$audio_, _audioResponse$audio_2;
    return {
      ...trackMetadata,
      trackSegments: [],
      trackCid: audioResponse.results['320'],
      previewCid: trackMetadata.previewStartSeconds !== undefined && trackMetadata.previewStartSeconds !== null ? audioResponse.results[`320_preview|${trackMetadata.previewStartSeconds}`] : trackMetadata.previewCid,
      origFileCid: audioResponse.orig_file_cid,
      origFilename: audioResponse.orig_filename || trackMetadata.origFilename,
      audioUploadId: audioResponse.id,
      coverArtSizes: coverArtResponse === null || coverArtResponse === void 0 ? void 0 : coverArtResponse.id,
      duration: parseInt(audioResponse.probe.format.duration, 10),
      bpm: (_audioResponse$audio_ = audioResponse.audio_analysis_results) !== null && _audioResponse$audio_ !== void 0 && _audioResponse$audio_.bpm ? audioResponse.audio_analysis_results.bpm : trackMetadata.bpm,
      musicalKey: (_audioResponse$audio_2 = audioResponse.audio_analysis_results) !== null && _audioResponse$audio_2 !== void 0 && _audioResponse$audio_2.key ? audioResponse.audio_analysis_results.key : trackMetadata.musicalKey,
      audioAnalysisErrorCount: audioResponse.audio_analysis_error_count || 0
    };
  }
  extractMediorumUploadOptions(metadata) {
    const uploadOptions = {};
    if (metadata.previewStartSeconds !== undefined && metadata.previewStartSeconds !== null) {
      uploadOptions.previewStartSeconds = metadata.previewStartSeconds.toString();
    }
    if (metadata.placementHosts) {
      uploadOptions.placement_hosts = metadata.placementHosts;
    }
    return uploadOptions;
  }
}

const DDEXResourceContributor = z.object({
  name: z.string(),
  roles: z.array(z.string()),
  sequence_number: z.optional(z.number())
}).strict();
const DDEXCopyright = z.object({
  year: z.string(),
  text: z.string()
}).strict();
const DDEXRightsController = z.object({
  name: z.string(),
  roles: z.array(z.string()),
  rights_share_unknown: z.optional(z.string())
}).strict();

/**
 * Type representing a file in Node environment
 */
const NodeFileSchema = z.object({
  buffer: z.custom(data => data),
  name: z.optional(z.string()),
  type: z.optional(z.string())
});
const BrowserFileSchema = z.custom(data => data);
const NativeFileSchema = z.object({
  uri: z.string(),
  name: z.string().nullable(),
  type: z.string().nullable(),
  copyError: z.optional(z.string()),
  fileCopyUri: z.optional(z.string()).nullable(),
  size: z.optional(z.number()).nullable()
});
/**
 * Type representing a file in Node and browser environments
 */
const CrossPlatformFileSchema = z.union([NodeFileSchema, BrowserFileSchema, NativeFileSchema]);
const isNodeFile = file => {
  if (file && file.buffer) {
    return true;
  }
  return false;
};
const isNativeFile = file => {
  if (file && file.uri) {
    return true;
  }
  return false;
};
const ALLOWED_IMAGE_MIME_TYPES = ['image/jpeg', 'image/png', 'image/bmp', 'image/tiff', 'image/gif', 'image/webp'];
const ALLOWED_AUDIO_MIME_TYPES_REGEX = /audio\/.+/;
const getFileType = async file => {
  if (isNativeFile(file)) {
    return {
      mime: file.type
    };
  }
  let fileTypeBrowser;
  if (typeof window !== 'undefined' && window) {
    fileTypeBrowser = await import('./browser-15461226.js').then(function (n) { return n.b; });
  }
  if (isNodeFile(file)) {
    return file.type ? {
      mime: file.type
    } : await fileType.fromBuffer(file.buffer);
  } else {
    return await fileTypeBrowser.fromBlob(file);
  }
};
const ImageFile = CrossPlatformFileSchema.refine(async file => {
  const fileType = await getFileType(file);
  return fileType && ALLOWED_IMAGE_MIME_TYPES.includes(fileType.mime);
}, `Image file has invalid file type. Supported file types are: ${ALLOWED_IMAGE_MIME_TYPES.join(', ')}`);
const AudioFile = CrossPlatformFileSchema.refine(async file => {
  const fileType = await getFileType(file);
  return fileType && ALLOWED_AUDIO_MIME_TYPES_REGEX.test(fileType.mime);
}, `Audio file has invalid file type. Supported file types are: audio/*`);

var Genre;
(function (Genre) {
  Genre["ALL"] = "All Genres";
  Genre["ELECTRONIC"] = "Electronic";
  Genre["ROCK"] = "Rock";
  Genre["METAL"] = "Metal";
  Genre["ALTERNATIVE"] = "Alternative";
  Genre["HIP_HOP_RAP"] = "Hip-Hop/Rap";
  Genre["EXPERIMENTAL"] = "Experimental";
  Genre["PUNK"] = "Punk";
  Genre["FOLK"] = "Folk";
  Genre["POP"] = "Pop";
  Genre["AMBIENT"] = "Ambient";
  Genre["SOUNDTRACK"] = "Soundtrack";
  Genre["WORLD"] = "World";
  Genre["JAZZ"] = "Jazz";
  Genre["ACOUSTIC"] = "Acoustic";
  Genre["FUNK"] = "Funk";
  Genre["R_AND_B_SOUL"] = "R&B/Soul";
  Genre["DEVOTIONAL"] = "Devotional";
  Genre["CLASSICAL"] = "Classical";
  Genre["REGGAE"] = "Reggae";
  Genre["PODCASTS"] = "Podcasts";
  Genre["COUNTRY"] = "Country";
  Genre["SPOKEN_WORK"] = "Spoken Word";
  Genre["COMEDY"] = "Comedy";
  Genre["BLUES"] = "Blues";
  Genre["KIDS"] = "Kids";
  Genre["AUDIOBOOKS"] = "Audiobooks";
  Genre["LATIN"] = "Latin";
  Genre["LOFI"] = "Lo-Fi";
  Genre["HYPERPOP"] = "Hyperpop";
  Genre["DANCEHALL"] = "Dancehall";
  // Electronic Subgenres
  Genre["TECHNO"] = "Techno";
  Genre["TRAP"] = "Trap";
  Genre["HOUSE"] = "House";
  Genre["TECH_HOUSE"] = "Tech House";
  Genre["DEEP_HOUSE"] = "Deep House";
  Genre["DISCO"] = "Disco";
  Genre["ELECTRO"] = "Electro";
  Genre["JUNGLE"] = "Jungle";
  Genre["PROGRESSIVE_HOUSE"] = "Progressive House";
  Genre["HARDSTYLE"] = "Hardstyle";
  Genre["GLITCH_HOP"] = "Glitch Hop";
  Genre["TRANCE"] = "Trance";
  Genre["FUTURE_BASS"] = "Future Bass";
  Genre["FUTURE_HOUSE"] = "Future House";
  Genre["TROPICAL_HOUSE"] = "Tropical House";
  Genre["DOWNTEMPO"] = "Downtempo";
  Genre["DRUM_AND_BASS"] = "Drum & Bass";
  Genre["DUBSTEP"] = "Dubstep";
  Genre["JERSEY_CLUB"] = "Jersey Club";
  Genre["VAPORWAVE"] = "Vaporwave";
  Genre["MOOMBAHTON"] = "Moombahton";
})(Genre || (Genre = {}));

const OptionalHashId = z.string().nullable().optional().transform(data => {
  var _decodeHashId;
  return data ? (_decodeHashId = decodeHashId(data)) !== null && _decodeHashId !== void 0 ? _decodeHashId : undefined : undefined;
});
const HashId = z.string().transform((data, context) => {
  const id = decodeHashId(data);
  if (id === null) {
    context.addIssue({
      code: z.ZodIssueCode.custom,
      message: 'Hash id is invalid'
    });
    return z.NEVER;
  }
  return id;
});
const OptionalId = z.number().nullable().optional().transform(data => {
  var _encodeHashId;
  return data ? (_encodeHashId = encodeHashId(data)) !== null && _encodeHashId !== void 0 ? _encodeHashId : undefined : undefined;
});
const Id = z.number().transform((data, context) => {
  const id = encodeHashId(data);
  if (id === null) {
    context.addIssue({
      code: z.ZodIssueCode.custom,
      message: 'Hash id is invalid'
    });
    return z.NEVER;
  }
  return id;
});

var Mood;
(function (Mood) {
  Mood["PEACEFUL"] = "Peaceful";
  Mood["ROMANTIC"] = "Romantic";
  Mood["SENTIMENTAL"] = "Sentimental";
  Mood["TENDER"] = "Tender";
  Mood["EASYGOING"] = "Easygoing";
  Mood["YEARNING"] = "Yearning";
  Mood["SOPHISTICATED"] = "Sophisticated";
  Mood["SENSUAL"] = "Sensual";
  Mood["COOL"] = "Cool";
  Mood["GRITTY"] = "Gritty";
  Mood["MELANCHOLY"] = "Melancholy";
  Mood["SERIOUS"] = "Serious";
  Mood["BROODING"] = "Brooding";
  Mood["FIERY"] = "Fiery";
  Mood["DEFIANT"] = "Defiant";
  Mood["AGGRESSIVE"] = "Aggressive";
  Mood["ROWDY"] = "Rowdy";
  Mood["EXCITED"] = "Excited";
  Mood["ENERGIZING"] = "Energizing";
  Mood["EMPOWERING"] = "Empowering";
  Mood["STIRRING"] = "Stirring";
  Mood["UPBEAT"] = "Upbeat";
  Mood["OTHER"] = "Other";
})(Mood || (Mood = {}));

const PublicKeySchema = z.union([z.string().transform((data, ctx) => {
  try {
    return new PublicKey(data);
  } catch (e) {
    ctx.addIssue({
      code: z.ZodIssueCode.custom,
      message: e instanceof Error ? e.message : 'Invalid PublicKey input'
    });
  }
  return z.NEVER;
}), z.custom(data => {
  return data instanceof PublicKey;
})]);
const TokenNameSchema = z.enum(['wAUDIO', 'USDC', 'BONK']);
const MintSchema = z.union([TokenNameSchema, PublicKeySchema]);
const RelaySchema = z.object({
  transaction: z.custom(),
  /**
   * Confirmation options used when sending the transaction on the server.
   * @see {@link https://solana-labs.github.io/solana-web3.js/classes/Connection.html#confirmTransaction confirmTransaction}
   */
  confirmationOptions: z.object({
    /**
     * The confirmation strategy to use when confirming.
     * @see {@link https://solana-labs.github.io/solana-web3.js/types/TransactionConfirmationStrategy.html ConfirmationStrategy}
     * @see {@link https://solana-labs.github.io/solana-web3.js/types/DurableNonceTransactionConfirmationStrategy.html DurableNonceTransactionConfirmationStrategy}
     * @see {@link https://solana-labs.github.io/solana-web3.js/types/BlockheightBasedTransactionConfirmationStrategy.html BlockhashBasedTransactionConfirmationStrategy}
     */
    strategy: z.union([z.object({
      blockhash: z.string(),
      lastValidBlockHeight: z.number()
    }), z.object({
      minContextSlot: z.number(),
      nonceAccountPubkey: PublicKeySchema,
      nonceValue: z.string()
    })]).optional(),
    /**
     * The commitment the server should confirm before responding.
     * Leave unset to have the server respond immediately after sending.
     * @see {@link https://solana-labs.github.io/solana-web3.js/types/Commitment.html Commitment}
     */
    commitment: z.enum(['processed', 'confirmed', 'finalized', 'recent', 'single', 'singleGossip', 'root', 'max']).optional()
  }).optional(),
  /**
   * Custom send options used when sending the transaction on the relay.
   * @see {@link https://solana-labs.github.io/solana-web3.js/types/SendOptions.html SendOptions}
   */
  sendOptions: z.custom().optional()
}).strict();
const LaunchCoinSchema = z.object({
  name: z.string().min(1, 'Name is required'),
  symbol: z.string().min(1, 'Symbol is required'),
  description: z.string().min(1, 'Description is required'),
  walletPublicKey: PublicKeySchema,
  initialBuyAmountAudio: z.string().optional(),
  image: z.custom(data => {
    return data instanceof Blob;
  }, 'Image file is required')
}).strict();

/**
 * Client for the Solana Relay Plugin on Discovery.
 */
class SolanaRelay extends BaseAPI$1 {
  constructor() {
    super(...arguments);
    /**
     * Public key of the currently selected transaction fee payer
     * from the selected Discovery Node.
     */
    _defineProperty$1(this, "feePayer", null);
  }
  /**
   * Gets a random fee payer public key from the selected discovery node's
   * Solana relay plugin.
   *
   * Used when relay transactions don't specify a fee payer override.
   */
  async getFeePayer(initOverrides) {
    if (this.feePayer !== null) {
      return this.feePayer;
    }
    const headerParameters = {
      'Content-Type': 'application/json'
    };
    const response = await this.request({
      path: '/feePayer',
      method: 'GET',
      headers: headerParameters
    }, initOverrides);
    const {
      feePayer
    } = await new JSONApiResponse$1(response, json => ({
      feePayer: !exists$2(json, 'feePayer') ? undefined : new PublicKey(json.feePayer)
    })).value();
    if (!feePayer) {
      throw new Error('Failed to get fee payer!');
    }
    this.feePayer = feePayer;
    return this.feePayer;
  }
  /**
   * Gets a location instruction to be sent along with a transaction.
   */
  async getLocationInstruction(initOverrides) {
    const headerParameters = {
      'Content-Type': 'application/json'
    };
    const response = await this.request({
      path: '/instruction/location',
      method: 'GET',
      headers: headerParameters
    }, initOverrides);
    const {
      instruction
    } = await new JSONApiResponse$1(response, json => ({
      instruction: new TransactionInstruction({
        keys: json.instruction.keys,
        programId: new PublicKey(json.instruction.programId),
        data: Buffer.from(json.instruction.data)
      })
    })).value();
    if (!instruction) {
      throw new Error('Failed to get instruction!');
    }
    return instruction;
  }
  /**
   * Relays a transaction to the selected discovery node's Solana relay plugin.
   */
  async relay(params, initOverrides) {
    const {
      transaction,
      confirmationOptions,
      sendOptions
    } = await parseParams('relay', RelaySchema)(params);
    const headerParameters = {
      'Content-Type': 'application/json'
    };
    const body = {
      transaction: Buffer.from(transaction.serialize()).toString('base64'),
      confirmationOptions,
      sendOptions
    };
    let response;
    try {
      response = await this.request({
        path: '/relay',
        method: 'POST',
        headers: headerParameters,
        body
      }, initOverrides);
    } catch (e) {
      // Catch response errors, and if possible, recreate the original
      // SendTransactionError to transparently raise to the caller.
      if (e instanceof Error && e.name === 'ResponseError') {
        const resp = e.response.clone();
        const body = await resp.json();
        if ('error' in body && 'transactionMessage' in body && 'signature' in body) {
          throw new SendTransactionError({
            action: body.error.indexOf('Simulation') > -1 ? 'simulate' : 'send',
            signature: body.signature,
            transactionMessage: body.transactionMessage,
            logs: body.transactionLogs
          });
        }
      }
      throw e;
    }
    return await new JSONApiResponse$1(response, json => {
      if (!exists$2(json, 'signature')) {
        throw new Error('Signature missing');
      }
      return {
        signature: json.signature
      };
    }).value();
  }
  /**
   * Launches a new artist coin on the launchpad with bonding curve.
   */
  async launchCoin(params) {
    const {
      name,
      symbol,
      description,
      walletPublicKey,
      initialBuyAmountAudio,
      image
    } = await parseParams('launchCoin', LaunchCoinSchema)(params);
    const headerParameters = {};
    // API uses multipart/form-data for the upload
    const formData = new FormData();
    formData.append('name', name);
    formData.append('symbol', symbol);
    formData.append('description', description);
    formData.append('walletPublicKey', walletPublicKey.toBase58());
    if (initialBuyAmountAudio) {
      formData.append('initialBuyAmountAudio', initialBuyAmountAudio.toString());
    }
    formData.append('image', image);
    const response = await this.request({
      path: '/launchpad/launch_coin',
      method: 'POST',
      headers: headerParameters,
      body: formData
    });
    return await new JSONApiResponse$1(response, json => {
      if (!exists$2(json, 'mintPublicKey')) {
        throw new Error('mintPublicKey missing from response');
      }
      if (!exists$2(json, 'createPoolTx')) {
        throw new Error('createPoolTx missing from response');
      }
      if (!exists$2(json, 'imageUri')) {
        throw new Error('imageUri missing from response');
      }
      return json;
    }).value();
  }
  /**
   * Gets a quote for the first buy transaction on the launchpad.
   * Returns quotes for SOL to AUDIO, SOL to USDC, and the bonding curve quote.
   */
  async getFirstBuyQuote(params, requestInitOverrides) {
    const audioInputAmount = 'audioInputAmount' in params ? params.audioInputAmount : undefined;
    const tokenOutputAmount = 'tokenOutputAmount' in params ? params.tokenOutputAmount : undefined;
    const noAudioInput = !audioInputAmount;
    const noTokenInput = !tokenOutputAmount;
    if (noAudioInput && noTokenInput) {
      throw new Error('Invalid arguments. Either solInputAmount or tokenOutputAmount must be provided');
    }
    const headerParameters = {};
    const queryParameters = audioInputAmount ? {
      audioInputAmount
    } : {
      tokenOutputAmount: tokenOutputAmount
    };
    const response = await this.request({
      path: '/launchpad/first_buy_quote',
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, requestInitOverrides);
    return await new JSONApiResponse$1(response, json => {
      if (!exists$2(json, 'audioInputAmount')) {
        throw new Error('audioInputAmount missing from response');
      }
      if (!exists$2(json, 'usdcValue')) {
        throw new Error('usdcValue missing from response');
      }
      if (!exists$2(json, 'tokenOutputAmount')) {
        throw new Error('tokenOutputAmount missing from response');
      }
      return {
        usdcValue: json.usdcValue,
        tokenOutputAmount: json.tokenOutputAmount,
        audioInputAmount: json.audioInputAmount,
        maxAudioInputAmount: json.maxAudioInputAmount,
        maxTokenOutputAmount: json.maxTokenOutputAmount
      };
    }).value();
  }
  /**
   * Gets launchpad config details such as max input/outut amounts & starting price.
   * These values only change if we decide to change our launchpad coin launch params.
   * We pull them from the server just to avoid having to hardcode values in the UI.
   */
  async getLaunchpadConfig(requestInitOverrides) {
    const headerParameters = {
      'Content-Type': 'application/json'
    };
    const queryParameters = {};
    const response = await this.request({
      path: '/launchpad/config',
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, requestInitOverrides);
    return await new JSONApiResponse$1(response, json => {
      return json;
    }).value();
  }
  /**
   * Claims creator trading fees from a dynamic bonding curve pool.
   */
  async claimFees(params, initOverrides) {
    const headerParameters = {
      'Content-Type': 'application/json'
    };
    const queryParameters = {
      tokenMint: params.tokenMint,
      ownerWalletAddress: params.ownerWalletAddress,
      receiverWalletAddress: params.receiverWalletAddress
    };
    const response = await this.request({
      path: '/launchpad/claim_fees',
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return await new JSONApiResponse$1(response, json => {
      return json;
    }).value();
  }
}

/**
 * Wallet adapter that uses the Solana Relay Plugin on Discovery Node.
 *
 * Implementing this interface allows consumers to choose to pay for their own
 * transactions rather than using our relay, simply by using their own wallet
 * app's existing wallet adapter in place of this class.
 *
 * @see {@link https://github.com/solana-labs/wallet-standard/blob/master/WALLET.md wallet-standard}
 * @see {@link https://github.com/solana-labs/wallet-adapter/blob/master/packages/wallets/phantom/src/adapter.ts Phantom Wallet Adapter}
 */
class SolanaRelayWalletAdapter {
  constructor(_ref) {
    let {
      solanaRelay
    } = _ref;
    _defineProperty$1(this, "name", 'AudiusSolanaWallet');
    _defineProperty$1(this, "url", '');
    _defineProperty$1(this, "icon", '');
    _defineProperty$1(this, "readyState", 'Loadable');
    _defineProperty$1(this, "supportedTransactionVersions", void 0);
    _defineProperty$1(this, "solanaRelay", void 0);
    _defineProperty$1(this, "_publicKey", null);
    _defineProperty$1(this, "_connecting", false);
    _defineProperty$1(this, "_connected", false);
    this.solanaRelay = solanaRelay;
  }
  get publicKey() {
    return this._publicKey;
  }
  get connecting() {
    return this._connecting;
  }
  get connected() {
    return this._connected;
  }
  async autoConnect() {
    await this.connect();
  }
  /**
   * On connection, grabs the fee payer from the Discovery Node plugin.
   */
  async connect() {
    this._connecting = true;
    this._publicKey = await this.solanaRelay.getFeePayer();
    if (!this._publicKey) {
      throw new Error('Failed to connect SolanaRelayWalletAdapter: Failed to get fee payer.');
    }
    this._connecting = false;
    this._connected = true;
  }
  async disconnect() {
    this._connected = false;
    this._publicKey = null;
  }
  /**
   * Sends a transaction using the relay to Discovery Node.
   * @param transaction the transaction to send.
   */
  async sendTransaction(transaction, _connection, sendOptions) {
    const {
      signature
    } = await this.solanaRelay.relay({
      transaction,
      sendOptions
    });
    return signature;
  }
}

const productionConfig = {
  network: {
    minVersion: '0.7.0',
    apiEndpoint: 'https://api.audius.co',
    storageNodes: [{
      endpoint: 'https://creatornode.audius.co',
      delegateOwnerWallet: '0xc8d0C29B6d540295e8fc8ac72456F2f4D41088c8'
    }, {
      endpoint: 'https://creatornode2.audius.co',
      delegateOwnerWallet: '0xf686647E3737d595C60c6DE2f5F90463542FE439'
    }, {
      endpoint: 'https://creatornode3.audius.co',
      delegateOwnerWallet: '0x0C32BE6328578E99b6F06E0e7A6B385EB8FC13d1'
    }, {
      endpoint: 'https://audius-content-1.figment.io',
      delegateOwnerWallet: '0xBfdE9a7DD3620CB6428463E9A9e9932B4d10fdc5'
    }, {
      endpoint: 'https://creatornode.audius.prod-eks-ap-northeast-1.staked.cloud',
      delegateOwnerWallet: '0x675086B880260D217963cF14F503272AEb44b2E9'
    }, {
      endpoint: 'https://audius-content-2.figment.io',
      delegateOwnerWallet: '0x6444212FFc23a4CcF7460f8Fe6D0e6074db59036'
    }, {
      endpoint: 'https://audius-content-3.figment.io',
      delegateOwnerWallet: '0xECEDCaABecb40ef4bE733BA47FaD612aeA1F396F'
    }, {
      endpoint: 'https://audius-content-4.figment.io',
      delegateOwnerWallet: '0x08fEF3884Db16E2E6211272cdC9Eee68E8b63b09'
    }, {
      endpoint: 'https://audius-content-5.figment.io',
      delegateOwnerWallet: '0x10fF8197f2e94eF880d940D2414E0A14983c3bFE'
    }, {
      endpoint: 'https://creatornode.audius1.prod-eks-ap-northeast-1.staked.cloud',
      delegateOwnerWallet: '0xC23Ee959E0B22a9B0F5dF18D7e7875cA4B6c4236'
    }, {
      endpoint: 'https://creatornode.audius2.prod-eks-ap-northeast-1.staked.cloud',
      delegateOwnerWallet: '0x51a5575dc04c1f5f2e39390d090aaf78554F5f7B'
    }, {
      endpoint: 'https://creatornode.audius3.prod-eks-ap-northeast-1.staked.cloud',
      delegateOwnerWallet: '0xe0b56BAe2276E016d3DB314Dd7374e596B0457ac'
    }, {
      endpoint: 'https://audius-content-6.figment.io',
      delegateOwnerWallet: '0x68a4Bd6b4177ffB025AF9844cBE4Fe31348AEE1D'
    }, {
      endpoint: 'https://audius-content-7.figment.io',
      delegateOwnerWallet: '0xf45a6DBf3ce0201F4012a19b1fB04D4f05B53a37'
    }, {
      endpoint: 'https://audius-content-8.figment.io',
      delegateOwnerWallet: '0x9708Fb04DeA029212126255B311a21F1F884cCB4'
    }, {
      endpoint: 'https://audius-content-9.figment.io',
      delegateOwnerWallet: '0x7c34c9709ed69513D55dF2020e799DA44fC52E6e'
    }, {
      endpoint: 'https://audius-content-10.figment.io',
      delegateOwnerWallet: '0xff753331CEa586DD5B23bd21222a3c902909F2dd'
    }, {
      endpoint: 'https://audius-content-11.figment.io',
      delegateOwnerWallet: '0xC9721F892BcC8822eb34237E875BE93904f11073'
    }, {
      endpoint: 'https://content.grassfed.network',
      delegateOwnerWallet: '0x33Ab85445c8A2690B9488e9fB5E6A9849d3a18d3'
    }, {
      endpoint: 'https://blockdaemon-audius-content-01.bdnodes.net',
      delegateOwnerWallet: '0x807C0fba7405aeb8b6a37A974df6259C6aB9bB1e'
    }, {
      endpoint: 'https://audius-content-1.cultur3stake.com',
      delegateOwnerWallet: '0xCEb6a23d6132Cfe329b3c8E3c45f9DDc28A62Bd4'
    }, {
      endpoint: 'https://audius-content-2.cultur3stake.com',
      delegateOwnerWallet: '0x2e9e7A4e35C3136fB651a0dBF8f91c9f5C27BBf7'
    }, {
      endpoint: 'https://audius-content-3.cultur3stake.com',
      delegateOwnerWallet: '0x742da6cAc2782FeA961bB7B9150a048F5167D1e1'
    }, {
      endpoint: 'https://audius-content-4.cultur3stake.com',
      delegateOwnerWallet: '0xcbb0cE7481685587b0988195Ff0cD6AA1A701657'
    }, {
      endpoint: 'https://audius-content-5.cultur3stake.com',
      delegateOwnerWallet: '0xFec4708155277D35d568aD6Ca322262577683584'
    }, {
      endpoint: 'https://audius-content-6.cultur3stake.com',
      delegateOwnerWallet: '0x3Db0E61591063310eEd22fd57E6f7F1ab2Bb538E'
    }, {
      endpoint: 'https://audius-content-7.cultur3stake.com',
      delegateOwnerWallet: '0xE6C00e7E8d582fD2856718a5439f1aeEB68e27E5'
    }, {
      endpoint: 'https://blockdaemon-audius-content-02.bdnodes.net',
      delegateOwnerWallet: '0x4Ad694B3fC34b3cC245aF6AA7B43C52ddD0d7AAE'
    }, {
      endpoint: 'https://blockdaemon-audius-content-03.bdnodes.net',
      delegateOwnerWallet: '0x8ea81225013719950E968DE0602c4Eca458fA9f4'
    }, {
      endpoint: 'https://blockdaemon-audius-content-04.bdnodes.net',
      delegateOwnerWallet: '0xcfFA8ACF0b04d9278eEE13928be264b2E9aaab97'
    }, {
      endpoint: 'https://blockdaemon-audius-content-05.bdnodes.net',
      delegateOwnerWallet: '0xB4Ff0cab630FB05a7fcEfec9E979a968b8f4fE55'
    }, {
      endpoint: 'https://blockdaemon-audius-content-06.bdnodes.net',
      delegateOwnerWallet: '0x7449da7d1548C11c481b87667EC9b2A8F20C13A0'
    }, {
      endpoint: 'https://blockdaemon-audius-content-07.bdnodes.net',
      delegateOwnerWallet: '0x00B1CA1A34257860f66e742eF163Ad30bF42d075'
    }, {
      endpoint: 'https://blockdaemon-audius-content-08.bdnodes.net',
      delegateOwnerWallet: '0x16650eDB44C720ea627d5a59ff0b4f74c37fe419'
    }, {
      endpoint: 'https://blockdaemon-audius-content-09.bdnodes.net',
      delegateOwnerWallet: '0xD5Cfcf4149c683516239fc653D5a470F3F4A606D'
    }, {
      endpoint: 'https://audius-content-8.cultur3stake.com',
      delegateOwnerWallet: '0xff432F81D0eb77DA5973Cf55e24A897882fdd3E6'
    }, {
      endpoint: 'https://blockchange-audius-content-01.bdnodes.net',
      delegateOwnerWallet: '0x8464c88502925a0076c381962F8B70b6EC892861'
    }, {
      endpoint: 'https://blockchange-audius-content-02.bdnodes.net',
      delegateOwnerWallet: '0x5e0D0BeDC11F0B512457f6f707A35703b1447Fb5'
    }, {
      endpoint: 'https://blockchange-audius-content-03.bdnodes.net',
      delegateOwnerWallet: '0xe3F1c416c3919bB2ffD78F1e38b9E81E8c80815F'
    }, {
      endpoint: 'https://audius-content-9.cultur3stake.com',
      delegateOwnerWallet: '0xB6f506557B2e9026743FeA6157e52F204D26690F'
    }, {
      endpoint: 'https://audius-content-10.cultur3stake.com',
      delegateOwnerWallet: '0x2AF4598D3CF95D8e76987c02BC8A8D71F58d49d5'
    }, {
      endpoint: 'https://audius-content-11.cultur3stake.com',
      delegateOwnerWallet: '0xB2684Cca5281d2bA6D9Ce66Cca215635FF2Ba466'
    }, {
      endpoint: 'https://audius-content-12.cultur3stake.com',
      delegateOwnerWallet: '0x28924C99822eA08bFCeDdE3a411308633948b349'
    }, {
      endpoint: 'https://audius-content-13.cultur3stake.com',
      delegateOwnerWallet: '0xcb23908aa0dCDef762ebEaA38391D8fFC69E6e8F'
    }, {
      endpoint: 'https://audius-content-14.cultur3stake.com',
      delegateOwnerWallet: '0xCbDa351492e52fdb2f0E7FBc440cA2047738b71C'
    }, {
      endpoint: 'https://audius-content-15.cultur3stake.com',
      delegateOwnerWallet: '0x2fE2652296c40BB22D33C6379558Bf63A25b4f9a'
    }, {
      endpoint: 'https://audius-content-16.cultur3stake.com',
      delegateOwnerWallet: '0x47367ED3Db5D9691d866cb09545DE7cccD571579'
    }, {
      endpoint: 'https://audius-content-17.cultur3stake.com',
      delegateOwnerWallet: '0xb472c555Ab9eA1D33543383d6d1F8885c97eF83A'
    }, {
      endpoint: 'https://audius-content-18.cultur3stake.com',
      delegateOwnerWallet: '0x4F62C17Dc54E58289354847974E1F246c8EAcf11'
    }, {
      endpoint: 'https://audius-content-12.figment.io',
      delegateOwnerWallet: '0x780641e157621621658F118375dc1B36Ea514d46'
    }, {
      endpoint: 'https://cn0.mainnet.audiusindex.org',
      delegateOwnerWallet: '0xf9b373E223b73473C59034072263f52aEF60133B'
    }, {
      endpoint: 'https://cn1.mainnet.audiusindex.org',
      delegateOwnerWallet: '0x9b0D01bd7F01BD6916Ba139743Ce9C524B9375Dd'
    }, {
      endpoint: 'https://cn2.mainnet.audiusindex.org',
      delegateOwnerWallet: '0xf6e297203c0086dc229DAE17F5b61a15F42A1A00'
    }, {
      endpoint: 'https://cn3.mainnet.audiusindex.org',
      delegateOwnerWallet: '0x24C4b2cb6eC4c87a03F66723d8750dbe98Fa3e4f'
    }, {
      endpoint: 'https://audius-content-13.figment.io',
      delegateOwnerWallet: '0x33a2da466B14990E0124383204b06F9196f62d8e'
    }, {
      endpoint: 'https://audius-content-14.figment.io',
      delegateOwnerWallet: '0x817c513C1B702eA0BdD4F8C1204C60372f715006'
    }, {
      endpoint: 'https://cn4.mainnet.audiusindex.org',
      delegateOwnerWallet: '0x69e749266C59757dA81F8C659Be6B07ce5Bac6C9'
    }, {
      endpoint: 'https://audius-creator-1.theblueprint.xyz',
      delegateOwnerWallet: '0x0E0aF7035581C615d07372be16D99A9B64E5B2e9'
    }, {
      endpoint: 'https://audius-creator-2.theblueprint.xyz',
      delegateOwnerWallet: '0x3D0dD2Cd46c2658d228769f4a394662946A28987'
    }, {
      endpoint: 'https://audius-creator-3.theblueprint.xyz',
      delegateOwnerWallet: '0x292B0d5987a7DE879909C48a54f0853C211da5f3'
    }, {
      endpoint: 'https://audius-creator-4.theblueprint.xyz',
      delegateOwnerWallet: '0xA815f8108C2772D24D7DCB866c861148f043224D'
    }, {
      endpoint: 'https://audius-creator-5.theblueprint.xyz',
      delegateOwnerWallet: '0x65Fe5BEf65A0E0b0520d6beE7767ea6Da7f792f6'
    }, {
      endpoint: 'https://audius-creator-6.theblueprint.xyz',
      delegateOwnerWallet: '0x19B026B0f0Dbf619DBf8C4Efb0190308ace56366'
    }, {
      endpoint: 'https://creatornode.audius8.prod-eks-ap-northeast-1.staked.cloud',
      delegateOwnerWallet: '0xc69F344FCDbc9D747559c968562f682ABfBa442C'
    }, {
      endpoint: 'https://cn1.stuffisup.com',
      delegateOwnerWallet: '0x0D16f8bBfFF114B1a525Bf8b8d98ED177FA74AD3'
    }, {
      endpoint: 'https://audius-cn1.tikilabs.com',
      delegateOwnerWallet: '0x159200F84c2cF000b3A014cD4D8244500CCc36ca'
    }, {
      endpoint: 'https://audius-creator-7.theblueprint.xyz',
      delegateOwnerWallet: '0x720758adEa33433833c14e2516fA421261D0875e'
    }, {
      endpoint: 'https://cn1.shakespearetech.com',
      delegateOwnerWallet: '0x44955AD360652c302644F564B42D1458C584A4ec'
    }, {
      endpoint: 'https://cn2.shakespearetech.com',
      delegateOwnerWallet: '0x68835714d9c208f9d6F4953F0555507e492fd898'
    }, {
      endpoint: 'https://cn3.shakespearetech.com',
      delegateOwnerWallet: '0x7162Ee2b7F0cB9651fd2FA2838B0CAF225B2a8D3'
    }, {
      endpoint: 'https://audius-creator-8.theblueprint.xyz',
      delegateOwnerWallet: '0x078842E88B82e6a69549043269AE3aADD5581105'
    }, {
      endpoint: 'https://audius-creator-9.theblueprint.xyz',
      delegateOwnerWallet: '0x2DfC8152eF49e91b83638ad2bd0D2F9efC6f65b5'
    }, {
      endpoint: 'https://audius-creator-10.theblueprint.xyz',
      delegateOwnerWallet: '0x97BcBFA8289731d694440795094E831599Ab7A11'
    }, {
      endpoint: 'https://audius-creator-11.theblueprint.xyz',
      delegateOwnerWallet: '0xfe38c5Ea3579c9333fE302414fe1895F7a320beF'
    }, {
      endpoint: 'https://audius-creator-12.theblueprint.xyz',
      delegateOwnerWallet: '0x8C78ef541135e2cb037f91109fb8EE780fa4709d'
    }, {
      endpoint: 'https://audius-creator-13.theblueprint.xyz',
      delegateOwnerWallet: '0x75D2269D18C59CC2ED00a63a40367AC495E3F330'
    }],
    antiAbuseOracleNodes: {
      endpoints: ['https://discoveryprovider.audius.co', 'https://audius-oracle.creatorseed.com', 'https://oracle.audius.endl.net'],
      registeredAddresses: ['0x9811BA3eAB1F2Cd9A2dFeDB19e8c2a69729DC8b6', '0xe60d50356cd891f56B744165fcc1D8B352201A76', '0x7A03cFAE79266683D9706731D6E187868E939c9C']
    },
    identityService: 'https://identityservice.audius.co'
  },
  acdc: {
    entityManagerContractAddress: '0x1Cd8a543596D499B9b6E7a6eC15ECd2B7857Fd64',
    chainId: 31524
  },
  solana: {
    claimableTokensProgramAddress: 'Ewkv3JahEFRKkcJmpoKB7pXbnUHwjAyXiwEo4ZY2rezQ',
    rewardManagerProgramAddress: 'DDZDcYdQFEMwcu2Mwo75yGFjJ1mUQyyXLWzhZLEVFcei',
    rewardManagerStateAddress: '71hWFVYokLaN1PNYzTAWi13EfJ7Xt9VbSWUKsXUT8mxE',
    paymentRouterProgramAddress: 'paytYpX3LPN98TAeen6bFFeraGSuWnomZmCXjAsoqPa',
    stakingBridgeProgramAddress: 'stkB5DZziVJT1C1VmzvDdRtdWxfs5nwcHViiaNBDK31',
    rpcEndpoint: 'https://audius-fe.rpcpool.com',
    usdcTokenMint: 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v',
    wAudioTokenMint: '9LzCMqDgTKYz9Drzqnpgee3SGa89up3a247ypMj2xrqM',
    bonkTokenMint: 'DezXAZ8z7PnrnRJjz3wXBoRgixCa6xjnB7YaB1pPB263',
    rewardManagerLookupTableAddress: '4UQwpGupH66RgQrWRqmPM9Two6VJEE68VZ7GeqZ3mvVv'
  },
  ethereum: {
    rpcEndpoint: 'https://eth-client.audius.co',
    addresses: {
      ethRewardsManagerAddress: '0x5aa6B99A2B461bA8E97207740f0A689C5C39C3b0',
      serviceProviderFactoryAddress: '0xD17A9bc90c582249e211a4f4b16721e7f65156c8',
      serviceTypeManagerAddress: '0x9EfB0f4F38aFbb4b0984D00C126E97E21b8417C5',
      audiusTokenAddress: '0x18aAA7115705e8be94bfFEBDE57Af9BFc265B998',
      audiusWormholeAddress: '0x6E7a1F7339bbB62b23D44797b63e4258d283E095',
      delegateManagerAddress: '0x4d7968ebfD390D5E7926Cb3587C39eFf2F9FB225',
      stakingAddress: '0xe6D97B2099F142513be7A2a068bE040656Ae4591'
    }
  }
};

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear$1() {
  this.__data__ = [];
  this.size = 0;
}
var _listCacheClear = listCacheClear$1;

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq$4(value, other) {
  return value === other || value !== value && other !== other;
}
var eq_1 = eq$4;

var eq$3 = eq_1;

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf$4(array, key) {
  var length = array.length;
  while (length--) {
    if (eq$3(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}
var _assocIndexOf = assocIndexOf$4;

var assocIndexOf$3 = _assocIndexOf;

/** Used for built-in method references. */
var arrayProto = Array.prototype;

/** Built-in value references. */
var splice = arrayProto.splice;

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete$1(key) {
  var data = this.__data__,
    index = assocIndexOf$3(data, key);
  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}
var _listCacheDelete = listCacheDelete$1;

var assocIndexOf$2 = _assocIndexOf;

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet$1(key) {
  var data = this.__data__,
    index = assocIndexOf$2(data, key);
  return index < 0 ? undefined : data[index][1];
}
var _listCacheGet = listCacheGet$1;

var assocIndexOf$1 = _assocIndexOf;

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas$1(key) {
  return assocIndexOf$1(this.__data__, key) > -1;
}
var _listCacheHas = listCacheHas$1;

var assocIndexOf = _assocIndexOf;

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet$1(key, value) {
  var data = this.__data__,
    index = assocIndexOf(data, key);
  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}
var _listCacheSet = listCacheSet$1;

var listCacheClear = _listCacheClear,
  listCacheDelete = _listCacheDelete,
  listCacheGet = _listCacheGet,
  listCacheHas = _listCacheHas,
  listCacheSet = _listCacheSet;

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache$4(entries) {
  var index = -1,
    length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `ListCache`.
ListCache$4.prototype.clear = listCacheClear;
ListCache$4.prototype['delete'] = listCacheDelete;
ListCache$4.prototype.get = listCacheGet;
ListCache$4.prototype.has = listCacheHas;
ListCache$4.prototype.set = listCacheSet;
var _ListCache = ListCache$4;

var ListCache$3 = _ListCache;

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear$1() {
  this.__data__ = new ListCache$3();
  this.size = 0;
}
var _stackClear = stackClear$1;

/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete$1(key) {
  var data = this.__data__,
    result = data['delete'](key);
  this.size = data.size;
  return result;
}
var _stackDelete = stackDelete$1;

/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet$1(key) {
  return this.__data__.get(key);
}
var _stackGet = stackGet$1;

/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas$1(key) {
  return this.__data__.has(key);
}
var _stackHas = stackHas$1;

/** Detect free variable `global` from Node.js. */
var freeGlobal$1 = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
var _freeGlobal = freeGlobal$1;

var freeGlobal = _freeGlobal;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root$4 = freeGlobal || freeSelf || Function('return this')();
var _root = root$4;

var root$3 = _root;

/** Built-in value references. */
var Symbol$3 = root$3.Symbol;
var _Symbol = Symbol$3;

var Symbol$2 = _Symbol;

/** Used for built-in method references. */
var objectProto$a = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$8 = objectProto$a.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString$1 = objectProto$a.toString;

/** Built-in value references. */
var symToStringTag$1 = Symbol$2 ? Symbol$2.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag$1(value) {
  var isOwn = hasOwnProperty$8.call(value, symToStringTag$1),
    tag = value[symToStringTag$1];
  try {
    value[symToStringTag$1] = undefined;
    var unmasked = true;
  } catch (e) {}
  var result = nativeObjectToString$1.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag$1] = tag;
    } else {
      delete value[symToStringTag$1];
    }
  }
  return result;
}
var _getRawTag = getRawTag$1;

/** Used for built-in method references. */
var objectProto$9 = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto$9.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString$1(value) {
  return nativeObjectToString.call(value);
}
var _objectToString = objectToString$1;

var Symbol$1 = _Symbol,
  getRawTag = _getRawTag,
  objectToString = _objectToString;

/** `Object#toString` result references. */
var nullTag = '[object Null]',
  undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = Symbol$1 ? Symbol$1.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag$4(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
}
var _baseGetTag = baseGetTag$4;

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject$7(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}
var isObject_1 = isObject$7;

var baseGetTag$3 = _baseGetTag,
  isObject$6 = isObject_1;

/** `Object#toString` result references. */
var asyncTag = '[object AsyncFunction]',
  funcTag$1 = '[object Function]',
  genTag = '[object GeneratorFunction]',
  proxyTag = '[object Proxy]';

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction$3(value) {
  if (!isObject$6(value)) {
    return false;
  }
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.
  var tag = baseGetTag$3(value);
  return tag == funcTag$1 || tag == genTag || tag == asyncTag || tag == proxyTag;
}
var isFunction_1 = isFunction$3;

var root$2 = _root;

/** Used to detect overreaching core-js shims. */
var coreJsData$1 = root$2['__core-js_shared__'];
var _coreJsData = coreJsData$1;

var coreJsData = _coreJsData;

/** Used to detect methods masquerading as native. */
var maskSrcKey = function () {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? 'Symbol(src)_1.' + uid : '';
}();

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked$1(func) {
  return !!maskSrcKey && maskSrcKey in func;
}
var _isMasked = isMasked$1;

/** Used for built-in method references. */
var funcProto$2 = Function.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString$2 = funcProto$2.toString;

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */
function toSource$1(func) {
  if (func != null) {
    try {
      return funcToString$2.call(func);
    } catch (e) {}
    try {
      return func + '';
    } catch (e) {}
  }
  return '';
}
var _toSource = toSource$1;

var isFunction$2 = isFunction_1,
  isMasked = _isMasked,
  isObject$5 = isObject_1,
  toSource = _toSource;

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used for built-in method references. */
var funcProto$1 = Function.prototype,
  objectProto$8 = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString$1 = funcProto$1.toString;

/** Used to check objects for own properties. */
var hasOwnProperty$7 = objectProto$8.hasOwnProperty;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' + funcToString$1.call(hasOwnProperty$7).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative$1(value) {
  if (!isObject$5(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction$2(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}
var _baseIsNative = baseIsNative$1;

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue$1(object, key) {
  return object == null ? undefined : object[key];
}
var _getValue = getValue$1;

var baseIsNative = _baseIsNative,
  getValue = _getValue;

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative$3(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}
var _getNative = getNative$3;

var getNative$2 = _getNative,
  root$1 = _root;

/* Built-in method references that are verified to be native. */
var Map$3 = getNative$2(root$1, 'Map');
var _Map = Map$3;

var getNative$1 = _getNative;

/* Built-in method references that are verified to be native. */
var nativeCreate$4 = getNative$1(Object, 'create');
var _nativeCreate = nativeCreate$4;

var nativeCreate$3 = _nativeCreate;

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear$1() {
  this.__data__ = nativeCreate$3 ? nativeCreate$3(null) : {};
  this.size = 0;
}
var _hashClear = hashClear$1;

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete$1(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}
var _hashDelete = hashDelete$1;

var nativeCreate$2 = _nativeCreate;

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED$1 = '__lodash_hash_undefined__';

/** Used for built-in method references. */
var objectProto$7 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$6 = objectProto$7.hasOwnProperty;

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet$1(key) {
  var data = this.__data__;
  if (nativeCreate$2) {
    var result = data[key];
    return result === HASH_UNDEFINED$1 ? undefined : result;
  }
  return hasOwnProperty$6.call(data, key) ? data[key] : undefined;
}
var _hashGet = hashGet$1;

var nativeCreate$1 = _nativeCreate;

/** Used for built-in method references. */
var objectProto$6 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$5 = objectProto$6.hasOwnProperty;

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas$1(key) {
  var data = this.__data__;
  return nativeCreate$1 ? data[key] !== undefined : hasOwnProperty$5.call(data, key);
}
var _hashHas = hashHas$1;

var nativeCreate = _nativeCreate;

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet$1(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;
  return this;
}
var _hashSet = hashSet$1;

var hashClear = _hashClear,
  hashDelete = _hashDelete,
  hashGet = _hashGet,
  hashHas = _hashHas,
  hashSet = _hashSet;

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash$2(entries) {
  var index = -1,
    length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `Hash`.
Hash$2.prototype.clear = hashClear;
Hash$2.prototype['delete'] = hashDelete;
Hash$2.prototype.get = hashGet;
Hash$2.prototype.has = hashHas;
Hash$2.prototype.set = hashSet;
var _Hash = Hash$2;

var Hash$1 = _Hash,
  ListCache$2 = _ListCache,
  Map$2 = _Map;

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear$1() {
  this.size = 0;
  this.__data__ = {
    'hash': new Hash$1(),
    'map': new (Map$2 || ListCache$2)(),
    'string': new Hash$1()
  };
}
var _mapCacheClear = mapCacheClear$1;

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable$1(value) {
  var type = typeof value;
  return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
}
var _isKeyable = isKeyable$1;

var isKeyable = _isKeyable;

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData$4(map, key) {
  var data = map.__data__;
  return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
}
var _getMapData = getMapData$4;

var getMapData$3 = _getMapData;

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete$1(key) {
  var result = getMapData$3(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}
var _mapCacheDelete = mapCacheDelete$1;

var getMapData$2 = _getMapData;

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet$1(key) {
  return getMapData$2(this, key).get(key);
}
var _mapCacheGet = mapCacheGet$1;

var getMapData$1 = _getMapData;

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas$1(key) {
  return getMapData$1(this, key).has(key);
}
var _mapCacheHas = mapCacheHas$1;

var getMapData = _getMapData;

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet$1(key, value) {
  var data = getMapData(this, key),
    size = data.size;
  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}
var _mapCacheSet = mapCacheSet$1;

var mapCacheClear = _mapCacheClear,
  mapCacheDelete = _mapCacheDelete,
  mapCacheGet = _mapCacheGet,
  mapCacheHas = _mapCacheHas,
  mapCacheSet = _mapCacheSet;

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache$1(entries) {
  var index = -1,
    length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `MapCache`.
MapCache$1.prototype.clear = mapCacheClear;
MapCache$1.prototype['delete'] = mapCacheDelete;
MapCache$1.prototype.get = mapCacheGet;
MapCache$1.prototype.has = mapCacheHas;
MapCache$1.prototype.set = mapCacheSet;
var _MapCache = MapCache$1;

var ListCache$1 = _ListCache,
  Map$1 = _Map,
  MapCache = _MapCache;

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet$1(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache$1) {
    var pairs = data.__data__;
    if (!Map$1 || pairs.length < LARGE_ARRAY_SIZE - 1) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}
var _stackSet = stackSet$1;

var ListCache = _ListCache,
  stackClear = _stackClear,
  stackDelete = _stackDelete,
  stackGet = _stackGet,
  stackHas = _stackHas,
  stackSet = _stackSet;

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack$1(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}

// Add methods to `Stack`.
Stack$1.prototype.clear = stackClear;
Stack$1.prototype['delete'] = stackDelete;
Stack$1.prototype.get = stackGet;
Stack$1.prototype.has = stackHas;
Stack$1.prototype.set = stackSet;
var _Stack = Stack$1;

var getNative = _getNative;
var defineProperty$2 = function () {
  try {
    var func = getNative(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (e) {}
}();
var _defineProperty = defineProperty$2;

var defineProperty$1 = _defineProperty;

/**
 * The base implementation of `assignValue` and `assignMergeValue` without
 * value checks.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function baseAssignValue$3(object, key, value) {
  if (key == '__proto__' && defineProperty$1) {
    defineProperty$1(object, key, {
      'configurable': true,
      'enumerable': true,
      'value': value,
      'writable': true
    });
  } else {
    object[key] = value;
  }
}
var _baseAssignValue = baseAssignValue$3;

var baseAssignValue$2 = _baseAssignValue,
  eq$2 = eq_1;

/**
 * This function is like `assignValue` except that it doesn't assign
 * `undefined` values.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignMergeValue$2(object, key, value) {
  if (value !== undefined && !eq$2(object[key], value) || value === undefined && !(key in object)) {
    baseAssignValue$2(object, key, value);
  }
}
var _assignMergeValue = assignMergeValue$2;

/**
 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseFor$1(fromRight) {
  return function (object, iteratee, keysFunc) {
    var index = -1,
      iterable = Object(object),
      props = keysFunc(object),
      length = props.length;
    while (length--) {
      var key = props[fromRight ? length : ++index];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}
var _createBaseFor = createBaseFor$1;

var createBaseFor = _createBaseFor;

/**
 * The base implementation of `baseForOwn` which iterates over `object`
 * properties returned by `keysFunc` and invokes `iteratee` for each property.
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */
var baseFor$1 = createBaseFor();
var _baseFor = baseFor$1;

var _cloneBuffer = {exports: {}};

(function (module, exports) {
  var root = _root;

  /** Detect free variable `exports`. */
  var freeExports = exports && !exports.nodeType && exports;

  /** Detect free variable `module`. */
  var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

  /** Detect the popular CommonJS extension `module.exports`. */
  var moduleExports = freeModule && freeModule.exports === freeExports;

  /** Built-in value references. */
  var Buffer = moduleExports ? root.Buffer : undefined,
    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;

  /**
   * Creates a clone of  `buffer`.
   *
   * @private
   * @param {Buffer} buffer The buffer to clone.
   * @param {boolean} [isDeep] Specify a deep clone.
   * @returns {Buffer} Returns the cloned buffer.
   */
  function cloneBuffer(buffer, isDeep) {
    if (isDeep) {
      return buffer.slice();
    }
    var length = buffer.length,
      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
    buffer.copy(result);
    return result;
  }
  module.exports = cloneBuffer;
})(_cloneBuffer, _cloneBuffer.exports);

var root = _root;

/** Built-in value references. */
var Uint8Array$2 = root.Uint8Array;
var _Uint8Array = Uint8Array$2;

var Uint8Array$1 = _Uint8Array;

/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */
function cloneArrayBuffer$1(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array$1(result).set(new Uint8Array$1(arrayBuffer));
  return result;
}
var _cloneArrayBuffer = cloneArrayBuffer$1;

var cloneArrayBuffer = _cloneArrayBuffer;

/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */
function cloneTypedArray$1(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}
var _cloneTypedArray = cloneTypedArray$1;

/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function copyArray$1(source, array) {
  var index = -1,
    length = source.length;
  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}
var _copyArray = copyArray$1;

var isObject$4 = isObject_1;

/** Built-in value references. */
var objectCreate = Object.create;

/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} proto The object to inherit from.
 * @returns {Object} Returns the new object.
 */
var baseCreate$1 = function () {
  function object() {}
  return function (proto) {
    if (!isObject$4(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object.prototype = proto;
    var result = new object();
    object.prototype = undefined;
    return result;
  };
}();
var _baseCreate = baseCreate$1;

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg$1(func, transform) {
  return function (arg) {
    return func(transform(arg));
  };
}
var _overArg = overArg$1;

var overArg = _overArg;

/** Built-in value references. */
var getPrototype$2 = overArg(Object.getPrototypeOf, Object);
var _getPrototype = getPrototype$2;

/** Used for built-in method references. */
var objectProto$5 = Object.prototype;

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype$2(value) {
  var Ctor = value && value.constructor,
    proto = typeof Ctor == 'function' && Ctor.prototype || objectProto$5;
  return value === proto;
}
var _isPrototype = isPrototype$2;

var baseCreate = _baseCreate,
  getPrototype$1 = _getPrototype,
  isPrototype$1 = _isPrototype;

/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneObject$1(object) {
  return typeof object.constructor == 'function' && !isPrototype$1(object) ? baseCreate(getPrototype$1(object)) : {};
}
var _initCloneObject = initCloneObject$1;

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike$5(value) {
  return value != null && typeof value == 'object';
}
var isObjectLike_1 = isObjectLike$5;

var baseGetTag$2 = _baseGetTag,
  isObjectLike$4 = isObjectLike_1;

/** `Object#toString` result references. */
var argsTag$1 = '[object Arguments]';

/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */
function baseIsArguments$1(value) {
  return isObjectLike$4(value) && baseGetTag$2(value) == argsTag$1;
}
var _baseIsArguments = baseIsArguments$1;

var baseIsArguments = _baseIsArguments,
  isObjectLike$3 = isObjectLike_1;

/** Used for built-in method references. */
var objectProto$4 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$4 = objectProto$4.hasOwnProperty;

/** Built-in value references. */
var propertyIsEnumerable = objectProto$4.propertyIsEnumerable;

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
var isArguments$2 = baseIsArguments(function () {
  return arguments;
}()) ? baseIsArguments : function (value) {
  return isObjectLike$3(value) && hasOwnProperty$4.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
};
var isArguments_1 = isArguments$2;

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray$2 = Array.isArray;
var isArray_1 = isArray$2;

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER$1 = 9007199254740991;

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength$2(value) {
  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER$1;
}
var isLength_1 = isLength$2;

var isFunction$1 = isFunction_1,
  isLength$1 = isLength_1;

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike$3(value) {
  return value != null && isLength$1(value.length) && !isFunction$1(value);
}
var isArrayLike_1 = isArrayLike$3;

var isArrayLike$2 = isArrayLike_1,
  isObjectLike$2 = isObjectLike_1;

/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */
function isArrayLikeObject$1(value) {
  return isObjectLike$2(value) && isArrayLike$2(value);
}
var isArrayLikeObject_1 = isArrayLikeObject$1;

var isBuffer$2 = {exports: {}};

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}
var stubFalse_1 = stubFalse;

(function (module, exports) {
  var root = _root,
    stubFalse = stubFalse_1;

  /** Detect free variable `exports`. */
  var freeExports = exports && !exports.nodeType && exports;

  /** Detect free variable `module`. */
  var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

  /** Detect the popular CommonJS extension `module.exports`. */
  var moduleExports = freeModule && freeModule.exports === freeExports;

  /** Built-in value references. */
  var Buffer = moduleExports ? root.Buffer : undefined;

  /* Built-in method references for those with the same name as other `lodash` methods. */
  var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

  /**
   * Checks if `value` is a buffer.
   *
   * @static
   * @memberOf _
   * @since 4.3.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
   * @example
   *
   * _.isBuffer(new Buffer(2));
   * // => true
   *
   * _.isBuffer(new Uint8Array(2));
   * // => false
   */
  var isBuffer = nativeIsBuffer || stubFalse;
  module.exports = isBuffer;
})(isBuffer$2, isBuffer$2.exports);

var baseGetTag$1 = _baseGetTag,
  getPrototype = _getPrototype,
  isObjectLike$1 = isObjectLike_1;

/** `Object#toString` result references. */
var objectTag$1 = '[object Object]';

/** Used for built-in method references. */
var funcProto = Function.prototype,
  objectProto$3 = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty$3 = objectProto$3.hasOwnProperty;

/** Used to infer the `Object` constructor. */
var objectCtorString = funcToString.call(Object);

/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */
function isPlainObject$1(value) {
  if (!isObjectLike$1(value) || baseGetTag$1(value) != objectTag$1) {
    return false;
  }
  var proto = getPrototype(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty$3.call(proto, 'constructor') && proto.constructor;
  return typeof Ctor == 'function' && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
}
var isPlainObject_1 = isPlainObject$1;

var baseGetTag = _baseGetTag,
  isLength = isLength_1,
  isObjectLike = isObjectLike_1;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
  arrayTag = '[object Array]',
  boolTag = '[object Boolean]',
  dateTag = '[object Date]',
  errorTag = '[object Error]',
  funcTag = '[object Function]',
  mapTag = '[object Map]',
  numberTag = '[object Number]',
  objectTag = '[object Object]',
  regexpTag = '[object RegExp]',
  setTag = '[object Set]',
  stringTag = '[object String]',
  weakMapTag = '[object WeakMap]';
var arrayBufferTag = '[object ArrayBuffer]',
  dataViewTag = '[object DataView]',
  float32Tag = '[object Float32Array]',
  float64Tag = '[object Float64Array]',
  int8Tag = '[object Int8Array]',
  int16Tag = '[object Int16Array]',
  int32Tag = '[object Int32Array]',
  uint8Tag = '[object Uint8Array]',
  uint8ClampedTag = '[object Uint8ClampedArray]',
  uint16Tag = '[object Uint16Array]',
  uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray$1(value) {
  return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}
var _baseIsTypedArray = baseIsTypedArray$1;

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary$1(func) {
  return function (value) {
    return func(value);
  };
}
var _baseUnary = baseUnary$1;

var _nodeUtil = {exports: {}};

(function (module, exports) {
  var freeGlobal = _freeGlobal;

  /** Detect free variable `exports`. */
  var freeExports = exports && !exports.nodeType && exports;

  /** Detect free variable `module`. */
  var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

  /** Detect the popular CommonJS extension `module.exports`. */
  var moduleExports = freeModule && freeModule.exports === freeExports;

  /** Detect free variable `process` from Node.js. */
  var freeProcess = moduleExports && freeGlobal.process;

  /** Used to access faster Node.js helpers. */
  var nodeUtil = function () {
    try {
      // Use `util.types` for Node.js 10+.
      var types = freeModule && freeModule.require && freeModule.require('util').types;
      if (types) {
        return types;
      }

      // Legacy `process.binding('util')` for Node.js < 10.
      return freeProcess && freeProcess.binding && freeProcess.binding('util');
    } catch (e) {}
  }();
  module.exports = nodeUtil;
})(_nodeUtil, _nodeUtil.exports);

var baseIsTypedArray = _baseIsTypedArray,
  baseUnary = _baseUnary,
  nodeUtil = _nodeUtil.exports;

/* Node.js helper references. */
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray$2 = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
var isTypedArray_1 = isTypedArray$2;

/**
 * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function safeGet$2(object, key) {
  if (key === 'constructor' && typeof object[key] === 'function') {
    return;
  }
  if (key == '__proto__') {
    return;
  }
  return object[key];
}
var _safeGet = safeGet$2;

var baseAssignValue$1 = _baseAssignValue,
  eq$1 = eq_1;

/** Used for built-in method references. */
var objectProto$2 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$2 = objectProto$2.hasOwnProperty;

/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignValue$1(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty$2.call(object, key) && eq$1(objValue, value)) || value === undefined && !(key in object)) {
    baseAssignValue$1(object, key, value);
  }
}
var _assignValue = assignValue$1;

var assignValue = _assignValue,
  baseAssignValue = _baseAssignValue;

/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */
function copyObject$1(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});
  var index = -1,
    length = props.length;
  while (++index < length) {
    var key = props[index];
    var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined;
    if (newValue === undefined) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue(object, key, newValue);
    } else {
      assignValue(object, key, newValue);
    }
  }
  return object;
}
var _copyObject = copyObject$1;

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes$1(n, iteratee) {
  var index = -1,
    result = Array(n);
  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}
var _baseTimes = baseTimes$1;

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex$2(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length && (type == 'number' || type != 'symbol' && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
}
var _isIndex = isIndex$2;

var baseTimes = _baseTimes,
  isArguments$1 = isArguments_1,
  isArray$1 = isArray_1,
  isBuffer$1 = isBuffer$2.exports,
  isIndex$1 = _isIndex,
  isTypedArray$1 = isTypedArray_1;

/** Used for built-in method references. */
var objectProto$1 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$1 = objectProto$1.hasOwnProperty;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys$1(value, inherited) {
  var isArr = isArray$1(value),
    isArg = !isArr && isArguments$1(value),
    isBuff = !isArr && !isArg && isBuffer$1(value),
    isType = !isArr && !isArg && !isBuff && isTypedArray$1(value),
    skipIndexes = isArr || isArg || isBuff || isType,
    result = skipIndexes ? baseTimes(value.length, String) : [],
    length = result.length;
  for (var key in value) {
    if ((inherited || hasOwnProperty$1.call(value, key)) && !(skipIndexes && (
    // Safari 9 has enumerable `arguments.length` in strict mode.
    key == 'length' ||
    // Node.js 0.10 has enumerable non-index properties on buffers.
    isBuff && (key == 'offset' || key == 'parent') ||
    // PhantomJS 2 has enumerable non-index properties on typed arrays.
    isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset') ||
    // Skip index properties.
    isIndex$1(key, length)))) {
      result.push(key);
    }
  }
  return result;
}
var _arrayLikeKeys = arrayLikeKeys$1;

/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function nativeKeysIn$1(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}
var _nativeKeysIn = nativeKeysIn$1;

var isObject$3 = isObject_1,
  isPrototype = _isPrototype,
  nativeKeysIn = _nativeKeysIn;

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeysIn$1(object) {
  if (!isObject$3(object)) {
    return nativeKeysIn(object);
  }
  var isProto = isPrototype(object),
    result = [];
  for (var key in object) {
    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}
var _baseKeysIn = baseKeysIn$1;

var arrayLikeKeys = _arrayLikeKeys,
  baseKeysIn = _baseKeysIn,
  isArrayLike$1 = isArrayLike_1;

/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */
function keysIn$2(object) {
  return isArrayLike$1(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}
var keysIn_1 = keysIn$2;

var copyObject = _copyObject,
  keysIn$1 = keysIn_1;

/**
 * Converts `value` to a plain object flattening inherited enumerable string
 * keyed properties of `value` to own properties of the plain object.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {Object} Returns the converted plain object.
 * @example
 *
 * function Foo() {
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.assign({ 'a': 1 }, new Foo);
 * // => { 'a': 1, 'b': 2 }
 *
 * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
 * // => { 'a': 1, 'b': 2, 'c': 3 }
 */
function toPlainObject$1(value) {
  return copyObject(value, keysIn$1(value));
}
var toPlainObject_1 = toPlainObject$1;

var assignMergeValue$1 = _assignMergeValue,
  cloneBuffer = _cloneBuffer.exports,
  cloneTypedArray = _cloneTypedArray,
  copyArray = _copyArray,
  initCloneObject = _initCloneObject,
  isArguments = isArguments_1,
  isArray = isArray_1,
  isArrayLikeObject = isArrayLikeObject_1,
  isBuffer = isBuffer$2.exports,
  isFunction = isFunction_1,
  isObject$2 = isObject_1,
  isPlainObject = isPlainObject_1,
  isTypedArray = isTypedArray_1,
  safeGet$1 = _safeGet,
  toPlainObject = toPlainObject_1;

/**
 * A specialized version of `baseMerge` for arrays and objects which performs
 * deep merges and tracks traversed objects enabling objects with circular
 * references to be merged.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {string} key The key of the value to merge.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} mergeFunc The function to merge values.
 * @param {Function} [customizer] The function to customize assigned values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */
function baseMergeDeep$1(object, source, key, srcIndex, mergeFunc, customizer, stack) {
  var objValue = safeGet$1(object, key),
    srcValue = safeGet$1(source, key),
    stacked = stack.get(srcValue);
  if (stacked) {
    assignMergeValue$1(object, key, stacked);
    return;
  }
  var newValue = customizer ? customizer(objValue, srcValue, key + '', object, source, stack) : undefined;
  var isCommon = newValue === undefined;
  if (isCommon) {
    var isArr = isArray(srcValue),
      isBuff = !isArr && isBuffer(srcValue),
      isTyped = !isArr && !isBuff && isTypedArray(srcValue);
    newValue = srcValue;
    if (isArr || isBuff || isTyped) {
      if (isArray(objValue)) {
        newValue = objValue;
      } else if (isArrayLikeObject(objValue)) {
        newValue = copyArray(objValue);
      } else if (isBuff) {
        isCommon = false;
        newValue = cloneBuffer(srcValue, true);
      } else if (isTyped) {
        isCommon = false;
        newValue = cloneTypedArray(srcValue, true);
      } else {
        newValue = [];
      }
    } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
      newValue = objValue;
      if (isArguments(objValue)) {
        newValue = toPlainObject(objValue);
      } else if (!isObject$2(objValue) || isFunction(objValue)) {
        newValue = initCloneObject(srcValue);
      }
    } else {
      isCommon = false;
    }
  }
  if (isCommon) {
    // Recursively merge objects and arrays (susceptible to call stack limits).
    stack.set(srcValue, newValue);
    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
    stack['delete'](srcValue);
  }
  assignMergeValue$1(object, key, newValue);
}
var _baseMergeDeep = baseMergeDeep$1;

var Stack = _Stack,
  assignMergeValue = _assignMergeValue,
  baseFor = _baseFor,
  baseMergeDeep = _baseMergeDeep,
  isObject$1 = isObject_1,
  keysIn = keysIn_1,
  safeGet = _safeGet;

/**
 * The base implementation of `_.merge` without support for multiple sources.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} [customizer] The function to customize merged values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */
function baseMerge$1(object, source, srcIndex, customizer, stack) {
  if (object === source) {
    return;
  }
  baseFor(source, function (srcValue, key) {
    stack || (stack = new Stack());
    if (isObject$1(srcValue)) {
      baseMergeDeep(object, source, key, srcIndex, baseMerge$1, customizer, stack);
    } else {
      var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + '', object, source, stack) : undefined;
      if (newValue === undefined) {
        newValue = srcValue;
      }
      assignMergeValue(object, key, newValue);
    }
  }, keysIn);
}
var _baseMerge = baseMerge$1;

/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity$2(value) {
  return value;
}
var identity_1 = identity$2;

/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply$1(func, thisArg, args) {
  switch (args.length) {
    case 0:
      return func.call(thisArg);
    case 1:
      return func.call(thisArg, args[0]);
    case 2:
      return func.call(thisArg, args[0], args[1]);
    case 3:
      return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}
var _apply = apply$1;

var apply = _apply;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * A specialized version of `baseRest` which transforms the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @param {Function} transform The rest array transform.
 * @returns {Function} Returns the new function.
 */
function overRest$1(func, start, transform) {
  start = nativeMax(start === undefined ? func.length - 1 : start, 0);
  return function () {
    var args = arguments,
      index = -1,
      length = nativeMax(args.length - start, 0),
      array = Array(length);
    while (++index < length) {
      array[index] = args[start + index];
    }
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = transform(array);
    return apply(func, this, otherArgs);
  };
}
var _overRest = overRest$1;

/**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new constant function.
 * @example
 *
 * var objects = _.times(2, _.constant({ 'a': 1 }));
 *
 * console.log(objects);
 * // => [{ 'a': 1 }, { 'a': 1 }]
 *
 * console.log(objects[0] === objects[1]);
 * // => true
 */
function constant$1(value) {
  return function () {
    return value;
  };
}
var constant_1 = constant$1;

var constant = constant_1,
  defineProperty = _defineProperty,
  identity$1 = identity_1;

/**
 * The base implementation of `setToString` without support for hot loop shorting.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var baseSetToString$1 = !defineProperty ? identity$1 : function (func, string) {
  return defineProperty(func, 'toString', {
    'configurable': true,
    'enumerable': false,
    'value': constant(string),
    'writable': true
  });
};
var _baseSetToString = baseSetToString$1;

/** Used to detect hot functions by number of calls within a span of milliseconds. */
var HOT_COUNT = 800,
  HOT_SPAN = 16;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeNow = Date.now;

/**
 * Creates a function that'll short out and invoke `identity` instead
 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
 * milliseconds.
 *
 * @private
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new shortable function.
 */
function shortOut$1(func) {
  var count = 0,
    lastCalled = 0;
  return function () {
    var stamp = nativeNow(),
      remaining = HOT_SPAN - (stamp - lastCalled);
    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(undefined, arguments);
  };
}
var _shortOut = shortOut$1;

var baseSetToString = _baseSetToString,
  shortOut = _shortOut;

/**
 * Sets the `toString` method of `func` to return `string`.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var setToString$1 = shortOut(baseSetToString);
var _setToString = setToString$1;

var identity = identity_1,
  overRest = _overRest,
  setToString = _setToString;

/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */
function baseRest$1(func, start) {
  return setToString(overRest(func, start, identity), func + '');
}
var _baseRest = baseRest$1;

var eq = eq_1,
  isArrayLike = isArrayLike_1,
  isIndex = _isIndex,
  isObject = isObject_1;

/**
 * Checks if the given arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
 *  else `false`.
 */
function isIterateeCall$1(value, index, object) {
  if (!isObject(object)) {
    return false;
  }
  var type = typeof index;
  if (type == 'number' ? isArrayLike(object) && isIndex(index, object.length) : type == 'string' && index in object) {
    return eq(object[index], value);
  }
  return false;
}
var _isIterateeCall = isIterateeCall$1;

var baseRest = _baseRest,
  isIterateeCall = _isIterateeCall;

/**
 * Creates a function like `_.assign`.
 *
 * @private
 * @param {Function} assigner The function to assign values.
 * @returns {Function} Returns the new assigner function.
 */
function createAssigner$1(assigner) {
  return baseRest(function (object, sources) {
    var index = -1,
      length = sources.length,
      customizer = length > 1 ? sources[length - 1] : undefined,
      guard = length > 2 ? sources[2] : undefined;
    customizer = assigner.length > 3 && typeof customizer == 'function' ? (length--, customizer) : undefined;
    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length < 3 ? undefined : customizer;
      length = 1;
    }
    object = Object(object);
    while (++index < length) {
      var source = sources[index];
      if (source) {
        assigner(object, source, index, customizer);
      }
    }
    return object;
  });
}
var _createAssigner = createAssigner$1;

var baseMerge = _baseMerge,
  createAssigner = _createAssigner;

/**
 * This method is like `_.merge` except that it accepts `customizer` which
 * is invoked to produce the merged values of the destination and source
 * properties. If `customizer` returns `undefined`, merging is handled by the
 * method instead. The `customizer` is invoked with six arguments:
 * (objValue, srcValue, key, object, source, stack).
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} sources The source objects.
 * @param {Function} customizer The function to customize assigned values.
 * @returns {Object} Returns `object`.
 * @example
 *
 * function customizer(objValue, srcValue) {
 *   if (_.isArray(objValue)) {
 *     return objValue.concat(srcValue);
 *   }
 * }
 *
 * var object = { 'a': [1], 'b': [2] };
 * var other = { 'a': [3], 'b': [4] };
 *
 * _.mergeWith(object, other, customizer);
 * // => { 'a': [1, 3], 'b': [2, 4] }
 */
var mergeWith = createAssigner(function (object, source, srcIndex, customizer) {
  baseMerge(object, source, srcIndex, customizer);
});
var mergeWith_1 = mergeWith;

/**
 * Gets the config with any undefined properties replaced by the defaults
 * @param config the config
 * @param defaults the defaults
 * @returns the merged config with defaults
 */
const mergeConfigWithDefaults = (config, defaults) => mergeWith_1({}, defaults, config, (_a, b) => {
  if (Array.isArray(b)) {
    return b;
  }
  return undefined;
});

const DEFAULT_LOG_LEVEL = 'warn';
const DEFAULT_LOG_PREFIX = '[audius-sdk]';
const logLevels = ['debug', 'info', 'warn', 'error'];
class Logger {
  constructor(config) {
    var _config$logLevel, _config$logPrefix;
    _defineProperty$1(this, "logLevel", void 0);
    _defineProperty$1(this, "logPrefix", '[audius-sdk]');
    this.logLevel = (_config$logLevel = config === null || config === void 0 ? void 0 : config.logLevel) !== null && _config$logLevel !== void 0 ? _config$logLevel : DEFAULT_LOG_LEVEL;
    this.logPrefix = (_config$logPrefix = config === null || config === void 0 ? void 0 : config.logPrefix) !== null && _config$logPrefix !== void 0 ? _config$logPrefix : DEFAULT_LOG_PREFIX;
  }
  createPrefixedLogger(logPrefix) {
    return new Logger({
      logLevel: this.logLevel,
      logPrefix: `${this.logPrefix}${logPrefix}`
    });
  }
  debug() {
    if (logLevels.indexOf(this.logLevel) > logLevels.indexOf('debug')) {
      return;
    }
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    console.debug(this.logPrefix, ...args);
  }
  info() {
    if (logLevels.indexOf(this.logLevel) > logLevels.indexOf('info')) {
      return;
    }
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    console.info(this.logPrefix, ...args);
  }
  warn() {
    if (logLevels.indexOf(this.logLevel) > logLevels.indexOf('warn')) {
      return;
    }
    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      args[_key3] = arguments[_key3];
    }
    console.warn(this.logPrefix, ...args);
  }
  error() {
    if (logLevels.indexOf(this.logLevel) > logLevels.indexOf('error')) {
      return;
    }
    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      args[_key4] = arguments[_key4];
    }
    console.error(this.logPrefix, ...args);
  }
}

const getDefaultSolanaClientConfig = servicesConfig => ({
  rpcEndpoints: [servicesConfig.solana.rpcEndpoint],
  logger: new Logger()
});

const PrioritySchema = z.enum(['MIN', 'LOW', 'MEDIUM', 'HIGH', 'VERY_HIGH', 'UNSAFE_MAX']);
// Note: Don't just use a custom object w/ `instanceof TransactionInstruction`
// as separate instances of @solana/web3.js would fail the instanceof check.
// See: https://stackoverflow.com/questions/75976618/why-does-the-instanceof-operator-return-false-on-instance-passed-to-library/75977756#75977756
const TransactionInstructionSchema = z.object({
  data: z.custom(),
  keys: z.array(z.object({
    pubkey: PublicKeySchema,
    isSigner: z.boolean(),
    isWritable: z.boolean()
  })),
  programId: PublicKeySchema
}).transform(arg => arg instanceof TransactionInstruction ? arg : new TransactionInstruction(arg));
// Note: Don't just use a custom object w/ `instanceof AddressLookupTableAccount`
// as separate instances of @solana/web3.js would fail the instanceof check.
// See: https://stackoverflow.com/questions/75976618/why-does-the-instanceof-operator-return-false-on-instance-passed-to-library/75977756#75977756
const AddressLookupTableAccountSchema = z.object({
  key: PublicKeySchema,
  state: z.object({
    addresses: z.array(PublicKeySchema),
    authority: z.optional(PublicKeySchema),
    deactivationSlot: z.bigint(),
    lastExtendedSlot: z.number(),
    lastExtendedSlotStartIndex: z.number()
  })
}).transform(arg => arg instanceof AddressLookupTableAccount ? arg : new AddressLookupTableAccount(arg));
const BuildTransactionSchema = z.object({
  instructions: z.array(TransactionInstructionSchema).min(1),
  recentBlockhash: z.string().optional(),
  feePayer: PublicKeySchema.optional(),
  /**
   * Either the public keys or actual account data for related address lookup tables.
   */
  addressLookupTables: z.union([z.array(PublicKeySchema).default([]), z.array(AddressLookupTableAccountSchema).default([])]).optional(),
  /**
   * Adds a ComputeBudget instruction to set the compute unit price for the
   * transaction. Can specify a percentile or percentile enum to use recent
   * prioritization fees to programatically set the price.
   */
  priorityFee: z.union([z.object({
    /**
     * The exact amount of microLamports to add per compute unit.
     */
    microLamports: z.number().min(0)
  }), z.object({
    /**
     * Specify the precise percentile (0-100) of recent priority fees
     * to use as this transaction's base priority fee per compute unit.
     */
    percentile: z.number().min(0).max(100),
    /**
     * Multiply the base priority fee per compute unit by some factor.
     * For example a multiplier of 2 and percentile of 50 will set the
     * priority fee to twice the median.
     */
    multiplier: z.number().min(0).optional(),
    /**
     * The minimum microLamports to use as the priority fee per compute
     * unit, regardless of the percentiles.
     */
    minimumMicroLamports: z.number().min(0).optional(),
    /**
     * The maximum microLamports to use as the priority fee per compute
     * unit, regardless of the percentiles.
     */
    maximumMicroLamports: z.number().min(0).optional()
  }), z.object({
    /**
     * Specify an enum-based percentile of recent priority fees to use as
     * this transactions priority fee per compute unit.
     */
    priority: PrioritySchema,
    /**
     * Multiply the base priority fee per compute unit by some factor.
     * For example a multiplier of 2 and percentile of 50 will set the
     * priority fee to twice the median.
     */
    multiplier: z.number().min(0).optional(),
    /**
     * The minimum microLamports to use as the priority fee per compute
     * unit, regardless of the percentiles.
     */
    minimumMicroLamports: z.number().min(0).optional(),
    /**
     * The maximum microLamports to use as the priority fee per compute
     * unit, regardless of the percentiles.
     */
    maximumMicroLamports: z.number().min(0).optional()
  })]).nullable().optional(),
  computeLimit: z.union([z.object({
    /**
     * Set hard limit on the compute units used.
     */
    units: z.number().min(0)
  }), z.object({
    /**
     * Simulate the transaction and multiply the simulated unitsConsumed
     * by this number to find the budget limit.
     */
    simulationMultiplier: z.number().min(0)
  })]).nullable().optional()
}).strict();

const isPublicKeyArray = arr => arr.every(a => a instanceof PublicKey);
const priorityToPercentileMap = {
  MIN: 0,
  LOW: 25,
  MEDIUM: 50,
  HIGH: 75,
  VERY_HIGH: 95,
  UNSAFE_MAX: 100
};
/**
 * This service is the main interaction source with Solana. It includes the
 * RPC client connection and the wallet adapter.
 *
 * The service contains helpful primitives for helping build, send, and confirm
 * transactions.
 */
class SolanaClient {
  constructor(config) {
    var _configWithDefaults$l;
    /** The Solana RPC client. */
    _defineProperty$1(this, "connection", void 0);
    _defineProperty$1(this, "wallet", void 0);
    _defineProperty$1(this, "logger", void 0);
    const configWithDefaults = mergeConfigWithDefaults(config, getDefaultSolanaClientConfig(productionConfig));
    if (!configWithDefaults.rpcEndpoints[0]) {
      throw new Error('RPC Endpoints not configured');
    }
    this.connection = new Connection(
    // Only supports one RPC endpoint right now
    configWithDefaults.rpcEndpoints[0], configWithDefaults.rpcConfig);
    this.wallet = config.solanaWalletAdapter;
    this.logger = (_configWithDefaults$l = configWithDefaults.logger) === null || _configWithDefaults$l === void 0 ? void 0 : _configWithDefaults$l.createPrefixedLogger('[solana-client]');
  }
  /**
   * Convenience helper to construct v0 transactions.
   *
   * Handles fetching a recent blockhash, getting lookup table accounts,
   * and assigning a fee payer.
   */
  async buildTransaction(params) {
    let {
      instructions,
      feePayer,
      recentBlockhash,
      addressLookupTables = [],
      priorityFee = {
        priority: 'VERY_HIGH',
        minimumMicroLamports: 150000,
        maximumMicroLamports: 10000000,
        multiplier: 1.5
      },
      computeLimit = {
        simulationMultiplier: 1.5
      }
    } = await parseParams('buildTransaction', BuildTransactionSchema)(params);
    if (!recentBlockhash) {
      const res = await this.connection.getLatestBlockhash();
      recentBlockhash = res.blockhash;
    }
    const payerKey = feePayer !== null && feePayer !== void 0 ? feePayer : await this.getFeePayer();
    // Calculate priority fees
    if (priorityFee) {
      if ('microLamports' in priorityFee) {
        instructions.push(ComputeBudgetProgram.setComputeUnitPrice({
          microLamports: priorityFee.microLamports
        }));
      } else {
        var _priorityFee$multipli, _orderedFees$percenti, _priorityFee$minimumM, _priorityFee$maximumM;
        const res = await this.connection.getRecentPrioritizationFees();
        const orderedFees = res.map(r => r.prioritizationFee).sort((a, b) => a - b);
        const percentile = 'percentile' in priorityFee ? priorityFee.percentile : priorityToPercentileMap[priorityFee.priority];
        const multiplier = (_priorityFee$multipli = priorityFee.multiplier) !== null && _priorityFee$multipli !== void 0 ? _priorityFee$multipli : 1;
        const percentileIndex = Math.max(Math.round(percentile / 100.0 * orderedFees.length - 1), 0);
        const baseFee = ((_orderedFees$percenti = orderedFees[percentileIndex]) !== null && _orderedFees$percenti !== void 0 ? _orderedFees$percenti : 0) * multiplier;
        const microLamports = Math.min(Math.max(baseFee, (_priorityFee$minimumM = priorityFee.minimumMicroLamports) !== null && _priorityFee$minimumM !== void 0 ? _priorityFee$minimumM : 0), (_priorityFee$maximumM = priorityFee.maximumMicroLamports) !== null && _priorityFee$maximumM !== void 0 ? _priorityFee$maximumM : Number.MAX_SAFE_INTEGER);
        if (microLamports !== undefined) {
          instructions.push(ComputeBudgetProgram.setComputeUnitPrice({
            microLamports
          }));
        }
      }
    }
    const addressLookupTableAccounts = !isPublicKeyArray(addressLookupTables) ? addressLookupTables : await this.getLookupTableAccounts(addressLookupTables);
    // Simulate to get compute units
    if (computeLimit) {
      if ('units' in computeLimit) {
        instructions.push(ComputeBudgetProgram.setComputeUnitLimit({
          units: computeLimit.units
        }));
      } else {
        try {
          const simulatedMessage = new TransactionMessage({
            payerKey,
            recentBlockhash,
            instructions
          }).compileToV0Message(addressLookupTableAccounts);
          const simulatedTx = new VersionedTransaction(simulatedMessage);
          const res = await this.connection.simulateTransaction(simulatedTx, {
            replaceRecentBlockhash: true
          });
          if (res.value.err) {
            throw new Error(JSON.stringify(res.value.err));
          }
          this.logger.debug('Simulation succeeded, compute units used:', res.value.unitsConsumed);
          if (res.value.unitsConsumed) {
            instructions.push(ComputeBudgetProgram.setComputeUnitLimit({
              units: res.value.unitsConsumed * computeLimit.simulationMultiplier
            }));
          }
        } catch (e) {
          // For now, even if specifying compute budget limit, ignore errors
          this.logger.warn('Failed to get computeLimit', e);
        }
      }
    }
    const message = new TransactionMessage({
      payerKey,
      recentBlockhash,
      instructions
    }).compileToV0Message(addressLookupTableAccounts);
    return new VersionedTransaction(message);
  }
  /**
   * Sends a transaction using the connected wallet adapter and the connection.
   * @param transaction The transaction to send.
   * @param sendOptions The options to send it with.
   */
  async sendTransaction(transaction, sendOptions) {
    return await this.wallet.sendTransaction(transaction, this.connection, sendOptions);
  }
  /**
   * Confirms all the transactions provided
   */
  async confirmAllTransactions(signatures) {
    let commitment = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'confirmed';
    const {
      blockhash,
      lastValidBlockHeight
    } = await this.connection.getLatestBlockhash();
    const results = await Promise.all(signatures.map(async signature => {
      const res = await this.connection.confirmTransaction({
        signature,
        blockhash,
        lastValidBlockHeight
      }, commitment);
      return {
        signature,
        err: res.value.err
      };
    }));
    const errors = results.filter(r => !!r.err);
    if (errors.length > 0) {
      throw new Error(`Failed to confirm transactions: ${errors.map(e => `${e.signature}: ${e.err}`).join(', ')}`);
    }
  }
  /**
   * Gets the fee payer from the connected wallet.
   */
  async getFeePayer() {
    if (!this.wallet.connected) {
      await this.wallet.connect();
    }
    return this.wallet.publicKey;
  }
  /**
   * Normalizes the instructions as TransactionInstruction whether from
   * versioned transactions or legacy transactions.
   */
  async getInstructions(transaction) {
    if ('version' in transaction) {
      const lookupTableAccounts = await this.getLookupTableAccounts(transaction.message.addressTableLookups.map(k => k.accountKey));
      const decompiled = TransactionMessage.decompile(transaction.message, {
        addressLookupTableAccounts: lookupTableAccounts
      });
      return decompiled.instructions;
    } else {
      return transaction.instructions;
    }
  }
  /**
   * Fetches the address look up tables for populating transaction objects
   */
  async getLookupTableAccounts(lookupTableKeys) {
    return await Promise.all(lookupTableKeys.map(async accountKey => {
      const res = await this.connection.getAddressLookupTable(accountKey);
      if (res.value === null) {
        throw new Error(`Lookup table not found: ${accountKey.toBase58()}`);
      }
      return res.value;
    }));
  }
}

/**
 * Helper function to get both the token and mint address from one or the other.
 * @param mintOrToken either the name of the token ('USDC') or its mint address
 * @param mints a mapping of tokens to mint addresses
 * @returns the mint address and token name
 * @throws if the token isn't in the mint map
 */
const parseMint = (mintOrToken, mints) => {
  const mint = mintOrToken instanceof PublicKey ? mintOrToken : mints[mintOrToken];
  if (!mint) {
    throw Error('Mint not configured');
  }
  return mint;
};

class CustomInstructionError extends Error {
  constructor(instructionIndex, code) {
    super(JSON.stringify({
      InstructionError: [instructionIndex, {
        Custom: code
      }]
    }));
    _defineProperty$1(this, "instructionIndex", void 0);
    _defineProperty$1(this, "code", void 0);
    this.instructionIndex = instructionIndex;
    this.code = code;
  }
  static parseSendTransactionError(error) {
    var _parsed$InstructionEr, _parsed$InstructionEr2;
    const parsed = JSON.parse(error.transactionError.message);
    if (typeof (parsed === null || parsed === void 0 ? void 0 : (_parsed$InstructionEr = parsed.InstructionError) === null || _parsed$InstructionEr === void 0 ? void 0 : (_parsed$InstructionEr2 = _parsed$InstructionEr[1]) === null || _parsed$InstructionEr2 === void 0 ? void 0 : _parsed$InstructionEr2.Custom) === 'number') {
      return new CustomInstructionError(parsed.InstructionError[0], parsed.InstructionError[1].Custom);
    }
    throw new Error('Unable to parse custom transaction error');
  }
}

const getDefaultClaimableTokensConfig = config => ({
  programId: new PublicKey(config.solana.claimableTokensProgramAddress),
  mints: {
    wAUDIO: new PublicKey(config.solana.wAudioTokenMint),
    USDC: new PublicKey(config.solana.usdcTokenMint),
    BONK: new PublicKey(config.solana.bonkTokenMint)
  },
  logger: new Logger()
});

const GetOrCreateUserBankSchema = z.object({
  /** The user's Ethereum wallet. */
  ethWallet: z.string().optional(),
  /** The name of the token mint. */
  mint: MintSchema,
  /**
   * The public key of the account that will be paying the
   * account creation and transaction fees.
   */
  feePayer: PublicKeySchema.optional()
}).strict();
z.object({
  /** The sending user's Ethereum wallet. Defaults to the current audiusWalletClient address. */
  ethWallet: z.string().optional(),
  /** The name of the token mint. */
  mint: MintSchema
}).strict();
const CreateTransferSchema = z.object({
  /** The public key of the account that will be paying the transaction fees. */
  feePayer: PublicKeySchema.optional(),
  /** The sending user's Ethereum wallet. Defaults to the current audiusWalletClient address. */
  ethWallet: z.string().optional(),
  /** The name of the token mint. */
  mint: MintSchema,
  /** The public key of the destination account. */
  destination: PublicKeySchema
});
const CreateSecpSchema = z.object({
  /** The sending user's Ethereum wallet. Defaults to the current audiusWalletClient address. */
  ethWallet: z.string().optional(),
  /** The public key of the destination account. */
  destination: PublicKeySchema,
  /** The amount to send, in "lamports"/"wei" (bigint). */
  amount: z.bigint(),
  /** The name of the token mint. */
  mint: MintSchema,
  /** The index of this instruction within the transaction. */
  instructionIndex: z.number().optional()
}).strict();

class ClaimableTokensError extends Error {
  constructor(_ref) {
    var _ClaimableTokensError2;
    let {
      code,
      instructionName,
      cause
    } = _ref;
    super((_ClaimableTokensError2 = ClaimableTokensErrorMessages[code]) !== null && _ClaimableTokensError2 !== void 0 ? _ClaimableTokensError2 : `Unknown error: ${code}`, {
      cause
    });
    _defineProperty$1(this, "name", 'ClaimableTokensError');
    _defineProperty$1(this, "code", void 0);
    _defineProperty$1(this, "instructionName", void 0);
    _defineProperty$1(this, "customErrorName", void 0);
    this.code = code;
    this.instructionName = instructionName;
    this.customErrorName = ClaimableTokensErrorCode[code];
  }
}
/**
 * Connected client to the ClaimableTokens Solana program.
 *
 * The ClaimableTokens program is responsible for creation of program-owned
 * associated token accounts that are permissioned to users by their Ethereum
 * hedgehog wallet private keys.
 */
class ClaimableTokensClient {
  constructor(config) {
    _defineProperty$1(this, "client", void 0);
    /** The program ID of the ClaimableTokensProgram instance. */
    _defineProperty$1(this, "programId", void 0);
    /** Map from token mint name to public key address. */
    _defineProperty$1(this, "preconfiguredMints", void 0);
    /** Map from token mint name to derived user bank authority. */
    _defineProperty$1(this, "authorities", void 0);
    _defineProperty$1(this, "logger", void 0);
    _defineProperty$1(this, "audiusWalletClient", void 0);
    /**
     * Map of user banks to user bank creation promises.
     * Prevents concurrent attempts to create the same user bank.
     */
    _defineProperty$1(this, "_pendingUserBankCreationPromises", {});
    const configWithDefaults = mergeConfigWithDefaults(config, getDefaultClaimableTokensConfig(productionConfig));
    this.client = configWithDefaults.solanaClient;
    this.programId = configWithDefaults.programId;
    this.preconfiguredMints = configWithDefaults.mints;
    this.authorities = Object.fromEntries(Object.entries(configWithDefaults.mints).map(_ref2 => {
      let [token, mint] = _ref2;
      return [token, ClaimableTokensProgram.deriveAuthority({
        programId: configWithDefaults.programId,
        mint
      })];
    }));
    this.audiusWalletClient = configWithDefaults.audiusWalletClient;
    this.logger = configWithDefaults.logger.createPrefixedLogger('[claimable-tokens-client]');
  }
  /**
   * Creates a user bank or returns the existing user bank for a user.
   */
  async getOrCreateUserBank(params) {
    const args = await parseParams('getOrCreateUserBank', GetOrCreateUserBankSchema)(params);
    const {
      ethWallet = await this.getDefaultWalletAddress(),
      feePayer: feePayerOverride
    } = args;
    const mint = parseMint(args.mint, this.preconfiguredMints);
    const feePayer = feePayerOverride !== null && feePayerOverride !== void 0 ? feePayerOverride : await this.client.getFeePayer();
    const userBank = await this.deriveUserBank(args);
    // If already fetching/creating this user bank, wait for the existing promise.
    // Then assume the user bank has been created and return with didExist=true.
    // Don't attempt to catch and retry or concurrency will again be introduced.
    if (this._pendingUserBankCreationPromises[userBank.toBase58()]) {
      await this._pendingUserBankCreationPromises[userBank.toBase58()];
      return {
        userBank,
        didExist: true
      };
    }
    // Create a new lock on the fetch/creation process for this user bank
    this._pendingUserBankCreationPromises[userBank.toBase58()] = (async () => {
      const userBankAccount = await this.client.connection.getAccountInfo(userBank);
      if (!userBankAccount) {
        this.logger.debug(`User bank ${userBank} does not exist. Creating...`);
        const createUserBankInstruction = ClaimableTokensProgram.createAccountInstruction({
          ethAddress: ethWallet,
          payer: feePayer,
          mint,
          authority: this.deriveAuthority(mint),
          userBank,
          programId: this.programId
        });
        const {
          blockhash,
          lastValidBlockHeight
        } = await this.client.connection.getLatestBlockhash();
        const transaction = await this.client.buildTransaction({
          instructions: [createUserBankInstruction],
          recentBlockhash: blockhash
        });
        const signature = await this.sendTransaction(transaction);
        await this.client.connection.confirmTransaction({
          blockhash,
          lastValidBlockHeight,
          signature
        }, 'finalized');
        return {
          userBank,
          didExist: false
        };
      }
      this.logger.debug(`User bank ${userBank} already exists.`);
      return {
        userBank,
        didExist: true
      };
    })();
    try {
      // Wait for the promise and return the result.
      // Note that the lock is not removed on success. Keep it as an in-memory
      // cache that the user bank exists. Reduces RPC calls to check existence.
      return await this._pendingUserBankCreationPromises[userBank.toBase58()];
    } catch (e) {
      // Remove lock on error so that the next attempt retries creation.
      delete this._pendingUserBankCreationPromises[userBank.toBase58()];
      throw e;
    }
  }
  /**
   * Creates a claimable tokens program transfer instruction using configured
   * program ID, mint addresses, derived nonce, and derived authorities.
   *
   * Must be paired with a matching Secp256k1 instruction.
   * @see {@link createTransferSecpInstruction}
   */
  async createTransferInstruction(params) {
    const {
      feePayer: feePayerOverride,
      ethWallet = await this.getDefaultWalletAddress(),
      mint: mintOrToken,
      destination
    } = await parseParams('createTransferInstruction', CreateTransferSchema)(params);
    const mint = parseMint(mintOrToken, this.preconfiguredMints);
    const feePayer = feePayerOverride !== null && feePayerOverride !== void 0 ? feePayerOverride : await this.client.getFeePayer();
    const source = await this.deriveUserBank({
      ethWallet,
      mint
    });
    const nonceKey = ClaimableTokensProgram.deriveNonce({
      ethAddress: ethWallet,
      authority: this.deriveAuthority(mint),
      programId: this.programId
    });
    return ClaimableTokensProgram.createTransferInstruction({
      payer: feePayer,
      sourceEthAddress: ethWallet,
      sourceUserBank: source,
      destination,
      nonceAccount: nonceKey,
      authority: this.deriveAuthority(mint),
      programId: this.programId
    });
  }
  /**
   * Creates a signed Secp256k1 instruction for a claimable tokens transfer
   * using configured program ID, derived nonce, and derived authorities.
   *
   * @see {@link createTransferInstruction}
   */
  async createTransferSecpInstruction(params) {
    const {
      ethWallet = (await this.audiusWalletClient.getAddresses())[0],
      destination,
      amount,
      mint: mintOrToken,
      instructionIndex
    } = await parseParams('createTransferSecpInstruction', CreateSecpSchema)(params);
    const mint = parseMint(mintOrToken, this.preconfiguredMints);
    let nonce = BigInt(0);
    const nonceKey = ClaimableTokensProgram.deriveNonce({
      ethAddress: ethWallet,
      authority: this.deriveAuthority(mint),
      programId: this.programId
    });
    const nonceAccount = await this.client.connection.getAccountInfo(nonceKey);
    const encodedNonceData = nonceAccount === null || nonceAccount === void 0 ? void 0 : nonceAccount.data;
    if (encodedNonceData) {
      const nonceData = ClaimableTokensProgram.layouts.nonceAccountData.decode(encodedNonceData);
      nonce = nonceData.nonce;
    }
    const data = ClaimableTokensProgram.createSignedTransferInstructionData({
      destination,
      amount,
      nonce
    });
    const [signature, recoveryId] = await this.audiusWalletClient.sign({
      message: {
        raw: data
      }
    });
    return Secp256k1Program.createInstructionWithEthAddress({
      ethAddress: ethWallet,
      message: data,
      signature,
      recoveryId,
      instructionIndex
    });
  }
  /**
   * Derives the user bank of a user from their Ethereum wallet and the token mint.
   *
   * Use {@link getOrCreateUserBank} instead if you want to ensure the userBank exists.
   */
  async deriveUserBank(params) {
    const {
      ethWallet = (await this.audiusWalletClient.getAddresses())[0],
      mint: mintOrToken
    } = await parseParams('deriveUserBank', GetOrCreateUserBankSchema)(params);
    const mint = parseMint(mintOrToken, this.preconfiguredMints);
    return await ClaimableTokensProgram.deriveUserBank({
      ethAddress: ethWallet,
      claimableTokensPDA: this.deriveAuthority(mint)
    });
  }
  /**
   * Derives the authority for a given mint.
   * If the authority is not already cached, it will derive it.
   */
  deriveAuthority(mint) {
    const authority = this.authorities[mint.toBase58()];
    if (!authority) {
      return ClaimableTokensProgram.deriveAuthority({
        programId: this.programId,
        mint
      });
    }
    return authority;
  }
  /**
   * Override the sendTransaction method to provide some more friendly errors
   * back to the consumer for ClaimableTokens instructions
   */
  async sendTransaction(transaction, sendOptions) {
    try {
      return await this.client.sendTransaction(transaction, sendOptions);
    } catch (e) {
      if (e instanceof SendTransactionError) {
        try {
          const error = CustomInstructionError.parseSendTransactionError(e);
          if (error) {
            const instructions = await this.client.getInstructions(transaction);
            const instruction = instructions[error.instructionIndex];
            if (instruction && instruction.programId.equals(this.programId)) {
              var _ClaimableTokensInstr;
              const decodedInstruction = ClaimableTokensProgram.decodeInstruction(instruction);
              throw new ClaimableTokensError({
                code: error.code,
                instructionName: (_ClaimableTokensInstr = ClaimableTokensInstruction[decodedInstruction.data.instruction]) !== null && _ClaimableTokensInstr !== void 0 ? _ClaimableTokensInstr : 'Unknown',
                cause: e
              });
            }
          }
        } catch (nestedError) {
          if (nestedError instanceof ClaimableTokensError) {
            throw nestedError;
          } else {
            // If failed to provide user friendly error, surface original error
            this.logger.warn('Failed to parse ClaimableTokensError error', nestedError);
          }
        }
      }
      throw e;
    }
  }
  async getDefaultWalletAddress() {
    const addresses = await this.audiusWalletClient.getAddresses();
    if (!addresses || !addresses[0]) {
      throw new Error('Failed to infer wallet address. Did you forget the "ethAddress" argument?');
    }
    return addresses[0];
  }
}

const getDefaultRewardManagerClentConfig = config => ({
  programId: new PublicKey(config.solana.rewardManagerProgramAddress),
  rewardManagerState: new PublicKey(config.solana.rewardManagerStateAddress),
  rewardManagerLookupTable: new PublicKey(config.solana.rewardManagerLookupTableAddress),
  logger: new Logger()
});

const CreateSenderInstructionSchema = z.object({
  manager: PublicKeySchema,
  sender: z.string(),
  operator: z.string(),
  feePayer: PublicKeySchema.optional()
});
const CreateSubmitAttestationInstructionSchema = z.object({
  challengeId: z.string(),
  specifier: z.string(),
  senderEthAddress: z.string(),
  feePayer: PublicKeySchema.optional()
});
const CreateSubmitAttestationSecpInstructionSchema = z.object({
  challengeId: z.string(),
  specifier: z.string(),
  recipientEthAddress: z.string(),
  senderEthAddress: z.string(),
  amount: z.bigint(),
  antiAbuseOracleEthAddress: z.string().optional(),
  senderSignature: z.string(),
  instructionIndex: z.number().optional()
});
const CreateEvaluateAttestationsInstructionSchema = z.object({
  challengeId: z.string(),
  specifier: z.string(),
  recipientEthAddress: z.string(),
  destinationUserBank: PublicKeySchema,
  antiAbuseOracleEthAddress: z.string(),
  amount: z.bigint(),
  feePayer: PublicKeySchema.optional()
});
const GetSubmittedAttestationsSchema = z.object({
  challengeId: z.string(),
  specifier: z.string()
});

class RewardManagerError extends Error {
  constructor(_ref) {
    var _RewardManagerErrorMe;
    let {
      code,
      instructionName,
      cause
    } = _ref;
    super((_RewardManagerErrorMe = RewardManagerErrorMessages[code]) !== null && _RewardManagerErrorMe !== void 0 ? _RewardManagerErrorMe : `Unknown error: ${code}`, {
      cause
    });
    _defineProperty$1(this, "name", 'RewardManagerError');
    _defineProperty$1(this, "code", void 0);
    _defineProperty$1(this, "instructionName", void 0);
    _defineProperty$1(this, "customErrorName", void 0);
    this.code = code;
    this.instructionName = instructionName;
    this.customErrorName = RewardManagerErrorCode[code];
  }
}
/**
 * Connected client to the Solana RewardManager program.
 *
 * The RewardManager program is in charge of disbursing the community awards
 * based on attestations from N uniquely owned discovery nodes and an anti abuse
 * oracle node.
 */
class RewardManagerClient {
  constructor(config) {
    _defineProperty$1(this, "lookupTable", void 0);
    _defineProperty$1(this, "client", void 0);
    _defineProperty$1(this, "programId", void 0);
    _defineProperty$1(this, "rewardManagerStateAccount", void 0);
    _defineProperty$1(this, "authority", void 0);
    _defineProperty$1(this, "rewardManagerState", null);
    _defineProperty$1(this, "logger", void 0);
    const configWithDefaults = mergeConfigWithDefaults(config, getDefaultRewardManagerClentConfig(productionConfig));
    this.lookupTable = configWithDefaults.rewardManagerLookupTable;
    this.client = configWithDefaults.solanaClient;
    this.programId = configWithDefaults.programId;
    this.rewardManagerStateAccount = configWithDefaults.rewardManagerState;
    this.authority = RewardManagerProgram.deriveAuthority({
      programId: configWithDefaults.programId,
      rewardManagerState: configWithDefaults.rewardManagerState
    });
    this.logger = configWithDefaults.logger.createPrefixedLogger('[reward-manager-client]');
  }
  async createSenderInstruction(params) {
    const args = await parseParams('createSenderInstruction', CreateSenderInstructionSchema)(params);
    const {
      manager,
      sender: senderEthAddress,
      operator: operatorEthAddress,
      feePayer: feePayerOverride
    } = args;
    const feePayer = feePayerOverride !== null && feePayerOverride !== void 0 ? feePayerOverride : await this.client.getFeePayer();
    const sender = RewardManagerProgram.deriveSender({
      ethAddress: senderEthAddress,
      programId: this.programId,
      authority: this.authority
    });
    return RewardManagerProgram.createSenderInstruction({
      operatorEthAddress,
      senderEthAddress,
      rewardManagerState: this.rewardManagerStateAccount,
      manager,
      authority: this.authority,
      payer: feePayer,
      sender,
      rewardManagerProgramId: this.programId
    });
  }
  async createSubmitAttestationInstruction(params) {
    const args = await parseParams('createSubmitAttestationInstruction', CreateSubmitAttestationInstructionSchema)(params);
    const {
      challengeId,
      specifier,
      senderEthAddress,
      feePayer: feePayerOverride
    } = args;
    const disbursementId = this.makeDisbursementId(challengeId, specifier);
    const feePayer = feePayerOverride !== null && feePayerOverride !== void 0 ? feePayerOverride : await this.client.getFeePayer();
    const sender = RewardManagerProgram.deriveSender({
      ethAddress: senderEthAddress,
      programId: this.programId,
      authority: this.authority
    });
    const attestations = RewardManagerProgram.deriveAttestations({
      disbursementId,
      programId: this.programId,
      authority: this.authority
    });
    return RewardManagerProgram.createSubmitAttestationInstruction({
      disbursementId,
      attestations,
      rewardManagerState: this.rewardManagerStateAccount,
      authority: this.authority,
      payer: feePayer,
      sender,
      rewardManagerProgramId: this.programId
    });
  }
  async createSubmitAttestationSecpInstruction(params) {
    const args = await parseParams('createSubmitAttestationSecpInstruction', CreateSubmitAttestationSecpInstructionSchema)(params);
    const {
      recipientEthAddress,
      challengeId,
      specifier,
      amount,
      senderEthAddress,
      senderSignature,
      instructionIndex,
      antiAbuseOracleEthAddress
    } = args;
    const disbursementId = this.makeDisbursementId(challengeId, specifier);
    const {
      signature,
      recoveryId
    } = RewardManagerProgram.encodeSignature(senderSignature);
    const data = RewardManagerProgram.encodeAttestation({
      disbursementId,
      recipientEthAddress,
      amount,
      antiAbuseOracleEthAddress
    });
    return Secp256k1Program.createInstructionWithEthAddress({
      ethAddress: senderEthAddress,
      message: data,
      signature,
      recoveryId,
      instructionIndex
    });
  }
  async createEvaluateAttestationsInstruction(params) {
    const args = await parseParams('createEvaluateAttestationsInstruction', CreateEvaluateAttestationsInstructionSchema)(params);
    const {
      challengeId,
      specifier,
      recipientEthAddress,
      destinationUserBank,
      antiAbuseOracleEthAddress,
      amount,
      feePayer: feePayerOverride
    } = args;
    const disbursementId = this.makeDisbursementId(challengeId, specifier);
    const feePayer = feePayerOverride !== null && feePayerOverride !== void 0 ? feePayerOverride : await this.client.getFeePayer();
    const state = await this.getRewardManagerState();
    const disbursementAccount = RewardManagerProgram.deriveDisbursement({
      disbursementId,
      programId: this.programId,
      authority: this.authority
    });
    const attestations = RewardManagerProgram.deriveAttestations({
      disbursementId,
      programId: this.programId,
      authority: this.authority
    });
    const antiAbuseOracle = RewardManagerProgram.deriveSender({
      ethAddress: antiAbuseOracleEthAddress,
      programId: this.programId,
      authority: this.authority
    });
    return RewardManagerProgram.createEvaluateAttestationsInstruction({
      disbursementId,
      recipientEthAddress,
      amount,
      attestations,
      rewardManagerState: this.rewardManagerStateAccount,
      authority: this.authority,
      rewardManagerTokenSource: state.tokenAccount,
      destinationUserBank,
      disbursementAccount,
      antiAbuseOracle,
      payer: feePayer,
      rewardManagerProgramId: this.programId
    });
  }
  async getSubmittedAttestations(params) {
    const args = await parseParams('getSubmittedAttestations', GetSubmittedAttestationsSchema)(params);
    const {
      challengeId,
      specifier
    } = args;
    const disbursementId = this.makeDisbursementId(challengeId, specifier);
    const attestationsAccount = RewardManagerProgram.deriveAttestations({
      disbursementId,
      programId: this.programId,
      authority: this.authority
    });
    const accountInfo = await this.client.connection.getAccountInfo(attestationsAccount);
    if (!accountInfo) {
      return null;
    }
    const rewardManagerState = await this.getRewardManagerState();
    // Min Votes = discovery votes, +1 for AAO oracle
    const maxAttestations = rewardManagerState.minVotes + 1;
    return RewardManagerProgram.decodeAttestationsAccountData(maxAttestations, accountInfo.data);
  }
  makeDisbursementId(challengeId, specifier) {
    return `${challengeId}:${specifier}`;
  }
  async getRewardManagerState() {
    if (!this.rewardManagerState) {
      const state = await this.client.connection.getAccountInfo(this.rewardManagerStateAccount);
      if (state) {
        this.rewardManagerState = RewardManagerProgram.decodeRewardManagerState(state.data);
      } else {
        throw new Error('Failed to get reward manager account state.');
      }
    }
    return this.rewardManagerState;
  }
  /**
   * Override the sendTransaction method to provide some more friendly errors
   * back to the consumer for RewardManager instructions
   */
  async sendTransaction(transaction, sendOptions) {
    try {
      return await this.client.sendTransaction(transaction, sendOptions);
    } catch (e) {
      if (e instanceof SendTransactionError) {
        try {
          const error = CustomInstructionError.parseSendTransactionError(e);
          if (error) {
            const instructions = await this.client.getInstructions(transaction);
            const instruction = instructions[error.instructionIndex];
            if (instruction && instruction.programId.equals(this.programId)) {
              var _RewardManagerInstruc;
              const decodedInstruction = RewardManagerProgram.decodeInstruction(instruction);
              throw new RewardManagerError({
                code: error.code,
                instructionName: (_RewardManagerInstruc = RewardManagerInstruction[decodedInstruction.data.instruction]) !== null && _RewardManagerInstruc !== void 0 ? _RewardManagerInstruc : 'Unknown',
                cause: e
              });
            }
          }
        } catch (nestedError) {
          if (nestedError instanceof RewardManagerError) {
            throw nestedError;
          } else {
            // If failed to provide user friendly error, surface original error
            this.logger.warn('Failed to parse RewardManagerError error', nestedError);
          }
        }
      }
      throw e;
    }
  }
}

new PublicKey('Memo1UhkJRfHyvLMcVucJwxXeuD728EqVDDwQDxFMNo');
const MEMO_V2_PROGRAM_ID = new PublicKey('MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr');

const getDefaultPaymentRouterClientConfig = config => ({
  programId: new PublicKey(config.solana.paymentRouterProgramAddress),
  mints: {
    USDC: new PublicKey(config.solana.usdcTokenMint),
    wAUDIO: new PublicKey(config.solana.wAudioTokenMint)
  }
});

const CreateTransferInstructionSchema = z.object({
  mint: MintSchema,
  total: z.bigint(),
  sourceWallet: PublicKeySchema
});
const CreateRouteInstructionSchema = z.object({
  mint: MintSchema,
  splits: z.array(z.object({
    wallet: PublicKeySchema,
    amount: z.bigint()
  })),
  total: z.bigint()
});
const CreateMemoInstructionSchema = z.object({
  contentType: z.enum(['track', 'album']),
  contentId: HashId.or(z.number()),
  blockNumber: z.number(),
  buyerUserId: HashId.or(z.number()),
  accessType: z.enum(['stream', 'download']),
  signer: PublicKeySchema.optional()
});
const CreatePurchaseContentInstructionsSchema = CreateTransferInstructionSchema.extend(CreateRouteInstructionSchema.shape).extend(CreateMemoInstructionSchema.shape);
const GetOrCreateProgramTokenAccountSchema = z.object({
  mint: MintSchema
});

class PaymentRouterClient {
  constructor(config) {
    _defineProperty$1(this, "client", void 0);
    _defineProperty$1(this, "programId", void 0);
    /** The intermediate account where funds are sent to and routed from. */
    _defineProperty$1(this, "programAccount", void 0);
    _defineProperty$1(this, "programAccountBumpSeed", void 0);
    _defineProperty$1(this, "mints", void 0);
    _defineProperty$1(this, "existingTokenAccounts", void 0);
    const configWithDefaults = mergeConfigWithDefaults(config, getDefaultPaymentRouterClientConfig(productionConfig));
    this.client = configWithDefaults.solanaClient;
    this.programId = configWithDefaults.programId;
    const [pda, bump] = PublicKey.findProgramAddressSync([new TextEncoder().encode('payment_router')], this.programId);
    this.programAccount = pda;
    this.programAccountBumpSeed = bump;
    this.mints = configWithDefaults.mints;
    this.existingTokenAccounts = {};
  }
  async createTransferInstruction(params) {
    const args = await parseParams('createTransferInstruction', CreateTransferInstructionSchema)(params);
    const mint = parseMint(args.mint, this.mints);
    const programTokenAccount = await this.getOrCreateProgramTokenAccount({
      mint
    });
    const sourceWallet = args.sourceWallet;
    const sourceTokenAccount = getAssociatedTokenAddressSync(mint, sourceWallet, false);
    const amount = args.total;
    return createTransferInstruction(sourceTokenAccount, programTokenAccount.address, sourceWallet, amount);
  }
  async createRouteInstruction(params) {
    const args = await parseParams('createRouteInstruction', CreateRouteInstructionSchema)(params);
    const mint = parseMint(args.mint, this.mints);
    const programTokenAccount = await this.getOrCreateProgramTokenAccount({
      mint
    });
    const recipients = [];
    const amounts = [];
    for (const split of args.splits) {
      recipients.push(split.wallet);
      amounts.push(split.amount);
    }
    const totalAmount = args.total;
    return PaymentRouterProgram.createRouteInstruction({
      sender: programTokenAccount.address,
      senderOwner: this.programAccount,
      paymentRouterPdaBump: this.programAccountBumpSeed,
      recipients,
      amounts,
      totalAmount,
      programId: this.programId
    });
  }
  async createPurchaseMemoInstruction(params) {
    const {
      contentType,
      contentId,
      blockNumber,
      buyerUserId,
      accessType,
      signer
    } = await parseParams('createMemoInstructionSchema', CreateMemoInstructionSchema)(params);
    const memoString = `${contentType}:${contentId}:${blockNumber}:${buyerUserId}:${accessType}`;
    return new TransactionInstruction({
      keys: signer ? [{
        pubkey: signer,
        isSigner: true,
        isWritable: true
      }] : [],
      programId: MEMO_V2_PROGRAM_ID,
      data: Buffer.from(memoString)
    });
  }
  async createPurchaseContentInstructions(params) {
    const {
      mint,
      splits,
      total,
      contentId,
      contentType,
      blockNumber,
      buyerUserId,
      accessType,
      sourceWallet
    } = await parseParams('createPurchaseContentInstructions', CreatePurchaseContentInstructionsSchema)(params);
    return [await this.createTransferInstruction({
      total,
      mint,
      sourceWallet
    }), await this.createRouteInstruction({
      splits,
      total,
      mint
    }), await this.createPurchaseMemoInstruction({
      contentId,
      contentType,
      blockNumber,
      buyerUserId,
      accessType
    })];
  }
  /**
   * Creates or gets the intermediate funds token account for the program.
   * Only needs to be created once per mint.
   * @see {@link https://github.com/solana-labs/solana-program-library/blob/d72289c79a04411c69a8bf1054f7156b6196f9b3/token/js/src/actions/getOrCreateAssociatedTokenAccount.ts getOrCreateAssociatedTokenAccount}
   */
  async getOrCreateProgramTokenAccount(params) {
    const args = await parseParams('getOrCreateProgramTokenAccount', GetOrCreateProgramTokenAccountSchema)(params);
    const mint = parseMint(args.mint, this.mints);
    // Check for cached account
    const existingTokenAccount = this.existingTokenAccounts[mint.toBase58()];
    if (existingTokenAccount) {
      return existingTokenAccount;
    }
    const associatedTokenAdddress = getAssociatedTokenAddressSync(mint, this.programAccount, true);
    let account = null;
    try {
      account = await getAccount(this.client.connection, associatedTokenAdddress);
      this.existingTokenAccounts[mint.toBase58()] = account;
    } catch (error) {
      if (error instanceof TokenAccountNotFoundError) {
        // As this isn't atomic, it's possible others can create associated accounts meanwhile.
        try {
          const instruction = createAssociatedTokenAccountIdempotentInstruction(await this.client.getFeePayer(), associatedTokenAdddress, this.programAccount, mint);
          const {
            lastValidBlockHeight,
            blockhash
          } = await this.client.connection.getLatestBlockhash();
          const msg = new TransactionMessage({
            payerKey: await this.client.getFeePayer(),
            recentBlockhash: blockhash,
            instructions: [instruction]
          });
          const transaction = new VersionedTransaction(msg.compileToV0Message());
          const signature = await this.client.sendTransaction(transaction);
          await this.client.connection.confirmTransaction({
            signature,
            blockhash,
            lastValidBlockHeight
          }, 'finalized');
        } catch (e) {
          // Ignore all errors; for now there is no API-compatible way to selectively ignore the expected
          // instruction error if the associated account exists already.
        }
        // Now this should always succeed
        account = await getAccount(this.client.connection, associatedTokenAdddress);
      } else {
        throw error;
      }
    }
    if (!account.mint.equals(mint)) throw new TokenInvalidMintError();
    if (!account.owner.equals(this.programAccount)) throw new TokenInvalidOwnerError();
    return account;
  }
}

var StemCategory;
(function (StemCategory) {
  StemCategory["INSTRUMENTAL"] = "INSTRUMENTAL";
  StemCategory["LEAD_VOCALS"] = "LEAD_VOCALS";
  StemCategory["MELODIC_LEAD"] = "MELODIC_LEAD";
  StemCategory["PAD"] = "PAD";
  StemCategory["SNARE"] = "SNARE";
  StemCategory["KICK"] = "KICK";
  StemCategory["HIHAT"] = "HIHAT";
  StemCategory["PERCUSSION"] = "PERCUSSION";
  StemCategory["SAMPLE"] = "SAMPLE";
  StemCategory["BACKING_VOX"] = "BACKING_VOX";
  StemCategory["BASS"] = "BASS";
  StemCategory["OTHER"] = "OTHER";
})(StemCategory || (StemCategory = {}));

const MAX_DESCRIPTION_LENGTH = 2500;

const messages = {
  titleRequiredError: 'Your track must have a name',
  artworkRequiredError: 'Artwork is required',
  genreRequiredError: 'Genre is required',
  genreAllError: 'Genre cannot be set to "All Genres"'
};
const EthCollectibleGatedConditions = z.object({
  chain: z.literal('eth'),
  address: z.string(),
  standard: z.union([z.literal('ERC721'), z.literal('ERC1155')]),
  name: z.string(),
  slug: z.string(),
  imageUrl: z.optional(z.string()),
  externalLink: z.optional(z.string()).nullable()
}).strict();
const SolCollectibleGatedConditions = z.object({
  chain: z.literal('sol'),
  address: z.string(),
  name: z.string(),
  imageUrl: z.optional(z.string()),
  externalLink: z.optional(z.string()).nullable()
}).strict();
const CollectibleGatedConditions = z.object({
  nftCollection: z.optional(z.union([EthCollectibleGatedConditions, SolCollectibleGatedConditions]))
}).strict();
const FollowGatedConditions = z.object({
  followUserId: z.number()
}).strict();
const TipGatedConditions = z.object({
  tipUserId: z.number()
}).strict();
const TokenGatedConditions = z.object({
  tokenGate: z.object({
    tokenMint: z.string(),
    tokenAmount: z.number()
  })
}).strict();
const USDCPurchaseConditions = z.object({
  usdcPurchase: z.object({
    price: z.number().positive(),
    splits: z.any()
  })
}).strict();
const UploadTrackMetadataSchema = z.object({
  trackId: z.optional(HashId),
  aiAttributionUserId: z.optional(HashId),
  description: z.optional(z.string().max(MAX_DESCRIPTION_LENGTH)),
  fieldVisibility: z.optional(z.object({
    mood: z.optional(z.boolean()),
    tags: z.optional(z.boolean()),
    genre: z.optional(z.boolean()),
    share: z.optional(z.boolean()),
    playCount: z.optional(z.boolean()),
    remixes: z.optional(z.boolean())
  })),
  genre: z.enum(Object.values(Genre)).nullable().refine(val => val !== null, {
    message: messages.genreRequiredError
  }).refine(val => val !== Genre.ALL, {
    message: messages.genreAllError
  }),
  isrc: z.optional(z.string().nullable()),
  isUnlisted: z.optional(z.boolean()),
  iswc: z.optional(z.string().nullable()),
  license: z.optional(z.string().nullable()),
  mood: z.optional(z.enum(Object.values(Mood))).nullable(),
  isStreamGated: z.optional(z.boolean()),
  streamConditions: z.optional(z.union([CollectibleGatedConditions, FollowGatedConditions, TipGatedConditions, USDCPurchaseConditions, TokenGatedConditions])).nullable(),
  isDownloadGated: z.optional(z.boolean()),
  downloadConditions: z.optional(z.union([CollectibleGatedConditions, FollowGatedConditions, TipGatedConditions, USDCPurchaseConditions, TokenGatedConditions])).nullable(),
  releaseDate: z.optional(z.date()),
  remixOf: z.optional(z.object({
    tracks: z.array(z.object({
      parentTrackId: HashId
    })).min(1)
  }).strict()),
  stemOf: z.optional(z.object({
    category: z.enum(Object.values(StemCategory)).default(StemCategory.OTHER),
    parentTrackId: HashId
  })),
  tags: z.optional(z.string()),
  title: z.string({
    required_error: messages.titleRequiredError
  }),
  duration: z.optional(z.number()),
  previewStartSeconds: z.optional(z.number()),
  placementHosts: z.optional(z.string()),
  audioUploadId: z.optional(z.string()),
  trackCid: z.optional(z.string()),
  previewCid: z.optional(z.string()),
  origFileCid: z.optional(z.string()),
  origFilename: z.optional(z.string()),
  isDownloadable: z.optional(z.boolean()),
  isOriginalAvailable: z.optional(z.boolean()),
  ddexReleaseIds: z.optional(z.record(z.string()).nullable()),
  ddexApp: z.optional(z.string()),
  artists: z.optional(z.array(DDEXResourceContributor)).nullable(),
  resourceContributors: z.optional(z.array(DDEXResourceContributor).nullable()),
  indirectResourceContributors: z.optional(z.array(DDEXResourceContributor).nullable()),
  rightsController: z.optional(DDEXRightsController.nullable()),
  copyrightLine: z.optional(DDEXCopyright.nullable()),
  producerCopyrightLine: z.optional(DDEXCopyright.nullable()),
  parentalWarningType: z.optional(z.string().nullable()),
  bpm: z.optional(z.number().nullable()),
  isCustomBpm: z.optional(z.boolean()),
  musicalKey: z.optional(z.string().nullable()),
  isCustomMusicalKey: z.optional(z.boolean()),
  audioAnalysisErrorCount: z.optional(z.number()),
  commentsDisabled: z.optional(z.boolean()),
  isScheduledRelease: z.optional(z.boolean())
});
const UploadTrackSchema = z.object({
  userId: HashId,
  coverArtFile: ImageFile,
  metadata: UploadTrackMetadataSchema.strict(),
  onProgress: z.optional(z.function()),
  trackFile: AudioFile
}).strict();
const UploadTrackFilesSchema = z.object({
  userId: HashId,
  coverArtFile: z.optional(ImageFile),
  metadata: UploadTrackMetadataSchema.extend({
    genre: z.optional(z.enum(Object.values(Genre)))
  }).strict(),
  onProgress: z.optional(z.function()),
  trackFile: AudioFile
}).strict();
const UpdateTrackSchema = z.object({
  userId: HashId,
  trackId: HashId,
  metadata: UploadTrackMetadataSchema.strict().partial(),
  generatePreview: z.optional(z.boolean()),
  coverArtFile: z.optional(ImageFile),
  onProgress: z.optional(z.function())
}).strict();
const DeleteTrackSchema = z.object({
  userId: HashId,
  trackId: HashId
}).strict();
const FavoriteTrackSchema = z.object({
  userId: HashId,
  trackId: HashId,
  metadata: z.optional(z.object({
    /**
     * Is this a save of a repost? Used to dispatch notifications
     * when a user favorites another user's repost
     */
    isSaveOfRepost: z.boolean()
  }).strict())
}).strict();
const UnfavoriteTrackSchema = z.object({
  userId: HashId,
  trackId: HashId
}).strict();
const RepostTrackSchema = z.object({
  userId: HashId,
  trackId: HashId,
  metadata: z.optional(z.object({
    /**
     * Is this a repost of a repost? Used to dispatch notifications
     * when a user favorites another user's repost
     */
    isRepostOfRepost: z.boolean()
  }).strict())
}).strict();
const UnrepostTrackSchema = z.object({
  userId: HashId,
  trackId: HashId
}).strict();
const RecordTrackDownloadSchema = z.object({
  userId: HashId.optional(),
  trackId: HashId
}).strict();
const ShareTrackSchema = z.object({
  userId: HashId,
  trackId: HashId
}).strict();
const PurchaseTrackSchemaBase = z.object({
  /** The ID of the user purchasing the track. */
  userId: HashId,
  /** The ID of the track to purchase. */
  trackId: HashId,
  /**
   * The price of the track at the time of purchase (in dollars if number, USDC if bigint).
   * Used to check against current track price in case it changed,
   * effectively setting a "max price" for the purchase.
   */
  price: z.union([z.number().min(0), z.bigint().min(BigInt(0))]),
  /** Any extra amount the user wants to donate (in dollars if number, USDC if bigint) */
  extraAmount: z.union([z.number().min(0), z.bigint().min(BigInt(0))]).optional(),
  /** Whether to include the staking system as a recipient */
  includeNetworkCut: z.boolean().optional()
});
const GetPurchaseTrackInstructionsSchema = z.object({}).merge(PurchaseTrackSchemaBase);
const PurchaseTrackSchema = z.object({
  /** A wallet to use to purchase (defaults to the authed user's user bank if not specified) */
  walletAdapter: z.custom().optional(),
  /** A wallet to use to purchase (defaults to the authed user's user bank if not specified) */
  wallet: PublicKeySchema.optional()
}).merge(PurchaseTrackSchemaBase).strict();

const CreatePlaylistMetadataSchema = z.object({
  description: z.optional(z.string().max(1000)),
  playlistName: z.string(),
  isPrivate: z.optional(z.boolean()),
  coverArtCid: z.optional(z.string()),
  license: z.optional(z.string()),
  mood: z.optional(z.enum(Object.values(Mood))),
  releaseDate: z.optional(z.date()),
  ddexReleaseIds: z.optional(z.record(z.string()).nullable()),
  ddexApp: z.optional(z.string()),
  tags: z.optional(z.string()),
  upc: z.optional(z.string()),
  artists: z.optional(z.array(DDEXResourceContributor).nullable()),
  copyrightLine: z.optional(DDEXCopyright.nullable()),
  producerCopyrightLine: z.optional(DDEXCopyright.nullable()),
  parentalWarningType: z.optional(z.string().nullable()),
  isImageAutogenerated: z.optional(z.boolean()).nullable()
}).strict();
const CreatePlaylistSchema = z.object({
  playlistId: z.optional(HashId),
  coverArtFile: z.optional(ImageFile),
  metadata: CreatePlaylistMetadataSchema,
  onProgress: z.optional(z.function()),
  trackIds: z.optional(z.array(HashId)),
  userId: HashId
}).strict();
const UploadPlaylistMetadataSchema = CreatePlaylistMetadataSchema.extend({
  genre: z.enum(Object.values(Genre))
}).strict();
const PlaylistTrackMetadataSchema = UploadTrackMetadataSchema.partial({
  genre: true,
  mood: true,
  tags: true
});
const UpdatePlaylistMetadataSchema = UploadPlaylistMetadataSchema.partial().merge(z.object({
  isPrivate: z.optional(z.boolean()),
  playlistContents: z.optional(z.array(z.object({
    timestamp: z.number(),
    metadataTimestamp: z.optional(z.number()),
    trackId: HashId
  }))),
  coverArtCid: z.optional(z.string())
})).strict();
const UpdatePlaylistSchema = z.object({
  userId: HashId,
  playlistId: HashId,
  coverArtFile: z.optional(ImageFile),
  metadata: UpdatePlaylistMetadataSchema,
  onProgress: z.optional(z.function())
}).strict();
const UploadPlaylistSchema = z.object({
  userId: HashId,
  coverArtFile: ImageFile,
  metadata: UploadPlaylistMetadataSchema,
  onProgress: z.optional(z.function()),
  /**
   * Track metadata is populated from the playlist if fields are missing
   */
  trackMetadatas: z.array(PlaylistTrackMetadataSchema),
  trackFiles: z.array(AudioFile)
}).strict();
const PublishPlaylistSchema = z.object({
  userId: HashId,
  playlistId: HashId
}).strict();
const AddTrackToPlaylistSchema = z.object({
  userId: HashId,
  playlistId: HashId,
  trackId: HashId
}).strict();
const RemoveTrackFromPlaylistSchema = z.object({
  userId: HashId,
  playlistId: HashId,
  trackIndex: z.number()
}).strict();
const DeletePlaylistSchema = z.object({
  userId: HashId,
  playlistId: HashId
}).strict();
const FavoritePlaylistSchema = z.object({
  userId: HashId,
  playlistId: HashId,
  metadata: z.optional(z.object({
    /**
     * Is this a save of a repost? Used to dispatch notifications
     * when a user favorites another user's repost
     */
    isSaveOfRepost: z.boolean()
  }).strict())
}).strict();
const UnfavoritePlaylistSchema = z.object({
  userId: HashId,
  playlistId: HashId
}).strict();
const RepostPlaylistSchema = z.object({
  userId: HashId,
  playlistId: HashId,
  metadata: z.optional(z.object({
    /**
     * Is this a repost of a repost? Used to dispatch notifications
     * when a user favorites another user's repost
     */
    isRepostOfRepost: z.boolean()
  }).strict())
}).strict();
const UnrepostPlaylistSchema = z.object({
  userId: HashId,
  playlistId: HashId
}).strict();
const SharePlaylistSchema = z.object({
  userId: HashId,
  playlistId: HashId
}).strict();

// Returns current timestamp in seconds, which is the expected
// format for client-generated playlist entry timestamps
const getCurrentTimestamp = () => {
  return Math.floor(Date.now() / 1000);
};
class PlaylistsApi$1 extends PlaylistsApi$2 {
  constructor(configuration, storage, entityManager, logger) {
    super(configuration);
    _defineProperty$1(this, "storage", void 0);
    _defineProperty$1(this, "entityManager", void 0);
    _defineProperty$1(this, "logger", void 0);
    _defineProperty$1(this, "trackUploadHelper", void 0);
    this.storage = storage;
    this.entityManager = entityManager;
    this.logger = logger;
    this.trackUploadHelper = new TrackUploadHelper(configuration);
    this.logger = logger.createPrefixedLogger('[playlists-api]');
  }
  /** @hidden
   * Create a playlist from existing tracks
   */
  async createPlaylist(params, advancedOptions) {
    // Parse inputs
    const parsedParameters = await parseParams('createPlaylist', CreatePlaylistSchema)(params);
    // Call createPlaylistInternal with parsed inputs
    return await this.createPlaylistInternal(parsedParameters, advancedOptions);
  }
  /** @hidden
   * Upload a playlist
   * Uploads the specified tracks and combines them into a playlist
   */
  async uploadPlaylist(params, advancedOptions) {
    // Parse inputs
    const parsedParameters = await parseParams('uploadPlaylist', UploadPlaylistSchema)(params);
    // Call uploadPlaylistInternal with parsed inputs
    return await this.uploadPlaylistInternal(parsedParameters, advancedOptions);
  }
  /** @hidden
   * Publish a playlist
   * Changes a playlist from private to public
   */
  async publishPlaylist(params, advancedOptions) {
    // Parse inputs
    await parseParams('publishPlaylist', PublishPlaylistSchema)(params);
    return await this.fetchAndUpdatePlaylist({
      userId: params.userId,
      playlistId: params.playlistId,
      updateMetadata: playlist => ({
        ...playlist,
        isPrivate: false
      })
    }, advancedOptions);
  }
  /** @hidden
   * Add a single track to the end of a playlist
   * For more control use updatePlaylist
   */
  async addTrackToPlaylist(params, advancedOptions) {
    // Parse inputs
    await parseParams('addTrackToPlaylist', AddTrackToPlaylistSchema)(params);
    return await this.fetchAndUpdatePlaylist({
      userId: params.userId,
      playlistId: params.playlistId,
      updateMetadata: playlist => {
        var _playlist$playlistCon;
        return {
          ...playlist,
          playlistContents: [...((_playlist$playlistCon = playlist.playlistContents) !== null && _playlist$playlistCon !== void 0 ? _playlist$playlistCon : []), {
            trackId: params.trackId,
            timestamp: getCurrentTimestamp()
          }]
        };
      }
    }, advancedOptions);
  }
  /** @hidden
   * Removes a single track at the given index of playlist
   * For more control use updatePlaylist
   */
  async removeTrackFromPlaylist(params, advancedOptions) {
    // Parse inputs
    const {
      trackIndex
    } = await parseParams('removeTrackFromPlaylist', RemoveTrackFromPlaylistSchema)(params);
    return await this.fetchAndUpdatePlaylist({
      userId: params.userId,
      playlistId: params.playlistId,
      updateMetadata: playlist => {
        if (!playlist.playlistContents || playlist.playlistContents.length <= trackIndex) {
          throw new Error(`No track exists at index ${trackIndex}`);
        }
        playlist.playlistContents.splice(trackIndex, 1);
        return {
          ...playlist,
          playlistContents: playlist.playlistContents
        };
      }
    }, advancedOptions);
  }
  /** @hidden
   * Update a playlist
   */
  async updatePlaylist(params, advancedOptions) {
    // Parse inputs
    const parsedParameters = await parseParams('updatePlaylist', UpdatePlaylistSchema)(params);
    // Call updatePlaylistInternal with parsed inputs
    return await this.updatePlaylistInternal(parsedParameters, advancedOptions);
  }
  /** @hidden
   * Delete a playlist
   */
  async deletePlaylist(params, advancedOptions) {
    // Parse inputs
    const {
      userId,
      playlistId
    } = await parseParams('deletePlaylist', DeletePlaylistSchema)(params);
    return await this.entityManager.manageEntity({
      userId,
      entityType: EntityType.PLAYLIST,
      entityId: playlistId,
      action: Action.DELETE,
      ...advancedOptions
    });
  }
  /** @hidden
   * Favorite a playlist
   */
  async favoritePlaylist(params, advancedOptions) {
    // Parse inputs
    const {
      userId,
      playlistId,
      metadata
    } = await parseParams('favoritePlaylist', FavoritePlaylistSchema)(params);
    return await this.entityManager.manageEntity({
      userId,
      entityType: EntityType.PLAYLIST,
      entityId: playlistId,
      action: Action.SAVE,
      metadata: metadata && JSON.stringify(snakecaseKeys(metadata)),
      ...advancedOptions
    });
  }
  /** @hidden
   * Unfavorite a playlist
   */
  async unfavoritePlaylist(params, advancedOptions) {
    // Parse inputs
    const {
      userId,
      playlistId
    } = await parseParams('unfavoritePlaylist', UnfavoritePlaylistSchema)(params);
    return await this.entityManager.manageEntity({
      userId,
      entityType: EntityType.PLAYLIST,
      entityId: playlistId,
      action: Action.UNSAVE,
      ...advancedOptions
    });
  }
  /** @hidden
   * Repost a playlist
   */
  async repostPlaylist(params, advancedOptions) {
    // Parse inputs
    const {
      userId,
      playlistId,
      metadata
    } = await parseParams('respostPlaylist', RepostPlaylistSchema)(params);
    return await this.entityManager.manageEntity({
      userId,
      entityType: EntityType.PLAYLIST,
      entityId: playlistId,
      action: Action.REPOST,
      metadata: metadata && JSON.stringify(snakecaseKeys(metadata)),
      ...advancedOptions
    });
  }
  /** @hidden
   * Unrepost a playlist
   */
  async unrepostPlaylist(params, advancedOptions) {
    // Parse inputs
    const {
      userId,
      playlistId
    } = await parseParams('unrepostPlaylist', UnrepostPlaylistSchema)(params);
    return await this.entityManager.manageEntity({
      userId,
      entityType: EntityType.PLAYLIST,
      entityId: playlistId,
      action: Action.UNREPOST,
      ...advancedOptions
    });
  }
  /** @hidden
   * Share a playlist
   */
  async sharePlaylist(params, advancedOptions) {
    // Parse inputs
    const {
      userId,
      playlistId
    } = await parseParams('sharePlaylist', SharePlaylistSchema)(params);
    return await this.entityManager.manageEntity({
      userId,
      entityType: EntityType.PLAYLIST,
      entityId: playlistId,
      action: Action.SHARE,
      ...advancedOptions
    });
  }
  /** @internal
   * Combines the metadata for a track and a collection (playlist or album),
   * taking the metadata from the playlist when the track is missing it.
   */
  combineMetadata(trackMetadata, playlistMetadata) {
    const metadata = trackMetadata;
    if (!metadata.mood) metadata.mood = playlistMetadata.mood;
    if (playlistMetadata.tags) {
      if (!metadata.tags) {
        // Take playlist tags
        metadata.tags = playlistMetadata.tags;
      } else {
        // Combine tags and dedupe
        metadata.tags = [...new Set([...metadata.tags.split(','), ...playlistMetadata.tags.split(',')])].join(',');
      }
    }
    return trackMetadata;
  }
  /** @internal
   * Update helper method that first fetches a playlist and then updates it
   */
  async fetchAndUpdatePlaylist(_ref, advancedOptions) {
    var _playlistResponse$dat;
    let {
      userId,
      playlistId,
      updateMetadata
    } = _ref;
    // Fetch playlist
    const playlistResponse = await this.getPlaylist({
      playlistId,
      userId
    });
    const playlist = (_playlistResponse$dat = playlistResponse.data) === null || _playlistResponse$dat === void 0 ? void 0 : _playlistResponse$dat[0];
    if (!playlist) {
      throw new Error(`Could not fetch playlist: ${playlistId}`);
    }
    const supportedUpdateFields = Object.keys(UpdatePlaylistMetadataSchema.shape);
    return await this.updatePlaylist({
      userId,
      playlistId,
      metadata: updateMetadata(pick(playlist, supportedUpdateFields))
    }, advancedOptions);
  }
  /** @internal
   * Method to upload a playlist with already parsed inputs
   * This is used for both playlists and albums
   */
  async uploadPlaylistInternal(_ref2, advancedOptions) {
    let {
      userId,
      coverArtFile,
      trackFiles,
      onProgress,
      metadata,
      trackMetadatas
    } = _ref2;
    // Upload track audio and cover art to storage node
    const [coverArtResponse, ...audioResponses] = await Promise.all([retry3(async () => await this.storage.uploadFile({
      file: coverArtFile,
      onProgress,
      template: 'img_square'
    }), e => {
      this.logger.info('Retrying uploadPlaylistCoverArt', e);
    }), ...trackFiles.map(async (trackFile, idx) => await retry3(async () => await this.storage.uploadFile({
      file: trackFile,
      onProgress,
      template: 'audio',
      options: this.trackUploadHelper.extractMediorumUploadOptions(trackMetadatas[idx])
    }), e => {
      this.logger.info('Retrying uploadTrackAudio', e);
    }))]);
    // Write tracks to chain
    const trackIds = await Promise.all(trackMetadatas.map(async (parsedTrackMetadata, i) => {
      // Transform track metadata
      const trackMetadata = this.combineMetadata(this.trackUploadHelper.transformTrackUploadMetadata(parsedTrackMetadata, userId), metadata);
      const audioResponse = audioResponses[i];
      if (!audioResponse) {
        throw new Error(`Failed to upload track: ${trackMetadata.title}`);
      }
      // Update metadata to include uploaded CIDs
      const updatedMetadata = this.trackUploadHelper.populateTrackMetadataWithUploadResponse(trackMetadata, audioResponse, coverArtResponse);
      const trackId = await this.trackUploadHelper.generateId('track');
      await this.entityManager.manageEntity({
        userId,
        entityType: EntityType.TRACK,
        entityId: trackId,
        action: Action.CREATE,
        metadata: JSON.stringify({
          cid: '',
          data: snakecaseKeys(updatedMetadata)
        }),
        ...advancedOptions
      });
      return trackId;
    }));
    const playlistId = await this.trackUploadHelper.generateId('playlist');
    const timestamp = getCurrentTimestamp();
    // Update metadata to include track ids and cover art cid
    const updatedMetadata = {
      ...metadata,
      isPrivate: false,
      playlistContents: trackIds.map(trackId => ({
        trackId,
        timestamp
      })),
      playlistImageSizesMultihash: coverArtResponse.id
    };
    // Write playlist metadata to chain
    const response = await this.entityManager.manageEntity({
      userId,
      entityType: EntityType.PLAYLIST,
      entityId: playlistId,
      action: Action.CREATE,
      metadata: JSON.stringify({
        cid: '',
        data: snakecaseKeys(updatedMetadata)
      }),
      ...advancedOptions
    });
    return {
      ...response,
      playlistId: encodeHashId(playlistId)
    };
  }
  /** @internal
   * Method to update a playlist with already parsed inputs
   * This is used for both playlists and albums
   */
  async updatePlaylistInternal(_ref3, advancedOptions) {
    let {
      userId,
      playlistId,
      coverArtFile,
      onProgress,
      metadata
    } = _ref3;
    // Upload cover art to storage node
    const coverArtResponse = coverArtFile && (await retry3(async () => await this.storage.uploadFile({
      file: coverArtFile,
      onProgress,
      template: 'img_square'
    }), e => {
      this.logger.info('Retrying uploadPlaylistCoverArt', e);
    }));
    const updatedMetadata = {
      ...metadata,
      ...(coverArtResponse ? {
        playlistImageSizesMultihash: coverArtResponse.id
      } : {})
    };
    return await this.entityManager.manageEntity({
      userId,
      entityType: EntityType.PLAYLIST,
      entityId: playlistId,
      action: Action.UPDATE,
      metadata: JSON.stringify({
        cid: '',
        data: snakecaseKeys(updatedMetadata)
      }),
      ...advancedOptions
    });
  }
  /** @internal
   * Method to create a playlist with already parsed inputs
   * This is used for both playlists and albums
   */
  async createPlaylistInternal(_ref4, advancedOptions) {
    var _coverArtResponse$id;
    let {
      userId,
      coverArtFile,
      metadata,
      onProgress,
      trackIds,
      playlistId: providedPlaylistId
    } = _ref4;
    // Upload cover art to storage node
    const coverArtResponse = coverArtFile && (await retry3(async () => await this.storage.uploadFile({
      file: coverArtFile,
      onProgress,
      template: 'img_square'
    }), e => {
      this.logger.info('Retrying uploadPlaylistCoverArt', e);
    }));
    const playlistId = providedPlaylistId || (await this.generatePlaylistId());
    const timestamp = getCurrentTimestamp();
    // Update metadata to include track ids
    const updatedMetadata = {
      ...metadata,
      playlistContents: (trackIds !== null && trackIds !== void 0 ? trackIds : []).map(trackId => ({
        trackId,
        timestamp
      })),
      playlistImageSizesMultihash: (_coverArtResponse$id = coverArtResponse === null || coverArtResponse === void 0 ? void 0 : coverArtResponse.id) !== null && _coverArtResponse$id !== void 0 ? _coverArtResponse$id : metadata.coverArtCid
    };
    // Write playlist metadata to chain
    const response = await this.entityManager.manageEntity({
      userId,
      entityType: EntityType.PLAYLIST,
      entityId: playlistId,
      action: Action.CREATE,
      metadata: JSON.stringify({
        cid: '',
        data: snakecaseKeys(updatedMetadata)
      }),
      ...advancedOptions
    });
    return {
      ...response,
      playlistId: encodeHashId(playlistId)
    };
  }
  /**
   * Generates a new playlist ID
   *
   * @hidden
   */
  async generatePlaylistId() {
    return this.trackUploadHelper.generateId('playlist');
  }
}

const getAlbumSchema = z.object({
  userId: HashId.optional(),
  albumId: HashId
});
const getAlbumsSchema = z.object({
  userId: HashId.optional(),
  id: z.array(HashId)
});
const getAlbumTracksSchema = z.object({
  albumId: HashId
});
const CreateAlbumMetadataSchema = z.object({
  albumName: z.string(),
  isPrivate: z.optional(z.boolean()),
  description: z.optional(z.string().max(1000)),
  license: z.optional(z.string()),
  releaseDate: z.optional(z.date()),
  ddexReleaseIds: z.optional(z.record(z.string()).nullable()),
  ddexApp: z.optional(z.string()),
  upc: z.optional(z.string()),
  artists: z.optional(z.array(DDEXResourceContributor).nullable()),
  copyrightLine: z.optional(DDEXCopyright.nullable()),
  producerCopyrightLine: z.optional(DDEXCopyright.nullable()),
  parentalWarningType: z.optional(z.string().nullable()),
  isStreamGated: z.optional(z.boolean()),
  streamConditions: z.optional(USDCPurchaseConditions).nullable(),
  isDownloadGated: z.optional(z.boolean()),
  downloadConditions: z.optional(USDCPurchaseConditions).nullable(),
  isScheduledRelease: z.optional(z.boolean())
}).strict();
const CreateAlbumSchema = z.object({
  albumId: z.optional(HashId),
  userId: HashId,
  coverArtFile: z.optional(ImageFile),
  metadata: CreateAlbumMetadataSchema,
  onProgress: z.optional(z.function()),
  trackIds: z.optional(z.array(HashId))
}).strict();
const UploadAlbumMetadataSchema = CreateAlbumMetadataSchema.extend({
  genre: z.enum(Object.values(Genre)),
  mood: z.optional(z.enum(Object.values(Mood))),
  tags: z.optional(z.string())
});
const AlbumTrackMetadataSchema = UploadTrackMetadataSchema.partial({
  genre: true,
  mood: true,
  tags: true,
  isStreamGated: true,
  streamConditions: true,
  isDownloadable: true,
  downloadConditions: true
});
const UpdateAlbumMetadataSchema = UploadAlbumMetadataSchema.partial().merge(z.object({
  playlistContents: z.optional(z.array(z.object({
    timestamp: z.number(),
    metadataTimestamp: z.optional(z.number()),
    trackId: HashId
  })))
})).strict();
const UploadAlbumSchema = z.object({
  userId: HashId,
  coverArtFile: ImageFile,
  metadata: UploadAlbumMetadataSchema,
  onProgress: z.optional(z.function()),
  /**
   * Track metadata is populated from the album if fields are missing
   */
  trackMetadatas: z.array(AlbumTrackMetadataSchema),
  trackFiles: z.array(AudioFile)
}).strict();
const UpdateAlbumSchema = z.object({
  userId: HashId,
  albumId: HashId,
  coverArtFile: z.optional(ImageFile),
  metadata: UpdateAlbumMetadataSchema,
  onProgress: z.optional(z.function())
}).strict();
const DeleteAlbumSchema = z.object({
  userId: HashId,
  albumId: HashId
}).strict();
const FavoriteAlbumSchema = z.object({
  userId: HashId,
  albumId: HashId,
  metadata: z.optional(z.object({
    /**
     * Is this a save of a repost? Used to dispatch notifications
     * when a user favorites another user's repost
     */
    isSaveOfRepost: z.boolean()
  }))
}).strict();
const UnfavoriteAlbumSchema = z.object({
  userId: HashId,
  albumId: HashId
}).strict();
const RepostAlbumSchema = z.object({
  userId: HashId,
  albumId: HashId,
  metadata: z.optional(z.object({
    /**
     * Is this a repost of a repost? Used to dispatch notifications
     * when a user favorites another user's repost
     */
    isRepostOfRepost: z.boolean()
  }))
}).strict();
const UnrepostAlbumSchema = z.object({
  userId: HashId,
  albumId: HashId
}).strict();
const PurchaseAlbumSchemaBase = z.object({
  /** The ID of the user purchasing the album. */
  userId: HashId,
  /** The ID of the album to purchase. */
  albumId: HashId,
  /**
   * The price of the album at the time of purchase (in dollars if number, USDC if bigint).
   * Used to check against current album price in case it changed,
   * effectively setting a "max price" for the purchase.
   */
  price: z.union([z.number().min(0), z.bigint().min(BigInt(0))]),
  /** Any extra amount the user wants to donate (in dollars if number, USDC if bigint) */
  extraAmount: z.union([z.number().min(0), z.bigint().min(BigInt(0))]).optional(),
  /** Whether to include the staking system as a recipient */
  includeNetworkCut: z.boolean().optional()
});
const GetPurchaseAlbumInstructionsSchema = z.object({}).merge(PurchaseAlbumSchemaBase);
const PurchaseAlbumSchema = z.object({
  /** A wallet to use to purchase (defaults to the authed user's user bank if not specified) */
  walletAdapter: z.custom().optional(),
  /** A wallet to use to purchase (defaults to the authed user's user bank if not specified) */
  wallet: PublicKeySchema.optional()
}).merge(PurchaseAlbumSchemaBase).strict();

class AlbumsApi {
  constructor(configuration, storage, entityManager, logger, claimableTokensClient, paymentRouterClient, solanaRelay, solanaClient) {
    _defineProperty$1(this, "logger", void 0);
    _defineProperty$1(this, "claimableTokensClient", void 0);
    _defineProperty$1(this, "paymentRouterClient", void 0);
    _defineProperty$1(this, "solanaRelay", void 0);
    _defineProperty$1(this, "solanaClient", void 0);
    _defineProperty$1(this, "playlistsApi", void 0);
    this.logger = logger;
    this.claimableTokensClient = claimableTokensClient;
    this.paymentRouterClient = paymentRouterClient;
    this.solanaRelay = solanaRelay;
    this.solanaClient = solanaClient;
    this.playlistsApi = new PlaylistsApi$1(configuration, storage, entityManager, logger);
  }
  // READS
  async getAlbum(params) {
    const {
      userId,
      albumId
    } = params;
    return await this.playlistsApi.getPlaylist({
      userId,
      playlistId: albumId
    });
  }
  async getBulkAlbums(params) {
    const {
      userId,
      id
    } = params;
    return await this.playlistsApi.getBulkPlaylists({
      userId,
      id
    });
  }
  async getAlbumTracks(params) {
    const {
      albumId
    } = params;
    return await this.playlistsApi.getPlaylistTracks({
      playlistId: albumId
    });
  }
  // WRITES
  /** @hidden
   * Create an album from existing tracks
   */
  async createAlbum(params, advancedOptions) {
    // Parse inputs
    const {
      metadata,
      ...parsedParameters
    } = await parseParams('createAlbum', CreateAlbumSchema)(params);
    const {
      albumName,
      ...playlistMetadata
    } = metadata;
    // Call createPlaylistInternal with parsed inputs
    const response = await this.playlistsApi.createPlaylistInternal({
      ...parsedParameters,
      playlistId: parsedParameters.albumId,
      metadata: {
        ...playlistMetadata,
        playlistName: albumName,
        isAlbum: true
      }
    }, advancedOptions);
    return {
      ...response,
      albumId: response.playlistId
    };
  }
  /** @hidden
   * Upload an album
   * Uploads the specified tracks and combines them into an album
   */
  async uploadAlbum(params, advancedOptions) {
    const {
      metadata,
      ...parsedParameters
    } = await parseParams('uploadAlbum', UploadAlbumSchema)(params);
    const {
      albumName,
      ...playlistMetadata
    } = metadata;
    // Call uploadPlaylistInternal with parsed inputs
    const response = await this.playlistsApi.uploadPlaylistInternal({
      ...parsedParameters,
      metadata: {
        ...playlistMetadata,
        playlistName: albumName,
        isAlbum: true
      }
    }, advancedOptions);
    return {
      blockHash: response.blockHash,
      blockNumber: response.blockNumber,
      albumId: response.playlistId
    };
  }
  /** @hidden
   * Update an album
   */
  async updateAlbum(params, advancedOptions) {
    const {
      albumId,
      metadata,
      ...parsedParameters
    } = await parseParams('updateAlbum', UpdateAlbumSchema)(params);
    const {
      albumName,
      ...playlistMetadata
    } = metadata;
    // Call updatePlaylistInternal with parsed inputs
    return await this.playlistsApi.updatePlaylistInternal({
      ...parsedParameters,
      playlistId: albumId,
      metadata: {
        ...playlistMetadata,
        playlistName: albumName
      }
    }, advancedOptions);
  }
  /** @hidden
   * Delete an album
   */
  async deleteAlbum(params, advancedOptions) {
    await parseParams('deleteAlbum', DeleteAlbumSchema)(params);
    return await this.playlistsApi.deletePlaylist({
      userId: params.userId,
      playlistId: params.albumId
    }, advancedOptions);
  }
  /** @hidden
   * Favorite an album
   */
  async favoriteAlbum(params, advancedOptions) {
    const {
      metadata
    } = await parseParams('favoriteAlbum', FavoriteAlbumSchema)(params);
    return await this.playlistsApi.favoritePlaylist({
      userId: params.userId,
      playlistId: params.albumId,
      metadata
    }, advancedOptions);
  }
  /** @hidden
   * Unfavorite an album
   */
  async unfavoriteAlbum(params, advancedOptions) {
    await parseParams('unfavoriteAlbum', UnfavoriteAlbumSchema)(params);
    return await this.playlistsApi.unfavoritePlaylist({
      userId: params.userId,
      playlistId: params.albumId
    }, advancedOptions);
  }
  /** @hidden
   * Repost an album
   */
  async repostAlbum(params, advancedOptions) {
    const {
      metadata
    } = await parseParams('repostAlbum', RepostAlbumSchema)(params);
    return await this.playlistsApi.repostPlaylist({
      userId: params.userId,
      playlistId: params.albumId,
      metadata
    }, advancedOptions);
  }
  /** @hidden
   * Unrepost an album
   */
  async unrepostAlbum(params, advancedOptions) {
    await parseParams('unrepostAlbum', UnrepostAlbumSchema)(params);
    return await this.playlistsApi.unrepostPlaylist({
      userId: params.userId,
      playlistId: params.albumId
    }, advancedOptions);
  }
  /**
   * Gets the Solana instructions that purchase the album
   *
   * @hidden
   */
  async getPurchaseAlbumInstructions(params) {
    var _album$access;
    const {
      userId,
      albumId,
      price: priceNumber,
      extraAmount: extraAmountNumber = 0
    } = await parseParams('getPurchaseAlbumInstructions', GetPurchaseAlbumInstructionsSchema)(params);
    const contentType = 'album';
    const mint = 'USDC';
    // Fetch album
    this.logger.debug('Fetching album...', {
      albumId
    });
    const {
      data: album
    } = await this.playlistsApi.getPlaylistAccessInfo({
      userId: params.userId,
      playlistId: params.albumId // use hashed albumId
    });
    // Validate purchase attempt
    if (!album) {
      throw new Error('Album not found.');
    }
    if (!album.isStreamGated) {
      throw new Error('Attempted to purchase free album.');
    }
    if (album.userId === params.userId) {
      throw new Error('Attempted to purchase own album.');
    }
    let numberSplits = [];
    let centPrice;
    const accessType = 'stream';
    // Get conditions
    if (album.streamConditions && instanceOfExtendedPurchaseGate(album.streamConditions)) {
      centPrice = album.streamConditions.usdcPurchase.price;
      numberSplits = album.streamConditions.usdcPurchase.splits;
    } else {
      this.logger.debug(album.streamConditions);
      throw new Error('Album is not available for purchase.');
    }
    // Check if already purchased
    if ((_album$access = album.access) !== null && _album$access !== void 0 && _album$access.stream) {
      throw new Error('Album already purchased');
    }
    // Check if price changed
    if (USDC(priceNumber).value < USDC(centPrice / 100).value) {
      throw new Error('Track price increased.');
    }
    const extraAmount = USDC(extraAmountNumber).value;
    const total = USDC(centPrice / 100.0).value + extraAmount;
    this.logger.debug('Purchase total:', total);
    const splits = await prepareSplits({
      splits: numberSplits,
      extraAmount,
      claimableTokensClient: this.claimableTokensClient,
      logger: this.logger
    });
    this.logger.debug('Calculated splits:', splits);
    const routeInstruction = await this.paymentRouterClient.createRouteInstruction({
      splits,
      total,
      mint
    });
    const memoInstruction = await this.paymentRouterClient.createPurchaseMemoInstruction({
      contentId: albumId,
      contentType,
      blockNumber: album.blocknumber,
      buyerUserId: userId,
      accessType
    });
    let locationMemoInstruction;
    try {
      locationMemoInstruction = await this.solanaRelay.getLocationInstruction();
    } catch (e) {
      this.logger.warn('Unable to compute location memo instruction');
    }
    return {
      instructions: {
        routeInstruction,
        memoInstruction,
        locationMemoInstruction
      },
      total
    };
  }
  /**
   * Purchases stream access to an album
   *
   * @hidden
   */
  async purchaseAlbum(params) {
    const {
      wallet
    } = await parseParams('purchaseAlbum', PurchaseAlbumSchema)(params);
    const {
      // only send the base params to getPurchaseInstructions
      wallet: ignoredWallet,
      walletAdapter: ignoredWalletAdapter,
      ...baseParams
    } = params;
    const {
      instructions: {
        routeInstruction,
        memoInstruction,
        locationMemoInstruction
      },
      total
    } = await this.getPurchaseAlbumInstructions(baseParams);
    let transaction;
    const mint = 'USDC';
    if (wallet) {
      this.logger.debug('Using provided wallet to purchase...', {
        wallet: wallet.toBase58()
      });
      // Use the specified Solana wallet
      const transferInstruction = await this.paymentRouterClient.createTransferInstruction({
        sourceWallet: wallet,
        total,
        mint
      });
      transaction = await this.solanaClient.buildTransaction({
        feePayer: wallet,
        instructions: [transferInstruction, routeInstruction, memoInstruction, locationMemoInstruction].filter(Boolean)
      });
    } else {
      // Use the authed wallet's userbank and relay
      this.logger.debug(`Using userBank ${await this.claimableTokensClient.deriveUserBank({
        mint: 'USDC'
      })} to purchase...`);
      const paymentRouterTokenAccount = await this.paymentRouterClient.getOrCreateProgramTokenAccount({
        mint
      });
      const transferSecpInstruction = await this.claimableTokensClient.createTransferSecpInstruction({
        destination: paymentRouterTokenAccount.address,
        mint,
        amount: total
      });
      const transferInstruction = await this.claimableTokensClient.createTransferInstruction({
        destination: paymentRouterTokenAccount.address,
        mint
      });
      transaction = await this.solanaClient.buildTransaction({
        feePayer: wallet,
        instructions: [transferSecpInstruction, transferInstruction, routeInstruction, memoInstruction, locationMemoInstruction].filter(Boolean)
      });
    }
    if (params.walletAdapter) {
      if (!params.walletAdapter.publicKey) {
        throw new Error('Param walletAdapter was specified, but no wallet selected');
      }
      return await params.walletAdapter.sendTransaction(transaction, this.solanaClient.connection);
    }
    return this.solanaClient.sendTransaction(transaction, {
      skipPreflight: true
    });
  }
}

class CryptoUtils {
  /**
   * Encrypts data using AES with the last 32 bytes of the secret
   * @param secret The secret key for encryption
   * @param payload The data to encrypt
   */
  static async encrypt(secret, payload) {
    return await aes.encrypt(secret.slice(secret.length - 32), payload);
  }
  /**
   * Encrypts a string using AES with the last 32 bytes of the secret
   * @param secret The secret key for encryption
   * @param payload The string to encrypt
   */
  static async encryptString(secret, payload) {
    return await CryptoUtils.encrypt(secret, new TextEncoder().encode(payload));
  }
  /**
   * Decrypts data using AES with the last 32 bytes of the secret
   * @param secret The secret key for decryption
   * @param payload The data to decrypt
   */
  static async decrypt(secret, payload) {
    return await aes.decrypt(secret.slice(secret.length - 32), payload);
  }
  /**
   * Decrypts data and converts it to a string using AES with the last 32 bytes of the secret
   * @param secret The secret key for decryption
   * @param payload The data to decrypt
   */
  static async decryptString(secret, payload) {
    return new TextDecoder().decode(await CryptoUtils.decrypt(secret, payload));
  }
}

// NOTE: No imports allowed - quicktype is not yet able to track imports!
/**
 * Defines who the user allows to message them
 */
var ChatPermission;
(function (ChatPermission) {
  ChatPermission["ALL"] = "all";
  ChatPermission["TIPPEES"] = "tippees";
  ChatPermission["TIPPERS"] = "tippers";
  ChatPermission["FOLLOWEES"] = "followees";
  ChatPermission["FOLLOWERS"] = "followers";
  ChatPermission["VERIFIED"] = "verified";
  ChatPermission["NONE"] = "none";
})(ChatPermission || (ChatPermission = {}));
var ChatBlastAudience;
(function (ChatBlastAudience) {
  ChatBlastAudience["FOLLOWERS"] = "follower_audience";
  ChatBlastAudience["TIPPERS"] = "tipper_audience";
  ChatBlastAudience["REMIXERS"] = "remixer_audience";
  ChatBlastAudience["CUSTOMERS"] = "customer_audience";
  ChatBlastAudience["COIN_HOLDERS"] = "coin_holder_audience";
})(ChatBlastAudience || (ChatBlastAudience = {}));

// REQUEST PARAMETERS
const ChatGetAllRequestSchema = z.object({
  userId: z.string(),
  limit: z.optional(z.number()),
  before: z.optional(z.string()),
  after: z.optional(z.string())
});
const ChatGetRequestSchema = z.object({
  currentUserId: z.optional(z.string()),
  chatId: z.string()
});
const ChatGetMessagesRequestSchema = z.object({
  currentUserId: z.optional(z.string()),
  chatId: z.string(),
  isBlast: z.optional(z.boolean()),
  limit: z.optional(z.number()),
  before: z.optional(z.string()),
  after: z.optional(z.string())
});
const ChatGetUnreadCountRequestSchema = z.optional(z.object({
  currentUserId: z.optional(z.string())
}));
const ChatGetBlockersRequestSchema = z.optional(z.object({
  currentUserId: z.optional(z.string())
}));
const ChatCreateRequestSchema = z.object({
  currentUserId: z.optional(z.string()),
  userId: z.string(),
  invitedUserIds: z.array(z.string()).min(1)
});
const ChatInviteRequestSchema = z.object({
  currentUserId: z.optional(z.string()),
  chatId: z.string(),
  userId: z.string(),
  invitedUserIds: z.array(z.string()).min(1)
});
const ChatMessageRequestSchema = z.object({
  currentUserId: z.optional(z.string()),
  chatId: z.string(),
  messageId: z.optional(z.string()),
  message: z.string()
});
const ChatBlastMessageRequestSchema = z.object({
  currentUserId: z.optional(z.string()),
  blastId: z.string(),
  message: z.string(),
  audience: z.nativeEnum(ChatBlastAudience),
  audienceContentId: z.optional(z.string()),
  audienceContentType: z.optional(z.enum(['track', 'album']))
});
const ChatReactRequestSchema = z.object({
  currentUserId: z.optional(z.string()),
  chatId: z.string(),
  messageId: z.string(),
  reaction: z.nullable(z.string())
});
const ChatReadRequestSchema = z.object({
  currentUserId: z.optional(z.string()),
  chatId: z.string()
});
const ChatBlockRequestSchema = z.object({
  currentUserId: z.optional(z.string()),
  userId: z.string()
});
const ChatDeleteRequestSchema = z.object({
  currentUserId: z.optional(z.string()),
  chatId: z.string()
});
const ChatPermitRequestSchema = z.object({
  currentUserId: z.optional(z.string()),
  permit: z.optional(z.nativeEnum(ChatPermission)),
  permitList: z.optional(z.array(z.nativeEnum(ChatPermission)).min(1)),
  allow: z.optional(z.boolean())
});
const ChatValidateCanCreateRequestSchema = z.object({
  currentUserId: z.optional(z.string()),
  userIds: z.array(z.string()).min(1)
});
const ChatGetPermissionRequestSchema = z.object({
  currentUserId: z.optional(z.string()),
  userIds: z.array(z.string()).min(1)
});
const ChatUnfurlRequestSchema = z.object({
  urls: z.array(z.string()).min(1)
});

const GENERIC_MESSAGE_ERROR = 'Error: this message cannot be displayed';
class ChatsApi extends BaseAPI$1 {
  constructor(config, audiusWalletClient, logger) {
    super(config);
    _defineProperty$1(this, "audiusWalletClient", void 0);
    _defineProperty$1(this, "logger", void 0);
    /**
     * A map of chatId => chatSecret so we don't have to repeatedly fetch it
     */
    _defineProperty$1(this, "chatSecrets", {});
    /**
     * A map of userId => publicKey promise to cache and deduplicate public key requests
     */
    _defineProperty$1(this, "publicKeyCache", {});
    /**
     * An event emitter that's used for consumers to listen for chat events
     */
    _defineProperty$1(this, "eventEmitter", void 0);
    /**
     * Proxy to the event emitter addListener
     */
    _defineProperty$1(this, "addEventListener", void 0);
    /**
     * Proxy to the event emitter removeListener
     */
    _defineProperty$1(this, "removeEventListener", void 0);
    this.audiusWalletClient = audiusWalletClient;
    this.logger = logger;
    this.eventEmitter = new require$$0();
    this.addEventListener = this.eventEmitter.addListener.bind(this.eventEmitter);
    this.removeEventListener = this.eventEmitter.removeListener.bind(this.eventEmitter);
    this.logger = logger.createPrefixedLogger('[chats-api]');
  }
  // #region QUERY
  /**
   * Establishes a websocket connection for listening to chat events.
   * @param params.currentUserId the user to listen for chat events for
   */
  async listen() {
    await this.createWebsocket(this.configuration.basePath);
  }
  /**
   * Gets a single chat
   * @param params.chatId the chat to get
   * @param params.currentUserId the user to act on behalf of
   * @returns the chat response
   */
  async get(params) {
    const {
      chatId,
      currentUserId
    } = await parseParams('get', ChatGetRequestSchema)(params);
    const response = await this.getRaw(chatId, currentUserId);
    return {
      ...response,
      data: response.data ? await this.decryptLastChatMessage(response.data) : response.data
    };
  }
  /**
   * Gets a list of chats
   * @param params.limit the max number of chats to get
   * @param params.before a timestamp cursor for pagination
   * @param params.after a timestamp cursor for pagination
   * @param params.userId the user to act on behalf of
   * @returns the chat list response
   */
  async getAll(params) {
    const {
      userId,
      limit,
      before,
      after
    } = await parseParams('getAll', ChatGetAllRequestSchema)(params);
    // Get new blasts and upgrade them to chats
    this.upgradeBlasts(userId);
    const path = `/comms/chats`;
    const query = {
      timestamp: new Date().getTime()
    };
    if (limit) {
      query.limit = limit;
    }
    if (before) {
      query.before = before;
    }
    if (after) {
      query.after = after;
    }
    if (userId) {
      query.current_user_id = userId;
    }
    const response = await this.signAndSendRequest({
      method: 'GET',
      headers: {},
      path,
      query
    });
    const json = await response.json();
    const decrypted = await Promise.all(json.data.map(async c => await this.decryptLastChatMessage(c)));
    return {
      ...json,
      data: decrypted
    };
  }
  /**
   * Gets a list of messages
   * @param params.chatId the chat to get messages for
   * @param params.before a timestamp cursor for pagination
   * @param params.after a timestamp cursor for pagination
   * @param params.currentUserId the user to act on behalf of
   * @returns the messages list response
   */
  async getMessages(params) {
    const {
      currentUserId,
      chatId,
      isBlast,
      limit,
      before,
      after
    } = await parseParams('getMessages', ChatGetMessagesRequestSchema)(params);
    let sharedSecret;
    if (!isBlast) {
      try {
        sharedSecret = await this.getChatSecret(chatId);
      } catch (e) {
        this.logger.error("[audius-sdk] Couldn't get chat secret", e);
        throw new Error("[audius-sdk] Couldn't get chat secret");
      }
    }
    const path = `/comms/chats/${chatId}/messages`;
    const query = {
      timestamp: new Date().getTime()
    };
    if (isBlast) {
      query.is_blast = isBlast;
    }
    if (limit) {
      query.limit = limit;
    }
    if (before) {
      query.before = before;
    }
    if (after) {
      query.after = after;
    }
    if (currentUserId) {
      query.current_user_id = currentUserId;
    }
    const response = await this.signAndSendRequest({
      method: 'GET',
      headers: {},
      path,
      query
    });
    const json = await response.json();
    const decrypted = await Promise.all(json.data.map(async m => ({
      ...m,
      message: m.is_plaintext ? m.message : await CryptoUtils.decryptString(sharedSecret, base64.decode(m.message)).catch(e => {
        this.logger.error("[audius-sdk]: Error: Couldn't decrypt chat message", m, e);
        return GENERIC_MESSAGE_ERROR;
      })
    })));
    return {
      ...json,
      data: decrypted
    };
  }
  /**
   * Gets a list of chat blasts for which chats haven't been created yet
   * @returns the blast messages list response
   */
  async getBlasts() {
    const query = {
      timestamp: new Date().getTime()
    };
    const res = await this.signAndSendRequest({
      method: 'GET',
      path: `/comms/blasts`,
      headers: {},
      query
    });
    return await res.json();
  }
  /**
   * Gets the total unread message count for a user
   * @param params.currentUserId the user to act on behalf of
   * @returns the unread count response
   */
  async getUnreadCount(params) {
    const parsedArgs = await parseParams('getUnreadCount', ChatGetUnreadCountRequestSchema)(params);
    const query = {
      timestamp: new Date().getTime()
    };
    if (parsedArgs !== null && parsedArgs !== void 0 && parsedArgs.currentUserId) {
      query.current_user_id = parsedArgs.currentUserId;
    }
    const res = await this.signAndSendRequest({
      method: 'GET',
      path: `/comms/chats/unread`,
      headers: {},
      query
    });
    return await res.json();
  }
  /**
   * Gets the permission settings of the given users
   * @param params.userIds the users to fetch permissions of
   * @param params.currentUserId the user to act on behalf of
   * @returns the permissions response
   */
  async getPermissions(params) {
    const query = {
      timestamp: new Date().getTime()
    };
    const {
      userIds,
      currentUserId
    } = await parseParams('getPermissions', ChatGetPermissionRequestSchema)(params);
    query.id = userIds;
    if (currentUserId) {
      query.current_user_id = currentUserId;
    }
    const res = await this.signAndSendRequest({
      method: 'GET',
      path: '/comms/chats/permissions',
      headers: {},
      query
    });
    return await res.json();
  }
  /**
   * Gets the user ids that have blocked the current user
   * @param params.currentUserId the user to act on behalf of
   * @returns the blockers response
   */
  async getBlockers(params) {
    const parsedArgs = await parseParams('getBlockers', ChatGetBlockersRequestSchema)(params);
    const query = {
      timestamp: new Date().getTime()
    };
    if (parsedArgs !== null && parsedArgs !== void 0 && parsedArgs.currentUserId) {
      query.current_user_id = parsedArgs.currentUserId;
    }
    const response = await this.signAndSendRequest({
      method: 'GET',
      path: `/comms/chats/blockers`,
      headers: {},
      query
    });
    return await response.json();
  }
  /**
   * Gets the user ids the current user has blocked
   * @param params.currentUserId the user to act on behalf of
   * @returns
   */
  async getBlockees(params) {
    const parsedArgs = await parseParams('getBlockees', ChatGetBlockersRequestSchema)(params);
    const query = {
      timestamp: new Date().getTime()
    };
    if (parsedArgs !== null && parsedArgs !== void 0 && parsedArgs.currentUserId) {
      query.current_user_id = parsedArgs.currentUserId;
    }
    const response = await this.signAndSendRequest({
      method: 'GET',
      path: `/comms/chats/blockees`,
      headers: {},
      query
    });
    return await response.json();
  }
  /**
   * Gets URL metadata useful for link previews
   * @param params.content the urls to get metadata for
   * @returns the unfurl response
   */
  async unfurl(params) {
    const {
      urls
    } = await parseParams('unfurl', ChatUnfurlRequestSchema)(params);
    const query = {
      content: urls
    };
    const res = await this.request({
      method: 'GET',
      path: '/comms/unfurl',
      query,
      headers: {}
    });
    return await res.json();
  }
  // #endregion
  // #region MUTATE
  /**
   * Creates a chat between users
   * @param params.userId the user id who is creating the chat
   * @param params.invitedUserIds the user ids to add to the chat
   * @param params.currentUserId the user to act on behalf of
   * @returns the rpc object
   */
  async create(params) {
    const {
      currentUserId,
      userId,
      invitedUserIds
    } = await parseParams('create', ChatCreateRequestSchema)(params);
    const chatId = [userId, ...invitedUserIds].sort().join(':');
    const chatSecret = secp256k1$1.utils.randomPrivateKey();
    const invites = await this.createInvites(userId, invitedUserIds, chatSecret);
    return await this.sendRpc({
      current_user_id: currentUserId,
      method: 'chat.create',
      params: {
        chat_id: chatId,
        invites
      }
    });
  }
  /**
   * Invites other users to an existing chat
   * @param params.chatId the chat id of the chat to invite to
   * @param params.userId the user id who is creating the chat
   * @param params.invitedUserIds the user ids to add to the chat
   * @param params.currentUserId the user to act on behalf of
   * @returns the rpc object
   */
  async invite(params) {
    const {
      currentUserId,
      chatId,
      userId,
      invitedUserIds
    } = await parseParams('invite', ChatInviteRequestSchema)(params);
    const chatSecret = await this.getChatSecret(chatId);
    const invites = await this.createInvites(userId, invitedUserIds, chatSecret);
    return await this.sendRpc({
      current_user_id: currentUserId,
      method: 'chat.invite',
      params: {
        chat_id: chatId,
        invites
      }
    });
  }
  /**
   * Sends a message to a user in a chat
   * @param params.message the message
   * @param params.chatId the chat to send a message in
   * @param params.messageId the id of the message
   * @param params.currentUserId the user to act on behalf of
   * @returns the rpc object
   */
  async message(params) {
    const {
      currentUserId,
      chatId,
      message,
      messageId
    } = await parseParams('message', ChatMessageRequestSchema)(params);
    const chatSecret = await this.getChatSecret(chatId);
    const encrypted = await CryptoUtils.encryptString(chatSecret, message);
    const encodedMessage = base64.encode(encrypted);
    return await this.sendRpc({
      current_user_id: currentUserId,
      method: 'chat.message',
      params: {
        chat_id: chatId,
        message_id: messageId !== null && messageId !== void 0 ? messageId : ulid(),
        message: encodedMessage
      }
    });
  }
  /**
   * Sends a blast message to a set of users
   * @param params.message the message
   * @param params.blastId the id of the message
   * @param params.audience the audience to send the message to
   * @param params.audienceTrackId for targeting remixers/purchasers of a specific track
   * @param params.currentUserId the user to act on behalf of
   * @returns the rpc object
   */
  async messageBlast(params) {
    const {
      currentUserId,
      blastId,
      message,
      audience,
      audienceContentId,
      audienceContentType: audienceContentTypeParam
    } = await parseParams('messageBlast', ChatBlastMessageRequestSchema)(params);
    let audienceContentType = audienceContentTypeParam;
    if (audience === ChatBlastAudience.REMIXERS && !!audienceContentId) {
      audienceContentType = 'track';
    }
    return await this.sendRpc({
      current_user_id: currentUserId,
      method: 'chat.blast',
      params: {
        blast_id: blastId !== null && blastId !== void 0 ? blastId : ulid(),
        audience,
        audience_content_id: audienceContentId,
        audience_content_type: audienceContentType,
        message
      }
    });
  }
  /**
   * Reacts to a message
   * @param params.reaction the reaction
   * @param params.chatId the chat to send a reaction in
   * @param params.messageId the id of the message to react to
   * @param params.currentUserId the user to act on behalf of
   * @returns the rpc object
   */
  async react(params) {
    const {
      currentUserId,
      chatId,
      messageId,
      reaction
    } = await parseParams('react', ChatReactRequestSchema)(params);
    return await this.sendRpc({
      current_user_id: currentUserId,
      method: 'chat.react',
      params: {
        chat_id: chatId,
        message_id: messageId,
        reaction
      }
    });
  }
  /**
   * Marks a chat as read
   * @param params.chatId the chat to mark as read
   * @param params.currentUserId the user to act on behalf of
   * @returns the rpc object
   */
  async read(params) {
    const {
      currentUserId,
      chatId
    } = await parseParams('read', ChatReadRequestSchema)(params);
    return await this.sendRpc({
      current_user_id: currentUserId,
      method: 'chat.read',
      params: {
        chat_id: chatId
      }
    });
  }
  /**
   * Blocks a user from sending messages to the current user
   * @param params.userId the user to block
   * @param params.currentUserId the user to act on behalf of
   * @returns the rpc object
   */
  async block(params) {
    const {
      currentUserId,
      userId
    } = await parseParams('block', ChatBlockRequestSchema)(params);
    return await this.sendRpc({
      current_user_id: currentUserId,
      method: 'chat.block',
      params: {
        user_id: userId
      }
    });
  }
  /**
   * Unblocks a user from sending messages to the current user
   * @param params.userId the user to unblock
   * @param params.currentUserId the user to act on behalf of
   * @returns the rpc object
   */
  async unblock(params) {
    const {
      currentUserId,
      userId
    } = await parseParams('unblock', ChatBlockRequestSchema)(params);
    return await this.sendRpc({
      current_user_id: currentUserId,
      method: 'chat.unblock',
      params: {
        user_id: userId
      }
    });
  }
  /**
   * Clears a chat's history for the current user
   * @param params.chatId the chat to clear
   * @param params.currentUserId the user to act on behalf of
   * @returns the rpc object
   */
  async delete(params) {
    const {
      currentUserId,
      chatId
    } = await parseParams('delete', ChatDeleteRequestSchema)(params);
    return await this.sendRpc({
      current_user_id: currentUserId,
      method: 'chat.delete',
      params: {
        chat_id: chatId
      }
    });
  }
  /**
   * Sets the inbox settings permissions of the current user
   * @param params.permit the permission to set
   * @param params.currentUserId the user to act on behalf of
   * @returns the rpc object
   */
  async permit(params) {
    const {
      currentUserId,
      permit,
      permitList,
      allow
    } = await parseParams('permit', ChatPermitRequestSchema)(params);
    return await this.sendRpc({
      current_user_id: currentUserId,
      method: 'chat.permit',
      params: {
        permit: permit !== null && permit !== void 0 ? permit : ChatPermission.ALL,
        permit_list: permitList !== null && permitList !== void 0 ? permitList : [ChatPermission.ALL],
        allow
      }
    });
  }
  // #endregion
  // #region PRIVATE
  async createInvites(userId, invitedUserIds, chatSecret) {
    const allUserIds = [userId, ...invitedUserIds];
    // Fetch all public keys in parallel to avoid sequential network requests
    const publicKeyPromises = allUserIds.map(id => this.getPublicKey(id));
    const publicKeys = await Promise.all(publicKeyPromises);
    const userPublicKey = publicKeys[0];
    if (!userPublicKey) {
      throw new Error(`Failed to fetch public key for user ${userId}`);
    }
    return await Promise.all(allUserIds.map(async (userId, index) => {
      const inviteePublicKey = publicKeys[index];
      if (!inviteePublicKey) {
        throw new Error(`Failed to fetch public key for user ${userId}`);
      }
      const inviteCode = await this.createInviteCode(userPublicKey, inviteePublicKey, chatSecret);
      return {
        user_id: userId,
        invite_code: base64.encode(inviteCode)
      };
    }));
  }
  async createInviteCode(userPublicKey, inviteePublicKey, chatSecret) {
    const sharedSecret = await this.audiusWalletClient.getSharedSecret({
      publicKey: inviteePublicKey
    });
    const encryptedChatSecret = await CryptoUtils.encrypt(sharedSecret, chatSecret);
    const inviteCode = new Uint8Array(65 + encryptedChatSecret.length);
    inviteCode.set(userPublicKey);
    inviteCode.set(encryptedChatSecret, 65);
    return inviteCode;
  }
  async readInviteCode(inviteCode) {
    const friendPublicKey = inviteCode.slice(0, 65);
    const chatSecretEncrypted = inviteCode.slice(65);
    const sharedSecret = await this.audiusWalletClient.getSharedSecret({
      publicKey: friendPublicKey
    });
    return await CryptoUtils.decrypt(sharedSecret, chatSecretEncrypted);
  }
  async decryptLastChatMessage(c) {
    if (c.last_message_is_plaintext) return c;
    let lastMessage = '';
    try {
      const sharedSecret = await this.getChatSecret(c.chat_id);
      if (c.last_message && c.last_message.length > 0) {
        lastMessage = await CryptoUtils.decryptString(sharedSecret, base64.decode(c.last_message));
      }
    } catch (e) {
      this.logger.error("[audius-sdk]: Error: Couldn't decrypt last chat message", c, e);
      lastMessage = GENERIC_MESSAGE_ERROR;
    }
    return {
      ...c,
      last_message: lastMessage
    };
  }
  async getRaw(chatId, currentUserId) {
    const path = `/comms/chats/${chatId}`;
    const queryParameters = {
      timestamp: new Date().getTime()
    };
    if (currentUserId) {
      queryParameters.current_user_id = currentUserId;
    }
    const response = await this.signAndSendRequest({
      method: 'GET',
      headers: {},
      path,
      query: queryParameters
    });
    return await response.json();
  }
  async getChatSecret(chatId) {
    const existingChatSecret = this.chatSecrets[chatId];
    if (!existingChatSecret) {
      const response = await this.getRaw(chatId);
      const chatSecret = await this.readInviteCode(base64.decode(response.data.invite_code));
      this.chatSecrets[chatId] = chatSecret;
      return chatSecret;
    }
    return existingChatSecret;
  }
  async getPublicKey(userId) {
    if (!this.publicKeyCache[userId]) {
      this.publicKeyCache[userId] = this.fetchPublicKey(userId);
    }
    const cachedPromise = this.publicKeyCache[userId];
    if (!cachedPromise) {
      throw new Error(`Public key cache is unexpectedly empty for user ${userId}`);
    }
    return await cachedPromise;
  }
  async fetchPublicKey(userId) {
    const response = await this.request({
      path: `/comms/pubkey/${userId}`,
      method: 'GET',
      headers: {}
    });
    const json = await response.json();
    return base64.decode(json.data);
  }
  async upgradeBlasts(userId) {
    const blasts = await this.getBlasts();
    const uniqueBlasts = uniqBy(blasts.data, 'pending_chat_id');
    await Promise.all(uniqueBlasts.map(async blast => {
      const encodedSenderId = encodeHashId(blast.from_user_id);
      if (encodedSenderId) {
        await this.create({
          userId,
          invitedUserIds: [encodedSenderId]
        });
      }
    }));
    for (const blast of blasts.data) {
      const encodedSenderId = encodeHashId(blast.from_user_id);
      if (encodedSenderId) {
        this.eventEmitter.emit('message', {
          chatId: blast.pending_chat_id,
          message: {
            // the order of blast_id + pending_chat_id needs to match Misc.BlastMessageID in comms
            message_id: blast.blast_id + blast.pending_chat_id,
            message: blast.plaintext,
            sender_user_id: encodedSenderId,
            created_at: blast.created_at,
            reactions: [],
            is_plaintext: true,
            audience: blast.audience
          }
        });
      }
    }
  }
  async getSignatureHeader(payload) {
    const [signature, recid] = await this.audiusWalletClient.sign({
      message: payload
    });
    const signatureBytes = new Uint8Array(65);
    signatureBytes.set(signature, 0);
    signatureBytes[64] = recid;
    return {
      'x-sig': base64.encode(signatureBytes)
    };
  }
  async signAndSendRequest(request) {
    const payload = request.method === 'GET' ? request.query ? `${request.path}?${this.configuration.queryParamsStringify(request.query)}` : request.path : request.body;
    return await this.request({
      ...request,
      headers: {
        ...request.headers,
        ...(await this.getSignatureHeader(payload))
      }
    });
  }
  async sendRpc(args) {
    const payload = JSON.stringify({
      ...args,
      timestamp: new Date().getTime()
    });
    await this.signAndSendRequest({
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      path: `/comms/mutate`,
      body: payload
    });
    return args;
  }
  async createWebsocket(endpoint) {
    const timestamp = new Date().getTime();
    const originalUrl = `/comms/chats/ws?timestamp=${timestamp}`;
    const signatureHeader = await this.getSignatureHeader(originalUrl);
    const host = endpoint.replace(/http(s?)/g, 'ws$1');
    const url = `${host}${originalUrl}&signature=${encodeURIComponent(signatureHeader['x-sig'])}`;
    const ws = new WebSocket(url);
    ws.addEventListener('message', messageEvent => {
      const handleAsync = async () => {
        const data = JSON.parse(messageEvent.data);
        if (data.rpc.method === 'chat.message') {
          const sharedSecret = await this.getChatSecret(data.rpc.params.chat_id);
          this.eventEmitter.emit('message', {
            chatId: data.rpc.params.chat_id,
            message: {
              message_id: data.rpc.params.message_id,
              message: data.rpc.params.is_plaintext ? data.rpc.params.message : await CryptoUtils.decryptString(sharedSecret, base64.decode(data.rpc.params.message)).catch(e => {
                this.logger.error("[audius-sdk]: Error: Couldn't decrypt websocket chat message", data, e);
                return GENERIC_MESSAGE_ERROR;
              }),
              sender_user_id: data.metadata.senderUserId,
              created_at: data.metadata.timestamp,
              reactions: [],
              is_plaintext: !!data.rpc.params.is_plaintext,
              audience: data.rpc.params.audience
            }
          });
        } else if (data.rpc.method === 'chat.react') {
          this.eventEmitter.emit('reaction', {
            chatId: data.rpc.params.chat_id,
            messageId: data.rpc.params.message_id,
            reaction: {
              reaction: data.rpc.params.reaction,
              user_id: data.metadata.senderUserId,
              created_at: data.metadata.timestamp
            }
          });
        } else if (data.rpc.method === 'chat.blast') {
          const userId = data.metadata.receiverUserId;
          await this.upgradeBlasts(userId);
          this.eventEmitter.emit('blast', {
            audience: data.rpc.params.audience,
            audienceContentType: data.rpc.params.audience_content_type,
            audienceContentId: data.rpc.params.audience_content_id,
            message: {
              message_id: data.rpc.params.blast_id,
              message: data.rpc.params.message,
              sender_user_id: data.metadata.senderUserId,
              created_at: data.metadata.timestamp,
              reactions: [],
              is_plaintext: true,
              audience: data.rpc.params.audience
            }
          });
        }
      };
      handleAsync();
    });
    ws.addEventListener('open', () => {
      this.eventEmitter.emit('open');
    });
    ws.addEventListener('close', () => {
      this.eventEmitter.emit('close');
    });
    ws.addEventListener('error', e => {
      this.eventEmitter.emit('error', e);
    });
    return ws;
  }
}

class CommentsApi$1 extends CommentsApi$2 {
  constructor(configuration, entityManager, logger) {
    super(configuration);
    _defineProperty$1(this, "entityManager", void 0);
    _defineProperty$1(this, "logger", void 0);
    this.entityManager = entityManager;
    this.logger = logger;
  }
  async generateCommentId() {
    const response = await this.getUnclaimedCommentID();
    const {
      data: unclaimedId
    } = response;
    if (!unclaimedId) {
      return Math.floor(Math.random() * 1000000);
    }
    return decodeHashId(unclaimedId);
  }
  async postComment(metadata) {
    const {
      userId,
      entityType = EntityType.TRACK,
      commentId
    } = metadata;
    const newCommentId = commentId !== null && commentId !== void 0 ? commentId : await this.generateCommentId();
    await this.entityManager.manageEntity({
      userId,
      entityType: EntityType.COMMENT,
      entityId: newCommentId,
      action: Action.CREATE,
      metadata: JSON.stringify({
        cid: '',
        data: snakecaseKeys({
          entityType,
          ...metadata
        })
      })
    });
    this.logger.info('Successfully posted a comment');
    return encodeHashId(newCommentId);
  }
  async editComment(metadata) {
    const {
      userId,
      entityId,
      trackId
    } = metadata;
    const response = await this.entityManager.manageEntity({
      userId,
      entityType: EntityType.COMMENT,
      entityId,
      action: Action.UPDATE,
      metadata: JSON.stringify({
        cid: '',
        data: snakecaseKeys({
          ...metadata,
          entityId: trackId
        })
      })
    });
    return response;
  }
  async deleteComment(metadata) {
    const {
      userId,
      entityId
    } = metadata;
    const response = await this.entityManager.manageEntity({
      userId,
      entityType: EntityType.COMMENT,
      entityId,
      action: Action.DELETE,
      metadata: ''
    });
    return response;
  }
  async reactComment(metadata) {
    const {
      userId,
      commentId,
      isLiked,
      trackId
    } = metadata;
    const response = await this.entityManager.manageEntity({
      userId,
      entityType: EntityType.COMMENT,
      entityId: commentId,
      action: isLiked ? Action.REACT : Action.UNREACT,
      metadata: JSON.stringify({
        cid: '',
        data: snakecaseKeys({
          entityId: trackId,
          entityType: EntityType.TRACK
        })
      })
    });
    return response;
  }
  async pinComment(metadata) {
    const {
      userId,
      entityId,
      trackId,
      isPin
    } = metadata;
    const response = await this.entityManager.manageEntity({
      userId,
      entityType: EntityType.COMMENT,
      entityId,
      action: isPin ? Action.PIN : Action.UNPIN,
      metadata: JSON.stringify({
        cid: '',
        data: snakecaseKeys({
          entityId: trackId
        })
      })
    });
    return response;
  }
  async reportComment(userId, entityId) {
    const response = await this.entityManager.manageEntity({
      userId,
      entityType: EntityType.COMMENT,
      entityId,
      action: Action.REPORT,
      metadata: ''
    });
    return response;
  }
  async muteUser(userId, mutedUserId, isMuted) {
    const response = await this.entityManager.manageEntity({
      userId,
      entityType: EntityType.USER,
      entityId: mutedUserId,
      action: isMuted ? Action.UNMUTE : Action.MUTE,
      metadata: ''
    });
    return response;
  }
  async updateCommentNotificationSetting(config) {
    const response = await this.entityManager.manageEntity({
      ...config,
      metadata: ''
    });
    return response;
  }
}

const EthAddressSchema = z.custom(val => {
  return z.string().startsWith('0x', 'Hex string must start with 0x').regex(/^0x[0-9a-fA-F]+$/, 'Hex must only include hexadecimal characters 0-9, a-F').length(42, 'Ethereum address must be 42 characters (including 0x').parse(val);
});

const CreateDashboardWalletUser = z.object({
  wallet: EthAddressSchema,
  userId: HashId,
  walletSignature: z.object({
    /** Message should be of the form: "Connecting Audius user id a93jl at 39823489" OR "Connecting Audius user @jill1990 at 39823489" */
    message: z.string(),
    signature: z.string()
  }).optional(),
  userSignature: z.object({
    /** Message should be of the form: "Connecting Audius protocol dashboard wallet 0x6c9CA7D9580d4e8286B0628c0300A2A1235a8e2E at 39823489" */
    message: z.string(),
    signature: z.string()
  }).optional()
}).refine(data => !!data.userSignature || !!data.walletSignature, "Either `userSignature` or `walletSignature` is required. Use `userSignature` if SDK is authenticated with the wallet's sign methods, and use `walletSignature` if SDK is authenticated with the user's sign methods.");
const DeleteDashboardWalletUserSchema = z.object({
  userId: HashId,
  wallet: EthAddressSchema
});

class DashboardWalletUsersApi extends DashboardWalletUsersApi$1 {
  constructor(config, entityManager) {
    super(config);
    _defineProperty$1(this, "entityManager", void 0);
    this.entityManager = entityManager;
  }
  /**
   * Connect an Audius user to a wallet on the protocol dashboard
   */
  async connectUserToDashboardWallet(params, advancedOptions) {
    const {
      wallet,
      userId,
      walletSignature,
      userSignature
    } = await parseParams('createDashboardWalletUser', CreateDashboardWalletUser)(params);
    const signatureMetadata = walletSignature ? {
      wallet_signature: {
        message: walletSignature.message,
        signature: walletSignature.signature
      }
    } : {
      user_signature: {
        message: userSignature.message,
        signature: userSignature.signature
      }
    };
    const response = await this.entityManager.manageEntity({
      userId,
      entityType: EntityType.DASHBOARD_WALLET_USER,
      entityId: 0,
      action: Action.CREATE,
      metadata: JSON.stringify({
        wallet,
        ...signatureMetadata
      }),
      ...advancedOptions
    });
    return {
      ...response
    };
  }
  /**
   * Disconnect an Audius user from a wallet on the protocol dashboard
   */
  async disconnectUserFromDashboardWallet(params) {
    const {
      userId,
      wallet
    } = await parseParams('deleteDashboardWalletUser', DeleteDashboardWalletUserSchema)(params);
    return await this.entityManager.manageEntity({
      userId,
      entityType: EntityType.DASHBOARD_WALLET_USER,
      entityId: 0,
      action: Action.DELETE,
      metadata: JSON.stringify({
        wallet
      })
    });
  }
}

// HMAC (RFC 2104)
class HMAC extends Hash$3 {
  constructor(hash, _key) {
    super();
    this.finished = false;
    this.destroyed = false;
    hash$1(hash);
    const key = toBytes$1(_key);
    this.iHash = hash.create();
    if (typeof this.iHash.update !== 'function') throw new Error('Expected instance of class which extends utils.Hash');
    this.blockLen = this.iHash.blockLen;
    this.outputLen = this.iHash.outputLen;
    const blockLen = this.blockLen;
    const pad = new Uint8Array(blockLen);
    // blockLen can be bigger than outputLen
    pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);
    for (let i = 0; i < pad.length; i++) pad[i] ^= 0x36;
    this.iHash.update(pad);
    // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone
    this.oHash = hash.create();
    // Undo internal XOR && apply outer XOR
    for (let i = 0; i < pad.length; i++) pad[i] ^= 0x36 ^ 0x5c;
    this.oHash.update(pad);
    pad.fill(0);
  }
  update(buf) {
    exists$3(this);
    this.iHash.update(buf);
    return this;
  }
  digestInto(out) {
    exists$3(this);
    bytes$1(out, this.outputLen);
    this.finished = true;
    this.iHash.digestInto(out);
    this.oHash.update(out);
    this.oHash.digestInto(out);
    this.destroy();
  }
  digest() {
    const out = new Uint8Array(this.oHash.outputLen);
    this.digestInto(out);
    return out;
  }
  _cloneInto(to) {
    // Create new instance without calling constructor since key already in state and we don't know it.
    to || (to = Object.create(Object.getPrototypeOf(this), {}));
    const {
      oHash,
      iHash,
      finished,
      destroyed,
      blockLen,
      outputLen
    } = this;
    to = to;
    to.finished = finished;
    to.destroyed = destroyed;
    to.blockLen = blockLen;
    to.outputLen = outputLen;
    to.oHash = oHash._cloneInto(to.oHash);
    to.iHash = iHash._cloneInto(to.iHash);
    return to;
  }
  destroy() {
    this.destroyed = true;
    this.oHash.destroy();
    this.iHash.destroy();
  }
}
/**
 * HMAC: RFC2104 message authentication code.
 * @param hash - function that would be used e.g. sha256
 * @param key - message key
 * @param message - message data
 * @example
 * import { hmac } from '@noble/hashes/hmac';
 * import { sha256 } from '@noble/hashes/sha2';
 * const mac1 = hmac(sha256, 'key', 'message');
 */
const hmac = (hash, key, message) => new HMAC(hash, key).update(message).digest();
hmac.create = (hash, key) => new HMAC(hash, key);

/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
// 100 lines of code in the file are duplicated from noble-hashes (utils).
// This is OK: `abstract` directory does not use noble-hashes.
// User may opt-in into using different hashing library. This way, noble-hashes
// won't be included into their bundle.
const _0n$4 = /* @__PURE__ */BigInt(0);
const _1n$5 = /* @__PURE__ */BigInt(1);
const _2n$3 = /* @__PURE__ */BigInt(2);
function isBytes(a) {
  return a instanceof Uint8Array || a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array';
}
function abytes(item) {
  if (!isBytes(item)) throw new Error('Uint8Array expected');
}
function abool(title, value) {
  if (typeof value !== 'boolean') throw new Error(`${title} must be valid boolean, got "${value}".`);
}
// Array where index 0xf0 (240) is mapped to string 'f0'
const hexes = /* @__PURE__ */Array.from({
  length: 256
}, (_, i) => i.toString(16).padStart(2, '0'));
/**
 * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'
 */
function bytesToHex(bytes) {
  abytes(bytes);
  // pre-caching improves the speed 6x
  let hex = '';
  for (let i = 0; i < bytes.length; i++) {
    hex += hexes[bytes[i]];
  }
  return hex;
}
function numberToHexUnpadded(num) {
  const hex = num.toString(16);
  return hex.length & 1 ? `0${hex}` : hex;
}
function hexToNumber(hex) {
  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);
  // Big Endian
  return BigInt(hex === '' ? '0' : `0x${hex}`);
}
// We use optimized technique to convert hex string to byte array
const asciis = {
  _0: 48,
  _9: 57,
  _A: 65,
  _F: 70,
  _a: 97,
  _f: 102
};
function asciiToBase16(char) {
  if (char >= asciis._0 && char <= asciis._9) return char - asciis._0;
  if (char >= asciis._A && char <= asciis._F) return char - (asciis._A - 10);
  if (char >= asciis._a && char <= asciis._f) return char - (asciis._a - 10);
  return;
}
/**
 * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])
 */
function hexToBytes(hex) {
  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);
  const hl = hex.length;
  const al = hl / 2;
  if (hl % 2) throw new Error('padded hex string expected, got unpadded hex of length ' + hl);
  const array = new Uint8Array(al);
  for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
    const n1 = asciiToBase16(hex.charCodeAt(hi));
    const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
    if (n1 === undefined || n2 === undefined) {
      const char = hex[hi] + hex[hi + 1];
      throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
    }
    array[ai] = n1 * 16 + n2;
  }
  return array;
}
// BE: Big Endian, LE: Little Endian
function bytesToNumberBE(bytes) {
  return hexToNumber(bytesToHex(bytes));
}
function bytesToNumberLE(bytes) {
  abytes(bytes);
  return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));
}
function numberToBytesBE(n, len) {
  return hexToBytes(n.toString(16).padStart(len * 2, '0'));
}
function numberToBytesLE(n, len) {
  return numberToBytesBE(n, len).reverse();
}
// Unpadded, rarely used
function numberToVarBytesBE(n) {
  return hexToBytes(numberToHexUnpadded(n));
}
/**
 * Takes hex string or Uint8Array, converts to Uint8Array.
 * Validates output length.
 * Will throw error for other types.
 * @param title descriptive title for an error e.g. 'private key'
 * @param hex hex string or Uint8Array
 * @param expectedLength optional, will compare to result array's length
 * @returns
 */
function ensureBytes(title, hex, expectedLength) {
  let res;
  if (typeof hex === 'string') {
    try {
      res = hexToBytes(hex);
    } catch (e) {
      throw new Error(`${title} must be valid hex string, got "${hex}". Cause: ${e}`);
    }
  } else if (isBytes(hex)) {
    // Uint8Array.from() instead of hash.slice() because node.js Buffer
    // is instance of Uint8Array, and its slice() creates **mutable** copy
    res = Uint8Array.from(hex);
  } else {
    throw new Error(`${title} must be hex string or Uint8Array`);
  }
  const len = res.length;
  if (typeof expectedLength === 'number' && len !== expectedLength) throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);
  return res;
}
/**
 * Copies several Uint8Arrays into one.
 */
function concatBytes() {
  let sum = 0;
  for (let i = 0; i < arguments.length; i++) {
    const a = i < 0 || arguments.length <= i ? undefined : arguments[i];
    abytes(a);
    sum += a.length;
  }
  const res = new Uint8Array(sum);
  for (let i = 0, pad = 0; i < arguments.length; i++) {
    const a = i < 0 || arguments.length <= i ? undefined : arguments[i];
    res.set(a, pad);
    pad += a.length;
  }
  return res;
}
// Compares 2 u8a-s in kinda constant time
function equalBytes(a, b) {
  if (a.length !== b.length) return false;
  let diff = 0;
  for (let i = 0; i < a.length; i++) diff |= a[i] ^ b[i];
  return diff === 0;
}
/**
 * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])
 */
function utf8ToBytes$1(str) {
  if (typeof str !== 'string') throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
  return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809
}
// Is positive bigint
const isPosBig = n => typeof n === 'bigint' && _0n$4 <= n;
function inRange(n, min, max) {
  return isPosBig(n) && isPosBig(min) && isPosBig(max) && min <= n && n < max;
}
/**
 * Asserts min <= n < max. NOTE: It's < max and not <= max.
 * @example
 * aInRange('x', x, 1n, 256n); // would assume x is in (1n..255n)
 */
function aInRange(title, n, min, max) {
  // Why min <= n < max and not a (min < n < max) OR b (min <= n <= max)?
  // consider P=256n, min=0n, max=P
  // - a for min=0 would require -1:          `inRange('x', x, -1n, P)`
  // - b would commonly require subtraction:  `inRange('x', x, 0n, P - 1n)`
  // - our way is the cleanest:               `inRange('x', x, 0n, P)
  if (!inRange(n, min, max)) throw new Error(`expected valid ${title}: ${min} <= n < ${max}, got ${typeof n} ${n}`);
}
// Bit operations
/**
 * Calculates amount of bits in a bigint.
 * Same as `n.toString(2).length`
 */
function bitLen(n) {
  let len;
  for (len = 0; n > _0n$4; n >>= _1n$5, len += 1);
  return len;
}
/**
 * Gets single bit at position.
 * NOTE: first bit position is 0 (same as arrays)
 * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`
 */
function bitGet(n, pos) {
  return n >> BigInt(pos) & _1n$5;
}
/**
 * Sets single bit at position.
 */
function bitSet(n, pos, value) {
  return n | (value ? _1n$5 : _0n$4) << BigInt(pos);
}
/**
 * Calculate mask for N bits. Not using ** operator with bigints because of old engines.
 * Same as BigInt(`0b${Array(i).fill('1').join('')}`)
 */
const bitMask = n => (_2n$3 << BigInt(n - 1)) - _1n$5;
// DRBG
const u8n = data => new Uint8Array(data); // creates Uint8Array
const u8fr = arr => Uint8Array.from(arr); // another shortcut
/**
 * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.
 * @returns function that will call DRBG until 2nd arg returns something meaningful
 * @example
 *   const drbg = createHmacDRBG<Key>(32, 32, hmac);
 *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined
 */
function createHmacDrbg(hashLen, qByteLen, hmacFn) {
  if (typeof hashLen !== 'number' || hashLen < 2) throw new Error('hashLen must be a number');
  if (typeof qByteLen !== 'number' || qByteLen < 2) throw new Error('qByteLen must be a number');
  if (typeof hmacFn !== 'function') throw new Error('hmacFn must be a function');
  // Step B, Step C: set hashLen to 8*ceil(hlen/8)
  let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.
  let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same
  let i = 0; // Iterations counter, will throw when over 1000
  const reset = () => {
    v.fill(1);
    k.fill(0);
    i = 0;
  };
  const h = function () {
    for (var _len = arguments.length, b = new Array(_len), _key = 0; _key < _len; _key++) {
      b[_key] = arguments[_key];
    }
    return hmacFn(k, v, ...b);
  }; // hmac(k)(v, ...values)
  const reseed = function () {
    let seed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : u8n();
    // HMAC-DRBG reseed() function. Steps D-G
    k = h(u8fr([0x00]), seed); // k = hmac(k || v || 0x00 || seed)
    v = h(); // v = hmac(k || v)
    if (seed.length === 0) return;
    k = h(u8fr([0x01]), seed); // k = hmac(k || v || 0x01 || seed)
    v = h(); // v = hmac(k || v)
  };
  const gen = () => {
    // HMAC-DRBG generate() function
    if (i++ >= 1000) throw new Error('drbg: tried 1000 values');
    let len = 0;
    const out = [];
    while (len < qByteLen) {
      v = h();
      const sl = v.slice();
      out.push(sl);
      len += v.length;
    }
    return concatBytes(...out);
  };
  const genUntil = (seed, pred) => {
    reset();
    reseed(seed); // Steps D-G
    let res = undefined; // Step H: grind until k is in [1..n-1]
    while (!(res = pred(gen()))) reseed();
    reset();
    return res;
  };
  return genUntil;
}
// Validating curves and fields
const validatorFns = {
  bigint: val => typeof val === 'bigint',
  function: val => typeof val === 'function',
  boolean: val => typeof val === 'boolean',
  string: val => typeof val === 'string',
  stringOrUint8Array: val => typeof val === 'string' || isBytes(val),
  isSafeInteger: val => Number.isSafeInteger(val),
  array: val => Array.isArray(val),
  field: (val, object) => object.Fp.isValid(val),
  hash: val => typeof val === 'function' && Number.isSafeInteger(val.outputLen)
};
// type Record<K extends string | number | symbol, T> = { [P in K]: T; }
function validateObject(object, validators) {
  let optValidators = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  const checkField = (fieldName, type, isOptional) => {
    const checkVal = validatorFns[type];
    if (typeof checkVal !== 'function') throw new Error(`Invalid validator "${type}", expected function`);
    const val = object[fieldName];
    if (isOptional && val === undefined) return;
    if (!checkVal(val, object)) {
      throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);
    }
  };
  for (const [fieldName, type] of Object.entries(validators)) checkField(fieldName, type, false);
  for (const [fieldName, type] of Object.entries(optValidators)) checkField(fieldName, type, true);
  return object;
}
// validate type tests
// const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };
// const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!
// // Should fail type-check
// const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });
// const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });
// const z3 = validateObject(o, { test: 'boolean', z: 'bug' });
// const z4 = validateObject(o, { a: 'boolean', z: 'bug' });
/**
 * throws not implemented error
 */
const notImplemented = () => {
  throw new Error('not implemented');
};
/**
 * Memoizes (caches) computation result.
 * Uses WeakMap: the value is going auto-cleaned by GC after last reference is removed.
 */
function memoized(fn) {
  const map = new WeakMap();
  return function (arg) {
    const val = map.get(arg);
    if (val !== undefined) return val;
    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      args[_key2 - 1] = arguments[_key2];
    }
    const computed = fn(arg, ...args);
    map.set(arg, computed);
    return computed;
  };
}

var ut = /*#__PURE__*/Object.freeze({
    __proto__: null,
    isBytes: isBytes,
    abytes: abytes,
    abool: abool,
    bytesToHex: bytesToHex,
    numberToHexUnpadded: numberToHexUnpadded,
    hexToNumber: hexToNumber,
    hexToBytes: hexToBytes,
    bytesToNumberBE: bytesToNumberBE,
    bytesToNumberLE: bytesToNumberLE,
    numberToBytesBE: numberToBytesBE,
    numberToBytesLE: numberToBytesLE,
    numberToVarBytesBE: numberToVarBytesBE,
    ensureBytes: ensureBytes,
    concatBytes: concatBytes,
    equalBytes: equalBytes,
    utf8ToBytes: utf8ToBytes$1,
    inRange: inRange,
    aInRange: aInRange,
    bitLen: bitLen,
    bitGet: bitGet,
    bitSet: bitSet,
    bitMask: bitMask,
    createHmacDrbg: createHmacDrbg,
    validateObject: validateObject,
    notImplemented: notImplemented,
    memoized: memoized
});

/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
// prettier-ignore
const _0n$3 = BigInt(0),
  _1n$4 = BigInt(1),
  _2n$2 = BigInt(2),
  _3n$1 = BigInt(3);
// prettier-ignore
const _4n = BigInt(4),
  _5n = BigInt(5),
  _8n = BigInt(8);
// prettier-ignore
BigInt(9);
  BigInt(16);
// Calculates a modulo b
function mod(a, b) {
  const result = a % b;
  return result >= _0n$3 ? result : b + result;
}
/**
 * Efficiently raise num to power and do modular division.
 * Unsafe in some contexts: uses ladder, so can expose bigint bits.
 * @example
 * pow(2n, 6n, 11n) // 64n % 11n == 9n
 */
// TODO: use field version && remove
function pow(num, power, modulo) {
  if (modulo <= _0n$3 || power < _0n$3) throw new Error('Expected power/modulo > 0');
  if (modulo === _1n$4) return _0n$3;
  let res = _1n$4;
  while (power > _0n$3) {
    if (power & _1n$4) res = res * num % modulo;
    num = num * num % modulo;
    power >>= _1n$4;
  }
  return res;
}
// Does x ^ (2 ^ power) mod p. pow2(30, 4) == 30 ^ (2 ^ 4)
function pow2(x, power, modulo) {
  let res = x;
  while (power-- > _0n$3) {
    res *= res;
    res %= modulo;
  }
  return res;
}
// Inverses number over modulo
function invert(number, modulo) {
  if (number === _0n$3 || modulo <= _0n$3) {
    throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);
  }
  // Euclidean GCD https://brilliant.org/wiki/extended-euclidean-algorithm/
  // Fermat's little theorem "CT-like" version inv(n) = n^(m-2) mod m is 30x slower.
  let a = mod(number, modulo);
  let b = modulo;
  // prettier-ignore
  let x = _0n$3,
    u = _1n$4;
  while (a !== _0n$3) {
    // JIT applies optimization if those two lines follow each other
    const q = b / a;
    const r = b % a;
    const m = x - u * q;
    // prettier-ignore
    b = a, a = r, x = u, u = m;
  }
  const gcd = b;
  if (gcd !== _1n$4) throw new Error('invert: does not exist');
  return mod(x, modulo);
}
/**
 * Tonelli-Shanks square root search algorithm.
 * 1. https://eprint.iacr.org/2012/685.pdf (page 12)
 * 2. Square Roots from 1; 24, 51, 10 to Dan Shanks
 * Will start an infinite loop if field order P is not prime.
 * @param P field order
 * @returns function that takes field Fp (created from P) and number n
 */
function tonelliShanks(P) {
  // Legendre constant: used to calculate Legendre symbol (a | p),
  // which denotes the value of a^((p-1)/2) (mod p).
  // (a | p)  1    if a is a square (mod p)
  // (a | p)  -1   if a is not a square (mod p)
  // (a | p)  0    if a  0 (mod p)
  const legendreC = (P - _1n$4) / _2n$2;
  let Q, S, Z;
  // Step 1: By factoring out powers of 2 from p - 1,
  // find q and s such that p - 1 = q*(2^s) with q odd
  for (Q = P - _1n$4, S = 0; Q % _2n$2 === _0n$3; Q /= _2n$2, S++);
  // Step 2: Select a non-square z such that (z | p)  -1 and set c  zq
  for (Z = _2n$2; Z < P && pow(Z, legendreC, P) !== P - _1n$4; Z++);
  // Fast-path
  if (S === 1) {
    const p1div4 = (P + _1n$4) / _4n;
    return function tonelliFast(Fp, n) {
      const root = Fp.pow(n, p1div4);
      if (!Fp.eql(Fp.sqr(root), n)) throw new Error('Cannot find square root');
      return root;
    };
  }
  // Slow-path
  const Q1div2 = (Q + _1n$4) / _2n$2;
  return function tonelliSlow(Fp, n) {
    // Step 0: Check that n is indeed a square: (n | p) should not be  -1
    if (Fp.pow(n, legendreC) === Fp.neg(Fp.ONE)) throw new Error('Cannot find square root');
    let r = S;
    // TODO: will fail at Fp2/etc
    let g = Fp.pow(Fp.mul(Fp.ONE, Z), Q); // will update both x and b
    let x = Fp.pow(n, Q1div2); // first guess at the square root
    let b = Fp.pow(n, Q); // first guess at the fudge factor
    while (!Fp.eql(b, Fp.ONE)) {
      if (Fp.eql(b, Fp.ZERO)) return Fp.ZERO; // https://en.wikipedia.org/wiki/Tonelli%E2%80%93Shanks_algorithm (4. If t = 0, return r = 0)
      // Find m such b^(2^m)==1
      let m = 1;
      for (let t2 = Fp.sqr(b); m < r; m++) {
        if (Fp.eql(t2, Fp.ONE)) break;
        t2 = Fp.sqr(t2); // t2 *= t2
      }
      // NOTE: r-m-1 can be bigger than 32, need to convert to bigint before shift, otherwise there will be overflow
      const ge = Fp.pow(g, _1n$4 << BigInt(r - m - 1)); // ge = 2^(r-m-1)
      g = Fp.sqr(ge); // g = ge * ge
      x = Fp.mul(x, ge); // x *= ge
      b = Fp.mul(b, g); // b *= g
      r = m;
    }
    return x;
  };
}
function FpSqrt(P) {
  // NOTE: different algorithms can give different roots, it is up to user to decide which one they want.
  // For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).
  // P  3 (mod 4)
  // n = n^((P+1)/4)
  if (P % _4n === _3n$1) {
    // Not all roots possible!
    // const ORDER =
    //   0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaabn;
    // const NUM = 72057594037927816n;
    const p1div4 = (P + _1n$4) / _4n;
    return function sqrt3mod4(Fp, n) {
      const root = Fp.pow(n, p1div4);
      // Throw if root**2 != n
      if (!Fp.eql(Fp.sqr(root), n)) throw new Error('Cannot find square root');
      return root;
    };
  }
  // Atkin algorithm for q  5 (mod 8), https://eprint.iacr.org/2012/685.pdf (page 10)
  if (P % _8n === _5n) {
    const c1 = (P - _5n) / _8n;
    return function sqrt5mod8(Fp, n) {
      const n2 = Fp.mul(n, _2n$2);
      const v = Fp.pow(n2, c1);
      const nv = Fp.mul(n, v);
      const i = Fp.mul(Fp.mul(nv, _2n$2), v);
      const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));
      if (!Fp.eql(Fp.sqr(root), n)) throw new Error('Cannot find square root');
      return root;
    };
  }
  // Other cases: Tonelli-Shanks algorithm
  return tonelliShanks(P);
}
// prettier-ignore
const FIELD_FIELDS = ['create', 'isValid', 'is0', 'neg', 'inv', 'sqrt', 'sqr', 'eql', 'add', 'sub', 'mul', 'pow', 'div', 'addN', 'subN', 'mulN', 'sqrN'];
function validateField(field) {
  const initial = {
    ORDER: 'bigint',
    MASK: 'bigint',
    BYTES: 'isSafeInteger',
    BITS: 'isSafeInteger'
  };
  const opts = FIELD_FIELDS.reduce((map, val) => {
    map[val] = 'function';
    return map;
  }, initial);
  return validateObject(field, opts);
}
// Generic field functions
/**
 * Same as `pow` but for Fp: non-constant-time.
 * Unsafe in some contexts: uses ladder, so can expose bigint bits.
 */
function FpPow(f, num, power) {
  // Should have same speed as pow for bigints
  // TODO: benchmark!
  if (power < _0n$3) throw new Error('Expected power > 0');
  if (power === _0n$3) return f.ONE;
  if (power === _1n$4) return num;
  let p = f.ONE;
  let d = num;
  while (power > _0n$3) {
    if (power & _1n$4) p = f.mul(p, d);
    d = f.sqr(d);
    power >>= _1n$4;
  }
  return p;
}
/**
 * Efficiently invert an array of Field elements.
 * `inv(0)` will return `undefined` here: make sure to throw an error.
 */
function FpInvertBatch(f, nums) {
  const tmp = new Array(nums.length);
  // Walk from first to last, multiply them by each other MOD p
  const lastMultiplied = nums.reduce((acc, num, i) => {
    if (f.is0(num)) return acc;
    tmp[i] = acc;
    return f.mul(acc, num);
  }, f.ONE);
  // Invert last element
  const inverted = f.inv(lastMultiplied);
  // Walk from last to first, multiply them by inverted each other MOD p
  nums.reduceRight((acc, num, i) => {
    if (f.is0(num)) return acc;
    tmp[i] = f.mul(acc, tmp[i]);
    return f.mul(acc, num);
  }, inverted);
  return tmp;
}
// CURVE.n lengths
function nLength(n, nBitLength) {
  // Bit size, byte size of CURVE.n
  const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;
  const nByteLength = Math.ceil(_nBitLength / 8);
  return {
    nBitLength: _nBitLength,
    nByteLength
  };
}
/**
 * Initializes a finite field over prime. **Non-primes are not supported.**
 * Do not init in loop: slow. Very fragile: always run a benchmark on a change.
 * Major performance optimizations:
 * * a) denormalized operations like mulN instead of mul
 * * b) same object shape: never add or remove keys
 * * c) Object.freeze
 * NOTE: operations don't check 'isValid' for all elements for performance reasons,
 * it is caller responsibility to check this.
 * This is low-level code, please make sure you know what you doing.
 * @param ORDER prime positive bigint
 * @param bitLen how many bits the field consumes
 * @param isLE (def: false) if encoding / decoding should be in little-endian
 * @param redef optional faster redefinitions of sqrt and other methods
 */
function Field(ORDER, bitLen) {
  let isLE = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  let redef = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  if (ORDER <= _0n$3) throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);
  const {
    nBitLength: BITS,
    nByteLength: BYTES
  } = nLength(ORDER, bitLen);
  if (BYTES > 2048) throw new Error('Field lengths over 2048 bytes are not supported');
  const sqrtP = FpSqrt(ORDER);
  const f = Object.freeze({
    ORDER,
    BITS,
    BYTES,
    MASK: bitMask(BITS),
    ZERO: _0n$3,
    ONE: _1n$4,
    create: num => mod(num, ORDER),
    isValid: num => {
      if (typeof num !== 'bigint') throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);
      return _0n$3 <= num && num < ORDER; // 0 is valid element, but it's not invertible
    },
    is0: num => num === _0n$3,
    isOdd: num => (num & _1n$4) === _1n$4,
    neg: num => mod(-num, ORDER),
    eql: (lhs, rhs) => lhs === rhs,
    sqr: num => mod(num * num, ORDER),
    add: (lhs, rhs) => mod(lhs + rhs, ORDER),
    sub: (lhs, rhs) => mod(lhs - rhs, ORDER),
    mul: (lhs, rhs) => mod(lhs * rhs, ORDER),
    pow: (num, power) => FpPow(f, num, power),
    div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),
    // Same as above, but doesn't normalize
    sqrN: num => num * num,
    addN: (lhs, rhs) => lhs + rhs,
    subN: (lhs, rhs) => lhs - rhs,
    mulN: (lhs, rhs) => lhs * rhs,
    inv: num => invert(num, ORDER),
    sqrt: redef.sqrt || (n => sqrtP(f, n)),
    invertBatch: lst => FpInvertBatch(f, lst),
    // TODO: do we really need constant cmov?
    // We don't have const-time bigints anyway, so probably will be not very useful
    cmov: (a, b, c) => c ? b : a,
    toBytes: num => isLE ? numberToBytesLE(num, BYTES) : numberToBytesBE(num, BYTES),
    fromBytes: bytes => {
      if (bytes.length !== BYTES) throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes.length}`);
      return isLE ? bytesToNumberLE(bytes) : bytesToNumberBE(bytes);
    }
  });
  return Object.freeze(f);
}
/**
 * Returns total number of bytes consumed by the field element.
 * For example, 32 bytes for usual 256-bit weierstrass curve.
 * @param fieldOrder number of field elements, usually CURVE.n
 * @returns byte length of field
 */
function getFieldBytesLength(fieldOrder) {
  if (typeof fieldOrder !== 'bigint') throw new Error('field order must be bigint');
  const bitLength = fieldOrder.toString(2).length;
  return Math.ceil(bitLength / 8);
}
/**
 * Returns minimal amount of bytes that can be safely reduced
 * by field order.
 * Should be 2^-128 for 128-bit curve such as P256.
 * @param fieldOrder number of field elements, usually CURVE.n
 * @returns byte length of target hash
 */
function getMinHashLength(fieldOrder) {
  const length = getFieldBytesLength(fieldOrder);
  return length + Math.ceil(length / 2);
}
/**
 * "Constant-time" private key generation utility.
 * Can take (n + n/2) or more bytes of uniform input e.g. from CSPRNG or KDF
 * and convert them into private scalar, with the modulo bias being negligible.
 * Needs at least 48 bytes of input for 32-byte private key.
 * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/
 * FIPS 186-5, A.2 https://csrc.nist.gov/publications/detail/fips/186/5/final
 * RFC 9380, https://www.rfc-editor.org/rfc/rfc9380#section-5
 * @param hash hash output from SHA3 or a similar function
 * @param groupOrder size of subgroup - (e.g. secp256k1.CURVE.n)
 * @param isLE interpret hash bytes as LE num
 * @returns valid private scalar
 */
function mapHashToField(key, fieldOrder) {
  let isLE = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  const len = key.length;
  const fieldLen = getFieldBytesLength(fieldOrder);
  const minLen = getMinHashLength(fieldOrder);
  // No small numbers: need to understand bias story. No huge numbers: easier to detect JS timings.
  if (len < 16 || len < minLen || len > 1024) throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);
  const num = isLE ? bytesToNumberBE(key) : bytesToNumberLE(key);
  // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0
  const reduced = mod(num, fieldOrder - _1n$4) + _1n$4;
  return isLE ? numberToBytesLE(reduced, fieldLen) : numberToBytesBE(reduced, fieldLen);
}

/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const _0n$2 = BigInt(0);
const _1n$3 = BigInt(1);
// Since points in different groups cannot be equal (different object constructor),
// we can have single place to store precomputes
const pointPrecomputes = new WeakMap();
const pointWindowSizes = new WeakMap(); // This allows use make points immutable (nothing changes inside)
// Elliptic curve multiplication of Point by scalar. Fragile.
// Scalars should always be less than curve order: this should be checked inside of a curve itself.
// Creates precomputation tables for fast multiplication:
// - private scalar is split by fixed size windows of W bits
// - every window point is collected from window's table & added to accumulator
// - since windows are different, same point inside tables won't be accessed more than once per calc
// - each multiplication is 'Math.ceil(CURVE_ORDER / ) + 1' point additions (fixed for any scalar)
// - +1 window is neccessary for wNAF
// - wNAF reduces table size: 2x less memory + 2x faster generation, but 10% slower multiplication
// TODO: Research returning 2d JS array of windows, instead of a single window. This would allow
// windows to be in different memory locations
function wNAF(c, bits) {
  const constTimeNegate = (condition, item) => {
    const neg = item.negate();
    return condition ? neg : item;
  };
  const validateW = W => {
    if (!Number.isSafeInteger(W) || W <= 0 || W > bits) throw new Error(`Wrong window size=${W}, should be [1..${bits}]`);
  };
  const opts = W => {
    validateW(W);
    const windows = Math.ceil(bits / W) + 1; // +1, because
    const windowSize = 2 ** (W - 1); // -1 because we skip zero
    return {
      windows,
      windowSize
    };
  };
  return {
    constTimeNegate,
    // non-const time multiplication ladder
    unsafeLadder(elm, n) {
      let p = c.ZERO;
      let d = elm;
      while (n > _0n$2) {
        if (n & _1n$3) p = p.add(d);
        d = d.double();
        n >>= _1n$3;
      }
      return p;
    },
    /**
     * Creates a wNAF precomputation window. Used for caching.
     * Default window size is set by `utils.precompute()` and is equal to 8.
     * Number of precomputed points depends on the curve size:
     * 2^(1) * (Math.ceil( / ) + 1), where:
     * -  is the window size
     * -  is the bitlength of the curve order.
     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
     * @returns precomputed point tables flattened to a single array
     */
    precomputeWindow(elm, W) {
      const {
        windows,
        windowSize
      } = opts(W);
      const points = [];
      let p = elm;
      let base = p;
      for (let window = 0; window < windows; window++) {
        base = p;
        points.push(base);
        // =1, because we skip zero
        for (let i = 1; i < windowSize; i++) {
          base = base.add(p);
          points.push(base);
        }
        p = base.double();
      }
      return points;
    },
    /**
     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @returns real and fake (for const-time) points
     */
    wNAF(W, precomputes, n) {
      // TODO: maybe check that scalar is less than group order? wNAF behavious is undefined otherwise
      // But need to carefully remove other checks before wNAF. ORDER == bits here
      const {
        windows,
        windowSize
      } = opts(W);
      let p = c.ZERO;
      let f = c.BASE;
      const mask = BigInt(2 ** W - 1); // Create mask with W ones: 0b1111 for W=4 etc.
      const maxNumber = 2 ** W;
      const shiftBy = BigInt(W);
      for (let window = 0; window < windows; window++) {
        const offset = window * windowSize;
        // Extract W bits.
        let wbits = Number(n & mask);
        // Shift number by W bits.
        n >>= shiftBy;
        // If the bits are bigger than max size, we'll split those.
        // +224 => 256 - 32
        if (wbits > windowSize) {
          wbits -= maxNumber;
          n += _1n$3;
        }
        // This code was first written with assumption that 'f' and 'p' will never be infinity point:
        // since each addition is multiplied by 2 ** W, it cannot cancel each other. However,
        // there is negate now: it is possible that negated element from low value
        // would be the same as high element, which will create carry into next window.
        // It's not obvious how this can fail, but still worth investigating later.
        // Check if we're onto Zero point.
        // Add random point inside current window to f.
        const offset1 = offset;
        const offset2 = offset + Math.abs(wbits) - 1; // -1 because we skip zero
        const cond1 = window % 2 !== 0;
        const cond2 = wbits < 0;
        if (wbits === 0) {
          // The most important part for const-time getPublicKey
          f = f.add(constTimeNegate(cond1, precomputes[offset1]));
        } else {
          p = p.add(constTimeNegate(cond2, precomputes[offset2]));
        }
      }
      // JIT-compiler should not eliminate f here, since it will later be used in normalizeZ()
      // Even if the variable is still unused, there are some checks which will
      // throw an exception, so compiler needs to prove they won't happen, which is hard.
      // At this point there is a way to F be infinity-point even if p is not,
      // which makes it less const-time: around 1 bigint multiply.
      return {
        p,
        f
      };
    },
    wNAFCached(P, n, transform) {
      const W = pointWindowSizes.get(P) || 1;
      // Calculate precomputes on a first run, reuse them after
      let comp = pointPrecomputes.get(P);
      if (!comp) {
        comp = this.precomputeWindow(P, W);
        if (W !== 1) pointPrecomputes.set(P, transform(comp));
      }
      return this.wNAF(W, comp, n);
    },
    // We calculate precomputes for elliptic curve point multiplication
    // using windowed method. This specifies window size and
    // stores precomputed values. Usually only base point would be precomputed.
    setWindowSize(P, W) {
      validateW(W);
      pointWindowSizes.set(P, W);
      pointPrecomputes.delete(P);
    }
  };
}
/**
 * Pippenger algorithm for multi-scalar multiplication (MSM).
 * MSM is basically (Pa + Qb + Rc + ...).
 * 30x faster vs naive addition on L=4096, 10x faster with precomputes.
 * For N=254bit, L=1, it does: 1024 ADD + 254 DBL. For L=5: 1536 ADD + 254 DBL.
 * Algorithmically constant-time (for same L), even when 1 point + scalar, or when scalar = 0.
 * @param c Curve Point constructor
 * @param field field over CURVE.N - important that it's not over CURVE.P
 * @param points array of L curve points
 * @param scalars array of L scalars (aka private keys / bigints)
 */
function pippenger(c, field, points, scalars) {
  // If we split scalars by some window (let's say 8 bits), every chunk will only
  // take 256 buckets even if there are 4096 scalars, also re-uses double.
  // TODO:
  // - https://eprint.iacr.org/2024/750.pdf
  // - https://tches.iacr.org/index.php/TCHES/article/view/10287
  // 0 is accepted in scalars
  if (!Array.isArray(points) || !Array.isArray(scalars) || scalars.length !== points.length) throw new Error('arrays of points and scalars must have equal length');
  scalars.forEach((s, i) => {
    if (!field.isValid(s)) throw new Error(`wrong scalar at index ${i}`);
  });
  points.forEach((p, i) => {
    if (!(p instanceof c)) throw new Error(`wrong point at index ${i}`);
  });
  const wbits = bitLen(BigInt(points.length));
  const windowSize = wbits > 12 ? wbits - 3 : wbits > 4 ? wbits - 2 : wbits ? 2 : 1; // in bits
  const MASK = (1 << windowSize) - 1;
  const buckets = new Array(MASK + 1).fill(c.ZERO); // +1 for zero array
  const lastBits = Math.floor((field.BITS - 1) / windowSize) * windowSize;
  let sum = c.ZERO;
  for (let i = lastBits; i >= 0; i -= windowSize) {
    buckets.fill(c.ZERO);
    for (let j = 0; j < scalars.length; j++) {
      const scalar = scalars[j];
      const wbits = Number(scalar >> BigInt(i) & BigInt(MASK));
      buckets[wbits] = buckets[wbits].add(points[j]);
    }
    let resI = c.ZERO; // not using this will do small speed-up, but will lose ct
    // Skip first bucket, because it is zero
    for (let j = buckets.length - 1, sumI = c.ZERO; j > 0; j--) {
      sumI = sumI.add(buckets[j]);
      resI = resI.add(sumI);
    }
    sum = sum.add(resI);
    if (i !== 0) for (let j = 0; j < windowSize; j++) sum = sum.double();
  }
  return sum;
}
function validateBasic(curve) {
  validateField(curve.Fp);
  validateObject(curve, {
    n: 'bigint',
    h: 'bigint',
    Gx: 'field',
    Gy: 'field'
  }, {
    nBitLength: 'isSafeInteger',
    nByteLength: 'isSafeInteger'
  });
  // Set defaults
  return Object.freeze({
    ...nLength(curve.n, curve.nBitLength),
    ...curve,
    ...{
      p: curve.Fp.ORDER
    }
  });
}

/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function validateSigVerOpts(opts) {
  if (opts.lowS !== undefined) abool('lowS', opts.lowS);
  if (opts.prehash !== undefined) abool('prehash', opts.prehash);
}
function validatePointOpts(curve) {
  const opts = validateBasic(curve);
  validateObject(opts, {
    a: 'field',
    b: 'field'
  }, {
    allowedPrivateKeyLengths: 'array',
    wrapPrivateKey: 'boolean',
    isTorsionFree: 'function',
    clearCofactor: 'function',
    allowInfinityPoint: 'boolean',
    fromBytes: 'function',
    toBytes: 'function'
  });
  const {
    endo,
    Fp,
    a
  } = opts;
  if (endo) {
    if (!Fp.eql(a, Fp.ZERO)) {
      throw new Error('Endomorphism can only be defined for Koblitz curves that have a=0');
    }
    if (typeof endo !== 'object' || typeof endo.beta !== 'bigint' || typeof endo.splitScalar !== 'function') {
      throw new Error('Expected endomorphism with beta: bigint and splitScalar: function');
    }
  }
  return Object.freeze({
    ...opts
  });
}
const {
  bytesToNumberBE: b2n,
  hexToBytes: h2b
} = ut;
/**
 * ASN.1 DER encoding utilities. ASN is very complex & fragile. Format:
 *
 *     [0x30 (SEQUENCE), bytelength, 0x02 (INTEGER), intLength, R, 0x02 (INTEGER), intLength, S]
 *
 * Docs: https://letsencrypt.org/docs/a-warm-welcome-to-asn1-and-der/, https://luca.ntop.org/Teaching/Appunti/asn1.html
 */
const DER = {
  // asn.1 DER encoding utils
  Err: class DERErr extends Error {
    constructor() {
      let m = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
      super(m);
    }
  },
  // Basic building block is TLV (Tag-Length-Value)
  _tlv: {
    encode: (tag, data) => {
      const {
        Err: E
      } = DER;
      if (tag < 0 || tag > 256) throw new E('tlv.encode: wrong tag');
      if (data.length & 1) throw new E('tlv.encode: unpadded data');
      const dataLen = data.length / 2;
      const len = numberToHexUnpadded(dataLen);
      if (len.length / 2 & 128) throw new E('tlv.encode: long form length too big');
      // length of length with long form flag
      const lenLen = dataLen > 127 ? numberToHexUnpadded(len.length / 2 | 128) : '';
      return `${numberToHexUnpadded(tag)}${lenLen}${len}${data}`;
    },
    // v - value, l - left bytes (unparsed)
    decode(tag, data) {
      const {
        Err: E
      } = DER;
      let pos = 0;
      if (tag < 0 || tag > 256) throw new E('tlv.encode: wrong tag');
      if (data.length < 2 || data[pos++] !== tag) throw new E('tlv.decode: wrong tlv');
      const first = data[pos++];
      const isLong = !!(first & 128); // First bit of first length byte is flag for short/long form
      let length = 0;
      if (!isLong) length = first;else {
        // Long form: [longFlag(1bit), lengthLength(7bit), length (BE)]
        const lenLen = first & 127;
        if (!lenLen) throw new E('tlv.decode(long): indefinite length not supported');
        if (lenLen > 4) throw new E('tlv.decode(long): byte length is too big'); // this will overflow u32 in js
        const lengthBytes = data.subarray(pos, pos + lenLen);
        if (lengthBytes.length !== lenLen) throw new E('tlv.decode: length bytes not complete');
        if (lengthBytes[0] === 0) throw new E('tlv.decode(long): zero leftmost byte');
        for (const b of lengthBytes) length = length << 8 | b;
        pos += lenLen;
        if (length < 128) throw new E('tlv.decode(long): not minimal encoding');
      }
      const v = data.subarray(pos, pos + length);
      if (v.length !== length) throw new E('tlv.decode: wrong value length');
      return {
        v,
        l: data.subarray(pos + length)
      };
    }
  },
  // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,
  // since we always use positive integers here. It must always be empty:
  // - add zero byte if exists
  // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)
  _int: {
    encode(num) {
      const {
        Err: E
      } = DER;
      if (num < _0n$1) throw new E('integer: negative integers are not allowed');
      let hex = numberToHexUnpadded(num);
      // Pad with zero byte if negative flag is present
      if (Number.parseInt(hex[0], 16) & 0b1000) hex = '00' + hex;
      if (hex.length & 1) throw new E('unexpected assertion');
      return hex;
    },
    decode(data) {
      const {
        Err: E
      } = DER;
      if (data[0] & 128) throw new E('Invalid signature integer: negative');
      if (data[0] === 0x00 && !(data[1] & 128)) throw new E('Invalid signature integer: unnecessary leading zero');
      return b2n(data);
    }
  },
  toSig(hex) {
    // parse DER signature
    const {
      Err: E,
      _int: int,
      _tlv: tlv
    } = DER;
    const data = typeof hex === 'string' ? h2b(hex) : hex;
    abytes(data);
    const {
      v: seqBytes,
      l: seqLeftBytes
    } = tlv.decode(0x30, data);
    if (seqLeftBytes.length) throw new E('Invalid signature: left bytes after parsing');
    const {
      v: rBytes,
      l: rLeftBytes
    } = tlv.decode(0x02, seqBytes);
    const {
      v: sBytes,
      l: sLeftBytes
    } = tlv.decode(0x02, rLeftBytes);
    if (sLeftBytes.length) throw new E('Invalid signature: left bytes after parsing');
    return {
      r: int.decode(rBytes),
      s: int.decode(sBytes)
    };
  },
  hexFromSig(sig) {
    const {
      _tlv: tlv,
      _int: int
    } = DER;
    const seq = `${tlv.encode(0x02, int.encode(sig.r))}${tlv.encode(0x02, int.encode(sig.s))}`;
    return tlv.encode(0x30, seq);
  }
};
// Be friendly to bad ECMAScript parsers by not using bigint literals
// prettier-ignore
const _0n$1 = BigInt(0),
  _1n$2 = BigInt(1);
  BigInt(2);
  const _3n = BigInt(3);
  BigInt(4);
function weierstrassPoints(opts) {
  const CURVE = validatePointOpts(opts);
  const {
    Fp
  } = CURVE; // All curves has same field / group length as for now, but they can differ
  const Fn = Field(CURVE.n, CURVE.nBitLength);
  const toBytes = CURVE.toBytes || ((_c, point, _isCompressed) => {
    const a = point.toAffine();
    return concatBytes(Uint8Array.from([0x04]), Fp.toBytes(a.x), Fp.toBytes(a.y));
  });
  const fromBytes = CURVE.fromBytes || (bytes => {
    // const head = bytes[0];
    const tail = bytes.subarray(1);
    // if (head !== 0x04) throw new Error('Only non-compressed encoding is supported');
    const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));
    const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));
    return {
      x,
      y
    };
  });
  /**
   * y = x + ax + b: Short weierstrass curve formula
   * @returns y
   */
  function weierstrassEquation(x) {
    const {
      a,
      b
    } = CURVE;
    const x2 = Fp.sqr(x); // x * x
    const x3 = Fp.mul(x2, x); // x2 * x
    return Fp.add(Fp.add(x3, Fp.mul(x, a)), b); // x3 + a * x + b
  }
  // Validate whether the passed curve params are valid.
  // We check if curve equation works for generator point.
  // `assertValidity()` won't work: `isTorsionFree()` is not available at this point in bls12-381.
  // ProjectivePoint class has not been initialized yet.
  if (!Fp.eql(Fp.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx))) throw new Error('bad generator point: equation left != right');
  // Valid group elements reside in range 1..n-1
  function isWithinCurveOrder(num) {
    return inRange(num, _1n$2, CURVE.n);
  }
  // Validates if priv key is valid and converts it to bigint.
  // Supports options allowedPrivateKeyLengths and wrapPrivateKey.
  function normPrivateKeyToScalar(key) {
    const {
      allowedPrivateKeyLengths: lengths,
      nByteLength,
      wrapPrivateKey,
      n: N
    } = CURVE;
    if (lengths && typeof key !== 'bigint') {
      if (isBytes(key)) key = bytesToHex(key);
      // Normalize to hex string, pad. E.g. P521 would norm 130-132 char hex to 132-char bytes
      if (typeof key !== 'string' || !lengths.includes(key.length)) throw new Error('Invalid key');
      key = key.padStart(nByteLength * 2, '0');
    }
    let num;
    try {
      num = typeof key === 'bigint' ? key : bytesToNumberBE(ensureBytes('private key', key, nByteLength));
    } catch (error) {
      throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);
    }
    if (wrapPrivateKey) num = mod(num, N); // disabled by default, enabled for BLS
    aInRange('private key', num, _1n$2, N); // num in range [1..N-1]
    return num;
  }
  function assertPrjPoint(other) {
    if (!(other instanceof Point)) throw new Error('ProjectivePoint expected');
  }
  // Memoized toAffine / validity check. They are heavy. Points are immutable.
  // Converts Projective point to affine (x, y) coordinates.
  // Can accept precomputed Z^-1 - for example, from invertBatch.
  // (x, y, z)  (x=x/z, y=y/z)
  const toAffineMemo = memoized((p, iz) => {
    const {
      px: x,
      py: y,
      pz: z
    } = p;
    // Fast-path for normalized points
    if (Fp.eql(z, Fp.ONE)) return {
      x,
      y
    };
    const is0 = p.is0();
    // If invZ was 0, we return zero point. However we still want to execute
    // all operations, so we replace invZ with a random number, 1.
    if (iz == null) iz = is0 ? Fp.ONE : Fp.inv(z);
    const ax = Fp.mul(x, iz);
    const ay = Fp.mul(y, iz);
    const zz = Fp.mul(z, iz);
    if (is0) return {
      x: Fp.ZERO,
      y: Fp.ZERO
    };
    if (!Fp.eql(zz, Fp.ONE)) throw new Error('invZ was invalid');
    return {
      x: ax,
      y: ay
    };
  });
  // NOTE: on exception this will crash 'cached' and no value will be set.
  // Otherwise true will be return
  const assertValidMemo = memoized(p => {
    if (p.is0()) {
      // (0, 1, 0) aka ZERO is invalid in most contexts.
      // In BLS, ZERO can be serialized, so we allow it.
      // (0, 0, 0) is wrong representation of ZERO and is always invalid.
      if (CURVE.allowInfinityPoint && !Fp.is0(p.py)) return;
      throw new Error('bad point: ZERO');
    }
    // Some 3rd-party test vectors require different wording between here & `fromCompressedHex`
    const {
      x,
      y
    } = p.toAffine();
    // Check if x, y are valid field elements
    if (!Fp.isValid(x) || !Fp.isValid(y)) throw new Error('bad point: x or y not FE');
    const left = Fp.sqr(y); // y
    const right = weierstrassEquation(x); // x + ax + b
    if (!Fp.eql(left, right)) throw new Error('bad point: equation left != right');
    if (!p.isTorsionFree()) throw new Error('bad point: not in prime-order subgroup');
    return true;
  });
  /**
   * Projective Point works in 3d / projective (homogeneous) coordinates: (x, y, z)  (x=x/z, y=y/z)
   * Default Point works in 2d / affine coordinates: (x, y)
   * We're doing calculations in projective, because its operations don't require costly inversion.
   */
  class Point {
    constructor(px, py, pz) {
      this.px = px;
      this.py = py;
      this.pz = pz;
      if (px == null || !Fp.isValid(px)) throw new Error('x required');
      if (py == null || !Fp.isValid(py)) throw new Error('y required');
      if (pz == null || !Fp.isValid(pz)) throw new Error('z required');
      Object.freeze(this);
    }
    // Does not validate if the point is on-curve.
    // Use fromHex instead, or call assertValidity() later.
    static fromAffine(p) {
      const {
        x,
        y
      } = p || {};
      if (!p || !Fp.isValid(x) || !Fp.isValid(y)) throw new Error('invalid affine point');
      if (p instanceof Point) throw new Error('projective point not allowed');
      const is0 = i => Fp.eql(i, Fp.ZERO);
      // fromAffine(x:0, y:0) would produce (x:0, y:0, z:1), but we need (x:0, y:1, z:0)
      if (is0(x) && is0(y)) return Point.ZERO;
      return new Point(x, y, Fp.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    /**
     * Takes a bunch of Projective Points but executes only one
     * inversion on all of them. Inversion is very slow operation,
     * so this improves performance massively.
     * Optimization: converts a list of projective points to a list of identical points with Z=1.
     */
    static normalizeZ(points) {
      const toInv = Fp.invertBatch(points.map(p => p.pz));
      return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);
    }
    /**
     * Converts hash string or Uint8Array to Point.
     * @param hex short/long ECDSA hex
     */
    static fromHex(hex) {
      const P = Point.fromAffine(fromBytes(ensureBytes('pointHex', hex)));
      P.assertValidity();
      return P;
    }
    // Multiplies generator point by privateKey.
    static fromPrivateKey(privateKey) {
      return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));
    }
    // Multiscalar Multiplication
    static msm(points, scalars) {
      return pippenger(Point, Fn, points, scalars);
    }
    // "Private method", don't use it directly
    _setWindowSize(windowSize) {
      wnaf.setWindowSize(this, windowSize);
    }
    // A point on curve is valid if it conforms to equation.
    assertValidity() {
      assertValidMemo(this);
    }
    hasEvenY() {
      const {
        y
      } = this.toAffine();
      if (Fp.isOdd) return !Fp.isOdd(y);
      throw new Error("Field doesn't support isOdd");
    }
    /**
     * Compare one point to another.
     */
    equals(other) {
      assertPrjPoint(other);
      const {
        px: X1,
        py: Y1,
        pz: Z1
      } = this;
      const {
        px: X2,
        py: Y2,
        pz: Z2
      } = other;
      const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));
      const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));
      return U1 && U2;
    }
    /**
     * Flips point to one corresponding to (x, -y) in Affine coordinates.
     */
    negate() {
      return new Point(this.px, Fp.neg(this.py), this.pz);
    }
    // Renes-Costello-Batina exception-free doubling formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 3
    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
    double() {
      const {
        a,
        b
      } = CURVE;
      const b3 = Fp.mul(b, _3n);
      const {
        px: X1,
        py: Y1,
        pz: Z1
      } = this;
      let X3 = Fp.ZERO,
        Y3 = Fp.ZERO,
        Z3 = Fp.ZERO; // prettier-ignore
      let t0 = Fp.mul(X1, X1); // step 1
      let t1 = Fp.mul(Y1, Y1);
      let t2 = Fp.mul(Z1, Z1);
      let t3 = Fp.mul(X1, Y1);
      t3 = Fp.add(t3, t3); // step 5
      Z3 = Fp.mul(X1, Z1);
      Z3 = Fp.add(Z3, Z3);
      X3 = Fp.mul(a, Z3);
      Y3 = Fp.mul(b3, t2);
      Y3 = Fp.add(X3, Y3); // step 10
      X3 = Fp.sub(t1, Y3);
      Y3 = Fp.add(t1, Y3);
      Y3 = Fp.mul(X3, Y3);
      X3 = Fp.mul(t3, X3);
      Z3 = Fp.mul(b3, Z3); // step 15
      t2 = Fp.mul(a, t2);
      t3 = Fp.sub(t0, t2);
      t3 = Fp.mul(a, t3);
      t3 = Fp.add(t3, Z3);
      Z3 = Fp.add(t0, t0); // step 20
      t0 = Fp.add(Z3, t0);
      t0 = Fp.add(t0, t2);
      t0 = Fp.mul(t0, t3);
      Y3 = Fp.add(Y3, t0);
      t2 = Fp.mul(Y1, Z1); // step 25
      t2 = Fp.add(t2, t2);
      t0 = Fp.mul(t2, t3);
      X3 = Fp.sub(X3, t0);
      Z3 = Fp.mul(t2, t1);
      Z3 = Fp.add(Z3, Z3); // step 30
      Z3 = Fp.add(Z3, Z3);
      return new Point(X3, Y3, Z3);
    }
    // Renes-Costello-Batina exception-free addition formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 1
    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
    add(other) {
      assertPrjPoint(other);
      const {
        px: X1,
        py: Y1,
        pz: Z1
      } = this;
      const {
        px: X2,
        py: Y2,
        pz: Z2
      } = other;
      let X3 = Fp.ZERO,
        Y3 = Fp.ZERO,
        Z3 = Fp.ZERO; // prettier-ignore
      const a = CURVE.a;
      const b3 = Fp.mul(CURVE.b, _3n);
      let t0 = Fp.mul(X1, X2); // step 1
      let t1 = Fp.mul(Y1, Y2);
      let t2 = Fp.mul(Z1, Z2);
      let t3 = Fp.add(X1, Y1);
      let t4 = Fp.add(X2, Y2); // step 5
      t3 = Fp.mul(t3, t4);
      t4 = Fp.add(t0, t1);
      t3 = Fp.sub(t3, t4);
      t4 = Fp.add(X1, Z1);
      let t5 = Fp.add(X2, Z2); // step 10
      t4 = Fp.mul(t4, t5);
      t5 = Fp.add(t0, t2);
      t4 = Fp.sub(t4, t5);
      t5 = Fp.add(Y1, Z1);
      X3 = Fp.add(Y2, Z2); // step 15
      t5 = Fp.mul(t5, X3);
      X3 = Fp.add(t1, t2);
      t5 = Fp.sub(t5, X3);
      Z3 = Fp.mul(a, t4);
      X3 = Fp.mul(b3, t2); // step 20
      Z3 = Fp.add(X3, Z3);
      X3 = Fp.sub(t1, Z3);
      Z3 = Fp.add(t1, Z3);
      Y3 = Fp.mul(X3, Z3);
      t1 = Fp.add(t0, t0); // step 25
      t1 = Fp.add(t1, t0);
      t2 = Fp.mul(a, t2);
      t4 = Fp.mul(b3, t4);
      t1 = Fp.add(t1, t2);
      t2 = Fp.sub(t0, t2); // step 30
      t2 = Fp.mul(a, t2);
      t4 = Fp.add(t4, t2);
      t0 = Fp.mul(t1, t4);
      Y3 = Fp.add(Y3, t0);
      t0 = Fp.mul(t5, t4); // step 35
      X3 = Fp.mul(t3, X3);
      X3 = Fp.sub(X3, t0);
      t0 = Fp.mul(t3, t1);
      Z3 = Fp.mul(t5, Z3);
      Z3 = Fp.add(Z3, t0); // step 40
      return new Point(X3, Y3, Z3);
    }
    subtract(other) {
      return this.add(other.negate());
    }
    is0() {
      return this.equals(Point.ZERO);
    }
    wNAF(n) {
      return wnaf.wNAFCached(this, n, Point.normalizeZ);
    }
    /**
     * Non-constant-time multiplication. Uses double-and-add algorithm.
     * It's faster, but should only be used when you don't care about
     * an exposed private key e.g. sig verification, which works over *public* keys.
     */
    multiplyUnsafe(sc) {
      aInRange('scalar', sc, _0n$1, CURVE.n);
      const I = Point.ZERO;
      if (sc === _0n$1) return I;
      if (sc === _1n$2) return this;
      const {
        endo
      } = CURVE;
      if (!endo) return wnaf.unsafeLadder(this, sc);
      // Apply endomorphism
      let {
        k1neg,
        k1,
        k2neg,
        k2
      } = endo.splitScalar(sc);
      let k1p = I;
      let k2p = I;
      let d = this;
      while (k1 > _0n$1 || k2 > _0n$1) {
        if (k1 & _1n$2) k1p = k1p.add(d);
        if (k2 & _1n$2) k2p = k2p.add(d);
        d = d.double();
        k1 >>= _1n$2;
        k2 >>= _1n$2;
      }
      if (k1neg) k1p = k1p.negate();
      if (k2neg) k2p = k2p.negate();
      k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
      return k1p.add(k2p);
    }
    /**
     * Constant time multiplication.
     * Uses wNAF method. Windowed method may be 10% faster,
     * but takes 2x longer to generate and consumes 2x memory.
     * Uses precomputes when available.
     * Uses endomorphism for Koblitz curves.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */
    multiply(scalar) {
      const {
        endo,
        n: N
      } = CURVE;
      aInRange('scalar', scalar, _1n$2, N);
      let point, fake; // Fake point is used to const-time mult
      if (endo) {
        const {
          k1neg,
          k1,
          k2neg,
          k2
        } = endo.splitScalar(scalar);
        let {
          p: k1p,
          f: f1p
        } = this.wNAF(k1);
        let {
          p: k2p,
          f: f2p
        } = this.wNAF(k2);
        k1p = wnaf.constTimeNegate(k1neg, k1p);
        k2p = wnaf.constTimeNegate(k2neg, k2p);
        k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
        point = k1p.add(k2p);
        fake = f1p.add(f2p);
      } else {
        const {
          p,
          f
        } = this.wNAF(scalar);
        point = p;
        fake = f;
      }
      // Normalize `z` for both points, but return only real one
      return Point.normalizeZ([point, fake])[0];
    }
    /**
     * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
     * Not using Strauss-Shamir trick: precomputation tables are faster.
     * The trick could be useful if both P and Q are not G (not in our case).
     * @returns non-zero affine point
     */
    multiplyAndAddUnsafe(Q, a, b) {
      const G = Point.BASE; // No Strauss-Shamir trick: we have 10% faster G precomputes
      const mul = (P, a // Select faster multiply() method
      ) => a === _0n$1 || a === _1n$2 || !P.equals(G) ? P.multiplyUnsafe(a) : P.multiply(a);
      const sum = mul(this, a).add(mul(Q, b));
      return sum.is0() ? undefined : sum;
    }
    // Converts Projective point to affine (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    // (x, y, z)  (x=x/z, y=y/z)
    toAffine(iz) {
      return toAffineMemo(this, iz);
    }
    isTorsionFree() {
      const {
        h: cofactor,
        isTorsionFree
      } = CURVE;
      if (cofactor === _1n$2) return true; // No subgroups, always torsion-free
      if (isTorsionFree) return isTorsionFree(Point, this);
      throw new Error('isTorsionFree() has not been declared for the elliptic curve');
    }
    clearCofactor() {
      const {
        h: cofactor,
        clearCofactor
      } = CURVE;
      if (cofactor === _1n$2) return this; // Fast-path
      if (clearCofactor) return clearCofactor(Point, this);
      return this.multiplyUnsafe(CURVE.h);
    }
    toRawBytes() {
      let isCompressed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      abool('isCompressed', isCompressed);
      this.assertValidity();
      return toBytes(Point, this, isCompressed);
    }
    toHex() {
      let isCompressed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      abool('isCompressed', isCompressed);
      return bytesToHex(this.toRawBytes(isCompressed));
    }
  }
  Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);
  Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO);
  const _bits = CURVE.nBitLength;
  const wnaf = wNAF(Point, CURVE.endo ? Math.ceil(_bits / 2) : _bits);
  // Validate if generator point is on curve
  return {
    CURVE,
    ProjectivePoint: Point,
    normPrivateKeyToScalar,
    weierstrassEquation,
    isWithinCurveOrder
  };
}
function validateOpts(curve) {
  const opts = validateBasic(curve);
  validateObject(opts, {
    hash: 'hash',
    hmac: 'function',
    randomBytes: 'function'
  }, {
    bits2int: 'function',
    bits2int_modN: 'function',
    lowS: 'boolean'
  });
  return Object.freeze({
    lowS: true,
    ...opts
  });
}
/**
 * Creates short weierstrass curve and ECDSA signature methods for it.
 * @example
 * import { Field } from '@noble/curves/abstract/modular';
 * // Before that, define BigInt-s: a, b, p, n, Gx, Gy
 * const curve = weierstrass({ a, b, Fp: Field(p), n, Gx, Gy, h: 1n })
 */
function weierstrass(curveDef) {
  const CURVE = validateOpts(curveDef);
  const {
    Fp,
    n: CURVE_ORDER
  } = CURVE;
  const compressedLen = Fp.BYTES + 1; // e.g. 33 for 32
  const uncompressedLen = 2 * Fp.BYTES + 1; // e.g. 65 for 32
  function modN(a) {
    return mod(a, CURVE_ORDER);
  }
  function invN(a) {
    return invert(a, CURVE_ORDER);
  }
  const {
    ProjectivePoint: Point,
    normPrivateKeyToScalar,
    weierstrassEquation,
    isWithinCurveOrder
  } = weierstrassPoints({
    ...CURVE,
    toBytes(_c, point, isCompressed) {
      const a = point.toAffine();
      const x = Fp.toBytes(a.x);
      const cat = concatBytes;
      abool('isCompressed', isCompressed);
      if (isCompressed) {
        return cat(Uint8Array.from([point.hasEvenY() ? 0x02 : 0x03]), x);
      } else {
        return cat(Uint8Array.from([0x04]), x, Fp.toBytes(a.y));
      }
    },
    fromBytes(bytes) {
      const len = bytes.length;
      const head = bytes[0];
      const tail = bytes.subarray(1);
      // this.assertValidity() is done inside of fromHex
      if (len === compressedLen && (head === 0x02 || head === 0x03)) {
        const x = bytesToNumberBE(tail);
        if (!inRange(x, _1n$2, Fp.ORDER)) throw new Error('Point is not on curve');
        const y2 = weierstrassEquation(x); // y = x + ax + b
        let y;
        try {
          y = Fp.sqrt(y2); // y = y ^ (p+1)/4
        } catch (sqrtError) {
          const suffix = sqrtError instanceof Error ? ': ' + sqrtError.message : '';
          throw new Error('Point is not on curve' + suffix);
        }
        const isYOdd = (y & _1n$2) === _1n$2;
        // ECDSA
        const isHeadOdd = (head & 1) === 1;
        if (isHeadOdd !== isYOdd) y = Fp.neg(y);
        return {
          x,
          y
        };
      } else if (len === uncompressedLen && head === 0x04) {
        const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));
        const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));
        return {
          x,
          y
        };
      } else {
        throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);
      }
    }
  });
  const numToNByteStr = num => bytesToHex(numberToBytesBE(num, CURVE.nByteLength));
  function isBiggerThanHalfOrder(number) {
    const HALF = CURVE_ORDER >> _1n$2;
    return number > HALF;
  }
  function normalizeS(s) {
    return isBiggerThanHalfOrder(s) ? modN(-s) : s;
  }
  // slice bytes num
  const slcNum = (b, from, to) => bytesToNumberBE(b.slice(from, to));
  /**
   * ECDSA signature with its (r, s) properties. Supports DER & compact representations.
   */
  class Signature {
    constructor(r, s, recovery) {
      this.r = r;
      this.s = s;
      this.recovery = recovery;
      this.assertValidity();
    }
    // pair (bytes of r, bytes of s)
    static fromCompact(hex) {
      const l = CURVE.nByteLength;
      hex = ensureBytes('compactSignature', hex, l * 2);
      return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));
    }
    // DER encoded ECDSA signature
    // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
    static fromDER(hex) {
      const {
        r,
        s
      } = DER.toSig(ensureBytes('DER', hex));
      return new Signature(r, s);
    }
    assertValidity() {
      aInRange('r', this.r, _1n$2, CURVE_ORDER); // r in [1..N]
      aInRange('s', this.s, _1n$2, CURVE_ORDER); // s in [1..N]
    }
    addRecoveryBit(recovery) {
      return new Signature(this.r, this.s, recovery);
    }
    recoverPublicKey(msgHash) {
      const {
        r,
        s,
        recovery: rec
      } = this;
      const h = bits2int_modN(ensureBytes('msgHash', msgHash)); // Truncate hash
      if (rec == null || ![0, 1, 2, 3].includes(rec)) throw new Error('recovery id invalid');
      const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;
      if (radj >= Fp.ORDER) throw new Error('recovery id 2 or 3 invalid');
      const prefix = (rec & 1) === 0 ? '02' : '03';
      const R = Point.fromHex(prefix + numToNByteStr(radj));
      const ir = invN(radj); // r^-1
      const u1 = modN(-h * ir); // -hr^-1
      const u2 = modN(s * ir); // sr^-1
      const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2); // (sr^-1)R-(hr^-1)G = -(hr^-1)G + (sr^-1)
      if (!Q) throw new Error('point at infinify'); // unsafe is fine: no priv data leaked
      Q.assertValidity();
      return Q;
    }
    // Signatures should be low-s, to prevent malleability.
    hasHighS() {
      return isBiggerThanHalfOrder(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;
    }
    // DER-encoded
    toDERRawBytes() {
      return hexToBytes(this.toDERHex());
    }
    toDERHex() {
      return DER.hexFromSig({
        r: this.r,
        s: this.s
      });
    }
    // padded bytes of r, then padded bytes of s
    toCompactRawBytes() {
      return hexToBytes(this.toCompactHex());
    }
    toCompactHex() {
      return numToNByteStr(this.r) + numToNByteStr(this.s);
    }
  }
  const utils = {
    isValidPrivateKey(privateKey) {
      try {
        normPrivateKeyToScalar(privateKey);
        return true;
      } catch (error) {
        return false;
      }
    },
    normPrivateKeyToScalar: normPrivateKeyToScalar,
    /**
     * Produces cryptographically secure private key from random of size
     * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
     */
    randomPrivateKey: () => {
      const length = getMinHashLength(CURVE.n);
      return mapHashToField(CURVE.randomBytes(length), CURVE.n);
    },
    /**
     * Creates precompute table for an arbitrary EC point. Makes point "cached".
     * Allows to massively speed-up `point.multiply(scalar)`.
     * @returns cached point
     * @example
     * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
     * fast.multiply(privKey); // much faster ECDH now
     */
    precompute() {
      let windowSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 8;
      let point = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Point.BASE;
      point._setWindowSize(windowSize);
      point.multiply(BigInt(3)); // 3 is arbitrary, just need any number here
      return point;
    }
  };
  /**
   * Computes public key for a private key. Checks for validity of the private key.
   * @param privateKey private key
   * @param isCompressed whether to return compact (default), or full key
   * @returns Public key, full when isCompressed=false; short when isCompressed=true
   */
  function getPublicKey(privateKey) {
    let isCompressed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
    return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);
  }
  /**
   * Quick and dirty check for item being public key. Does not validate hex, or being on-curve.
   */
  function isProbPub(item) {
    const arr = isBytes(item);
    const str = typeof item === 'string';
    const len = (arr || str) && item.length;
    if (arr) return len === compressedLen || len === uncompressedLen;
    if (str) return len === 2 * compressedLen || len === 2 * uncompressedLen;
    if (item instanceof Point) return true;
    return false;
  }
  /**
   * ECDH (Elliptic Curve Diffie Hellman).
   * Computes shared public key from private key and public key.
   * Checks: 1) private key validity 2) shared key is on-curve.
   * Does NOT hash the result.
   * @param privateA private key
   * @param publicB different public key
   * @param isCompressed whether to return compact (default), or full key
   * @returns shared public key
   */
  function getSharedSecret(privateA, publicB) {
    let isCompressed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
    if (isProbPub(privateA)) throw new Error('first arg must be private key');
    if (!isProbPub(publicB)) throw new Error('second arg must be public key');
    const b = Point.fromHex(publicB); // check for being on-curve
    return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);
  }
  // RFC6979: ensure ECDSA msg is X bytes and < N. RFC suggests optional truncating via bits2octets.
  // FIPS 186-4 4.6 suggests the leftmost min(nBitLen, outLen) bits, which matches bits2int.
  // bits2int can produce res>N, we can do mod(res, N) since the bitLen is the same.
  // int2octets can't be used; pads small msgs with 0: unacceptatble for trunc as per RFC vectors
  const bits2int = CURVE.bits2int || function (bytes) {
    // For curves with nBitLength % 8 !== 0: bits2octets(bits2octets(m)) !== bits2octets(m)
    // for some cases, since bytes.length * 8 is not actual bitLength.
    const num = bytesToNumberBE(bytes); // check for == u8 done here
    const delta = bytes.length * 8 - CURVE.nBitLength; // truncate to nBitLength leftmost bits
    return delta > 0 ? num >> BigInt(delta) : num;
  };
  const bits2int_modN = CURVE.bits2int_modN || function (bytes) {
    return modN(bits2int(bytes)); // can't use bytesToNumberBE here
  };
  // NOTE: pads output with zero as per spec
  const ORDER_MASK = bitMask(CURVE.nBitLength);
  /**
   * Converts to bytes. Checks if num in `[0..ORDER_MASK-1]` e.g.: `[0..2^256-1]`.
   */
  function int2octets(num) {
    aInRange(`num < 2^${CURVE.nBitLength}`, num, _0n$1, ORDER_MASK);
    // works with order, can have different size than numToField!
    return numberToBytesBE(num, CURVE.nByteLength);
  }
  // Steps A, D of RFC6979 3.2
  // Creates RFC6979 seed; converts msg/privKey to numbers.
  // Used only in sign, not in verify.
  // NOTE: we cannot assume here that msgHash has same amount of bytes as curve order, this will be wrong at least for P521.
  // Also it can be bigger for P224 + SHA256
  function prepSig(msgHash, privateKey) {
    let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultSigOpts;
    if (['recovered', 'canonical'].some(k => k in opts)) throw new Error('sign() legacy options not supported');
    const {
      hash,
      randomBytes
    } = CURVE;
    let {
      lowS,
      prehash,
      extraEntropy: ent
    } = opts; // generates low-s sigs by default
    if (lowS == null) lowS = true; // RFC6979 3.2: we skip step A, because we already provide hash
    msgHash = ensureBytes('msgHash', msgHash);
    validateSigVerOpts(opts);
    if (prehash) msgHash = ensureBytes('prehashed msgHash', hash(msgHash));
    // We can't later call bits2octets, since nested bits2int is broken for curves
    // with nBitLength % 8 !== 0. Because of that, we unwrap it here as int2octets call.
    // const bits2octets = (bits) => int2octets(bits2int_modN(bits))
    const h1int = bits2int_modN(msgHash);
    const d = normPrivateKeyToScalar(privateKey); // validate private key, convert to bigint
    const seedArgs = [int2octets(d), int2octets(h1int)];
    // extraEntropy. RFC6979 3.6: additional k' (optional).
    if (ent != null && ent !== false) {
      // K = HMAC_K(V || 0x00 || int2octets(x) || bits2octets(h1) || k')
      const e = ent === true ? randomBytes(Fp.BYTES) : ent; // generate random bytes OR pass as-is
      seedArgs.push(ensureBytes('extraEntropy', e)); // check for being bytes
    }
    const seed = concatBytes(...seedArgs); // Step D of RFC6979 3.2
    const m = h1int; // NOTE: no need to call bits2int second time here, it is inside truncateHash!
    // Converts signature params into point w r/s, checks result for validity.
    function k2sig(kBytes) {
      // RFC 6979 Section 3.2, step 3: k = bits2int(T)
      const k = bits2int(kBytes); // Cannot use fields methods, since it is group element
      if (!isWithinCurveOrder(k)) return; // Important: all mod() calls here must be done over N
      const ik = invN(k); // k^-1 mod n
      const q = Point.BASE.multiply(k).toAffine(); // q = Gk
      const r = modN(q.x); // r = q.x mod n
      if (r === _0n$1) return;
      // Can use scalar blinding b^-1(bm + bdr) where b  [1,q1] according to
      // https://tches.iacr.org/index.php/TCHES/article/view/7337/6509. We've decided against it:
      // a) dependency on CSPRNG b) 15% slowdown c) doesn't really help since bigints are not CT
      const s = modN(ik * modN(m + r * d)); // Not using blinding here
      if (s === _0n$1) return;
      let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n$2); // recovery bit (2 or 3, when q.x > n)
      let normS = s;
      if (lowS && isBiggerThanHalfOrder(s)) {
        normS = normalizeS(s); // if lowS was passed, ensure s is always
        recovery ^= 1; // // in the bottom half of N
      }
      return new Signature(r, normS, recovery); // use normS, not s
    }
    return {
      seed,
      k2sig
    };
  }
  const defaultSigOpts = {
    lowS: CURVE.lowS,
    prehash: false
  };
  const defaultVerOpts = {
    lowS: CURVE.lowS,
    prehash: false
  };
  /**
   * Signs message hash with a private key.
   * ```
   * sign(m, d, k) where
   *   (x, y) = G  k
   *   r = x mod n
   *   s = (m + dr)/k mod n
   * ```
   * @param msgHash NOT message. msg needs to be hashed to `msgHash`, or use `prehash`.
   * @param privKey private key
   * @param opts lowS for non-malleable sigs. extraEntropy for mixing randomness into k. prehash will hash first arg.
   * @returns signature with recovery param
   */
  function sign(msgHash, privKey) {
    let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultSigOpts;
    const {
      seed,
      k2sig
    } = prepSig(msgHash, privKey, opts); // Steps A, D of RFC6979 3.2.
    const C = CURVE;
    const drbg = createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);
    return drbg(seed, k2sig); // Steps B, C, D, E, F, G
  }
  // Enable precomputes. Slows down first publicKey computation by 20ms.
  Point.BASE._setWindowSize(8);
  // utils.precompute(8, ProjectivePoint.BASE)
  /**
   * Verifies a signature against message hash and public key.
   * Rejects lowS signatures by default: to override,
   * specify option `{lowS: false}`. Implements section 4.1.4 from https://www.secg.org/sec1-v2.pdf:
   *
   * ```
   * verify(r, s, h, P) where
   *   U1 = hs^-1 mod n
   *   U2 = rs^-1 mod n
   *   R = U1G - U2P
   *   mod(R.x, n) == r
   * ```
   */
  function verify(signature, msgHash, publicKey) {
    var _Point$BASE$multiplyA;
    let opts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : defaultVerOpts;
    const sg = signature;
    msgHash = ensureBytes('msgHash', msgHash);
    publicKey = ensureBytes('publicKey', publicKey);
    if ('strict' in opts) throw new Error('options.strict was renamed to lowS');
    validateSigVerOpts(opts);
    const {
      lowS,
      prehash
    } = opts;
    let _sig = undefined;
    let P;
    try {
      if (typeof sg === 'string' || isBytes(sg)) {
        // Signature can be represented in 2 ways: compact (2*nByteLength) & DER (variable-length).
        // Since DER can also be 2*nByteLength bytes, we check for it first.
        try {
          _sig = Signature.fromDER(sg);
        } catch (derError) {
          if (!(derError instanceof DER.Err)) throw derError;
          _sig = Signature.fromCompact(sg);
        }
      } else if (typeof sg === 'object' && typeof sg.r === 'bigint' && typeof sg.s === 'bigint') {
        const {
          r,
          s
        } = sg;
        _sig = new Signature(r, s);
      } else {
        throw new Error('PARSE');
      }
      P = Point.fromHex(publicKey);
    } catch (error) {
      if (error.message === 'PARSE') throw new Error(`signature must be Signature instance, Uint8Array or hex string`);
      return false;
    }
    if (lowS && _sig.hasHighS()) return false;
    if (prehash) msgHash = CURVE.hash(msgHash);
    const {
      r,
      s
    } = _sig;
    const h = bits2int_modN(msgHash); // Cannot use fields methods, since it is group element
    const is = invN(s); // s^-1
    const u1 = modN(h * is); // u1 = hs^-1 mod n
    const u2 = modN(r * is); // u2 = rs^-1 mod n
    const R = (_Point$BASE$multiplyA = Point.BASE.multiplyAndAddUnsafe(P, u1, u2)) === null || _Point$BASE$multiplyA === void 0 ? void 0 : _Point$BASE$multiplyA.toAffine(); // R = u1G + u2P
    if (!R) return false;
    const v = modN(R.x);
    return v === r;
  }
  return {
    CURVE,
    getPublicKey,
    getSharedSecret,
    sign,
    verify,
    ProjectivePoint: Point,
    Signature,
    utils
  };
}

/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
// connects noble-curves to noble-hashes
function getHash(hash) {
  return {
    hash,
    hmac: function (key) {
      for (var _len = arguments.length, msgs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        msgs[_key - 1] = arguments[_key];
      }
      return hmac(hash, key, concatBytes$2(...msgs));
    },
    randomBytes
  };
}
function createCurve(curveDef, defHash) {
  const create = hash => weierstrass({
    ...curveDef,
    ...getHash(hash)
  });
  return Object.freeze({
    ...create(defHash),
    create
  });
}

/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const secp256k1P = BigInt('0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f');
const secp256k1N = BigInt('0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141');
const _1n$1 = BigInt(1);
const _2n$1 = BigInt(2);
const divNearest = (a, b) => (a + b / _2n$1) / b;
/**
 * n = n^((p+1)/4) for fields p = 3 mod 4. We unwrap the loop and multiply bit-by-bit.
 * (P+1n/4n).toString(2) would produce bits [223x 1, 0, 22x 1, 4x 0, 11, 00]
 */
function sqrtMod(y) {
  const P = secp256k1P;
  // prettier-ignore
  const _3n = BigInt(3),
    _6n = BigInt(6),
    _11n = BigInt(11),
    _22n = BigInt(22);
  // prettier-ignore
  const _23n = BigInt(23),
    _44n = BigInt(44),
    _88n = BigInt(88);
  const b2 = y * y * y % P; // x^3, 11
  const b3 = b2 * b2 * y % P; // x^7
  const b6 = pow2(b3, _3n, P) * b3 % P;
  const b9 = pow2(b6, _3n, P) * b3 % P;
  const b11 = pow2(b9, _2n$1, P) * b2 % P;
  const b22 = pow2(b11, _11n, P) * b11 % P;
  const b44 = pow2(b22, _22n, P) * b22 % P;
  const b88 = pow2(b44, _44n, P) * b44 % P;
  const b176 = pow2(b88, _88n, P) * b88 % P;
  const b220 = pow2(b176, _44n, P) * b44 % P;
  const b223 = pow2(b220, _3n, P) * b3 % P;
  const t1 = pow2(b223, _23n, P) * b22 % P;
  const t2 = pow2(t1, _6n, P) * b2 % P;
  const root = pow2(t2, _2n$1, P);
  if (!Fp.eql(Fp.sqr(root), y)) throw new Error('Cannot find square root');
  return root;
}
const Fp = Field(secp256k1P, undefined, undefined, {
  sqrt: sqrtMod
});
/**
 * secp256k1 short weierstrass curve and ECDSA signatures over it.
 */
const secp256k1 = createCurve({
  a: BigInt(0),
  // equation params: a, b
  b: BigInt(7),
  // Seem to be rigid: bitcointalk.org/index.php?topic=289795.msg3183975#msg3183975
  Fp,
  // Field's prime: 2n**256n - 2n**32n - 2n**9n - 2n**8n - 2n**7n - 2n**6n - 2n**4n - 1n
  n: secp256k1N,
  // Curve order, total count of valid points in the field
  // Base point (x, y) aka generator point
  Gx: BigInt('55066263022277343669578718895168534326250603453777594175500187360389116729240'),
  Gy: BigInt('32670510020758816978083085130507043184471273380659243275938904335757337482424'),
  h: BigInt(1),
  // Cofactor
  lowS: true,
  // Allow only low-S signatures by default in sign() and verify()
  /**
   * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.
   * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.
   * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.
   * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066
   */
  endo: {
    beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'),
    splitScalar: k => {
      const n = secp256k1N;
      const a1 = BigInt('0x3086d221a7d46bcde86c90e49284eb15');
      const b1 = -_1n$1 * BigInt('0xe4437ed6010e88286f547fa90abfe4c3');
      const a2 = BigInt('0x114ca50f7a8e2f3f657c1108d9d44cfd8');
      const b2 = a1;
      const POW_2_128 = BigInt('0x100000000000000000000000000000000'); // (2n**128n).toString(16)
      const c1 = divNearest(b2 * k, n);
      const c2 = divNearest(-b1 * k, n);
      let k1 = mod(k - c1 * a1 - c2 * a2, n);
      let k2 = mod(-c1 * b1 - c2 * b2, n);
      const k1neg = k1 > POW_2_128;
      const k2neg = k2 > POW_2_128;
      if (k1neg) k1 = n - k1;
      if (k2neg) k2 = n - k2;
      if (k1 > POW_2_128 || k2 > POW_2_128) {
        throw new Error('splitScalar: Endomorphism failed, k=' + k);
      }
      return {
        k1neg,
        k1,
        k2neg,
        k2
      };
    }
  }
}, sha256$3);
// Schnorr signatures are superior to ECDSA from above. Below is Schnorr-specific BIP0340 code.
// https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki
BigInt(0);
secp256k1.ProjectivePoint;

/**
 * @description Generates a random private key.
 *
 * @returns A randomly generated private key.
 */
function generatePrivateKey() {
  return toHex(secp256k1.utils.randomPrivateKey());
}

// TODO(v3): Rename to `toLocalAccount` + add `source` property to define source (privateKey, mnemonic, hdKey, etc).
/**
 * @description Creates an Account from a custom signing implementation.
 *
 * @returns A Local Account.
 */
function toAccount(source) {
  if (typeof source === 'string') {
    if (!isAddress(source, {
      strict: false
    })) throw new InvalidAddressError({
      address: source
    });
    return {
      address: source,
      type: 'json-rpc'
    };
  }
  if (!isAddress(source.address, {
    strict: false
  })) throw new InvalidAddressError({
    address: source.address
  });
  return {
    address: source.address,
    nonceManager: source.nonceManager,
    sign: source.sign,
    experimental_signAuthorization: source.experimental_signAuthorization,
    signMessage: source.signMessage,
    signTransaction: source.signTransaction,
    signTypedData: source.signTypedData,
    source: 'custom',
    type: 'local'
  };
}

/**
 * @description Converts a signature into hex format.
 *
 * @param signature The signature to convert.
 * @returns The signature in hex format.
 *
 * @example
 * serializeSignature({
 *   r: '0x6e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf',
 *   s: '0x4a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db8',
 *   yParity: 1
 * })
 * // "0x6e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf4a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db81c"
 */
function serializeSignature(_ref) {
  let {
    r,
    s,
    to = 'hex',
    v,
    yParity
  } = _ref;
  const yParity_ = (() => {
    if (yParity === 0 || yParity === 1) return yParity;
    if (v && (v === 27n || v === 28n || v >= 35n)) return v % 2n === 0n ? 1 : 0;
    throw new Error('Invalid `v` or `yParity` value');
  })();
  const signature = `0x${new secp256k1.Signature(hexToBigInt(r), hexToBigInt(s)).toCompactHex()}${yParity_ === 0 ? '1b' : '1c'}`;
  if (to === 'hex') return signature;
  return hexToBytes$1(signature);
}

// TODO(v3): Convert to sync.
/**
 * @description Signs a hash with a given private key.
 *
 * @param hash The hash to sign.
 * @param privateKey The private key to sign with.
 *
 * @returns The signature.
 */
async function sign$1(_ref) {
  let {
    hash,
    privateKey,
    to = 'object'
  } = _ref;
  const {
    r,
    s,
    recovery
  } = secp256k1.sign(hash.slice(2), privateKey.slice(2));
  const signature = {
    r: numberToHex(r, {
      size: 32
    }),
    s: numberToHex(s, {
      size: 32
    }),
    v: recovery ? 28n : 27n,
    yParity: recovery
  };
  return (() => {
    if (to === 'bytes' || to === 'hex') return serializeSignature({
      ...signature,
      to
    });
    return signature;
  })();
}

/**
 * Signs an Authorization hash in [EIP-7702 format](https://eips.ethereum.org/EIPS/eip-7702): `keccak256('0x05' || rlp([chain_id, address, nonce]))`.
 */
async function experimental_signAuthorization(parameters) {
  const {
    contractAddress,
    chainId,
    nonce,
    privateKey,
    to = 'object'
  } = parameters;
  const signature = await sign$1({
    hash: hashAuthorization({
      contractAddress,
      chainId,
      nonce
    }),
    privateKey,
    to
  });
  if (to === 'object') return {
    contractAddress,
    chainId,
    nonce,
    ...signature
  };
  return signature;
}

const presignMessagePrefix = '\x19Ethereum Signed Message:\n';

function toPrefixedMessage(message_) {
  const message = (() => {
    if (typeof message_ === 'string') return stringToHex(message_);
    if (typeof message_.raw === 'string') return message_.raw;
    return bytesToHex$1(message_.raw);
  })();
  const prefix = stringToHex(`${presignMessagePrefix}${size(message)}`);
  return concat([prefix, message]);
}

function hashMessage(message, to_) {
  return keccak256(toPrefixedMessage(message), to_);
}

/**
 * @description Calculates an Ethereum-specific signature in [EIP-191 format](https://eips.ethereum.org/EIPS/eip-191):
 * `keccak256("\x19Ethereum Signed Message:\n" + len(message) + message))`.
 *
 * @returns The signature.
 */
async function signMessage$1(_ref) {
  let {
    message,
    privateKey
  } = _ref;
  return await sign$1({
    hash: hashMessage(message),
    privateKey,
    to: 'hex'
  });
}

async function signTransaction(parameters) {
  const {
    privateKey,
    transaction,
    serializer = serializeTransaction
  } = parameters;
  const signableTransaction = (() => {
    // For EIP-4844 Transactions, we want to sign the transaction payload body (tx_payload_body) without the sidecars (ie. without the network wrapper).
    // See: https://github.com/ethereum/EIPs/blob/e00f4daa66bd56e2dbd5f1d36d09fd613811a48b/EIPS/eip-4844.md#networking
    if (transaction.type === 'eip4844') return {
      ...transaction,
      sidecars: false
    };
    return transaction;
  })();
  const signature = await sign$1({
    hash: keccak256(serializer(signableTransaction)),
    privateKey
  });
  return serializer(transaction, signature);
}

// `bytes<M>`: binary type of `M` bytes, `0 < M <= 32`
// https://regexr.com/6va55
const bytesRegex = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/;
// `(u)int<M>`: (un)signed integer type of `M` bits, `0 < M <= 256`, `M % 8 == 0`
// https://regexr.com/6v8hp
const integerRegex = /^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;

function serializeTypedData(parameters) {
  const {
    domain: domain_,
    message: message_,
    primaryType,
    types
  } = parameters;
  const normalizeData = (struct, data_) => {
    const data = {
      ...data_
    };
    for (const param of struct) {
      const {
        name,
        type
      } = param;
      if (type === 'address') data[name] = data[name].toLowerCase();
    }
    return data;
  };
  const domain = (() => {
    if (!types.EIP712Domain) return {};
    if (!domain_) return {};
    return normalizeData(types.EIP712Domain, domain_);
  })();
  const message = (() => {
    if (primaryType === 'EIP712Domain') return undefined;
    return normalizeData(types[primaryType], message_);
  })();
  return stringify({
    domain,
    message,
    primaryType,
    types
  });
}
function validateTypedData(parameters) {
  const {
    domain,
    message,
    primaryType,
    types
  } = parameters;
  const validateData = (struct, data) => {
    for (const param of struct) {
      const {
        name,
        type
      } = param;
      const value = data[name];
      const integerMatch = type.match(integerRegex);
      if (integerMatch && (typeof value === 'number' || typeof value === 'bigint')) {
        const [_type, base, size_] = integerMatch;
        // If number cannot be cast to a sized hex value, it is out of range
        // and will throw.
        numberToHex(value, {
          signed: base === 'int',
          size: Number.parseInt(size_) / 8
        });
      }
      if (type === 'address' && typeof value === 'string' && !isAddress(value)) throw new InvalidAddressError({
        address: value
      });
      const bytesMatch = type.match(bytesRegex);
      if (bytesMatch) {
        const [_type, size_] = bytesMatch;
        if (size_ && size(value) !== Number.parseInt(size_)) throw new BytesSizeMismatchError({
          expectedSize: Number.parseInt(size_),
          givenSize: size(value)
        });
      }
      const struct = types[type];
      if (struct) validateData(struct, value);
    }
  };
  // Validate domain types.
  if (types.EIP712Domain && domain) validateData(types.EIP712Domain, domain);
  // Validate message types.
  if (primaryType !== 'EIP712Domain') validateData(types[primaryType], message);
}
function getTypesForEIP712Domain(_ref) {
  let {
    domain
  } = _ref;
  return [typeof (domain === null || domain === void 0 ? void 0 : domain.name) === 'string' && {
    name: 'name',
    type: 'string'
  }, (domain === null || domain === void 0 ? void 0 : domain.version) && {
    name: 'version',
    type: 'string'
  }, typeof (domain === null || domain === void 0 ? void 0 : domain.chainId) === 'number' && {
    name: 'chainId',
    type: 'uint256'
  }, (domain === null || domain === void 0 ? void 0 : domain.verifyingContract) && {
    name: 'verifyingContract',
    type: 'address'
  }, (domain === null || domain === void 0 ? void 0 : domain.salt) && {
    name: 'salt',
    type: 'bytes32'
  }].filter(Boolean);
}

// Implementation forked and adapted from https://github.com/MetaMask/eth-sig-util/blob/main/src/sign-typed-data.ts
function hashTypedData(parameters) {
  const {
    domain = {},
    message,
    primaryType
  } = parameters;
  const types = {
    EIP712Domain: getTypesForEIP712Domain({
      domain
    }),
    ...parameters.types
  };
  // Need to do a runtime validation check on addresses, byte ranges, integer ranges, etc
  // as we can't statically check this with TypeScript.
  validateTypedData({
    domain,
    message,
    primaryType,
    types
  });
  const parts = ['0x1901'];
  if (domain) parts.push(hashDomain({
    domain,
    types: types
  }));
  if (primaryType !== 'EIP712Domain') parts.push(hashStruct({
    data: message,
    primaryType,
    types: types
  }));
  return keccak256(concat(parts));
}
function hashDomain(_ref) {
  let {
    domain,
    types
  } = _ref;
  return hashStruct({
    data: domain,
    primaryType: 'EIP712Domain',
    types
  });
}
function hashStruct(_ref2) {
  let {
    data,
    primaryType,
    types
  } = _ref2;
  const encoded = encodeData({
    data,
    primaryType,
    types
  });
  return keccak256(encoded);
}
function encodeData(_ref3) {
  let {
    data,
    primaryType,
    types
  } = _ref3;
  const encodedTypes = [{
    type: 'bytes32'
  }];
  const encodedValues = [hashType({
    primaryType,
    types
  })];
  for (const field of types[primaryType]) {
    const [type, value] = encodeField({
      types,
      name: field.name,
      type: field.type,
      value: data[field.name]
    });
    encodedTypes.push(type);
    encodedValues.push(value);
  }
  return encodeAbiParameters(encodedTypes, encodedValues);
}
function hashType(_ref4) {
  let {
    primaryType,
    types
  } = _ref4;
  const encodedHashType = toHex(encodeType({
    primaryType,
    types
  }));
  return keccak256(encodedHashType);
}
function encodeType(_ref5) {
  let {
    primaryType,
    types
  } = _ref5;
  let result = '';
  const unsortedDeps = findTypeDependencies({
    primaryType,
    types
  });
  unsortedDeps.delete(primaryType);
  const deps = [primaryType, ...Array.from(unsortedDeps).sort()];
  for (const type of deps) {
    result += `${type}(${types[type].map(_ref6 => {
      let {
        name,
        type: t
      } = _ref6;
      return `${t} ${name}`;
    }).join(',')})`;
  }
  return result;
}
function findTypeDependencies(_ref7) {
  let {
    primaryType: primaryType_,
    types
  } = _ref7;
  let results = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Set();
  const match = primaryType_.match(/^\w*/u);
  const primaryType = match === null || match === void 0 ? void 0 : match[0];
  if (results.has(primaryType) || types[primaryType] === undefined) {
    return results;
  }
  results.add(primaryType);
  for (const field of types[primaryType]) {
    findTypeDependencies({
      primaryType: field.type,
      types
    }, results);
  }
  return results;
}
function encodeField(_ref8) {
  let {
    types,
    name,
    type,
    value
  } = _ref8;
  if (types[type] !== undefined) {
    return [{
      type: 'bytes32'
    }, keccak256(encodeData({
      data: value,
      primaryType: type,
      types
    }))];
  }
  if (type === 'bytes') {
    const prepend = value.length % 2 ? '0' : '';
    value = `0x${prepend + value.slice(2)}`;
    return [{
      type: 'bytes32'
    }, keccak256(value)];
  }
  if (type === 'string') return [{
    type: 'bytes32'
  }, keccak256(toHex(value))];
  if (type.lastIndexOf(']') === type.length - 1) {
    const parsedType = type.slice(0, type.lastIndexOf('['));
    const typeValuePairs = value.map(item => encodeField({
      name,
      type: parsedType,
      types,
      value: item
    }));
    return [{
      type: 'bytes32'
    }, keccak256(encodeAbiParameters(typeValuePairs.map(_ref9 => {
      let [t] = _ref9;
      return t;
    }), typeValuePairs.map(_ref0 => {
      let [, v] = _ref0;
      return v;
    })))];
  }
  return [{
    type
  }, value];
}

/**
 * @description Signs typed data and calculates an Ethereum-specific signature in [EIP-191 format](https://eips.ethereum.org/EIPS/eip-191):
 * `keccak256("\x19Ethereum Signed Message:\n" + len(message) + message))`.
 *
 * @returns The signature.
 */
async function signTypedData$1(parameters) {
  const {
    privateKey,
    ...typedData
  } = parameters;
  return await sign$1({
    hash: hashTypedData(typedData),
    privateKey,
    to: 'hex'
  });
}

/**
 * @description Creates an Account from a private key.
 *
 * @returns A Private Key Account.
 */
function privateKeyToAccount(privateKey) {
  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  const {
    nonceManager
  } = options;
  const publicKey = toHex(secp256k1.getPublicKey(privateKey.slice(2), false));
  const address = publicKeyToAddress(publicKey);
  const account = toAccount({
    address,
    nonceManager,
    async sign(_ref) {
      let {
        hash
      } = _ref;
      return sign$1({
        hash,
        privateKey,
        to: 'hex'
      });
    },
    async experimental_signAuthorization(authorization) {
      return experimental_signAuthorization({
        ...authorization,
        privateKey
      });
    },
    async signMessage(_ref2) {
      let {
        message
      } = _ref2;
      return signMessage$1({
        message,
        privateKey
      });
    },
    async signTransaction(transaction) {
      let {
        serializer
      } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      return signTransaction({
        privateKey,
        transaction,
        serializer
      });
    },
    async signTypedData(typedData) {
      return signTypedData$1({
        ...typedData,
        privateKey
      });
    }
  });
  return {
    ...account,
    publicKey,
    source: 'privateKey'
  };
}

/**
 * @description Converts an ECDSA private key to an address.
 *
 * @param privateKey The private key to convert.
 *
 * @returns The address.
 */
function privateKeyToAddress(privateKey) {
  const publicKey = bytesToHex$1(secp256k1.getPublicKey(privateKey.slice(2), false));
  return publicKeyToAddress(publicKey);
}

const fetch$1 = (input, init) => crossFetch(input, {
  ...(init !== null && init !== void 0 ? init : {}),
  credentials: 'credentials' in Request.prototype ? init === null || init === void 0 ? void 0 : init.credentials : undefined
});

// TODO: Not sure if still needed
var ChallengeId;
(function (ChallengeId) {
  ChallengeId["TRACK_UPLOADS"] = "u";
  ChallengeId["REFERRALS"] = "r";
  ChallengeId["VERIFIED_REFERRALS"] = "rv";
  ChallengeId["REFERRED"] = "rd";
  ChallengeId["MOBILE_INSTALL"] = "m";
  ChallengeId["CONNECT_VERIFIED_ACCOUNT"] = "v";
  ChallengeId["LISTEN_STREAK_ENDLESS"] = "e";
  ChallengeId["COMPLETE_PROFILE"] = "p";
  ChallengeId["SEND_FIRST_TIP"] = "ft";
  ChallengeId["CREATE_FIRST_PLAYLIST"] = "fp";
  ChallengeId["AUDIO_MATCHING_BUYER"] = "b";
  ChallengeId["AUDIO_MATCHING_SELLER"] = "s";
  ChallengeId["TRENDING_TRACK"] = "tt";
  ChallengeId["TRENDING_PLAYLIST"] = "tp";
  ChallengeId["TRENDING_UNDERGROUND_TRACK"] = "tut";
  ChallengeId["ONE_SHOT"] = "o";
  ChallengeId["FIRST_WEEKLY_COMMENT"] = "c";
  ChallengeId["PLAY_COUNT_250_MILESTONE_2025"] = "p1";
  ChallengeId["PLAY_COUNT_1000_MILESTONE_2025"] = "p2";
  ChallengeId["PLAY_COUNT_10000_MILESTONE_2025"] = "p3";
  ChallengeId["TASTEMAKER"] = "t";
  ChallengeId["COSIGN"] = "cs";
  ChallengeId["PINNED_COMMENT"] = "cp";
  ChallengeId["REMIX_CONTEST_WINNER"] = "w";
})(ChallengeId || (ChallengeId = {}));

const GetAttestationSchema = z.object({
  /** The user's handle. */
  handle: z.string(),
  /** The challenge identifier. As in, the challenge "name." */
  challengeId: z.nativeEnum(ChallengeId),
  /**
   * Identifier for the completed challenge instance.
   *
   * @see {@link ChallengesApi.generateSpecifier}
   */
  specifier: z.string(),
  /** The amount being claimed, in decimal wAUDIO. */
  amount: z.number()
});

class AntiAbuseOracle extends BaseAPI$1 {
  constructor(_ref) {
    let {
      antiAbuseOracleSelector
    } = _ref;
    super(new Configuration$1({
      basePath: '',
      fetchApi: fetch$1,
      middleware: [antiAbuseOracleSelector.createMiddleware()]
    }));
    _defineProperty$1(this, "antiAbuseOracleSelector", void 0);
    this.antiAbuseOracleSelector = antiAbuseOracleSelector;
  }
  async getWalletAddress() {
    const selected = await this.antiAbuseOracleSelector.getSelectedService();
    return selected.wallet;
  }
  async getChallengeAttestation(params, initOverrides) {
    const response = await this.getChallengeAttestationRaw(params, initOverrides);
    return await response.value();
  }
  async getChallengeAttestationRaw(params, initOverrides) {
    const {
      handle,
      challengeId,
      specifier,
      amount
    } = await parseParams('getChallengeAttestation', GetAttestationSchema)(params);
    const response = await this.request({
      path: `/attestation/${handle}`,
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: {
        challengeId,
        challengeSpecifier: specifier,
        amount
      }
    }, initOverrides);
    return new JSONApiResponse$1(response, json => ({
      result: exists$2(json, 'result') ? json.result : false,
      errorCode: exists$2(json, 'errorCode') ? json.errorCode : undefined
    }));
  }
}

/**
 * Extracts the path of a URL with query parameters. Platform agnostic.
 */
const getPathFromUrl = url => {
  const pathRegex = /^([a-z]+:\/\/)?(?:www\.)?([^/]+)?(.*)$/;
  const match = url.match(pathRegex);
  if (match !== null && match !== void 0 && match[3]) {
    const path = match[3];
    return path;
  } else {
    throw new Error(`Invalid URL, couldn't get path.`);
  }
};

/**
 * Polyfill for Promise.any
 * Adapted from Sergio Tskhovrebov's implementation:
 * https://dev.to/sinxwal/looking-for-promise-any-let-s-quickly-implement-a-polyfill-for-it-1kga
 */
const promiseAny = async iterable => {
  if (Promise.any) {
    return Promise.any(iterable);
  }
  return await Promise.all([...iterable].map(async promise => await new Promise((resolve, reject) => {
    Promise.resolve(promise).then(reject, resolve);
  }))).then(async errors => await Promise.reject(errors), async value => await Promise.resolve(value));
};

const getDefaultAntiAbuseOracleSelectorConfig = config => ({
  registeredAddresses: config.network.antiAbuseOracleNodes.registeredAddresses,
  endpoints: config.network.antiAbuseOracleNodes.endpoints,
  logger: new Logger()
});

class AntiAbuseOracleSelector {
  constructor(config) {
    _defineProperty$1(this, "endpoints", void 0);
    _defineProperty$1(this, "registeredAddresses", void 0);
    _defineProperty$1(this, "logger", void 0);
    _defineProperty$1(this, "selectedNode", null);
    const configWithDefaults = mergeConfigWithDefaults(config, getDefaultAntiAbuseOracleSelectorConfig(productionConfig));
    this.endpoints = configWithDefaults.endpoints;
    this.registeredAddresses = configWithDefaults.registeredAddresses;
    this.logger = configWithDefaults.logger;
  }
  createMiddleware() {
    return {
      pre: async context => {
        let url = context.url;
        if (!url.startsWith('http')) {
          const service = await this.getSelectedService();
          url = `${service.endpoint}${context.url}`;
        }
        return {
          url,
          init: context.init
        };
      },
      onError: async context => {
        // Reselect and retry on new healthy AAO
        const path = getPathFromUrl(context.url);
        this.selectedNode = null;
        const newService = await this.getSelectedService();
        // Use context.fetch to retry just once.
        return context.fetch(`${newService.endpoint}${path}`, context.init);
      }
    };
  }
  /**
   * Gets the currently selected Anti Abuse Oracle.
   * @throws if no service is available.
   */
  async getSelectedService() {
    if (!this.selectedNode) {
      this.selectedNode = await this.select();
    }
    return this.selectedNode;
  }
  /**
   * Races the configured endpoints for the fastest healthy registered service.
   * @throws if no services available.
   */
  async select() {
    try {
      return await promiseAny(this.endpoints.map(async endpoint => {
        try {
          return await this.getNode(endpoint);
        } catch (e) {
          this.logger.warn(`Anti Abuse Oracle ${endpoint} is unhealthy: ${e}`);
          throw e;
        }
      }));
    } catch (e) {
      throw new Error('All Anti Abuse Oracles are unhealthy');
    }
  }
  /**
   * Fetches the healthcheck for the given endpoint, and checks that the wallet
   * is a registered Anti Abuse Oracle wallet.
   * @returns the node wallet and endpoint if healthy
   */
  async getNode(endpoint) {
    const response = await fetch$1(`${endpoint}/health_check`);
    if (response.ok) {
      var _json$walletPubkey;
      const json = await response.json();
      const wallet = (_json$walletPubkey = json.walletPubkey) !== null && _json$walletPubkey !== void 0 ? _json$walletPubkey : json.antiAbuseWalletPubkey;
      if (!this.registeredAddresses.includes(wallet)) {
        throw new Error(`Not registered: ${wallet}`);
      }
      return {
        wallet,
        endpoint
      };
    } else {
      throw new Error(`Response failed with status ${response.status}`);
    }
  }
}

class ArchiverService extends BaseAPI$1 {
  async createStemsArchive(_ref) {
    let {
      trackId,
      userId,
      includeParent
    } = _ref;
    const response = await this.request({
      method: 'POST',
      path: `/stems/${trackId}`,
      query: {
        user_id: userId,
        include_parent: !!includeParent
      },
      headers: {}
    });
    return new JSONApiResponse$1(response).value();
  }
  async getStemsArchiveJobStatus(_ref2) {
    let {
      jobId
    } = _ref2;
    const response = await this.request({
      method: 'GET',
      path: `/stems/job/${jobId}`,
      headers: {}
    });
    return new JSONApiResponse$1(response).value();
  }
  async cancelStemsArchiveJob(_ref3) {
    let {
      jobId
    } = _ref3;
    const response = await this.request({
      method: 'DELETE',
      path: `/stems/job/${jobId}`,
      headers: {}
    });
    return new JSONApiResponse$1(response).value();
  }
}

/**
 * Returns a list of account addresses owned by the wallet or client.
 *
 * - Docs: https://viem.sh/docs/actions/wallet/getAddresses
 * - JSON-RPC Methods: [`eth_accounts`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_accounts)
 *
 * @param client - Client to use
 * @returns List of account addresses owned by the wallet or client. {@link GetAddressesReturnType}
 *
 * @example
 * import { createWalletClient, custom } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { getAddresses } from 'viem/wallet'
 *
 * const client = createWalletClient({
 *   chain: mainnet,
 *   transport: custom(window.ethereum),
 * })
 * const accounts = await getAddresses(client)
 */
async function getAddresses(client) {
  var _client$account;
  if (((_client$account = client.account) === null || _client$account === void 0 ? void 0 : _client$account.type) === 'local') return [client.account.address];
  const addresses = await client.request({
    method: 'eth_accounts'
  }, {
    dedupe: true
  });
  return addresses.map(address => checksumAddress(address));
}

/**
 * Calculates an Ethereum-specific signature in [EIP-191 format](https://eips.ethereum.org/EIPS/eip-191): `keccak256("\x19Ethereum Signed Message:\n" + len(message) + message))`.
 *
 * - Docs: https://viem.sh/docs/actions/wallet/signMessage
 * - JSON-RPC Methods:
 *   - JSON-RPC Accounts: [`personal_sign`](https://docs.metamask.io/guide/signing-data#personal-sign)
 *   - Local Accounts: Signs locally. No JSON-RPC request.
 *
 * With the calculated signature, you can:
 * - use [`verifyMessage`](https://viem.sh/docs/utilities/verifyMessage) to verify the signature,
 * - use [`recoverMessageAddress`](https://viem.sh/docs/utilities/recoverMessageAddress) to recover the signing address from a signature.
 *
 * @param client - Client to use
 * @param parameters - {@link SignMessageParameters}
 * @returns The signed message. {@link SignMessageReturnType}
 *
 * @example
 * import { createWalletClient, custom } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { signMessage } from 'viem/wallet'
 *
 * const client = createWalletClient({
 *   chain: mainnet,
 *   transport: custom(window.ethereum),
 * })
 * const signature = await signMessage(client, {
 *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
 *   message: 'hello world',
 * })
 *
 * @example
 * // Account Hoisting
 * import { createWalletClient, custom } from 'viem'
 * import { privateKeyToAccount } from 'viem/accounts'
 * import { mainnet } from 'viem/chains'
 * import { signMessage } from 'viem/wallet'
 *
 * const client = createWalletClient({
 *   account: privateKeyToAccount('0x'),
 *   chain: mainnet,
 *   transport: custom(window.ethereum),
 * })
 * const signature = await signMessage(client, {
 *   message: 'hello world',
 * })
 */
async function signMessage(client, _ref) {
  let {
    account: account_ = client.account,
    message
  } = _ref;
  if (!account_) throw new AccountNotFoundError({
    docsPath: '/docs/actions/wallet/signMessage'
  });
  const account = parseAccount(account_);
  if (account.signMessage) return account.signMessage({
    message
  });
  const message_ = (() => {
    if (typeof message === 'string') return stringToHex(message);
    if (message.raw instanceof Uint8Array) return toHex(message.raw);
    return message.raw;
  })();
  return client.request({
    method: 'personal_sign',
    params: [message_, account.address]
  }, {
    retryCount: 0
  });
}

/**
 * Signs typed data and calculates an Ethereum-specific signature in [https://eips.ethereum.org/EIPS/eip-712](https://eips.ethereum.org/EIPS/eip-712): `sign(keccak256("\x19\x01"  domainSeparator  hashStruct(message)))`
 *
 * - Docs: https://viem.sh/docs/actions/wallet/signTypedData
 * - JSON-RPC Methods:
 *   - JSON-RPC Accounts: [`eth_signTypedData_v4`](https://docs.metamask.io/guide/signing-data#signtypeddata-v4)
 *   - Local Accounts: Signs locally. No JSON-RPC request.
 *
 * @param client - Client to use
 * @param parameters - {@link SignTypedDataParameters}
 * @returns The signed data. {@link SignTypedDataReturnType}
 *
 * @example
 * import { createWalletClient, custom } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { signTypedData } from 'viem/wallet'
 *
 * const client = createWalletClient({
 *   chain: mainnet,
 *   transport: custom(window.ethereum),
 * })
 * const signature = await signTypedData(client, {
 *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
 *   domain: {
 *     name: 'Ether Mail',
 *     version: '1',
 *     chainId: 1,
 *     verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',
 *   },
 *   types: {
 *     Person: [
 *       { name: 'name', type: 'string' },
 *       { name: 'wallet', type: 'address' },
 *     ],
 *     Mail: [
 *       { name: 'from', type: 'Person' },
 *       { name: 'to', type: 'Person' },
 *       { name: 'contents', type: 'string' },
 *     ],
 *   },
 *   primaryType: 'Mail',
 *   message: {
 *     from: {
 *       name: 'Cow',
 *       wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
 *     },
 *     to: {
 *       name: 'Bob',
 *       wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
 *     },
 *     contents: 'Hello, Bob!',
 *   },
 * })
 *
 * @example
 * // Account Hoisting
 * import { createWalletClient, http } from 'viem'
 * import { privateKeyToAccount } from 'viem/accounts'
 * import { mainnet } from 'viem/chains'
 * import { signTypedData } from 'viem/wallet'
 *
 * const client = createWalletClient({
 *   account: privateKeyToAccount('0x'),
 *   chain: mainnet,
 *   transport: http(),
 * })
 * const signature = await signTypedData(client, {
 *   domain: {
 *     name: 'Ether Mail',
 *     version: '1',
 *     chainId: 1,
 *     verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',
 *   },
 *   types: {
 *     Person: [
 *       { name: 'name', type: 'string' },
 *       { name: 'wallet', type: 'address' },
 *     ],
 *     Mail: [
 *       { name: 'from', type: 'Person' },
 *       { name: 'to', type: 'Person' },
 *       { name: 'contents', type: 'string' },
 *     ],
 *   },
 *   primaryType: 'Mail',
 *   message: {
 *     from: {
 *       name: 'Cow',
 *       wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
 *     },
 *     to: {
 *       name: 'Bob',
 *       wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
 *     },
 *     contents: 'Hello, Bob!',
 *   },
 * })
 */
async function signTypedData(client, parameters) {
  const {
    account: account_ = client.account,
    domain,
    message,
    primaryType
  } = parameters;
  if (!account_) throw new AccountNotFoundError({
    docsPath: '/docs/actions/wallet/signTypedData'
  });
  const account = parseAccount(account_);
  const types = {
    EIP712Domain: getTypesForEIP712Domain({
      domain
    }),
    ...parameters.types
  };
  // Need to do a runtime validation check on addresses, byte ranges, integer ranges, etc
  // as we can't statically check this with TypeScript.
  validateTypedData({
    domain,
    message,
    primaryType,
    types
  });
  if (account.signTypedData) return account.signTypedData({
    domain,
    message,
    primaryType,
    types
  });
  const typedData = serializeTypedData({
    domain,
    message,
    primaryType,
    types
  });
  return client.request({
    method: 'eth_signTypedData_v4',
    params: [account.address, typedData]
  }, {
    retryCount: 0
  });
}

async function getSharedSecret(client, _ref) {
  let {
    account: account_ = client.account,
    publicKey
  } = _ref;
  if (!account_) throw new Error('Account not found');
  const account = typeof account_ === 'string' ? {
    address: account_,
    type: 'json-rpc'
  } : account_;
  if ('getSharedSecret' in account && account.getSharedSecret) {
    return account.getSharedSecret(publicKey);
  }
  throw new Error(`Account type '${account.type}' does not implement 'getSharedSecret' method.`);
}

async function sign(client, _ref) {
  let {
    account: account_ = client.account,
    message: message_
  } = _ref;
  if (!account_) throw new Error('Account not found');
  const account = typeof account_ === 'string' ? {
    address: account_,
    type: 'json-rpc'
  } : account_;
  const message = (() => {
    if (typeof message_ === 'string') return stringToHex(message_);
    if (message_.raw instanceof Uint8Array) return toHex(message_.raw);
    return message_.raw;
  })();
  if ('signRaw' in account && account.signRaw) {
    return account.signRaw(message);
  }
  throw new Error(`Account type '${account.type}' does not implement 'sign' method.`);
}

/**
 * A stub of a Viem transport. Used in cases where making an RPC call is unwanted,
 * which is true of most AudiusWalletClient implementations.
 */
const localTransport = () => {
  const request = async _ref => {
    let {
      method,
      params
    } = _ref;
    console.error('Local transport in use. RPC methods are not implemented.', {
      method,
      params
    });
    throw new Error(`Method '${method}' not implemented on local transport.`);
  };
  return {
    request
  };
};

function number(n) {
  if (!Number.isSafeInteger(n) || n < 0) throw new Error(`Wrong positive integer: ${n}`);
}
function bool(b) {
  if (typeof b !== 'boolean') throw new Error(`Expected boolean, not ${b}`);
}
function bytes(b) {
  if (!(b instanceof Uint8Array)) throw new TypeError('Expected Uint8Array');
  for (var _len = arguments.length, lengths = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    lengths[_key - 1] = arguments[_key];
  }
  if (lengths.length > 0 && !lengths.includes(b.length)) throw new TypeError(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);
}
function hash(hash) {
  if (typeof hash !== 'function' || typeof hash.create !== 'function') throw new Error('Hash should be wrapped by utils.wrapConstructor');
  number(hash.outputLen);
  number(hash.blockLen);
}
function exists$1(instance) {
  let checkFinished = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  if (instance.destroyed) throw new Error('Hash instance has been destroyed');
  if (checkFinished && instance.finished) throw new Error('Hash#digest() has already been called');
}
function output(out, instance) {
  bytes(out);
  const min = instance.outputLen;
  if (out.length < min) {
    throw new Error(`digestInto() expects output buffer of length at least ${min}`);
  }
}
const assert = {
  number,
  bool,
  bytes,
  hash,
  exists: exists$1,
  output
};

const U32_MASK64 = BigInt(2 ** 32 - 1);
const _32n = BigInt(32);
// We are not using BigUint64Array, because they are extremely slow as per 2022
function fromBig(n) {
  let le = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  if (le) return {
    h: Number(n & U32_MASK64),
    l: Number(n >> _32n & U32_MASK64)
  };
  return {
    h: Number(n >> _32n & U32_MASK64) | 0,
    l: Number(n & U32_MASK64) | 0
  };
}
function split(lst) {
  let le = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  let Ah = new Uint32Array(lst.length);
  let Al = new Uint32Array(lst.length);
  for (let i = 0; i < lst.length; i++) {
    const {
      h,
      l
    } = fromBig(lst[i], le);
    [Ah[i], Al[i]] = [h, l];
  }
  return [Ah, Al];
}
const toBig = (h, l) => BigInt(h >>> 0) << _32n | BigInt(l >>> 0);
// for Shift in [0, 32)
const shrSH = (h, l, s) => h >>> s;
const shrSL = (h, l, s) => h << 32 - s | l >>> s;
// Right rotate for Shift in [1, 32)
const rotrSH = (h, l, s) => h >>> s | l << 32 - s;
const rotrSL = (h, l, s) => h << 32 - s | l >>> s;
// Right rotate for Shift in (32, 64), NOTE: 32 is special case.
const rotrBH = (h, l, s) => h << 64 - s | l >>> s - 32;
const rotrBL = (h, l, s) => h >>> s - 32 | l << 64 - s;
// Right rotate for shift===32 (just swaps l&h)
const rotr32H = (h, l) => l;
const rotr32L = (h, l) => h;
// Left rotate for Shift in [1, 32)
const rotlSH = (h, l, s) => h << s | l >>> 32 - s;
const rotlSL = (h, l, s) => l << s | h >>> 32 - s;
// Left rotate for Shift in (32, 64), NOTE: 32 is special case.
const rotlBH = (h, l, s) => l << s - 32 | h >>> 64 - s;
const rotlBL = (h, l, s) => h << s - 32 | l >>> 64 - s;
// JS uses 32-bit signed integers for bitwise operations which means we cannot
// simple take carry out of low bit sum by shift, we need to use division.
// Removing "export" has 5% perf penalty -_-
function add(Ah, Al, Bh, Bl) {
  const l = (Al >>> 0) + (Bl >>> 0);
  return {
    h: Ah + Bh + (l / 2 ** 32 | 0) | 0,
    l: l | 0
  };
}
// Addition with more than 2 elements
const add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
const add3H = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
const add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
const add4H = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
const add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
const add5H = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
// prettier-ignore
const u64 = {
  fromBig,
  split,
  toBig,
  shrSH,
  shrSL,
  rotrSH,
  rotrSL,
  rotrBH,
  rotrBL,
  rotr32H,
  rotr32L,
  rotlSH,
  rotlSL,
  rotlBH,
  rotlBL,
  add,
  add3L,
  add3H,
  add4L,
  add4H,
  add5H,
  add5L
};

/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const u32 = arr => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
// Cast array to view
const createView = arr => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
// The rotate right (circular right shift) operation for uint32
const rotr = (word, shift) => word << 32 - shift | word >>> shift;
// big-endian hardware is rare. Just in case someone still decides to run hashes:
// early-throw an error because we don't support BE yet.
const isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;
if (!isLE) throw new Error('Non little-endian hardware is not supported');
Array.from({
  length: 256
}, (v, i) => i.toString(16).padStart(2, '0'));
function utf8ToBytes(str) {
  if (typeof str !== 'string') {
    throw new TypeError(`utf8ToBytes expected string, got ${typeof str}`);
  }
  return new TextEncoder().encode(str);
}
function toBytes(data) {
  if (typeof data === 'string') data = utf8ToBytes(data);
  if (!(data instanceof Uint8Array)) throw new TypeError(`Expected input type is Uint8Array (got ${typeof data})`);
  return data;
}
// For runtime check if class implements interface
class Hash {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
}
function wrapConstructor(hashConstructor) {
  const hashC = message => hashConstructor().update(toBytes(message)).digest();
  const tmp = hashConstructor();
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = () => hashConstructor();
  return hashC;
}
function wrapConstructorWithOpts(hashCons) {
  const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
  const tmp = hashCons({});
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = opts => hashCons(opts);
  return hashC;
}

// Various per round constants calculations
const [SHA3_PI, SHA3_ROTL, _SHA3_IOTA] = [[], [], []];
const _0n = BigInt(0);
const _1n = BigInt(1);
const _2n = BigInt(2);
const _7n = BigInt(7);
const _256n = BigInt(256);
const _0x71n = BigInt(0x71);
for (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {
  // Pi
  [x, y] = [y, (2 * x + 3 * y) % 5];
  SHA3_PI.push(2 * (5 * y + x));
  // Rotational
  SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);
  // Iota
  let t = _0n;
  for (let j = 0; j < 7; j++) {
    R = (R << _1n ^ (R >> _7n) * _0x71n) % _256n;
    if (R & _2n) t ^= _1n << (_1n << BigInt(j)) - _1n;
  }
  _SHA3_IOTA.push(t);
}
const [SHA3_IOTA_H, SHA3_IOTA_L] = u64.split(_SHA3_IOTA, true);
// Left rotation (without 0, 32, 64)
const rotlH = (h, l, s) => s > 32 ? u64.rotlBH(h, l, s) : u64.rotlSH(h, l, s);
const rotlL = (h, l, s) => s > 32 ? u64.rotlBL(h, l, s) : u64.rotlSL(h, l, s);
// Same as keccakf1600, but allows to skip some rounds
function keccakP(s) {
  let rounds = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 24;
  const B = new Uint32Array(5 * 2);
  // NOTE: all indices are x2 since we store state as u32 instead of u64 (bigints to slow in js)
  for (let round = 24 - rounds; round < 24; round++) {
    // Theta 
    for (let x = 0; x < 10; x++) B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
    for (let x = 0; x < 10; x += 2) {
      const idx1 = (x + 8) % 10;
      const idx0 = (x + 2) % 10;
      const B0 = B[idx0];
      const B1 = B[idx0 + 1];
      const Th = rotlH(B0, B1, 1) ^ B[idx1];
      const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];
      for (let y = 0; y < 50; y += 10) {
        s[x + y] ^= Th;
        s[x + y + 1] ^= Tl;
      }
    }
    // Rho () and Pi ()
    let curH = s[2];
    let curL = s[3];
    for (let t = 0; t < 24; t++) {
      const shift = SHA3_ROTL[t];
      const Th = rotlH(curH, curL, shift);
      const Tl = rotlL(curH, curL, shift);
      const PI = SHA3_PI[t];
      curH = s[PI];
      curL = s[PI + 1];
      s[PI] = Th;
      s[PI + 1] = Tl;
    }
    // Chi ()
    for (let y = 0; y < 50; y += 10) {
      for (let x = 0; x < 10; x++) B[x] = s[y + x];
      for (let x = 0; x < 10; x++) s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
    }
    // Iota ()
    s[0] ^= SHA3_IOTA_H[round];
    s[1] ^= SHA3_IOTA_L[round];
  }
  B.fill(0);
}
class Keccak extends Hash {
  // NOTE: we accept arguments in bytes instead of bits here.
  constructor(blockLen, suffix, outputLen) {
    let enableXOF = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
    let rounds = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 24;
    super();
    this.blockLen = blockLen;
    this.suffix = suffix;
    this.outputLen = outputLen;
    this.enableXOF = enableXOF;
    this.rounds = rounds;
    this.pos = 0;
    this.posOut = 0;
    this.finished = false;
    this.destroyed = false;
    // Can be passed from user as dkLen
    assert.number(outputLen);
    // 1600 = 5x5 matrix of 64bit.  1600 bits === 200 bytes
    if (0 >= this.blockLen || this.blockLen >= 200) throw new Error('Sha3 supports only keccak-f1600 function');
    this.state = new Uint8Array(200);
    this.state32 = u32(this.state);
  }
  keccak() {
    keccakP(this.state32, this.rounds);
    this.posOut = 0;
    this.pos = 0;
  }
  update(data) {
    assert.exists(this);
    const {
      blockLen,
      state
    } = this;
    data = toBytes(data);
    const len = data.length;
    for (let pos = 0; pos < len;) {
      const take = Math.min(blockLen - this.pos, len - pos);
      for (let i = 0; i < take; i++) state[this.pos++] ^= data[pos++];
      if (this.pos === blockLen) this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished) return;
    this.finished = true;
    const {
      state,
      suffix,
      pos,
      blockLen
    } = this;
    // Do the padding
    state[pos] ^= suffix;
    if ((suffix & 0x80) !== 0 && pos === blockLen - 1) this.keccak();
    state[blockLen - 1] ^= 0x80;
    this.keccak();
  }
  writeInto(out) {
    assert.exists(this, false);
    assert.bytes(out);
    this.finish();
    const bufferOut = this.state;
    const {
      blockLen
    } = this;
    for (let pos = 0, len = out.length; pos < len;) {
      if (this.posOut >= blockLen) this.keccak();
      const take = Math.min(blockLen - this.posOut, len - pos);
      out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
      this.posOut += take;
      pos += take;
    }
    return out;
  }
  xofInto(out) {
    // Sha3/Keccak usage with XOF is probably mistake, only SHAKE instances can do XOF
    if (!this.enableXOF) throw new Error('XOF is not possible for this instance');
    return this.writeInto(out);
  }
  xof(bytes) {
    assert.number(bytes);
    return this.xofInto(new Uint8Array(bytes));
  }
  digestInto(out) {
    assert.output(out, this);
    if (this.finished) throw new Error('digest() was already called');
    this.writeInto(out);
    this.destroy();
    return out;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = true;
    this.state.fill(0);
  }
  _cloneInto(to) {
    const {
      blockLen,
      suffix,
      outputLen,
      rounds,
      enableXOF
    } = this;
    to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
    to.state32.set(this.state32);
    to.pos = this.pos;
    to.posOut = this.posOut;
    to.finished = this.finished;
    to.rounds = rounds;
    // Suffix can change in cSHAKE
    to.suffix = suffix;
    to.outputLen = outputLen;
    to.enableXOF = enableXOF;
    to.destroyed = this.destroyed;
    return to;
  }
}
const gen = (suffix, blockLen, outputLen) => wrapConstructor(() => new Keccak(blockLen, suffix, outputLen));
gen(0x06, 144, 224 / 8);
/**
 * SHA3-256 hash function
 * @param message - that would be hashed
 */
gen(0x06, 136, 256 / 8);
gen(0x06, 104, 384 / 8);
gen(0x06, 72, 512 / 8);
gen(0x01, 144, 224 / 8);
/**
 * keccak-256 hash function. Different from SHA3-256.
 * @param message - that would be hashed
 */
const keccak_256 = gen(0x01, 136, 256 / 8);
gen(0x01, 104, 384 / 8);
gen(0x01, 72, 512 / 8);
const genShake = (suffix, blockLen, outputLen) => wrapConstructorWithOpts(function () {
  let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return new Keccak(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true);
});
genShake(0x1f, 168, 128 / 8);
genShake(0x1f, 136, 256 / 8);

/**
 * Creates a Viem account that has sign and getSharedSecret capability from a private key.
 */
function privateKeyToAudiusAccount(privateKey) {
  const privateKeyAccount = privateKeyToAccount(privateKey);
  return {
    ...privateKeyAccount,
    source: 'custom',
    getSharedSecret: async publicKey => {
      return secp256k1$1.getSharedSecret(hexToBytes$2(privateKey), publicKey, true);
    },
    signRaw: async data => {
      return secp256k1$1.sign(keccak_256(hexToBytes$2(data)), hexToBytes$2(privateKey), {
        recovered: true,
        der: false
      });
    }
  };
}

class HedgehogWalletNotFoundError extends Error {
  constructor() {
    super('Hedgehog wallet not found. Is the user logged in?');
  }
}
/**
 * Creates a Viem client that uses a local Hedgehog instance to do all the wallet methods.
 */
function createHedgehogWalletClient(hedgehog) {
  // Gets the local privateKeyAccount for the Hedgehog wallet.
  // Unfortunately, Hedgehog loads the wallet asynchronously from storage,
  // so we can't have the account already initialized on start.
  let account_;
  const getAccount = async () => {
    await hedgehog.waitUntilReady();
    const wallet = hedgehog.getWallet();
    if (!wallet) {
      throw new HedgehogWalletNotFoundError();
    }
    if (!account_ || account_.address !== wallet.getAddressString()) {
      account_ = privateKeyToAudiusAccount(wallet.getPrivateKeyString());
    }
    return account_;
  };
  // Init the client as though we have an account
  const client = createClient({
    name: 'hedgehog',
    type: 'audius',
    transport: custom(localTransport())
  });
  // Set the account lazily, without making this method async
  getAccount().then(account => {
    client.account = account;
  }).catch(e => {
    if (e instanceof HedgehogWalletNotFoundError) {
      // Do nothing - to be expected if the user is not logged in yet.
      // Throw only if they actually try to do something without a wallet.
      return;
    }
    throw e;
  });
  // Custom implements each action to inject the account asynchronously, since
  // Hedgehog needs to make the async calls to storage to restore wallets.
  return client.extend(client => ({
    getAddresses: async () => {
      client.account = await getAccount();
      return getAddresses(client);
    },
    sign: async args => {
      client.account = await getAccount();
      return sign(client, args);
    },
    signMessage: async args => {
      client.account = await getAccount();
      return signMessage(client, args);
    },
    signTypedData: async args => {
      client.account = await getAccount();
      return signTypedData(client, args);
    },
    getSharedSecret: async args => {
      client.account = await getAccount();
      return getSharedSecret(client, args);
    }
  }));
}

function audiusWalletActions(client) {
  return {
    getAddresses: async () => getAddresses(client),
    sign: args => sign(client, args),
    signMessage: args => signMessage(client, args),
    signTypedData: args => signTypedData(client, args),
    getSharedSecret: args => getSharedSecret(client, args)
  };
}

const ensureHex = str => str.startsWith('0x') ? str : `0x${str}`;
const createAppWalletClient = _ref => {
  let {
    apiKey,
    apiSecret
  } = _ref;
  if (apiSecret) {
    return createClient({
      name: 'Audius App',
      type: 'audius',
      account: privateKeyToAudiusAccount(ensureHex(apiSecret)),
      transport: custom(localTransport())
    }).extend(audiusWalletActions);
  } else {
    return createClient({
      name: 'Audius Readonly App',
      type: 'audius',
      account: {
        address: ensureHex(apiKey),
        type: 'local'
      },
      transport: custom(localTransport())
    }).extend(audiusWalletActions);
  }
};

/**
 * This file includes schemas for use in EIP-712 compliant signature generation and
 * signature validation, generator functions for generating data
 * in the form needed by eth_personalSign / eth-sig-util's signTypedData functions,
 * generators for contract signing domains, and a helper function for generating
 * cryptographically secure nonces in nodejs or in the browser.
 * modeled off: https://github.com/ethereum/EIPs/blob/master/EIPS/eip-712.md
 */
const getNonce = async () => {
  return '0x' + bytesToHex$2(randomBytes(32));
};

const abi = [{
  constant: true,
  inputs: [{
    name: '',
    type: 'bytes32'
  }],
  name: 'usedSignatures',
  outputs: [{
    name: '',
    type: 'bool'
  }],
  payable: false,
  stateMutability: 'view',
  type: 'function'
}, {
  anonymous: false,
  inputs: [{
    indexed: false,
    name: '_userId',
    type: 'uint256'
  }, {
    indexed: false,
    name: '_signer',
    type: 'address'
  }, {
    indexed: false,
    name: '_entityType',
    type: 'string'
  }, {
    indexed: false,
    name: '_entityId',
    type: 'uint256'
  }, {
    indexed: false,
    name: '_metadata',
    type: 'string'
  }, {
    indexed: false,
    name: '_action',
    type: 'string'
  }],
  name: 'ManageEntity',
  type: 'event'
}, {
  anonymous: false,
  inputs: [{
    indexed: false,
    name: '_userId',
    type: 'uint256'
  }, {
    indexed: false,
    name: '_isVerified',
    type: 'bool'
  }],
  name: 'ManageIsVerified',
  type: 'event'
}, {
  constant: false,
  inputs: [{
    name: 'name',
    type: 'string'
  }, {
    name: 'version',
    type: 'string'
  }, {
    name: 'chainId',
    type: 'uint256'
  }],
  name: 'initialize',
  outputs: [],
  payable: false,
  stateMutability: 'nonpayable',
  type: 'function'
}, {
  constant: false,
  inputs: [{
    name: '_verifierAddress',
    type: 'address'
  }, {
    name: '_networkId',
    type: 'uint256'
  }],
  name: 'initialize',
  outputs: [],
  payable: false,
  stateMutability: 'nonpayable',
  type: 'function'
}, {
  constant: false,
  inputs: [{
    name: '_userId',
    type: 'uint256'
  }, {
    name: '_entityType',
    type: 'string'
  }, {
    name: '_entityId',
    type: 'uint256'
  }, {
    name: '_action',
    type: 'string'
  }, {
    name: '_metadata',
    type: 'string'
  }, {
    name: '_nonce',
    type: 'bytes32'
  }, {
    name: '_subjectSig',
    type: 'bytes'
  }],
  name: 'manageEntity',
  outputs: [],
  payable: false,
  stateMutability: 'nonpayable',
  type: 'function'
}, {
  constant: false,
  inputs: [{
    name: '_userId',
    type: 'uint256'
  }, {
    name: '_isVerified',
    type: 'bool'
  }],
  name: 'manageIsVerified',
  outputs: [],
  payable: false,
  stateMutability: 'nonpayable',
  type: 'function'
}];

class EntityManager {}
_defineProperty$1(EntityManager, "abi", abi);
_defineProperty$1(EntityManager, "types", {
  EIP712Domain: [{
    name: 'name',
    type: 'string'
  }, {
    name: 'version',
    type: 'string'
  }, {
    name: 'chainId',
    type: 'uint256'
  }, {
    name: 'verifyingContract',
    type: 'address'
  }],
  // NOTE: Need to update "uint" to "uint32" ("uint" isn't a thing).
  // Can't do so now because would break signature recovery on relay
  // and in indexing.
  ManageEntity: [{
    name: 'userId',
    type: 'uint'
  }, {
    name: 'entityType',
    type: 'string'
  }, {
    name: 'entityId',
    type: 'uint'
  }, {
    name: 'action',
    type: 'string'
  }, {
    name: 'metadata',
    type: 'string'
  }, {
    name: 'nonce',
    type: 'bytes32'
  }]
});

const getDefaultEntityManagerConfig = config => ({
  contractAddress: config.acdc.entityManagerContractAddress,
  chainId: config.acdc.chainId,
  endpoint: config.network.apiEndpoint,
  logger: new Logger()
});

const DEFAULT_GAS_LIMIT = 2000000;
const CONFIRMATION_POLLING_INTERVAL = 2000;
const CONFIRMATION_TIMEOUT = 45000;
class EntityManagerClient {
  constructor(config_) {
    _defineProperty$1(this, "audiusWalletClient", void 0);
    _defineProperty$1(this, "logger", void 0);
    _defineProperty$1(this, "chainId", void 0);
    _defineProperty$1(this, "contractAddress", void 0);
    _defineProperty$1(this, "endpoint", void 0);
    const config = mergeConfigWithDefaults(config_, getDefaultEntityManagerConfig(productionConfig));
    this.audiusWalletClient = config.audiusWalletClient;
    this.chainId = config.chainId;
    this.contractAddress = config.contractAddress;
    this.logger = config.logger.createPrefixedLogger('[entity-manager]');
    this.endpoint = config.endpoint;
  }
  /**
   * Calls the manage entity method on chain to update some data
   */
  async manageEntity(_ref) {
    let {
      userId,
      entityType,
      entityId,
      action,
      metadata = '',
      confirmationTimeout = CONFIRMATION_TIMEOUT,
      skipConfirmation = false
    } = _ref;
    const nonce = await getNonce();
    const typedData = {
      domain: this.getDomain(),
      primaryType: 'ManageEntity',
      message: {
        // TODO: Strictly check callsites to ensure userId always passed in
        // @ts-ignore Need to update this type to "uint32" instead of "uint"
        userId: userId,
        entityType,
        // @ts-ignore Need to update this type to "uint32" instead of "uint"
        entityId,
        action,
        metadata,
        nonce
      },
      types: EntityManager.types
    };
    const [senderAddress] = await this.audiusWalletClient.getAddresses();
    const signature = await this.audiusWalletClient.signTypedData(typedData);
    const url = `${this.endpoint}/relay`;
    this.logger.info(`Making relay request to ${url}`);
    const response = await fetch$1(url, {
      method: 'POST',
      headers: new Headers({
        'Content-Type': 'application/json'
      }),
      body: JSON.stringify({
        contractAddress: this.contractAddress,
        contractRegistryKey: 'EntityManager',
        encodedABI: encodeFunctionData({
          abi: EntityManager.abi,
          args: [BigInt(userId), entityType, BigInt(entityId), action, metadata, nonce, signature],
          functionName: 'manageEntity'
        }),
        // Gas limit not really needed with ACDC
        gasLimit: DEFAULT_GAS_LIMIT,
        senderAddress
      })
    });
    if (response.ok) {
      const jsonResponse = await response.json();
      if (!skipConfirmation) {
        await this.confirmWrite({
          blockHash: jsonResponse.receipt.blockHash,
          blockNumber: jsonResponse.receipt.blockNumber,
          confirmationTimeout
        });
      }
      return {
        blockHash: jsonResponse.receipt.blockHash,
        blockNumber: jsonResponse.receipt.blockNumber
      };
    } else {
      if (response.status === 429) {
        this.logger.error('API Rate Limit Exceeded: You have exceeded the allowed number of requests for this action. Please wait and try again later. If you require a higher rate limit, please send an email to api@audius.co with your request, detailing the reasons and expected usage.');
      }
      throw new ResponseError$1(response, 'Response returned an error code');
    }
  }
  /**
   * Confirms a write by polling for the block to be indexed by API
   */
  async confirmWrite(_ref2) {
    let {
      blockHash,
      blockNumber,
      confirmationTimeout = CONFIRMATION_TIMEOUT,
      confirmationPollingInterval = CONFIRMATION_POLLING_INTERVAL
    } = _ref2;
    this.logger.info(`Confirming write ${blockHash} ${blockNumber}`);
    const confirmBlock = async () => {
      const url = `${this.endpoint}/block_confirmation?blocknumber=${blockNumber}&blockhash=${blockHash}`;
      const {
        data: {
          block_passed
        }
      } = await (await fetch$1(url)).json();
      return block_passed ? BlockConfirmation.CONFIRMED : BlockConfirmation.UNKNOWN;
    };
    let confirmation = await confirmBlock();
    const start = Date.now();
    while (confirmation === BlockConfirmation.UNKNOWN) {
      if (Date.now() - start > confirmationTimeout) {
        throw new Error(`Could not confirm write within ${confirmationTimeout}ms`);
      }
      await new Promise(resolve => setTimeout(resolve, confirmationPollingInterval));
      confirmation = await confirmBlock();
    }
    this.logger.info('Write confirmed');
    return true;
  }
  /**
   * Decodes the manage entity function data
   * @param data - The encoded function data
   * @returns The decoded function data
   */
  decodeManageEntity(data) {
    const decodedAbi = decodeFunctionData({
      abi: EntityManager.abi,
      data
    });
    if (decodedAbi.functionName !== 'manageEntity') {
      throw new Error('Expected manageEntity function');
    }
    const [userId, entityType, entityId, action, metadata, nonce, subjectSig] = decodedAbi.args;
    if (!userId || !entityType ||
    // 0 is a valid entityId for some actions
    !entityId && entityId !== BigInt(0) || !action ||
    // Empty string is valid metadata for some actions
    !metadata && metadata !== '' || !nonce || !subjectSig) {
      throw new Error('Missing complete manageEntity function data');
    }
    return {
      userId,
      entityType: entityType,
      entityId,
      action: action,
      metadata,
      nonce,
      subjectSig
    };
  }
  /**
   * Gets the domain used for proxy signing for the entity manager
   * @returns The domain object
   */
  getDomain() {
    return {
      name: 'Entity Manager',
      chainId: BigInt(this.chainId),
      version: '1',
      verifyingContract: this.contractAddress
    };
  }
  /**
   * Recovers the signer address from the encoded ABI
   * @param encodedABI - The encoded ABI
   * @returns The recovered signer address
   */
  async recoverSigner(encodedABI) {
    const decodedAbi = this.decodeManageEntity(encodedABI);
    const {
      userId,
      entityType,
      entityId,
      action,
      metadata,
      nonce,
      subjectSig
    } = decodedAbi;
    return await recoverTypedDataAddress({
      domain: this.getDomain(),
      primaryType: 'ManageEntity',
      message: {
        // @ts-ignore Need to update this type to "uint32" instead of "uint"
        userId: Number(userId),
        entityType,
        // @ts-ignore Need to update this type to "uint32" instead of "uint"
        entityId: Number(entityId),
        action,
        metadata,
        nonce
      },
      types: EntityManager.types,
      signature: subjectSig
    });
  }
}

const wait = async milliseconds => {
  return await new Promise(resolve => setTimeout(resolve, milliseconds));
};

const getDefaultStorageServiceConfig = _config => ({
  logger: new Logger()
});

const MAX_TRACK_TRANSCODE_TIMEOUT = 3600000; // 1 hour
const MAX_TRACK_TRANSCODE_NO_PROGRESS_TIMEOUT = 600000; // 10 minutes
const MAX_IMAGE_RESIZE_TIMEOUT_MS = 300000; // 5 minutes
const POLL_STATUS_INTERVAL = 3000; // 3s
class Storage {
  constructor(config) {
    /**
     * Configuration passed in by consumer (with defaults)
     */
    _defineProperty$1(this, "config", void 0);
    _defineProperty$1(this, "storageNodeSelector", void 0);
    _defineProperty$1(this, "logger", void 0);
    this.config = mergeConfigWithDefaults(config, getDefaultStorageServiceConfig());
    this.storageNodeSelector = config.storageNodeSelector;
    this.logger = this.config.logger.createPrefixedLogger('[storage]');
  }
  /**
   * Upload a file to a content node
   * @param file
   * @param onProgress
   * @param template
   * @param options
   * @returns
   */
  async uploadFile(_ref) {
    var _file$name, _response2, _response2$data;
    let {
      file,
      onProgress,
      template,
      options = {}
    } = _ref;
    const formData = new FormData$1();
    formData.append('template', template);
    Object.keys(options).forEach(key => {
      formData.append(key, `${options[key]}`);
    });
    const formDataFile = 'uri' in file ? {
      ...file,
      // NOTE this is required for react-native
      // certain characters in the file name make formData invalid
      name: file.name ? encodeURIComponent(file.name.replace(/[()]/g, '')) : 'blob'
    } : file;
    formData.append('files', isNodeFile(formDataFile) ? formDataFile.buffer : formDataFile, (_file$name = file.name) !== null && _file$name !== void 0 ? _file$name : 'blob');
    // Using axios for now because it supports upload progress,
    // and Node doesn't support XmlHttpRequest
    let response = null;
    const request = {
      method: 'post',
      maxContentLength: Infinity,
      data: formData,
      headers: {
        ...(formData.getBoundary ? {
          'Content-Type': `multipart/form-data; boundary=${formData.getBoundary()}`
        } : undefined)
      },
      onUploadProgress: progressEvent => {
        const progress = {
          upload: {
            loaded: progressEvent.loaded,
            total: progressEvent.total
          }
        };
        onProgress === null || onProgress === void 0 ? void 0 : onProgress(template === 'audio' ? {
          audio: progress
        } : {
          art: progress
        });
      }
    };
    let lastErr;
    for (let selectedNode = await this.storageNodeSelector.getSelectedNode(); !this.storageNodeSelector.triedSelectingAllNodes(); selectedNode = await this.storageNodeSelector.getSelectedNode(true)) {
      request.url = `${selectedNode}/uploads`;
      try {
        var _response, _response$data;
        response = await axios(request);
        // Server will sometimes return empty array in case of error
        if (((_response = response) === null || _response === void 0 ? void 0 : (_response$data = _response.data) === null || _response$data === void 0 ? void 0 : _response$data.length) > 0) {
          break;
        }
      } catch (e) {
        lastErr = e; // keep trying other nodes
      }
    }
    // Covers no response or empty response
    if (!((_response2 = response) !== null && _response2 !== void 0 && (_response2$data = _response2.data) !== null && _response2$data !== void 0 && _response2$data.length)) {
      const msg = `Error sending storagev2 upload request, tried all healthy storage nodes. Last error: ${lastErr}`;
      this.logger.error(msg);
      throw new Error(msg);
    }
    return await this.pollProcessingStatus(response.data[0].id, template, onProgress);
  }
  /**
   * Generates a preview for a track at the given second offset
   * @param {Object} params
   * @param {string} params.cid - The CID of the track to generate a preview for
   * @param {number} params.secondOffset - The offset in seconds to start the preview from
   * @returns {Promise<string>} The CID of the generated preview
   */
  async generatePreview(_ref2) {
    let {
      cid,
      secondOffset
    } = _ref2;
    const contentNodeEndpoint = await this.storageNodeSelector.getSelectedNode();
    if (!contentNodeEndpoint) {
      throw new Error('No content node available');
    }
    const response = await axios({
      method: 'post',
      url: `${contentNodeEndpoint}/generate_preview/${cid}/${secondOffset}`
    });
    return response.data.cid;
  }
  /**
   * Works for both track transcode and image resize jobs
   * @param id ID of the transcode/resize job
   * @param maxPollingMs millis to stop polling and error if job is not done
   * @returns successful job info, or throws error if job fails / times out
   */
  async pollProcessingStatus(id, template, onProgress) {
    const start = Date.now();
    let lastProgressUpdate = Date.now();
    let lastTranscodeProgress = 0;
    const maxPollingMs = template === 'audio' ? MAX_TRACK_TRANSCODE_TIMEOUT : MAX_IMAGE_RESIZE_TIMEOUT_MS;
    while (Date.now() - start < maxPollingMs) {
      try {
        const resp = await this.getProcessingStatus(id);
        if (template === 'audio' && resp.transcode_progress) {
          // Only update lastProgressUpdate if the progress has increased
          if (resp.transcode_progress > lastTranscodeProgress) {
            lastProgressUpdate = Date.now();
            lastTranscodeProgress = resp.transcode_progress;
          } else if (Date.now() - lastProgressUpdate > MAX_TRACK_TRANSCODE_NO_PROGRESS_TIMEOUT) {
            throw new Error(`No transcoding progress increase for ${MAX_TRACK_TRANSCODE_NO_PROGRESS_TIMEOUT}ms. Progress stuck at ${lastTranscodeProgress}. id=${id}`);
          }
          onProgress === null || onProgress === void 0 ? void 0 : onProgress({
            audio: {
              transcode: {
                decimal: resp.transcode_progress
              }
            }
          });
        }
        if ((resp === null || resp === void 0 ? void 0 : resp.status) === 'done') {
          return resp;
        }
        if ((resp === null || resp === void 0 ? void 0 : resp.status) === 'error' || (resp === null || resp === void 0 ? void 0 : resp.status) === 'error_retranscode_preview') {
          throw new Error(`Upload failed: id=${id}, resp=${JSON.stringify(resp)}`);
        }
      } catch (e) {
        var _e$message, _e$message2, _e$response;
        // Rethrow if error is "Upload failed", stalled, or if status code is 422 (Unprocessable Entity)
        if ((_e$message = e.message) !== null && _e$message !== void 0 && _e$message.startsWith('Upload failed') || (_e$message2 = e.message) !== null && _e$message2 !== void 0 && _e$message2.startsWith('No transcoding progress increase') || e.response && ((_e$response = e.response) === null || _e$response === void 0 ? void 0 : _e$response.status) === 422) {
          throw e;
        }
        // Swallow errors caused by failure to establish connection to node so we can retry polling
        this.logger.error(`Failed to poll for processing status, ${e}`);
      }
      await wait(POLL_STATUS_INTERVAL);
    }
    throw new Error(`Upload took over ${maxPollingMs}ms. id=${id}`);
  }
  /**
   * Gets the task progress given the task type and id associated with the job
   * @param id the id of the transcoding or resizing job
   * @returns the status, and the success or failed response if the job is complete
   */
  async getProcessingStatus(id) {
    let lastErr;
    for (let selectedNode = await this.storageNodeSelector.getSelectedNode(); !this.storageNodeSelector.triedSelectingAllNodes(); selectedNode = await this.storageNodeSelector.getSelectedNode(true)) {
      try {
        const response = await fetch$1(`${selectedNode}/uploads/${id}`);
        if (response.ok) {
          return await response.json();
        } else {
          lastErr = `HTTP error: ${response.status} ${response.statusText}, ${await response.text()}`;
        }
      } catch (e) {
        lastErr = e;
      }
    }
    const msg = `Error sending storagev2 uploads polling request, tried all healthy storage nodes. Last error: ${lastErr}`;
    this.logger.error(msg);
    throw new Error(msg);
  }
}

// Polyfill for Safari 14
function setBigUint64(view, byteOffset, value, isLE) {
  if (typeof view.setBigUint64 === 'function') return view.setBigUint64(byteOffset, value, isLE);
  const _32n = BigInt(32);
  const _u32_max = BigInt(0xffffffff);
  const wh = Number(value >> _32n & _u32_max);
  const wl = Number(value & _u32_max);
  const h = isLE ? 4 : 0;
  const l = isLE ? 0 : 4;
  view.setUint32(byteOffset + h, wh, isLE);
  view.setUint32(byteOffset + l, wl, isLE);
}
// Base SHA2 class (RFC 6234)
class SHA2 extends Hash {
  constructor(blockLen, outputLen, padOffset, isLE) {
    super();
    this.blockLen = blockLen;
    this.outputLen = outputLen;
    this.padOffset = padOffset;
    this.isLE = isLE;
    this.finished = false;
    this.length = 0;
    this.pos = 0;
    this.destroyed = false;
    this.buffer = new Uint8Array(blockLen);
    this.view = createView(this.buffer);
  }
  update(data) {
    assert.exists(this);
    const {
      view,
      buffer,
      blockLen
    } = this;
    data = toBytes(data);
    const len = data.length;
    for (let pos = 0; pos < len;) {
      const take = Math.min(blockLen - this.pos, len - pos);
      // Fast path: we have at least one block in input, cast it to view and process
      if (take === blockLen) {
        const dataView = createView(data);
        for (; blockLen <= len - pos; pos += blockLen) this.process(dataView, pos);
        continue;
      }
      buffer.set(data.subarray(pos, pos + take), this.pos);
      this.pos += take;
      pos += take;
      if (this.pos === blockLen) {
        this.process(view, 0);
        this.pos = 0;
      }
    }
    this.length += data.length;
    this.roundClean();
    return this;
  }
  digestInto(out) {
    assert.exists(this);
    assert.output(out, this);
    this.finished = true;
    // Padding
    // We can avoid allocation of buffer for padding completely if it
    // was previously not allocated here. But it won't change performance.
    const {
      buffer,
      view,
      blockLen,
      isLE
    } = this;
    let {
      pos
    } = this;
    // append the bit '1' to the message
    buffer[pos++] = 0b10000000;
    this.buffer.subarray(pos).fill(0);
    // we have less than padOffset left in buffer, so we cannot put length in current block, need process it and pad again
    if (this.padOffset > blockLen - pos) {
      this.process(view, 0);
      pos = 0;
    }
    // Pad until full block byte with zeros
    for (let i = pos; i < blockLen; i++) buffer[i] = 0;
    // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that
    // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.
    // So we just write lowest 64 bits of that value.
    setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
    this.process(view, 0);
    const oview = createView(out);
    const len = this.outputLen;
    // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT
    if (len % 4) throw new Error('_sha2: outputLen should be aligned to 32bit');
    const outLen = len / 4;
    const state = this.get();
    if (outLen > state.length) throw new Error('_sha2: outputLen bigger than state');
    for (let i = 0; i < outLen; i++) oview.setUint32(4 * i, state[i], isLE);
  }
  digest() {
    const {
      buffer,
      outputLen
    } = this;
    this.digestInto(buffer);
    const res = buffer.slice(0, outputLen);
    this.destroy();
    return res;
  }
  _cloneInto(to) {
    to || (to = new this.constructor());
    to.set(...this.get());
    const {
      blockLen,
      buffer,
      length,
      finished,
      destroyed,
      pos
    } = this;
    to.length = length;
    to.pos = pos;
    to.finished = finished;
    to.destroyed = destroyed;
    if (length % blockLen) to.buffer.set(buffer);
    return to;
  }
}

// Choice: a ? b : c
const Chi = (a, b, c) => a & b ^ ~a & c;
// Majority function, true if any two inpust is true
const Maj = (a, b, c) => a & b ^ a & c ^ b & c;
// Round constants:
// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)
// prettier-ignore
const SHA256_K = new Uint32Array([0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2]);
// Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):
// prettier-ignore
const IV = new Uint32Array([0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19]);
// Temporary buffer, not used to store anything between runs
// Named this way because it matches specification.
const SHA256_W = new Uint32Array(64);
class SHA256 extends SHA2 {
  constructor() {
    super(64, 32, 8, false);
    // We cannot use array here since array allows indexing by variable
    // which means optimizer/compiler cannot use registers.
    this.A = IV[0] | 0;
    this.B = IV[1] | 0;
    this.C = IV[2] | 0;
    this.D = IV[3] | 0;
    this.E = IV[4] | 0;
    this.F = IV[5] | 0;
    this.G = IV[6] | 0;
    this.H = IV[7] | 0;
  }
  get() {
    const {
      A,
      B,
      C,
      D,
      E,
      F,
      G,
      H
    } = this;
    return [A, B, C, D, E, F, G, H];
  }
  // prettier-ignore
  set(A, B, C, D, E, F, G, H) {
    this.A = A | 0;
    this.B = B | 0;
    this.C = C | 0;
    this.D = D | 0;
    this.E = E | 0;
    this.F = F | 0;
    this.G = G | 0;
    this.H = H | 0;
  }
  process(view, offset) {
    // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array
    for (let i = 0; i < 16; i++, offset += 4) SHA256_W[i] = view.getUint32(offset, false);
    for (let i = 16; i < 64; i++) {
      const W15 = SHA256_W[i - 15];
      const W2 = SHA256_W[i - 2];
      const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ W15 >>> 3;
      const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ W2 >>> 10;
      SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;
    }
    // Compression function main loop, 64 rounds
    let {
      A,
      B,
      C,
      D,
      E,
      F,
      G,
      H
    } = this;
    for (let i = 0; i < 64; i++) {
      const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);
      const T1 = H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;
      const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);
      const T2 = sigma0 + Maj(A, B, C) | 0;
      H = G;
      G = F;
      F = E;
      E = D + T1 | 0;
      D = C;
      C = B;
      B = A;
      A = T1 + T2 | 0;
    }
    // Add the compressed chunk to the current hash value
    A = A + this.A | 0;
    B = B + this.B | 0;
    C = C + this.C | 0;
    D = D + this.D | 0;
    E = E + this.E | 0;
    F = F + this.F | 0;
    G = G + this.G | 0;
    H = H + this.H | 0;
    this.set(A, B, C, D, E, F, G, H);
  }
  roundClean() {
    SHA256_W.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0);
    this.buffer.fill(0);
  }
}
// Constants from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf
class SHA224 extends SHA256 {
  constructor() {
    super();
    this.A = 0xc1059ed8 | 0;
    this.B = 0x367cd507 | 0;
    this.C = 0x3070dd17 | 0;
    this.D = 0xf70e5939 | 0;
    this.E = 0xffc00b31 | 0;
    this.F = 0x68581511 | 0;
    this.G = 0x64f98fa7 | 0;
    this.H = 0xbefa4fa4 | 0;
    this.outputLen = 28;
  }
}
/**
 * SHA2-256 hash function
 * @param message - data that would be hashed
 */
const sha256$1 = wrapConstructor(() => new SHA256());
wrapConstructor(() => new SHA224());

class NodeScore {
  constructor(node) {
    _defineProperty$1(this, "node", void 0);
    _defineProperty$1(this, "score", void 0);
    this.node = node;
    this.score = 0;
  }
}
/**
 * TypeScript equivalent of https://github.com/tysonmote/rendezvous/blob/be0258dbbd3d/rendezvous.go
 */
class RendezvousHash {
  constructor() {
    _defineProperty$1(this, "nodes", []);
    this.add(...arguments);
  }
  add() {
    for (var _len = arguments.length, nodes = new Array(_len), _key = 0; _key < _len; _key++) {
      nodes[_key] = arguments[_key];
    }
    for (const node of nodes) {
      this.nodes.push(new NodeScore(Buffer$1.from(node)));
    }
  }
  getNodes() {
    return this.nodes.map(nodeScore => nodeScore.node.toString());
  }
  get(key) {
    const first = this.getN(1, key)[0];
    return first !== null && first !== void 0 ? first : '';
  }
  getN(n, key) {
    return this.rendezvous256(key).slice(0, n);
  }
  rendezvous256(key) {
    const tuples = this.nodes.map(n => {
      const hostName = n.node.toString();
      return [hostName, bytesToHex$2(sha256$1(`${hostName}${key}`))];
    });
    tuples.sort((t1, t2) => {
      const [aHost, aScore] = t1;
      const [bHost, bScore] = t2;
      if (aScore === bScore) {
        return aHost < bHost ? -1 : 1;
      }
      return aScore < bScore ? -1 : 1;
    });
    return tuples.map(t => t[0]);
  }
}

const getDefaultStorageNodeSelectorConfig = config => ({
  bootstrapNodes: config.network.storageNodes,
  endpoint: config.network.apiEndpoint,
  logger: new Logger()
});

const isNodeHealthy = async function (endpoint) {
  let logger = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : console;
  try {
    var _health$transcodeStat;
    const resp = await axios({
      baseURL: endpoint,
      url: `/health_check`,
      method: 'get',
      timeout: 3000
    });
    if (resp.status !== 200) {
      logger.warn(`isNodeHealthy: ${endpoint} returned non-200 status ${resp.status}`);
      return false;
    }
    // check has space + not slow
    const health = resp.data.data;
    // skip nodes if avg transcode time is over 3 minutes
    const avgTranscodeTime = ((_health$transcodeStat = health.transcodeStats) === null || _health$transcodeStat === void 0 ? void 0 : _health$transcodeStat.AvgTranscodeTime) || 0;
    const isSlowTranscode = avgTranscodeTime > 180;
    return health.diskHasSpace && !isSlowTranscode;
  } catch (e) {
    logger.error(`isNodeHealthy: Error checking health: ${e}`);
    return false;
  }
};

class StorageNodeSelector {
  constructor(config) {
    var _this$config$bootstra;
    _defineProperty$1(this, "config", void 0);
    _defineProperty$1(this, "logger", void 0);
    _defineProperty$1(this, "nodes", void 0);
    _defineProperty$1(this, "orderedNodes", void 0);
    // endpoints (lowercase)
    _defineProperty$1(this, "selectedNode", void 0);
    _defineProperty$1(this, "selectionState", void 0);
    this.config = mergeConfigWithDefaults(config, getDefaultStorageNodeSelectorConfig(productionConfig));
    this.logger = this.config.logger.createPrefixedLogger('[storage-node-selector]');
    this.nodes = (_this$config$bootstra = this.config.bootstrapNodes) !== null && _this$config$bootstra !== void 0 ? _this$config$bootstra : [];
    this.selectionState = 'healthy_only';
    this.updateAvailableStorageNodes(this.config.endpoint);
  }
  async updateAvailableStorageNodes(endpoint) {
    var _responseData$data$ne;
    this.logger.info('Updating list of available storage nodes');
    const healthCheckEndpoint = `${endpoint}/health_check`;
    const healthCheckResponse = await fetch(healthCheckEndpoint);
    if (!healthCheckResponse.ok) {
      this.logger.warn('API health check did not respond successfully');
      return;
    }
    const responseData = await healthCheckResponse.json();
    const contentNodes = (_responseData$data$ne = responseData.data.network) === null || _responseData$data$ne === void 0 ? void 0 : _responseData$data$ne.content_nodes;
    if (!contentNodes) {
      this.logger.warn('API health check did not contain any available content nodes');
      return;
    }
    this.nodes = contentNodes;
    this.selectionState = 'healthy_only';
  }
  async getSelectedNode() {
    let forceReselect = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    if (this.selectedNode && !forceReselect) {
      return this.selectedNode;
    }
    return await this.select();
  }
  triedSelectingAllNodes() {
    return this.selectionState === 'failed_all';
  }
  getNodes(cid) {
    return this.orderNodes(cid);
  }
  async select() {
    var _await$this$selectUnt;
    // We've selected all healthy nodes. Restart from the beginning of the ordered list
    if (this.selectionState === 'failed_all') {
      this.selectionState = 'healthy_only';
    }
    // Select the next node in rendezvous order from the list of all nodes
    this.selectedNode = (_await$this$selectUnt = await this.selectUntilEndOfList()) !== null && _await$this$selectUnt !== void 0 ? _await$this$selectUnt : null;
    this.logger.info('Selected content node', this.selectedNode);
    if (!this.selectedNode) {
      // We've selected all healthy nodes. Return null and start over next time select() is called
      this.logger.info('Selected all healthy nodes. Returning null and starting over next time select() is called');
      this.selectionState = 'failed_all';
    }
    return this.selectedNode;
  }
  async selectUntilEndOfList() {
    var _this$orderedNodes;
    if (!((_this$orderedNodes = this.orderedNodes) !== null && _this$orderedNodes !== void 0 && _this$orderedNodes.length)) {
      this.orderedNodes = this.orderNodes(new Date().toString());
    }
    if (this.orderedNodes.length === 0) {
      return undefined;
    }
    const currentNodeIndex = this.selectedNode ? this.orderedNodes.indexOf(this.selectedNode) : -1;
    let selectedNode;
    let nextNodeIndex = currentNodeIndex;
    while (nextNodeIndex !== this.orderedNodes.length - 1) {
      nextNodeIndex++;
      const nextNode = this.orderedNodes[nextNodeIndex];
      if (!nextNode) continue; // should never happen unless this.orderedNodes has falsy values
      if (await isNodeHealthy(nextNode)) {
        selectedNode = nextNode;
        break;
      }
    }
    return selectedNode;
  }
  orderNodes(key) {
    const endpoints = this.nodes.map(node => node.endpoint.toLowerCase());
    const hash = new RendezvousHash(...endpoints);
    return hash.getN(this.nodes.length, key);
  }
}

/**
 * Abstract class for initializing individual contract clients.
 */
class EthereumContract {
  constructor(config) {
    /** A viem client */
    _defineProperty$1(this, "client", void 0);
    this.client = createPublicClient({
      chain: mainnet,
      transport: http(config.rpcEndpoint)
    });
  }
}

class ServiceTypeManagerClient extends EthereumContract {
  constructor(config) {
    super(config);
    _defineProperty$1(this, "discoveryNodeServiceType", void 0);
    _defineProperty$1(this, "contentNodeServiceType", void 0);
    _defineProperty$1(this, "contract", void 0);
    _defineProperty$1(this, "getDiscoveryNodeVersion", async () => {
      const version = await this.contract.getCurrentVersion({
        serviceType: this.discoveryNodeServiceType
      });
      return hexToString(version, {
        size: 32
      });
    });
    _defineProperty$1(this, "getContentNodeVersion", async () => {
      const version = await this.contract.getCurrentVersion({
        serviceType: this.contentNodeServiceType
      });
      return hexToString(version, {
        size: 32
      });
    });
    this.discoveryNodeServiceType = config.discoveryNodeServiceType;
    this.contentNodeServiceType = config.contentNodeServiceType;
    this.contract = new ServiceTypeManager(this.client, {
      address: config.addresses.serviceTypeManagerAddress
    });
  }
}

const getDefaultEthereumClientConfig = servicesConfig => {
  return {
    rpcEndpoint: servicesConfig.ethereum.rpcEndpoint,
    addresses: servicesConfig.ethereum.addresses,
    client: createPublicClient({
      chain: mainnet,
      transport: http(servicesConfig.ethereum.rpcEndpoint)
    })
  };
};

const getDefaultServiceTypeManagerConfig = config => ({
  discoveryNodeServiceType: '0x646973636f766572792d6e6f6465000000000000000000000000000000000000',
  contentNodeServiceType: '0x636f6e74656e742d6e6f64650000000000000000000000000000000000000000',
  ...getDefaultEthereumClientConfig(config)
});

class ServiceProviderFactoryClient extends EthereumContract {
  constructor(config) {
    super(config);
    _defineProperty$1(this, "discoveryNodeServiceType", void 0);
    _defineProperty$1(this, "contentNodeServiceType", void 0);
    _defineProperty$1(this, "contract", void 0);
    _defineProperty$1(this, "getDiscoveryNodes", async () => {
      const count = await this.contract.getTotalServiceTypeProviders({
        serviceType: this.discoveryNodeServiceType
      });
      const list = await Promise.all(range$1(1, Number(count) + 1).map(async i => await this.contract.getServiceEndpointInfo({
        serviceType: this.discoveryNodeServiceType,
        index: BigInt(i)
      })));
      // Remove empty endpoints
      return list.filter(_ref => {
        let [_, endpoint] = _ref;
        return endpoint !== '';
      });
    });
    _defineProperty$1(this, "getContentNodes", async () => {
      const count = await this.contract.getTotalServiceTypeProviders({
        serviceType: this.contentNodeServiceType
      });
      const list = await Promise.all(range$1(1, Number(count) + 1).map(async i => await this.contract.getServiceEndpointInfo({
        serviceType: this.contentNodeServiceType,
        index: BigInt(i)
      })));
      // Remove empty endpoints
      return list.filter(_ref2 => {
        let [_, endpoint] = _ref2;
        return endpoint !== '';
      });
    });
    this.discoveryNodeServiceType = config.discoveryNodeServiceType;
    this.contentNodeServiceType = config.contentNodeServiceType;
    this.contract = new ServiceProviderFactory(this.client, {
      address: config.addresses.serviceProviderFactoryAddress
    });
  }
}

const getDefaultServiceProviderFactoryConfig = config => ({
  discoveryNodeServiceType: '0x646973636f766572792d6e6f6465000000000000000000000000000000000000',
  contentNodeServiceType: '0x636f6e74656e742d6e6f64650000000000000000000000000000000000000000',
  ...getDefaultEthereumClientConfig(config)
});

class EthRewardsManagerClient extends EthereumContract {
  constructor(config) {
    super(config);
    _defineProperty$1(this, "contract", void 0);
    this.contract = new EthRewardsManager(this.client, {
      address: config.addresses.ethRewardsManagerAddress
    });
  }
}

const getDefaultEthRewardsManagerConfig = config => ({
  ...getDefaultEthereumClientConfig(config)
});

const GasFeeSchema = z.union([z.object({
  // Legacy
  gasPrice: z.bigint().optional()
}), z.object({
  // EIP-1559
  maxFeePerGas: z.bigint().optional(),
  maxPriorityFeePerGas: z.bigint().optional()
})]).and(z.object({
  gas: z.bigint().optional()
}));

const BalanceOfSchema = z.object({
  account: EthAddressSchema
});
const PermitSchema = GasFeeSchema.and(z.object({
  args: z.object({
    owner: EthAddressSchema.optional(),
    spender: EthAddressSchema,
    value: z.bigint(),
    deadline: z.bigint().optional()
  }),
  account: z.custom().optional()
}));

const ONE_HOUR_IN_MS = 1000 * 60 * 60;
class AudiusTokenClient {
  constructor(config) {
    _defineProperty$1(this, "contractAddress", void 0);
    _defineProperty$1(this, "audiusWalletClient", void 0);
    _defineProperty$1(this, "walletClient", void 0);
    _defineProperty$1(this, "publicClient", void 0);
    this.audiusWalletClient = config.audiusWalletClient;
    this.walletClient = config.ethWalletClient;
    this.publicClient = config.ethPublicClient;
    this.contractAddress = config.address;
  }
  async permit(params) {
    const {
      args: {
        owner = (await this.audiusWalletClient.getAddresses())[0],
        spender,
        value,
        deadline = BigInt(Date.now() + ONE_HOUR_IN_MS)
      },
      ...other
    } = await parseParams('permit', PermitSchema)(params);
    // Get args
    if (owner === undefined) {
      throw new Error('Parameter "owner" could not be derived from wallet client.');
    }
    const nonce = await this.publicClient.readContract({
      address: this.contractAddress,
      abi: AudiusToken.abi,
      functionName: 'nonces',
      args: [owner]
    });
    // Sign the typed data with the user's Audius wallet
    const typedData = {
      primaryType: 'Permit',
      domain: await this.domain(),
      message: {
        owner,
        spender,
        value,
        nonce,
        deadline
      },
      types: AudiusToken.types
    };
    const signature = await this.audiusWalletClient.signTypedData(typedData);
    const {
      r,
      s,
      v
    } = parseSignature(signature);
    // Send the transaction on Ethereum
    const {
      request
    } = await this.publicClient.simulateContract({
      address: this.contractAddress,
      abi: AudiusToken.abi,
      functionName: 'permit',
      args: [owner, spender, value, deadline, Number(v), r, s],
      ...other
    });
    return await this.walletClient.writeContract(request);
  }
  async balanceOf(params) {
    const {
      account
    } = await parseParams('balanceOf', BalanceOfSchema)(params);
    const balance = await this.publicClient.readContract({
      address: this.contractAddress,
      abi: AudiusToken.abi,
      functionName: 'balanceOf',
      args: [account]
    });
    return BigInt(balance);
  }
  async domain() {
    return {
      name: await this.publicClient.readContract({
        abi: AudiusToken.abi,
        address: this.contractAddress,
        functionName: 'name'
      }),
      chainId: BigInt(await this.publicClient.getChainId()),
      verifyingContract: this.contractAddress,
      version: '1'
    };
  }
}

const getDefaultAudiusTokenConfig = config => ({
  address: config.ethereum.addresses.audiusTokenAddress
});

class ClaimsManagerClient extends EthereumContract {
  constructor(config) {
    super(config);
    _defineProperty$1(this, "contract", void 0);
    this.contract = new ClaimsManager(this.client);
  }
}

const getDefaultClaimsManagerConfig = config => ({
  ...getDefaultEthereumClientConfig(config)
});

class DelegateManagerClient {
  constructor(config) {
    _defineProperty$1(this, "contractAddress", void 0);
    _defineProperty$1(this, "publicClient", void 0);
    _defineProperty$1(this, "getIncreaseDelegatedStakeEvents", _ref => {
      let {
        fromBlock = BigInt(0),
        delegator,
        serviceProvider,
        increaseAmount
      } = _ref;
      const args = {};
      if (delegator) args._delegator = delegator;
      if (serviceProvider) args._serviceProvider = serviceProvider;
      if (increaseAmount) args._increaseAmount = increaseAmount;
      return this.publicClient.getContractEvents({
        address: this.contractAddress,
        abi: DelegateManager.abi,
        eventName: 'IncreaseDelegatedStake',
        fromBlock,
        args
      });
    });
    _defineProperty$1(this, "getUndelegateStakeRequestedEvents", _ref2 => {
      let {
        fromBlock = BigInt(0),
        delegator,
        serviceProvider
      } = _ref2;
      const args = {};
      if (delegator) args._delegator = delegator;
      if (serviceProvider) args._serviceProvider = serviceProvider;
      return this.publicClient.getContractEvents({
        address: this.contractAddress,
        abi: DelegateManager.abi,
        eventName: 'UndelegateStakeRequested',
        fromBlock,
        args
      });
    });
    _defineProperty$1(this, "getUndelegateStakeRequestEvaluatedEvents", _ref3 => {
      let {
        fromBlock = BigInt(0),
        delegator,
        serviceProvider
      } = _ref3;
      const args = {};
      if (delegator) args._delegator = delegator;
      if (serviceProvider) args._serviceProvider = serviceProvider;
      return this.publicClient.getContractEvents({
        address: this.contractAddress,
        abi: DelegateManager.abi,
        eventName: 'UndelegateStakeRequestEvaluated',
        fromBlock,
        args
      });
    });
    _defineProperty$1(this, "getUndelegateStakeRequestCancelledEvents", _ref4 => {
      let {
        fromBlock = BigInt(0),
        delegator,
        serviceProvider
      } = _ref4;
      const args = {};
      if (delegator) args._delegator = delegator;
      if (serviceProvider) args._serviceProvider = serviceProvider;
      return this.publicClient.getContractEvents({
        address: this.contractAddress,
        abi: DelegateManager.abi,
        eventName: 'UndelegateStakeRequestCancelled',
        fromBlock,
        args
      });
    });
    _defineProperty$1(this, "getRemoveDelegatorRequestedEvents", _ref5 => {
      let {
        fromBlock = BigInt(0),
        delegator,
        serviceProvider
      } = _ref5;
      const args = {};
      if (delegator) args._delegator = delegator;
      if (serviceProvider) args._serviceProvider = serviceProvider;
      return this.publicClient.getContractEvents({
        address: this.contractAddress,
        abi: DelegateManager.abi,
        eventName: 'RemoveDelegatorRequested',
        fromBlock,
        args
      });
    });
    _defineProperty$1(this, "getRemoveDelegatorEvaluatedEvents", _ref6 => {
      let {
        fromBlock = BigInt(0),
        delegator,
        serviceProvider,
        unstakedAmount
      } = _ref6;
      const args = {};
      if (delegator) args._delegator = delegator;
      if (serviceProvider) args._serviceProvider = serviceProvider;
      if (unstakedAmount) args._unstakedAmount = unstakedAmount;
      return this.publicClient.getContractEvents({
        address: this.contractAddress,
        abi: DelegateManager.abi,
        eventName: 'RemoveDelegatorRequestEvaluated',
        fromBlock,
        args
      });
    });
    _defineProperty$1(this, "getRemoveDelegatorCancelledEvents", _ref7 => {
      let {
        fromBlock = BigInt(0),
        delegator,
        serviceProvider
      } = _ref7;
      const args = {};
      if (delegator) args._delegator = delegator;
      if (serviceProvider) args._serviceProvider = serviceProvider;
      return this.publicClient.getContractEvents({
        address: this.contractAddress,
        abi: DelegateManager.abi,
        eventName: 'RemoveDelegatorRequestCancelled',
        fromBlock,
        args
      });
    });
    _defineProperty$1(this, "getClaimEvents", _ref8 => {
      let {
        fromBlock = BigInt(0),
        claimer
      } = _ref8;
      const args = {};
      if (claimer) args._claimer = claimer;
      return this.publicClient.getContractEvents({
        address: this.contractAddress,
        abi: DelegateManager.abi,
        eventName: 'Claim',
        fromBlock,
        args
      });
    });
    _defineProperty$1(this, "getSlashEvents", _ref9 => {
      let {
        fromBlock = BigInt(0),
        target
      } = _ref9;
      const args = {};
      if (target) args._target = target;
      return this.publicClient.getContractEvents({
        address: this.contractAddress,
        abi: DelegateManager.abi,
        eventName: 'Slash',
        fromBlock,
        args
      });
    });
    _defineProperty$1(this, "getDelegatorsList", _ref0 => {
      let {
        serviceProviderAddress
      } = _ref0;
      return this.publicClient.readContract({
        address: this.contractAddress,
        abi: DelegateManager.abi,
        functionName: 'getDelegatorsList',
        args: [serviceProviderAddress]
      });
    });
    _defineProperty$1(this, "getTotalDelegatedToServiceProvider", _ref1 => {
      let {
        serviceProviderAddress
      } = _ref1;
      return this.publicClient.readContract({
        address: this.contractAddress,
        abi: DelegateManager.abi,
        functionName: 'getTotalDelegatedToServiceProvider',
        args: [serviceProviderAddress]
      });
    });
    _defineProperty$1(this, "getTotalLockedDelegationForServiceProvider", _ref10 => {
      let {
        serviceProviderAddress
      } = _ref10;
      return this.publicClient.readContract({
        address: this.contractAddress,
        abi: DelegateManager.abi,
        functionName: 'getTotalLockedDelegationForServiceProvider',
        args: [serviceProviderAddress]
      });
    });
    _defineProperty$1(this, "getTotalDelegatorStake", _ref11 => {
      let {
        delegatorAddress
      } = _ref11;
      return this.publicClient.readContract({
        address: this.contractAddress,
        abi: DelegateManager.abi,
        functionName: 'getTotalDelegatorStake',
        args: [delegatorAddress]
      });
    });
    _defineProperty$1(this, "getDelegatorStakeForServiceProvider", _ref12 => {
      let {
        delegatorAddress,
        serviceProviderAddress
      } = _ref12;
      return this.publicClient.readContract({
        address: this.contractAddress,
        abi: DelegateManager.abi,
        functionName: 'getDelegatorStakeForServiceProvider',
        args: [delegatorAddress, serviceProviderAddress]
      });
    });
    _defineProperty$1(this, "getPendingRemoveDelegatorRequest", _ref13 => {
      let {
        delegatorAddress,
        serviceProviderAddress
      } = _ref13;
      return this.publicClient.readContract({
        address: this.contractAddress,
        abi: DelegateManager.abi,
        functionName: 'getPendingRemoveDelegatorRequest',
        args: [serviceProviderAddress, delegatorAddress]
      });
    });
    _defineProperty$1(this, "getPendingUndelegateRequest", _ref14 => {
      let {
        delegatorAddress
      } = _ref14;
      return this.publicClient.readContract({
        address: this.contractAddress,
        abi: DelegateManager.abi,
        functionName: 'getPendingUndelegateRequest',
        args: [delegatorAddress]
      });
    });
    _defineProperty$1(this, "getUndelegateLockupDuration", () => this.publicClient.readContract({
      address: this.contractAddress,
      abi: DelegateManager.abi,
      functionName: 'getUndelegateLockupDuration'
    }));
    _defineProperty$1(this, "getMaxDelegators", () => this.publicClient.readContract({
      address: this.contractAddress,
      abi: DelegateManager.abi,
      functionName: 'getMaxDelegators'
    }));
    _defineProperty$1(this, "getMinDelegationAmount", () => this.publicClient.readContract({
      address: this.contractAddress,
      abi: DelegateManager.abi,
      functionName: 'getMinDelegationAmount'
    }));
    _defineProperty$1(this, "getRemoveDelegatorLockupDuration", () => this.publicClient.readContract({
      address: this.contractAddress,
      abi: DelegateManager.abi,
      functionName: 'getRemoveDelegatorLockupDuration'
    }));
    _defineProperty$1(this, "getRemoveDelegatorEvalDuration", () => this.publicClient.readContract({
      address: this.contractAddress,
      abi: DelegateManager.abi,
      functionName: 'getRemoveDelegatorEvalDuration'
    }));
    _defineProperty$1(this, "getGovernanceAddress", () => this.publicClient.readContract({
      address: this.contractAddress,
      abi: DelegateManager.abi,
      functionName: 'getGovernanceAddress'
    }));
    _defineProperty$1(this, "getServiceProviderFactoryAddress", () => this.publicClient.readContract({
      address: this.contractAddress,
      abi: DelegateManager.abi,
      functionName: 'getServiceProviderFactoryAddress'
    }));
    _defineProperty$1(this, "getClaimsManagerAddress", () => this.publicClient.readContract({
      address: this.contractAddress,
      abi: DelegateManager.abi,
      functionName: 'getClaimsManagerAddress'
    }));
    _defineProperty$1(this, "getStakingAddress", () => this.publicClient.readContract({
      address: this.contractAddress,
      abi: DelegateManager.abi,
      functionName: 'getStakingAddress'
    }));
    _defineProperty$1(this, "getSPMinDelegationAmount", _ref15 => {
      let {
        serviceProviderAddress
      } = _ref15;
      return this.publicClient.readContract({
        address: this.contractAddress,
        abi: DelegateManager.abi,
        functionName: 'getSPMinDelegationAmount',
        args: [serviceProviderAddress]
      });
    });
    this.contractAddress = config.address;
    this.publicClient = config.ethPublicClient;
  }
}

const getDefaultDelegateManagerConfig = config => ({
  address: config.ethereum.addresses.delegateManagerAddress
});

class StakingClient {
  constructor(config) {
    _defineProperty$1(this, "contractAddress", void 0);
    _defineProperty$1(this, "publicClient", void 0);
    _defineProperty$1(this, "token", () => this.publicClient.readContract({
      address: this.contractAddress,
      abi: Staking.abi,
      functionName: 'token'
    }));
    _defineProperty$1(this, "totalStaked", () => this.publicClient.readContract({
      address: this.contractAddress,
      abi: Staking.abi,
      functionName: 'totalStaked'
    }));
    _defineProperty$1(this, "supportsHistory", () => this.publicClient.readContract({
      address: this.contractAddress,
      abi: Staking.abi,
      functionName: 'supportsHistory'
    }));
    _defineProperty$1(this, "totalStakedFor", _ref => {
      let {
        account
      } = _ref;
      return this.publicClient.readContract({
        address: this.contractAddress,
        abi: Staking.abi,
        functionName: 'totalStakedFor',
        args: [account]
      });
    });
    _defineProperty$1(this, "totalStakedAt", _ref2 => {
      let {
        blockNumber
      } = _ref2;
      return this.publicClient.readContract({
        address: this.contractAddress,
        abi: Staking.abi,
        functionName: 'totalStakedAt',
        args: [blockNumber]
      });
    });
    _defineProperty$1(this, "totalStakedForAt", _ref3 => {
      let {
        account,
        blockNumber
      } = _ref3;
      return this.publicClient.readContract({
        address: this.contractAddress,
        abi: Staking.abi,
        functionName: 'totalStakedForAt',
        args: [account, blockNumber]
      });
    });
    _defineProperty$1(this, "isStaker", _ref4 => {
      let {
        account
      } = _ref4;
      return this.publicClient.readContract({
        address: this.contractAddress,
        abi: Staking.abi,
        functionName: 'isStaker',
        args: [account]
      });
    });
    _defineProperty$1(this, "lastClaimedFor", _ref5 => {
      let {
        account
      } = _ref5;
      return this.publicClient.readContract({
        address: this.contractAddress,
        abi: Staking.abi,
        functionName: 'lastClaimedFor',
        args: [account]
      });
    });
    _defineProperty$1(this, "getDelegateManagerAddress", () => this.publicClient.readContract({
      address: this.contractAddress,
      abi: Staking.abi,
      functionName: 'getDelegateManagerAddress'
    }));
    _defineProperty$1(this, "getClaimsManagerAddress", () => this.publicClient.readContract({
      address: this.contractAddress,
      abi: Staking.abi,
      functionName: 'getClaimsManagerAddress'
    }));
    _defineProperty$1(this, "getServiceProviderFactoryAddress", () => this.publicClient.readContract({
      address: this.contractAddress,
      abi: Staking.abi,
      functionName: 'getServiceProviderFactoryAddress'
    }));
    _defineProperty$1(this, "getGovernanceAddress", () => this.publicClient.readContract({
      address: this.contractAddress,
      abi: Staking.abi,
      functionName: 'getGovernanceAddress'
    }));
    this.contractAddress = config.address;
    this.publicClient = config.ethPublicClient;
  }
}

const getDefaultStakingConfig = config => ({
  address: config.ethereum.addresses.stakingAddress
});

class TrustedNotifierManagerClient extends EthereumContract {
  constructor(config) {
    super(config);
    _defineProperty$1(this, "contract", void 0);
    this.contract = new TrustedNotifierManager(this.client);
  }
}

const getDefaultTrustedNotifierManagerConfig = config => ({
  ...getDefaultEthereumClientConfig(config)
});

const range = length => [...Array(length).keys()];
const zip = arr => range(arr[0].length).map(col => range(arr.length).map(row => arr[row][col]));

//The intent of this file is probably best explained by an example:
function isMappableKey(key) {
  return ["string", "number", "symbol", "bigint", "boolean"].includes(typeof key);
}
const isRecursiveTuple = arr => arr.length === 2 && !Array.isArray(arr[0]) && Array.isArray(arr[1]);
const cartesianRightRecursive = arr => arr.length === 0 ? [] : Array.isArray(arr[0]) ? arr.map(_ref => {
  let [key, val] = _ref;
  return Array.isArray(val) ? (isRecursiveTuple(val) ? cartesianRightRecursive(val) : val).map(ele => [key, ele].flat()) : [[key, val]];
}).flat() : isRecursiveTuple(arr) ? cartesianRightRecursive(arr[1]).map(ele => [arr[0], ele]) : arr;
const toMapping = (mapping, shape) => {
  const crr = cartesianRightRecursive(mapping);
  if (crr.length === 0) throw new Error("Invalid mapping: empty");
  const definedShape = shape === undefined ? [range(crr[0].length - 1), [crr[0].length - 1]] : shape.map(ind => typeof ind === "number" ? [ind] : ind);
  // store reference to leaf object to unwrap values if all leaves are singletons
  let leafObjects = [];
  let allSingletons = true;
  const buildMappingRecursively = (keyCartesianSet, values) => {
    const distinctKeys = Array.from(new Set(keyCartesianSet[0]).values());
    const keyRows = new Map(distinctKeys.map(key => [key, []]));
    for (const [i, key] of keyCartesianSet[0].entries()) keyRows.get(key).push(i);
    // termination case
    if (keyCartesianSet.length === 1) {
      const ret = Object.fromEntries(distinctKeys.map(key => [key, keyRows.get(key).map(i => values[i].length === 1 ? values[i][0] : values[i])]));
      if (allSingletons) {
        for (const valRow of keyRows.values()) if (valRow.length > 1) {
          allSingletons = false;
          return ret;
        }
        leafObjects.push(ret);
      }
      return ret;
    }
    const droppedKeyCol = zip(keyCartesianSet.slice(1));
    return Object.fromEntries(distinctKeys.map(key => {
      const rows = keyRows.get(key);
      const keyCartesianSubset = zip(rows.map(i => droppedKeyCol[i]));
      const valuesSubset = rows.map(i => values[i]);
      return [key, buildMappingRecursively(keyCartesianSubset, valuesSubset)];
    }));
  };
  const cols = zip(crr);
  const getCol = col => {
    const colArr = cols[col];
    if (colArr === undefined) throw new Error(`Invalid shape: column ${col} does not exist`);
    return colArr;
  };
  const [keyCartesianSet, leafValues] = definedShape.map(indx => indx.map(col => getCol(col)));
  if (keyCartesianSet.length === 0) throw new Error("Invalid shape: empty key set");
  if (leafValues.length === 0) throw new Error("Invalid shape: empty value set");
  for (const keyCol of keyCartesianSet) for (const key of keyCol) if (!isMappableKey(key)) throw new Error(`Invalid key: ${key} in ${keyCol}`);
  const ret = buildMappingRecursively(keyCartesianSet, zip(leafValues));
  if (allSingletons) for (const leafObj of leafObjects) for (const key of Object.keys(leafObj)) leafObj[key] = leafObj[key][0];
  return ret;
};
function constMap(mappingEntries, shape) {
  const mapping = toMapping(mappingEntries, shape);
  const genericMappingFunc = function () {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return args.reduce((subMapping, key) => {
      var _subMapping$key$toStr;
      return subMapping ? (_subMapping$key$toStr = subMapping[key.toString()]) !== null && _subMapping$key$toStr !== void 0 ? _subMapping$key$toStr : undefined : undefined;
    }, mapping);
  };
  return Object.assign(genericMappingFunc, {
    has: function () {
      return genericMappingFunc(...arguments) !== undefined;
    },
    get: function () {
      return genericMappingFunc(...arguments);
    },
    subMap: key => mapping[key.toString()]
  });
}
//--- find a bunch of "tests" below
// It's unclear to me how to even properly test Typescript types, seeing how there isn't even an
//  equals operation...
// So this will have to do for now...
// const sample = [
//   [
//     "Mainnet", [
//       ["Ethereum", 1n],
//       ["Bsc", 56n],
//       ['Polygon', 137n],
//     ]
//   ],
//   [
//     "Testnet", [
//       ["Ethereum", 5n],
//       ["Sepolia", 11155111n],
//     ]
//   ]
// ] as const satisfies MappingEntries;
// type Test1 = ToMapping<typeof sample>;
// type Test2 = ToMapping<typeof sample, [[0,1],2]>; //same as Test1
// type Test3 = ToMapping<typeof sample, [[0,1],[2]]>; //same as Test1
// type Test10 = ToMapping<typeof sample, [[0,1],[0,1,2]]>;
// type Test11 = ToMapping<typeof sample, [[0,1],[2,1,0]]>;
// type Element10 = Test10["Mainnet"]["Ethereum"];
// type Element11 = Test11["Mainnet"]["Ethereum"];
// type Test20 = ToMapping<typeof sample, [0,1]>;
// type Test21 = ToMapping<typeof sample, [[0],1]>; //same as Test20
// type Test22 = ToMapping<typeof sample, [0,[1]]>; //same as Test20
// type Test23 = ToMapping<typeof sample, [[0],[1]]>; //same as Test20
// type Test30 = ToMapping<typeof sample, [2,0]>;
// type Test31 = ToMapping<typeof sample, [2,[0,1]]>;
// type Test32 = ToMapping<typeof sample, [[1,0],2]>;
// type Test40 = ToMapping<typeof sample, [1,0]>;
// const test1 = constMap(sample);
// const test1Entry1 = test1("Testnet", "Sepolia"); //11155111n
// const test2 = constMap(sample, [[0,1],2]); //same as test1
// const test2Entry1 = test2("Testnet", "Sepolia"); //same as test1Entry1
// const test2Entry2 = test2.get("doesn't", "exist"); //undefined: <bigint chain ids> | undefined
// const test2Entry3 = test2.has("doesn't", "exist"); //false: boolean
// const test3SubMap = test2.subMap("Testnet");
// const test3Entry1 = test3SubMap("Sepolia"); //11155111n
// const test3Entry2 = test3SubMap("Ethereum"); //5n
// const test10 = constMap(sample, [[0,1],[0,1,2]]);
// const test10Entry1 = test10("Testnet", "Sepolia"); //["Testnet", "Sepolia", 11155111n]
// const test20 = constMap(sample, [0,1]);
// const test20Entry1 = test20("Testnet"); //["Ethereum", "Sepolia"]
// const test30 = constMap(sample, [2,0]);
// const test30Entry1 = test30(1n); //"Mainnet"
// const test31 = constMap(sample, [2,[0,1]]);
// const test31Entry1 = test31(1n); //["Mainnet", "Ethereum"]
// const test31Entry2 = test31(11155111n); //["Testnet", "Sepolia"]
// const test40 = constMap(sample, [1,0]);
// const test40Entry1 = test40("Ethereum"); //["Mainnet", "Testnet"]
// const test40Entry2 = test40("Sepolia"); //["Testnet"]
// const test40Entry3 = test40("Bsc"); //["Mainnet"]

// prettier-ignore
const chainIdAndChainEntries = [
//Unlike the old sdk, we are not including an "Unset" chain with chainId 0 here because:
//  * no other types would be associated with it (such as contracts or a platform)
//  * avoids awkward "chain but not 'Unset'" checks
//  * "off" is not a TV channel either
//Instead we'll use `null` for chain and 0 as the chainId where appropriate (e.g. governance VAAs)
[1, "Solana"], [2, "Ethereum"], [3, "Terra"], [4, "Bsc"], [5, "Polygon"], [6, "Avalanche"], [7, "Oasis"], [8, "Algorand"], [9, "Aurora"], [10, "Fantom"], [11, "Karura"], [12, "Acala"], [13, "Klaytn"], [14, "Celo"], [15, "Near"], [16, "Moonbeam"], [17, "Neon"], [18, "Terra2"], [19, "Injective"], [20, "Osmosis"], [21, "Sui"], [22, "Aptos"], [23, "Arbitrum"], [24, "Optimism"], [25, "Gnosis"], [26, "Pythnet"], [28, "Xpla"], [29, "Btc"], [30, "Base"], [32, "Sei"], [33, "Rootstock"], [34, "Scroll"], [35, "Mantle"], [36, "Blast"], [37, "Xlayer"], [38, "Linea"], [39, "Berachain"], [40, "Seievm"], [43, "Snaxchain"], [44, "Unichain"], [45, "Worldchain"], [3104, "Wormchain"], [4000, "Cosmoshub"], [4001, "Evmos"], [4002, "Kujira"], [4003, "Neutron"], [4004, "Celestia"], [4005, "Stargaze"], [4006, "Seda"], [4007, "Dymension"], [4008, "Provenance"], [10002, "Sepolia"], [10003, "ArbitrumSepolia"], [10004, "BaseSepolia"], [10005, "OptimismSepolia"], [10006, "Holesky"], [10007, "PolygonSepolia"], [10008, "MonadDevnet"]];
const [chainIds, chains] = zip(chainIdAndChainEntries);
const chainToChainId = constMap(chainIdAndChainEntries, [1, 0]);
const chainIdToChain = constMap(chainIdAndChainEntries);
const isChain = chain => chainToChainId.has(chain);
const isChainId = chainId => chainIdToChain.has(chainId);
const toChainId = chain => {
  switch (typeof chain) {
    case "string":
      if (isChain(chain)) return chainToChainId(chain);
      break;
    case "number":
      if (isChainId(chain)) return chain;
      break;
  }
  throw Error(`Cannot convert to ChainId: ${chain}`);
};

const HexSchema = z.custom(val => {
  return z.string().startsWith('0x', 'Hex string must start with 0x').regex(/^0x[0-9a-fA-F]+$/, 'Hex must only include hexadecimal characters 0-9, a-F').parse(val);
});

const TransferTokensSchema = GasFeeSchema.and(z.object({
  args: z.object({
    from: EthAddressSchema.optional(),
    amount: z.bigint(),
    recipientChain: z.enum(chains).transform(toChainId),
    recipient: HexSchema,
    deadline: z.bigint().optional(),
    arbiterFee: z.bigint().optional()
  }),
  account: z.custom().optional()
}));

const ONE_HOUR_IN_S = 60 * 60;
class AudiusWormholeClient {
  constructor(config) {
    _defineProperty$1(this, "contractAddress", void 0);
    _defineProperty$1(this, "audiusWalletClient", void 0);
    _defineProperty$1(this, "walletClient", void 0);
    _defineProperty$1(this, "publicClient", void 0);
    this.audiusWalletClient = config.audiusWalletClient;
    this.walletClient = config.ethWalletClient;
    this.publicClient = config.ethPublicClient;
    this.contractAddress = config.address;
  }
  async transferTokens(params) {
    const {
      args: {
        from = (await this.audiusWalletClient.getAddresses())[0],
        amount,
        recipientChain,
        recipient,
        deadline = BigInt(Math.round(Date.now() / 1000) + ONE_HOUR_IN_S),
        arbiterFee = BigInt(0)
      },
      ...other
    } = await parseParams('transferTokens', TransferTokensSchema)(params);
    // Get args
    if (from === undefined) {
      throw new Error('Parameter "from" could not be derived from wallet client.');
    }
    const nonce = await this.publicClient.readContract({
      address: this.contractAddress,
      abi: AudiusWormhole.abi,
      functionName: 'nonces',
      args: [from]
    });
    // Sign the typed data with the user's Audius wallet
    const typedData = {
      primaryType: 'TransferTokens',
      domain: await this.domain(),
      message: {
        from,
        amount,
        recipientChain,
        recipient,
        artbiterFee: arbiterFee,
        deadline,
        nonce
      },
      types: AudiusWormhole.types
    };
    const signature = await this.audiusWalletClient.signTypedData(typedData);
    const {
      r,
      s,
      v
    } = parseSignature(signature);
    // Send the transaction on Ethereum
    const {
      request
    } = await this.publicClient.simulateContract({
      address: this.contractAddress,
      abi: AudiusWormhole.abi,
      functionName: 'transferTokens',
      args: [from, amount, recipientChain, recipient, arbiterFee, deadline, Number(v), r, s],
      ...other
    });
    return await this.walletClient.writeContract(request);
  }
  async domain() {
    return {
      name: 'AudiusWormholeClient',
      chainId: BigInt(await this.publicClient.getChainId()),
      verifyingContract: this.contractAddress,
      version: '1'
    };
  }
}

const getDefaultWormholeConfig = config => ({
  address: config.ethereum.addresses.audiusWormholeAddress
});

class RegistryClient extends EthereumContract {
  constructor(config) {
    super(config);
    _defineProperty$1(this, "contract", void 0);
    this.contract = new Registry(this.client);
  }
}

const getDefaultRegistryConfig = config => ({
  ...getDefaultEthereumClientConfig(config)
});

class GovernanceClient extends EthereumContract {
  constructor(config) {
    super(config);
    _defineProperty$1(this, "contract", void 0);
    this.contract = new Governance(this.client);
  }
}

const getDefaultGovernanceConfig = config => ({
  ...getDefaultEthereumClientConfig(config)
});

class EmailEncryptionService extends BaseAPI$1 {
  /**
   * Constructs a new EmailEncryptionService instance
   * @param config - SDK configuration object
   * @param audiusWalletClient - Configured AudiusWalletClient instance for cryptographic operations
   */
  constructor(config, audiusWalletClient) {
    super(config);
    _defineProperty$1(this, "audiusWalletClient", void 0);
    _defineProperty$1(this, "symmetricKeyCache", new Map());
    _defineProperty$1(this, "sharedSecretCache", new Map());
    _defineProperty$1(this, "cacheSize", 1000);
    this.audiusWalletClient = audiusWalletClient;
  }
  /**
   * Creates a new symmetric key for email encryption
   * @returns The symmetric key as Uint8Array
   */
  createSymmetricKey() {
    return crypto.getRandomValues(new Uint8Array(32));
  }
  /**
   * Encrypts a symmetric key for a user using their public key and shared secret
   * @param userId - The ID of the user to encrypt for
   * @param symmetricKey - The symmetric key to encrypt
   * @returns The encrypted key as a base64 string
   */
  async encryptSymmetricKey(userId, symmetricKey) {
    const userPublicKey = await this.getPublicKey(userId);
    const sharedSecret = await this.audiusWalletClient.getSharedSecret({
      publicKey: userPublicKey
    });
    const encryptedKeyBytes = await CryptoUtils.encrypt(sharedSecret, symmetricKey);
    return base64.encode(encryptedKeyBytes);
  }
  /**
   * Decrypts a symmetric key using cached shared secrets
   * @param encryptedKey - The encrypted symmetric key as a base64 string
   * @param userId - The ID of the user who encrypted the key
   * @param pubkeyBase64 - Optional pre-provided public key to avoid API calls
   * @returns The decrypted symmetric key from cache or new decryption
   * @remarks Uses LRU caching for symmetric keys and shared secrets to improve performance
   */
  async decryptSymmetricKey(encryptedKey, userId, pubkeyBase64) {
    const cacheKey = `${userId}-${encryptedKey}`;
    if (!this.symmetricKeyCache.has(cacheKey)) {
      // Store the promise in the cache to handle concurrent requests
      this.symmetricKeyCache.set(cacheKey, pubkeyBase64 ? this.decryptSymmetricKeyWithPublicKey(encryptedKey, pubkeyBase64) : this.decryptSymmetricKeyDirect(encryptedKey, userId));
      // Remove oldest entries if caches get too large
      if (this.symmetricKeyCache.size >= this.cacheSize) {
        this.removeOldestEntries(this.symmetricKeyCache);
      }
      if (this.sharedSecretCache.size >= this.cacheSize) {
        this.removeOldestEntries(this.sharedSecretCache);
      }
    }
    return this.symmetricKeyCache.get(cacheKey);
  }
  /**
   * Encrypts an email using a symmetric key
   * @param email - The email to encrypt
   * @param symmetricKey - The symmetric key to use
   * @returns The encrypted email as a base64 string
   */
  async encryptEmail(email, symmetricKey) {
    const encryptedBytes = await CryptoUtils.encryptString(symmetricKey, email);
    return base64.encode(encryptedBytes);
  }
  /**
   * Decrypts an email using a symmetric key
   * @param encryptedEmail - The encrypted email as a base64 string
   * @param symmetricKey - The symmetric key to use
   * @returns The decrypted email
   */
  async decryptEmail(encryptedEmail, symmetricKey) {
    return await CryptoUtils.decryptString(symmetricKey, base64.decode(encryptedEmail));
  }
  /**
   * Creates and distributes a symmetric key between an email owner and recipients
   * @param emailOwnerId - The ID of the email owner
   * @param receivingIds - List of user IDs who will receive access
   * @param grantorId - The ID of the user granting access
   * @returns The encrypted symmetric keys for storage
   * @remarks Includes the email owner in the recipient list automatically
   */
  async createSharedKey(emailOwnerId, receivingIds, grantorId) {
    // Generate random symmetric key
    const symmetricKey = this.createSymmetricKey();
    // Include email owner in the list of recipients
    const allRecipientIds = [emailOwnerId, ...receivingIds];
    // Encrypt for each receiving user including the owner
    const receiverEncryptedKeys = await Promise.all(allRecipientIds.map(async receivingId => {
      const encryptedKey = await this.encryptSymmetricKey(receivingId, symmetricKey);
      return {
        receivingId,
        encryptedKey,
        grantorId
      };
    }));
    return {
      symmetricKey,
      receiverEncryptedKeys
    };
  }
  /**
   * Encrypts emails for multiple recipients using a shared symmetric key
   * @param emailOwnerId - The ID of the email owner
   * @param receivingIds - List of user IDs who will receive access
   * @param grantorId - The ID of the user granting access
   * @param emails - List of emails to encrypt
   * @returns Object containing encrypted emails and encrypted symmetric keys
   */
  async encryptEmails(emailOwnerId, receivingIds, grantorId, emails) {
    // Create symmetric key for all recipients
    const {
      symmetricKey,
      receiverEncryptedKeys
    } = await this.createSharedKey(emailOwnerId, receivingIds, grantorId);
    // Encrypt emails with symmetric key
    const encryptedEmails = await Promise.all(emails.map(email => this.encryptEmail(email, symmetricKey)));
    return {
      encryptedEmails,
      receiverEncryptedKeys
    };
  }
  // Caching Infrastructure
  /**
   * Removes oldest entries from a cache map when size limit is reached
   * @param map - The cache map to prune
   * @remarks Implements LRU-like cache eviction by removing oldest 1/3 of entries
   * @private Internal cache maintenance utility
   */
  removeOldestEntries(map) {
    const entries = Array.from(map.keys());
    entries.slice(0, this.cacheSize / 3).forEach(key => map.delete(key));
  }
  // Core Decryption Implementations
  /**
   * Direct decryption path using user ID to fetch public key
   * @param encryptedKey - Base64 encoded encrypted symmetric key
   * @param userId - ID of user who encrypted the key
   * @returns Decrypted symmetric key bytes
   * @private Internal decryption implementation
   */
  async decryptSymmetricKeyDirect(encryptedKey, userId) {
    const userPublicKey = await this.getPublicKey(userId);
    const sharedSecret = await this.getSharedSecretWithCache(userPublicKey);
    return await CryptoUtils.decrypt(sharedSecret, base64.decode(encryptedKey));
  }
  /**
   * Optimized decryption path using pre-provided public key
   * @param encryptedKey - Base64 encoded encrypted symmetric key
   * @param pubkeyBase64 - Base64 encoded public key of encrypting user
   * @returns Decrypted symmetric key bytes
   * @private Internal decryption implementation
   * @remarks Bypasses public key API call when key is already known
   */
  async decryptSymmetricKeyWithPublicKey(encryptedKey, pubkeyBase64) {
    const userPublicKey = base64.decode(pubkeyBase64);
    const sharedSecret = await this.getSharedSecretWithCache(userPublicKey);
    return await CryptoUtils.decrypt(sharedSecret, base64.decode(encryptedKey));
  }
  /**
   * Gets the public key for a user from the comms API
   * @param userId - The ID of the user to get the public key for
   * @returns The user's public key as a Uint8Array
   * @private Internal API call wrapper
   */
  async getPublicKey(userId) {
    const response = await this.request({
      path: `/comms/pubkey/${userId}`,
      method: 'GET',
      headers: {}
    });
    const json = await response.json();
    return base64.decode(json.data);
  }
  /**
   * Retrieves shared secret with caching mechanism
   * @param publicKey - Public key to derive shared secret from
   * @returns Cached shared secret promise
   * @private Manages LRU cache for shared secrets
   */
  async getSharedSecretWithCache(publicKey) {
    const cacheKey = Buffer.from(publicKey).toString('base64');
    if (!this.sharedSecretCache.has(cacheKey)) {
      this.sharedSecretCache.set(cacheKey, this.audiusWalletClient.getSharedSecret({
        publicKey
      }));
    }
    return this.sharedSecretCache.get(cacheKey);
  }
}

const isApiKeyValid = apiKey => {
  try {
    if (apiKey.length !== 40) {
      return false;
    }
    const hexadecimalRegex = /^[0-9a-fA-F]+$/;
    return hexadecimalRegex.test(apiKey);
  } catch (_e) {
    return false;
  }
};

const DEVELOPER_APP_MAX_DESCRIPTION_LENGTH = 128;
const DEVELOPER_APP_MAX_IMAGE_URL_LENGTH = 2000;
const DEVELOPER_APP_IMAGE_URL_REGEX = /^(https?):\/\//i;
const CreateDeveloperAppSchema = z.object({
  name: z.string(),
  description: z.optional(z.string().max(DEVELOPER_APP_MAX_DESCRIPTION_LENGTH)),
  imageUrl: z.optional(z.string().max(DEVELOPER_APP_MAX_IMAGE_URL_LENGTH).refine(value => DEVELOPER_APP_IMAGE_URL_REGEX.test(value), {
    message: 'Invalid URL'
  })),
  userId: HashId
});
const UpdateDeveloperAppSchema = z.object({
  appApiKey: z.custom(data => {
    return isApiKeyValid(data);
  }),
  name: z.string(),
  description: z.optional(z.string().max(DEVELOPER_APP_MAX_DESCRIPTION_LENGTH)),
  imageUrl: z.optional(z.string().max(DEVELOPER_APP_MAX_IMAGE_URL_LENGTH).refine(value => DEVELOPER_APP_IMAGE_URL_REGEX.test(value), {
    message: 'Invalid URL'
  })),
  userId: HashId
});
const DeleteDeveloperAppSchema = z.object({
  userId: HashId,
  appApiKey: z.custom(data => {
    return isApiKeyValid(data);
  })
});

class DeveloperAppsApi extends DeveloperAppsApi$1 {
  constructor(config, entityManager) {
    super(config);
    _defineProperty$1(this, "entityManager", void 0);
    this.entityManager = entityManager;
  }
  /**
   * Create a developer app
   */
  async createDeveloperApp(params, advancedOptions) {
    const {
      name,
      userId,
      description,
      imageUrl
    } = await parseParams('createDeveloperApp', CreateDeveloperAppSchema)(params);
    const privateKey = generatePrivateKey();
    const address = privateKeyToAddress(privateKey);
    const wallet = createAppWalletClient({
      apiKey: address,
      apiSecret: privateKey
    });
    const unixTs = Math.round(new Date().getTime() / 1000); // current unix timestamp (sec)
    const message = `Creating Audius developer app at ${unixTs}`;
    const signature = await wallet.signMessage({
      message
    });
    const response = await this.entityManager.manageEntity({
      userId,
      entityType: EntityType.DEVELOPER_APP,
      entityId: 0,
      action: Action.CREATE,
      metadata: JSON.stringify({
        name,
        description,
        image_url: imageUrl,
        app_signature: {
          message,
          signature
        }
      }),
      ...advancedOptions
    });
    const apiKey = address.slice(2).toLowerCase();
    const apiSecret = privateKey.slice(2).toLowerCase();
    return {
      ...response,
      apiKey,
      apiSecret
    };
  }
  /**
   * Update a developer app
   */
  async updateDeveloperApp(params, advancedOptions) {
    const {
      appApiKey,
      name,
      userId,
      description,
      imageUrl
    } = await parseParams('updateDeveloperApp', UpdateDeveloperAppSchema)(params);
    const response = await this.entityManager.manageEntity({
      userId,
      entityType: EntityType.DEVELOPER_APP,
      entityId: 0,
      action: Action.UPDATE,
      metadata: JSON.stringify({
        address: `0x${appApiKey}`,
        name,
        description,
        image_url: imageUrl
      }),
      ...advancedOptions
    });
    return {
      ...response
    };
  }
  /**
   * Delete a developer app
   */
  async deleteDeveloperApp(params) {
    const {
      userId,
      appApiKey
    } = await parseParams('deleteDeveloperApp', DeleteDeveloperAppSchema)(params);
    return await this.entityManager.manageEntity({
      userId,
      entityType: EntityType.DEVELOPER_APP,
      entityId: 0,
      action: Action.DELETE,
      metadata: JSON.stringify({
        address: `0x${appApiKey}`
      })
    });
  }
}

// Base schema for event metadata
const EventMetadataSchema = z.object({
  userId: z.number(),
  eventId: z.number(),
  eventType: z.nativeEnum(EventEventTypeEnum).optional(),
  entityType: z.nativeEnum(EventEntityTypeEnum).optional(),
  entityId: z.number().optional(),
  endDate: z.string().optional(),
  eventData: z.record(z.any()).optional()
});
// Request schemas for each operation
const CreateEventSchema = EventMetadataSchema.omit({
  eventId: true
}).extend({
  eventId: z.number().optional() // Make eventId optional for creation
});
const UpdateEventSchema = EventMetadataSchema.pick({
  userId: true,
  eventId: true,
  endDate: true,
  eventData: true
});
const DeleteEventSchema = EventMetadataSchema.pick({
  userId: true,
  eventId: true
});

class EventsApi extends EventsApi$1 {
  constructor(configuration, entityManager, logger) {
    super(configuration);
    _defineProperty$1(this, "entityManager", void 0);
    _defineProperty$1(this, "logger", void 0);
    this.entityManager = entityManager;
    this.logger = logger;
    this.logger = logger.createPrefixedLogger('[events-api]');
  }
  async generateEventId() {
    const response = await this.getUnclaimedEventID();
    const {
      data: unclaimedId
    } = response;
    if (!unclaimedId) {
      return Math.floor(Math.random() * 1000000);
    }
    return decodeHashId(unclaimedId);
  }
  /**
   * Create an event
   */
  async createEvent(params) {
    // Parse inputs
    const parsedParameters = await parseParams('createEvent', CreateEventSchema)(params);
    const {
      userId,
      eventId,
      eventType,
      entityType,
      entityId: eventEntityId,
      endDate,
      eventData
    } = parsedParameters;
    const entityId = eventId !== null && eventId !== void 0 ? eventId : await this.generateEventId();
    const response = await this.entityManager.manageEntity({
      entityId,
      userId,
      entityType: EntityType.EVENT,
      action: Action.CREATE,
      metadata: JSON.stringify({
        cid: '',
        data: snakecaseKeys({
          eventType,
          entityType,
          entityId: eventEntityId,
          endDate,
          eventData
        })
      })
    });
    this.logger.info('Successfully created a event');
    return response;
  }
  /**
   * Update an event
   */
  async updateEvent(params) {
    // Parse inputs
    const parsedParameters = await parseParams('updateEvent', UpdateEventSchema)(params);
    const {
      userId,
      eventId,
      endDate,
      eventData
    } = parsedParameters;
    const response = await this.entityManager.manageEntity({
      entityId: eventId,
      userId,
      entityType: EntityType.EVENT,
      action: Action.UPDATE,
      metadata: JSON.stringify({
        cid: '',
        data: snakecaseKeys({
          endDate,
          eventData
        })
      })
    });
    this.logger.info('Successfully updated the event');
    return response;
  }
  /**
   * Delete an event
   */
  async deleteEvent(params) {
    // Parse inputs
    const parsedParameters = await parseParams('deleteEvent', DeleteEventSchema)(params);
    const {
      userId,
      eventId
    } = parsedParameters;
    const response = await this.entityManager.manageEntity({
      entityId: eventId,
      userId,
      entityType: EntityType.EVENT,
      action: Action.DELETE,
      metadata: ''
    });
    this.logger.info('Successfully deleted the event');
    return response;
  }
}

/* tslint:disable */
/* eslint-disable */
/**
 * API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
const BASE_PATH = "/v1/full".replace(/\/+$/, "");
class Configuration {
  constructor() {
    let configuration = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    _defineProperty$1(this, "configuration", void 0);
    this.configuration = configuration;
  }
  set config(configuration) {
    this.configuration = configuration;
  }
  get basePath() {
    return this.configuration.basePath != null ? this.configuration.basePath : BASE_PATH;
  }
  get fetchApi() {
    return this.configuration.fetchApi;
  }
  get middleware() {
    return this.configuration.middleware || [];
  }
  get queryParamsStringify() {
    return this.configuration.queryParamsStringify || querystring;
  }
  get username() {
    return this.configuration.username;
  }
  get password() {
    return this.configuration.password;
  }
  get apiKey() {
    const apiKey = this.configuration.apiKey;
    if (apiKey) {
      return typeof apiKey === 'function' ? apiKey : () => apiKey;
    }
    return undefined;
  }
  get accessToken() {
    const accessToken = this.configuration.accessToken;
    if (accessToken) {
      return typeof accessToken === 'function' ? accessToken : async () => accessToken;
    }
    return undefined;
  }
  get headers() {
    return this.configuration.headers;
  }
  get credentials() {
    return this.configuration.credentials;
  }
}
const DefaultConfig = new Configuration();
/**
 * This is the base class for all generated API classes.
 */
class BaseAPI {
  constructor() {
    let configuration = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DefaultConfig;
    _defineProperty$1(this, "configuration", void 0);
    _defineProperty$1(this, "middleware", void 0);
    _defineProperty$1(this, "fetchApi", async (url, init) => {
      let fetchParams = {
        url,
        init
      };
      for (const middleware of this.middleware) {
        if (middleware.pre) {
          fetchParams = (await middleware.pre({
            fetch: this.fetchApi,
            ...fetchParams
          })) || fetchParams;
        }
      }
      let response = undefined;
      try {
        response = await (this.configuration.fetchApi || fetch)(fetchParams.url, fetchParams.init);
      } catch (e) {
        for (const middleware of this.middleware) {
          if (middleware.onError) {
            response = (await middleware.onError({
              fetch: this.fetchApi,
              url: fetchParams.url,
              init: fetchParams.init,
              error: e,
              response: response ? response.clone() : undefined
            })) || response;
          }
        }
        if (response === undefined) {
          if (e instanceof Error) {
            throw new FetchError(e, 'The request failed and the interceptors did not return an alternative response');
          } else {
            throw e;
          }
        }
      }
      for (const middleware of this.middleware) {
        if (middleware.post) {
          response = (await middleware.post({
            fetch: this.fetchApi,
            url: fetchParams.url,
            init: fetchParams.init,
            response: response.clone()
          })) || response;
        }
      }
      return response;
    });
    this.configuration = configuration;
    this.middleware = configuration.middleware;
  }
  /** @hidden */
  withMiddleware() {
    const next = this.clone();
    next.middleware = next.middleware.concat(...arguments);
    return next;
  }
  /** @hidden */
  withPreMiddleware() {
    for (var _len = arguments.length, preMiddlewares = new Array(_len), _key = 0; _key < _len; _key++) {
      preMiddlewares[_key] = arguments[_key];
    }
    const middlewares = preMiddlewares.map(pre => ({
      pre
    }));
    return this.withMiddleware(...middlewares);
  }
  /** @hidden */
  withPostMiddleware() {
    for (var _len2 = arguments.length, postMiddlewares = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      postMiddlewares[_key2] = arguments[_key2];
    }
    const middlewares = postMiddlewares.map(post => ({
      post
    }));
    return this.withMiddleware(...middlewares);
  }
  /** @hidden */
  async request(context, initOverrides) {
    const {
      url,
      init
    } = await this.createFetchParams(context, initOverrides);
    const response = await this.fetchApi(url, init);
    if (response && response.status >= 200 && response.status < 300) {
      return response;
    }
    throw new ResponseError(response, 'Response returned an error code');
  }
  async createFetchParams(context, initOverrides) {
    let url = this.configuration.basePath + context.path;
    if (context.query !== undefined && Object.keys(context.query).length !== 0) {
      // only add the querystring to the URL if there are query parameters.
      // this is done to avoid urls ending with a "?" character which buggy webservers
      // do not handle correctly sometimes.
      url += '?' + this.configuration.queryParamsStringify(context.query);
    }
    const headers = Object.assign({}, this.configuration.headers, context.headers);
    Object.keys(headers).forEach(key => headers[key] === undefined ? delete headers[key] : {});
    const initOverrideFn = typeof initOverrides === "function" ? initOverrides : async () => initOverrides;
    const initParams = {
      method: context.method,
      headers,
      body: context.body,
      credentials: this.configuration.credentials
    };
    const overriddenInit = {
      ...initParams,
      ...(await initOverrideFn({
        init: initParams,
        context
      }))
    };
    const init = {
      ...overriddenInit,
      body: isFormData(overriddenInit.body) || overriddenInit.body instanceof URLSearchParams || isBlob(overriddenInit.body) || isString(overriddenInit.body) ? overriddenInit.body : JSON.stringify(overriddenInit.body)
    };
    return {
      url,
      init
    };
  }
  /**
   * Create a shallow clone of `this` by constructing a new instance
   * and then shallow cloning data members.
   */
  clone() {
    const constructor = this.constructor;
    const next = new constructor(this.configuration);
    next.middleware = this.middleware.slice();
    return next;
  }
}
function isBlob(value) {
  return typeof Blob !== 'undefined' && value instanceof Blob;
}
function isFormData(value) {
  return typeof FormData !== "undefined" && value instanceof FormData;
}
function isString(value) {
  return typeof value === 'string';
}
class ResponseError extends Error {
  constructor(response, msg) {
    super(msg);
    _defineProperty$1(this, "response", void 0);
    _defineProperty$1(this, "name", "ResponseError");
    this.response = response;
  }
}
class FetchError extends Error {
  constructor(cause, msg) {
    super(msg, {
      cause
    });
    _defineProperty$1(this, "name", "FetchError");
  }
}
class RequiredError extends Error {
  constructor(field, msg) {
    super(msg);
    _defineProperty$1(this, "field", void 0);
    _defineProperty$1(this, "name", "RequiredError");
    this.field = field;
  }
}
const COLLECTION_FORMATS = {
  csv: ",",
  ssv: " ",
  tsv: "\t",
  pipes: "|"
};
function exists(json, key) {
  const value = json[key];
  return value !== null && value !== undefined;
}
function querystring(params) {
  let prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  return Object.keys(params).sort().map(key => querystringSingleKey(key, params[key], prefix)).filter(part => part.length > 0).join('&');
}
function querystringSingleKey(key, value) {
  let keyPrefix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
  const fullKey = keyPrefix + (keyPrefix.length ? `[${key}]` : key);
  if (value instanceof Array) {
    const multiValue = value.map(singleValue => encodeURIComponent(String(singleValue))).join(`&${encodeURIComponent(fullKey)}=`);
    return `${encodeURIComponent(fullKey)}=${multiValue}`;
  }
  if (value instanceof Set) {
    const valueAsArray = Array.from(value);
    return querystringSingleKey(key, valueAsArray, keyPrefix);
  }
  if (value instanceof Date) {
    return `${encodeURIComponent(fullKey)}=${encodeURIComponent(value.toISOString())}`;
  }
  if (value instanceof Object) {
    return querystring(value, fullKey);
  }
  return `${encodeURIComponent(fullKey)}=${encodeURIComponent(String(value))}`;
}
function mapValues(data, fn) {
  return Object.keys(data).reduce((acc, key) => ({
    ...acc,
    [key]: fn(data[key])
  }), {});
}
function canConsumeForm(consumes) {
  for (const consume of consumes) {
    if ('multipart/form-data' === consume.contentType) {
      return true;
    }
  }
  return false;
}
class JSONApiResponse {
  constructor(raw) {
    let transformer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : jsonValue => jsonValue;
    _defineProperty$1(this, "raw", void 0);
    _defineProperty$1(this, "transformer", void 0);
    this.raw = raw;
    this.transformer = transformer;
  }
  async value() {
    return this.transformer(await this.raw.json());
  }
}
class VoidApiResponse {
  constructor(raw) {
    _defineProperty$1(this, "raw", void 0);
    this.raw = raw;
  }
  async value() {
    return undefined;
  }
}
class BlobApiResponse {
  constructor(raw) {
    _defineProperty$1(this, "raw", void 0);
    this.raw = raw;
  }
  async value() {
    return await this.raw.blob();
  }
}
class TextApiResponse {
  constructor(raw) {
    _defineProperty$1(this, "raw", void 0);
    this.raw = raw;
  }
  async value() {
    return await this.raw.text();
  }
}

/* tslint:disable */
/* eslint-disable */
// @ts-nocheck
/**
 * API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * Check if a given object implements the Access interface.
 */
function instanceOfAccess(value) {
  let isInstance = true;
  isInstance = isInstance && "stream" in value && value["stream"] !== undefined;
  isInstance = isInstance && "download" in value && value["download"] !== undefined;
  return isInstance;
}
function AccessFromJSON(json) {
  return AccessFromJSONTyped(json);
}
function AccessFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'stream': json['stream'],
    'download': json['download']
  };
}
function AccessToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'stream': value.stream,
    'download': value.download
  };
}

/* tslint:disable */
/* eslint-disable */
// @ts-nocheck
/**
 * API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * Check if a given object implements the FollowGate interface.
 */
function instanceOfFollowGate(value) {
  let isInstance = true;
  isInstance = isInstance && "followUserId" in value && value["followUserId"] !== undefined;
  return isInstance;
}
function FollowGateFromJSON(json) {
  return FollowGateFromJSONTyped(json);
}
function FollowGateFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'followUserId': json['follow_user_id']
  };
}
function FollowGateToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'follow_user_id': value.followUserId
  };
}

/* tslint:disable */
/**
 * @export
 */
const NftCollectionChainEnum = {
  Eth: 'eth',
  Sol: 'sol'
};
/**
 * @export
 */
const NftCollectionStandardEnum = {
  Erc721: 'ERC721',
  Erc1155: 'ERC1155'
};
/**
 * Check if a given object implements the NftCollection interface.
 */
function instanceOfNftCollection(value) {
  let isInstance = true;
  isInstance = isInstance && "chain" in value && value["chain"] !== undefined;
  isInstance = isInstance && "address" in value && value["address"] !== undefined;
  isInstance = isInstance && "name" in value && value["name"] !== undefined;
  return isInstance;
}
function NftCollectionFromJSON(json) {
  return NftCollectionFromJSONTyped(json);
}
function NftCollectionFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'chain': json['chain'],
    'standard': !exists(json, 'standard') ? undefined : json['standard'],
    'address': json['address'],
    'name': json['name'],
    'imageUrl': !exists(json, 'imageUrl') ? undefined : json['imageUrl'],
    'externalLink': !exists(json, 'externalLink') ? undefined : json['externalLink']
  };
}
function NftCollectionToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'chain': value.chain,
    'standard': value.standard,
    'address': value.address,
    'name': value.name,
    'imageUrl': value.imageUrl,
    'externalLink': value.externalLink
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the NftGate interface.
 */
function instanceOfNftGate(value) {
  let isInstance = true;
  isInstance = isInstance && "nftCollection" in value && value["nftCollection"] !== undefined;
  return isInstance;
}
function NftGateFromJSON(json) {
  return NftGateFromJSONTyped(json);
}
function NftGateFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'nftCollection': NftCollectionFromJSON(json['nft_collection'])
  };
}
function NftGateToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'nft_collection': NftCollectionToJSON(value.nftCollection)
  };
}

/* tslint:disable */
/* eslint-disable */
// @ts-nocheck
/**
 * API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * Check if a given object implements the UsdcGate interface.
 */
function instanceOfUsdcGate(value) {
  let isInstance = true;
  isInstance = isInstance && "splits" in value && value["splits"] !== undefined;
  isInstance = isInstance && "price" in value && value["price"] !== undefined;
  return isInstance;
}
function UsdcGateFromJSON(json) {
  return UsdcGateFromJSONTyped(json);
}
function UsdcGateFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'splits': json['splits'],
    'price': json['price']
  };
}
function UsdcGateToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'splits': value.splits,
    'price': value.price
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the PurchaseGate interface.
 */
function instanceOfPurchaseGate(value) {
  let isInstance = true;
  isInstance = isInstance && "usdcPurchase" in value && value["usdcPurchase"] !== undefined;
  return isInstance;
}
function PurchaseGateFromJSON(json) {
  return PurchaseGateFromJSONTyped(json);
}
function PurchaseGateFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'usdcPurchase': UsdcGateFromJSON(json['usdc_purchase'])
  };
}
function PurchaseGateToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'usdc_purchase': UsdcGateToJSON(value.usdcPurchase)
  };
}

/* tslint:disable */
/* eslint-disable */
// @ts-nocheck
/**
 * API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * Check if a given object implements the TipGate interface.
 */
function instanceOfTipGate(value) {
  let isInstance = true;
  isInstance = isInstance && "tipUserId" in value && value["tipUserId"] !== undefined;
  return isInstance;
}
function TipGateFromJSON(json) {
  return TipGateFromJSONTyped(json);
}
function TipGateFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'tipUserId': json['tip_user_id']
  };
}
function TipGateToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'tip_user_id': value.tipUserId
  };
}

/* tslint:disable */
/* eslint-disable */
// @ts-nocheck
/**
 * API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * Check if a given object implements the ExtendedTokenGate interface.
 */
function instanceOfExtendedTokenGate(value) {
  let isInstance = true;
  isInstance = isInstance && "tokenMint" in value && value["tokenMint"] !== undefined;
  isInstance = isInstance && "tokenAmount" in value && value["tokenAmount"] !== undefined;
  return isInstance;
}
function ExtendedTokenGateFromJSON(json) {
  return ExtendedTokenGateFromJSONTyped(json);
}
function ExtendedTokenGateFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'tokenMint': json['token_mint'],
    'tokenAmount': json['token_amount']
  };
}
function ExtendedTokenGateToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'token_mint': value.tokenMint,
    'token_amount': value.tokenAmount
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the TokenGate interface.
 */
function instanceOfTokenGate(value) {
  let isInstance = true;
  isInstance = isInstance && "tokenGate" in value && value["tokenGate"] !== undefined;
  return isInstance;
}
function TokenGateFromJSON(json) {
  return TokenGateFromJSONTyped(json);
}
function TokenGateFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'tokenGate': ExtendedTokenGateFromJSON(json['token_gate'])
  };
}
function TokenGateToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'token_gate': ExtendedTokenGateToJSON(value.tokenGate)
  };
}

/* tslint:disable */
function AccessGateFromJSON(json) {
  return AccessGateFromJSONTyped(json);
}
function AccessGateFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    ...FollowGateFromJSONTyped(json),
    ...NftGateFromJSONTyped(json),
    ...PurchaseGateFromJSONTyped(json),
    ...TipGateFromJSONTyped(json),
    ...TokenGateFromJSONTyped(json)
  };
}
function AccessGateToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  if (instanceOfFollowGate(value)) {
    return FollowGateToJSON(value);
  }
  if (instanceOfNftGate(value)) {
    return NftGateToJSON(value);
  }
  if (instanceOfPurchaseGate(value)) {
    return PurchaseGateToJSON(value);
  }
  if (instanceOfTipGate(value)) {
    return TipGateToJSON(value);
  }
  if (instanceOfTokenGate(value)) {
    return TokenGateToJSON(value);
  }
  return {};
}

/* tslint:disable */
/**
 * Check if a given object implements the AccountCollectionUser interface.
 */
function instanceOfAccountCollectionUser(value) {
  let isInstance = true;
  isInstance = isInstance && "id" in value && value["id"] !== undefined;
  isInstance = isInstance && "handle" in value && value["handle"] !== undefined;
  return isInstance;
}
function AccountCollectionUserFromJSON(json) {
  return AccountCollectionUserFromJSONTyped(json);
}
function AccountCollectionUserFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'id': json['id'],
    'handle': json['handle'],
    'isDeactivated': !exists(json, 'is_deactivated') ? undefined : json['is_deactivated']
  };
}
function AccountCollectionUserToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'id': value.id,
    'handle': value.handle,
    'is_deactivated': value.isDeactivated
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the AccountCollection interface.
 */
function instanceOfAccountCollection(value) {
  let isInstance = true;
  isInstance = isInstance && "id" in value && value["id"] !== undefined;
  isInstance = isInstance && "isAlbum" in value && value["isAlbum"] !== undefined;
  isInstance = isInstance && "name" in value && value["name"] !== undefined;
  isInstance = isInstance && "permalink" in value && value["permalink"] !== undefined;
  isInstance = isInstance && "user" in value && value["user"] !== undefined;
  return isInstance;
}
function AccountCollectionFromJSON(json) {
  return AccountCollectionFromJSONTyped(json);
}
function AccountCollectionFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'id': json['id'],
    'isAlbum': json['is_album'],
    'name': json['name'],
    'permalink': json['permalink'],
    'user': AccountCollectionUserFromJSON(json['user'])
  };
}
function AccountCollectionToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'id': value.id,
    'is_album': value.isAlbum,
    'name': value.name,
    'permalink': value.permalink,
    'user': AccountCollectionUserToJSON(value.user)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the PlaylistLibrary interface.
 */
function instanceOfPlaylistLibrary(value) {
  let isInstance = true;
  return isInstance;
}
function PlaylistLibraryFromJSON(json) {
  return PlaylistLibraryFromJSONTyped(json);
}
function PlaylistLibraryFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'contents': !exists(json, 'contents') ? undefined : json['contents']
  };
}
function PlaylistLibraryToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'contents': value.contents
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the CoverPhoto interface.
 */
function instanceOfCoverPhoto(value) {
  let isInstance = true;
  return isInstance;
}
function CoverPhotoFromJSON(json) {
  return CoverPhotoFromJSONTyped(json);
}
function CoverPhotoFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    '_640x': !exists(json, '640x') ? undefined : json['640x'],
    '_2000x': !exists(json, '2000x') ? undefined : json['2000x']
  };
}
function CoverPhotoToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    '640x': value._640x,
    '2000x': value._2000x
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the CoverPhotoFull interface.
 */
function instanceOfCoverPhotoFull(value) {
  let isInstance = true;
  return isInstance;
}
function CoverPhotoFullFromJSON(json) {
  return CoverPhotoFullFromJSONTyped(json);
}
function CoverPhotoFullFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    '_640x': !exists(json, '640x') ? undefined : json['640x'],
    '_2000x': !exists(json, '2000x') ? undefined : json['2000x'],
    'mirrors': !exists(json, 'mirrors') ? undefined : json['mirrors']
  };
}
function CoverPhotoFullToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    '640x': value._640x,
    '2000x': value._2000x,
    'mirrors': value.mirrors
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the ProfilePicture interface.
 */
function instanceOfProfilePicture(value) {
  let isInstance = true;
  return isInstance;
}
function ProfilePictureFromJSON(json) {
  return ProfilePictureFromJSONTyped(json);
}
function ProfilePictureFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    '_150x150': !exists(json, '150x150') ? undefined : json['150x150'],
    '_480x480': !exists(json, '480x480') ? undefined : json['480x480'],
    '_1000x1000': !exists(json, '1000x1000') ? undefined : json['1000x1000']
  };
}
function ProfilePictureToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    '150x150': value._150x150,
    '480x480': value._480x480,
    '1000x1000': value._1000x1000
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the ProfilePictureFull interface.
 */
function instanceOfProfilePictureFull(value) {
  let isInstance = true;
  return isInstance;
}
function ProfilePictureFullFromJSON(json) {
  return ProfilePictureFullFromJSONTyped(json);
}
function ProfilePictureFullFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    '_150x150': !exists(json, '150x150') ? undefined : json['150x150'],
    '_480x480': !exists(json, '480x480') ? undefined : json['480x480'],
    '_1000x1000': !exists(json, '1000x1000') ? undefined : json['1000x1000'],
    'mirrors': !exists(json, 'mirrors') ? undefined : json['mirrors']
  };
}
function ProfilePictureFullToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    '150x150': value._150x150,
    '480x480': value._480x480,
    '1000x1000': value._1000x1000,
    'mirrors': value.mirrors
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the UserFullArtistCoinBadge interface.
 */
function instanceOfUserFullArtistCoinBadge(value) {
  let isInstance = true;
  return isInstance;
}
function UserFullArtistCoinBadgeFromJSON(json) {
  return UserFullArtistCoinBadgeFromJSONTyped(json);
}
function UserFullArtistCoinBadgeFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'mint': !exists(json, 'mint') ? undefined : json['mint'],
    'logoUri': !exists(json, 'logo_uri') ? undefined : json['logo_uri'],
    'ticker': !exists(json, 'ticker') ? undefined : json['ticker']
  };
}
function UserFullArtistCoinBadgeToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'mint': value.mint,
    'logo_uri': value.logoUri,
    'ticker': value.ticker
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the UserFull interface.
 */
function instanceOfUserFull(value) {
  let isInstance = true;
  isInstance = isInstance && "albumCount" in value && value["albumCount"] !== undefined;
  isInstance = isInstance && "artistCoinBadge" in value && value["artistCoinBadge"] !== undefined;
  isInstance = isInstance && "followeeCount" in value && value["followeeCount"] !== undefined;
  isInstance = isInstance && "followerCount" in value && value["followerCount"] !== undefined;
  isInstance = isInstance && "handle" in value && value["handle"] !== undefined;
  isInstance = isInstance && "id" in value && value["id"] !== undefined;
  isInstance = isInstance && "isVerified" in value && value["isVerified"] !== undefined;
  isInstance = isInstance && "verifiedWithTwitter" in value && value["verifiedWithTwitter"] !== undefined;
  isInstance = isInstance && "verifiedWithInstagram" in value && value["verifiedWithInstagram"] !== undefined;
  isInstance = isInstance && "verifiedWithTiktok" in value && value["verifiedWithTiktok"] !== undefined;
  isInstance = isInstance && "name" in value && value["name"] !== undefined;
  isInstance = isInstance && "playlistCount" in value && value["playlistCount"] !== undefined;
  isInstance = isInstance && "repostCount" in value && value["repostCount"] !== undefined;
  isInstance = isInstance && "trackCount" in value && value["trackCount"] !== undefined;
  isInstance = isInstance && "isDeactivated" in value && value["isDeactivated"] !== undefined;
  isInstance = isInstance && "isAvailable" in value && value["isAvailable"] !== undefined;
  isInstance = isInstance && "ercWallet" in value && value["ercWallet"] !== undefined;
  isInstance = isInstance && "splWallet" in value && value["splWallet"] !== undefined;
  isInstance = isInstance && "splUsdcWallet" in value && value["splUsdcWallet"] !== undefined;
  isInstance = isInstance && "supporterCount" in value && value["supporterCount"] !== undefined;
  isInstance = isInstance && "supportingCount" in value && value["supportingCount"] !== undefined;
  isInstance = isInstance && "totalAudioBalance" in value && value["totalAudioBalance"] !== undefined;
  isInstance = isInstance && "wallet" in value && value["wallet"] !== undefined;
  isInstance = isInstance && "balance" in value && value["balance"] !== undefined;
  isInstance = isInstance && "associatedWalletsBalance" in value && value["associatedWalletsBalance"] !== undefined;
  isInstance = isInstance && "totalBalance" in value && value["totalBalance"] !== undefined;
  isInstance = isInstance && "waudioBalance" in value && value["waudioBalance"] !== undefined;
  isInstance = isInstance && "associatedSolWalletsBalance" in value && value["associatedSolWalletsBalance"] !== undefined;
  isInstance = isInstance && "blocknumber" in value && value["blocknumber"] !== undefined;
  isInstance = isInstance && "createdAt" in value && value["createdAt"] !== undefined;
  isInstance = isInstance && "isStorageV2" in value && value["isStorageV2"] !== undefined;
  isInstance = isInstance && "currentUserFolloweeFollowCount" in value && value["currentUserFolloweeFollowCount"] !== undefined;
  isInstance = isInstance && "doesCurrentUserFollow" in value && value["doesCurrentUserFollow"] !== undefined;
  isInstance = isInstance && "doesCurrentUserSubscribe" in value && value["doesCurrentUserSubscribe"] !== undefined;
  isInstance = isInstance && "doesFollowCurrentUser" in value && value["doesFollowCurrentUser"] !== undefined;
  isInstance = isInstance && "handleLc" in value && value["handleLc"] !== undefined;
  isInstance = isInstance && "updatedAt" in value && value["updatedAt"] !== undefined;
  isInstance = isInstance && "hasCollectibles" in value && value["hasCollectibles"] !== undefined;
  isInstance = isInstance && "allowAiAttribution" in value && value["allowAiAttribution"] !== undefined;
  return isInstance;
}
function UserFullFromJSON(json) {
  return UserFullFromJSONTyped(json);
}
function UserFullFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'albumCount': json['album_count'],
    'artistPickTrackId': !exists(json, 'artist_pick_track_id') ? undefined : json['artist_pick_track_id'],
    'artistCoinBadge': UserFullArtistCoinBadgeFromJSON(json['artist_coin_badge']),
    'bio': !exists(json, 'bio') ? undefined : json['bio'],
    'coverPhoto': !exists(json, 'cover_photo') ? undefined : CoverPhotoFullFromJSON(json['cover_photo']),
    'followeeCount': json['followee_count'],
    'followerCount': json['follower_count'],
    'handle': json['handle'],
    'id': json['id'],
    'isVerified': json['is_verified'],
    'twitterHandle': !exists(json, 'twitter_handle') ? undefined : json['twitter_handle'],
    'instagramHandle': !exists(json, 'instagram_handle') ? undefined : json['instagram_handle'],
    'tiktokHandle': !exists(json, 'tiktok_handle') ? undefined : json['tiktok_handle'],
    'verifiedWithTwitter': json['verified_with_twitter'],
    'verifiedWithInstagram': json['verified_with_instagram'],
    'verifiedWithTiktok': json['verified_with_tiktok'],
    'website': !exists(json, 'website') ? undefined : json['website'],
    'donation': !exists(json, 'donation') ? undefined : json['donation'],
    'location': !exists(json, 'location') ? undefined : json['location'],
    'name': json['name'],
    'playlistCount': json['playlist_count'],
    'profilePicture': !exists(json, 'profile_picture') ? undefined : ProfilePictureFullFromJSON(json['profile_picture']),
    'repostCount': json['repost_count'],
    'trackCount': json['track_count'],
    'isDeactivated': json['is_deactivated'],
    'isAvailable': json['is_available'],
    'ercWallet': json['erc_wallet'],
    'splWallet': json['spl_wallet'],
    'splUsdcWallet': json['spl_usdc_wallet'],
    'splUsdcPayoutWallet': !exists(json, 'spl_usdc_payout_wallet') ? undefined : json['spl_usdc_payout_wallet'],
    'supporterCount': json['supporter_count'],
    'supportingCount': json['supporting_count'],
    'totalAudioBalance': json['total_audio_balance'],
    'wallet': json['wallet'],
    'balance': json['balance'],
    'associatedWalletsBalance': json['associated_wallets_balance'],
    'totalBalance': json['total_balance'],
    'waudioBalance': json['waudio_balance'],
    'associatedSolWalletsBalance': json['associated_sol_wallets_balance'],
    'blocknumber': json['blocknumber'],
    'createdAt': json['created_at'],
    'isStorageV2': json['is_storage_v2'],
    'creatorNodeEndpoint': !exists(json, 'creator_node_endpoint') ? undefined : json['creator_node_endpoint'],
    'currentUserFolloweeFollowCount': json['current_user_followee_follow_count'],
    'doesCurrentUserFollow': json['does_current_user_follow'],
    'doesCurrentUserSubscribe': json['does_current_user_subscribe'],
    'doesFollowCurrentUser': json['does_follow_current_user'],
    'handleLc': json['handle_lc'],
    'updatedAt': json['updated_at'],
    'coverPhotoSizes': !exists(json, 'cover_photo_sizes') ? undefined : json['cover_photo_sizes'],
    'coverPhotoCids': !exists(json, 'cover_photo_cids') ? undefined : CoverPhotoFromJSON(json['cover_photo_cids']),
    'coverPhotoLegacy': !exists(json, 'cover_photo_legacy') ? undefined : json['cover_photo_legacy'],
    'profilePictureSizes': !exists(json, 'profile_picture_sizes') ? undefined : json['profile_picture_sizes'],
    'profilePictureCids': !exists(json, 'profile_picture_cids') ? undefined : ProfilePictureFromJSON(json['profile_picture_cids']),
    'profilePictureLegacy': !exists(json, 'profile_picture_legacy') ? undefined : json['profile_picture_legacy'],
    'hasCollectibles': json['has_collectibles'],
    'playlistLibrary': !exists(json, 'playlist_library') ? undefined : PlaylistLibraryFromJSON(json['playlist_library']),
    'allowAiAttribution': json['allow_ai_attribution'],
    'profileType': !exists(json, 'profile_type') ? undefined : json['profile_type']
  };
}
function UserFullToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'album_count': value.albumCount,
    'artist_pick_track_id': value.artistPickTrackId,
    'artist_coin_badge': UserFullArtistCoinBadgeToJSON(value.artistCoinBadge),
    'bio': value.bio,
    'cover_photo': CoverPhotoFullToJSON(value.coverPhoto),
    'followee_count': value.followeeCount,
    'follower_count': value.followerCount,
    'handle': value.handle,
    'id': value.id,
    'is_verified': value.isVerified,
    'twitter_handle': value.twitterHandle,
    'instagram_handle': value.instagramHandle,
    'tiktok_handle': value.tiktokHandle,
    'verified_with_twitter': value.verifiedWithTwitter,
    'verified_with_instagram': value.verifiedWithInstagram,
    'verified_with_tiktok': value.verifiedWithTiktok,
    'website': value.website,
    'donation': value.donation,
    'location': value.location,
    'name': value.name,
    'playlist_count': value.playlistCount,
    'profile_picture': ProfilePictureFullToJSON(value.profilePicture),
    'repost_count': value.repostCount,
    'track_count': value.trackCount,
    'is_deactivated': value.isDeactivated,
    'is_available': value.isAvailable,
    'erc_wallet': value.ercWallet,
    'spl_wallet': value.splWallet,
    'spl_usdc_wallet': value.splUsdcWallet,
    'spl_usdc_payout_wallet': value.splUsdcPayoutWallet,
    'supporter_count': value.supporterCount,
    'supporting_count': value.supportingCount,
    'total_audio_balance': value.totalAudioBalance,
    'wallet': value.wallet,
    'balance': value.balance,
    'associated_wallets_balance': value.associatedWalletsBalance,
    'total_balance': value.totalBalance,
    'waudio_balance': value.waudioBalance,
    'associated_sol_wallets_balance': value.associatedSolWalletsBalance,
    'blocknumber': value.blocknumber,
    'created_at': value.createdAt,
    'is_storage_v2': value.isStorageV2,
    'creator_node_endpoint': value.creatorNodeEndpoint,
    'current_user_followee_follow_count': value.currentUserFolloweeFollowCount,
    'does_current_user_follow': value.doesCurrentUserFollow,
    'does_current_user_subscribe': value.doesCurrentUserSubscribe,
    'does_follow_current_user': value.doesFollowCurrentUser,
    'handle_lc': value.handleLc,
    'updated_at': value.updatedAt,
    'cover_photo_sizes': value.coverPhotoSizes,
    'cover_photo_cids': CoverPhotoToJSON(value.coverPhotoCids),
    'cover_photo_legacy': value.coverPhotoLegacy,
    'profile_picture_sizes': value.profilePictureSizes,
    'profile_picture_cids': ProfilePictureToJSON(value.profilePictureCids),
    'profile_picture_legacy': value.profilePictureLegacy,
    'has_collectibles': value.hasCollectibles,
    'playlist_library': PlaylistLibraryToJSON(value.playlistLibrary),
    'allow_ai_attribution': value.allowAiAttribution,
    'profile_type': value.profileType
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the AccountFull interface.
 */
function instanceOfAccountFull(value) {
  let isInstance = true;
  isInstance = isInstance && "user" in value && value["user"] !== undefined;
  isInstance = isInstance && "playlists" in value && value["playlists"] !== undefined;
  isInstance = isInstance && "trackSaveCount" in value && value["trackSaveCount"] !== undefined;
  return isInstance;
}
function AccountFullFromJSON(json) {
  return AccountFullFromJSONTyped(json);
}
function AccountFullFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'user': UserFullFromJSON(json['user']),
    'playlists': json['playlists'].map(AccountCollectionFromJSON),
    'playlistLibrary': !exists(json, 'playlist_library') ? undefined : PlaylistLibraryFromJSON(json['playlist_library']),
    'trackSaveCount': json['track_save_count']
  };
}
function AccountFullToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'user': UserFullToJSON(value.user),
    'playlists': value.playlists.map(AccountCollectionToJSON),
    'playlist_library': PlaylistLibraryToJSON(value.playlistLibrary),
    'track_save_count': value.trackSaveCount
  };
}

/* tslint:disable */
/**
 * @export
 */
const ActivityFullItemTypeEnum = {
  Track: 'track',
  Playlist: 'playlist'
};
/**
 * Check if a given object implements the ActivityFull interface.
 */
function instanceOfActivityFull(value) {
  let isInstance = true;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== undefined;
  isInstance = isInstance && "itemType" in value && value["itemType"] !== undefined;
  isInstance = isInstance && "item" in value && value["item"] !== undefined;
  isInstance = isInstance && "_class" in value && value["_class"] !== undefined;
  return isInstance;
}
function ActivityFullFromJSON(json) {
  return ActivityFullFromJSONTyped(json, false);
}
function ActivityFullFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  if (!ignoreDiscriminator) {
    if (json['_class'] === 'collection_activity_full') {
      return CollectionActivityFullFromJSONTyped(json, true);
    }
    if (json['_class'] === 'collection_activity_full_without_tracks') {
      return CollectionActivityFullWithoutTracksFromJSONTyped(json, true);
    }
    if (json['_class'] === 'track_activity_full') {
      return TrackActivityFullFromJSONTyped(json, true);
    }
  }
  return {
    'timestamp': json['timestamp'],
    'itemType': json['item_type'],
    'item': json['item'],
    '_class': json['class']
  };
}
function ActivityFullToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'timestamp': value.timestamp,
    'item_type': value.itemType,
    'item': value.item,
    'class': value._class
  };
}

/* tslint:disable */
/* eslint-disable */
// @ts-nocheck
/**
 * API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * Check if a given object implements the AlbumBacklink interface.
 */
function instanceOfAlbumBacklink(value) {
  let isInstance = true;
  isInstance = isInstance && "playlistId" in value && value["playlistId"] !== undefined;
  isInstance = isInstance && "playlistName" in value && value["playlistName"] !== undefined;
  isInstance = isInstance && "permalink" in value && value["permalink"] !== undefined;
  return isInstance;
}
function AlbumBacklinkFromJSON(json) {
  return AlbumBacklinkFromJSONTyped(json);
}
function AlbumBacklinkFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'playlistId': json['playlist_id'],
    'playlistName': json['playlist_name'],
    'permalink': json['permalink']
  };
}
function AlbumBacklinkToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'playlist_id': value.playlistId,
    'playlist_name': value.playlistName,
    'permalink': value.permalink
  };
}

/* tslint:disable */
/* eslint-disable */
// @ts-nocheck
/**
 * API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * Check if a given object implements the Favorite interface.
 */
function instanceOfFavorite(value) {
  let isInstance = true;
  isInstance = isInstance && "favoriteItemId" in value && value["favoriteItemId"] !== undefined;
  isInstance = isInstance && "favoriteType" in value && value["favoriteType"] !== undefined;
  isInstance = isInstance && "userId" in value && value["userId"] !== undefined;
  isInstance = isInstance && "createdAt" in value && value["createdAt"] !== undefined;
  return isInstance;
}
function FavoriteFromJSON(json) {
  return FavoriteFromJSONTyped(json);
}
function FavoriteFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'favoriteItemId': json['favorite_item_id'],
    'favoriteType': json['favorite_type'],
    'userId': json['user_id'],
    'createdAt': json['created_at']
  };
}
function FavoriteToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'favorite_item_id': value.favoriteItemId,
    'favorite_type': value.favoriteType,
    'user_id': value.userId,
    'created_at': value.createdAt
  };
}

/* tslint:disable */
/* eslint-disable */
// @ts-nocheck
/**
 * API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * Check if a given object implements the PlaylistAddedTimestamp interface.
 */
function instanceOfPlaylistAddedTimestamp(value) {
  let isInstance = true;
  isInstance = isInstance && "metadataTimestamp" in value && value["metadataTimestamp"] !== undefined;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== undefined;
  isInstance = isInstance && "trackId" in value && value["trackId"] !== undefined;
  return isInstance;
}
function PlaylistAddedTimestampFromJSON(json) {
  return PlaylistAddedTimestampFromJSONTyped(json);
}
function PlaylistAddedTimestampFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'metadataTimestamp': json['metadata_timestamp'],
    'timestamp': json['timestamp'],
    'trackId': json['track_id']
  };
}
function PlaylistAddedTimestampToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'metadata_timestamp': value.metadataTimestamp,
    'timestamp': value.timestamp,
    'track_id': value.trackId
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the PlaylistArtwork interface.
 */
function instanceOfPlaylistArtwork(value) {
  let isInstance = true;
  return isInstance;
}
function PlaylistArtworkFromJSON(json) {
  return PlaylistArtworkFromJSONTyped(json);
}
function PlaylistArtworkFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    '_150x150': !exists(json, '150x150') ? undefined : json['150x150'],
    '_480x480': !exists(json, '480x480') ? undefined : json['480x480'],
    '_1000x1000': !exists(json, '1000x1000') ? undefined : json['1000x1000']
  };
}
function PlaylistArtworkToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    '150x150': value._150x150,
    '480x480': value._480x480,
    '1000x1000': value._1000x1000
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the PlaylistArtworkFull interface.
 */
function instanceOfPlaylistArtworkFull(value) {
  let isInstance = true;
  return isInstance;
}
function PlaylistArtworkFullFromJSON(json) {
  return PlaylistArtworkFullFromJSONTyped(json);
}
function PlaylistArtworkFullFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    '_150x150': !exists(json, '150x150') ? undefined : json['150x150'],
    '_480x480': !exists(json, '480x480') ? undefined : json['480x480'],
    '_1000x1000': !exists(json, '1000x1000') ? undefined : json['1000x1000'],
    'mirrors': !exists(json, 'mirrors') ? undefined : json['mirrors']
  };
}
function PlaylistArtworkFullToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    '150x150': value._150x150,
    '480x480': value._480x480,
    '1000x1000': value._1000x1000,
    'mirrors': value.mirrors
  };
}

/* tslint:disable */
/* eslint-disable */
// @ts-nocheck
/**
 * API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * Check if a given object implements the Repost interface.
 */
function instanceOfRepost(value) {
  let isInstance = true;
  isInstance = isInstance && "repostItemId" in value && value["repostItemId"] !== undefined;
  isInstance = isInstance && "repostType" in value && value["repostType"] !== undefined;
  isInstance = isInstance && "userId" in value && value["userId"] !== undefined;
  return isInstance;
}
function RepostFromJSON(json) {
  return RepostFromJSONTyped(json);
}
function RepostFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'repostItemId': json['repost_item_id'],
    'repostType': json['repost_type'],
    'userId': json['user_id']
  };
}
function RepostToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'repost_item_id': value.repostItemId,
    'repost_type': value.repostType,
    'user_id': value.userId
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the CoverArt interface.
 */
function instanceOfCoverArt(value) {
  let isInstance = true;
  return isInstance;
}
function CoverArtFromJSON(json) {
  return CoverArtFromJSONTyped(json);
}
function CoverArtFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    '_150x150': !exists(json, '150x150') ? undefined : json['150x150'],
    '_480x480': !exists(json, '480x480') ? undefined : json['480x480'],
    '_1000x1000': !exists(json, '1000x1000') ? undefined : json['1000x1000']
  };
}
function CoverArtToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    '150x150': value._150x150,
    '480x480': value._480x480,
    '1000x1000': value._1000x1000
  };
}

/* tslint:disable */
/* eslint-disable */
// @ts-nocheck
/**
 * API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * Check if a given object implements the FieldVisibility interface.
 */
function instanceOfFieldVisibility(value) {
  let isInstance = true;
  isInstance = isInstance && "mood" in value && value["mood"] !== undefined;
  isInstance = isInstance && "tags" in value && value["tags"] !== undefined;
  isInstance = isInstance && "genre" in value && value["genre"] !== undefined;
  isInstance = isInstance && "share" in value && value["share"] !== undefined;
  isInstance = isInstance && "playCount" in value && value["playCount"] !== undefined;
  isInstance = isInstance && "remixes" in value && value["remixes"] !== undefined;
  return isInstance;
}
function FieldVisibilityFromJSON(json) {
  return FieldVisibilityFromJSONTyped(json);
}
function FieldVisibilityFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'mood': json['mood'],
    'tags': json['tags'],
    'genre': json['genre'],
    'share': json['share'],
    'playCount': json['play_count'],
    'remixes': json['remixes']
  };
}
function FieldVisibilityToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'mood': value.mood,
    'tags': value.tags,
    'genre': value.genre,
    'share': value.share,
    'play_count': value.playCount,
    'remixes': value.remixes
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the FullRemix interface.
 */
function instanceOfFullRemix(value) {
  let isInstance = true;
  isInstance = isInstance && "parentTrackId" in value && value["parentTrackId"] !== undefined;
  isInstance = isInstance && "user" in value && value["user"] !== undefined;
  isInstance = isInstance && "hasRemixAuthorReposted" in value && value["hasRemixAuthorReposted"] !== undefined;
  isInstance = isInstance && "hasRemixAuthorSaved" in value && value["hasRemixAuthorSaved"] !== undefined;
  return isInstance;
}
function FullRemixFromJSON(json) {
  return FullRemixFromJSONTyped(json);
}
function FullRemixFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'parentTrackId': json['parent_track_id'],
    'user': UserFullFromJSON(json['user']),
    'hasRemixAuthorReposted': json['has_remix_author_reposted'],
    'hasRemixAuthorSaved': json['has_remix_author_saved']
  };
}
function FullRemixToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'parent_track_id': value.parentTrackId,
    'user': UserFullToJSON(value.user),
    'has_remix_author_reposted': value.hasRemixAuthorReposted,
    'has_remix_author_saved': value.hasRemixAuthorSaved
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the FullRemixParent interface.
 */
function instanceOfFullRemixParent(value) {
  let isInstance = true;
  return isInstance;
}
function FullRemixParentFromJSON(json) {
  return FullRemixParentFromJSONTyped(json);
}
function FullRemixParentFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'tracks': !exists(json, 'tracks') ? undefined : json['tracks'].map(FullRemixFromJSON)
  };
}
function FullRemixParentToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'tracks': value.tracks === undefined ? undefined : value.tracks.map(FullRemixToJSON)
  };
}

/* tslint:disable */
/* eslint-disable */
// @ts-nocheck
/**
 * API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * Check if a given object implements the StemParent interface.
 */
function instanceOfStemParent(value) {
  let isInstance = true;
  isInstance = isInstance && "category" in value && value["category"] !== undefined;
  isInstance = isInstance && "parentTrackId" in value && value["parentTrackId"] !== undefined;
  return isInstance;
}
function StemParentFromJSON(json) {
  return StemParentFromJSONTyped(json);
}
function StemParentFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'category': json['category'],
    'parentTrackId': json['parent_track_id']
  };
}
function StemParentToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'category': value.category,
    'parent_track_id': value.parentTrackId
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the TrackArtworkFull interface.
 */
function instanceOfTrackArtworkFull(value) {
  let isInstance = true;
  return isInstance;
}
function TrackArtworkFullFromJSON(json) {
  return TrackArtworkFullFromJSONTyped(json);
}
function TrackArtworkFullFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    '_150x150': !exists(json, '150x150') ? undefined : json['150x150'],
    '_480x480': !exists(json, '480x480') ? undefined : json['480x480'],
    '_1000x1000': !exists(json, '1000x1000') ? undefined : json['1000x1000'],
    'mirrors': !exists(json, 'mirrors') ? undefined : json['mirrors']
  };
}
function TrackArtworkFullToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    '150x150': value._150x150,
    '480x480': value._480x480,
    '1000x1000': value._1000x1000,
    'mirrors': value.mirrors
  };
}

/* tslint:disable */
/* eslint-disable */
// @ts-nocheck
/**
 * API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * Check if a given object implements the TrackSegment interface.
 */
function instanceOfTrackSegment(value) {
  let isInstance = true;
  isInstance = isInstance && "duration" in value && value["duration"] !== undefined;
  isInstance = isInstance && "multihash" in value && value["multihash"] !== undefined;
  return isInstance;
}
function TrackSegmentFromJSON(json) {
  return TrackSegmentFromJSONTyped(json);
}
function TrackSegmentFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'duration': json['duration'],
    'multihash': json['multihash']
  };
}
function TrackSegmentToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'duration': value.duration,
    'multihash': value.multihash
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the UrlWithMirrors interface.
 */
function instanceOfUrlWithMirrors(value) {
  let isInstance = true;
  isInstance = isInstance && "mirrors" in value && value["mirrors"] !== undefined;
  return isInstance;
}
function UrlWithMirrorsFromJSON(json) {
  return UrlWithMirrorsFromJSONTyped(json);
}
function UrlWithMirrorsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'url': !exists(json, 'url') ? undefined : json['url'],
    'mirrors': json['mirrors']
  };
}
function UrlWithMirrorsToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'url': value.url,
    'mirrors': value.mirrors
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the TrackFull interface.
 */
function instanceOfTrackFull(value) {
  let isInstance = true;
  isInstance = isInstance && "artwork" in value && value["artwork"] !== undefined;
  isInstance = isInstance && "genre" in value && value["genre"] !== undefined;
  isInstance = isInstance && "id" in value && value["id"] !== undefined;
  isInstance = isInstance && "isOriginalAvailable" in value && value["isOriginalAvailable"] !== undefined;
  isInstance = isInstance && "remixOf" in value && value["remixOf"] !== undefined;
  isInstance = isInstance && "repostCount" in value && value["repostCount"] !== undefined;
  isInstance = isInstance && "favoriteCount" in value && value["favoriteCount"] !== undefined;
  isInstance = isInstance && "commentCount" in value && value["commentCount"] !== undefined;
  isInstance = isInstance && "title" in value && value["title"] !== undefined;
  isInstance = isInstance && "user" in value && value["user"] !== undefined;
  isInstance = isInstance && "duration" in value && value["duration"] !== undefined;
  isInstance = isInstance && "isDownloadable" in value && value["isDownloadable"] !== undefined;
  isInstance = isInstance && "playCount" in value && value["playCount"] !== undefined;
  isInstance = isInstance && "permalink" in value && value["permalink"] !== undefined;
  isInstance = isInstance && "access" in value && value["access"] !== undefined;
  isInstance = isInstance && "blocknumber" in value && value["blocknumber"] !== undefined;
  isInstance = isInstance && "coverArtSizes" in value && value["coverArtSizes"] !== undefined;
  isInstance = isInstance && "createdAt" in value && value["createdAt"] !== undefined;
  isInstance = isInstance && "fieldVisibility" in value && value["fieldVisibility"] !== undefined;
  isInstance = isInstance && "followeeReposts" in value && value["followeeReposts"] !== undefined;
  isInstance = isInstance && "hasCurrentUserReposted" in value && value["hasCurrentUserReposted"] !== undefined;
  isInstance = isInstance && "isScheduledRelease" in value && value["isScheduledRelease"] !== undefined;
  isInstance = isInstance && "isUnlisted" in value && value["isUnlisted"] !== undefined;
  isInstance = isInstance && "hasCurrentUserSaved" in value && value["hasCurrentUserSaved"] !== undefined;
  isInstance = isInstance && "followeeFavorites" in value && value["followeeFavorites"] !== undefined;
  isInstance = isInstance && "routeId" in value && value["routeId"] !== undefined;
  isInstance = isInstance && "trackSegments" in value && value["trackSegments"] !== undefined;
  isInstance = isInstance && "updatedAt" in value && value["updatedAt"] !== undefined;
  isInstance = isInstance && "userId" in value && value["userId"] !== undefined;
  isInstance = isInstance && "isDelete" in value && value["isDelete"] !== undefined;
  isInstance = isInstance && "isAvailable" in value && value["isAvailable"] !== undefined;
  isInstance = isInstance && "isStreamGated" in value && value["isStreamGated"] !== undefined;
  isInstance = isInstance && "isDownloadGated" in value && value["isDownloadGated"] !== undefined;
  isInstance = isInstance && "isOwnedByUser" in value && value["isOwnedByUser"] !== undefined;
  isInstance = isInstance && "stream" in value && value["stream"] !== undefined;
  isInstance = isInstance && "download" in value && value["download"] !== undefined;
  isInstance = isInstance && "preview" in value && value["preview"] !== undefined;
  return isInstance;
}
function TrackFullFromJSON(json) {
  return TrackFullFromJSONTyped(json);
}
function TrackFullFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'artwork': TrackArtworkFullFromJSON(json['artwork']),
    'description': !exists(json, 'description') ? undefined : json['description'],
    'genre': json['genre'],
    'id': json['id'],
    'trackCid': !exists(json, 'track_cid') ? undefined : json['track_cid'],
    'previewCid': !exists(json, 'preview_cid') ? undefined : json['preview_cid'],
    'origFileCid': !exists(json, 'orig_file_cid') ? undefined : json['orig_file_cid'],
    'origFilename': !exists(json, 'orig_filename') ? undefined : json['orig_filename'],
    'isOriginalAvailable': json['is_original_available'],
    'mood': !exists(json, 'mood') ? undefined : json['mood'],
    'releaseDate': !exists(json, 'release_date') ? undefined : json['release_date'],
    'remixOf': FullRemixParentFromJSON(json['remix_of']),
    'repostCount': json['repost_count'],
    'favoriteCount': json['favorite_count'],
    'commentCount': json['comment_count'],
    'tags': !exists(json, 'tags') ? undefined : json['tags'],
    'title': json['title'],
    'user': UserFullFromJSON(json['user']),
    'duration': json['duration'],
    'isDownloadable': json['is_downloadable'],
    'playCount': json['play_count'],
    'permalink': json['permalink'],
    'isStreamable': !exists(json, 'is_streamable') ? undefined : json['is_streamable'],
    'ddexApp': !exists(json, 'ddex_app') ? undefined : json['ddex_app'],
    'playlistsContainingTrack': !exists(json, 'playlists_containing_track') ? undefined : json['playlists_containing_track'],
    'pinnedCommentId': !exists(json, 'pinned_comment_id') ? undefined : json['pinned_comment_id'],
    'albumBacklink': !exists(json, 'album_backlink') ? undefined : AlbumBacklinkFromJSON(json['album_backlink']),
    'access': AccessFromJSON(json['access']),
    'blocknumber': json['blocknumber'],
    'createDate': !exists(json, 'create_date') ? undefined : json['create_date'],
    'coverArtSizes': json['cover_art_sizes'],
    'coverArtCids': !exists(json, 'cover_art_cids') ? undefined : CoverArtFromJSON(json['cover_art_cids']),
    'createdAt': json['created_at'],
    'creditsSplits': !exists(json, 'credits_splits') ? undefined : json['credits_splits'],
    'isrc': !exists(json, 'isrc') ? undefined : json['isrc'],
    'license': !exists(json, 'license') ? undefined : json['license'],
    'iswc': !exists(json, 'iswc') ? undefined : json['iswc'],
    'fieldVisibility': FieldVisibilityFromJSON(json['field_visibility']),
    'followeeReposts': json['followee_reposts'].map(RepostFromJSON),
    'hasCurrentUserReposted': json['has_current_user_reposted'],
    'isScheduledRelease': json['is_scheduled_release'],
    'isUnlisted': json['is_unlisted'],
    'hasCurrentUserSaved': json['has_current_user_saved'],
    'followeeFavorites': json['followee_favorites'].map(FavoriteFromJSON),
    'routeId': json['route_id'],
    'stemOf': !exists(json, 'stem_of') ? undefined : StemParentFromJSON(json['stem_of']),
    'trackSegments': json['track_segments'].map(TrackSegmentFromJSON),
    'updatedAt': json['updated_at'],
    'userId': json['user_id'],
    'isDelete': json['is_delete'],
    'coverArt': !exists(json, 'cover_art') ? undefined : json['cover_art'],
    'isAvailable': json['is_available'],
    'aiAttributionUserId': !exists(json, 'ai_attribution_user_id') ? undefined : json['ai_attribution_user_id'],
    'allowedApiKeys': !exists(json, 'allowed_api_keys') ? undefined : json['allowed_api_keys'],
    'audioUploadId': !exists(json, 'audio_upload_id') ? undefined : json['audio_upload_id'],
    'previewStartSeconds': !exists(json, 'preview_start_seconds') ? undefined : json['preview_start_seconds'],
    'bpm': !exists(json, 'bpm') ? undefined : json['bpm'],
    'isCustomBpm': !exists(json, 'is_custom_bpm') ? undefined : json['is_custom_bpm'],
    'musicalKey': !exists(json, 'musical_key') ? undefined : json['musical_key'],
    'isCustomMusicalKey': !exists(json, 'is_custom_musical_key') ? undefined : json['is_custom_musical_key'],
    'audioAnalysisErrorCount': !exists(json, 'audio_analysis_error_count') ? undefined : json['audio_analysis_error_count'],
    'commentsDisabled': !exists(json, 'comments_disabled') ? undefined : json['comments_disabled'],
    'ddexReleaseIds': !exists(json, 'ddex_release_ids') ? undefined : json['ddex_release_ids'],
    'artists': !exists(json, 'artists') ? undefined : json['artists'],
    'resourceContributors': !exists(json, 'resource_contributors') ? undefined : json['resource_contributors'],
    'indirectResourceContributors': !exists(json, 'indirect_resource_contributors') ? undefined : json['indirect_resource_contributors'],
    'rightsController': !exists(json, 'rights_controller') ? undefined : json['rights_controller'],
    'copyrightLine': !exists(json, 'copyright_line') ? undefined : json['copyright_line'],
    'producerCopyrightLine': !exists(json, 'producer_copyright_line') ? undefined : json['producer_copyright_line'],
    'parentalWarningType': !exists(json, 'parental_warning_type') ? undefined : json['parental_warning_type'],
    'isStreamGated': json['is_stream_gated'],
    'streamConditions': !exists(json, 'stream_conditions') ? undefined : AccessGateFromJSON(json['stream_conditions']),
    'isDownloadGated': json['is_download_gated'],
    'downloadConditions': !exists(json, 'download_conditions') ? undefined : AccessGateFromJSON(json['download_conditions']),
    'coverOriginalSongTitle': !exists(json, 'cover_original_song_title') ? undefined : json['cover_original_song_title'],
    'coverOriginalArtist': !exists(json, 'cover_original_artist') ? undefined : json['cover_original_artist'],
    'isOwnedByUser': json['is_owned_by_user'],
    'stream': UrlWithMirrorsFromJSON(json['stream']),
    'download': UrlWithMirrorsFromJSON(json['download']),
    'preview': UrlWithMirrorsFromJSON(json['preview'])
  };
}
function TrackFullToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'artwork': TrackArtworkFullToJSON(value.artwork),
    'description': value.description,
    'genre': value.genre,
    'id': value.id,
    'track_cid': value.trackCid,
    'preview_cid': value.previewCid,
    'orig_file_cid': value.origFileCid,
    'orig_filename': value.origFilename,
    'is_original_available': value.isOriginalAvailable,
    'mood': value.mood,
    'release_date': value.releaseDate,
    'remix_of': FullRemixParentToJSON(value.remixOf),
    'repost_count': value.repostCount,
    'favorite_count': value.favoriteCount,
    'comment_count': value.commentCount,
    'tags': value.tags,
    'title': value.title,
    'user': UserFullToJSON(value.user),
    'duration': value.duration,
    'is_downloadable': value.isDownloadable,
    'play_count': value.playCount,
    'permalink': value.permalink,
    'is_streamable': value.isStreamable,
    'ddex_app': value.ddexApp,
    'playlists_containing_track': value.playlistsContainingTrack,
    'pinned_comment_id': value.pinnedCommentId,
    'album_backlink': AlbumBacklinkToJSON(value.albumBacklink),
    'access': AccessToJSON(value.access),
    'blocknumber': value.blocknumber,
    'create_date': value.createDate,
    'cover_art_sizes': value.coverArtSizes,
    'cover_art_cids': CoverArtToJSON(value.coverArtCids),
    'created_at': value.createdAt,
    'credits_splits': value.creditsSplits,
    'isrc': value.isrc,
    'license': value.license,
    'iswc': value.iswc,
    'field_visibility': FieldVisibilityToJSON(value.fieldVisibility),
    'followee_reposts': value.followeeReposts.map(RepostToJSON),
    'has_current_user_reposted': value.hasCurrentUserReposted,
    'is_scheduled_release': value.isScheduledRelease,
    'is_unlisted': value.isUnlisted,
    'has_current_user_saved': value.hasCurrentUserSaved,
    'followee_favorites': value.followeeFavorites.map(FavoriteToJSON),
    'route_id': value.routeId,
    'stem_of': StemParentToJSON(value.stemOf),
    'track_segments': value.trackSegments.map(TrackSegmentToJSON),
    'updated_at': value.updatedAt,
    'user_id': value.userId,
    'is_delete': value.isDelete,
    'cover_art': value.coverArt,
    'is_available': value.isAvailable,
    'ai_attribution_user_id': value.aiAttributionUserId,
    'allowed_api_keys': value.allowedApiKeys,
    'audio_upload_id': value.audioUploadId,
    'preview_start_seconds': value.previewStartSeconds,
    'bpm': value.bpm,
    'is_custom_bpm': value.isCustomBpm,
    'musical_key': value.musicalKey,
    'is_custom_musical_key': value.isCustomMusicalKey,
    'audio_analysis_error_count': value.audioAnalysisErrorCount,
    'comments_disabled': value.commentsDisabled,
    'ddex_release_ids': value.ddexReleaseIds,
    'artists': value.artists,
    'resource_contributors': value.resourceContributors,
    'indirect_resource_contributors': value.indirectResourceContributors,
    'rights_controller': value.rightsController,
    'copyright_line': value.copyrightLine,
    'producer_copyright_line': value.producerCopyrightLine,
    'parental_warning_type': value.parentalWarningType,
    'is_stream_gated': value.isStreamGated,
    'stream_conditions': AccessGateToJSON(value.streamConditions),
    'is_download_gated': value.isDownloadGated,
    'download_conditions': AccessGateToJSON(value.downloadConditions),
    'cover_original_song_title': value.coverOriginalSongTitle,
    'cover_original_artist': value.coverOriginalArtist,
    'is_owned_by_user': value.isOwnedByUser,
    'stream': UrlWithMirrorsToJSON(value.stream),
    'download': UrlWithMirrorsToJSON(value.download),
    'preview': UrlWithMirrorsToJSON(value.preview)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the PlaylistFullWithoutTracks interface.
 */
function instanceOfPlaylistFullWithoutTracks(value) {
  let isInstance = true;
  isInstance = isInstance && "permalink" in value && value["permalink"] !== undefined;
  isInstance = isInstance && "id" in value && value["id"] !== undefined;
  isInstance = isInstance && "isAlbum" in value && value["isAlbum"] !== undefined;
  isInstance = isInstance && "isImageAutogenerated" in value && value["isImageAutogenerated"] !== undefined;
  isInstance = isInstance && "playlistName" in value && value["playlistName"] !== undefined;
  isInstance = isInstance && "playlistContents" in value && value["playlistContents"] !== undefined;
  isInstance = isInstance && "repostCount" in value && value["repostCount"] !== undefined;
  isInstance = isInstance && "favoriteCount" in value && value["favoriteCount"] !== undefined;
  isInstance = isInstance && "totalPlayCount" in value && value["totalPlayCount"] !== undefined;
  isInstance = isInstance && "user" in value && value["user"] !== undefined;
  isInstance = isInstance && "access" in value && value["access"] !== undefined;
  isInstance = isInstance && "trackCount" in value && value["trackCount"] !== undefined;
  isInstance = isInstance && "blocknumber" in value && value["blocknumber"] !== undefined;
  isInstance = isInstance && "createdAt" in value && value["createdAt"] !== undefined;
  isInstance = isInstance && "followeeReposts" in value && value["followeeReposts"] !== undefined;
  isInstance = isInstance && "followeeFavorites" in value && value["followeeFavorites"] !== undefined;
  isInstance = isInstance && "hasCurrentUserReposted" in value && value["hasCurrentUserReposted"] !== undefined;
  isInstance = isInstance && "hasCurrentUserSaved" in value && value["hasCurrentUserSaved"] !== undefined;
  isInstance = isInstance && "isDelete" in value && value["isDelete"] !== undefined;
  isInstance = isInstance && "isPrivate" in value && value["isPrivate"] !== undefined;
  isInstance = isInstance && "updatedAt" in value && value["updatedAt"] !== undefined;
  isInstance = isInstance && "addedTimestamps" in value && value["addedTimestamps"] !== undefined;
  isInstance = isInstance && "userId" in value && value["userId"] !== undefined;
  isInstance = isInstance && "isStreamGated" in value && value["isStreamGated"] !== undefined;
  isInstance = isInstance && "isScheduledRelease" in value && value["isScheduledRelease"] !== undefined;
  return isInstance;
}
function PlaylistFullWithoutTracksFromJSON(json) {
  return PlaylistFullWithoutTracksFromJSONTyped(json);
}
function PlaylistFullWithoutTracksFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'artwork': !exists(json, 'artwork') ? undefined : PlaylistArtworkFullFromJSON(json['artwork']),
    'description': !exists(json, 'description') ? undefined : json['description'],
    'permalink': json['permalink'],
    'id': json['id'],
    'isAlbum': json['is_album'],
    'isImageAutogenerated': json['is_image_autogenerated'],
    'playlistName': json['playlist_name'],
    'playlistContents': json['playlist_contents'].map(PlaylistAddedTimestampFromJSON),
    'repostCount': json['repost_count'],
    'favoriteCount': json['favorite_count'],
    'totalPlayCount': json['total_play_count'],
    'user': UserFullFromJSON(json['user']),
    'ddexApp': !exists(json, 'ddex_app') ? undefined : json['ddex_app'],
    'access': AccessFromJSON(json['access']),
    'upc': !exists(json, 'upc') ? undefined : json['upc'],
    'trackCount': json['track_count'],
    'blocknumber': json['blocknumber'],
    'createdAt': json['created_at'],
    'followeeReposts': json['followee_reposts'].map(RepostFromJSON),
    'followeeFavorites': json['followee_favorites'].map(FavoriteFromJSON),
    'hasCurrentUserReposted': json['has_current_user_reposted'],
    'hasCurrentUserSaved': json['has_current_user_saved'],
    'isDelete': json['is_delete'],
    'isPrivate': json['is_private'],
    'updatedAt': json['updated_at'],
    'addedTimestamps': json['added_timestamps'].map(PlaylistAddedTimestampFromJSON),
    'userId': json['user_id'],
    'tracks': !exists(json, 'tracks') ? undefined : json['tracks'].map(TrackFullFromJSON),
    'coverArt': !exists(json, 'cover_art') ? undefined : json['cover_art'],
    'coverArtSizes': !exists(json, 'cover_art_sizes') ? undefined : json['cover_art_sizes'],
    'coverArtCids': !exists(json, 'cover_art_cids') ? undefined : PlaylistArtworkFromJSON(json['cover_art_cids']),
    'isStreamGated': json['is_stream_gated'],
    'streamConditions': !exists(json, 'stream_conditions') ? undefined : AccessGateFromJSON(json['stream_conditions']),
    'isScheduledRelease': json['is_scheduled_release'],
    'releaseDate': !exists(json, 'release_date') ? undefined : json['release_date'],
    'ddexReleaseIds': !exists(json, 'ddex_release_ids') ? undefined : json['ddex_release_ids'],
    'artists': !exists(json, 'artists') ? undefined : json['artists'],
    'copyrightLine': !exists(json, 'copyright_line') ? undefined : json['copyright_line'],
    'producerCopyrightLine': !exists(json, 'producer_copyright_line') ? undefined : json['producer_copyright_line'],
    'parentalWarningType': !exists(json, 'parental_warning_type') ? undefined : json['parental_warning_type']
  };
}
function PlaylistFullWithoutTracksToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'artwork': PlaylistArtworkFullToJSON(value.artwork),
    'description': value.description,
    'permalink': value.permalink,
    'id': value.id,
    'is_album': value.isAlbum,
    'is_image_autogenerated': value.isImageAutogenerated,
    'playlist_name': value.playlistName,
    'playlist_contents': value.playlistContents.map(PlaylistAddedTimestampToJSON),
    'repost_count': value.repostCount,
    'favorite_count': value.favoriteCount,
    'total_play_count': value.totalPlayCount,
    'user': UserFullToJSON(value.user),
    'ddex_app': value.ddexApp,
    'access': AccessToJSON(value.access),
    'upc': value.upc,
    'track_count': value.trackCount,
    'blocknumber': value.blocknumber,
    'created_at': value.createdAt,
    'followee_reposts': value.followeeReposts.map(RepostToJSON),
    'followee_favorites': value.followeeFavorites.map(FavoriteToJSON),
    'has_current_user_reposted': value.hasCurrentUserReposted,
    'has_current_user_saved': value.hasCurrentUserSaved,
    'is_delete': value.isDelete,
    'is_private': value.isPrivate,
    'updated_at': value.updatedAt,
    'added_timestamps': value.addedTimestamps.map(PlaylistAddedTimestampToJSON),
    'user_id': value.userId,
    'tracks': value.tracks === undefined ? undefined : value.tracks.map(TrackFullToJSON),
    'cover_art': value.coverArt,
    'cover_art_sizes': value.coverArtSizes,
    'cover_art_cids': PlaylistArtworkToJSON(value.coverArtCids),
    'is_stream_gated': value.isStreamGated,
    'stream_conditions': AccessGateToJSON(value.streamConditions),
    'is_scheduled_release': value.isScheduledRelease,
    'release_date': value.releaseDate,
    'ddex_release_ids': value.ddexReleaseIds,
    'artists': value.artists,
    'copyright_line': value.copyrightLine,
    'producer_copyright_line': value.producerCopyrightLine,
    'parental_warning_type': value.parentalWarningType
  };
}

/* tslint:disable */
/* eslint-disable */
// @ts-nocheck
/**
 * API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * Check if a given object implements the VersionMetadata interface.
 */
function instanceOfVersionMetadata(value) {
  let isInstance = true;
  isInstance = isInstance && "service" in value && value["service"] !== undefined;
  isInstance = isInstance && "version" in value && value["version"] !== undefined;
  return isInstance;
}
function VersionMetadataFromJSON(json) {
  return VersionMetadataFromJSONTyped(json);
}
function VersionMetadataFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'service': json['service'],
    'version': json['version']
  };
}
function VersionMetadataToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'service': value.service,
    'version': value.version
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the AlbumsResponseFull interface.
 */
function instanceOfAlbumsResponseFull(value) {
  let isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value && value["latestChainBlock"] !== undefined;
  isInstance = isInstance && "latestIndexedBlock" in value && value["latestIndexedBlock"] !== undefined;
  isInstance = isInstance && "latestChainSlotPlays" in value && value["latestChainSlotPlays"] !== undefined;
  isInstance = isInstance && "latestIndexedSlotPlays" in value && value["latestIndexedSlotPlays"] !== undefined;
  isInstance = isInstance && "signature" in value && value["signature"] !== undefined;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== undefined;
  isInstance = isInstance && "version" in value && value["version"] !== undefined;
  return isInstance;
}
function AlbumsResponseFullFromJSON(json) {
  return AlbumsResponseFullFromJSONTyped(json);
}
function AlbumsResponseFullFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : json['data'].map(PlaylistFullWithoutTracksFromJSON)
  };
}
function AlbumsResponseFullToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': value.data === undefined ? undefined : value.data.map(PlaylistFullWithoutTracksToJSON)
  };
}

/* tslint:disable */
/* eslint-disable */
// @ts-nocheck
/**
 * API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * Check if a given object implements the AnnouncementNotificationActionData interface.
 */
function instanceOfAnnouncementNotificationActionData(value) {
  let isInstance = true;
  isInstance = isInstance && "title" in value && value["title"] !== undefined;
  isInstance = isInstance && "pushBody" in value && value["pushBody"] !== undefined;
  isInstance = isInstance && "shortDescription" in value && value["shortDescription"] !== undefined;
  isInstance = isInstance && "longDescription" in value && value["longDescription"] !== undefined;
  return isInstance;
}
function AnnouncementNotificationActionDataFromJSON(json) {
  return AnnouncementNotificationActionDataFromJSONTyped(json);
}
function AnnouncementNotificationActionDataFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'title': json['title'],
    'pushBody': json['push_body'],
    'shortDescription': json['short_description'],
    'longDescription': json['long_description']
  };
}
function AnnouncementNotificationActionDataToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'title': value.title,
    'push_body': value.pushBody,
    'short_description': value.shortDescription,
    'long_description': value.longDescription
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the AnnouncementNotificationAction interface.
 */
function instanceOfAnnouncementNotificationAction(value) {
  let isInstance = true;
  isInstance = isInstance && "specifier" in value && value["specifier"] !== undefined;
  isInstance = isInstance && "type" in value && value["type"] !== undefined;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== undefined;
  isInstance = isInstance && "data" in value && value["data"] !== undefined;
  return isInstance;
}
function AnnouncementNotificationActionFromJSON(json) {
  return AnnouncementNotificationActionFromJSONTyped(json);
}
function AnnouncementNotificationActionFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'specifier': json['specifier'],
    'type': json['type'],
    'timestamp': json['timestamp'],
    'data': AnnouncementNotificationActionDataFromJSON(json['data'])
  };
}
function AnnouncementNotificationActionToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'specifier': value.specifier,
    'type': value.type,
    'timestamp': value.timestamp,
    'data': AnnouncementNotificationActionDataToJSON(value.data)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the AnnouncementNotification interface.
 */
function instanceOfAnnouncementNotification(value) {
  let isInstance = true;
  isInstance = isInstance && "type" in value && value["type"] !== undefined;
  isInstance = isInstance && "groupId" in value && value["groupId"] !== undefined;
  isInstance = isInstance && "isSeen" in value && value["isSeen"] !== undefined;
  isInstance = isInstance && "actions" in value && value["actions"] !== undefined;
  return isInstance;
}
function AnnouncementNotificationFromJSON(json) {
  return AnnouncementNotificationFromJSONTyped(json);
}
function AnnouncementNotificationFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'type': json['type'],
    'groupId': json['group_id'],
    'isSeen': json['is_seen'],
    'seenAt': !exists(json, 'seen_at') ? undefined : json['seen_at'],
    'actions': json['actions'].map(AnnouncementNotificationActionFromJSON)
  };
}
function AnnouncementNotificationToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'type': value.type,
    'group_id': value.groupId,
    'is_seen': value.isSeen,
    'seen_at': value.seenAt,
    'actions': value.actions.map(AnnouncementNotificationActionToJSON)
  };
}

/* tslint:disable */
/* eslint-disable */
// @ts-nocheck
/**
 * API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * Check if a given object implements the ApproveManagerRequestNotificationActionData interface.
 */
function instanceOfApproveManagerRequestNotificationActionData(value) {
  let isInstance = true;
  isInstance = isInstance && "userId" in value && value["userId"] !== undefined;
  isInstance = isInstance && "granteeUserId" in value && value["granteeUserId"] !== undefined;
  isInstance = isInstance && "granteeAddress" in value && value["granteeAddress"] !== undefined;
  return isInstance;
}
function ApproveManagerRequestNotificationActionDataFromJSON(json) {
  return ApproveManagerRequestNotificationActionDataFromJSONTyped(json);
}
function ApproveManagerRequestNotificationActionDataFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'userId': json['user_id'],
    'granteeUserId': json['grantee_user_id'],
    'granteeAddress': json['grantee_address']
  };
}
function ApproveManagerRequestNotificationActionDataToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'user_id': value.userId,
    'grantee_user_id': value.granteeUserId,
    'grantee_address': value.granteeAddress
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the ApproveManagerRequestNotificationAction interface.
 */
function instanceOfApproveManagerRequestNotificationAction(value) {
  let isInstance = true;
  isInstance = isInstance && "specifier" in value && value["specifier"] !== undefined;
  isInstance = isInstance && "type" in value && value["type"] !== undefined;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== undefined;
  isInstance = isInstance && "data" in value && value["data"] !== undefined;
  return isInstance;
}
function ApproveManagerRequestNotificationActionFromJSON(json) {
  return ApproveManagerRequestNotificationActionFromJSONTyped(json);
}
function ApproveManagerRequestNotificationActionFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'specifier': json['specifier'],
    'type': json['type'],
    'timestamp': json['timestamp'],
    'data': ApproveManagerRequestNotificationActionDataFromJSON(json['data'])
  };
}
function ApproveManagerRequestNotificationActionToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'specifier': value.specifier,
    'type': value.type,
    'timestamp': value.timestamp,
    'data': ApproveManagerRequestNotificationActionDataToJSON(value.data)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the ApproveManagerRequestNotification interface.
 */
function instanceOfApproveManagerRequestNotification(value) {
  let isInstance = true;
  isInstance = isInstance && "type" in value && value["type"] !== undefined;
  isInstance = isInstance && "groupId" in value && value["groupId"] !== undefined;
  isInstance = isInstance && "isSeen" in value && value["isSeen"] !== undefined;
  isInstance = isInstance && "actions" in value && value["actions"] !== undefined;
  return isInstance;
}
function ApproveManagerRequestNotificationFromJSON(json) {
  return ApproveManagerRequestNotificationFromJSONTyped(json);
}
function ApproveManagerRequestNotificationFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'type': json['type'],
    'groupId': json['group_id'],
    'isSeen': json['is_seen'],
    'seenAt': !exists(json, 'seen_at') ? undefined : json['seen_at'],
    'actions': json['actions'].map(ApproveManagerRequestNotificationActionFromJSON)
  };
}
function ApproveManagerRequestNotificationToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'type': value.type,
    'group_id': value.groupId,
    'is_seen': value.isSeen,
    'seen_at': value.seenAt,
    'actions': value.actions.map(ApproveManagerRequestNotificationActionToJSON)
  };
}

/* tslint:disable */
/* eslint-disable */
// @ts-nocheck
/**
 * API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * Check if a given object implements the ArtistRemixContestEndedNotificationActionData interface.
 */
function instanceOfArtistRemixContestEndedNotificationActionData(value) {
  let isInstance = true;
  isInstance = isInstance && "entityId" in value && value["entityId"] !== undefined;
  return isInstance;
}
function ArtistRemixContestEndedNotificationActionDataFromJSON(json) {
  return ArtistRemixContestEndedNotificationActionDataFromJSONTyped(json);
}
function ArtistRemixContestEndedNotificationActionDataFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'entityId': json['entity_id']
  };
}
function ArtistRemixContestEndedNotificationActionDataToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'entity_id': value.entityId
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the ArtistRemixContestEndedNotificationAction interface.
 */
function instanceOfArtistRemixContestEndedNotificationAction(value) {
  let isInstance = true;
  isInstance = isInstance && "specifier" in value && value["specifier"] !== undefined;
  isInstance = isInstance && "type" in value && value["type"] !== undefined;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== undefined;
  isInstance = isInstance && "data" in value && value["data"] !== undefined;
  return isInstance;
}
function ArtistRemixContestEndedNotificationActionFromJSON(json) {
  return ArtistRemixContestEndedNotificationActionFromJSONTyped(json);
}
function ArtistRemixContestEndedNotificationActionFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'specifier': json['specifier'],
    'type': json['type'],
    'timestamp': json['timestamp'],
    'data': ArtistRemixContestEndedNotificationActionDataFromJSON(json['data'])
  };
}
function ArtistRemixContestEndedNotificationActionToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'specifier': value.specifier,
    'type': value.type,
    'timestamp': value.timestamp,
    'data': ArtistRemixContestEndedNotificationActionDataToJSON(value.data)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the ArtistRemixContestEndedNotification interface.
 */
function instanceOfArtistRemixContestEndedNotification(value) {
  let isInstance = true;
  isInstance = isInstance && "type" in value && value["type"] !== undefined;
  isInstance = isInstance && "groupId" in value && value["groupId"] !== undefined;
  isInstance = isInstance && "isSeen" in value && value["isSeen"] !== undefined;
  isInstance = isInstance && "actions" in value && value["actions"] !== undefined;
  return isInstance;
}
function ArtistRemixContestEndedNotificationFromJSON(json) {
  return ArtistRemixContestEndedNotificationFromJSONTyped(json);
}
function ArtistRemixContestEndedNotificationFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'type': json['type'],
    'groupId': json['group_id'],
    'isSeen': json['is_seen'],
    'seenAt': !exists(json, 'seen_at') ? undefined : json['seen_at'],
    'actions': json['actions'].map(ArtistRemixContestEndedNotificationActionFromJSON)
  };
}
function ArtistRemixContestEndedNotificationToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'type': value.type,
    'group_id': value.groupId,
    'is_seen': value.isSeen,
    'seen_at': value.seenAt,
    'actions': value.actions.map(ArtistRemixContestEndedNotificationActionToJSON)
  };
}

/* tslint:disable */
/* eslint-disable */
// @ts-nocheck
/**
 * API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * Check if a given object implements the ArtistRemixContestEndingSoonNotificationActionData interface.
 */
function instanceOfArtistRemixContestEndingSoonNotificationActionData(value) {
  let isInstance = true;
  isInstance = isInstance && "entityUserId" in value && value["entityUserId"] !== undefined;
  isInstance = isInstance && "entityId" in value && value["entityId"] !== undefined;
  return isInstance;
}
function ArtistRemixContestEndingSoonNotificationActionDataFromJSON(json) {
  return ArtistRemixContestEndingSoonNotificationActionDataFromJSONTyped(json);
}
function ArtistRemixContestEndingSoonNotificationActionDataFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'entityUserId': json['entity_user_id'],
    'entityId': json['entity_id']
  };
}
function ArtistRemixContestEndingSoonNotificationActionDataToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'entity_user_id': value.entityUserId,
    'entity_id': value.entityId
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the ArtistRemixContestEndingSoonNotificationAction interface.
 */
function instanceOfArtistRemixContestEndingSoonNotificationAction(value) {
  let isInstance = true;
  isInstance = isInstance && "specifier" in value && value["specifier"] !== undefined;
  isInstance = isInstance && "type" in value && value["type"] !== undefined;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== undefined;
  isInstance = isInstance && "data" in value && value["data"] !== undefined;
  return isInstance;
}
function ArtistRemixContestEndingSoonNotificationActionFromJSON(json) {
  return ArtistRemixContestEndingSoonNotificationActionFromJSONTyped(json);
}
function ArtistRemixContestEndingSoonNotificationActionFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'specifier': json['specifier'],
    'type': json['type'],
    'timestamp': json['timestamp'],
    'data': ArtistRemixContestEndingSoonNotificationActionDataFromJSON(json['data'])
  };
}
function ArtistRemixContestEndingSoonNotificationActionToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'specifier': value.specifier,
    'type': value.type,
    'timestamp': value.timestamp,
    'data': ArtistRemixContestEndingSoonNotificationActionDataToJSON(value.data)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the ArtistRemixContestEndingSoonNotification interface.
 */
function instanceOfArtistRemixContestEndingSoonNotification(value) {
  let isInstance = true;
  isInstance = isInstance && "type" in value && value["type"] !== undefined;
  isInstance = isInstance && "groupId" in value && value["groupId"] !== undefined;
  isInstance = isInstance && "isSeen" in value && value["isSeen"] !== undefined;
  isInstance = isInstance && "actions" in value && value["actions"] !== undefined;
  return isInstance;
}
function ArtistRemixContestEndingSoonNotificationFromJSON(json) {
  return ArtistRemixContestEndingSoonNotificationFromJSONTyped(json);
}
function ArtistRemixContestEndingSoonNotificationFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'type': json['type'],
    'groupId': json['group_id'],
    'isSeen': json['is_seen'],
    'seenAt': !exists(json, 'seen_at') ? undefined : json['seen_at'],
    'actions': json['actions'].map(ArtistRemixContestEndingSoonNotificationActionFromJSON)
  };
}
function ArtistRemixContestEndingSoonNotificationToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'type': value.type,
    'group_id': value.groupId,
    'is_seen': value.isSeen,
    'seen_at': value.seenAt,
    'actions': value.actions.map(ArtistRemixContestEndingSoonNotificationActionToJSON)
  };
}

/* tslint:disable */
/* eslint-disable */
// @ts-nocheck
/**
 * API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * Check if a given object implements the ArtistRemixContestSubmissionsNotificationActionData interface.
 */
function instanceOfArtistRemixContestSubmissionsNotificationActionData(value) {
  let isInstance = true;
  isInstance = isInstance && "eventId" in value && value["eventId"] !== undefined;
  isInstance = isInstance && "milestone" in value && value["milestone"] !== undefined;
  isInstance = isInstance && "entityId" in value && value["entityId"] !== undefined;
  return isInstance;
}
function ArtistRemixContestSubmissionsNotificationActionDataFromJSON(json) {
  return ArtistRemixContestSubmissionsNotificationActionDataFromJSONTyped(json);
}
function ArtistRemixContestSubmissionsNotificationActionDataFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'eventId': json['event_id'],
    'milestone': json['milestone'],
    'entityId': json['entity_id']
  };
}
function ArtistRemixContestSubmissionsNotificationActionDataToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'event_id': value.eventId,
    'milestone': value.milestone,
    'entity_id': value.entityId
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the ArtistRemixContestSubmissionsNotificationAction interface.
 */
function instanceOfArtistRemixContestSubmissionsNotificationAction(value) {
  let isInstance = true;
  isInstance = isInstance && "specifier" in value && value["specifier"] !== undefined;
  isInstance = isInstance && "type" in value && value["type"] !== undefined;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== undefined;
  isInstance = isInstance && "data" in value && value["data"] !== undefined;
  return isInstance;
}
function ArtistRemixContestSubmissionsNotificationActionFromJSON(json) {
  return ArtistRemixContestSubmissionsNotificationActionFromJSONTyped(json);
}
function ArtistRemixContestSubmissionsNotificationActionFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'specifier': json['specifier'],
    'type': json['type'],
    'timestamp': json['timestamp'],
    'data': ArtistRemixContestSubmissionsNotificationActionDataFromJSON(json['data'])
  };
}
function ArtistRemixContestSubmissionsNotificationActionToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'specifier': value.specifier,
    'type': value.type,
    'timestamp': value.timestamp,
    'data': ArtistRemixContestSubmissionsNotificationActionDataToJSON(value.data)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the ArtistRemixContestSubmissionsNotification interface.
 */
function instanceOfArtistRemixContestSubmissionsNotification(value) {
  let isInstance = true;
  isInstance = isInstance && "type" in value && value["type"] !== undefined;
  isInstance = isInstance && "groupId" in value && value["groupId"] !== undefined;
  isInstance = isInstance && "isSeen" in value && value["isSeen"] !== undefined;
  isInstance = isInstance && "actions" in value && value["actions"] !== undefined;
  return isInstance;
}
function ArtistRemixContestSubmissionsNotificationFromJSON(json) {
  return ArtistRemixContestSubmissionsNotificationFromJSONTyped(json);
}
function ArtistRemixContestSubmissionsNotificationFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'type': json['type'],
    'groupId': json['group_id'],
    'isSeen': json['is_seen'],
    'seenAt': !exists(json, 'seen_at') ? undefined : json['seen_at'],
    'actions': json['actions'].map(ArtistRemixContestSubmissionsNotificationActionFromJSON)
  };
}
function ArtistRemixContestSubmissionsNotificationToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'type': value.type,
    'group_id': value.groupId,
    'is_seen': value.isSeen,
    'seen_at': value.seenAt,
    'actions': value.actions.map(ArtistRemixContestSubmissionsNotificationActionToJSON)
  };
}

/* tslint:disable */
/* eslint-disable */
// @ts-nocheck
/**
 * API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * Check if a given object implements the Attestation interface.
 */
function instanceOfAttestation(value) {
  let isInstance = true;
  isInstance = isInstance && "ownerWallet" in value && value["ownerWallet"] !== undefined;
  isInstance = isInstance && "attestation" in value && value["attestation"] !== undefined;
  return isInstance;
}
function AttestationFromJSON(json) {
  return AttestationFromJSONTyped(json);
}
function AttestationFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'ownerWallet': json['owner_wallet'],
    'attestation': json['attestation']
  };
}
function AttestationToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'owner_wallet': value.ownerWallet,
    'attestation': value.attestation
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the AttestationReponse interface.
 */
function instanceOfAttestationReponse(value) {
  let isInstance = true;
  return isInstance;
}
function AttestationReponseFromJSON(json) {
  return AttestationReponseFromJSONTyped(json);
}
function AttestationReponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'data': !exists(json, 'data') ? undefined : AttestationFromJSON(json['data'])
  };
}
function AttestationReponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'data': AttestationToJSON(value.data)
  };
}

/* tslint:disable */
/**
 * @export
 */
const BestSellingItemContentTypeEnum = {
  Track: 'track',
  Album: 'album'
};
/**
 * Check if a given object implements the BestSellingItem interface.
 */
function instanceOfBestSellingItem(value) {
  let isInstance = true;
  isInstance = isInstance && "contentId" in value && value["contentId"] !== undefined;
  isInstance = isInstance && "title" in value && value["title"] !== undefined;
  isInstance = isInstance && "ownerId" in value && value["ownerId"] !== undefined;
  return isInstance;
}
function BestSellingItemFromJSON(json) {
  return BestSellingItemFromJSONTyped(json);
}
function BestSellingItemFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'contentId': json['content_id'],
    'contentType': !exists(json, 'content_type') ? undefined : json['content_type'],
    'title': json['title'],
    'ownerId': json['owner_id']
  };
}
function BestSellingItemToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'content_id': value.contentId,
    'content_type': value.contentType,
    'title': value.title,
    'owner_id': value.ownerId
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the PlaylistFull interface.
 */
function instanceOfPlaylistFull(value) {
  let isInstance = true;
  isInstance = isInstance && "permalink" in value && value["permalink"] !== undefined;
  isInstance = isInstance && "id" in value && value["id"] !== undefined;
  isInstance = isInstance && "isAlbum" in value && value["isAlbum"] !== undefined;
  isInstance = isInstance && "isImageAutogenerated" in value && value["isImageAutogenerated"] !== undefined;
  isInstance = isInstance && "playlistName" in value && value["playlistName"] !== undefined;
  isInstance = isInstance && "playlistContents" in value && value["playlistContents"] !== undefined;
  isInstance = isInstance && "repostCount" in value && value["repostCount"] !== undefined;
  isInstance = isInstance && "favoriteCount" in value && value["favoriteCount"] !== undefined;
  isInstance = isInstance && "totalPlayCount" in value && value["totalPlayCount"] !== undefined;
  isInstance = isInstance && "user" in value && value["user"] !== undefined;
  isInstance = isInstance && "access" in value && value["access"] !== undefined;
  isInstance = isInstance && "trackCount" in value && value["trackCount"] !== undefined;
  isInstance = isInstance && "blocknumber" in value && value["blocknumber"] !== undefined;
  isInstance = isInstance && "createdAt" in value && value["createdAt"] !== undefined;
  isInstance = isInstance && "followeeReposts" in value && value["followeeReposts"] !== undefined;
  isInstance = isInstance && "followeeFavorites" in value && value["followeeFavorites"] !== undefined;
  isInstance = isInstance && "hasCurrentUserReposted" in value && value["hasCurrentUserReposted"] !== undefined;
  isInstance = isInstance && "hasCurrentUserSaved" in value && value["hasCurrentUserSaved"] !== undefined;
  isInstance = isInstance && "isDelete" in value && value["isDelete"] !== undefined;
  isInstance = isInstance && "isPrivate" in value && value["isPrivate"] !== undefined;
  isInstance = isInstance && "updatedAt" in value && value["updatedAt"] !== undefined;
  isInstance = isInstance && "addedTimestamps" in value && value["addedTimestamps"] !== undefined;
  isInstance = isInstance && "userId" in value && value["userId"] !== undefined;
  isInstance = isInstance && "isStreamGated" in value && value["isStreamGated"] !== undefined;
  isInstance = isInstance && "isScheduledRelease" in value && value["isScheduledRelease"] !== undefined;
  return isInstance;
}
function PlaylistFullFromJSON(json) {
  return PlaylistFullFromJSONTyped(json);
}
function PlaylistFullFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'artwork': !exists(json, 'artwork') ? undefined : PlaylistArtworkFullFromJSON(json['artwork']),
    'description': !exists(json, 'description') ? undefined : json['description'],
    'permalink': json['permalink'],
    'id': json['id'],
    'isAlbum': json['is_album'],
    'isImageAutogenerated': json['is_image_autogenerated'],
    'playlistName': json['playlist_name'],
    'playlistContents': json['playlist_contents'].map(PlaylistAddedTimestampFromJSON),
    'repostCount': json['repost_count'],
    'favoriteCount': json['favorite_count'],
    'totalPlayCount': json['total_play_count'],
    'user': UserFullFromJSON(json['user']),
    'ddexApp': !exists(json, 'ddex_app') ? undefined : json['ddex_app'],
    'access': AccessFromJSON(json['access']),
    'upc': !exists(json, 'upc') ? undefined : json['upc'],
    'trackCount': json['track_count'],
    'blocknumber': json['blocknumber'],
    'createdAt': json['created_at'],
    'followeeReposts': json['followee_reposts'].map(RepostFromJSON),
    'followeeFavorites': json['followee_favorites'].map(FavoriteFromJSON),
    'hasCurrentUserReposted': json['has_current_user_reposted'],
    'hasCurrentUserSaved': json['has_current_user_saved'],
    'isDelete': json['is_delete'],
    'isPrivate': json['is_private'],
    'updatedAt': json['updated_at'],
    'addedTimestamps': json['added_timestamps'].map(PlaylistAddedTimestampFromJSON),
    'userId': json['user_id'],
    'tracks': !exists(json, 'tracks') ? undefined : json['tracks'].map(TrackFullFromJSON),
    'coverArt': !exists(json, 'cover_art') ? undefined : json['cover_art'],
    'coverArtSizes': !exists(json, 'cover_art_sizes') ? undefined : json['cover_art_sizes'],
    'coverArtCids': !exists(json, 'cover_art_cids') ? undefined : PlaylistArtworkFromJSON(json['cover_art_cids']),
    'isStreamGated': json['is_stream_gated'],
    'streamConditions': !exists(json, 'stream_conditions') ? undefined : AccessGateFromJSON(json['stream_conditions']),
    'isScheduledRelease': json['is_scheduled_release'],
    'releaseDate': !exists(json, 'release_date') ? undefined : json['release_date'],
    'ddexReleaseIds': !exists(json, 'ddex_release_ids') ? undefined : json['ddex_release_ids'],
    'artists': !exists(json, 'artists') ? undefined : json['artists'],
    'copyrightLine': !exists(json, 'copyright_line') ? undefined : json['copyright_line'],
    'producerCopyrightLine': !exists(json, 'producer_copyright_line') ? undefined : json['producer_copyright_line'],
    'parentalWarningType': !exists(json, 'parental_warning_type') ? undefined : json['parental_warning_type']
  };
}
function PlaylistFullToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'artwork': PlaylistArtworkFullToJSON(value.artwork),
    'description': value.description,
    'permalink': value.permalink,
    'id': value.id,
    'is_album': value.isAlbum,
    'is_image_autogenerated': value.isImageAutogenerated,
    'playlist_name': value.playlistName,
    'playlist_contents': value.playlistContents.map(PlaylistAddedTimestampToJSON),
    'repost_count': value.repostCount,
    'favorite_count': value.favoriteCount,
    'total_play_count': value.totalPlayCount,
    'user': UserFullToJSON(value.user),
    'ddex_app': value.ddexApp,
    'access': AccessToJSON(value.access),
    'upc': value.upc,
    'track_count': value.trackCount,
    'blocknumber': value.blocknumber,
    'created_at': value.createdAt,
    'followee_reposts': value.followeeReposts.map(RepostToJSON),
    'followee_favorites': value.followeeFavorites.map(FavoriteToJSON),
    'has_current_user_reposted': value.hasCurrentUserReposted,
    'has_current_user_saved': value.hasCurrentUserSaved,
    'is_delete': value.isDelete,
    'is_private': value.isPrivate,
    'updated_at': value.updatedAt,
    'added_timestamps': value.addedTimestamps.map(PlaylistAddedTimestampToJSON),
    'user_id': value.userId,
    'tracks': value.tracks === undefined ? undefined : value.tracks.map(TrackFullToJSON),
    'cover_art': value.coverArt,
    'cover_art_sizes': value.coverArtSizes,
    'cover_art_cids': PlaylistArtworkToJSON(value.coverArtCids),
    'is_stream_gated': value.isStreamGated,
    'stream_conditions': AccessGateToJSON(value.streamConditions),
    'is_scheduled_release': value.isScheduledRelease,
    'release_date': value.releaseDate,
    'ddex_release_ids': value.ddexReleaseIds,
    'artists': value.artists,
    'copyright_line': value.copyrightLine,
    'producer_copyright_line': value.producerCopyrightLine,
    'parental_warning_type': value.parentalWarningType
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the Related interface.
 */
function instanceOfRelated(value) {
  let isInstance = true;
  return isInstance;
}
function RelatedFromJSON(json) {
  return RelatedFromJSONTyped(json);
}
function RelatedFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'users': !exists(json, 'users') ? undefined : json['users'].map(UserFullFromJSON),
    'tracks': !exists(json, 'tracks') ? undefined : json['tracks'].map(TrackFullFromJSON),
    'playlists': !exists(json, 'playlists') ? undefined : json['playlists'].map(PlaylistFullFromJSON)
  };
}
function RelatedToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'users': value.users === undefined ? undefined : value.users.map(UserFullToJSON),
    'tracks': value.tracks === undefined ? undefined : value.tracks.map(TrackFullToJSON),
    'playlists': value.playlists === undefined ? undefined : value.playlists.map(PlaylistFullToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the BestSellingFullResponse interface.
 */
function instanceOfBestSellingFullResponse(value) {
  let isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value && value["latestChainBlock"] !== undefined;
  isInstance = isInstance && "latestIndexedBlock" in value && value["latestIndexedBlock"] !== undefined;
  isInstance = isInstance && "latestChainSlotPlays" in value && value["latestChainSlotPlays"] !== undefined;
  isInstance = isInstance && "latestIndexedSlotPlays" in value && value["latestIndexedSlotPlays"] !== undefined;
  isInstance = isInstance && "signature" in value && value["signature"] !== undefined;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== undefined;
  isInstance = isInstance && "version" in value && value["version"] !== undefined;
  return isInstance;
}
function BestSellingFullResponseFromJSON(json) {
  return BestSellingFullResponseFromJSONTyped(json);
}
function BestSellingFullResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : json['data'].map(BestSellingItemFromJSON),
    'related': !exists(json, 'related') ? undefined : RelatedFromJSON(json['related'])
  };
}
function BestSellingFullResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': value.data === undefined ? undefined : value.data.map(BestSellingItemToJSON),
    'related': RelatedToJSON(value.related)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the ChallengeRewardNotificationActionData interface.
 */
function instanceOfChallengeRewardNotificationActionData(value) {
  let isInstance = true;
  isInstance = isInstance && "amount" in value && value["amount"] !== undefined;
  isInstance = isInstance && "specifier" in value && value["specifier"] !== undefined;
  isInstance = isInstance && "challengeId" in value && value["challengeId"] !== undefined;
  return isInstance;
}
function ChallengeRewardNotificationActionDataFromJSON(json) {
  return ChallengeRewardNotificationActionDataFromJSONTyped(json);
}
function ChallengeRewardNotificationActionDataFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'amount': json['amount'],
    'specifier': json['specifier'],
    'challengeId': json['challenge_id'],
    'listenStreak': !exists(json, 'listen_streak') ? undefined : json['listen_streak']
  };
}
function ChallengeRewardNotificationActionDataToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'amount': value.amount,
    'specifier': value.specifier,
    'challenge_id': value.challengeId,
    'listen_streak': value.listenStreak
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the ChallengeRewardNotificationAction interface.
 */
function instanceOfChallengeRewardNotificationAction(value) {
  let isInstance = true;
  isInstance = isInstance && "specifier" in value && value["specifier"] !== undefined;
  isInstance = isInstance && "type" in value && value["type"] !== undefined;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== undefined;
  isInstance = isInstance && "data" in value && value["data"] !== undefined;
  return isInstance;
}
function ChallengeRewardNotificationActionFromJSON(json) {
  return ChallengeRewardNotificationActionFromJSONTyped(json);
}
function ChallengeRewardNotificationActionFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'specifier': json['specifier'],
    'type': json['type'],
    'timestamp': json['timestamp'],
    'data': ChallengeRewardNotificationActionDataFromJSON(json['data'])
  };
}
function ChallengeRewardNotificationActionToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'specifier': value.specifier,
    'type': value.type,
    'timestamp': value.timestamp,
    'data': ChallengeRewardNotificationActionDataToJSON(value.data)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the ChallengeRewardNotification interface.
 */
function instanceOfChallengeRewardNotification(value) {
  let isInstance = true;
  isInstance = isInstance && "type" in value && value["type"] !== undefined;
  isInstance = isInstance && "groupId" in value && value["groupId"] !== undefined;
  isInstance = isInstance && "isSeen" in value && value["isSeen"] !== undefined;
  isInstance = isInstance && "actions" in value && value["actions"] !== undefined;
  return isInstance;
}
function ChallengeRewardNotificationFromJSON(json) {
  return ChallengeRewardNotificationFromJSONTyped(json);
}
function ChallengeRewardNotificationFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'type': json['type'],
    'groupId': json['group_id'],
    'isSeen': json['is_seen'],
    'seenAt': !exists(json, 'seen_at') ? undefined : json['seen_at'],
    'actions': json['actions'].map(ChallengeRewardNotificationActionFromJSON)
  };
}
function ChallengeRewardNotificationToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'type': value.type,
    'group_id': value.groupId,
    'is_seen': value.isSeen,
    'seen_at': value.seenAt,
    'actions': value.actions.map(ChallengeRewardNotificationActionToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the CidData interface.
 */
function instanceOfCidData(value) {
  let isInstance = true;
  return isInstance;
}
function CidDataFromJSON(json) {
  return CidDataFromJSONTyped(json);
}
function CidDataFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'collectibles': !exists(json, 'collectibles') ? undefined : json['collectibles'],
    'associatedSolWallets': !exists(json, 'associated_sol_wallets') ? undefined : json['associated_sol_wallets'],
    'associatedWallets': !exists(json, 'associated_wallets') ? undefined : json['associated_wallets']
  };
}
function CidDataToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'collectibles': value.collectibles,
    'associated_sol_wallets': value.associatedSolWallets,
    'associated_wallets': value.associatedWallets
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the DataAndType interface.
 */
function instanceOfDataAndType(value) {
  let isInstance = true;
  return isInstance;
}
function DataAndTypeFromJSON(json) {
  return DataAndTypeFromJSONTyped(json);
}
function DataAndTypeFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'type': !exists(json, 'type') ? undefined : json['type'],
    'data': !exists(json, 'data') ? undefined : CidDataFromJSON(json['data'])
  };
}
function DataAndTypeToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'type': value.type,
    'data': CidDataToJSON(value.data)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the CidDataResponse interface.
 */
function instanceOfCidDataResponse(value) {
  let isInstance = true;
  return isInstance;
}
function CidDataResponseFromJSON(json) {
  return CidDataResponseFromJSONTyped(json);
}
function CidDataResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'data': !exists(json, 'data') ? undefined : DataAndTypeFromJSON(json['data'])
  };
}
function CidDataResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'data': DataAndTypeToJSON(value.data)
  };
}

/* tslint:disable */
/* eslint-disable */
// @ts-nocheck
/**
 * API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * Check if a given object implements the ClaimableRewardNotificationActionData interface.
 */
function instanceOfClaimableRewardNotificationActionData(value) {
  let isInstance = true;
  isInstance = isInstance && "amount" in value && value["amount"] !== undefined;
  isInstance = isInstance && "specifier" in value && value["specifier"] !== undefined;
  isInstance = isInstance && "challengeId" in value && value["challengeId"] !== undefined;
  return isInstance;
}
function ClaimableRewardNotificationActionDataFromJSON(json) {
  return ClaimableRewardNotificationActionDataFromJSONTyped(json);
}
function ClaimableRewardNotificationActionDataFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'amount': json['amount'],
    'specifier': json['specifier'],
    'challengeId': json['challenge_id']
  };
}
function ClaimableRewardNotificationActionDataToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'amount': value.amount,
    'specifier': value.specifier,
    'challenge_id': value.challengeId
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the ClaimableRewardNotificationAction interface.
 */
function instanceOfClaimableRewardNotificationAction(value) {
  let isInstance = true;
  isInstance = isInstance && "specifier" in value && value["specifier"] !== undefined;
  isInstance = isInstance && "type" in value && value["type"] !== undefined;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== undefined;
  isInstance = isInstance && "data" in value && value["data"] !== undefined;
  return isInstance;
}
function ClaimableRewardNotificationActionFromJSON(json) {
  return ClaimableRewardNotificationActionFromJSONTyped(json);
}
function ClaimableRewardNotificationActionFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'specifier': json['specifier'],
    'type': json['type'],
    'timestamp': json['timestamp'],
    'data': ClaimableRewardNotificationActionDataFromJSON(json['data'])
  };
}
function ClaimableRewardNotificationActionToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'specifier': value.specifier,
    'type': value.type,
    'timestamp': value.timestamp,
    'data': ClaimableRewardNotificationActionDataToJSON(value.data)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the ClaimableRewardNotification interface.
 */
function instanceOfClaimableRewardNotification(value) {
  let isInstance = true;
  isInstance = isInstance && "type" in value && value["type"] !== undefined;
  isInstance = isInstance && "groupId" in value && value["groupId"] !== undefined;
  isInstance = isInstance && "isSeen" in value && value["isSeen"] !== undefined;
  isInstance = isInstance && "actions" in value && value["actions"] !== undefined;
  return isInstance;
}
function ClaimableRewardNotificationFromJSON(json) {
  return ClaimableRewardNotificationFromJSONTyped(json);
}
function ClaimableRewardNotificationFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'type': json['type'],
    'groupId': json['group_id'],
    'isSeen': json['is_seen'],
    'seenAt': !exists(json, 'seen_at') ? undefined : json['seen_at'],
    'actions': json['actions'].map(ClaimableRewardNotificationActionFromJSON)
  };
}
function ClaimableRewardNotificationToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'type': value.type,
    'group_id': value.groupId,
    'is_seen': value.isSeen,
    'seen_at': value.seenAt,
    'actions': value.actions.map(ClaimableRewardNotificationActionToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the Coin interface.
 */
function instanceOfCoin(value) {
  let isInstance = true;
  isInstance = isInstance && "mint" in value && value["mint"] !== undefined;
  isInstance = isInstance && "ticker" in value && value["ticker"] !== undefined;
  isInstance = isInstance && "decimals" in value && value["decimals"] !== undefined;
  isInstance = isInstance && "name" in value && value["name"] !== undefined;
  isInstance = isInstance && "createdAt" in value && value["createdAt"] !== undefined;
  return isInstance;
}
function CoinFromJSON(json) {
  return CoinFromJSONTyped(json);
}
function CoinFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'mint': json['mint'],
    'ticker': json['ticker'],
    'decimals': json['decimals'],
    'name': json['name'],
    'logoUri': !exists(json, 'logo_uri') ? undefined : json['logo_uri'],
    'description': !exists(json, 'description') ? undefined : json['description'],
    'xHandle': !exists(json, 'x_handle') ? undefined : json['x_handle'],
    'instagramHandle': !exists(json, 'instagram_handle') ? undefined : json['instagram_handle'],
    'tiktokHandle': !exists(json, 'tiktok_handle') ? undefined : json['tiktok_handle'],
    'website': !exists(json, 'website') ? undefined : json['website'],
    'link1': !exists(json, 'link_1') ? undefined : json['link_1'],
    'link2': !exists(json, 'link_2') ? undefined : json['link_2'],
    'link3': !exists(json, 'link_3') ? undefined : json['link_3'],
    'link4': !exists(json, 'link_4') ? undefined : json['link_4'],
    'hasDiscord': !exists(json, 'has_discord') ? undefined : json['has_discord'],
    'createdAt': new Date(json['created_at']),
    'updatedAt': !exists(json, 'updated_at') ? undefined : new Date(json['updated_at']),
    'ownerId': !exists(json, 'owner_id') ? undefined : json['owner_id']
  };
}
function CoinToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'mint': value.mint,
    'ticker': value.ticker,
    'decimals': value.decimals,
    'name': value.name,
    'logo_uri': value.logoUri,
    'description': value.description,
    'x_handle': value.xHandle,
    'instagram_handle': value.instagramHandle,
    'tiktok_handle': value.tiktokHandle,
    'website': value.website,
    'link_1': value.link1,
    'link_2': value.link2,
    'link_3': value.link3,
    'link_4': value.link4,
    'has_discord': value.hasDiscord,
    'created_at': value.createdAt.toISOString(),
    'updated_at': value.updatedAt === undefined ? undefined : value.updatedAt.toISOString(),
    'owner_id': value.ownerId
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the CoinResponse interface.
 */
function instanceOfCoinResponse(value) {
  let isInstance = true;
  return isInstance;
}
function CoinResponseFromJSON(json) {
  return CoinResponseFromJSONTyped(json);
}
function CoinResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'data': !exists(json, 'data') ? undefined : CoinFromJSON(json['data'])
  };
}
function CoinResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'data': CoinToJSON(value.data)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the CoinsResponse interface.
 */
function instanceOfCoinsResponse(value) {
  let isInstance = true;
  isInstance = isInstance && "data" in value && value["data"] !== undefined;
  return isInstance;
}
function CoinsResponseFromJSON(json) {
  return CoinsResponseFromJSONTyped(json);
}
function CoinsResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'data': json['data'].map(CoinFromJSON)
  };
}
function CoinsResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'data': value.data.map(CoinToJSON)
  };
}

/* tslint:disable */
/**
 * @export
 */
const CollectionActivityFullItemTypeEnum = {
  Playlist: 'playlist'
};
/**
 * Check if a given object implements the CollectionActivityFull interface.
 */
function instanceOfCollectionActivityFull(value) {
  let isInstance = true;
  isInstance = isInstance && "itemType" in value && value["itemType"] !== undefined;
  isInstance = isInstance && "item" in value && value["item"] !== undefined;
  return isInstance;
}
function CollectionActivityFullFromJSON(json) {
  return CollectionActivityFullFromJSONTyped(json, false);
}
function CollectionActivityFullFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    ...ActivityFullFromJSONTyped(json, ignoreDiscriminator),
    'itemType': json['item_type'],
    'item': PlaylistFullFromJSON(json['item'])
  };
}
function CollectionActivityFullToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    ...ActivityFullToJSON(value),
    'item_type': value.itemType,
    'item': PlaylistFullToJSON(value.item)
  };
}

/* tslint:disable */
/**
 * @export
 */
const CollectionActivityFullWithoutTracksItemTypeEnum = {
  Playlist: 'playlist'
};
/**
 * Check if a given object implements the CollectionActivityFullWithoutTracks interface.
 */
function instanceOfCollectionActivityFullWithoutTracks(value) {
  let isInstance = true;
  isInstance = isInstance && "itemType" in value && value["itemType"] !== undefined;
  isInstance = isInstance && "item" in value && value["item"] !== undefined;
  return isInstance;
}
function CollectionActivityFullWithoutTracksFromJSON(json) {
  return CollectionActivityFullWithoutTracksFromJSONTyped(json, false);
}
function CollectionActivityFullWithoutTracksFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    ...ActivityFullFromJSONTyped(json, ignoreDiscriminator),
    'itemType': json['item_type'],
    'item': PlaylistFullWithoutTracksFromJSON(json['item'])
  };
}
function CollectionActivityFullWithoutTracksToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    ...ActivityFullToJSON(value),
    'item_type': value.itemType,
    'item': PlaylistFullWithoutTracksToJSON(value.item)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the CollectionLibraryResponseFull interface.
 */
function instanceOfCollectionLibraryResponseFull(value) {
  let isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value && value["latestChainBlock"] !== undefined;
  isInstance = isInstance && "latestIndexedBlock" in value && value["latestIndexedBlock"] !== undefined;
  isInstance = isInstance && "latestChainSlotPlays" in value && value["latestChainSlotPlays"] !== undefined;
  isInstance = isInstance && "latestIndexedSlotPlays" in value && value["latestIndexedSlotPlays"] !== undefined;
  isInstance = isInstance && "signature" in value && value["signature"] !== undefined;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== undefined;
  isInstance = isInstance && "version" in value && value["version"] !== undefined;
  return isInstance;
}
function CollectionLibraryResponseFullFromJSON(json) {
  return CollectionLibraryResponseFullFromJSONTyped(json);
}
function CollectionLibraryResponseFullFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : json['data'].map(CollectionActivityFullWithoutTracksFromJSON)
  };
}
function CollectionLibraryResponseFullToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': value.data === undefined ? undefined : value.data.map(CollectionActivityFullWithoutTracksToJSON)
  };
}

/* tslint:disable */
/* eslint-disable */
// @ts-nocheck
/**
 * API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * Check if a given object implements the CommentMention interface.
 */
function instanceOfCommentMention(value) {
  let isInstance = true;
  isInstance = isInstance && "userId" in value && value["userId"] !== undefined;
  isInstance = isInstance && "handle" in value && value["handle"] !== undefined;
  return isInstance;
}
function CommentMentionFromJSON(json) {
  return CommentMentionFromJSONTyped(json);
}
function CommentMentionFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'userId': json['user_id'],
    'handle': json['handle']
  };
}
function CommentMentionToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'user_id': value.userId,
    'handle': value.handle
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the ReplyComment interface.
 */
function instanceOfReplyComment(value) {
  let isInstance = true;
  isInstance = isInstance && "id" in value && value["id"] !== undefined;
  isInstance = isInstance && "entityId" in value && value["entityId"] !== undefined;
  isInstance = isInstance && "entityType" in value && value["entityType"] !== undefined;
  isInstance = isInstance && "userId" in value && value["userId"] !== undefined;
  isInstance = isInstance && "message" in value && value["message"] !== undefined;
  isInstance = isInstance && "reactCount" in value && value["reactCount"] !== undefined;
  isInstance = isInstance && "isEdited" in value && value["isEdited"] !== undefined;
  isInstance = isInstance && "createdAt" in value && value["createdAt"] !== undefined;
  return isInstance;
}
function ReplyCommentFromJSON(json) {
  return ReplyCommentFromJSONTyped(json);
}
function ReplyCommentFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'id': json['id'],
    'entityId': json['entity_id'],
    'entityType': json['entity_type'],
    'userId': json['user_id'],
    'message': json['message'],
    'mentions': !exists(json, 'mentions') ? undefined : json['mentions'].map(CommentMentionFromJSON),
    'trackTimestampS': !exists(json, 'track_timestamp_s') ? undefined : json['track_timestamp_s'],
    'reactCount': json['react_count'],
    'isEdited': json['is_edited'],
    'isCurrentUserReacted': !exists(json, 'is_current_user_reacted') ? undefined : json['is_current_user_reacted'],
    'isArtistReacted': !exists(json, 'is_artist_reacted') ? undefined : json['is_artist_reacted'],
    'createdAt': json['created_at'],
    'updatedAt': !exists(json, 'updated_at') ? undefined : json['updated_at'],
    'parentCommentId': !exists(json, 'parent_comment_id') ? undefined : json['parent_comment_id']
  };
}
function ReplyCommentToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'id': value.id,
    'entity_id': value.entityId,
    'entity_type': value.entityType,
    'user_id': value.userId,
    'message': value.message,
    'mentions': value.mentions === undefined ? undefined : value.mentions.map(CommentMentionToJSON),
    'track_timestamp_s': value.trackTimestampS,
    'react_count': value.reactCount,
    'is_edited': value.isEdited,
    'is_current_user_reacted': value.isCurrentUserReacted,
    'is_artist_reacted': value.isArtistReacted,
    'created_at': value.createdAt,
    'updated_at': value.updatedAt,
    'parent_comment_id': value.parentCommentId
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the Comment interface.
 */
function instanceOfComment(value) {
  let isInstance = true;
  isInstance = isInstance && "id" in value && value["id"] !== undefined;
  isInstance = isInstance && "entityId" in value && value["entityId"] !== undefined;
  isInstance = isInstance && "entityType" in value && value["entityType"] !== undefined;
  isInstance = isInstance && "message" in value && value["message"] !== undefined;
  isInstance = isInstance && "reactCount" in value && value["reactCount"] !== undefined;
  isInstance = isInstance && "replyCount" in value && value["replyCount"] !== undefined;
  isInstance = isInstance && "isEdited" in value && value["isEdited"] !== undefined;
  isInstance = isInstance && "createdAt" in value && value["createdAt"] !== undefined;
  return isInstance;
}
function CommentFromJSON(json) {
  return CommentFromJSONTyped(json);
}
function CommentFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'id': json['id'],
    'entityId': json['entity_id'],
    'entityType': json['entity_type'],
    'userId': !exists(json, 'user_id') ? undefined : json['user_id'],
    'message': json['message'],
    'mentions': !exists(json, 'mentions') ? undefined : json['mentions'].map(CommentMentionFromJSON),
    'trackTimestampS': !exists(json, 'track_timestamp_s') ? undefined : json['track_timestamp_s'],
    'reactCount': json['react_count'],
    'replyCount': json['reply_count'],
    'isEdited': json['is_edited'],
    'isCurrentUserReacted': !exists(json, 'is_current_user_reacted') ? undefined : json['is_current_user_reacted'],
    'isArtistReacted': !exists(json, 'is_artist_reacted') ? undefined : json['is_artist_reacted'],
    'isTombstone': !exists(json, 'is_tombstone') ? undefined : json['is_tombstone'],
    'isMuted': !exists(json, 'is_muted') ? undefined : json['is_muted'],
    'createdAt': json['created_at'],
    'updatedAt': !exists(json, 'updated_at') ? undefined : json['updated_at'],
    'replies': !exists(json, 'replies') ? undefined : json['replies'].map(ReplyCommentFromJSON),
    'parentCommentId': !exists(json, 'parent_comment_id') ? undefined : json['parent_comment_id']
  };
}
function CommentToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'id': value.id,
    'entity_id': value.entityId,
    'entity_type': value.entityType,
    'user_id': value.userId,
    'message': value.message,
    'mentions': value.mentions === undefined ? undefined : value.mentions.map(CommentMentionToJSON),
    'track_timestamp_s': value.trackTimestampS,
    'react_count': value.reactCount,
    'reply_count': value.replyCount,
    'is_edited': value.isEdited,
    'is_current_user_reacted': value.isCurrentUserReacted,
    'is_artist_reacted': value.isArtistReacted,
    'is_tombstone': value.isTombstone,
    'is_muted': value.isMuted,
    'created_at': value.createdAt,
    'updated_at': value.updatedAt,
    'replies': value.replies === undefined ? undefined : value.replies.map(ReplyCommentToJSON),
    'parent_comment_id': value.parentCommentId
  };
}

/* tslint:disable */
/**
 * @export
 */
const CommentMentionNotificationActionDataTypeEnum = {
  Track: 'Track',
  Playlist: 'Playlist',
  Album: 'Album'
};
/**
 * Check if a given object implements the CommentMentionNotificationActionData interface.
 */
function instanceOfCommentMentionNotificationActionData(value) {
  let isInstance = true;
  isInstance = isInstance && "type" in value && value["type"] !== undefined;
  isInstance = isInstance && "entityId" in value && value["entityId"] !== undefined;
  isInstance = isInstance && "entityUserId" in value && value["entityUserId"] !== undefined;
  isInstance = isInstance && "commentUserId" in value && value["commentUserId"] !== undefined;
  return isInstance;
}
function CommentMentionNotificationActionDataFromJSON(json) {
  return CommentMentionNotificationActionDataFromJSONTyped(json);
}
function CommentMentionNotificationActionDataFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'type': json['type'],
    'entityId': json['entity_id'],
    'entityUserId': json['entity_user_id'],
    'commentUserId': json['comment_user_id'],
    'commentId': !exists(json, 'comment_id') ? undefined : json['comment_id']
  };
}
function CommentMentionNotificationActionDataToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'type': value.type,
    'entity_id': value.entityId,
    'entity_user_id': value.entityUserId,
    'comment_user_id': value.commentUserId,
    'comment_id': value.commentId
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the CommentMentionNotificationAction interface.
 */
function instanceOfCommentMentionNotificationAction(value) {
  let isInstance = true;
  isInstance = isInstance && "specifier" in value && value["specifier"] !== undefined;
  isInstance = isInstance && "type" in value && value["type"] !== undefined;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== undefined;
  isInstance = isInstance && "data" in value && value["data"] !== undefined;
  return isInstance;
}
function CommentMentionNotificationActionFromJSON(json) {
  return CommentMentionNotificationActionFromJSONTyped(json);
}
function CommentMentionNotificationActionFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'specifier': json['specifier'],
    'type': json['type'],
    'timestamp': json['timestamp'],
    'data': CommentMentionNotificationActionDataFromJSON(json['data'])
  };
}
function CommentMentionNotificationActionToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'specifier': value.specifier,
    'type': value.type,
    'timestamp': value.timestamp,
    'data': CommentMentionNotificationActionDataToJSON(value.data)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the CommentMentionNotification interface.
 */
function instanceOfCommentMentionNotification(value) {
  let isInstance = true;
  isInstance = isInstance && "type" in value && value["type"] !== undefined;
  isInstance = isInstance && "groupId" in value && value["groupId"] !== undefined;
  isInstance = isInstance && "isSeen" in value && value["isSeen"] !== undefined;
  isInstance = isInstance && "actions" in value && value["actions"] !== undefined;
  return isInstance;
}
function CommentMentionNotificationFromJSON(json) {
  return CommentMentionNotificationFromJSONTyped(json);
}
function CommentMentionNotificationFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'type': json['type'],
    'groupId': json['group_id'],
    'isSeen': json['is_seen'],
    'seenAt': !exists(json, 'seen_at') ? undefined : json['seen_at'],
    'actions': json['actions'].map(CommentMentionNotificationActionFromJSON)
  };
}
function CommentMentionNotificationToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'type': value.type,
    'group_id': value.groupId,
    'is_seen': value.isSeen,
    'seen_at': value.seenAt,
    'actions': value.actions.map(CommentMentionNotificationActionToJSON)
  };
}

/* tslint:disable */
/**
 * @export
 */
const CommentNotificationActionDataTypeEnum = {
  Track: 'Track',
  Playlist: 'Playlist',
  Album: 'Album'
};
/**
 * Check if a given object implements the CommentNotificationActionData interface.
 */
function instanceOfCommentNotificationActionData(value) {
  let isInstance = true;
  isInstance = isInstance && "type" in value && value["type"] !== undefined;
  isInstance = isInstance && "entityId" in value && value["entityId"] !== undefined;
  isInstance = isInstance && "commentUserId" in value && value["commentUserId"] !== undefined;
  return isInstance;
}
function CommentNotificationActionDataFromJSON(json) {
  return CommentNotificationActionDataFromJSONTyped(json);
}
function CommentNotificationActionDataFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'type': json['type'],
    'entityId': json['entity_id'],
    'commentUserId': json['comment_user_id'],
    'commentId': !exists(json, 'comment_id') ? undefined : json['comment_id']
  };
}
function CommentNotificationActionDataToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'type': value.type,
    'entity_id': value.entityId,
    'comment_user_id': value.commentUserId,
    'comment_id': value.commentId
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the CommentNotificationAction interface.
 */
function instanceOfCommentNotificationAction(value) {
  let isInstance = true;
  isInstance = isInstance && "specifier" in value && value["specifier"] !== undefined;
  isInstance = isInstance && "type" in value && value["type"] !== undefined;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== undefined;
  isInstance = isInstance && "data" in value && value["data"] !== undefined;
  return isInstance;
}
function CommentNotificationActionFromJSON(json) {
  return CommentNotificationActionFromJSONTyped(json);
}
function CommentNotificationActionFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'specifier': json['specifier'],
    'type': json['type'],
    'timestamp': json['timestamp'],
    'data': CommentNotificationActionDataFromJSON(json['data'])
  };
}
function CommentNotificationActionToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'specifier': value.specifier,
    'type': value.type,
    'timestamp': value.timestamp,
    'data': CommentNotificationActionDataToJSON(value.data)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the CommentNotification interface.
 */
function instanceOfCommentNotification(value) {
  let isInstance = true;
  isInstance = isInstance && "type" in value && value["type"] !== undefined;
  isInstance = isInstance && "groupId" in value && value["groupId"] !== undefined;
  isInstance = isInstance && "isSeen" in value && value["isSeen"] !== undefined;
  isInstance = isInstance && "actions" in value && value["actions"] !== undefined;
  return isInstance;
}
function CommentNotificationFromJSON(json) {
  return CommentNotificationFromJSONTyped(json);
}
function CommentNotificationFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'type': json['type'],
    'groupId': json['group_id'],
    'isSeen': json['is_seen'],
    'seenAt': !exists(json, 'seen_at') ? undefined : json['seen_at'],
    'actions': json['actions'].map(CommentNotificationActionFromJSON)
  };
}
function CommentNotificationToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'type': value.type,
    'group_id': value.groupId,
    'is_seen': value.isSeen,
    'seen_at': value.seenAt,
    'actions': value.actions.map(CommentNotificationActionToJSON)
  };
}

/* tslint:disable */
/**
 * @export
 */
const CommentReactionNotificationActionDataTypeEnum = {
  Track: 'Track',
  Playlist: 'Playlist',
  Album: 'Album'
};
/**
 * Check if a given object implements the CommentReactionNotificationActionData interface.
 */
function instanceOfCommentReactionNotificationActionData(value) {
  let isInstance = true;
  isInstance = isInstance && "type" in value && value["type"] !== undefined;
  isInstance = isInstance && "entityId" in value && value["entityId"] !== undefined;
  isInstance = isInstance && "entityUserId" in value && value["entityUserId"] !== undefined;
  isInstance = isInstance && "reacterUserId" in value && value["reacterUserId"] !== undefined;
  return isInstance;
}
function CommentReactionNotificationActionDataFromJSON(json) {
  return CommentReactionNotificationActionDataFromJSONTyped(json);
}
function CommentReactionNotificationActionDataFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'type': json['type'],
    'entityId': json['entity_id'],
    'entityUserId': json['entity_user_id'],
    'reacterUserId': json['reacter_user_id'],
    'commentId': !exists(json, 'comment_id') ? undefined : json['comment_id']
  };
}
function CommentReactionNotificationActionDataToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'type': value.type,
    'entity_id': value.entityId,
    'entity_user_id': value.entityUserId,
    'reacter_user_id': value.reacterUserId,
    'comment_id': value.commentId
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the CommentReactionNotificationAction interface.
 */
function instanceOfCommentReactionNotificationAction(value) {
  let isInstance = true;
  isInstance = isInstance && "specifier" in value && value["specifier"] !== undefined;
  isInstance = isInstance && "type" in value && value["type"] !== undefined;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== undefined;
  isInstance = isInstance && "data" in value && value["data"] !== undefined;
  return isInstance;
}
function CommentReactionNotificationActionFromJSON(json) {
  return CommentReactionNotificationActionFromJSONTyped(json);
}
function CommentReactionNotificationActionFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'specifier': json['specifier'],
    'type': json['type'],
    'timestamp': json['timestamp'],
    'data': CommentReactionNotificationActionDataFromJSON(json['data'])
  };
}
function CommentReactionNotificationActionToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'specifier': value.specifier,
    'type': value.type,
    'timestamp': value.timestamp,
    'data': CommentReactionNotificationActionDataToJSON(value.data)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the CommentReactionNotification interface.
 */
function instanceOfCommentReactionNotification(value) {
  let isInstance = true;
  isInstance = isInstance && "type" in value && value["type"] !== undefined;
  isInstance = isInstance && "groupId" in value && value["groupId"] !== undefined;
  isInstance = isInstance && "isSeen" in value && value["isSeen"] !== undefined;
  isInstance = isInstance && "actions" in value && value["actions"] !== undefined;
  return isInstance;
}
function CommentReactionNotificationFromJSON(json) {
  return CommentReactionNotificationFromJSONTyped(json);
}
function CommentReactionNotificationFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'type': json['type'],
    'groupId': json['group_id'],
    'isSeen': json['is_seen'],
    'seenAt': !exists(json, 'seen_at') ? undefined : json['seen_at'],
    'actions': json['actions'].map(CommentReactionNotificationActionFromJSON)
  };
}
function CommentReactionNotificationToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'type': value.type,
    'group_id': value.groupId,
    'is_seen': value.isSeen,
    'seen_at': value.seenAt,
    'actions': value.actions.map(CommentReactionNotificationActionToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the CommentRepliesResponse interface.
 */
function instanceOfCommentRepliesResponse(value) {
  let isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value && value["latestChainBlock"] !== undefined;
  isInstance = isInstance && "latestIndexedBlock" in value && value["latestIndexedBlock"] !== undefined;
  isInstance = isInstance && "latestChainSlotPlays" in value && value["latestChainSlotPlays"] !== undefined;
  isInstance = isInstance && "latestIndexedSlotPlays" in value && value["latestIndexedSlotPlays"] !== undefined;
  isInstance = isInstance && "signature" in value && value["signature"] !== undefined;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== undefined;
  isInstance = isInstance && "version" in value && value["version"] !== undefined;
  return isInstance;
}
function CommentRepliesResponseFromJSON(json) {
  return CommentRepliesResponseFromJSONTyped(json);
}
function CommentRepliesResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : json['data'].map(ReplyCommentFromJSON),
    'related': !exists(json, 'related') ? undefined : RelatedFromJSON(json['related'])
  };
}
function CommentRepliesResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': value.data === undefined ? undefined : value.data.map(ReplyCommentToJSON),
    'related': RelatedToJSON(value.related)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the CommentResponse interface.
 */
function instanceOfCommentResponse(value) {
  let isInstance = true;
  return isInstance;
}
function CommentResponseFromJSON(json) {
  return CommentResponseFromJSONTyped(json);
}
function CommentResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'data': !exists(json, 'data') ? undefined : json['data'].map(CommentFromJSON)
  };
}
function CommentResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'data': value.data === undefined ? undefined : value.data.map(CommentToJSON)
  };
}

/* tslint:disable */
/**
 * @export
 */
const CommentThreadNotificationActionDataTypeEnum = {
  Track: 'Track',
  Playlist: 'Playlist',
  Album: 'Album'
};
/**
 * Check if a given object implements the CommentThreadNotificationActionData interface.
 */
function instanceOfCommentThreadNotificationActionData(value) {
  let isInstance = true;
  isInstance = isInstance && "type" in value && value["type"] !== undefined;
  isInstance = isInstance && "entityId" in value && value["entityId"] !== undefined;
  isInstance = isInstance && "entityUserId" in value && value["entityUserId"] !== undefined;
  isInstance = isInstance && "commentUserId" in value && value["commentUserId"] !== undefined;
  return isInstance;
}
function CommentThreadNotificationActionDataFromJSON(json) {
  return CommentThreadNotificationActionDataFromJSONTyped(json);
}
function CommentThreadNotificationActionDataFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'type': json['type'],
    'entityId': json['entity_id'],
    'entityUserId': json['entity_user_id'],
    'commentUserId': json['comment_user_id'],
    'commentId': !exists(json, 'comment_id') ? undefined : json['comment_id']
  };
}
function CommentThreadNotificationActionDataToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'type': value.type,
    'entity_id': value.entityId,
    'entity_user_id': value.entityUserId,
    'comment_user_id': value.commentUserId,
    'comment_id': value.commentId
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the CommentThreadNotificationAction interface.
 */
function instanceOfCommentThreadNotificationAction(value) {
  let isInstance = true;
  isInstance = isInstance && "specifier" in value && value["specifier"] !== undefined;
  isInstance = isInstance && "type" in value && value["type"] !== undefined;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== undefined;
  isInstance = isInstance && "data" in value && value["data"] !== undefined;
  return isInstance;
}
function CommentThreadNotificationActionFromJSON(json) {
  return CommentThreadNotificationActionFromJSONTyped(json);
}
function CommentThreadNotificationActionFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'specifier': json['specifier'],
    'type': json['type'],
    'timestamp': json['timestamp'],
    'data': CommentThreadNotificationActionDataFromJSON(json['data'])
  };
}
function CommentThreadNotificationActionToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'specifier': value.specifier,
    'type': value.type,
    'timestamp': value.timestamp,
    'data': CommentThreadNotificationActionDataToJSON(value.data)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the CommentThreadNotification interface.
 */
function instanceOfCommentThreadNotification(value) {
  let isInstance = true;
  isInstance = isInstance && "type" in value && value["type"] !== undefined;
  isInstance = isInstance && "groupId" in value && value["groupId"] !== undefined;
  isInstance = isInstance && "isSeen" in value && value["isSeen"] !== undefined;
  isInstance = isInstance && "actions" in value && value["actions"] !== undefined;
  return isInstance;
}
function CommentThreadNotificationFromJSON(json) {
  return CommentThreadNotificationFromJSONTyped(json);
}
function CommentThreadNotificationFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'type': json['type'],
    'groupId': json['group_id'],
    'isSeen': json['is_seen'],
    'seenAt': !exists(json, 'seen_at') ? undefined : json['seen_at'],
    'actions': json['actions'].map(CommentThreadNotificationActionFromJSON)
  };
}
function CommentThreadNotificationToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'type': value.type,
    'group_id': value.groupId,
    'is_seen': value.isSeen,
    'seen_at': value.seenAt,
    'actions': value.actions.map(CommentThreadNotificationActionToJSON)
  };
}

/* tslint:disable */
/* eslint-disable */
// @ts-nocheck
/**
 * API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * Check if a given object implements the CosignNotificationActionData interface.
 */
function instanceOfCosignNotificationActionData(value) {
  let isInstance = true;
  isInstance = isInstance && "parentTrackId" in value && value["parentTrackId"] !== undefined;
  isInstance = isInstance && "trackId" in value && value["trackId"] !== undefined;
  isInstance = isInstance && "trackOwnerId" in value && value["trackOwnerId"] !== undefined;
  return isInstance;
}
function CosignNotificationActionDataFromJSON(json) {
  return CosignNotificationActionDataFromJSONTyped(json);
}
function CosignNotificationActionDataFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'parentTrackId': json['parent_track_id'],
    'trackId': json['track_id'],
    'trackOwnerId': json['track_owner_id']
  };
}
function CosignNotificationActionDataToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'parent_track_id': value.parentTrackId,
    'track_id': value.trackId,
    'track_owner_id': value.trackOwnerId
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the CosignNotificationAction interface.
 */
function instanceOfCosignNotificationAction(value) {
  let isInstance = true;
  isInstance = isInstance && "specifier" in value && value["specifier"] !== undefined;
  isInstance = isInstance && "type" in value && value["type"] !== undefined;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== undefined;
  isInstance = isInstance && "data" in value && value["data"] !== undefined;
  return isInstance;
}
function CosignNotificationActionFromJSON(json) {
  return CosignNotificationActionFromJSONTyped(json);
}
function CosignNotificationActionFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'specifier': json['specifier'],
    'type': json['type'],
    'timestamp': json['timestamp'],
    'data': CosignNotificationActionDataFromJSON(json['data'])
  };
}
function CosignNotificationActionToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'specifier': value.specifier,
    'type': value.type,
    'timestamp': value.timestamp,
    'data': CosignNotificationActionDataToJSON(value.data)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the CosignNotification interface.
 */
function instanceOfCosignNotification(value) {
  let isInstance = true;
  isInstance = isInstance && "type" in value && value["type"] !== undefined;
  isInstance = isInstance && "groupId" in value && value["groupId"] !== undefined;
  isInstance = isInstance && "isSeen" in value && value["isSeen"] !== undefined;
  isInstance = isInstance && "actions" in value && value["actions"] !== undefined;
  return isInstance;
}
function CosignNotificationFromJSON(json) {
  return CosignNotificationFromJSONTyped(json);
}
function CosignNotificationFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'type': json['type'],
    'groupId': json['group_id'],
    'isSeen': json['is_seen'],
    'seenAt': !exists(json, 'seen_at') ? undefined : json['seen_at'],
    'actions': json['actions'].map(CosignNotificationActionFromJSON)
  };
}
function CosignNotificationToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'type': value.type,
    'group_id': value.groupId,
    'is_seen': value.isSeen,
    'seen_at': value.seenAt,
    'actions': value.actions.map(CosignNotificationActionToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the CreateCoinRequest interface.
 */
function instanceOfCreateCoinRequest(value) {
  let isInstance = true;
  isInstance = isInstance && "mint" in value && value["mint"] !== undefined;
  isInstance = isInstance && "ticker" in value && value["ticker"] !== undefined;
  isInstance = isInstance && "decimals" in value && value["decimals"] !== undefined;
  isInstance = isInstance && "name" in value && value["name"] !== undefined;
  return isInstance;
}
function CreateCoinRequestFromJSON(json) {
  return CreateCoinRequestFromJSONTyped(json);
}
function CreateCoinRequestFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'mint': json['mint'],
    'ticker': json['ticker'],
    'decimals': json['decimals'],
    'name': json['name'],
    'logoUri': !exists(json, 'logo_uri') ? undefined : json['logo_uri'],
    'description': !exists(json, 'description') ? undefined : json['description']
  };
}
function CreateCoinRequestToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'mint': value.mint,
    'ticker': value.ticker,
    'decimals': value.decimals,
    'name': value.name,
    'logo_uri': value.logoUri,
    'description': value.description
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the CreateCoinResponseData interface.
 */
function instanceOfCreateCoinResponseData(value) {
  let isInstance = true;
  isInstance = isInstance && "mint" in value && value["mint"] !== undefined;
  isInstance = isInstance && "ticker" in value && value["ticker"] !== undefined;
  isInstance = isInstance && "userId" in value && value["userId"] !== undefined;
  isInstance = isInstance && "decimals" in value && value["decimals"] !== undefined;
  isInstance = isInstance && "name" in value && value["name"] !== undefined;
  isInstance = isInstance && "createdAt" in value && value["createdAt"] !== undefined;
  return isInstance;
}
function CreateCoinResponseDataFromJSON(json) {
  return CreateCoinResponseDataFromJSONTyped(json);
}
function CreateCoinResponseDataFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'mint': json['mint'],
    'ticker': json['ticker'],
    'userId': json['user_id'],
    'decimals': json['decimals'],
    'name': json['name'],
    'logoUri': !exists(json, 'logo_uri') ? undefined : json['logo_uri'],
    'createdAt': new Date(json['created_at'])
  };
}
function CreateCoinResponseDataToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'mint': value.mint,
    'ticker': value.ticker,
    'user_id': value.userId,
    'decimals': value.decimals,
    'name': value.name,
    'logo_uri': value.logoUri,
    'created_at': value.createdAt.toISOString()
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the CreateCoinResponse interface.
 */
function instanceOfCreateCoinResponse(value) {
  let isInstance = true;
  return isInstance;
}
function CreateCoinResponseFromJSON(json) {
  return CreateCoinResponseFromJSONTyped(json);
}
function CreateCoinResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'data': !exists(json, 'data') ? undefined : CreateCoinResponseDataFromJSON(json['data'])
  };
}
function CreateCoinResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'data': CreateCoinResponseDataToJSON(value.data)
  };
}

/* tslint:disable */
/* eslint-disable */
// @ts-nocheck
/**
 * API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * Check if a given object implements the CreatePlaylistNotificationActionData interface.
 */
function instanceOfCreatePlaylistNotificationActionData(value) {
  let isInstance = true;
  isInstance = isInstance && "isAlbum" in value && value["isAlbum"] !== undefined;
  isInstance = isInstance && "playlistId" in value && value["playlistId"] !== undefined;
  return isInstance;
}
function CreatePlaylistNotificationActionDataFromJSON(json) {
  return CreatePlaylistNotificationActionDataFromJSONTyped(json);
}
function CreatePlaylistNotificationActionDataFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'isAlbum': json['is_album'],
    'playlistId': json['playlist_id']
  };
}
function CreatePlaylistNotificationActionDataToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'is_album': value.isAlbum,
    'playlist_id': value.playlistId
  };
}

/* tslint:disable */
/* eslint-disable */
// @ts-nocheck
/**
 * API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * Check if a given object implements the CreateTrackNotificationActionData interface.
 */
function instanceOfCreateTrackNotificationActionData(value) {
  let isInstance = true;
  isInstance = isInstance && "trackId" in value && value["trackId"] !== undefined;
  return isInstance;
}
function CreateTrackNotificationActionDataFromJSON(json) {
  return CreateTrackNotificationActionDataFromJSONTyped(json);
}
function CreateTrackNotificationActionDataFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'trackId': json['track_id']
  };
}
function CreateTrackNotificationActionDataToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'track_id': value.trackId
  };
}

/* tslint:disable */
function CreateNotificationActionDataFromJSON(json) {
  return CreateNotificationActionDataFromJSONTyped(json);
}
function CreateNotificationActionDataFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    ...CreatePlaylistNotificationActionDataFromJSONTyped(json),
    ...CreateTrackNotificationActionDataFromJSONTyped(json)
  };
}
function CreateNotificationActionDataToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  if (instanceOfCreatePlaylistNotificationActionData(value)) {
    return CreatePlaylistNotificationActionDataToJSON(value);
  }
  if (instanceOfCreateTrackNotificationActionData(value)) {
    return CreateTrackNotificationActionDataToJSON(value);
  }
  return {};
}

/* tslint:disable */
/**
 * Check if a given object implements the CreateNotificationAction interface.
 */
function instanceOfCreateNotificationAction(value) {
  let isInstance = true;
  isInstance = isInstance && "specifier" in value && value["specifier"] !== undefined;
  isInstance = isInstance && "type" in value && value["type"] !== undefined;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== undefined;
  isInstance = isInstance && "data" in value && value["data"] !== undefined;
  return isInstance;
}
function CreateNotificationActionFromJSON(json) {
  return CreateNotificationActionFromJSONTyped(json);
}
function CreateNotificationActionFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'specifier': json['specifier'],
    'type': json['type'],
    'timestamp': json['timestamp'],
    'data': CreateNotificationActionDataFromJSON(json['data'])
  };
}
function CreateNotificationActionToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'specifier': value.specifier,
    'type': value.type,
    'timestamp': value.timestamp,
    'data': CreateNotificationActionDataToJSON(value.data)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the CreateNotification interface.
 */
function instanceOfCreateNotification(value) {
  let isInstance = true;
  isInstance = isInstance && "type" in value && value["type"] !== undefined;
  isInstance = isInstance && "groupId" in value && value["groupId"] !== undefined;
  isInstance = isInstance && "isSeen" in value && value["isSeen"] !== undefined;
  isInstance = isInstance && "actions" in value && value["actions"] !== undefined;
  return isInstance;
}
function CreateNotificationFromJSON(json) {
  return CreateNotificationFromJSONTyped(json);
}
function CreateNotificationFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'type': json['type'],
    'groupId': json['group_id'],
    'isSeen': json['is_seen'],
    'seenAt': !exists(json, 'seen_at') ? undefined : json['seen_at'],
    'actions': json['actions'].map(CreateNotificationActionFromJSON)
  };
}
function CreateNotificationToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'type': value.type,
    'group_id': value.groupId,
    'is_seen': value.isSeen,
    'seen_at': value.seenAt,
    'actions': value.actions.map(CreateNotificationActionToJSON)
  };
}

/* tslint:disable */
/* eslint-disable */
// @ts-nocheck
/**
 * API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * Check if a given object implements the FanRemixContestEndedNotificationActionData interface.
 */
function instanceOfFanRemixContestEndedNotificationActionData(value) {
  let isInstance = true;
  isInstance = isInstance && "entityUserId" in value && value["entityUserId"] !== undefined;
  isInstance = isInstance && "entityId" in value && value["entityId"] !== undefined;
  return isInstance;
}
function FanRemixContestEndedNotificationActionDataFromJSON(json) {
  return FanRemixContestEndedNotificationActionDataFromJSONTyped(json);
}
function FanRemixContestEndedNotificationActionDataFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'entityUserId': json['entity_user_id'],
    'entityId': json['entity_id']
  };
}
function FanRemixContestEndedNotificationActionDataToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'entity_user_id': value.entityUserId,
    'entity_id': value.entityId
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the FanRemixContestEndedNotificationAction interface.
 */
function instanceOfFanRemixContestEndedNotificationAction(value) {
  let isInstance = true;
  isInstance = isInstance && "specifier" in value && value["specifier"] !== undefined;
  isInstance = isInstance && "type" in value && value["type"] !== undefined;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== undefined;
  isInstance = isInstance && "data" in value && value["data"] !== undefined;
  return isInstance;
}
function FanRemixContestEndedNotificationActionFromJSON(json) {
  return FanRemixContestEndedNotificationActionFromJSONTyped(json);
}
function FanRemixContestEndedNotificationActionFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'specifier': json['specifier'],
    'type': json['type'],
    'timestamp': json['timestamp'],
    'data': FanRemixContestEndedNotificationActionDataFromJSON(json['data'])
  };
}
function FanRemixContestEndedNotificationActionToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'specifier': value.specifier,
    'type': value.type,
    'timestamp': value.timestamp,
    'data': FanRemixContestEndedNotificationActionDataToJSON(value.data)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the FanRemixContestEndedNotification interface.
 */
function instanceOfFanRemixContestEndedNotification(value) {
  let isInstance = true;
  isInstance = isInstance && "type" in value && value["type"] !== undefined;
  isInstance = isInstance && "groupId" in value && value["groupId"] !== undefined;
  isInstance = isInstance && "isSeen" in value && value["isSeen"] !== undefined;
  isInstance = isInstance && "actions" in value && value["actions"] !== undefined;
  return isInstance;
}
function FanRemixContestEndedNotificationFromJSON(json) {
  return FanRemixContestEndedNotificationFromJSONTyped(json);
}
function FanRemixContestEndedNotificationFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'type': json['type'],
    'groupId': json['group_id'],
    'isSeen': json['is_seen'],
    'seenAt': !exists(json, 'seen_at') ? undefined : json['seen_at'],
    'actions': json['actions'].map(FanRemixContestEndedNotificationActionFromJSON)
  };
}
function FanRemixContestEndedNotificationToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'type': value.type,
    'group_id': value.groupId,
    'is_seen': value.isSeen,
    'seen_at': value.seenAt,
    'actions': value.actions.map(FanRemixContestEndedNotificationActionToJSON)
  };
}

/* tslint:disable */
/* eslint-disable */
// @ts-nocheck
/**
 * API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * Check if a given object implements the FanRemixContestEndingSoonNotificationActionData interface.
 */
function instanceOfFanRemixContestEndingSoonNotificationActionData(value) {
  let isInstance = true;
  isInstance = isInstance && "entityUserId" in value && value["entityUserId"] !== undefined;
  isInstance = isInstance && "entityId" in value && value["entityId"] !== undefined;
  return isInstance;
}
function FanRemixContestEndingSoonNotificationActionDataFromJSON(json) {
  return FanRemixContestEndingSoonNotificationActionDataFromJSONTyped(json);
}
function FanRemixContestEndingSoonNotificationActionDataFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'entityUserId': json['entity_user_id'],
    'entityId': json['entity_id']
  };
}
function FanRemixContestEndingSoonNotificationActionDataToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'entity_user_id': value.entityUserId,
    'entity_id': value.entityId
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the FanRemixContestEndingSoonNotificationAction interface.
 */
function instanceOfFanRemixContestEndingSoonNotificationAction(value) {
  let isInstance = true;
  isInstance = isInstance && "specifier" in value && value["specifier"] !== undefined;
  isInstance = isInstance && "type" in value && value["type"] !== undefined;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== undefined;
  isInstance = isInstance && "data" in value && value["data"] !== undefined;
  return isInstance;
}
function FanRemixContestEndingSoonNotificationActionFromJSON(json) {
  return FanRemixContestEndingSoonNotificationActionFromJSONTyped(json);
}
function FanRemixContestEndingSoonNotificationActionFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'specifier': json['specifier'],
    'type': json['type'],
    'timestamp': json['timestamp'],
    'data': FanRemixContestEndingSoonNotificationActionDataFromJSON(json['data'])
  };
}
function FanRemixContestEndingSoonNotificationActionToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'specifier': value.specifier,
    'type': value.type,
    'timestamp': value.timestamp,
    'data': FanRemixContestEndingSoonNotificationActionDataToJSON(value.data)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the FanRemixContestEndingSoonNotification interface.
 */
function instanceOfFanRemixContestEndingSoonNotification(value) {
  let isInstance = true;
  isInstance = isInstance && "type" in value && value["type"] !== undefined;
  isInstance = isInstance && "groupId" in value && value["groupId"] !== undefined;
  isInstance = isInstance && "isSeen" in value && value["isSeen"] !== undefined;
  isInstance = isInstance && "actions" in value && value["actions"] !== undefined;
  return isInstance;
}
function FanRemixContestEndingSoonNotificationFromJSON(json) {
  return FanRemixContestEndingSoonNotificationFromJSONTyped(json);
}
function FanRemixContestEndingSoonNotificationFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'type': json['type'],
    'groupId': json['group_id'],
    'isSeen': json['is_seen'],
    'seenAt': !exists(json, 'seen_at') ? undefined : json['seen_at'],
    'actions': json['actions'].map(FanRemixContestEndingSoonNotificationActionFromJSON)
  };
}
function FanRemixContestEndingSoonNotificationToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'type': value.type,
    'group_id': value.groupId,
    'is_seen': value.isSeen,
    'seen_at': value.seenAt,
    'actions': value.actions.map(FanRemixContestEndingSoonNotificationActionToJSON)
  };
}

/* tslint:disable */
/* eslint-disable */
// @ts-nocheck
/**
 * API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * Check if a given object implements the FanRemixContestStartedNotificationActionData interface.
 */
function instanceOfFanRemixContestStartedNotificationActionData(value) {
  let isInstance = true;
  isInstance = isInstance && "entityUserId" in value && value["entityUserId"] !== undefined;
  isInstance = isInstance && "entityId" in value && value["entityId"] !== undefined;
  return isInstance;
}
function FanRemixContestStartedNotificationActionDataFromJSON(json) {
  return FanRemixContestStartedNotificationActionDataFromJSONTyped(json);
}
function FanRemixContestStartedNotificationActionDataFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'entityUserId': json['entity_user_id'],
    'entityId': json['entity_id']
  };
}
function FanRemixContestStartedNotificationActionDataToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'entity_user_id': value.entityUserId,
    'entity_id': value.entityId
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the FanRemixContestStartedNotificationAction interface.
 */
function instanceOfFanRemixContestStartedNotificationAction(value) {
  let isInstance = true;
  isInstance = isInstance && "specifier" in value && value["specifier"] !== undefined;
  isInstance = isInstance && "type" in value && value["type"] !== undefined;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== undefined;
  isInstance = isInstance && "data" in value && value["data"] !== undefined;
  return isInstance;
}
function FanRemixContestStartedNotificationActionFromJSON(json) {
  return FanRemixContestStartedNotificationActionFromJSONTyped(json);
}
function FanRemixContestStartedNotificationActionFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'specifier': json['specifier'],
    'type': json['type'],
    'timestamp': json['timestamp'],
    'data': FanRemixContestStartedNotificationActionDataFromJSON(json['data'])
  };
}
function FanRemixContestStartedNotificationActionToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'specifier': value.specifier,
    'type': value.type,
    'timestamp': value.timestamp,
    'data': FanRemixContestStartedNotificationActionDataToJSON(value.data)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the FanRemixContestStartedNotification interface.
 */
function instanceOfFanRemixContestStartedNotification(value) {
  let isInstance = true;
  isInstance = isInstance && "type" in value && value["type"] !== undefined;
  isInstance = isInstance && "groupId" in value && value["groupId"] !== undefined;
  isInstance = isInstance && "isSeen" in value && value["isSeen"] !== undefined;
  isInstance = isInstance && "actions" in value && value["actions"] !== undefined;
  return isInstance;
}
function FanRemixContestStartedNotificationFromJSON(json) {
  return FanRemixContestStartedNotificationFromJSONTyped(json);
}
function FanRemixContestStartedNotificationFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'type': json['type'],
    'groupId': json['group_id'],
    'isSeen': json['is_seen'],
    'seenAt': !exists(json, 'seen_at') ? undefined : json['seen_at'],
    'actions': json['actions'].map(FanRemixContestStartedNotificationActionFromJSON)
  };
}
function FanRemixContestStartedNotificationToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'type': value.type,
    'group_id': value.groupId,
    'is_seen': value.isSeen,
    'seen_at': value.seenAt,
    'actions': value.actions.map(FanRemixContestStartedNotificationActionToJSON)
  };
}

/* tslint:disable */
/* eslint-disable */
// @ts-nocheck
/**
 * API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * Check if a given object implements the FanRemixContestWinnersSelectedNotificationActionData interface.
 */
function instanceOfFanRemixContestWinnersSelectedNotificationActionData(value) {
  let isInstance = true;
  isInstance = isInstance && "entityUserId" in value && value["entityUserId"] !== undefined;
  isInstance = isInstance && "entityId" in value && value["entityId"] !== undefined;
  return isInstance;
}
function FanRemixContestWinnersSelectedNotificationActionDataFromJSON(json) {
  return FanRemixContestWinnersSelectedNotificationActionDataFromJSONTyped(json);
}
function FanRemixContestWinnersSelectedNotificationActionDataFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'entityUserId': json['entity_user_id'],
    'entityId': json['entity_id']
  };
}
function FanRemixContestWinnersSelectedNotificationActionDataToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'entity_user_id': value.entityUserId,
    'entity_id': value.entityId
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the FanRemixContestWinnersSelectedNotificationAction interface.
 */
function instanceOfFanRemixContestWinnersSelectedNotificationAction(value) {
  let isInstance = true;
  isInstance = isInstance && "specifier" in value && value["specifier"] !== undefined;
  isInstance = isInstance && "type" in value && value["type"] !== undefined;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== undefined;
  isInstance = isInstance && "data" in value && value["data"] !== undefined;
  return isInstance;
}
function FanRemixContestWinnersSelectedNotificationActionFromJSON(json) {
  return FanRemixContestWinnersSelectedNotificationActionFromJSONTyped(json);
}
function FanRemixContestWinnersSelectedNotificationActionFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'specifier': json['specifier'],
    'type': json['type'],
    'timestamp': json['timestamp'],
    'data': FanRemixContestWinnersSelectedNotificationActionDataFromJSON(json['data'])
  };
}
function FanRemixContestWinnersSelectedNotificationActionToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'specifier': value.specifier,
    'type': value.type,
    'timestamp': value.timestamp,
    'data': FanRemixContestWinnersSelectedNotificationActionDataToJSON(value.data)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the FanRemixContestWinnersSelectedNotification interface.
 */
function instanceOfFanRemixContestWinnersSelectedNotification(value) {
  let isInstance = true;
  isInstance = isInstance && "type" in value && value["type"] !== undefined;
  isInstance = isInstance && "groupId" in value && value["groupId"] !== undefined;
  isInstance = isInstance && "isSeen" in value && value["isSeen"] !== undefined;
  isInstance = isInstance && "actions" in value && value["actions"] !== undefined;
  return isInstance;
}
function FanRemixContestWinnersSelectedNotificationFromJSON(json) {
  return FanRemixContestWinnersSelectedNotificationFromJSONTyped(json);
}
function FanRemixContestWinnersSelectedNotificationFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'type': json['type'],
    'groupId': json['group_id'],
    'isSeen': json['is_seen'],
    'seenAt': !exists(json, 'seen_at') ? undefined : json['seen_at'],
    'actions': json['actions'].map(FanRemixContestWinnersSelectedNotificationActionFromJSON)
  };
}
function FanRemixContestWinnersSelectedNotificationToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'type': value.type,
    'group_id': value.groupId,
    'is_seen': value.isSeen,
    'seen_at': value.seenAt,
    'actions': value.actions.map(FanRemixContestWinnersSelectedNotificationActionToJSON)
  };
}

/* tslint:disable */
/* eslint-disable */
// @ts-nocheck
/**
 * API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * Check if a given object implements the FollowNotificationActionData interface.
 */
function instanceOfFollowNotificationActionData(value) {
  let isInstance = true;
  isInstance = isInstance && "followerUserId" in value && value["followerUserId"] !== undefined;
  isInstance = isInstance && "followeeUserId" in value && value["followeeUserId"] !== undefined;
  return isInstance;
}
function FollowNotificationActionDataFromJSON(json) {
  return FollowNotificationActionDataFromJSONTyped(json);
}
function FollowNotificationActionDataFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'followerUserId': json['follower_user_id'],
    'followeeUserId': json['followee_user_id']
  };
}
function FollowNotificationActionDataToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'follower_user_id': value.followerUserId,
    'followee_user_id': value.followeeUserId
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the FollowNotificationAction interface.
 */
function instanceOfFollowNotificationAction(value) {
  let isInstance = true;
  isInstance = isInstance && "specifier" in value && value["specifier"] !== undefined;
  isInstance = isInstance && "type" in value && value["type"] !== undefined;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== undefined;
  isInstance = isInstance && "data" in value && value["data"] !== undefined;
  return isInstance;
}
function FollowNotificationActionFromJSON(json) {
  return FollowNotificationActionFromJSONTyped(json);
}
function FollowNotificationActionFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'specifier': json['specifier'],
    'type': json['type'],
    'timestamp': json['timestamp'],
    'data': FollowNotificationActionDataFromJSON(json['data'])
  };
}
function FollowNotificationActionToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'specifier': value.specifier,
    'type': value.type,
    'timestamp': value.timestamp,
    'data': FollowNotificationActionDataToJSON(value.data)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the FollowNotification interface.
 */
function instanceOfFollowNotification(value) {
  let isInstance = true;
  isInstance = isInstance && "type" in value && value["type"] !== undefined;
  isInstance = isInstance && "groupId" in value && value["groupId"] !== undefined;
  isInstance = isInstance && "isSeen" in value && value["isSeen"] !== undefined;
  isInstance = isInstance && "actions" in value && value["actions"] !== undefined;
  return isInstance;
}
function FollowNotificationFromJSON(json) {
  return FollowNotificationFromJSONTyped(json);
}
function FollowNotificationFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'type': json['type'],
    'groupId': json['group_id'],
    'isSeen': json['is_seen'],
    'seenAt': !exists(json, 'seen_at') ? undefined : json['seen_at'],
    'actions': json['actions'].map(FollowNotificationActionFromJSON)
  };
}
function FollowNotificationToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'type': value.type,
    'group_id': value.groupId,
    'is_seen': value.isSeen,
    'seen_at': value.seenAt,
    'actions': value.actions.map(FollowNotificationActionToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the FollowingResponse interface.
 */
function instanceOfFollowingResponse(value) {
  let isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value && value["latestChainBlock"] !== undefined;
  isInstance = isInstance && "latestIndexedBlock" in value && value["latestIndexedBlock"] !== undefined;
  isInstance = isInstance && "latestChainSlotPlays" in value && value["latestChainSlotPlays"] !== undefined;
  isInstance = isInstance && "latestIndexedSlotPlays" in value && value["latestIndexedSlotPlays"] !== undefined;
  isInstance = isInstance && "signature" in value && value["signature"] !== undefined;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== undefined;
  isInstance = isInstance && "version" in value && value["version"] !== undefined;
  return isInstance;
}
function FollowingResponseFromJSON(json) {
  return FollowingResponseFromJSONTyped(json);
}
function FollowingResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : json['data'].map(UserFullFromJSON)
  };
}
function FollowingResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': value.data === undefined ? undefined : value.data.map(UserFullToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the FollowingResponseFull interface.
 */
function instanceOfFollowingResponseFull(value) {
  let isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value && value["latestChainBlock"] !== undefined;
  isInstance = isInstance && "latestIndexedBlock" in value && value["latestIndexedBlock"] !== undefined;
  isInstance = isInstance && "latestChainSlotPlays" in value && value["latestChainSlotPlays"] !== undefined;
  isInstance = isInstance && "latestIndexedSlotPlays" in value && value["latestIndexedSlotPlays"] !== undefined;
  isInstance = isInstance && "signature" in value && value["signature"] !== undefined;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== undefined;
  isInstance = isInstance && "version" in value && value["version"] !== undefined;
  return isInstance;
}
function FollowingResponseFullFromJSON(json) {
  return FollowingResponseFullFromJSONTyped(json);
}
function FollowingResponseFullFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : json['data'].map(UserFullFromJSON)
  };
}
function FollowingResponseFullToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': value.data === undefined ? undefined : value.data.map(UserFullToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the UserSubscribers interface.
 */
function instanceOfUserSubscribers(value) {
  let isInstance = true;
  isInstance = isInstance && "userId" in value && value["userId"] !== undefined;
  return isInstance;
}
function UserSubscribersFromJSON(json) {
  return UserSubscribersFromJSONTyped(json);
}
function UserSubscribersFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'userId': json['user_id'],
    'subscriberIds': !exists(json, 'subscriber_ids') ? undefined : json['subscriber_ids']
  };
}
function UserSubscribersToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'user_id': value.userId,
    'subscriber_ids': value.subscriberIds
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the FullBulkSubscribersResponse interface.
 */
function instanceOfFullBulkSubscribersResponse(value) {
  let isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value && value["latestChainBlock"] !== undefined;
  isInstance = isInstance && "latestIndexedBlock" in value && value["latestIndexedBlock"] !== undefined;
  isInstance = isInstance && "latestChainSlotPlays" in value && value["latestChainSlotPlays"] !== undefined;
  isInstance = isInstance && "latestIndexedSlotPlays" in value && value["latestIndexedSlotPlays"] !== undefined;
  isInstance = isInstance && "signature" in value && value["signature"] !== undefined;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== undefined;
  isInstance = isInstance && "version" in value && value["version"] !== undefined;
  return isInstance;
}
function FullBulkSubscribersResponseFromJSON(json) {
  return FullBulkSubscribersResponseFromJSONTyped(json);
}
function FullBulkSubscribersResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : json['data'].map(UserSubscribersFromJSON)
  };
}
function FullBulkSubscribersResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': value.data === undefined ? undefined : value.data.map(UserSubscribersToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the FullFollowersResponse interface.
 */
function instanceOfFullFollowersResponse(value) {
  let isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value && value["latestChainBlock"] !== undefined;
  isInstance = isInstance && "latestIndexedBlock" in value && value["latestIndexedBlock"] !== undefined;
  isInstance = isInstance && "latestChainSlotPlays" in value && value["latestChainSlotPlays"] !== undefined;
  isInstance = isInstance && "latestIndexedSlotPlays" in value && value["latestIndexedSlotPlays"] !== undefined;
  isInstance = isInstance && "signature" in value && value["signature"] !== undefined;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== undefined;
  isInstance = isInstance && "version" in value && value["version"] !== undefined;
  return isInstance;
}
function FullFollowersResponseFromJSON(json) {
  return FullFollowersResponseFromJSONTyped(json);
}
function FullFollowersResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : json['data'].map(UserFullFromJSON)
  };
}
function FullFollowersResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': value.data === undefined ? undefined : value.data.map(UserFullToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the FullSupporting interface.
 */
function instanceOfFullSupporting(value) {
  let isInstance = true;
  isInstance = isInstance && "rank" in value && value["rank"] !== undefined;
  isInstance = isInstance && "amount" in value && value["amount"] !== undefined;
  isInstance = isInstance && "receiver" in value && value["receiver"] !== undefined;
  return isInstance;
}
function FullSupportingFromJSON(json) {
  return FullSupportingFromJSONTyped(json);
}
function FullSupportingFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'rank': json['rank'],
    'amount': json['amount'],
    'receiver': UserFullFromJSON(json['receiver'])
  };
}
function FullSupportingToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'rank': value.rank,
    'amount': value.amount,
    'receiver': UserFullToJSON(value.receiver)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the FullGetSupportedUsers interface.
 */
function instanceOfFullGetSupportedUsers(value) {
  let isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value && value["latestChainBlock"] !== undefined;
  isInstance = isInstance && "latestIndexedBlock" in value && value["latestIndexedBlock"] !== undefined;
  isInstance = isInstance && "latestChainSlotPlays" in value && value["latestChainSlotPlays"] !== undefined;
  isInstance = isInstance && "latestIndexedSlotPlays" in value && value["latestIndexedSlotPlays"] !== undefined;
  isInstance = isInstance && "signature" in value && value["signature"] !== undefined;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== undefined;
  isInstance = isInstance && "version" in value && value["version"] !== undefined;
  return isInstance;
}
function FullGetSupportedUsersFromJSON(json) {
  return FullGetSupportedUsersFromJSONTyped(json);
}
function FullGetSupportedUsersFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : json['data'].map(FullSupportingFromJSON)
  };
}
function FullGetSupportedUsersToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': value.data === undefined ? undefined : value.data.map(FullSupportingToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the FullSupporter interface.
 */
function instanceOfFullSupporter(value) {
  let isInstance = true;
  isInstance = isInstance && "rank" in value && value["rank"] !== undefined;
  isInstance = isInstance && "amount" in value && value["amount"] !== undefined;
  isInstance = isInstance && "sender" in value && value["sender"] !== undefined;
  return isInstance;
}
function FullSupporterFromJSON(json) {
  return FullSupporterFromJSONTyped(json);
}
function FullSupporterFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'rank': json['rank'],
    'amount': json['amount'],
    'sender': UserFullFromJSON(json['sender'])
  };
}
function FullSupporterToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'rank': value.rank,
    'amount': value.amount,
    'sender': UserFullToJSON(value.sender)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the FullGetSupporter interface.
 */
function instanceOfFullGetSupporter(value) {
  let isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value && value["latestChainBlock"] !== undefined;
  isInstance = isInstance && "latestIndexedBlock" in value && value["latestIndexedBlock"] !== undefined;
  isInstance = isInstance && "latestChainSlotPlays" in value && value["latestChainSlotPlays"] !== undefined;
  isInstance = isInstance && "latestIndexedSlotPlays" in value && value["latestIndexedSlotPlays"] !== undefined;
  isInstance = isInstance && "signature" in value && value["signature"] !== undefined;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== undefined;
  isInstance = isInstance && "version" in value && value["version"] !== undefined;
  return isInstance;
}
function FullGetSupporterFromJSON(json) {
  return FullGetSupporterFromJSONTyped(json);
}
function FullGetSupporterFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : FullSupporterFromJSON(json['data'])
  };
}
function FullGetSupporterToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': FullSupporterToJSON(value.data)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the FullGetSupporters interface.
 */
function instanceOfFullGetSupporters(value) {
  let isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value && value["latestChainBlock"] !== undefined;
  isInstance = isInstance && "latestIndexedBlock" in value && value["latestIndexedBlock"] !== undefined;
  isInstance = isInstance && "latestChainSlotPlays" in value && value["latestChainSlotPlays"] !== undefined;
  isInstance = isInstance && "latestIndexedSlotPlays" in value && value["latestIndexedSlotPlays"] !== undefined;
  isInstance = isInstance && "signature" in value && value["signature"] !== undefined;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== undefined;
  isInstance = isInstance && "version" in value && value["version"] !== undefined;
  return isInstance;
}
function FullGetSupportersFromJSON(json) {
  return FullGetSupportersFromJSONTyped(json);
}
function FullGetSupportersFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : json['data'].map(FullSupporterFromJSON)
  };
}
function FullGetSupportersToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': value.data === undefined ? undefined : value.data.map(FullSupporterToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the FullGetSupporting interface.
 */
function instanceOfFullGetSupporting(value) {
  let isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value && value["latestChainBlock"] !== undefined;
  isInstance = isInstance && "latestIndexedBlock" in value && value["latestIndexedBlock"] !== undefined;
  isInstance = isInstance && "latestChainSlotPlays" in value && value["latestChainSlotPlays"] !== undefined;
  isInstance = isInstance && "latestIndexedSlotPlays" in value && value["latestIndexedSlotPlays"] !== undefined;
  isInstance = isInstance && "signature" in value && value["signature"] !== undefined;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== undefined;
  isInstance = isInstance && "version" in value && value["version"] !== undefined;
  return isInstance;
}
function FullGetSupportingFromJSON(json) {
  return FullGetSupportingFromJSONTyped(json);
}
function FullGetSupportingFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : FullSupportingFromJSON(json['data'])
  };
}
function FullGetSupportingToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': FullSupportingToJSON(value.data)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the FullMutualFollowersResponse interface.
 */
function instanceOfFullMutualFollowersResponse(value) {
  let isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value && value["latestChainBlock"] !== undefined;
  isInstance = isInstance && "latestIndexedBlock" in value && value["latestIndexedBlock"] !== undefined;
  isInstance = isInstance && "latestChainSlotPlays" in value && value["latestChainSlotPlays"] !== undefined;
  isInstance = isInstance && "latestIndexedSlotPlays" in value && value["latestIndexedSlotPlays"] !== undefined;
  isInstance = isInstance && "signature" in value && value["signature"] !== undefined;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== undefined;
  isInstance = isInstance && "version" in value && value["version"] !== undefined;
  return isInstance;
}
function FullMutualFollowersResponseFromJSON(json) {
  return FullMutualFollowersResponseFromJSONTyped(json);
}
function FullMutualFollowersResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : json['data'].map(UserFullFromJSON)
  };
}
function FullMutualFollowersResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': value.data === undefined ? undefined : value.data.map(UserFullToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the FullPlaylistResponse interface.
 */
function instanceOfFullPlaylistResponse(value) {
  let isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value && value["latestChainBlock"] !== undefined;
  isInstance = isInstance && "latestIndexedBlock" in value && value["latestIndexedBlock"] !== undefined;
  isInstance = isInstance && "latestChainSlotPlays" in value && value["latestChainSlotPlays"] !== undefined;
  isInstance = isInstance && "latestIndexedSlotPlays" in value && value["latestIndexedSlotPlays"] !== undefined;
  isInstance = isInstance && "signature" in value && value["signature"] !== undefined;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== undefined;
  isInstance = isInstance && "version" in value && value["version"] !== undefined;
  return isInstance;
}
function FullPlaylistResponseFromJSON(json) {
  return FullPlaylistResponseFromJSONTyped(json);
}
function FullPlaylistResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : json['data'].map(PlaylistFullFromJSON)
  };
}
function FullPlaylistResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': value.data === undefined ? undefined : value.data.map(PlaylistFullToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the FullPlaylistTracksResponse interface.
 */
function instanceOfFullPlaylistTracksResponse(value) {
  let isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value && value["latestChainBlock"] !== undefined;
  isInstance = isInstance && "latestIndexedBlock" in value && value["latestIndexedBlock"] !== undefined;
  isInstance = isInstance && "latestChainSlotPlays" in value && value["latestChainSlotPlays"] !== undefined;
  isInstance = isInstance && "latestIndexedSlotPlays" in value && value["latestIndexedSlotPlays"] !== undefined;
  isInstance = isInstance && "signature" in value && value["signature"] !== undefined;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== undefined;
  isInstance = isInstance && "version" in value && value["version"] !== undefined;
  return isInstance;
}
function FullPlaylistTracksResponseFromJSON(json) {
  return FullPlaylistTracksResponseFromJSONTyped(json);
}
function FullPlaylistTracksResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : json['data'].map(TrackFullFromJSON)
  };
}
function FullPlaylistTracksResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': value.data === undefined ? undefined : value.data.map(TrackFullToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the FullPurchasersResponse interface.
 */
function instanceOfFullPurchasersResponse(value) {
  let isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value && value["latestChainBlock"] !== undefined;
  isInstance = isInstance && "latestIndexedBlock" in value && value["latestIndexedBlock"] !== undefined;
  isInstance = isInstance && "latestChainSlotPlays" in value && value["latestChainSlotPlays"] !== undefined;
  isInstance = isInstance && "latestIndexedSlotPlays" in value && value["latestIndexedSlotPlays"] !== undefined;
  isInstance = isInstance && "signature" in value && value["signature"] !== undefined;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== undefined;
  isInstance = isInstance && "version" in value && value["version"] !== undefined;
  return isInstance;
}
function FullPurchasersResponseFromJSON(json) {
  return FullPurchasersResponseFromJSONTyped(json);
}
function FullPurchasersResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : json['data'].map(UserFullFromJSON)
  };
}
function FullPurchasersResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': value.data === undefined ? undefined : value.data.map(UserFullToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the FullRemixersResponse interface.
 */
function instanceOfFullRemixersResponse(value) {
  let isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value && value["latestChainBlock"] !== undefined;
  isInstance = isInstance && "latestIndexedBlock" in value && value["latestIndexedBlock"] !== undefined;
  isInstance = isInstance && "latestChainSlotPlays" in value && value["latestChainSlotPlays"] !== undefined;
  isInstance = isInstance && "latestIndexedSlotPlays" in value && value["latestIndexedSlotPlays"] !== undefined;
  isInstance = isInstance && "signature" in value && value["signature"] !== undefined;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== undefined;
  isInstance = isInstance && "version" in value && value["version"] !== undefined;
  return isInstance;
}
function FullRemixersResponseFromJSON(json) {
  return FullRemixersResponseFromJSONTyped(json);
}
function FullRemixersResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : json['data'].map(UserFullFromJSON)
  };
}
function FullRemixersResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': value.data === undefined ? undefined : value.data.map(UserFullToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the FullReposts interface.
 */
function instanceOfFullReposts(value) {
  let isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value && value["latestChainBlock"] !== undefined;
  isInstance = isInstance && "latestIndexedBlock" in value && value["latestIndexedBlock"] !== undefined;
  isInstance = isInstance && "latestChainSlotPlays" in value && value["latestChainSlotPlays"] !== undefined;
  isInstance = isInstance && "latestIndexedSlotPlays" in value && value["latestIndexedSlotPlays"] !== undefined;
  isInstance = isInstance && "signature" in value && value["signature"] !== undefined;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== undefined;
  isInstance = isInstance && "version" in value && value["version"] !== undefined;
  return isInstance;
}
function FullRepostsFromJSON(json) {
  return FullRepostsFromJSONTyped(json);
}
function FullRepostsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : json['data'].map(ActivityFullFromJSON)
  };
}
function FullRepostsToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': value.data === undefined ? undefined : value.data.map(ActivityFullToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the FullSubscribersResponse interface.
 */
function instanceOfFullSubscribersResponse(value) {
  let isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value && value["latestChainBlock"] !== undefined;
  isInstance = isInstance && "latestIndexedBlock" in value && value["latestIndexedBlock"] !== undefined;
  isInstance = isInstance && "latestChainSlotPlays" in value && value["latestChainSlotPlays"] !== undefined;
  isInstance = isInstance && "latestIndexedSlotPlays" in value && value["latestIndexedSlotPlays"] !== undefined;
  isInstance = isInstance && "signature" in value && value["signature"] !== undefined;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== undefined;
  isInstance = isInstance && "version" in value && value["version"] !== undefined;
  return isInstance;
}
function FullSubscribersResponseFromJSON(json) {
  return FullSubscribersResponseFromJSONTyped(json);
}
function FullSubscribersResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : json['data'].map(UserFullFromJSON)
  };
}
function FullSubscribersResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': value.data === undefined ? undefined : value.data.map(UserFullToJSON)
  };
}

/* tslint:disable */
/* eslint-disable */
// @ts-nocheck
/**
 * API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * Check if a given object implements the SupporterReference interface.
 */
function instanceOfSupporterReference(value) {
  let isInstance = true;
  isInstance = isInstance && "userId" in value && value["userId"] !== undefined;
  return isInstance;
}
function SupporterReferenceFromJSON(json) {
  return SupporterReferenceFromJSONTyped(json);
}
function SupporterReferenceFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'userId': json['user_id']
  };
}
function SupporterReferenceToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'user_id': value.userId
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the FullTip interface.
 */
function instanceOfFullTip(value) {
  let isInstance = true;
  isInstance = isInstance && "amount" in value && value["amount"] !== undefined;
  isInstance = isInstance && "sender" in value && value["sender"] !== undefined;
  isInstance = isInstance && "receiver" in value && value["receiver"] !== undefined;
  isInstance = isInstance && "createdAt" in value && value["createdAt"] !== undefined;
  isInstance = isInstance && "slot" in value && value["slot"] !== undefined;
  isInstance = isInstance && "followeeSupporters" in value && value["followeeSupporters"] !== undefined;
  isInstance = isInstance && "txSignature" in value && value["txSignature"] !== undefined;
  return isInstance;
}
function FullTipFromJSON(json) {
  return FullTipFromJSONTyped(json);
}
function FullTipFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'amount': json['amount'],
    'sender': UserFullFromJSON(json['sender']),
    'receiver': UserFullFromJSON(json['receiver']),
    'createdAt': json['created_at'],
    'slot': json['slot'],
    'followeeSupporters': json['followee_supporters'].map(SupporterReferenceFromJSON),
    'txSignature': json['tx_signature']
  };
}
function FullTipToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'amount': value.amount,
    'sender': UserFullToJSON(value.sender),
    'receiver': UserFullToJSON(value.receiver),
    'created_at': value.createdAt,
    'slot': value.slot,
    'followee_supporters': value.followeeSupporters.map(SupporterReferenceToJSON),
    'tx_signature': value.txSignature
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the FullTopListener interface.
 */
function instanceOfFullTopListener(value) {
  let isInstance = true;
  return isInstance;
}
function FullTopListenerFromJSON(json) {
  return FullTopListenerFromJSONTyped(json);
}
function FullTopListenerFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'data': !exists(json, 'data') ? undefined : json['data'].map(FullTopListenerFromJSON)
  };
}
function FullTopListenerToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'data': value.data === undefined ? undefined : value.data.map(FullTopListenerToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the FullTrackResponse interface.
 */
function instanceOfFullTrackResponse(value) {
  let isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value && value["latestChainBlock"] !== undefined;
  isInstance = isInstance && "latestIndexedBlock" in value && value["latestIndexedBlock"] !== undefined;
  isInstance = isInstance && "latestChainSlotPlays" in value && value["latestChainSlotPlays"] !== undefined;
  isInstance = isInstance && "latestIndexedSlotPlays" in value && value["latestIndexedSlotPlays"] !== undefined;
  isInstance = isInstance && "signature" in value && value["signature"] !== undefined;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== undefined;
  isInstance = isInstance && "version" in value && value["version"] !== undefined;
  return isInstance;
}
function FullTrackResponseFromJSON(json) {
  return FullTrackResponseFromJSONTyped(json);
}
function FullTrackResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : TrackFullFromJSON(json['data'])
  };
}
function FullTrackResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': TrackFullToJSON(value.data)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the FullTracks interface.
 */
function instanceOfFullTracks(value) {
  let isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value && value["latestChainBlock"] !== undefined;
  isInstance = isInstance && "latestIndexedBlock" in value && value["latestIndexedBlock"] !== undefined;
  isInstance = isInstance && "latestChainSlotPlays" in value && value["latestChainSlotPlays"] !== undefined;
  isInstance = isInstance && "latestIndexedSlotPlays" in value && value["latestIndexedSlotPlays"] !== undefined;
  isInstance = isInstance && "signature" in value && value["signature"] !== undefined;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== undefined;
  isInstance = isInstance && "version" in value && value["version"] !== undefined;
  return isInstance;
}
function FullTracksFromJSON(json) {
  return FullTracksFromJSONTyped(json);
}
function FullTracksFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : json['data'].map(TrackFullFromJSON)
  };
}
function FullTracksToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': value.data === undefined ? undefined : value.data.map(TrackFullToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the FullTracksResponse interface.
 */
function instanceOfFullTracksResponse(value) {
  let isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value && value["latestChainBlock"] !== undefined;
  isInstance = isInstance && "latestIndexedBlock" in value && value["latestIndexedBlock"] !== undefined;
  isInstance = isInstance && "latestChainSlotPlays" in value && value["latestChainSlotPlays"] !== undefined;
  isInstance = isInstance && "latestIndexedSlotPlays" in value && value["latestIndexedSlotPlays"] !== undefined;
  isInstance = isInstance && "signature" in value && value["signature"] !== undefined;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== undefined;
  isInstance = isInstance && "version" in value && value["version"] !== undefined;
  return isInstance;
}
function FullTracksResponseFromJSON(json) {
  return FullTracksResponseFromJSONTyped(json);
}
function FullTracksResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : json['data'].map(TrackFullFromJSON)
  };
}
function FullTracksResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': value.data === undefined ? undefined : value.data.map(TrackFullToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the FullTrendingPlaylistsResponse interface.
 */
function instanceOfFullTrendingPlaylistsResponse(value) {
  let isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value && value["latestChainBlock"] !== undefined;
  isInstance = isInstance && "latestIndexedBlock" in value && value["latestIndexedBlock"] !== undefined;
  isInstance = isInstance && "latestChainSlotPlays" in value && value["latestChainSlotPlays"] !== undefined;
  isInstance = isInstance && "latestIndexedSlotPlays" in value && value["latestIndexedSlotPlays"] !== undefined;
  isInstance = isInstance && "signature" in value && value["signature"] !== undefined;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== undefined;
  isInstance = isInstance && "version" in value && value["version"] !== undefined;
  return isInstance;
}
function FullTrendingPlaylistsResponseFromJSON(json) {
  return FullTrendingPlaylistsResponseFromJSONTyped(json);
}
function FullTrendingPlaylistsResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : json['data'].map(PlaylistFullFromJSON)
  };
}
function FullTrendingPlaylistsResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': value.data === undefined ? undefined : value.data.map(PlaylistFullToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the FullUserResponse interface.
 */
function instanceOfFullUserResponse(value) {
  let isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value && value["latestChainBlock"] !== undefined;
  isInstance = isInstance && "latestIndexedBlock" in value && value["latestIndexedBlock"] !== undefined;
  isInstance = isInstance && "latestChainSlotPlays" in value && value["latestChainSlotPlays"] !== undefined;
  isInstance = isInstance && "latestIndexedSlotPlays" in value && value["latestIndexedSlotPlays"] !== undefined;
  isInstance = isInstance && "signature" in value && value["signature"] !== undefined;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== undefined;
  isInstance = isInstance && "version" in value && value["version"] !== undefined;
  return isInstance;
}
function FullUserResponseFromJSON(json) {
  return FullUserResponseFromJSONTyped(json);
}
function FullUserResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : json['data'].map(UserFullFromJSON)
  };
}
function FullUserResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': value.data === undefined ? undefined : value.data.map(UserFullToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the GetTipsResponse interface.
 */
function instanceOfGetTipsResponse(value) {
  let isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value && value["latestChainBlock"] !== undefined;
  isInstance = isInstance && "latestIndexedBlock" in value && value["latestIndexedBlock"] !== undefined;
  isInstance = isInstance && "latestChainSlotPlays" in value && value["latestChainSlotPlays"] !== undefined;
  isInstance = isInstance && "latestIndexedSlotPlays" in value && value["latestIndexedSlotPlays"] !== undefined;
  isInstance = isInstance && "signature" in value && value["signature"] !== undefined;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== undefined;
  isInstance = isInstance && "version" in value && value["version"] !== undefined;
  return isInstance;
}
function GetTipsResponseFromJSON(json) {
  return GetTipsResponseFromJSONTyped(json);
}
function GetTipsResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : json['data'].map(FullTipFromJSON)
  };
}
function GetTipsResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': value.data === undefined ? undefined : value.data.map(FullTipToJSON)
  };
}

/* tslint:disable */
/* eslint-disable */
// @ts-nocheck
/**
 * API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * Check if a given object implements the Grant interface.
 */
function instanceOfGrant(value) {
  let isInstance = true;
  isInstance = isInstance && "granteeAddress" in value && value["granteeAddress"] !== undefined;
  isInstance = isInstance && "userId" in value && value["userId"] !== undefined;
  isInstance = isInstance && "isRevoked" in value && value["isRevoked"] !== undefined;
  isInstance = isInstance && "isApproved" in value && value["isApproved"] !== undefined;
  isInstance = isInstance && "createdAt" in value && value["createdAt"] !== undefined;
  isInstance = isInstance && "updatedAt" in value && value["updatedAt"] !== undefined;
  return isInstance;
}
function GrantFromJSON(json) {
  return GrantFromJSONTyped(json);
}
function GrantFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'granteeAddress': json['grantee_address'],
    'userId': json['user_id'],
    'isRevoked': json['is_revoked'],
    'isApproved': json['is_approved'],
    'createdAt': json['created_at'],
    'updatedAt': json['updated_at']
  };
}
function GrantToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'grantee_address': value.granteeAddress,
    'user_id': value.userId,
    'is_revoked': value.isRevoked,
    'is_approved': value.isApproved,
    'created_at': value.createdAt,
    'updated_at': value.updatedAt
  };
}

/* tslint:disable */
/**
 * @export
 */
const TrackActivityFullItemTypeEnum = {
  Track: 'track'
};
/**
 * Check if a given object implements the TrackActivityFull interface.
 */
function instanceOfTrackActivityFull(value) {
  let isInstance = true;
  isInstance = isInstance && "itemType" in value && value["itemType"] !== undefined;
  isInstance = isInstance && "item" in value && value["item"] !== undefined;
  return isInstance;
}
function TrackActivityFullFromJSON(json) {
  return TrackActivityFullFromJSONTyped(json, false);
}
function TrackActivityFullFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    ...ActivityFullFromJSONTyped(json, ignoreDiscriminator),
    'itemType': json['item_type'],
    'item': TrackFullFromJSON(json['item'])
  };
}
function TrackActivityFullToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    ...ActivityFullToJSON(value),
    'item_type': value.itemType,
    'item': TrackFullToJSON(value.item)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the HistoryResponseFull interface.
 */
function instanceOfHistoryResponseFull(value) {
  let isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value && value["latestChainBlock"] !== undefined;
  isInstance = isInstance && "latestIndexedBlock" in value && value["latestIndexedBlock"] !== undefined;
  isInstance = isInstance && "latestChainSlotPlays" in value && value["latestChainSlotPlays"] !== undefined;
  isInstance = isInstance && "latestIndexedSlotPlays" in value && value["latestIndexedSlotPlays"] !== undefined;
  isInstance = isInstance && "signature" in value && value["signature"] !== undefined;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== undefined;
  isInstance = isInstance && "version" in value && value["version"] !== undefined;
  return isInstance;
}
function HistoryResponseFullFromJSON(json) {
  return HistoryResponseFullFromJSONTyped(json);
}
function HistoryResponseFullFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : json['data'].map(TrackActivityFullFromJSON)
  };
}
function HistoryResponseFullToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': value.data === undefined ? undefined : value.data.map(TrackActivityFullToJSON)
  };
}

/* tslint:disable */
/* eslint-disable */
// @ts-nocheck
/**
 * API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * Check if a given object implements the ListenStreakReminderNotificationActionData interface.
 */
function instanceOfListenStreakReminderNotificationActionData(value) {
  let isInstance = true;
  isInstance = isInstance && "streak" in value && value["streak"] !== undefined;
  return isInstance;
}
function ListenStreakReminderNotificationActionDataFromJSON(json) {
  return ListenStreakReminderNotificationActionDataFromJSONTyped(json);
}
function ListenStreakReminderNotificationActionDataFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'streak': json['streak']
  };
}
function ListenStreakReminderNotificationActionDataToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'streak': value.streak
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the ListenStreakReminderNotificationAction interface.
 */
function instanceOfListenStreakReminderNotificationAction(value) {
  let isInstance = true;
  isInstance = isInstance && "specifier" in value && value["specifier"] !== undefined;
  isInstance = isInstance && "type" in value && value["type"] !== undefined;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== undefined;
  isInstance = isInstance && "data" in value && value["data"] !== undefined;
  return isInstance;
}
function ListenStreakReminderNotificationActionFromJSON(json) {
  return ListenStreakReminderNotificationActionFromJSONTyped(json);
}
function ListenStreakReminderNotificationActionFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'specifier': json['specifier'],
    'type': json['type'],
    'timestamp': json['timestamp'],
    'data': ListenStreakReminderNotificationActionDataFromJSON(json['data'])
  };
}
function ListenStreakReminderNotificationActionToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'specifier': value.specifier,
    'type': value.type,
    'timestamp': value.timestamp,
    'data': ListenStreakReminderNotificationActionDataToJSON(value.data)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the ListenStreakReminderNotification interface.
 */
function instanceOfListenStreakReminderNotification(value) {
  let isInstance = true;
  isInstance = isInstance && "type" in value && value["type"] !== undefined;
  isInstance = isInstance && "groupId" in value && value["groupId"] !== undefined;
  isInstance = isInstance && "isSeen" in value && value["isSeen"] !== undefined;
  isInstance = isInstance && "actions" in value && value["actions"] !== undefined;
  return isInstance;
}
function ListenStreakReminderNotificationFromJSON(json) {
  return ListenStreakReminderNotificationFromJSONTyped(json);
}
function ListenStreakReminderNotificationFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'type': json['type'],
    'groupId': json['group_id'],
    'isSeen': json['is_seen'],
    'seenAt': !exists(json, 'seen_at') ? undefined : json['seen_at'],
    'actions': json['actions'].map(ListenStreakReminderNotificationActionFromJSON)
  };
}
function ListenStreakReminderNotificationToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'type': value.type,
    'group_id': value.groupId,
    'is_seen': value.isSeen,
    'seen_at': value.seenAt,
    'actions': value.actions.map(ListenStreakReminderNotificationActionToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the ManagedUser interface.
 */
function instanceOfManagedUser(value) {
  let isInstance = true;
  isInstance = isInstance && "user" in value && value["user"] !== undefined;
  isInstance = isInstance && "grant" in value && value["grant"] !== undefined;
  return isInstance;
}
function ManagedUserFromJSON(json) {
  return ManagedUserFromJSONTyped(json);
}
function ManagedUserFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'user': UserFullFromJSON(json['user']),
    'grant': GrantFromJSON(json['grant'])
  };
}
function ManagedUserToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'user': UserFullToJSON(value.user),
    'grant': GrantToJSON(value.grant)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the ManagedUsersResponse interface.
 */
function instanceOfManagedUsersResponse(value) {
  let isInstance = true;
  return isInstance;
}
function ManagedUsersResponseFromJSON(json) {
  return ManagedUsersResponseFromJSONTyped(json);
}
function ManagedUsersResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'data': !exists(json, 'data') ? undefined : json['data'].map(ManagedUserFromJSON)
  };
}
function ManagedUsersResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'data': value.data === undefined ? undefined : value.data.map(ManagedUserToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the UserManager interface.
 */
function instanceOfUserManager(value) {
  let isInstance = true;
  isInstance = isInstance && "manager" in value && value["manager"] !== undefined;
  isInstance = isInstance && "grant" in value && value["grant"] !== undefined;
  return isInstance;
}
function UserManagerFromJSON(json) {
  return UserManagerFromJSONTyped(json);
}
function UserManagerFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'manager': UserFullFromJSON(json['manager']),
    'grant': GrantFromJSON(json['grant'])
  };
}
function UserManagerToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'manager': UserFullToJSON(value.manager),
    'grant': GrantToJSON(value.grant)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the ManagersResponse interface.
 */
function instanceOfManagersResponse(value) {
  let isInstance = true;
  return isInstance;
}
function ManagersResponseFromJSON(json) {
  return ManagersResponseFromJSONTyped(json);
}
function ManagersResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'data': !exists(json, 'data') ? undefined : json['data'].map(UserManagerFromJSON)
  };
}
function ManagersResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'data': value.data === undefined ? undefined : value.data.map(UserManagerToJSON)
  };
}

/* tslint:disable */
/* eslint-disable */
// @ts-nocheck
/**
 * API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * Check if a given object implements the PlaylistMilestoneNotificationActionData interface.
 */
function instanceOfPlaylistMilestoneNotificationActionData(value) {
  let isInstance = true;
  isInstance = isInstance && "type" in value && value["type"] !== undefined;
  isInstance = isInstance && "threshold" in value && value["threshold"] !== undefined;
  isInstance = isInstance && "playlistId" in value && value["playlistId"] !== undefined;
  isInstance = isInstance && "isAlbum" in value && value["isAlbum"] !== undefined;
  return isInstance;
}
function PlaylistMilestoneNotificationActionDataFromJSON(json) {
  return PlaylistMilestoneNotificationActionDataFromJSONTyped(json);
}
function PlaylistMilestoneNotificationActionDataFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'type': json['type'],
    'threshold': json['threshold'],
    'playlistId': json['playlist_id'],
    'isAlbum': json['is_album']
  };
}
function PlaylistMilestoneNotificationActionDataToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'type': value.type,
    'threshold': value.threshold,
    'playlist_id': value.playlistId,
    'is_album': value.isAlbum
  };
}

/* tslint:disable */
/* eslint-disable */
// @ts-nocheck
/**
 * API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * Check if a given object implements the TrackMilestoneNotificationActionData interface.
 */
function instanceOfTrackMilestoneNotificationActionData(value) {
  let isInstance = true;
  isInstance = isInstance && "type" in value && value["type"] !== undefined;
  isInstance = isInstance && "threshold" in value && value["threshold"] !== undefined;
  isInstance = isInstance && "trackId" in value && value["trackId"] !== undefined;
  return isInstance;
}
function TrackMilestoneNotificationActionDataFromJSON(json) {
  return TrackMilestoneNotificationActionDataFromJSONTyped(json);
}
function TrackMilestoneNotificationActionDataFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'type': json['type'],
    'threshold': json['threshold'],
    'trackId': json['track_id']
  };
}
function TrackMilestoneNotificationActionDataToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'type': value.type,
    'threshold': value.threshold,
    'track_id': value.trackId
  };
}

/* tslint:disable */
/* eslint-disable */
// @ts-nocheck
/**
 * API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * Check if a given object implements the UserMilestoneNotificationActionData interface.
 */
function instanceOfUserMilestoneNotificationActionData(value) {
  let isInstance = true;
  isInstance = isInstance && "type" in value && value["type"] !== undefined;
  isInstance = isInstance && "threshold" in value && value["threshold"] !== undefined;
  isInstance = isInstance && "userId" in value && value["userId"] !== undefined;
  return isInstance;
}
function UserMilestoneNotificationActionDataFromJSON(json) {
  return UserMilestoneNotificationActionDataFromJSONTyped(json);
}
function UserMilestoneNotificationActionDataFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'type': json['type'],
    'threshold': json['threshold'],
    'userId': json['user_id']
  };
}
function UserMilestoneNotificationActionDataToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'type': value.type,
    'threshold': value.threshold,
    'user_id': value.userId
  };
}

/* tslint:disable */
function MilestoneNotificationActionDataFromJSON(json) {
  return MilestoneNotificationActionDataFromJSONTyped(json);
}
function MilestoneNotificationActionDataFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    ...PlaylistMilestoneNotificationActionDataFromJSONTyped(json),
    ...TrackMilestoneNotificationActionDataFromJSONTyped(json),
    ...UserMilestoneNotificationActionDataFromJSONTyped(json)
  };
}
function MilestoneNotificationActionDataToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  if (instanceOfPlaylistMilestoneNotificationActionData(value)) {
    return PlaylistMilestoneNotificationActionDataToJSON(value);
  }
  if (instanceOfTrackMilestoneNotificationActionData(value)) {
    return TrackMilestoneNotificationActionDataToJSON(value);
  }
  if (instanceOfUserMilestoneNotificationActionData(value)) {
    return UserMilestoneNotificationActionDataToJSON(value);
  }
  return {};
}

/* tslint:disable */
/**
 * Check if a given object implements the MilestoneNotificationAction interface.
 */
function instanceOfMilestoneNotificationAction(value) {
  let isInstance = true;
  isInstance = isInstance && "specifier" in value && value["specifier"] !== undefined;
  isInstance = isInstance && "type" in value && value["type"] !== undefined;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== undefined;
  isInstance = isInstance && "data" in value && value["data"] !== undefined;
  return isInstance;
}
function MilestoneNotificationActionFromJSON(json) {
  return MilestoneNotificationActionFromJSONTyped(json);
}
function MilestoneNotificationActionFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'specifier': json['specifier'],
    'type': json['type'],
    'timestamp': json['timestamp'],
    'data': MilestoneNotificationActionDataFromJSON(json['data'])
  };
}
function MilestoneNotificationActionToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'specifier': value.specifier,
    'type': value.type,
    'timestamp': value.timestamp,
    'data': MilestoneNotificationActionDataToJSON(value.data)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the MilestoneNotification interface.
 */
function instanceOfMilestoneNotification(value) {
  let isInstance = true;
  isInstance = isInstance && "type" in value && value["type"] !== undefined;
  isInstance = isInstance && "groupId" in value && value["groupId"] !== undefined;
  isInstance = isInstance && "isSeen" in value && value["isSeen"] !== undefined;
  isInstance = isInstance && "actions" in value && value["actions"] !== undefined;
  return isInstance;
}
function MilestoneNotificationFromJSON(json) {
  return MilestoneNotificationFromJSONTyped(json);
}
function MilestoneNotificationFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'type': json['type'],
    'groupId': json['group_id'],
    'isSeen': json['is_seen'],
    'seenAt': !exists(json, 'seen_at') ? undefined : json['seen_at'],
    'actions': json['actions'].map(MilestoneNotificationActionFromJSON)
  };
}
function MilestoneNotificationToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'type': value.type,
    'group_id': value.groupId,
    'is_seen': value.isSeen,
    'seen_at': value.seenAt,
    'actions': value.actions.map(MilestoneNotificationActionToJSON)
  };
}

/* tslint:disable */
/* eslint-disable */
// @ts-nocheck
/**
 * API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * Check if a given object implements the ReactionNotificationActionData interface.
 */
function instanceOfReactionNotificationActionData(value) {
  let isInstance = true;
  isInstance = isInstance && "reactedTo" in value && value["reactedTo"] !== undefined;
  isInstance = isInstance && "reactionType" in value && value["reactionType"] !== undefined;
  isInstance = isInstance && "reactionValue" in value && value["reactionValue"] !== undefined;
  isInstance = isInstance && "receiverUserId" in value && value["receiverUserId"] !== undefined;
  isInstance = isInstance && "senderUserId" in value && value["senderUserId"] !== undefined;
  isInstance = isInstance && "senderWallet" in value && value["senderWallet"] !== undefined;
  isInstance = isInstance && "tipAmount" in value && value["tipAmount"] !== undefined;
  return isInstance;
}
function ReactionNotificationActionDataFromJSON(json) {
  return ReactionNotificationActionDataFromJSONTyped(json);
}
function ReactionNotificationActionDataFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'reactedTo': json['reacted_to'],
    'reactionType': json['reaction_type'],
    'reactionValue': json['reaction_value'],
    'receiverUserId': json['receiver_user_id'],
    'senderUserId': json['sender_user_id'],
    'senderWallet': json['sender_wallet'],
    'tipAmount': json['tip_amount']
  };
}
function ReactionNotificationActionDataToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'reacted_to': value.reactedTo,
    'reaction_type': value.reactionType,
    'reaction_value': value.reactionValue,
    'receiver_user_id': value.receiverUserId,
    'sender_user_id': value.senderUserId,
    'sender_wallet': value.senderWallet,
    'tip_amount': value.tipAmount
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the ReactionNotificationAction interface.
 */
function instanceOfReactionNotificationAction(value) {
  let isInstance = true;
  isInstance = isInstance && "specifier" in value && value["specifier"] !== undefined;
  isInstance = isInstance && "type" in value && value["type"] !== undefined;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== undefined;
  isInstance = isInstance && "data" in value && value["data"] !== undefined;
  return isInstance;
}
function ReactionNotificationActionFromJSON(json) {
  return ReactionNotificationActionFromJSONTyped(json);
}
function ReactionNotificationActionFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'specifier': json['specifier'],
    'type': json['type'],
    'timestamp': json['timestamp'],
    'data': ReactionNotificationActionDataFromJSON(json['data'])
  };
}
function ReactionNotificationActionToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'specifier': value.specifier,
    'type': value.type,
    'timestamp': value.timestamp,
    'data': ReactionNotificationActionDataToJSON(value.data)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the ReactionNotification interface.
 */
function instanceOfReactionNotification(value) {
  let isInstance = true;
  isInstance = isInstance && "type" in value && value["type"] !== undefined;
  isInstance = isInstance && "groupId" in value && value["groupId"] !== undefined;
  isInstance = isInstance && "isSeen" in value && value["isSeen"] !== undefined;
  isInstance = isInstance && "actions" in value && value["actions"] !== undefined;
  return isInstance;
}
function ReactionNotificationFromJSON(json) {
  return ReactionNotificationFromJSONTyped(json);
}
function ReactionNotificationFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'type': json['type'],
    'groupId': json['group_id'],
    'isSeen': json['is_seen'],
    'seenAt': !exists(json, 'seen_at') ? undefined : json['seen_at'],
    'actions': json['actions'].map(ReactionNotificationActionFromJSON)
  };
}
function ReactionNotificationToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'type': value.type,
    'group_id': value.groupId,
    'is_seen': value.isSeen,
    'seen_at': value.seenAt,
    'actions': value.actions.map(ReactionNotificationActionToJSON)
  };
}

/* tslint:disable */
/* eslint-disable */
// @ts-nocheck
/**
 * API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * Check if a given object implements the ReceiveTipNotificationActionData interface.
 */
function instanceOfReceiveTipNotificationActionData(value) {
  let isInstance = true;
  isInstance = isInstance && "amount" in value && value["amount"] !== undefined;
  isInstance = isInstance && "senderUserId" in value && value["senderUserId"] !== undefined;
  isInstance = isInstance && "receiverUserId" in value && value["receiverUserId"] !== undefined;
  isInstance = isInstance && "tipTxSignature" in value && value["tipTxSignature"] !== undefined;
  isInstance = isInstance && "reactionValue" in value && value["reactionValue"] !== undefined;
  return isInstance;
}
function ReceiveTipNotificationActionDataFromJSON(json) {
  return ReceiveTipNotificationActionDataFromJSONTyped(json);
}
function ReceiveTipNotificationActionDataFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'amount': json['amount'],
    'senderUserId': json['sender_user_id'],
    'receiverUserId': json['receiver_user_id'],
    'tipTxSignature': json['tip_tx_signature'],
    'reactionValue': json['reaction_value']
  };
}
function ReceiveTipNotificationActionDataToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'amount': value.amount,
    'sender_user_id': value.senderUserId,
    'receiver_user_id': value.receiverUserId,
    'tip_tx_signature': value.tipTxSignature,
    'reaction_value': value.reactionValue
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the ReceiveTipNotificationAction interface.
 */
function instanceOfReceiveTipNotificationAction(value) {
  let isInstance = true;
  isInstance = isInstance && "specifier" in value && value["specifier"] !== undefined;
  isInstance = isInstance && "type" in value && value["type"] !== undefined;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== undefined;
  isInstance = isInstance && "data" in value && value["data"] !== undefined;
  return isInstance;
}
function ReceiveTipNotificationActionFromJSON(json) {
  return ReceiveTipNotificationActionFromJSONTyped(json);
}
function ReceiveTipNotificationActionFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'specifier': json['specifier'],
    'type': json['type'],
    'timestamp': json['timestamp'],
    'data': ReceiveTipNotificationActionDataFromJSON(json['data'])
  };
}
function ReceiveTipNotificationActionToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'specifier': value.specifier,
    'type': value.type,
    'timestamp': value.timestamp,
    'data': ReceiveTipNotificationActionDataToJSON(value.data)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the ReceiveTipNotification interface.
 */
function instanceOfReceiveTipNotification(value) {
  let isInstance = true;
  isInstance = isInstance && "type" in value && value["type"] !== undefined;
  isInstance = isInstance && "groupId" in value && value["groupId"] !== undefined;
  isInstance = isInstance && "isSeen" in value && value["isSeen"] !== undefined;
  isInstance = isInstance && "actions" in value && value["actions"] !== undefined;
  return isInstance;
}
function ReceiveTipNotificationFromJSON(json) {
  return ReceiveTipNotificationFromJSONTyped(json);
}
function ReceiveTipNotificationFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'type': json['type'],
    'groupId': json['group_id'],
    'isSeen': json['is_seen'],
    'seenAt': !exists(json, 'seen_at') ? undefined : json['seen_at'],
    'actions': json['actions'].map(ReceiveTipNotificationActionFromJSON)
  };
}
function ReceiveTipNotificationToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'type': value.type,
    'group_id': value.groupId,
    'is_seen': value.isSeen,
    'seen_at': value.seenAt,
    'actions': value.actions.map(ReceiveTipNotificationActionToJSON)
  };
}

/* tslint:disable */
/* eslint-disable */
// @ts-nocheck
/**
 * API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * Check if a given object implements the RemixNotificationActionData interface.
 */
function instanceOfRemixNotificationActionData(value) {
  let isInstance = true;
  isInstance = isInstance && "parentTrackId" in value && value["parentTrackId"] !== undefined;
  isInstance = isInstance && "trackId" in value && value["trackId"] !== undefined;
  return isInstance;
}
function RemixNotificationActionDataFromJSON(json) {
  return RemixNotificationActionDataFromJSONTyped(json);
}
function RemixNotificationActionDataFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'parentTrackId': json['parent_track_id'],
    'trackId': json['track_id']
  };
}
function RemixNotificationActionDataToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'parent_track_id': value.parentTrackId,
    'track_id': value.trackId
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the RemixNotificationAction interface.
 */
function instanceOfRemixNotificationAction(value) {
  let isInstance = true;
  isInstance = isInstance && "specifier" in value && value["specifier"] !== undefined;
  isInstance = isInstance && "type" in value && value["type"] !== undefined;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== undefined;
  isInstance = isInstance && "data" in value && value["data"] !== undefined;
  return isInstance;
}
function RemixNotificationActionFromJSON(json) {
  return RemixNotificationActionFromJSONTyped(json);
}
function RemixNotificationActionFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'specifier': json['specifier'],
    'type': json['type'],
    'timestamp': json['timestamp'],
    'data': RemixNotificationActionDataFromJSON(json['data'])
  };
}
function RemixNotificationActionToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'specifier': value.specifier,
    'type': value.type,
    'timestamp': value.timestamp,
    'data': RemixNotificationActionDataToJSON(value.data)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the RemixNotification interface.
 */
function instanceOfRemixNotification(value) {
  let isInstance = true;
  isInstance = isInstance && "type" in value && value["type"] !== undefined;
  isInstance = isInstance && "groupId" in value && value["groupId"] !== undefined;
  isInstance = isInstance && "isSeen" in value && value["isSeen"] !== undefined;
  isInstance = isInstance && "actions" in value && value["actions"] !== undefined;
  return isInstance;
}
function RemixNotificationFromJSON(json) {
  return RemixNotificationFromJSONTyped(json);
}
function RemixNotificationFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'type': json['type'],
    'groupId': json['group_id'],
    'isSeen': json['is_seen'],
    'seenAt': !exists(json, 'seen_at') ? undefined : json['seen_at'],
    'actions': json['actions'].map(RemixNotificationActionFromJSON)
  };
}
function RemixNotificationToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'type': value.type,
    'group_id': value.groupId,
    'is_seen': value.isSeen,
    'seen_at': value.seenAt,
    'actions': value.actions.map(RemixNotificationActionToJSON)
  };
}

/* tslint:disable */
/* eslint-disable */
// @ts-nocheck
/**
 * API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * @export
 */
const RepostNotificationActionDataTypeEnum = {
  Track: 'track',
  Playlist: 'playlist',
  Album: 'album'
};
/**
 * Check if a given object implements the RepostNotificationActionData interface.
 */
function instanceOfRepostNotificationActionData(value) {
  let isInstance = true;
  isInstance = isInstance && "type" in value && value["type"] !== undefined;
  isInstance = isInstance && "userId" in value && value["userId"] !== undefined;
  isInstance = isInstance && "repostItemId" in value && value["repostItemId"] !== undefined;
  return isInstance;
}
function RepostNotificationActionDataFromJSON(json) {
  return RepostNotificationActionDataFromJSONTyped(json);
}
function RepostNotificationActionDataFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'type': json['type'],
    'userId': json['user_id'],
    'repostItemId': json['repost_item_id']
  };
}
function RepostNotificationActionDataToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'type': value.type,
    'user_id': value.userId,
    'repost_item_id': value.repostItemId
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the RepostNotificationAction interface.
 */
function instanceOfRepostNotificationAction(value) {
  let isInstance = true;
  isInstance = isInstance && "specifier" in value && value["specifier"] !== undefined;
  isInstance = isInstance && "type" in value && value["type"] !== undefined;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== undefined;
  isInstance = isInstance && "data" in value && value["data"] !== undefined;
  return isInstance;
}
function RepostNotificationActionFromJSON(json) {
  return RepostNotificationActionFromJSONTyped(json);
}
function RepostNotificationActionFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'specifier': json['specifier'],
    'type': json['type'],
    'timestamp': json['timestamp'],
    'data': RepostNotificationActionDataFromJSON(json['data'])
  };
}
function RepostNotificationActionToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'specifier': value.specifier,
    'type': value.type,
    'timestamp': value.timestamp,
    'data': RepostNotificationActionDataToJSON(value.data)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the RepostNotification interface.
 */
function instanceOfRepostNotification(value) {
  let isInstance = true;
  isInstance = isInstance && "type" in value && value["type"] !== undefined;
  isInstance = isInstance && "groupId" in value && value["groupId"] !== undefined;
  isInstance = isInstance && "isSeen" in value && value["isSeen"] !== undefined;
  isInstance = isInstance && "actions" in value && value["actions"] !== undefined;
  return isInstance;
}
function RepostNotificationFromJSON(json) {
  return RepostNotificationFromJSONTyped(json);
}
function RepostNotificationFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'type': json['type'],
    'groupId': json['group_id'],
    'isSeen': json['is_seen'],
    'seenAt': !exists(json, 'seen_at') ? undefined : json['seen_at'],
    'actions': json['actions'].map(RepostNotificationActionFromJSON)
  };
}
function RepostNotificationToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'type': value.type,
    'group_id': value.groupId,
    'is_seen': value.isSeen,
    'seen_at': value.seenAt,
    'actions': value.actions.map(RepostNotificationActionToJSON)
  };
}

/* tslint:disable */
/* eslint-disable */
// @ts-nocheck
/**
 * API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * @export
 */
const RepostOfRepostNotificationActionDataTypeEnum = {
  Track: 'track',
  Playlist: 'playlist',
  Album: 'album'
};
/**
 * Check if a given object implements the RepostOfRepostNotificationActionData interface.
 */
function instanceOfRepostOfRepostNotificationActionData(value) {
  let isInstance = true;
  isInstance = isInstance && "type" in value && value["type"] !== undefined;
  isInstance = isInstance && "userId" in value && value["userId"] !== undefined;
  isInstance = isInstance && "repostOfRepostItemId" in value && value["repostOfRepostItemId"] !== undefined;
  return isInstance;
}
function RepostOfRepostNotificationActionDataFromJSON(json) {
  return RepostOfRepostNotificationActionDataFromJSONTyped(json);
}
function RepostOfRepostNotificationActionDataFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'type': json['type'],
    'userId': json['user_id'],
    'repostOfRepostItemId': json['repost_of_repost_item_id']
  };
}
function RepostOfRepostNotificationActionDataToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'type': value.type,
    'user_id': value.userId,
    'repost_of_repost_item_id': value.repostOfRepostItemId
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the RepostOfRepostNotificationAction interface.
 */
function instanceOfRepostOfRepostNotificationAction(value) {
  let isInstance = true;
  isInstance = isInstance && "specifier" in value && value["specifier"] !== undefined;
  isInstance = isInstance && "type" in value && value["type"] !== undefined;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== undefined;
  isInstance = isInstance && "data" in value && value["data"] !== undefined;
  return isInstance;
}
function RepostOfRepostNotificationActionFromJSON(json) {
  return RepostOfRepostNotificationActionFromJSONTyped(json);
}
function RepostOfRepostNotificationActionFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'specifier': json['specifier'],
    'type': json['type'],
    'timestamp': json['timestamp'],
    'data': RepostOfRepostNotificationActionDataFromJSON(json['data'])
  };
}
function RepostOfRepostNotificationActionToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'specifier': value.specifier,
    'type': value.type,
    'timestamp': value.timestamp,
    'data': RepostOfRepostNotificationActionDataToJSON(value.data)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the RepostOfRepostNotification interface.
 */
function instanceOfRepostOfRepostNotification(value) {
  let isInstance = true;
  isInstance = isInstance && "type" in value && value["type"] !== undefined;
  isInstance = isInstance && "groupId" in value && value["groupId"] !== undefined;
  isInstance = isInstance && "isSeen" in value && value["isSeen"] !== undefined;
  isInstance = isInstance && "actions" in value && value["actions"] !== undefined;
  return isInstance;
}
function RepostOfRepostNotificationFromJSON(json) {
  return RepostOfRepostNotificationFromJSONTyped(json);
}
function RepostOfRepostNotificationFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'type': json['type'],
    'groupId': json['group_id'],
    'isSeen': json['is_seen'],
    'seenAt': !exists(json, 'seen_at') ? undefined : json['seen_at'],
    'actions': json['actions'].map(RepostOfRepostNotificationActionFromJSON)
  };
}
function RepostOfRepostNotificationToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'type': value.type,
    'group_id': value.groupId,
    'is_seen': value.isSeen,
    'seen_at': value.seenAt,
    'actions': value.actions.map(RepostOfRepostNotificationActionToJSON)
  };
}

/* tslint:disable */
/* eslint-disable */
// @ts-nocheck
/**
 * API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * Check if a given object implements the RequestManagerNotificationActionData interface.
 */
function instanceOfRequestManagerNotificationActionData(value) {
  let isInstance = true;
  isInstance = isInstance && "userId" in value && value["userId"] !== undefined;
  isInstance = isInstance && "granteeUserId" in value && value["granteeUserId"] !== undefined;
  isInstance = isInstance && "granteeAddress" in value && value["granteeAddress"] !== undefined;
  return isInstance;
}
function RequestManagerNotificationActionDataFromJSON(json) {
  return RequestManagerNotificationActionDataFromJSONTyped(json);
}
function RequestManagerNotificationActionDataFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'userId': json['user_id'],
    'granteeUserId': json['grantee_user_id'],
    'granteeAddress': json['grantee_address']
  };
}
function RequestManagerNotificationActionDataToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'user_id': value.userId,
    'grantee_user_id': value.granteeUserId,
    'grantee_address': value.granteeAddress
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the RequestManagerNotificationAction interface.
 */
function instanceOfRequestManagerNotificationAction(value) {
  let isInstance = true;
  isInstance = isInstance && "specifier" in value && value["specifier"] !== undefined;
  isInstance = isInstance && "type" in value && value["type"] !== undefined;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== undefined;
  isInstance = isInstance && "data" in value && value["data"] !== undefined;
  return isInstance;
}
function RequestManagerNotificationActionFromJSON(json) {
  return RequestManagerNotificationActionFromJSONTyped(json);
}
function RequestManagerNotificationActionFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'specifier': json['specifier'],
    'type': json['type'],
    'timestamp': json['timestamp'],
    'data': RequestManagerNotificationActionDataFromJSON(json['data'])
  };
}
function RequestManagerNotificationActionToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'specifier': value.specifier,
    'type': value.type,
    'timestamp': value.timestamp,
    'data': RequestManagerNotificationActionDataToJSON(value.data)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the RequestManagerNotification interface.
 */
function instanceOfRequestManagerNotification(value) {
  let isInstance = true;
  isInstance = isInstance && "type" in value && value["type"] !== undefined;
  isInstance = isInstance && "groupId" in value && value["groupId"] !== undefined;
  isInstance = isInstance && "isSeen" in value && value["isSeen"] !== undefined;
  isInstance = isInstance && "actions" in value && value["actions"] !== undefined;
  return isInstance;
}
function RequestManagerNotificationFromJSON(json) {
  return RequestManagerNotificationFromJSONTyped(json);
}
function RequestManagerNotificationFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'type': json['type'],
    'groupId': json['group_id'],
    'isSeen': json['is_seen'],
    'seenAt': !exists(json, 'seen_at') ? undefined : json['seen_at'],
    'actions': json['actions'].map(RequestManagerNotificationActionFromJSON)
  };
}
function RequestManagerNotificationToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'type': value.type,
    'group_id': value.groupId,
    'is_seen': value.isSeen,
    'seen_at': value.seenAt,
    'actions': value.actions.map(RequestManagerNotificationActionToJSON)
  };
}

/* tslint:disable */
/* eslint-disable */
// @ts-nocheck
/**
 * API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * @export
 */
const SaveNotificationActionDataTypeEnum = {
  Track: 'track',
  Playlist: 'playlist',
  Album: 'album'
};
/**
 * Check if a given object implements the SaveNotificationActionData interface.
 */
function instanceOfSaveNotificationActionData(value) {
  let isInstance = true;
  isInstance = isInstance && "type" in value && value["type"] !== undefined;
  isInstance = isInstance && "userId" in value && value["userId"] !== undefined;
  isInstance = isInstance && "saveItemId" in value && value["saveItemId"] !== undefined;
  return isInstance;
}
function SaveNotificationActionDataFromJSON(json) {
  return SaveNotificationActionDataFromJSONTyped(json);
}
function SaveNotificationActionDataFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'type': json['type'],
    'userId': json['user_id'],
    'saveItemId': json['save_item_id']
  };
}
function SaveNotificationActionDataToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'type': value.type,
    'user_id': value.userId,
    'save_item_id': value.saveItemId
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the SaveNotificationAction interface.
 */
function instanceOfSaveNotificationAction(value) {
  let isInstance = true;
  isInstance = isInstance && "specifier" in value && value["specifier"] !== undefined;
  isInstance = isInstance && "type" in value && value["type"] !== undefined;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== undefined;
  isInstance = isInstance && "data" in value && value["data"] !== undefined;
  return isInstance;
}
function SaveNotificationActionFromJSON(json) {
  return SaveNotificationActionFromJSONTyped(json);
}
function SaveNotificationActionFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'specifier': json['specifier'],
    'type': json['type'],
    'timestamp': json['timestamp'],
    'data': SaveNotificationActionDataFromJSON(json['data'])
  };
}
function SaveNotificationActionToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'specifier': value.specifier,
    'type': value.type,
    'timestamp': value.timestamp,
    'data': SaveNotificationActionDataToJSON(value.data)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the SaveNotification interface.
 */
function instanceOfSaveNotification(value) {
  let isInstance = true;
  isInstance = isInstance && "type" in value && value["type"] !== undefined;
  isInstance = isInstance && "groupId" in value && value["groupId"] !== undefined;
  isInstance = isInstance && "isSeen" in value && value["isSeen"] !== undefined;
  isInstance = isInstance && "actions" in value && value["actions"] !== undefined;
  return isInstance;
}
function SaveNotificationFromJSON(json) {
  return SaveNotificationFromJSONTyped(json);
}
function SaveNotificationFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'type': json['type'],
    'groupId': json['group_id'],
    'isSeen': json['is_seen'],
    'seenAt': !exists(json, 'seen_at') ? undefined : json['seen_at'],
    'actions': json['actions'].map(SaveNotificationActionFromJSON)
  };
}
function SaveNotificationToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'type': value.type,
    'group_id': value.groupId,
    'is_seen': value.isSeen,
    'seen_at': value.seenAt,
    'actions': value.actions.map(SaveNotificationActionToJSON)
  };
}

/* tslint:disable */
/* eslint-disable */
// @ts-nocheck
/**
 * API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * @export
 */
const SaveOfRepostNotificationActionDataTypeEnum = {
  Track: 'track',
  Playlist: 'playlist',
  Album: 'album'
};
/**
 * Check if a given object implements the SaveOfRepostNotificationActionData interface.
 */
function instanceOfSaveOfRepostNotificationActionData(value) {
  let isInstance = true;
  isInstance = isInstance && "type" in value && value["type"] !== undefined;
  isInstance = isInstance && "userId" in value && value["userId"] !== undefined;
  isInstance = isInstance && "saveOfRepostItemId" in value && value["saveOfRepostItemId"] !== undefined;
  return isInstance;
}
function SaveOfRepostNotificationActionDataFromJSON(json) {
  return SaveOfRepostNotificationActionDataFromJSONTyped(json);
}
function SaveOfRepostNotificationActionDataFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'type': json['type'],
    'userId': json['user_id'],
    'saveOfRepostItemId': json['save_of_repost_item_id']
  };
}
function SaveOfRepostNotificationActionDataToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'type': value.type,
    'user_id': value.userId,
    'save_of_repost_item_id': value.saveOfRepostItemId
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the SaveOfRepostNotificationAction interface.
 */
function instanceOfSaveOfRepostNotificationAction(value) {
  let isInstance = true;
  isInstance = isInstance && "specifier" in value && value["specifier"] !== undefined;
  isInstance = isInstance && "type" in value && value["type"] !== undefined;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== undefined;
  isInstance = isInstance && "data" in value && value["data"] !== undefined;
  return isInstance;
}
function SaveOfRepostNotificationActionFromJSON(json) {
  return SaveOfRepostNotificationActionFromJSONTyped(json);
}
function SaveOfRepostNotificationActionFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'specifier': json['specifier'],
    'type': json['type'],
    'timestamp': json['timestamp'],
    'data': SaveOfRepostNotificationActionDataFromJSON(json['data'])
  };
}
function SaveOfRepostNotificationActionToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'specifier': value.specifier,
    'type': value.type,
    'timestamp': value.timestamp,
    'data': SaveOfRepostNotificationActionDataToJSON(value.data)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the SaveOfRepostNotification interface.
 */
function instanceOfSaveOfRepostNotification(value) {
  let isInstance = true;
  isInstance = isInstance && "type" in value && value["type"] !== undefined;
  isInstance = isInstance && "groupId" in value && value["groupId"] !== undefined;
  isInstance = isInstance && "isSeen" in value && value["isSeen"] !== undefined;
  isInstance = isInstance && "actions" in value && value["actions"] !== undefined;
  return isInstance;
}
function SaveOfRepostNotificationFromJSON(json) {
  return SaveOfRepostNotificationFromJSONTyped(json);
}
function SaveOfRepostNotificationFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'type': json['type'],
    'groupId': json['group_id'],
    'isSeen': json['is_seen'],
    'seenAt': !exists(json, 'seen_at') ? undefined : json['seen_at'],
    'actions': json['actions'].map(SaveOfRepostNotificationActionFromJSON)
  };
}
function SaveOfRepostNotificationToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'type': value.type,
    'group_id': value.groupId,
    'is_seen': value.isSeen,
    'seen_at': value.seenAt,
    'actions': value.actions.map(SaveOfRepostNotificationActionToJSON)
  };
}

/* tslint:disable */
/* eslint-disable */
// @ts-nocheck
/**
 * API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * Check if a given object implements the SendTipNotificationActionData interface.
 */
function instanceOfSendTipNotificationActionData(value) {
  let isInstance = true;
  isInstance = isInstance && "amount" in value && value["amount"] !== undefined;
  isInstance = isInstance && "senderUserId" in value && value["senderUserId"] !== undefined;
  isInstance = isInstance && "receiverUserId" in value && value["receiverUserId"] !== undefined;
  isInstance = isInstance && "tipTxSignature" in value && value["tipTxSignature"] !== undefined;
  return isInstance;
}
function SendTipNotificationActionDataFromJSON(json) {
  return SendTipNotificationActionDataFromJSONTyped(json);
}
function SendTipNotificationActionDataFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'amount': json['amount'],
    'senderUserId': json['sender_user_id'],
    'receiverUserId': json['receiver_user_id'],
    'tipTxSignature': json['tip_tx_signature']
  };
}
function SendTipNotificationActionDataToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'amount': value.amount,
    'sender_user_id': value.senderUserId,
    'receiver_user_id': value.receiverUserId,
    'tip_tx_signature': value.tipTxSignature
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the SendTipNotificationAction interface.
 */
function instanceOfSendTipNotificationAction(value) {
  let isInstance = true;
  isInstance = isInstance && "specifier" in value && value["specifier"] !== undefined;
  isInstance = isInstance && "type" in value && value["type"] !== undefined;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== undefined;
  isInstance = isInstance && "data" in value && value["data"] !== undefined;
  return isInstance;
}
function SendTipNotificationActionFromJSON(json) {
  return SendTipNotificationActionFromJSONTyped(json);
}
function SendTipNotificationActionFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'specifier': json['specifier'],
    'type': json['type'],
    'timestamp': json['timestamp'],
    'data': SendTipNotificationActionDataFromJSON(json['data'])
  };
}
function SendTipNotificationActionToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'specifier': value.specifier,
    'type': value.type,
    'timestamp': value.timestamp,
    'data': SendTipNotificationActionDataToJSON(value.data)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the SendTipNotification interface.
 */
function instanceOfSendTipNotification(value) {
  let isInstance = true;
  isInstance = isInstance && "type" in value && value["type"] !== undefined;
  isInstance = isInstance && "groupId" in value && value["groupId"] !== undefined;
  isInstance = isInstance && "isSeen" in value && value["isSeen"] !== undefined;
  isInstance = isInstance && "actions" in value && value["actions"] !== undefined;
  return isInstance;
}
function SendTipNotificationFromJSON(json) {
  return SendTipNotificationFromJSONTyped(json);
}
function SendTipNotificationFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'type': json['type'],
    'groupId': json['group_id'],
    'isSeen': json['is_seen'],
    'seenAt': !exists(json, 'seen_at') ? undefined : json['seen_at'],
    'actions': json['actions'].map(SendTipNotificationActionFromJSON)
  };
}
function SendTipNotificationToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'type': value.type,
    'group_id': value.groupId,
    'is_seen': value.isSeen,
    'seen_at': value.seenAt,
    'actions': value.actions.map(SendTipNotificationActionToJSON)
  };
}

/* tslint:disable */
/* eslint-disable */
// @ts-nocheck
/**
 * API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * Check if a given object implements the SupporterDethronedNotificationActionData interface.
 */
function instanceOfSupporterDethronedNotificationActionData(value) {
  let isInstance = true;
  isInstance = isInstance && "dethronedUserId" in value && value["dethronedUserId"] !== undefined;
  isInstance = isInstance && "senderUserId" in value && value["senderUserId"] !== undefined;
  isInstance = isInstance && "receiverUserId" in value && value["receiverUserId"] !== undefined;
  return isInstance;
}
function SupporterDethronedNotificationActionDataFromJSON(json) {
  return SupporterDethronedNotificationActionDataFromJSONTyped(json);
}
function SupporterDethronedNotificationActionDataFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'dethronedUserId': json['dethroned_user_id'],
    'senderUserId': json['sender_user_id'],
    'receiverUserId': json['receiver_user_id']
  };
}
function SupporterDethronedNotificationActionDataToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'dethroned_user_id': value.dethronedUserId,
    'sender_user_id': value.senderUserId,
    'receiver_user_id': value.receiverUserId
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the SupporterDethronedNotificationAction interface.
 */
function instanceOfSupporterDethronedNotificationAction(value) {
  let isInstance = true;
  isInstance = isInstance && "specifier" in value && value["specifier"] !== undefined;
  isInstance = isInstance && "type" in value && value["type"] !== undefined;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== undefined;
  isInstance = isInstance && "data" in value && value["data"] !== undefined;
  return isInstance;
}
function SupporterDethronedNotificationActionFromJSON(json) {
  return SupporterDethronedNotificationActionFromJSONTyped(json);
}
function SupporterDethronedNotificationActionFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'specifier': json['specifier'],
    'type': json['type'],
    'timestamp': json['timestamp'],
    'data': SupporterDethronedNotificationActionDataFromJSON(json['data'])
  };
}
function SupporterDethronedNotificationActionToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'specifier': value.specifier,
    'type': value.type,
    'timestamp': value.timestamp,
    'data': SupporterDethronedNotificationActionDataToJSON(value.data)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the SupporterDethronedNotification interface.
 */
function instanceOfSupporterDethronedNotification(value) {
  let isInstance = true;
  isInstance = isInstance && "type" in value && value["type"] !== undefined;
  isInstance = isInstance && "groupId" in value && value["groupId"] !== undefined;
  isInstance = isInstance && "isSeen" in value && value["isSeen"] !== undefined;
  isInstance = isInstance && "actions" in value && value["actions"] !== undefined;
  return isInstance;
}
function SupporterDethronedNotificationFromJSON(json) {
  return SupporterDethronedNotificationFromJSONTyped(json);
}
function SupporterDethronedNotificationFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'type': json['type'],
    'groupId': json['group_id'],
    'isSeen': json['is_seen'],
    'seenAt': !exists(json, 'seen_at') ? undefined : json['seen_at'],
    'actions': json['actions'].map(SupporterDethronedNotificationActionFromJSON)
  };
}
function SupporterDethronedNotificationToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'type': value.type,
    'group_id': value.groupId,
    'is_seen': value.isSeen,
    'seen_at': value.seenAt,
    'actions': value.actions.map(SupporterDethronedNotificationActionToJSON)
  };
}

/* tslint:disable */
/* eslint-disable */
// @ts-nocheck
/**
 * API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * Check if a given object implements the SupporterRankUpNotificationActionData interface.
 */
function instanceOfSupporterRankUpNotificationActionData(value) {
  let isInstance = true;
  isInstance = isInstance && "rank" in value && value["rank"] !== undefined;
  isInstance = isInstance && "senderUserId" in value && value["senderUserId"] !== undefined;
  isInstance = isInstance && "receiverUserId" in value && value["receiverUserId"] !== undefined;
  return isInstance;
}
function SupporterRankUpNotificationActionDataFromJSON(json) {
  return SupporterRankUpNotificationActionDataFromJSONTyped(json);
}
function SupporterRankUpNotificationActionDataFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'rank': json['rank'],
    'senderUserId': json['sender_user_id'],
    'receiverUserId': json['receiver_user_id']
  };
}
function SupporterRankUpNotificationActionDataToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'rank': value.rank,
    'sender_user_id': value.senderUserId,
    'receiver_user_id': value.receiverUserId
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the SupporterRankUpNotificationAction interface.
 */
function instanceOfSupporterRankUpNotificationAction(value) {
  let isInstance = true;
  isInstance = isInstance && "specifier" in value && value["specifier"] !== undefined;
  isInstance = isInstance && "type" in value && value["type"] !== undefined;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== undefined;
  isInstance = isInstance && "data" in value && value["data"] !== undefined;
  return isInstance;
}
function SupporterRankUpNotificationActionFromJSON(json) {
  return SupporterRankUpNotificationActionFromJSONTyped(json);
}
function SupporterRankUpNotificationActionFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'specifier': json['specifier'],
    'type': json['type'],
    'timestamp': json['timestamp'],
    'data': SupporterRankUpNotificationActionDataFromJSON(json['data'])
  };
}
function SupporterRankUpNotificationActionToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'specifier': value.specifier,
    'type': value.type,
    'timestamp': value.timestamp,
    'data': SupporterRankUpNotificationActionDataToJSON(value.data)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the SupporterRankUpNotification interface.
 */
function instanceOfSupporterRankUpNotification(value) {
  let isInstance = true;
  isInstance = isInstance && "type" in value && value["type"] !== undefined;
  isInstance = isInstance && "groupId" in value && value["groupId"] !== undefined;
  isInstance = isInstance && "isSeen" in value && value["isSeen"] !== undefined;
  isInstance = isInstance && "actions" in value && value["actions"] !== undefined;
  return isInstance;
}
function SupporterRankUpNotificationFromJSON(json) {
  return SupporterRankUpNotificationFromJSONTyped(json);
}
function SupporterRankUpNotificationFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'type': json['type'],
    'groupId': json['group_id'],
    'isSeen': json['is_seen'],
    'seenAt': !exists(json, 'seen_at') ? undefined : json['seen_at'],
    'actions': json['actions'].map(SupporterRankUpNotificationActionFromJSON)
  };
}
function SupporterRankUpNotificationToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'type': value.type,
    'group_id': value.groupId,
    'is_seen': value.isSeen,
    'seen_at': value.seenAt,
    'actions': value.actions.map(SupporterRankUpNotificationActionToJSON)
  };
}

/* tslint:disable */
/* eslint-disable */
// @ts-nocheck
/**
 * API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * Check if a given object implements the TastemakerNotificationActionData interface.
 */
function instanceOfTastemakerNotificationActionData(value) {
  let isInstance = true;
  isInstance = isInstance && "tastemakerItemOwnerId" in value && value["tastemakerItemOwnerId"] !== undefined;
  isInstance = isInstance && "tastemakerItemId" in value && value["tastemakerItemId"] !== undefined;
  isInstance = isInstance && "action" in value && value["action"] !== undefined;
  isInstance = isInstance && "tastemakerItemType" in value && value["tastemakerItemType"] !== undefined;
  isInstance = isInstance && "tastemakerUserId" in value && value["tastemakerUserId"] !== undefined;
  return isInstance;
}
function TastemakerNotificationActionDataFromJSON(json) {
  return TastemakerNotificationActionDataFromJSONTyped(json);
}
function TastemakerNotificationActionDataFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'tastemakerItemOwnerId': json['tastemaker_item_owner_id'],
    'tastemakerItemId': json['tastemaker_item_id'],
    'action': json['action'],
    'tastemakerItemType': json['tastemaker_item_type'],
    'tastemakerUserId': json['tastemaker_user_id']
  };
}
function TastemakerNotificationActionDataToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'tastemaker_item_owner_id': value.tastemakerItemOwnerId,
    'tastemaker_item_id': value.tastemakerItemId,
    'action': value.action,
    'tastemaker_item_type': value.tastemakerItemType,
    'tastemaker_user_id': value.tastemakerUserId
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the TastemakerNotificationAction interface.
 */
function instanceOfTastemakerNotificationAction(value) {
  let isInstance = true;
  isInstance = isInstance && "specifier" in value && value["specifier"] !== undefined;
  isInstance = isInstance && "type" in value && value["type"] !== undefined;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== undefined;
  isInstance = isInstance && "data" in value && value["data"] !== undefined;
  return isInstance;
}
function TastemakerNotificationActionFromJSON(json) {
  return TastemakerNotificationActionFromJSONTyped(json);
}
function TastemakerNotificationActionFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'specifier': json['specifier'],
    'type': json['type'],
    'timestamp': json['timestamp'],
    'data': TastemakerNotificationActionDataFromJSON(json['data'])
  };
}
function TastemakerNotificationActionToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'specifier': value.specifier,
    'type': value.type,
    'timestamp': value.timestamp,
    'data': TastemakerNotificationActionDataToJSON(value.data)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the TastemakerNotification interface.
 */
function instanceOfTastemakerNotification(value) {
  let isInstance = true;
  isInstance = isInstance && "type" in value && value["type"] !== undefined;
  isInstance = isInstance && "groupId" in value && value["groupId"] !== undefined;
  isInstance = isInstance && "isSeen" in value && value["isSeen"] !== undefined;
  isInstance = isInstance && "actions" in value && value["actions"] !== undefined;
  return isInstance;
}
function TastemakerNotificationFromJSON(json) {
  return TastemakerNotificationFromJSONTyped(json);
}
function TastemakerNotificationFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'type': json['type'],
    'groupId': json['group_id'],
    'isSeen': json['is_seen'],
    'seenAt': !exists(json, 'seen_at') ? undefined : json['seen_at'],
    'actions': json['actions'].map(TastemakerNotificationActionFromJSON)
  };
}
function TastemakerNotificationToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'type': value.type,
    'group_id': value.groupId,
    'is_seen': value.isSeen,
    'seen_at': value.seenAt,
    'actions': value.actions.map(TastemakerNotificationActionToJSON)
  };
}

/* tslint:disable */
/* eslint-disable */
// @ts-nocheck
/**
 * API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * Check if a given object implements the TierChangeNotificationActionData interface.
 */
function instanceOfTierChangeNotificationActionData(value) {
  let isInstance = true;
  isInstance = isInstance && "newTier" in value && value["newTier"] !== undefined;
  isInstance = isInstance && "currentValue" in value && value["currentValue"] !== undefined;
  isInstance = isInstance && "newTierValue" in value && value["newTierValue"] !== undefined;
  return isInstance;
}
function TierChangeNotificationActionDataFromJSON(json) {
  return TierChangeNotificationActionDataFromJSONTyped(json);
}
function TierChangeNotificationActionDataFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'newTier': json['new_tier'],
    'currentValue': json['current_value'],
    'newTierValue': json['new_tier_value']
  };
}
function TierChangeNotificationActionDataToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'new_tier': value.newTier,
    'current_value': value.currentValue,
    'new_tier_value': value.newTierValue
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the TierChangeNotificationAction interface.
 */
function instanceOfTierChangeNotificationAction(value) {
  let isInstance = true;
  isInstance = isInstance && "specifier" in value && value["specifier"] !== undefined;
  isInstance = isInstance && "type" in value && value["type"] !== undefined;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== undefined;
  isInstance = isInstance && "data" in value && value["data"] !== undefined;
  return isInstance;
}
function TierChangeNotificationActionFromJSON(json) {
  return TierChangeNotificationActionFromJSONTyped(json);
}
function TierChangeNotificationActionFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'specifier': json['specifier'],
    'type': json['type'],
    'timestamp': json['timestamp'],
    'data': TierChangeNotificationActionDataFromJSON(json['data'])
  };
}
function TierChangeNotificationActionToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'specifier': value.specifier,
    'type': value.type,
    'timestamp': value.timestamp,
    'data': TierChangeNotificationActionDataToJSON(value.data)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the TierChangeNotification interface.
 */
function instanceOfTierChangeNotification(value) {
  let isInstance = true;
  isInstance = isInstance && "type" in value && value["type"] !== undefined;
  isInstance = isInstance && "groupId" in value && value["groupId"] !== undefined;
  isInstance = isInstance && "isSeen" in value && value["isSeen"] !== undefined;
  isInstance = isInstance && "actions" in value && value["actions"] !== undefined;
  return isInstance;
}
function TierChangeNotificationFromJSON(json) {
  return TierChangeNotificationFromJSONTyped(json);
}
function TierChangeNotificationFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'type': json['type'],
    'groupId': json['group_id'],
    'isSeen': json['is_seen'],
    'seenAt': !exists(json, 'seen_at') ? undefined : json['seen_at'],
    'actions': json['actions'].map(TierChangeNotificationActionFromJSON)
  };
}
function TierChangeNotificationToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'type': value.type,
    'group_id': value.groupId,
    'is_seen': value.isSeen,
    'seen_at': value.seenAt,
    'actions': value.actions.map(TierChangeNotificationActionToJSON)
  };
}

/* tslint:disable */
/* eslint-disable */
// @ts-nocheck
/**
 * API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * Check if a given object implements the TrackAddedToPlaylistNotificationActionData interface.
 */
function instanceOfTrackAddedToPlaylistNotificationActionData(value) {
  let isInstance = true;
  isInstance = isInstance && "trackId" in value && value["trackId"] !== undefined;
  isInstance = isInstance && "playlistId" in value && value["playlistId"] !== undefined;
  isInstance = isInstance && "playlistOwnerId" in value && value["playlistOwnerId"] !== undefined;
  return isInstance;
}
function TrackAddedToPlaylistNotificationActionDataFromJSON(json) {
  return TrackAddedToPlaylistNotificationActionDataFromJSONTyped(json);
}
function TrackAddedToPlaylistNotificationActionDataFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'trackId': json['track_id'],
    'playlistId': json['playlist_id'],
    'playlistOwnerId': json['playlist_owner_id']
  };
}
function TrackAddedToPlaylistNotificationActionDataToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'track_id': value.trackId,
    'playlist_id': value.playlistId,
    'playlist_owner_id': value.playlistOwnerId
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the TrackAddedToPlaylistNotificationAction interface.
 */
function instanceOfTrackAddedToPlaylistNotificationAction(value) {
  let isInstance = true;
  isInstance = isInstance && "specifier" in value && value["specifier"] !== undefined;
  isInstance = isInstance && "type" in value && value["type"] !== undefined;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== undefined;
  isInstance = isInstance && "data" in value && value["data"] !== undefined;
  return isInstance;
}
function TrackAddedToPlaylistNotificationActionFromJSON(json) {
  return TrackAddedToPlaylistNotificationActionFromJSONTyped(json);
}
function TrackAddedToPlaylistNotificationActionFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'specifier': json['specifier'],
    'type': json['type'],
    'timestamp': json['timestamp'],
    'data': TrackAddedToPlaylistNotificationActionDataFromJSON(json['data'])
  };
}
function TrackAddedToPlaylistNotificationActionToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'specifier': value.specifier,
    'type': value.type,
    'timestamp': value.timestamp,
    'data': TrackAddedToPlaylistNotificationActionDataToJSON(value.data)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the TrackAddedToPlaylistNotification interface.
 */
function instanceOfTrackAddedToPlaylistNotification(value) {
  let isInstance = true;
  isInstance = isInstance && "type" in value && value["type"] !== undefined;
  isInstance = isInstance && "groupId" in value && value["groupId"] !== undefined;
  isInstance = isInstance && "isSeen" in value && value["isSeen"] !== undefined;
  isInstance = isInstance && "actions" in value && value["actions"] !== undefined;
  return isInstance;
}
function TrackAddedToPlaylistNotificationFromJSON(json) {
  return TrackAddedToPlaylistNotificationFromJSONTyped(json);
}
function TrackAddedToPlaylistNotificationFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'type': json['type'],
    'groupId': json['group_id'],
    'isSeen': json['is_seen'],
    'seenAt': !exists(json, 'seen_at') ? undefined : json['seen_at'],
    'actions': json['actions'].map(TrackAddedToPlaylistNotificationActionFromJSON)
  };
}
function TrackAddedToPlaylistNotificationToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'type': value.type,
    'group_id': value.groupId,
    'is_seen': value.isSeen,
    'seen_at': value.seenAt,
    'actions': value.actions.map(TrackAddedToPlaylistNotificationActionToJSON)
  };
}

/* tslint:disable */
/* eslint-disable */
// @ts-nocheck
/**
 * API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * Check if a given object implements the TrackAddedToPurchasedAlbumNotificationActionData interface.
 */
function instanceOfTrackAddedToPurchasedAlbumNotificationActionData(value) {
  let isInstance = true;
  isInstance = isInstance && "trackId" in value && value["trackId"] !== undefined;
  isInstance = isInstance && "playlistId" in value && value["playlistId"] !== undefined;
  isInstance = isInstance && "playlistOwnerId" in value && value["playlistOwnerId"] !== undefined;
  return isInstance;
}
function TrackAddedToPurchasedAlbumNotificationActionDataFromJSON(json) {
  return TrackAddedToPurchasedAlbumNotificationActionDataFromJSONTyped(json);
}
function TrackAddedToPurchasedAlbumNotificationActionDataFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'trackId': json['track_id'],
    'playlistId': json['playlist_id'],
    'playlistOwnerId': json['playlist_owner_id']
  };
}
function TrackAddedToPurchasedAlbumNotificationActionDataToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'track_id': value.trackId,
    'playlist_id': value.playlistId,
    'playlist_owner_id': value.playlistOwnerId
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the TrackAddedToPurchasedAlbumNotificationAction interface.
 */
function instanceOfTrackAddedToPurchasedAlbumNotificationAction(value) {
  let isInstance = true;
  isInstance = isInstance && "specifier" in value && value["specifier"] !== undefined;
  isInstance = isInstance && "type" in value && value["type"] !== undefined;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== undefined;
  isInstance = isInstance && "data" in value && value["data"] !== undefined;
  return isInstance;
}
function TrackAddedToPurchasedAlbumNotificationActionFromJSON(json) {
  return TrackAddedToPurchasedAlbumNotificationActionFromJSONTyped(json);
}
function TrackAddedToPurchasedAlbumNotificationActionFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'specifier': json['specifier'],
    'type': json['type'],
    'timestamp': json['timestamp'],
    'data': TrackAddedToPurchasedAlbumNotificationActionDataFromJSON(json['data'])
  };
}
function TrackAddedToPurchasedAlbumNotificationActionToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'specifier': value.specifier,
    'type': value.type,
    'timestamp': value.timestamp,
    'data': TrackAddedToPurchasedAlbumNotificationActionDataToJSON(value.data)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the TrackAddedToPurchasedAlbumNotification interface.
 */
function instanceOfTrackAddedToPurchasedAlbumNotification(value) {
  let isInstance = true;
  isInstance = isInstance && "type" in value && value["type"] !== undefined;
  isInstance = isInstance && "groupId" in value && value["groupId"] !== undefined;
  isInstance = isInstance && "isSeen" in value && value["isSeen"] !== undefined;
  isInstance = isInstance && "actions" in value && value["actions"] !== undefined;
  return isInstance;
}
function TrackAddedToPurchasedAlbumNotificationFromJSON(json) {
  return TrackAddedToPurchasedAlbumNotificationFromJSONTyped(json);
}
function TrackAddedToPurchasedAlbumNotificationFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'type': json['type'],
    'groupId': json['group_id'],
    'isSeen': json['is_seen'],
    'seenAt': !exists(json, 'seen_at') ? undefined : json['seen_at'],
    'actions': json['actions'].map(TrackAddedToPurchasedAlbumNotificationActionFromJSON)
  };
}
function TrackAddedToPurchasedAlbumNotificationToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'type': value.type,
    'group_id': value.groupId,
    'is_seen': value.isSeen,
    'seen_at': value.seenAt,
    'actions': value.actions.map(TrackAddedToPurchasedAlbumNotificationActionToJSON)
  };
}

/* tslint:disable */
/* eslint-disable */
// @ts-nocheck
/**
 * API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * @export
 */
const TrendingNotificationActionDataTimeRangeEnum = {
  Week: 'week',
  Month: 'month',
  Year: 'year'
};
/**
 * Check if a given object implements the TrendingNotificationActionData interface.
 */
function instanceOfTrendingNotificationActionData(value) {
  let isInstance = true;
  isInstance = isInstance && "rank" in value && value["rank"] !== undefined;
  isInstance = isInstance && "genre" in value && value["genre"] !== undefined;
  isInstance = isInstance && "trackId" in value && value["trackId"] !== undefined;
  isInstance = isInstance && "timeRange" in value && value["timeRange"] !== undefined;
  return isInstance;
}
function TrendingNotificationActionDataFromJSON(json) {
  return TrendingNotificationActionDataFromJSONTyped(json);
}
function TrendingNotificationActionDataFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'rank': json['rank'],
    'genre': json['genre'],
    'trackId': json['track_id'],
    'timeRange': json['time_range']
  };
}
function TrendingNotificationActionDataToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'rank': value.rank,
    'genre': value.genre,
    'track_id': value.trackId,
    'time_range': value.timeRange
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the TrendingNotificationAction interface.
 */
function instanceOfTrendingNotificationAction(value) {
  let isInstance = true;
  isInstance = isInstance && "specifier" in value && value["specifier"] !== undefined;
  isInstance = isInstance && "type" in value && value["type"] !== undefined;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== undefined;
  isInstance = isInstance && "data" in value && value["data"] !== undefined;
  return isInstance;
}
function TrendingNotificationActionFromJSON(json) {
  return TrendingNotificationActionFromJSONTyped(json);
}
function TrendingNotificationActionFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'specifier': json['specifier'],
    'type': json['type'],
    'timestamp': json['timestamp'],
    'data': TrendingNotificationActionDataFromJSON(json['data'])
  };
}
function TrendingNotificationActionToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'specifier': value.specifier,
    'type': value.type,
    'timestamp': value.timestamp,
    'data': TrendingNotificationActionDataToJSON(value.data)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the TrendingNotification interface.
 */
function instanceOfTrendingNotification(value) {
  let isInstance = true;
  isInstance = isInstance && "type" in value && value["type"] !== undefined;
  isInstance = isInstance && "groupId" in value && value["groupId"] !== undefined;
  isInstance = isInstance && "isSeen" in value && value["isSeen"] !== undefined;
  isInstance = isInstance && "actions" in value && value["actions"] !== undefined;
  return isInstance;
}
function TrendingNotificationFromJSON(json) {
  return TrendingNotificationFromJSONTyped(json);
}
function TrendingNotificationFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'type': json['type'],
    'groupId': json['group_id'],
    'isSeen': json['is_seen'],
    'seenAt': !exists(json, 'seen_at') ? undefined : json['seen_at'],
    'actions': json['actions'].map(TrendingNotificationActionFromJSON)
  };
}
function TrendingNotificationToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'type': value.type,
    'group_id': value.groupId,
    'is_seen': value.isSeen,
    'seen_at': value.seenAt,
    'actions': value.actions.map(TrendingNotificationActionToJSON)
  };
}

/* tslint:disable */
/* eslint-disable */
// @ts-nocheck
/**
 * API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * @export
 */
const TrendingPlaylistNotificationActionDataTimeRangeEnum = {
  Week: 'week',
  Month: 'month',
  Year: 'year'
};
/**
 * Check if a given object implements the TrendingPlaylistNotificationActionData interface.
 */
function instanceOfTrendingPlaylistNotificationActionData(value) {
  let isInstance = true;
  isInstance = isInstance && "rank" in value && value["rank"] !== undefined;
  isInstance = isInstance && "genre" in value && value["genre"] !== undefined;
  isInstance = isInstance && "playlistId" in value && value["playlistId"] !== undefined;
  isInstance = isInstance && "timeRange" in value && value["timeRange"] !== undefined;
  return isInstance;
}
function TrendingPlaylistNotificationActionDataFromJSON(json) {
  return TrendingPlaylistNotificationActionDataFromJSONTyped(json);
}
function TrendingPlaylistNotificationActionDataFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'rank': json['rank'],
    'genre': json['genre'],
    'playlistId': json['playlist_id'],
    'timeRange': json['time_range']
  };
}
function TrendingPlaylistNotificationActionDataToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'rank': value.rank,
    'genre': value.genre,
    'playlist_id': value.playlistId,
    'time_range': value.timeRange
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the TrendingPlaylistNotificationAction interface.
 */
function instanceOfTrendingPlaylistNotificationAction(value) {
  let isInstance = true;
  isInstance = isInstance && "specifier" in value && value["specifier"] !== undefined;
  isInstance = isInstance && "type" in value && value["type"] !== undefined;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== undefined;
  isInstance = isInstance && "data" in value && value["data"] !== undefined;
  return isInstance;
}
function TrendingPlaylistNotificationActionFromJSON(json) {
  return TrendingPlaylistNotificationActionFromJSONTyped(json);
}
function TrendingPlaylistNotificationActionFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'specifier': json['specifier'],
    'type': json['type'],
    'timestamp': json['timestamp'],
    'data': TrendingPlaylistNotificationActionDataFromJSON(json['data'])
  };
}
function TrendingPlaylistNotificationActionToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'specifier': value.specifier,
    'type': value.type,
    'timestamp': value.timestamp,
    'data': TrendingPlaylistNotificationActionDataToJSON(value.data)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the TrendingPlaylistNotification interface.
 */
function instanceOfTrendingPlaylistNotification(value) {
  let isInstance = true;
  isInstance = isInstance && "type" in value && value["type"] !== undefined;
  isInstance = isInstance && "groupId" in value && value["groupId"] !== undefined;
  isInstance = isInstance && "isSeen" in value && value["isSeen"] !== undefined;
  isInstance = isInstance && "actions" in value && value["actions"] !== undefined;
  return isInstance;
}
function TrendingPlaylistNotificationFromJSON(json) {
  return TrendingPlaylistNotificationFromJSONTyped(json);
}
function TrendingPlaylistNotificationFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'type': json['type'],
    'groupId': json['group_id'],
    'isSeen': json['is_seen'],
    'seenAt': !exists(json, 'seen_at') ? undefined : json['seen_at'],
    'actions': json['actions'].map(TrendingPlaylistNotificationActionFromJSON)
  };
}
function TrendingPlaylistNotificationToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'type': value.type,
    'group_id': value.groupId,
    'is_seen': value.isSeen,
    'seen_at': value.seenAt,
    'actions': value.actions.map(TrendingPlaylistNotificationActionToJSON)
  };
}

/* tslint:disable */
/* eslint-disable */
// @ts-nocheck
/**
 * API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * @export
 */
const TrendingUndergroundNotificationActionDataTimeRangeEnum = {
  Week: 'week',
  Month: 'month',
  Year: 'year'
};
/**
 * Check if a given object implements the TrendingUndergroundNotificationActionData interface.
 */
function instanceOfTrendingUndergroundNotificationActionData(value) {
  let isInstance = true;
  isInstance = isInstance && "rank" in value && value["rank"] !== undefined;
  isInstance = isInstance && "genre" in value && value["genre"] !== undefined;
  isInstance = isInstance && "trackId" in value && value["trackId"] !== undefined;
  isInstance = isInstance && "timeRange" in value && value["timeRange"] !== undefined;
  return isInstance;
}
function TrendingUndergroundNotificationActionDataFromJSON(json) {
  return TrendingUndergroundNotificationActionDataFromJSONTyped(json);
}
function TrendingUndergroundNotificationActionDataFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'rank': json['rank'],
    'genre': json['genre'],
    'trackId': json['track_id'],
    'timeRange': json['time_range']
  };
}
function TrendingUndergroundNotificationActionDataToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'rank': value.rank,
    'genre': value.genre,
    'track_id': value.trackId,
    'time_range': value.timeRange
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the TrendingUndergroundNotificationAction interface.
 */
function instanceOfTrendingUndergroundNotificationAction(value) {
  let isInstance = true;
  isInstance = isInstance && "specifier" in value && value["specifier"] !== undefined;
  isInstance = isInstance && "type" in value && value["type"] !== undefined;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== undefined;
  isInstance = isInstance && "data" in value && value["data"] !== undefined;
  return isInstance;
}
function TrendingUndergroundNotificationActionFromJSON(json) {
  return TrendingUndergroundNotificationActionFromJSONTyped(json);
}
function TrendingUndergroundNotificationActionFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'specifier': json['specifier'],
    'type': json['type'],
    'timestamp': json['timestamp'],
    'data': TrendingUndergroundNotificationActionDataFromJSON(json['data'])
  };
}
function TrendingUndergroundNotificationActionToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'specifier': value.specifier,
    'type': value.type,
    'timestamp': value.timestamp,
    'data': TrendingUndergroundNotificationActionDataToJSON(value.data)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the TrendingUndergroundNotification interface.
 */
function instanceOfTrendingUndergroundNotification(value) {
  let isInstance = true;
  isInstance = isInstance && "type" in value && value["type"] !== undefined;
  isInstance = isInstance && "groupId" in value && value["groupId"] !== undefined;
  isInstance = isInstance && "isSeen" in value && value["isSeen"] !== undefined;
  isInstance = isInstance && "actions" in value && value["actions"] !== undefined;
  return isInstance;
}
function TrendingUndergroundNotificationFromJSON(json) {
  return TrendingUndergroundNotificationFromJSONTyped(json);
}
function TrendingUndergroundNotificationFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'type': json['type'],
    'groupId': json['group_id'],
    'isSeen': json['is_seen'],
    'seenAt': !exists(json, 'seen_at') ? undefined : json['seen_at'],
    'actions': json['actions'].map(TrendingUndergroundNotificationActionFromJSON)
  };
}
function TrendingUndergroundNotificationToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'type': value.type,
    'group_id': value.groupId,
    'is_seen': value.isSeen,
    'seen_at': value.seenAt,
    'actions': value.actions.map(TrendingUndergroundNotificationActionToJSON)
  };
}

/* tslint:disable */
/* eslint-disable */
// @ts-nocheck
/**
 * API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * Check if a given object implements the UsdcPurchaseBuyerNotificationActionData interface.
 */
function instanceOfUsdcPurchaseBuyerNotificationActionData(value) {
  let isInstance = true;
  isInstance = isInstance && "contentType" in value && value["contentType"] !== undefined;
  isInstance = isInstance && "buyerUserId" in value && value["buyerUserId"] !== undefined;
  isInstance = isInstance && "sellerUserId" in value && value["sellerUserId"] !== undefined;
  isInstance = isInstance && "amount" in value && value["amount"] !== undefined;
  isInstance = isInstance && "extraAmount" in value && value["extraAmount"] !== undefined;
  isInstance = isInstance && "contentId" in value && value["contentId"] !== undefined;
  return isInstance;
}
function UsdcPurchaseBuyerNotificationActionDataFromJSON(json) {
  return UsdcPurchaseBuyerNotificationActionDataFromJSONTyped(json);
}
function UsdcPurchaseBuyerNotificationActionDataFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'contentType': json['content_type'],
    'buyerUserId': json['buyer_user_id'],
    'sellerUserId': json['seller_user_id'],
    'amount': json['amount'],
    'extraAmount': json['extra_amount'],
    'contentId': json['content_id']
  };
}
function UsdcPurchaseBuyerNotificationActionDataToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'content_type': value.contentType,
    'buyer_user_id': value.buyerUserId,
    'seller_user_id': value.sellerUserId,
    'amount': value.amount,
    'extra_amount': value.extraAmount,
    'content_id': value.contentId
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the UsdcPurchaseBuyerNotificationAction interface.
 */
function instanceOfUsdcPurchaseBuyerNotificationAction(value) {
  let isInstance = true;
  isInstance = isInstance && "specifier" in value && value["specifier"] !== undefined;
  isInstance = isInstance && "type" in value && value["type"] !== undefined;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== undefined;
  isInstance = isInstance && "data" in value && value["data"] !== undefined;
  return isInstance;
}
function UsdcPurchaseBuyerNotificationActionFromJSON(json) {
  return UsdcPurchaseBuyerNotificationActionFromJSONTyped(json);
}
function UsdcPurchaseBuyerNotificationActionFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'specifier': json['specifier'],
    'type': json['type'],
    'timestamp': json['timestamp'],
    'data': UsdcPurchaseBuyerNotificationActionDataFromJSON(json['data'])
  };
}
function UsdcPurchaseBuyerNotificationActionToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'specifier': value.specifier,
    'type': value.type,
    'timestamp': value.timestamp,
    'data': UsdcPurchaseBuyerNotificationActionDataToJSON(value.data)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the UsdcPurchaseBuyerNotification interface.
 */
function instanceOfUsdcPurchaseBuyerNotification(value) {
  let isInstance = true;
  isInstance = isInstance && "type" in value && value["type"] !== undefined;
  isInstance = isInstance && "groupId" in value && value["groupId"] !== undefined;
  isInstance = isInstance && "isSeen" in value && value["isSeen"] !== undefined;
  isInstance = isInstance && "actions" in value && value["actions"] !== undefined;
  return isInstance;
}
function UsdcPurchaseBuyerNotificationFromJSON(json) {
  return UsdcPurchaseBuyerNotificationFromJSONTyped(json);
}
function UsdcPurchaseBuyerNotificationFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'type': json['type'],
    'groupId': json['group_id'],
    'isSeen': json['is_seen'],
    'seenAt': !exists(json, 'seen_at') ? undefined : json['seen_at'],
    'actions': json['actions'].map(UsdcPurchaseBuyerNotificationActionFromJSON)
  };
}
function UsdcPurchaseBuyerNotificationToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'type': value.type,
    'group_id': value.groupId,
    'is_seen': value.isSeen,
    'seen_at': value.seenAt,
    'actions': value.actions.map(UsdcPurchaseBuyerNotificationActionToJSON)
  };
}

/* tslint:disable */
/* eslint-disable */
// @ts-nocheck
/**
 * API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * Check if a given object implements the UsdcPurchaseSellerNotificationActionData interface.
 */
function instanceOfUsdcPurchaseSellerNotificationActionData(value) {
  let isInstance = true;
  isInstance = isInstance && "contentType" in value && value["contentType"] !== undefined;
  isInstance = isInstance && "buyerUserId" in value && value["buyerUserId"] !== undefined;
  isInstance = isInstance && "sellerUserId" in value && value["sellerUserId"] !== undefined;
  isInstance = isInstance && "amount" in value && value["amount"] !== undefined;
  isInstance = isInstance && "extraAmount" in value && value["extraAmount"] !== undefined;
  isInstance = isInstance && "contentId" in value && value["contentId"] !== undefined;
  return isInstance;
}
function UsdcPurchaseSellerNotificationActionDataFromJSON(json) {
  return UsdcPurchaseSellerNotificationActionDataFromJSONTyped(json);
}
function UsdcPurchaseSellerNotificationActionDataFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'contentType': json['content_type'],
    'buyerUserId': json['buyer_user_id'],
    'sellerUserId': json['seller_user_id'],
    'amount': json['amount'],
    'extraAmount': json['extra_amount'],
    'contentId': json['content_id']
  };
}
function UsdcPurchaseSellerNotificationActionDataToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'content_type': value.contentType,
    'buyer_user_id': value.buyerUserId,
    'seller_user_id': value.sellerUserId,
    'amount': value.amount,
    'extra_amount': value.extraAmount,
    'content_id': value.contentId
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the UsdcPurchaseSellerNotificationAction interface.
 */
function instanceOfUsdcPurchaseSellerNotificationAction(value) {
  let isInstance = true;
  isInstance = isInstance && "specifier" in value && value["specifier"] !== undefined;
  isInstance = isInstance && "type" in value && value["type"] !== undefined;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== undefined;
  isInstance = isInstance && "data" in value && value["data"] !== undefined;
  return isInstance;
}
function UsdcPurchaseSellerNotificationActionFromJSON(json) {
  return UsdcPurchaseSellerNotificationActionFromJSONTyped(json);
}
function UsdcPurchaseSellerNotificationActionFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'specifier': json['specifier'],
    'type': json['type'],
    'timestamp': json['timestamp'],
    'data': UsdcPurchaseSellerNotificationActionDataFromJSON(json['data'])
  };
}
function UsdcPurchaseSellerNotificationActionToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'specifier': value.specifier,
    'type': value.type,
    'timestamp': value.timestamp,
    'data': UsdcPurchaseSellerNotificationActionDataToJSON(value.data)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the UsdcPurchaseSellerNotification interface.
 */
function instanceOfUsdcPurchaseSellerNotification(value) {
  let isInstance = true;
  isInstance = isInstance && "type" in value && value["type"] !== undefined;
  isInstance = isInstance && "groupId" in value && value["groupId"] !== undefined;
  isInstance = isInstance && "isSeen" in value && value["isSeen"] !== undefined;
  isInstance = isInstance && "actions" in value && value["actions"] !== undefined;
  return isInstance;
}
function UsdcPurchaseSellerNotificationFromJSON(json) {
  return UsdcPurchaseSellerNotificationFromJSONTyped(json);
}
function UsdcPurchaseSellerNotificationFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'type': json['type'],
    'groupId': json['group_id'],
    'isSeen': json['is_seen'],
    'seenAt': !exists(json, 'seen_at') ? undefined : json['seen_at'],
    'actions': json['actions'].map(UsdcPurchaseSellerNotificationActionFromJSON)
  };
}
function UsdcPurchaseSellerNotificationToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'type': value.type,
    'group_id': value.groupId,
    'is_seen': value.isSeen,
    'seen_at': value.seenAt,
    'actions': value.actions.map(UsdcPurchaseSellerNotificationActionToJSON)
  };
}

/* tslint:disable */
function NotificationFromJSON(json) {
  return NotificationFromJSONTyped(json);
}
function NotificationFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  switch (json['type']) {
    case 'announcement':
      return {
        ...AnnouncementNotificationFromJSONTyped(json),
        type: 'announcement'
      };
    case 'approve_manager_request':
      return {
        ...ApproveManagerRequestNotificationFromJSONTyped(json),
        type: 'approve_manager_request'
      };
    case 'artist_remix_contest_ended':
      return {
        ...ArtistRemixContestEndedNotificationFromJSONTyped(json),
        type: 'artist_remix_contest_ended'
      };
    case 'artist_remix_contest_ending_soon':
      return {
        ...ArtistRemixContestEndingSoonNotificationFromJSONTyped(json),
        type: 'artist_remix_contest_ending_soon'
      };
    case 'artist_remix_contest_submissions':
      return {
        ...ArtistRemixContestSubmissionsNotificationFromJSONTyped(json),
        type: 'artist_remix_contest_submissions'
      };
    case 'challenge_reward':
      return {
        ...ChallengeRewardNotificationFromJSONTyped(json),
        type: 'challenge_reward'
      };
    case 'claimable_reward':
      return {
        ...ClaimableRewardNotificationFromJSONTyped(json),
        type: 'claimable_reward'
      };
    case 'comment':
      return {
        ...CommentNotificationFromJSONTyped(json),
        type: 'comment'
      };
    case 'comment_mention':
      return {
        ...CommentMentionNotificationFromJSONTyped(json),
        type: 'comment_mention'
      };
    case 'comment_reaction':
      return {
        ...CommentReactionNotificationFromJSONTyped(json),
        type: 'comment_reaction'
      };
    case 'comment_thread':
      return {
        ...CommentThreadNotificationFromJSONTyped(json),
        type: 'comment_thread'
      };
    case 'cosign':
      return {
        ...CosignNotificationFromJSONTyped(json),
        type: 'cosign'
      };
    case 'create':
      return {
        ...CreateNotificationFromJSONTyped(json),
        type: 'create'
      };
    case 'fan_remix_contest_ended':
      return {
        ...FanRemixContestEndedNotificationFromJSONTyped(json),
        type: 'fan_remix_contest_ended'
      };
    case 'fan_remix_contest_ending_soon':
      return {
        ...FanRemixContestEndingSoonNotificationFromJSONTyped(json),
        type: 'fan_remix_contest_ending_soon'
      };
    case 'fan_remix_contest_started':
      return {
        ...FanRemixContestStartedNotificationFromJSONTyped(json),
        type: 'fan_remix_contest_started'
      };
    case 'fan_remix_contest_winners_selected':
      return {
        ...FanRemixContestWinnersSelectedNotificationFromJSONTyped(json),
        type: 'fan_remix_contest_winners_selected'
      };
    case 'follow':
      return {
        ...FollowNotificationFromJSONTyped(json),
        type: 'follow'
      };
    case 'listen_streak_reminder':
      return {
        ...ListenStreakReminderNotificationFromJSONTyped(json),
        type: 'listen_streak_reminder'
      };
    case 'milestone':
      return {
        ...MilestoneNotificationFromJSONTyped(json),
        type: 'milestone'
      };
    case 'reaction':
      return {
        ...ReactionNotificationFromJSONTyped(json),
        type: 'reaction'
      };
    case 'remix':
      return {
        ...RemixNotificationFromJSONTyped(json),
        type: 'remix'
      };
    case 'repost':
      return {
        ...RepostNotificationFromJSONTyped(json),
        type: 'repost'
      };
    case 'repost_of_repost':
      return {
        ...RepostOfRepostNotificationFromJSONTyped(json),
        type: 'repost_of_repost'
      };
    case 'request_manager':
      return {
        ...RequestManagerNotificationFromJSONTyped(json),
        type: 'request_manager'
      };
    case 'save':
      return {
        ...SaveNotificationFromJSONTyped(json),
        type: 'save'
      };
    case 'save_of_repost':
      return {
        ...SaveOfRepostNotificationFromJSONTyped(json),
        type: 'save_of_repost'
      };
    case 'supporter_dethroned':
      return {
        ...SupporterDethronedNotificationFromJSONTyped(json),
        type: 'supporter_dethroned'
      };
    case 'supporter_rank_up':
      return {
        ...SupporterRankUpNotificationFromJSONTyped(json),
        type: 'supporter_rank_up'
      };
    case 'supporting_rank_up':
      return {
        ...SupporterRankUpNotificationFromJSONTyped(json),
        type: 'supporting_rank_up'
      };
    case 'tastemaker':
      return {
        ...TastemakerNotificationFromJSONTyped(json),
        type: 'tastemaker'
      };
    case 'tier_change':
      return {
        ...TierChangeNotificationFromJSONTyped(json),
        type: 'tier_change'
      };
    case 'tip_receive':
      return {
        ...ReceiveTipNotificationFromJSONTyped(json),
        type: 'tip_receive'
      };
    case 'tip_send':
      return {
        ...SendTipNotificationFromJSONTyped(json),
        type: 'tip_send'
      };
    case 'track_added_to_playlist':
      return {
        ...TrackAddedToPlaylistNotificationFromJSONTyped(json),
        type: 'track_added_to_playlist'
      };
    case 'track_added_to_purchased_album':
      return {
        ...TrackAddedToPurchasedAlbumNotificationFromJSONTyped(json),
        type: 'track_added_to_purchased_album'
      };
    case 'trending':
      return {
        ...TrendingNotificationFromJSONTyped(json),
        type: 'trending'
      };
    case 'trending_playlist':
      return {
        ...TrendingPlaylistNotificationFromJSONTyped(json),
        type: 'trending_playlist'
      };
    case 'trending_underground':
      return {
        ...TrendingUndergroundNotificationFromJSONTyped(json),
        type: 'trending_underground'
      };
    case 'usdc_purchase_buyer':
      return {
        ...UsdcPurchaseBuyerNotificationFromJSONTyped(json),
        type: 'usdc_purchase_buyer'
      };
    case 'usdc_purchase_seller':
      return {
        ...UsdcPurchaseSellerNotificationFromJSONTyped(json),
        type: 'usdc_purchase_seller'
      };
    default:
      throw new Error(`No variant of Notification exists with 'type=${json['type']}'`);
  }
}
function NotificationToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  switch (value['type']) {
    case 'announcement':
      return AnnouncementNotificationToJSON(value);
    case 'approve_manager_request':
      return ApproveManagerRequestNotificationToJSON(value);
    case 'artist_remix_contest_ended':
      return ArtistRemixContestEndedNotificationToJSON(value);
    case 'artist_remix_contest_ending_soon':
      return ArtistRemixContestEndingSoonNotificationToJSON(value);
    case 'artist_remix_contest_submissions':
      return ArtistRemixContestSubmissionsNotificationToJSON(value);
    case 'challenge_reward':
      return ChallengeRewardNotificationToJSON(value);
    case 'claimable_reward':
      return ClaimableRewardNotificationToJSON(value);
    case 'comment':
      return CommentNotificationToJSON(value);
    case 'comment_mention':
      return CommentMentionNotificationToJSON(value);
    case 'comment_reaction':
      return CommentReactionNotificationToJSON(value);
    case 'comment_thread':
      return CommentThreadNotificationToJSON(value);
    case 'cosign':
      return CosignNotificationToJSON(value);
    case 'create':
      return CreateNotificationToJSON(value);
    case 'fan_remix_contest_ended':
      return FanRemixContestEndedNotificationToJSON(value);
    case 'fan_remix_contest_ending_soon':
      return FanRemixContestEndingSoonNotificationToJSON(value);
    case 'fan_remix_contest_started':
      return FanRemixContestStartedNotificationToJSON(value);
    case 'fan_remix_contest_winners_selected':
      return FanRemixContestWinnersSelectedNotificationToJSON(value);
    case 'follow':
      return FollowNotificationToJSON(value);
    case 'listen_streak_reminder':
      return ListenStreakReminderNotificationToJSON(value);
    case 'milestone':
      return MilestoneNotificationToJSON(value);
    case 'reaction':
      return ReactionNotificationToJSON(value);
    case 'remix':
      return RemixNotificationToJSON(value);
    case 'repost':
      return RepostNotificationToJSON(value);
    case 'repost_of_repost':
      return RepostOfRepostNotificationToJSON(value);
    case 'request_manager':
      return RequestManagerNotificationToJSON(value);
    case 'save':
      return SaveNotificationToJSON(value);
    case 'save_of_repost':
      return SaveOfRepostNotificationToJSON(value);
    case 'supporter_dethroned':
      return SupporterDethronedNotificationToJSON(value);
    case 'supporter_rank_up':
      return SupporterRankUpNotificationToJSON(value);
    case 'supporting_rank_up':
      return SupporterRankUpNotificationToJSON(value);
    case 'tastemaker':
      return TastemakerNotificationToJSON(value);
    case 'tier_change':
      return TierChangeNotificationToJSON(value);
    case 'tip_receive':
      return ReceiveTipNotificationToJSON(value);
    case 'tip_send':
      return SendTipNotificationToJSON(value);
    case 'track_added_to_playlist':
      return TrackAddedToPlaylistNotificationToJSON(value);
    case 'track_added_to_purchased_album':
      return TrackAddedToPurchasedAlbumNotificationToJSON(value);
    case 'trending':
      return TrendingNotificationToJSON(value);
    case 'trending_playlist':
      return TrendingPlaylistNotificationToJSON(value);
    case 'trending_underground':
      return TrendingUndergroundNotificationToJSON(value);
    case 'usdc_purchase_buyer':
      return UsdcPurchaseBuyerNotificationToJSON(value);
    case 'usdc_purchase_seller':
      return UsdcPurchaseSellerNotificationToJSON(value);
    default:
      throw new Error(`No variant of Notification exists with 'type=${value['type']}'`);
  }
}

/* tslint:disable */
/**
 * Check if a given object implements the Notifications interface.
 */
function instanceOfNotifications(value) {
  let isInstance = true;
  isInstance = isInstance && "unreadCount" in value && value["unreadCount"] !== undefined;
  return isInstance;
}
function NotificationsFromJSON(json) {
  return NotificationsFromJSONTyped(json);
}
function NotificationsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'notifications': !exists(json, 'notifications') ? undefined : json['notifications'].map(NotificationFromJSON),
    'unreadCount': json['unread_count']
  };
}
function NotificationsToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'notifications': value.notifications === undefined ? undefined : value.notifications.map(NotificationToJSON),
    'unread_count': value.unreadCount
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the NotificationsResponse interface.
 */
function instanceOfNotificationsResponse(value) {
  let isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value && value["latestChainBlock"] !== undefined;
  isInstance = isInstance && "latestIndexedBlock" in value && value["latestIndexedBlock"] !== undefined;
  isInstance = isInstance && "latestChainSlotPlays" in value && value["latestChainSlotPlays"] !== undefined;
  isInstance = isInstance && "latestIndexedSlotPlays" in value && value["latestIndexedSlotPlays"] !== undefined;
  isInstance = isInstance && "signature" in value && value["signature"] !== undefined;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== undefined;
  isInstance = isInstance && "version" in value && value["version"] !== undefined;
  return isInstance;
}
function NotificationsResponseFromJSON(json) {
  return NotificationsResponseFromJSONTyped(json);
}
function NotificationsResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : NotificationsFromJSON(json['data'])
  };
}
function NotificationsResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': NotificationsToJSON(value.data)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the PlaylistFeedItem interface.
 */
function instanceOfPlaylistFeedItem(value) {
  let isInstance = true;
  isInstance = isInstance && "type" in value && value["type"] !== undefined;
  isInstance = isInstance && "item" in value && value["item"] !== undefined;
  return isInstance;
}
function PlaylistFeedItemFromJSON(json) {
  return PlaylistFeedItemFromJSONTyped(json);
}
function PlaylistFeedItemFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'type': json['type'],
    'item': PlaylistFullFromJSON(json['item'])
  };
}
function PlaylistFeedItemToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'type': value.type,
    'item': PlaylistFullToJSON(value.item)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the PlaylistUpdate interface.
 */
function instanceOfPlaylistUpdate(value) {
  let isInstance = true;
  isInstance = isInstance && "playlistId" in value && value["playlistId"] !== undefined;
  isInstance = isInstance && "updatedAt" in value && value["updatedAt"] !== undefined;
  return isInstance;
}
function PlaylistUpdateFromJSON(json) {
  return PlaylistUpdateFromJSONTyped(json);
}
function PlaylistUpdateFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'playlistId': json['playlist_id'],
    'updatedAt': json['updated_at'],
    'lastSeenAt': !exists(json, 'last_seen_at') ? undefined : json['last_seen_at']
  };
}
function PlaylistUpdateToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'playlist_id': value.playlistId,
    'updated_at': value.updatedAt,
    'last_seen_at': value.lastSeenAt
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the PlaylistUpdates interface.
 */
function instanceOfPlaylistUpdates(value) {
  let isInstance = true;
  return isInstance;
}
function PlaylistUpdatesFromJSON(json) {
  return PlaylistUpdatesFromJSONTyped(json);
}
function PlaylistUpdatesFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'playlistUpdates': !exists(json, 'playlist_updates') ? undefined : json['playlist_updates'].map(PlaylistUpdateFromJSON)
  };
}
function PlaylistUpdatesToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'playlist_updates': value.playlistUpdates === undefined ? undefined : value.playlistUpdates.map(PlaylistUpdateToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the PlaylistUpdatesResponse interface.
 */
function instanceOfPlaylistUpdatesResponse(value) {
  let isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value && value["latestChainBlock"] !== undefined;
  isInstance = isInstance && "latestIndexedBlock" in value && value["latestIndexedBlock"] !== undefined;
  isInstance = isInstance && "latestChainSlotPlays" in value && value["latestChainSlotPlays"] !== undefined;
  isInstance = isInstance && "latestIndexedSlotPlays" in value && value["latestIndexedSlotPlays"] !== undefined;
  isInstance = isInstance && "signature" in value && value["signature"] !== undefined;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== undefined;
  isInstance = isInstance && "version" in value && value["version"] !== undefined;
  return isInstance;
}
function PlaylistUpdatesResponseFromJSON(json) {
  return PlaylistUpdatesResponseFromJSONTyped(json);
}
function PlaylistUpdatesResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : PlaylistUpdatesFromJSON(json['data'])
  };
}
function PlaylistUpdatesResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': PlaylistUpdatesToJSON(value.data)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the PlaylistsResponseFull interface.
 */
function instanceOfPlaylistsResponseFull(value) {
  let isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value && value["latestChainBlock"] !== undefined;
  isInstance = isInstance && "latestIndexedBlock" in value && value["latestIndexedBlock"] !== undefined;
  isInstance = isInstance && "latestChainSlotPlays" in value && value["latestChainSlotPlays"] !== undefined;
  isInstance = isInstance && "latestIndexedSlotPlays" in value && value["latestIndexedSlotPlays"] !== undefined;
  isInstance = isInstance && "signature" in value && value["signature"] !== undefined;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== undefined;
  isInstance = isInstance && "version" in value && value["version"] !== undefined;
  return isInstance;
}
function PlaylistsResponseFullFromJSON(json) {
  return PlaylistsResponseFullFromJSONTyped(json);
}
function PlaylistsResponseFullFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : json['data'].map(PlaylistFullWithoutTracksFromJSON)
  };
}
function PlaylistsResponseFullToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': value.data === undefined ? undefined : value.data.map(PlaylistFullWithoutTracksToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the PurchaseSplit interface.
 */
function instanceOfPurchaseSplit(value) {
  let isInstance = true;
  isInstance = isInstance && "payoutWallet" in value && value["payoutWallet"] !== undefined;
  isInstance = isInstance && "amount" in value && value["amount"] !== undefined;
  return isInstance;
}
function PurchaseSplitFromJSON(json) {
  return PurchaseSplitFromJSONTyped(json);
}
function PurchaseSplitFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'userId': !exists(json, 'user_id') ? undefined : json['user_id'],
    'payoutWallet': json['payout_wallet'],
    'amount': json['amount']
  };
}
function PurchaseSplitToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'user_id': value.userId,
    'payout_wallet': value.payoutWallet,
    'amount': value.amount
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the Purchase interface.
 */
function instanceOfPurchase(value) {
  let isInstance = true;
  isInstance = isInstance && "slot" in value && value["slot"] !== undefined;
  isInstance = isInstance && "signature" in value && value["signature"] !== undefined;
  isInstance = isInstance && "sellerUserId" in value && value["sellerUserId"] !== undefined;
  isInstance = isInstance && "buyerUserId" in value && value["buyerUserId"] !== undefined;
  isInstance = isInstance && "amount" in value && value["amount"] !== undefined;
  isInstance = isInstance && "extraAmount" in value && value["extraAmount"] !== undefined;
  isInstance = isInstance && "contentType" in value && value["contentType"] !== undefined;
  isInstance = isInstance && "contentId" in value && value["contentId"] !== undefined;
  isInstance = isInstance && "createdAt" in value && value["createdAt"] !== undefined;
  isInstance = isInstance && "updatedAt" in value && value["updatedAt"] !== undefined;
  isInstance = isInstance && "access" in value && value["access"] !== undefined;
  isInstance = isInstance && "splits" in value && value["splits"] !== undefined;
  return isInstance;
}
function PurchaseFromJSON(json) {
  return PurchaseFromJSONTyped(json);
}
function PurchaseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'slot': json['slot'],
    'signature': json['signature'],
    'sellerUserId': json['seller_user_id'],
    'buyerUserId': json['buyer_user_id'],
    'amount': json['amount'],
    'extraAmount': json['extra_amount'],
    'contentType': json['content_type'],
    'contentId': json['content_id'],
    'createdAt': json['created_at'],
    'updatedAt': json['updated_at'],
    'access': json['access'],
    'splits': json['splits'].map(PurchaseSplitFromJSON)
  };
}
function PurchaseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'slot': value.slot,
    'signature': value.signature,
    'seller_user_id': value.sellerUserId,
    'buyer_user_id': value.buyerUserId,
    'amount': value.amount,
    'extra_amount': value.extraAmount,
    'content_type': value.contentType,
    'content_id': value.contentId,
    'created_at': value.createdAt,
    'updated_at': value.updatedAt,
    'access': value.access,
    'splits': value.splits.map(PurchaseSplitToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the PurchasersCountResponse interface.
 */
function instanceOfPurchasersCountResponse(value) {
  let isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value && value["latestChainBlock"] !== undefined;
  isInstance = isInstance && "latestIndexedBlock" in value && value["latestIndexedBlock"] !== undefined;
  isInstance = isInstance && "latestChainSlotPlays" in value && value["latestChainSlotPlays"] !== undefined;
  isInstance = isInstance && "latestIndexedSlotPlays" in value && value["latestIndexedSlotPlays"] !== undefined;
  isInstance = isInstance && "signature" in value && value["signature"] !== undefined;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== undefined;
  isInstance = isInstance && "version" in value && value["version"] !== undefined;
  return isInstance;
}
function PurchasersCountResponseFromJSON(json) {
  return PurchasersCountResponseFromJSONTyped(json);
}
function PurchasersCountResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : json['data']
  };
}
function PurchasersCountResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': value.data
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the PurchasesCountResponse interface.
 */
function instanceOfPurchasesCountResponse(value) {
  let isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value && value["latestChainBlock"] !== undefined;
  isInstance = isInstance && "latestIndexedBlock" in value && value["latestIndexedBlock"] !== undefined;
  isInstance = isInstance && "latestChainSlotPlays" in value && value["latestChainSlotPlays"] !== undefined;
  isInstance = isInstance && "latestIndexedSlotPlays" in value && value["latestIndexedSlotPlays"] !== undefined;
  isInstance = isInstance && "signature" in value && value["signature"] !== undefined;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== undefined;
  isInstance = isInstance && "version" in value && value["version"] !== undefined;
  return isInstance;
}
function PurchasesCountResponseFromJSON(json) {
  return PurchasesCountResponseFromJSONTyped(json);
}
function PurchasesCountResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : json['data']
  };
}
function PurchasesCountResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': value.data
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the PurchasesResponse interface.
 */
function instanceOfPurchasesResponse(value) {
  let isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value && value["latestChainBlock"] !== undefined;
  isInstance = isInstance && "latestIndexedBlock" in value && value["latestIndexedBlock"] !== undefined;
  isInstance = isInstance && "latestChainSlotPlays" in value && value["latestChainSlotPlays"] !== undefined;
  isInstance = isInstance && "latestIndexedSlotPlays" in value && value["latestIndexedSlotPlays"] !== undefined;
  isInstance = isInstance && "signature" in value && value["signature"] !== undefined;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== undefined;
  isInstance = isInstance && "version" in value && value["version"] !== undefined;
  return isInstance;
}
function PurchasesResponseFromJSON(json) {
  return PurchasesResponseFromJSONTyped(json);
}
function PurchasesResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : json['data'].map(PurchaseFromJSON)
  };
}
function PurchasesResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': value.data === undefined ? undefined : value.data.map(PurchaseToJSON)
  };
}

/* tslint:disable */
/* eslint-disable */
// @ts-nocheck
/**
 * API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * Check if a given object implements the Reaction interface.
 */
function instanceOfReaction(value) {
  let isInstance = true;
  isInstance = isInstance && "reactionValue" in value && value["reactionValue"] !== undefined;
  isInstance = isInstance && "reactionType" in value && value["reactionType"] !== undefined;
  isInstance = isInstance && "senderUserId" in value && value["senderUserId"] !== undefined;
  isInstance = isInstance && "reactedTo" in value && value["reactedTo"] !== undefined;
  return isInstance;
}
function ReactionFromJSON(json) {
  return ReactionFromJSONTyped(json);
}
function ReactionFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'reactionValue': json['reaction_value'],
    'reactionType': json['reaction_type'],
    'senderUserId': json['sender_user_id'],
    'reactedTo': json['reacted_to']
  };
}
function ReactionToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'reaction_value': value.reactionValue,
    'reaction_type': value.reactionType,
    'sender_user_id': value.senderUserId,
    'reacted_to': value.reactedTo
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the Reactions interface.
 */
function instanceOfReactions(value) {
  let isInstance = true;
  return isInstance;
}
function ReactionsFromJSON(json) {
  return ReactionsFromJSONTyped(json);
}
function ReactionsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'data': !exists(json, 'data') ? undefined : json['data'].map(ReactionFromJSON)
  };
}
function ReactionsToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'data': value.data === undefined ? undefined : value.data.map(ReactionToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the RelatedArtistResponseFull interface.
 */
function instanceOfRelatedArtistResponseFull(value) {
  let isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value && value["latestChainBlock"] !== undefined;
  isInstance = isInstance && "latestIndexedBlock" in value && value["latestIndexedBlock"] !== undefined;
  isInstance = isInstance && "latestChainSlotPlays" in value && value["latestChainSlotPlays"] !== undefined;
  isInstance = isInstance && "latestIndexedSlotPlays" in value && value["latestIndexedSlotPlays"] !== undefined;
  isInstance = isInstance && "signature" in value && value["signature"] !== undefined;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== undefined;
  isInstance = isInstance && "version" in value && value["version"] !== undefined;
  return isInstance;
}
function RelatedArtistResponseFullFromJSON(json) {
  return RelatedArtistResponseFullFromJSONTyped(json);
}
function RelatedArtistResponseFullFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : json['data'].map(UserFullFromJSON)
  };
}
function RelatedArtistResponseFullToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': value.data === undefined ? undefined : value.data.map(UserFullToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the RemixablesResponse interface.
 */
function instanceOfRemixablesResponse(value) {
  let isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value && value["latestChainBlock"] !== undefined;
  isInstance = isInstance && "latestIndexedBlock" in value && value["latestIndexedBlock"] !== undefined;
  isInstance = isInstance && "latestChainSlotPlays" in value && value["latestChainSlotPlays"] !== undefined;
  isInstance = isInstance && "latestIndexedSlotPlays" in value && value["latestIndexedSlotPlays"] !== undefined;
  isInstance = isInstance && "signature" in value && value["signature"] !== undefined;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== undefined;
  isInstance = isInstance && "version" in value && value["version"] !== undefined;
  return isInstance;
}
function RemixablesResponseFromJSON(json) {
  return RemixablesResponseFromJSONTyped(json);
}
function RemixablesResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : json['data'].map(TrackFullFromJSON)
  };
}
function RemixablesResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': value.data === undefined ? undefined : value.data.map(TrackFullToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the RemixersCountResponse interface.
 */
function instanceOfRemixersCountResponse(value) {
  let isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value && value["latestChainBlock"] !== undefined;
  isInstance = isInstance && "latestIndexedBlock" in value && value["latestIndexedBlock"] !== undefined;
  isInstance = isInstance && "latestChainSlotPlays" in value && value["latestChainSlotPlays"] !== undefined;
  isInstance = isInstance && "latestIndexedSlotPlays" in value && value["latestIndexedSlotPlays"] !== undefined;
  isInstance = isInstance && "signature" in value && value["signature"] !== undefined;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== undefined;
  isInstance = isInstance && "version" in value && value["version"] !== undefined;
  return isInstance;
}
function RemixersCountResponseFromJSON(json) {
  return RemixersCountResponseFromJSONTyped(json);
}
function RemixersCountResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : json['data']
  };
}
function RemixersCountResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': value.data
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the RemixesResponse interface.
 */
function instanceOfRemixesResponse(value) {
  let isInstance = true;
  isInstance = isInstance && "count" in value && value["count"] !== undefined;
  return isInstance;
}
function RemixesResponseFromJSON(json) {
  return RemixesResponseFromJSONTyped(json);
}
function RemixesResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'count': json['count'],
    'tracks': !exists(json, 'tracks') ? undefined : json['tracks'].map(TrackFullFromJSON)
  };
}
function RemixesResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'count': value.count,
    'tracks': value.tracks === undefined ? undefined : value.tracks.map(TrackFullToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the RemixesResponseFull interface.
 */
function instanceOfRemixesResponseFull(value) {
  let isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value && value["latestChainBlock"] !== undefined;
  isInstance = isInstance && "latestIndexedBlock" in value && value["latestIndexedBlock"] !== undefined;
  isInstance = isInstance && "latestChainSlotPlays" in value && value["latestChainSlotPlays"] !== undefined;
  isInstance = isInstance && "latestIndexedSlotPlays" in value && value["latestIndexedSlotPlays"] !== undefined;
  isInstance = isInstance && "signature" in value && value["signature"] !== undefined;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== undefined;
  isInstance = isInstance && "version" in value && value["version"] !== undefined;
  return isInstance;
}
function RemixesResponseFullFromJSON(json) {
  return RemixesResponseFullFromJSONTyped(json);
}
function RemixesResponseFullFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : RemixesResponseFromJSON(json['data'])
  };
}
function RemixesResponseFullToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': RemixesResponseToJSON(value.data)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the RemixingResponse interface.
 */
function instanceOfRemixingResponse(value) {
  let isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value && value["latestChainBlock"] !== undefined;
  isInstance = isInstance && "latestIndexedBlock" in value && value["latestIndexedBlock"] !== undefined;
  isInstance = isInstance && "latestChainSlotPlays" in value && value["latestChainSlotPlays"] !== undefined;
  isInstance = isInstance && "latestIndexedSlotPlays" in value && value["latestIndexedSlotPlays"] !== undefined;
  isInstance = isInstance && "signature" in value && value["signature"] !== undefined;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== undefined;
  isInstance = isInstance && "version" in value && value["version"] !== undefined;
  return isInstance;
}
function RemixingResponseFromJSON(json) {
  return RemixingResponseFromJSONTyped(json);
}
function RemixingResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : json['data'].map(TrackFullFromJSON)
  };
}
function RemixingResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': value.data === undefined ? undefined : value.data.map(TrackFullToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the SearchPlaylistFull interface.
 */
function instanceOfSearchPlaylistFull(value) {
  let isInstance = true;
  isInstance = isInstance && "permalink" in value && value["permalink"] !== undefined;
  isInstance = isInstance && "id" in value && value["id"] !== undefined;
  isInstance = isInstance && "isAlbum" in value && value["isAlbum"] !== undefined;
  isInstance = isInstance && "isImageAutogenerated" in value && value["isImageAutogenerated"] !== undefined;
  isInstance = isInstance && "playlistName" in value && value["playlistName"] !== undefined;
  isInstance = isInstance && "playlistContents" in value && value["playlistContents"] !== undefined;
  isInstance = isInstance && "repostCount" in value && value["repostCount"] !== undefined;
  isInstance = isInstance && "favoriteCount" in value && value["favoriteCount"] !== undefined;
  isInstance = isInstance && "totalPlayCount" in value && value["totalPlayCount"] !== undefined;
  isInstance = isInstance && "user" in value && value["user"] !== undefined;
  isInstance = isInstance && "access" in value && value["access"] !== undefined;
  isInstance = isInstance && "trackCount" in value && value["trackCount"] !== undefined;
  isInstance = isInstance && "blocknumber" in value && value["blocknumber"] !== undefined;
  isInstance = isInstance && "createdAt" in value && value["createdAt"] !== undefined;
  isInstance = isInstance && "hasCurrentUserReposted" in value && value["hasCurrentUserReposted"] !== undefined;
  isInstance = isInstance && "hasCurrentUserSaved" in value && value["hasCurrentUserSaved"] !== undefined;
  isInstance = isInstance && "isDelete" in value && value["isDelete"] !== undefined;
  isInstance = isInstance && "isPrivate" in value && value["isPrivate"] !== undefined;
  isInstance = isInstance && "updatedAt" in value && value["updatedAt"] !== undefined;
  isInstance = isInstance && "addedTimestamps" in value && value["addedTimestamps"] !== undefined;
  isInstance = isInstance && "userId" in value && value["userId"] !== undefined;
  isInstance = isInstance && "isStreamGated" in value && value["isStreamGated"] !== undefined;
  isInstance = isInstance && "isScheduledRelease" in value && value["isScheduledRelease"] !== undefined;
  return isInstance;
}
function SearchPlaylistFullFromJSON(json) {
  return SearchPlaylistFullFromJSONTyped(json);
}
function SearchPlaylistFullFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'artwork': !exists(json, 'artwork') ? undefined : PlaylistArtworkFullFromJSON(json['artwork']),
    'description': !exists(json, 'description') ? undefined : json['description'],
    'permalink': json['permalink'],
    'id': json['id'],
    'isAlbum': json['is_album'],
    'isImageAutogenerated': json['is_image_autogenerated'],
    'playlistName': json['playlist_name'],
    'playlistContents': json['playlist_contents'].map(PlaylistAddedTimestampFromJSON),
    'repostCount': json['repost_count'],
    'favoriteCount': json['favorite_count'],
    'totalPlayCount': json['total_play_count'],
    'user': UserFullFromJSON(json['user']),
    'ddexApp': !exists(json, 'ddex_app') ? undefined : json['ddex_app'],
    'access': AccessFromJSON(json['access']),
    'upc': !exists(json, 'upc') ? undefined : json['upc'],
    'trackCount': json['track_count'],
    'blocknumber': json['blocknumber'],
    'createdAt': json['created_at'],
    'followeeReposts': !exists(json, 'followee_reposts') ? undefined : json['followee_reposts'].map(RepostFromJSON),
    'followeeFavorites': !exists(json, 'followee_favorites') ? undefined : json['followee_favorites'].map(FavoriteFromJSON),
    'hasCurrentUserReposted': json['has_current_user_reposted'],
    'hasCurrentUserSaved': json['has_current_user_saved'],
    'isDelete': json['is_delete'],
    'isPrivate': json['is_private'],
    'updatedAt': json['updated_at'],
    'addedTimestamps': json['added_timestamps'].map(PlaylistAddedTimestampFromJSON),
    'userId': json['user_id'],
    'tracks': !exists(json, 'tracks') ? undefined : json['tracks'].map(TrackFullFromJSON),
    'coverArt': !exists(json, 'cover_art') ? undefined : json['cover_art'],
    'coverArtSizes': !exists(json, 'cover_art_sizes') ? undefined : json['cover_art_sizes'],
    'coverArtCids': !exists(json, 'cover_art_cids') ? undefined : PlaylistArtworkFromJSON(json['cover_art_cids']),
    'isStreamGated': json['is_stream_gated'],
    'streamConditions': !exists(json, 'stream_conditions') ? undefined : AccessGateFromJSON(json['stream_conditions']),
    'isScheduledRelease': json['is_scheduled_release'],
    'releaseDate': !exists(json, 'release_date') ? undefined : json['release_date'],
    'ddexReleaseIds': !exists(json, 'ddex_release_ids') ? undefined : json['ddex_release_ids'],
    'artists': !exists(json, 'artists') ? undefined : json['artists'],
    'copyrightLine': !exists(json, 'copyright_line') ? undefined : json['copyright_line'],
    'producerCopyrightLine': !exists(json, 'producer_copyright_line') ? undefined : json['producer_copyright_line'],
    'parentalWarningType': !exists(json, 'parental_warning_type') ? undefined : json['parental_warning_type']
  };
}
function SearchPlaylistFullToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'artwork': PlaylistArtworkFullToJSON(value.artwork),
    'description': value.description,
    'permalink': value.permalink,
    'id': value.id,
    'is_album': value.isAlbum,
    'is_image_autogenerated': value.isImageAutogenerated,
    'playlist_name': value.playlistName,
    'playlist_contents': value.playlistContents.map(PlaylistAddedTimestampToJSON),
    'repost_count': value.repostCount,
    'favorite_count': value.favoriteCount,
    'total_play_count': value.totalPlayCount,
    'user': UserFullToJSON(value.user),
    'ddex_app': value.ddexApp,
    'access': AccessToJSON(value.access),
    'upc': value.upc,
    'track_count': value.trackCount,
    'blocknumber': value.blocknumber,
    'created_at': value.createdAt,
    'followee_reposts': value.followeeReposts === undefined ? undefined : value.followeeReposts.map(RepostToJSON),
    'followee_favorites': value.followeeFavorites === undefined ? undefined : value.followeeFavorites.map(FavoriteToJSON),
    'has_current_user_reposted': value.hasCurrentUserReposted,
    'has_current_user_saved': value.hasCurrentUserSaved,
    'is_delete': value.isDelete,
    'is_private': value.isPrivate,
    'updated_at': value.updatedAt,
    'added_timestamps': value.addedTimestamps.map(PlaylistAddedTimestampToJSON),
    'user_id': value.userId,
    'tracks': value.tracks === undefined ? undefined : value.tracks.map(TrackFullToJSON),
    'cover_art': value.coverArt,
    'cover_art_sizes': value.coverArtSizes,
    'cover_art_cids': PlaylistArtworkToJSON(value.coverArtCids),
    'is_stream_gated': value.isStreamGated,
    'stream_conditions': AccessGateToJSON(value.streamConditions),
    'is_scheduled_release': value.isScheduledRelease,
    'release_date': value.releaseDate,
    'ddex_release_ids': value.ddexReleaseIds,
    'artists': value.artists,
    'copyright_line': value.copyrightLine,
    'producer_copyright_line': value.producerCopyrightLine,
    'parental_warning_type': value.parentalWarningType
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the SearchTrackFull interface.
 */
function instanceOfSearchTrackFull(value) {
  let isInstance = true;
  isInstance = isInstance && "artwork" in value && value["artwork"] !== undefined;
  isInstance = isInstance && "genre" in value && value["genre"] !== undefined;
  isInstance = isInstance && "id" in value && value["id"] !== undefined;
  isInstance = isInstance && "isOriginalAvailable" in value && value["isOriginalAvailable"] !== undefined;
  isInstance = isInstance && "remixOf" in value && value["remixOf"] !== undefined;
  isInstance = isInstance && "repostCount" in value && value["repostCount"] !== undefined;
  isInstance = isInstance && "favoriteCount" in value && value["favoriteCount"] !== undefined;
  isInstance = isInstance && "commentCount" in value && value["commentCount"] !== undefined;
  isInstance = isInstance && "title" in value && value["title"] !== undefined;
  isInstance = isInstance && "user" in value && value["user"] !== undefined;
  isInstance = isInstance && "duration" in value && value["duration"] !== undefined;
  isInstance = isInstance && "isDownloadable" in value && value["isDownloadable"] !== undefined;
  isInstance = isInstance && "playCount" in value && value["playCount"] !== undefined;
  isInstance = isInstance && "permalink" in value && value["permalink"] !== undefined;
  isInstance = isInstance && "access" in value && value["access"] !== undefined;
  isInstance = isInstance && "blocknumber" in value && value["blocknumber"] !== undefined;
  isInstance = isInstance && "coverArtSizes" in value && value["coverArtSizes"] !== undefined;
  isInstance = isInstance && "createdAt" in value && value["createdAt"] !== undefined;
  isInstance = isInstance && "fieldVisibility" in value && value["fieldVisibility"] !== undefined;
  isInstance = isInstance && "hasCurrentUserReposted" in value && value["hasCurrentUserReposted"] !== undefined;
  isInstance = isInstance && "isScheduledRelease" in value && value["isScheduledRelease"] !== undefined;
  isInstance = isInstance && "isUnlisted" in value && value["isUnlisted"] !== undefined;
  isInstance = isInstance && "hasCurrentUserSaved" in value && value["hasCurrentUserSaved"] !== undefined;
  isInstance = isInstance && "routeId" in value && value["routeId"] !== undefined;
  isInstance = isInstance && "trackSegments" in value && value["trackSegments"] !== undefined;
  isInstance = isInstance && "updatedAt" in value && value["updatedAt"] !== undefined;
  isInstance = isInstance && "userId" in value && value["userId"] !== undefined;
  isInstance = isInstance && "isDelete" in value && value["isDelete"] !== undefined;
  isInstance = isInstance && "isAvailable" in value && value["isAvailable"] !== undefined;
  isInstance = isInstance && "isStreamGated" in value && value["isStreamGated"] !== undefined;
  isInstance = isInstance && "isDownloadGated" in value && value["isDownloadGated"] !== undefined;
  isInstance = isInstance && "isOwnedByUser" in value && value["isOwnedByUser"] !== undefined;
  isInstance = isInstance && "stream" in value && value["stream"] !== undefined;
  isInstance = isInstance && "download" in value && value["download"] !== undefined;
  isInstance = isInstance && "preview" in value && value["preview"] !== undefined;
  return isInstance;
}
function SearchTrackFullFromJSON(json) {
  return SearchTrackFullFromJSONTyped(json);
}
function SearchTrackFullFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'artwork': TrackArtworkFullFromJSON(json['artwork']),
    'description': !exists(json, 'description') ? undefined : json['description'],
    'genre': json['genre'],
    'id': json['id'],
    'trackCid': !exists(json, 'track_cid') ? undefined : json['track_cid'],
    'previewCid': !exists(json, 'preview_cid') ? undefined : json['preview_cid'],
    'origFileCid': !exists(json, 'orig_file_cid') ? undefined : json['orig_file_cid'],
    'origFilename': !exists(json, 'orig_filename') ? undefined : json['orig_filename'],
    'isOriginalAvailable': json['is_original_available'],
    'mood': !exists(json, 'mood') ? undefined : json['mood'],
    'releaseDate': !exists(json, 'release_date') ? undefined : json['release_date'],
    'remixOf': FullRemixParentFromJSON(json['remix_of']),
    'repostCount': json['repost_count'],
    'favoriteCount': json['favorite_count'],
    'commentCount': json['comment_count'],
    'tags': !exists(json, 'tags') ? undefined : json['tags'],
    'title': json['title'],
    'user': UserFullFromJSON(json['user']),
    'duration': json['duration'],
    'isDownloadable': json['is_downloadable'],
    'playCount': json['play_count'],
    'permalink': json['permalink'],
    'isStreamable': !exists(json, 'is_streamable') ? undefined : json['is_streamable'],
    'ddexApp': !exists(json, 'ddex_app') ? undefined : json['ddex_app'],
    'playlistsContainingTrack': !exists(json, 'playlists_containing_track') ? undefined : json['playlists_containing_track'],
    'pinnedCommentId': !exists(json, 'pinned_comment_id') ? undefined : json['pinned_comment_id'],
    'albumBacklink': !exists(json, 'album_backlink') ? undefined : AlbumBacklinkFromJSON(json['album_backlink']),
    'access': AccessFromJSON(json['access']),
    'blocknumber': json['blocknumber'],
    'createDate': !exists(json, 'create_date') ? undefined : json['create_date'],
    'coverArtSizes': json['cover_art_sizes'],
    'coverArtCids': !exists(json, 'cover_art_cids') ? undefined : CoverArtFromJSON(json['cover_art_cids']),
    'createdAt': json['created_at'],
    'creditsSplits': !exists(json, 'credits_splits') ? undefined : json['credits_splits'],
    'isrc': !exists(json, 'isrc') ? undefined : json['isrc'],
    'license': !exists(json, 'license') ? undefined : json['license'],
    'iswc': !exists(json, 'iswc') ? undefined : json['iswc'],
    'fieldVisibility': FieldVisibilityFromJSON(json['field_visibility']),
    'followeeReposts': !exists(json, 'followee_reposts') ? undefined : json['followee_reposts'].map(RepostFromJSON),
    'hasCurrentUserReposted': json['has_current_user_reposted'],
    'isScheduledRelease': json['is_scheduled_release'],
    'isUnlisted': json['is_unlisted'],
    'hasCurrentUserSaved': json['has_current_user_saved'],
    'followeeFavorites': !exists(json, 'followee_favorites') ? undefined : json['followee_favorites'].map(FavoriteFromJSON),
    'routeId': json['route_id'],
    'stemOf': !exists(json, 'stem_of') ? undefined : StemParentFromJSON(json['stem_of']),
    'trackSegments': json['track_segments'].map(TrackSegmentFromJSON),
    'updatedAt': json['updated_at'],
    'userId': json['user_id'],
    'isDelete': json['is_delete'],
    'coverArt': !exists(json, 'cover_art') ? undefined : json['cover_art'],
    'isAvailable': json['is_available'],
    'aiAttributionUserId': !exists(json, 'ai_attribution_user_id') ? undefined : json['ai_attribution_user_id'],
    'allowedApiKeys': !exists(json, 'allowed_api_keys') ? undefined : json['allowed_api_keys'],
    'audioUploadId': !exists(json, 'audio_upload_id') ? undefined : json['audio_upload_id'],
    'previewStartSeconds': !exists(json, 'preview_start_seconds') ? undefined : json['preview_start_seconds'],
    'bpm': !exists(json, 'bpm') ? undefined : json['bpm'],
    'isCustomBpm': !exists(json, 'is_custom_bpm') ? undefined : json['is_custom_bpm'],
    'musicalKey': !exists(json, 'musical_key') ? undefined : json['musical_key'],
    'isCustomMusicalKey': !exists(json, 'is_custom_musical_key') ? undefined : json['is_custom_musical_key'],
    'audioAnalysisErrorCount': !exists(json, 'audio_analysis_error_count') ? undefined : json['audio_analysis_error_count'],
    'commentsDisabled': !exists(json, 'comments_disabled') ? undefined : json['comments_disabled'],
    'ddexReleaseIds': !exists(json, 'ddex_release_ids') ? undefined : json['ddex_release_ids'],
    'artists': !exists(json, 'artists') ? undefined : json['artists'],
    'resourceContributors': !exists(json, 'resource_contributors') ? undefined : json['resource_contributors'],
    'indirectResourceContributors': !exists(json, 'indirect_resource_contributors') ? undefined : json['indirect_resource_contributors'],
    'rightsController': !exists(json, 'rights_controller') ? undefined : json['rights_controller'],
    'copyrightLine': !exists(json, 'copyright_line') ? undefined : json['copyright_line'],
    'producerCopyrightLine': !exists(json, 'producer_copyright_line') ? undefined : json['producer_copyright_line'],
    'parentalWarningType': !exists(json, 'parental_warning_type') ? undefined : json['parental_warning_type'],
    'isStreamGated': json['is_stream_gated'],
    'streamConditions': !exists(json, 'stream_conditions') ? undefined : AccessGateFromJSON(json['stream_conditions']),
    'isDownloadGated': json['is_download_gated'],
    'downloadConditions': !exists(json, 'download_conditions') ? undefined : AccessGateFromJSON(json['download_conditions']),
    'coverOriginalSongTitle': !exists(json, 'cover_original_song_title') ? undefined : json['cover_original_song_title'],
    'coverOriginalArtist': !exists(json, 'cover_original_artist') ? undefined : json['cover_original_artist'],
    'isOwnedByUser': json['is_owned_by_user'],
    'stream': UrlWithMirrorsFromJSON(json['stream']),
    'download': UrlWithMirrorsFromJSON(json['download']),
    'preview': UrlWithMirrorsFromJSON(json['preview'])
  };
}
function SearchTrackFullToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'artwork': TrackArtworkFullToJSON(value.artwork),
    'description': value.description,
    'genre': value.genre,
    'id': value.id,
    'track_cid': value.trackCid,
    'preview_cid': value.previewCid,
    'orig_file_cid': value.origFileCid,
    'orig_filename': value.origFilename,
    'is_original_available': value.isOriginalAvailable,
    'mood': value.mood,
    'release_date': value.releaseDate,
    'remix_of': FullRemixParentToJSON(value.remixOf),
    'repost_count': value.repostCount,
    'favorite_count': value.favoriteCount,
    'comment_count': value.commentCount,
    'tags': value.tags,
    'title': value.title,
    'user': UserFullToJSON(value.user),
    'duration': value.duration,
    'is_downloadable': value.isDownloadable,
    'play_count': value.playCount,
    'permalink': value.permalink,
    'is_streamable': value.isStreamable,
    'ddex_app': value.ddexApp,
    'playlists_containing_track': value.playlistsContainingTrack,
    'pinned_comment_id': value.pinnedCommentId,
    'album_backlink': AlbumBacklinkToJSON(value.albumBacklink),
    'access': AccessToJSON(value.access),
    'blocknumber': value.blocknumber,
    'create_date': value.createDate,
    'cover_art_sizes': value.coverArtSizes,
    'cover_art_cids': CoverArtToJSON(value.coverArtCids),
    'created_at': value.createdAt,
    'credits_splits': value.creditsSplits,
    'isrc': value.isrc,
    'license': value.license,
    'iswc': value.iswc,
    'field_visibility': FieldVisibilityToJSON(value.fieldVisibility),
    'followee_reposts': value.followeeReposts === undefined ? undefined : value.followeeReposts.map(RepostToJSON),
    'has_current_user_reposted': value.hasCurrentUserReposted,
    'is_scheduled_release': value.isScheduledRelease,
    'is_unlisted': value.isUnlisted,
    'has_current_user_saved': value.hasCurrentUserSaved,
    'followee_favorites': value.followeeFavorites === undefined ? undefined : value.followeeFavorites.map(FavoriteToJSON),
    'route_id': value.routeId,
    'stem_of': StemParentToJSON(value.stemOf),
    'track_segments': value.trackSegments.map(TrackSegmentToJSON),
    'updated_at': value.updatedAt,
    'user_id': value.userId,
    'is_delete': value.isDelete,
    'cover_art': value.coverArt,
    'is_available': value.isAvailable,
    'ai_attribution_user_id': value.aiAttributionUserId,
    'allowed_api_keys': value.allowedApiKeys,
    'audio_upload_id': value.audioUploadId,
    'preview_start_seconds': value.previewStartSeconds,
    'bpm': value.bpm,
    'is_custom_bpm': value.isCustomBpm,
    'musical_key': value.musicalKey,
    'is_custom_musical_key': value.isCustomMusicalKey,
    'audio_analysis_error_count': value.audioAnalysisErrorCount,
    'comments_disabled': value.commentsDisabled,
    'ddex_release_ids': value.ddexReleaseIds,
    'artists': value.artists,
    'resource_contributors': value.resourceContributors,
    'indirect_resource_contributors': value.indirectResourceContributors,
    'rights_controller': value.rightsController,
    'copyright_line': value.copyrightLine,
    'producer_copyright_line': value.producerCopyrightLine,
    'parental_warning_type': value.parentalWarningType,
    'is_stream_gated': value.isStreamGated,
    'stream_conditions': AccessGateToJSON(value.streamConditions),
    'is_download_gated': value.isDownloadGated,
    'download_conditions': AccessGateToJSON(value.downloadConditions),
    'cover_original_song_title': value.coverOriginalSongTitle,
    'cover_original_artist': value.coverOriginalArtist,
    'is_owned_by_user': value.isOwnedByUser,
    'stream': UrlWithMirrorsToJSON(value.stream),
    'download': UrlWithMirrorsToJSON(value.download),
    'preview': UrlWithMirrorsToJSON(value.preview)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the SearchModel interface.
 */
function instanceOfSearchModel(value) {
  let isInstance = true;
  isInstance = isInstance && "users" in value && value["users"] !== undefined;
  isInstance = isInstance && "tracks" in value && value["tracks"] !== undefined;
  isInstance = isInstance && "playlists" in value && value["playlists"] !== undefined;
  isInstance = isInstance && "albums" in value && value["albums"] !== undefined;
  return isInstance;
}
function SearchModelFromJSON(json) {
  return SearchModelFromJSONTyped(json);
}
function SearchModelFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'users': json['users'].map(UserFullFromJSON),
    'followedUsers': !exists(json, 'followed_users') ? undefined : json['followed_users'].map(UserFullFromJSON),
    'tracks': json['tracks'].map(SearchTrackFullFromJSON),
    'savedTracks': !exists(json, 'saved_tracks') ? undefined : json['saved_tracks'].map(SearchTrackFullFromJSON),
    'playlists': json['playlists'].map(SearchPlaylistFullFromJSON),
    'savedPlaylists': !exists(json, 'saved_playlists') ? undefined : json['saved_playlists'].map(SearchPlaylistFullFromJSON),
    'albums': json['albums'].map(SearchPlaylistFullFromJSON),
    'savedAlbums': !exists(json, 'saved_albums') ? undefined : json['saved_albums'].map(SearchPlaylistFullFromJSON)
  };
}
function SearchModelToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'users': value.users.map(UserFullToJSON),
    'followed_users': value.followedUsers === undefined ? undefined : value.followedUsers.map(UserFullToJSON),
    'tracks': value.tracks.map(SearchTrackFullToJSON),
    'saved_tracks': value.savedTracks === undefined ? undefined : value.savedTracks.map(SearchTrackFullToJSON),
    'playlists': value.playlists.map(SearchPlaylistFullToJSON),
    'saved_playlists': value.savedPlaylists === undefined ? undefined : value.savedPlaylists.map(SearchPlaylistFullToJSON),
    'albums': value.albums.map(SearchPlaylistFullToJSON),
    'saved_albums': value.savedAlbums === undefined ? undefined : value.savedAlbums.map(SearchPlaylistFullToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the SearchAutocompleteResponse interface.
 */
function instanceOfSearchAutocompleteResponse(value) {
  let isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value && value["latestChainBlock"] !== undefined;
  isInstance = isInstance && "latestIndexedBlock" in value && value["latestIndexedBlock"] !== undefined;
  isInstance = isInstance && "latestChainSlotPlays" in value && value["latestChainSlotPlays"] !== undefined;
  isInstance = isInstance && "latestIndexedSlotPlays" in value && value["latestIndexedSlotPlays"] !== undefined;
  isInstance = isInstance && "signature" in value && value["signature"] !== undefined;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== undefined;
  isInstance = isInstance && "version" in value && value["version"] !== undefined;
  return isInstance;
}
function SearchAutocompleteResponseFromJSON(json) {
  return SearchAutocompleteResponseFromJSONTyped(json);
}
function SearchAutocompleteResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : SearchModelFromJSON(json['data'])
  };
}
function SearchAutocompleteResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': SearchModelToJSON(value.data)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the SearchFullResponse interface.
 */
function instanceOfSearchFullResponse(value) {
  let isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value && value["latestChainBlock"] !== undefined;
  isInstance = isInstance && "latestIndexedBlock" in value && value["latestIndexedBlock"] !== undefined;
  isInstance = isInstance && "latestChainSlotPlays" in value && value["latestChainSlotPlays"] !== undefined;
  isInstance = isInstance && "latestIndexedSlotPlays" in value && value["latestIndexedSlotPlays"] !== undefined;
  isInstance = isInstance && "signature" in value && value["signature"] !== undefined;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== undefined;
  isInstance = isInstance && "version" in value && value["version"] !== undefined;
  return isInstance;
}
function SearchFullResponseFromJSON(json) {
  return SearchFullResponseFromJSONTyped(json);
}
function SearchFullResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : SearchModelFromJSON(json['data'])
  };
}
function SearchFullResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': SearchModelToJSON(value.data)
  };
}

/* tslint:disable */
/* eslint-disable */
// @ts-nocheck
/**
 * API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * Check if a given object implements the StemFull interface.
 */
function instanceOfStemFull(value) {
  let isInstance = true;
  isInstance = isInstance && "id" in value && value["id"] !== undefined;
  isInstance = isInstance && "parentId" in value && value["parentId"] !== undefined;
  isInstance = isInstance && "category" in value && value["category"] !== undefined;
  isInstance = isInstance && "cid" in value && value["cid"] !== undefined;
  isInstance = isInstance && "userId" in value && value["userId"] !== undefined;
  isInstance = isInstance && "blocknumber" in value && value["blocknumber"] !== undefined;
  isInstance = isInstance && "origFilename" in value && value["origFilename"] !== undefined;
  return isInstance;
}
function StemFullFromJSON(json) {
  return StemFullFromJSONTyped(json);
}
function StemFullFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'id': json['id'],
    'parentId': json['parent_id'],
    'category': json['category'],
    'cid': json['cid'],
    'userId': json['user_id'],
    'blocknumber': json['blocknumber'],
    'origFilename': json['orig_filename']
  };
}
function StemFullToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'id': value.id,
    'parent_id': value.parentId,
    'category': value.category,
    'cid': value.cid,
    'user_id': value.userId,
    'blocknumber': value.blocknumber,
    'orig_filename': value.origFilename
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the StemsResponse interface.
 */
function instanceOfStemsResponse(value) {
  let isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value && value["latestChainBlock"] !== undefined;
  isInstance = isInstance && "latestIndexedBlock" in value && value["latestIndexedBlock"] !== undefined;
  isInstance = isInstance && "latestChainSlotPlays" in value && value["latestChainSlotPlays"] !== undefined;
  isInstance = isInstance && "latestIndexedSlotPlays" in value && value["latestIndexedSlotPlays"] !== undefined;
  isInstance = isInstance && "signature" in value && value["signature"] !== undefined;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== undefined;
  isInstance = isInstance && "version" in value && value["version"] !== undefined;
  return isInstance;
}
function StemsResponseFromJSON(json) {
  return StemsResponseFromJSONTyped(json);
}
function StemsResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : json['data'].map(StemFullFromJSON)
  };
}
function StemsResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': value.data === undefined ? undefined : value.data.map(StemFullToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the TopGenreUsersResponseFull interface.
 */
function instanceOfTopGenreUsersResponseFull(value) {
  let isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value && value["latestChainBlock"] !== undefined;
  isInstance = isInstance && "latestIndexedBlock" in value && value["latestIndexedBlock"] !== undefined;
  isInstance = isInstance && "latestChainSlotPlays" in value && value["latestChainSlotPlays"] !== undefined;
  isInstance = isInstance && "latestIndexedSlotPlays" in value && value["latestIndexedSlotPlays"] !== undefined;
  isInstance = isInstance && "signature" in value && value["signature"] !== undefined;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== undefined;
  isInstance = isInstance && "version" in value && value["version"] !== undefined;
  return isInstance;
}
function TopGenreUsersResponseFullFromJSON(json) {
  return TopGenreUsersResponseFullFromJSONTyped(json);
}
function TopGenreUsersResponseFullFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : json['data'].map(UserFullFromJSON)
  };
}
function TopGenreUsersResponseFullToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': value.data === undefined ? undefined : value.data.map(UserFullToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the TopUsersResponseFull interface.
 */
function instanceOfTopUsersResponseFull(value) {
  let isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value && value["latestChainBlock"] !== undefined;
  isInstance = isInstance && "latestIndexedBlock" in value && value["latestIndexedBlock"] !== undefined;
  isInstance = isInstance && "latestChainSlotPlays" in value && value["latestChainSlotPlays"] !== undefined;
  isInstance = isInstance && "latestIndexedSlotPlays" in value && value["latestIndexedSlotPlays"] !== undefined;
  isInstance = isInstance && "signature" in value && value["signature"] !== undefined;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== undefined;
  isInstance = isInstance && "version" in value && value["version"] !== undefined;
  return isInstance;
}
function TopUsersResponseFullFromJSON(json) {
  return TopUsersResponseFullFromJSONTyped(json);
}
function TopUsersResponseFullFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : json['data'].map(UserFullFromJSON)
  };
}
function TopUsersResponseFullToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': value.data === undefined ? undefined : value.data.map(UserFullToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the TrackCommentsResponseFull interface.
 */
function instanceOfTrackCommentsResponseFull(value) {
  let isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value && value["latestChainBlock"] !== undefined;
  isInstance = isInstance && "latestIndexedBlock" in value && value["latestIndexedBlock"] !== undefined;
  isInstance = isInstance && "latestChainSlotPlays" in value && value["latestChainSlotPlays"] !== undefined;
  isInstance = isInstance && "latestIndexedSlotPlays" in value && value["latestIndexedSlotPlays"] !== undefined;
  isInstance = isInstance && "signature" in value && value["signature"] !== undefined;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== undefined;
  isInstance = isInstance && "version" in value && value["version"] !== undefined;
  return isInstance;
}
function TrackCommentsResponseFullFromJSON(json) {
  return TrackCommentsResponseFullFromJSONTyped(json);
}
function TrackCommentsResponseFullFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : json['data'].map(CommentFromJSON),
    'related': !exists(json, 'related') ? undefined : RelatedFromJSON(json['related'])
  };
}
function TrackCommentsResponseFullToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': value.data === undefined ? undefined : value.data.map(CommentToJSON),
    'related': RelatedToJSON(value.related)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the TrackFavoritesResponseFull interface.
 */
function instanceOfTrackFavoritesResponseFull(value) {
  let isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value && value["latestChainBlock"] !== undefined;
  isInstance = isInstance && "latestIndexedBlock" in value && value["latestIndexedBlock"] !== undefined;
  isInstance = isInstance && "latestChainSlotPlays" in value && value["latestChainSlotPlays"] !== undefined;
  isInstance = isInstance && "latestIndexedSlotPlays" in value && value["latestIndexedSlotPlays"] !== undefined;
  isInstance = isInstance && "signature" in value && value["signature"] !== undefined;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== undefined;
  isInstance = isInstance && "version" in value && value["version"] !== undefined;
  return isInstance;
}
function TrackFavoritesResponseFullFromJSON(json) {
  return TrackFavoritesResponseFullFromJSONTyped(json);
}
function TrackFavoritesResponseFullFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : json['data'].map(UserFullFromJSON)
  };
}
function TrackFavoritesResponseFullToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': value.data === undefined ? undefined : value.data.map(UserFullToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the TrackFeedItem interface.
 */
function instanceOfTrackFeedItem(value) {
  let isInstance = true;
  isInstance = isInstance && "type" in value && value["type"] !== undefined;
  isInstance = isInstance && "item" in value && value["item"] !== undefined;
  return isInstance;
}
function TrackFeedItemFromJSON(json) {
  return TrackFeedItemFromJSONTyped(json);
}
function TrackFeedItemFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'type': json['type'],
    'item': TrackFullFromJSON(json['item'])
  };
}
function TrackFeedItemToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'type': value.type,
    'item': TrackFullToJSON(value.item)
  };
}

/* tslint:disable */
/* eslint-disable */
// @ts-nocheck
/**
 * API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * Check if a given object implements the TrackId interface.
 */
function instanceOfTrackId(value) {
  let isInstance = true;
  isInstance = isInstance && "id" in value && value["id"] !== undefined;
  return isInstance;
}
function TrackIdFromJSON(json) {
  return TrackIdFromJSONTyped(json);
}
function TrackIdFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'id': json['id']
  };
}
function TrackIdToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'id': value.id
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the TrackLibraryResponseFull interface.
 */
function instanceOfTrackLibraryResponseFull(value) {
  let isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value && value["latestChainBlock"] !== undefined;
  isInstance = isInstance && "latestIndexedBlock" in value && value["latestIndexedBlock"] !== undefined;
  isInstance = isInstance && "latestChainSlotPlays" in value && value["latestChainSlotPlays"] !== undefined;
  isInstance = isInstance && "latestIndexedSlotPlays" in value && value["latestIndexedSlotPlays"] !== undefined;
  isInstance = isInstance && "signature" in value && value["signature"] !== undefined;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== undefined;
  isInstance = isInstance && "version" in value && value["version"] !== undefined;
  return isInstance;
}
function TrackLibraryResponseFullFromJSON(json) {
  return TrackLibraryResponseFullFromJSONTyped(json);
}
function TrackLibraryResponseFullFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : json['data'].map(TrackActivityFullFromJSON)
  };
}
function TrackLibraryResponseFullToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': value.data === undefined ? undefined : value.data.map(TrackActivityFullToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the TrackRepostsResponseFull interface.
 */
function instanceOfTrackRepostsResponseFull(value) {
  let isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value && value["latestChainBlock"] !== undefined;
  isInstance = isInstance && "latestIndexedBlock" in value && value["latestIndexedBlock"] !== undefined;
  isInstance = isInstance && "latestChainSlotPlays" in value && value["latestChainSlotPlays"] !== undefined;
  isInstance = isInstance && "latestIndexedSlotPlays" in value && value["latestIndexedSlotPlays"] !== undefined;
  isInstance = isInstance && "signature" in value && value["signature"] !== undefined;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== undefined;
  isInstance = isInstance && "version" in value && value["version"] !== undefined;
  return isInstance;
}
function TrackRepostsResponseFullFromJSON(json) {
  return TrackRepostsResponseFullFromJSONTyped(json);
}
function TrackRepostsResponseFullFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : json['data'].map(UserFullFromJSON)
  };
}
function TrackRepostsResponseFullToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': value.data === undefined ? undefined : value.data.map(UserFullToJSON)
  };
}

/* tslint:disable */
/* eslint-disable */
// @ts-nocheck
/**
 * API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * Check if a given object implements the TransactionDetails interface.
 */
function instanceOfTransactionDetails(value) {
  let isInstance = true;
  isInstance = isInstance && "transactionDate" in value && value["transactionDate"] !== undefined;
  isInstance = isInstance && "transactionType" in value && value["transactionType"] !== undefined;
  isInstance = isInstance && "method" in value && value["method"] !== undefined;
  isInstance = isInstance && "signature" in value && value["signature"] !== undefined;
  isInstance = isInstance && "userBank" in value && value["userBank"] !== undefined;
  isInstance = isInstance && "change" in value && value["change"] !== undefined;
  isInstance = isInstance && "balance" in value && value["balance"] !== undefined;
  isInstance = isInstance && "metadata" in value && value["metadata"] !== undefined;
  return isInstance;
}
function TransactionDetailsFromJSON(json) {
  return TransactionDetailsFromJSONTyped(json);
}
function TransactionDetailsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'transactionDate': json['transaction_date'],
    'transactionType': json['transaction_type'],
    'method': json['method'],
    'signature': json['signature'],
    'userBank': json['user_bank'],
    'change': json['change'],
    'balance': json['balance'],
    'metadata': json['metadata']
  };
}
function TransactionDetailsToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'transaction_date': value.transactionDate,
    'transaction_type': value.transactionType,
    'method': value.method,
    'signature': value.signature,
    'user_bank': value.userBank,
    'change': value.change,
    'balance': value.balance,
    'metadata': value.metadata
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the TransactionHistoryCountResponse interface.
 */
function instanceOfTransactionHistoryCountResponse(value) {
  let isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value && value["latestChainBlock"] !== undefined;
  isInstance = isInstance && "latestIndexedBlock" in value && value["latestIndexedBlock"] !== undefined;
  isInstance = isInstance && "latestChainSlotPlays" in value && value["latestChainSlotPlays"] !== undefined;
  isInstance = isInstance && "latestIndexedSlotPlays" in value && value["latestIndexedSlotPlays"] !== undefined;
  isInstance = isInstance && "signature" in value && value["signature"] !== undefined;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== undefined;
  isInstance = isInstance && "version" in value && value["version"] !== undefined;
  return isInstance;
}
function TransactionHistoryCountResponseFromJSON(json) {
  return TransactionHistoryCountResponseFromJSONTyped(json);
}
function TransactionHistoryCountResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : json['data']
  };
}
function TransactionHistoryCountResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': value.data
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the TransactionHistoryResponse interface.
 */
function instanceOfTransactionHistoryResponse(value) {
  let isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value && value["latestChainBlock"] !== undefined;
  isInstance = isInstance && "latestIndexedBlock" in value && value["latestIndexedBlock"] !== undefined;
  isInstance = isInstance && "latestChainSlotPlays" in value && value["latestChainSlotPlays"] !== undefined;
  isInstance = isInstance && "latestIndexedSlotPlays" in value && value["latestIndexedSlotPlays"] !== undefined;
  isInstance = isInstance && "signature" in value && value["signature"] !== undefined;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== undefined;
  isInstance = isInstance && "version" in value && value["version"] !== undefined;
  return isInstance;
}
function TransactionHistoryResponseFromJSON(json) {
  return TransactionHistoryResponseFromJSONTyped(json);
}
function TransactionHistoryResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : json['data'].map(TransactionDetailsFromJSON)
  };
}
function TransactionHistoryResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': value.data === undefined ? undefined : value.data.map(TransactionDetailsToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the TrendingTimesIds interface.
 */
function instanceOfTrendingTimesIds(value) {
  let isInstance = true;
  return isInstance;
}
function TrendingTimesIdsFromJSON(json) {
  return TrendingTimesIdsFromJSONTyped(json);
}
function TrendingTimesIdsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'week': !exists(json, 'week') ? undefined : json['week'].map(TrackIdFromJSON),
    'month': !exists(json, 'month') ? undefined : json['month'].map(TrackIdFromJSON),
    'year': !exists(json, 'year') ? undefined : json['year'].map(TrackIdFromJSON)
  };
}
function TrendingTimesIdsToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'week': value.week === undefined ? undefined : value.week.map(TrackIdToJSON),
    'month': value.month === undefined ? undefined : value.month.map(TrackIdToJSON),
    'year': value.year === undefined ? undefined : value.year.map(TrackIdToJSON)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the TrendingIdsResponse interface.
 */
function instanceOfTrendingIdsResponse(value) {
  let isInstance = true;
  return isInstance;
}
function TrendingIdsResponseFromJSON(json) {
  return TrendingIdsResponseFromJSONTyped(json);
}
function TrendingIdsResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'data': !exists(json, 'data') ? undefined : TrendingTimesIdsFromJSON(json['data'])
  };
}
function TrendingIdsResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'data': TrendingTimesIdsToJSON(value.data)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the UpdateCoinRequest interface.
 */
function instanceOfUpdateCoinRequest(value) {
  let isInstance = true;
  return isInstance;
}
function UpdateCoinRequestFromJSON(json) {
  return UpdateCoinRequestFromJSONTyped(json);
}
function UpdateCoinRequestFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'description': !exists(json, 'description') ? undefined : json['description'],
    'link1': !exists(json, 'link_1') ? undefined : json['link_1'],
    'link2': !exists(json, 'link_2') ? undefined : json['link_2'],
    'link3': !exists(json, 'link_3') ? undefined : json['link_3'],
    'link4': !exists(json, 'link_4') ? undefined : json['link_4']
  };
}
function UpdateCoinRequestToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'description': value.description,
    'link_1': value.link1,
    'link_2': value.link2,
    'link_3': value.link3,
    'link_4': value.link4
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the UpdateCoinResponse interface.
 */
function instanceOfUpdateCoinResponse(value) {
  let isInstance = true;
  return isInstance;
}
function UpdateCoinResponseFromJSON(json) {
  return UpdateCoinResponseFromJSONTyped(json);
}
function UpdateCoinResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'success': !exists(json, 'success') ? undefined : json['success']
  };
}
function UpdateCoinResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'success': value.success
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the UserAccountResponseFull interface.
 */
function instanceOfUserAccountResponseFull(value) {
  let isInstance = true;
  return isInstance;
}
function UserAccountResponseFullFromJSON(json) {
  return UserAccountResponseFullFromJSONTyped(json);
}
function UserAccountResponseFullFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'data': !exists(json, 'data') ? undefined : AccountFullFromJSON(json['data'])
  };
}
function UserAccountResponseFullToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'data': AccountFullToJSON(value.data)
  };
}

/* tslint:disable */
/**
 * Check if a given object implements the UserCommentsResponseFull interface.
 */
function instanceOfUserCommentsResponseFull(value) {
  let isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value && value["latestChainBlock"] !== undefined;
  isInstance = isInstance && "latestIndexedBlock" in value && value["latestIndexedBlock"] !== undefined;
  isInstance = isInstance && "latestChainSlotPlays" in value && value["latestChainSlotPlays"] !== undefined;
  isInstance = isInstance && "latestIndexedSlotPlays" in value && value["latestIndexedSlotPlays"] !== undefined;
  isInstance = isInstance && "signature" in value && value["signature"] !== undefined;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== undefined;
  isInstance = isInstance && "version" in value && value["version"] !== undefined;
  return isInstance;
}
function UserCommentsResponseFullFromJSON(json) {
  return UserCommentsResponseFullFromJSONTyped(json);
}
function UserCommentsResponseFullFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : json['data'].map(CommentFromJSON),
    'related': !exists(json, 'related') ? undefined : RelatedFromJSON(json['related'])
  };
}
function UserCommentsResponseFullToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': value.data === undefined ? undefined : value.data.map(CommentToJSON),
    'related': RelatedToJSON(value.related)
  };
}

/* tslint:disable */
function UserFeedItemFromJSON(json) {
  return UserFeedItemFromJSONTyped(json);
}
function UserFeedItemFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  switch (json['type']) {
    case 'playlist':
      return {
        ...PlaylistFeedItemFromJSONTyped(json),
        type: 'playlist'
      };
    case 'track':
      return {
        ...TrackFeedItemFromJSONTyped(json),
        type: 'track'
      };
    default:
      throw new Error(`No variant of UserFeedItem exists with 'type=${json['type']}'`);
  }
}
function UserFeedItemToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  switch (value['type']) {
    case 'playlist':
      return PlaylistFeedItemToJSON(value);
    case 'track':
      return TrackFeedItemToJSON(value);
    default:
      throw new Error(`No variant of UserFeedItem exists with 'type=${value['type']}'`);
  }
}

/* tslint:disable */
/**
 * Check if a given object implements the UserFeedResponse interface.
 */
function instanceOfUserFeedResponse(value) {
  let isInstance = true;
  isInstance = isInstance && "latestChainBlock" in value && value["latestChainBlock"] !== undefined;
  isInstance = isInstance && "latestIndexedBlock" in value && value["latestIndexedBlock"] !== undefined;
  isInstance = isInstance && "latestChainSlotPlays" in value && value["latestChainSlotPlays"] !== undefined;
  isInstance = isInstance && "latestIndexedSlotPlays" in value && value["latestIndexedSlotPlays"] !== undefined;
  isInstance = isInstance && "signature" in value && value["signature"] !== undefined;
  isInstance = isInstance && "timestamp" in value && value["timestamp"] !== undefined;
  isInstance = isInstance && "version" in value && value["version"] !== undefined;
  return isInstance;
}
function UserFeedResponseFromJSON(json) {
  return UserFeedResponseFromJSONTyped(json);
}
function UserFeedResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    'latestChainBlock': json['latest_chain_block'],
    'latestIndexedBlock': json['latest_indexed_block'],
    'latestChainSlotPlays': json['latest_chain_slot_plays'],
    'latestIndexedSlotPlays': json['latest_indexed_slot_plays'],
    'signature': json['signature'],
    'timestamp': json['timestamp'],
    'version': VersionMetadataFromJSON(json['version']),
    'data': !exists(json, 'data') ? undefined : json['data'].map(UserFeedItemFromJSON)
  };
}
function UserFeedResponseToJSON(value) {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    'latest_chain_block': value.latestChainBlock,
    'latest_indexed_block': value.latestIndexedBlock,
    'latest_chain_slot_plays': value.latestChainSlotPlays,
    'latest_indexed_slot_plays': value.latestIndexedSlotPlays,
    'signature': value.signature,
    'timestamp': value.timestamp,
    'version': VersionMetadataToJSON(value.version),
    'data': value.data === undefined ? undefined : value.data.map(UserFeedItemToJSON)
  };
}

/* tslint:disable */
/**
 *
 */
class ChallengesApi extends BaseAPI {
  /**
   * @hidden
   * Produces an attestation that a given user has completed a challenge, or errors.
   */
  async getChallengeAttestationRaw(params, initOverrides) {
    if (params.challengeId === null || params.challengeId === undefined) {
      throw new RequiredError('challengeId', 'Required parameter params.challengeId was null or undefined when calling getChallengeAttestation.');
    }
    if (params.oracle === null || params.oracle === undefined) {
      throw new RequiredError('oracle', 'Required parameter params.oracle was null or undefined when calling getChallengeAttestation.');
    }
    if (params.specifier === null || params.specifier === undefined) {
      throw new RequiredError('specifier', 'Required parameter params.specifier was null or undefined when calling getChallengeAttestation.');
    }
    if (params.userId === null || params.userId === undefined) {
      throw new RequiredError('userId', 'Required parameter params.userId was null or undefined when calling getChallengeAttestation.');
    }
    const queryParameters = {};
    if (params.oracle !== undefined) {
      queryParameters['oracle'] = params.oracle;
    }
    if (params.specifier !== undefined) {
      queryParameters['specifier'] = params.specifier;
    }
    if (params.userId !== undefined) {
      queryParameters['user_id'] = params.userId;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/challenges/{challenge_id}/attest`.replace(`{${"challenge_id"}}`, encodeURIComponent(String(params.challengeId))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, jsonValue => AttestationReponseFromJSON(jsonValue));
  }
  /**
   * Produces an attestation that a given user has completed a challenge, or errors.
   */
  async getChallengeAttestation(params, initOverrides) {
    const response = await this.getChallengeAttestationRaw(params, initOverrides);
    return await response.value();
  }
}

/* tslint:disable */
/**
 *
 */
class CidDataApi extends BaseAPI {
  /**
   * @hidden
   * Get a metadata by CID
   */
  async getMetadataRaw(params, initOverrides) {
    if (params.metadataId === null || params.metadataId === undefined) {
      throw new RequiredError('metadataId', 'Required parameter params.metadataId was null or undefined when calling getMetadata.');
    }
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/cid_data/{metadata_id}`.replace(`{${"metadata_id"}}`, encodeURIComponent(String(params.metadataId))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, jsonValue => CidDataResponseFromJSON(jsonValue));
  }
  /**
   * Get a metadata by CID
   */
  async getMetadata(params, initOverrides) {
    const response = await this.getMetadataRaw(params, initOverrides);
    return await response.value();
  }
}

/* tslint:disable */
/**
 *
 */
class CoinsApi extends BaseAPI {
  /**
   * @hidden
   * Creates a new artist coin
   */
  async createCoinRaw(params, initOverrides) {
    if (params.userId === null || params.userId === undefined) {
      throw new RequiredError('userId', 'Required parameter params.userId was null or undefined when calling createCoin.');
    }
    if (params.createCoinRequest === null || params.createCoinRequest === undefined) {
      throw new RequiredError('createCoinRequest', 'Required parameter params.createCoinRequest was null or undefined when calling createCoin.');
    }
    const queryParameters = {};
    if (params.userId !== undefined) {
      queryParameters['user_id'] = params.userId;
    }
    const headerParameters = {};
    headerParameters['Content-Type'] = 'application/json';
    const response = await this.request({
      path: `/coins`,
      method: 'POST',
      headers: headerParameters,
      query: queryParameters,
      body: CreateCoinRequestToJSON(params.createCoinRequest)
    }, initOverrides);
    return new JSONApiResponse(response, jsonValue => CreateCoinResponseFromJSON(jsonValue));
  }
  /**
   * Creates a new artist coin
   */
  async createCoin(params, initOverrides) {
    const response = await this.createCoinRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets information about a specific coin by its mint address
   */
  async getCoinRaw(params, initOverrides) {
    if (params.mint === null || params.mint === undefined) {
      throw new RequiredError('mint', 'Required parameter params.mint was null or undefined when calling getCoin.');
    }
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/coins/{mint}`.replace(`{${"mint"}}`, encodeURIComponent(String(params.mint))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, jsonValue => CoinResponseFromJSON(jsonValue));
  }
  /**
   * Gets information about a specific coin by its mint address
   */
  async getCoin(params, initOverrides) {
    const response = await this.getCoinRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets information about a specific coin by its ticker
   */
  async getCoinByTickerRaw(params, initOverrides) {
    if (params.ticker === null || params.ticker === undefined) {
      throw new RequiredError('ticker', 'Required parameter params.ticker was null or undefined when calling getCoinByTicker.');
    }
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/coins/ticker/{ticker}`.replace(`{${"ticker"}}`, encodeURIComponent(String(params.ticker))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, jsonValue => CoinResponseFromJSON(jsonValue));
  }
  /**
   * Gets information about a specific coin by its ticker
   */
  async getCoinByTicker(params, initOverrides) {
    const response = await this.getCoinByTickerRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets a list of coins with optional filtering
   */
  async getCoinsRaw(params, initOverrides) {
    const queryParameters = {};
    if (params.ticker) {
      queryParameters['ticker'] = params.ticker;
    }
    if (params.mint) {
      queryParameters['mint'] = params.mint;
    }
    if (params.ownerId) {
      queryParameters['owner_id'] = params.ownerId;
    }
    if (params.limit !== undefined) {
      queryParameters['limit'] = params.limit;
    }
    if (params.offset !== undefined) {
      queryParameters['offset'] = params.offset;
    }
    if (params.query !== undefined) {
      queryParameters['query'] = params.query;
    }
    if (params.sortMethod !== undefined) {
      queryParameters['sort_method'] = params.sortMethod;
    }
    if (params.sortDirection !== undefined) {
      queryParameters['sort_direction'] = params.sortDirection;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/coins`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, jsonValue => CoinsResponseFromJSON(jsonValue));
  }
  /**
   * Gets a list of coins with optional filtering
   */
  async getCoins() {
    let params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let initOverrides = arguments.length > 1 ? arguments[1] : undefined;
    const response = await this.getCoinsRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Updates information about a specific coin by its mint address
   */
  async updateCoinRaw(params, initOverrides) {
    if (params.mint === null || params.mint === undefined) {
      throw new RequiredError('mint', 'Required parameter params.mint was null or undefined when calling updateCoin.');
    }
    if (params.userId === null || params.userId === undefined) {
      throw new RequiredError('userId', 'Required parameter params.userId was null or undefined when calling updateCoin.');
    }
    if (params.updateCoinRequest === null || params.updateCoinRequest === undefined) {
      throw new RequiredError('updateCoinRequest', 'Required parameter params.updateCoinRequest was null or undefined when calling updateCoin.');
    }
    const queryParameters = {};
    if (params.userId !== undefined) {
      queryParameters['user_id'] = params.userId;
    }
    const headerParameters = {};
    headerParameters['Content-Type'] = 'application/json';
    const response = await this.request({
      path: `/coins/{mint}`.replace(`{${"mint"}}`, encodeURIComponent(String(params.mint))),
      method: 'POST',
      headers: headerParameters,
      query: queryParameters,
      body: UpdateCoinRequestToJSON(params.updateCoinRequest)
    }, initOverrides);
    return new JSONApiResponse(response, jsonValue => UpdateCoinResponseFromJSON(jsonValue));
  }
  /**
   * Updates information about a specific coin by its mint address
   */
  async updateCoin(params, initOverrides) {
    const response = await this.updateCoinRaw(params, initOverrides);
    return await response.value();
  }
}
/**
 * @export
 */
const GetCoinsSortMethodEnum = {
  MarketCap: 'market_cap',
  Price: 'price',
  Volume: 'volume',
  CreatedAt: 'created_at',
  Holder: 'holder'
};
/**
 * @export
 */
const GetCoinsSortDirectionEnum = {
  Asc: 'asc',
  Desc: 'desc'
};

/* tslint:disable */
/**
 *
 */
class CommentsApi extends BaseAPI {
  /**
   * @hidden
   * Gets a comment by ID
   */
  async getCommentRaw(params, initOverrides) {
    if (params.commentId === null || params.commentId === undefined) {
      throw new RequiredError('commentId', 'Required parameter params.commentId was null or undefined when calling getComment.');
    }
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/comments/{comment_id}`.replace(`{${"comment_id"}}`, encodeURIComponent(String(params.commentId))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, jsonValue => CommentResponseFromJSON(jsonValue));
  }
  /**
   * Gets a comment by ID
   */
  async getComment(params, initOverrides) {
    const response = await this.getCommentRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets replies to a parent comment
   */
  async getCommentRepliesRaw(params, initOverrides) {
    if (params.commentId === null || params.commentId === undefined) {
      throw new RequiredError('commentId', 'Required parameter params.commentId was null or undefined when calling getCommentReplies.');
    }
    const queryParameters = {};
    if (params.offset !== undefined) {
      queryParameters['offset'] = params.offset;
    }
    if (params.limit !== undefined) {
      queryParameters['limit'] = params.limit;
    }
    if (params.userId !== undefined) {
      queryParameters['user_id'] = params.userId;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/comments/{comment_id}/replies`.replace(`{${"comment_id"}}`, encodeURIComponent(String(params.commentId))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, jsonValue => CommentRepliesResponseFromJSON(jsonValue));
  }
  /**
   * Gets replies to a parent comment
   */
  async getCommentReplies(params, initOverrides) {
    const response = await this.getCommentRepliesRaw(params, initOverrides);
    return await response.value();
  }
}

/* tslint:disable */
/**
 *
 */
class ExploreApi extends BaseAPI {
  /**
   * @hidden
   * Get best selling tracks and/or albums with related entities
   * Get best selling tracks and playlists with related entities
   */
  async getFullBestSellingRaw(params, initOverrides) {
    const queryParameters = {};
    if (params.offset !== undefined) {
      queryParameters['offset'] = params.offset;
    }
    if (params.limit !== undefined) {
      queryParameters['limit'] = params.limit;
    }
    if (params.userId !== undefined) {
      queryParameters['user_id'] = params.userId;
    }
    if (params.type !== undefined) {
      queryParameters['type'] = params.type;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/explore/best-selling`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, jsonValue => BestSellingFullResponseFromJSON(jsonValue));
  }
  /**
   * Get best selling tracks and/or albums with related entities
   * Get best selling tracks and playlists with related entities
   */
  async getFullBestSelling() {
    let params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let initOverrides = arguments.length > 1 ? arguments[1] : undefined;
    const response = await this.getFullBestSellingRaw(params, initOverrides);
    return await response.value();
  }
}
/**
 * @export
 */
const GetFullBestSellingTypeEnum = {
  All: 'all',
  Track: 'track',
  Album: 'album'
};

/* tslint:disable */
/**
 *
 */
class NotificationsApi$1 extends BaseAPI {
  /**
   * @hidden
   * Get notifications for user ID
   */
  async getNotificationsRaw(params, initOverrides) {
    if (params.userId === null || params.userId === undefined) {
      throw new RequiredError('userId', 'Required parameter params.userId was null or undefined when calling getNotifications.');
    }
    const queryParameters = {};
    if (params.timestamp !== undefined) {
      queryParameters['timestamp'] = params.timestamp;
    }
    if (params.groupId !== undefined) {
      queryParameters['group_id'] = params.groupId;
    }
    if (params.limit !== undefined) {
      queryParameters['limit'] = params.limit;
    }
    if (params.types) {
      queryParameters['types'] = params.types;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/notifications/{user_id}`.replace(`{${"user_id"}}`, encodeURIComponent(String(params.userId))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, jsonValue => NotificationsResponseFromJSON(jsonValue));
  }
  /**
   * Get notifications for user ID
   */
  async getNotifications(params, initOverrides) {
    const response = await this.getNotificationsRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Get playlists the user has saved that have been updated for user ID
   */
  async getPlaylistUpdatesRaw(params, initOverrides) {
    if (params.userId === null || params.userId === undefined) {
      throw new RequiredError('userId', 'Required parameter params.userId was null or undefined when calling getPlaylistUpdates.');
    }
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/notifications/{user_id}/playlist_updates`.replace(`{${"user_id"}}`, encodeURIComponent(String(params.userId))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, jsonValue => PlaylistUpdatesResponseFromJSON(jsonValue));
  }
  /**
   * Get playlists the user has saved that have been updated for user ID
   */
  async getPlaylistUpdates(params, initOverrides) {
    const response = await this.getPlaylistUpdatesRaw(params, initOverrides);
    return await response.value();
  }
}
/**
 * @export
 */
const GetNotificationsTypesEnum = {
  Announcement: 'announcement',
  Follow: 'follow',
  Repost: 'repost',
  Save: 'save',
  Remix: 'remix',
  Cosign: 'cosign',
  Create: 'create',
  TipReceive: 'tip_receive',
  TipSend: 'tip_send',
  ChallengeReward: 'challenge_reward',
  RepostOfRepost: 'repost_of_repost',
  SaveOfRepost: 'save_of_repost',
  Tastemaker: 'tastemaker',
  Reaction: 'reaction',
  SupporterDethroned: 'supporter_dethroned',
  SupporterRankUp: 'supporter_rank_up',
  SupportingRankUp: 'supporting_rank_up',
  Milestone: 'milestone',
  TrackMilestone: 'track_milestone',
  TrackAddedToPlaylist: 'track_added_to_playlist',
  PlaylistMilestone: 'playlist_milestone',
  TierChange: 'tier_change',
  Trending: 'trending',
  TrendingPlaylist: 'trending_playlist',
  TrendingUnderground: 'trending_underground',
  UsdcPurchaseBuyer: 'usdc_purchase_buyer',
  UsdcPurchaseSeller: 'usdc_purchase_seller',
  TrackAddedToPurchasedAlbum: 'track_added_to_purchased_album',
  RequestManager: 'request_manager',
  ApproveManagerRequest: 'approve_manager_request',
  ClaimableReward: 'claimable_reward',
  Comment: 'comment',
  CommentThread: 'comment_thread',
  CommentMention: 'comment_mention',
  CommentReaction: 'comment_reaction',
  ListenStreakReminder: 'listen_streak_reminder',
  FanRemixContestStarted: 'fan_remix_contest_started',
  FanRemixContestEnded: 'fan_remix_contest_ended',
  FanRemixContestEndingSoon: 'fan_remix_contest_ending_soon',
  FanRemixContestWinnersSelected: 'fan_remix_contest_winners_selected',
  ArtistRemixContestEnded: 'artist_remix_contest_ended',
  ArtistRemixContestEndingSoon: 'artist_remix_contest_ending_soon',
  ArtistRemixContestSubmissions: 'artist_remix_contest_submissions'
};

/* tslint:disable */
/**
 *
 */
class PlaylistsApi extends BaseAPI {
  /**
   * @hidden
   * Gets a list of playlists by ID
   */
  async getBulkPlaylistsRaw(params, initOverrides) {
    const queryParameters = {};
    if (params.userId !== undefined) {
      queryParameters['user_id'] = params.userId;
    }
    if (params.id) {
      queryParameters['id'] = params.id;
    }
    if (params.upc) {
      queryParameters['upc'] = params.upc;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/playlists`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, jsonValue => FullPlaylistResponseFromJSON(jsonValue));
  }
  /**
   * Gets a list of playlists by ID
   */
  async getBulkPlaylists() {
    let params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let initOverrides = arguments.length > 1 ? arguments[1] : undefined;
    const response = await this.getBulkPlaylistsRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Get a playlist by ID
   */
  async getPlaylistRaw(params, initOverrides) {
    if (params.playlistId === null || params.playlistId === undefined) {
      throw new RequiredError('playlistId', 'Required parameter params.playlistId was null or undefined when calling getPlaylist.');
    }
    const queryParameters = {};
    if (params.userId !== undefined) {
      queryParameters['user_id'] = params.userId;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/playlists/{playlist_id}`.replace(`{${"playlist_id"}}`, encodeURIComponent(String(params.playlistId))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, jsonValue => FullPlaylistResponseFromJSON(jsonValue));
  }
  /**
   * Get a playlist by ID
   */
  async getPlaylist(params, initOverrides) {
    const response = await this.getPlaylistRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Get a playlist by handle and slug
   */
  async getPlaylistByHandleAndSlugRaw(params, initOverrides) {
    if (params.handle === null || params.handle === undefined) {
      throw new RequiredError('handle', 'Required parameter params.handle was null or undefined when calling getPlaylistByHandleAndSlug.');
    }
    if (params.slug === null || params.slug === undefined) {
      throw new RequiredError('slug', 'Required parameter params.slug was null or undefined when calling getPlaylistByHandleAndSlug.');
    }
    const queryParameters = {};
    if (params.userId !== undefined) {
      queryParameters['user_id'] = params.userId;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/playlists/by_permalink/{handle}/{slug}`.replace(`{${"handle"}}`, encodeURIComponent(String(params.handle))).replace(`{${"slug"}}`, encodeURIComponent(String(params.slug))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, jsonValue => FullPlaylistResponseFromJSON(jsonValue));
  }
  /**
   * Get a playlist by handle and slug
   */
  async getPlaylistByHandleAndSlug(params, initOverrides) {
    const response = await this.getPlaylistByHandleAndSlugRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Fetch tracks within a playlist.
   */
  async getPlaylistTracksRaw(params, initOverrides) {
    if (params.playlistId === null || params.playlistId === undefined) {
      throw new RequiredError('playlistId', 'Required parameter params.playlistId was null or undefined when calling getPlaylistTracks.');
    }
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/playlists/{playlist_id}/tracks`.replace(`{${"playlist_id"}}`, encodeURIComponent(String(params.playlistId))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, jsonValue => FullPlaylistTracksResponseFromJSON(jsonValue));
  }
  /**
   * Fetch tracks within a playlist.
   */
  async getPlaylistTracks(params, initOverrides) {
    const response = await this.getPlaylistTracksRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Returns trending playlists for a time period
   */
  async getTrendingPlaylistsRaw(params, initOverrides) {
    const queryParameters = {};
    if (params.offset !== undefined) {
      queryParameters['offset'] = params.offset;
    }
    if (params.limit !== undefined) {
      queryParameters['limit'] = params.limit;
    }
    if (params.userId !== undefined) {
      queryParameters['user_id'] = params.userId;
    }
    if (params.time !== undefined) {
      queryParameters['time'] = params.time;
    }
    if (params.type !== undefined) {
      queryParameters['type'] = params.type;
    }
    if (params.omitTracks !== undefined) {
      queryParameters['omit_tracks'] = params.omitTracks;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/playlists/trending`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, jsonValue => FullTrendingPlaylistsResponseFromJSON(jsonValue));
  }
  /**
   * Returns trending playlists for a time period
   */
  async getTrendingPlaylists() {
    let params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let initOverrides = arguments.length > 1 ? arguments[1] : undefined;
    const response = await this.getTrendingPlaylistsRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Returns trending playlists for a time period based on the given trending version
   */
  async getTrendingPlaylistsWithVersionRaw(params, initOverrides) {
    if (params.version === null || params.version === undefined) {
      throw new RequiredError('version', 'Required parameter params.version was null or undefined when calling getTrendingPlaylistsWithVersion.');
    }
    const queryParameters = {};
    if (params.offset !== undefined) {
      queryParameters['offset'] = params.offset;
    }
    if (params.limit !== undefined) {
      queryParameters['limit'] = params.limit;
    }
    if (params.userId !== undefined) {
      queryParameters['user_id'] = params.userId;
    }
    if (params.time !== undefined) {
      queryParameters['time'] = params.time;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/playlists/trending/{version}`.replace(`{${"version"}}`, encodeURIComponent(String(params.version))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, jsonValue => FullTrendingPlaylistsResponseFromJSON(jsonValue));
  }
  /**
   * Returns trending playlists for a time period based on the given trending version
   */
  async getTrendingPlaylistsWithVersion(params, initOverrides) {
    const response = await this.getTrendingPlaylistsWithVersionRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Get users that favorited a playlist
   */
  async getUsersFromPlaylistFavoritesRaw(params, initOverrides) {
    if (params.playlistId === null || params.playlistId === undefined) {
      throw new RequiredError('playlistId', 'Required parameter params.playlistId was null or undefined when calling getUsersFromPlaylistFavorites.');
    }
    const queryParameters = {};
    if (params.offset !== undefined) {
      queryParameters['offset'] = params.offset;
    }
    if (params.limit !== undefined) {
      queryParameters['limit'] = params.limit;
    }
    if (params.userId !== undefined) {
      queryParameters['user_id'] = params.userId;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/playlists/{playlist_id}/favorites`.replace(`{${"playlist_id"}}`, encodeURIComponent(String(params.playlistId))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, jsonValue => FollowingResponseFromJSON(jsonValue));
  }
  /**
   * Get users that favorited a playlist
   */
  async getUsersFromPlaylistFavorites(params, initOverrides) {
    const response = await this.getUsersFromPlaylistFavoritesRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Get users that reposted a playlist
   */
  async getUsersFromPlaylistRepostsRaw(params, initOverrides) {
    if (params.playlistId === null || params.playlistId === undefined) {
      throw new RequiredError('playlistId', 'Required parameter params.playlistId was null or undefined when calling getUsersFromPlaylistReposts.');
    }
    const queryParameters = {};
    if (params.offset !== undefined) {
      queryParameters['offset'] = params.offset;
    }
    if (params.limit !== undefined) {
      queryParameters['limit'] = params.limit;
    }
    if (params.userId !== undefined) {
      queryParameters['user_id'] = params.userId;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/playlists/{playlist_id}/reposts`.replace(`{${"playlist_id"}}`, encodeURIComponent(String(params.playlistId))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, jsonValue => FollowingResponseFromJSON(jsonValue));
  }
  /**
   * Get users that reposted a playlist
   */
  async getUsersFromPlaylistReposts(params, initOverrides) {
    const response = await this.getUsersFromPlaylistRepostsRaw(params, initOverrides);
    return await response.value();
  }
}
/**
 * @export
 */
const GetTrendingPlaylistsTimeEnum = {
  Week: 'week',
  Month: 'month',
  Year: 'year',
  AllTime: 'allTime'
};
/**
 * @export
 */
const GetTrendingPlaylistsTypeEnum = {
  Playlist: 'playlist',
  Album: 'album'
};
/**
 * @export
 */
const GetTrendingPlaylistsWithVersionTimeEnum = {
  Week: 'week',
  Month: 'month',
  Year: 'year',
  AllTime: 'allTime'
};

/* tslint:disable */
/**
 *
 */
class ReactionsApi extends BaseAPI {
  /**
   * @hidden
   * Gets reactions by reacted_to_id and type
   */
  async bulkGetReactionsRaw(params, initOverrides) {
    if (params.reactedToIds === null || params.reactedToIds === undefined) {
      throw new RequiredError('reactedToIds', 'Required parameter params.reactedToIds was null or undefined when calling bulkGetReactions.');
    }
    const queryParameters = {};
    if (params.type !== undefined) {
      queryParameters['type'] = params.type;
    }
    if (params.reactedToIds) {
      queryParameters['reacted_to_ids'] = params.reactedToIds.join(COLLECTION_FORMATS["csv"]);
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/reactions`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, jsonValue => ReactionsFromJSON(jsonValue));
  }
  /**
   * Gets reactions by reacted_to_id and type
   */
  async bulkGetReactions(params, initOverrides) {
    const response = await this.bulkGetReactionsRaw(params, initOverrides);
    return await response.value();
  }
}

/* tslint:disable */
/**
 *
 */
class SearchApi extends BaseAPI {
  /**
   * @hidden
   * Get Users/Tracks/Playlists/Albums that best match the search query
   */
  async searchRaw(params, initOverrides) {
    const queryParameters = {};
    if (params.offset !== undefined) {
      queryParameters['offset'] = params.offset;
    }
    if (params.limit !== undefined) {
      queryParameters['limit'] = params.limit;
    }
    if (params.userId !== undefined) {
      queryParameters['user_id'] = params.userId;
    }
    if (params.query !== undefined) {
      queryParameters['query'] = params.query;
    }
    if (params.kind !== undefined) {
      queryParameters['kind'] = params.kind;
    }
    if (params.includePurchaseable !== undefined) {
      queryParameters['includePurchaseable'] = params.includePurchaseable;
    }
    if (params.genre) {
      queryParameters['genre'] = params.genre;
    }
    if (params.mood) {
      queryParameters['mood'] = params.mood;
    }
    if (params.isVerified !== undefined) {
      queryParameters['is_verified'] = params.isVerified;
    }
    if (params.hasDownloads !== undefined) {
      queryParameters['has_downloads'] = params.hasDownloads;
    }
    if (params.isPurchaseable !== undefined) {
      queryParameters['is_purchaseable'] = params.isPurchaseable;
    }
    if (params.key) {
      queryParameters['key'] = params.key;
    }
    if (params.bpmMin !== undefined) {
      queryParameters['bpm_min'] = params.bpmMin;
    }
    if (params.bpmMax !== undefined) {
      queryParameters['bpm_max'] = params.bpmMax;
    }
    if (params.sortMethod !== undefined) {
      queryParameters['sort_method'] = params.sortMethod;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/search/full`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, jsonValue => SearchFullResponseFromJSON(jsonValue));
  }
  /**
   * Get Users/Tracks/Playlists/Albums that best match the search query
   */
  async search() {
    let params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let initOverrides = arguments.length > 1 ? arguments[1] : undefined;
    const response = await this.searchRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Same as search but optimized for quicker response at the cost of some entity information.
   * Get Users/Tracks/Playlists/Albums that best match the search query
   */
  async searchAutocompleteRaw(params, initOverrides) {
    const queryParameters = {};
    if (params.offset !== undefined) {
      queryParameters['offset'] = params.offset;
    }
    if (params.limit !== undefined) {
      queryParameters['limit'] = params.limit;
    }
    if (params.userId !== undefined) {
      queryParameters['user_id'] = params.userId;
    }
    if (params.query !== undefined) {
      queryParameters['query'] = params.query;
    }
    if (params.kind !== undefined) {
      queryParameters['kind'] = params.kind;
    }
    if (params.includePurchaseable !== undefined) {
      queryParameters['includePurchaseable'] = params.includePurchaseable;
    }
    if (params.genre) {
      queryParameters['genre'] = params.genre;
    }
    if (params.mood) {
      queryParameters['mood'] = params.mood;
    }
    if (params.isVerified !== undefined) {
      queryParameters['is_verified'] = params.isVerified;
    }
    if (params.hasDownloads !== undefined) {
      queryParameters['has_downloads'] = params.hasDownloads;
    }
    if (params.isPurchaseable !== undefined) {
      queryParameters['is_purchaseable'] = params.isPurchaseable;
    }
    if (params.key) {
      queryParameters['key'] = params.key;
    }
    if (params.bpmMin !== undefined) {
      queryParameters['bpm_min'] = params.bpmMin;
    }
    if (params.bpmMax !== undefined) {
      queryParameters['bpm_max'] = params.bpmMax;
    }
    if (params.sortMethod !== undefined) {
      queryParameters['sort_method'] = params.sortMethod;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/search/autocomplete`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, jsonValue => SearchAutocompleteResponseFromJSON(jsonValue));
  }
  /**
   * Same as search but optimized for quicker response at the cost of some entity information.
   * Get Users/Tracks/Playlists/Albums that best match the search query
   */
  async searchAutocomplete() {
    let params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let initOverrides = arguments.length > 1 ? arguments[1] : undefined;
    const response = await this.searchAutocompleteRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Get Users/Tracks/Playlists/Albums that best match the provided tag
   */
  async searchTagsRaw(params, initOverrides) {
    const queryParameters = {};
    if (params.offset !== undefined) {
      queryParameters['offset'] = params.offset;
    }
    if (params.limit !== undefined) {
      queryParameters['limit'] = params.limit;
    }
    if (params.userId !== undefined) {
      queryParameters['user_id'] = params.userId;
    }
    if (params.query !== undefined) {
      queryParameters['query'] = params.query;
    }
    if (params.kind !== undefined) {
      queryParameters['kind'] = params.kind;
    }
    if (params.includePurchaseable !== undefined) {
      queryParameters['includePurchaseable'] = params.includePurchaseable;
    }
    if (params.genre) {
      queryParameters['genre'] = params.genre;
    }
    if (params.mood) {
      queryParameters['mood'] = params.mood;
    }
    if (params.isVerified !== undefined) {
      queryParameters['is_verified'] = params.isVerified;
    }
    if (params.hasDownloads !== undefined) {
      queryParameters['has_downloads'] = params.hasDownloads;
    }
    if (params.isPurchaseable !== undefined) {
      queryParameters['is_purchaseable'] = params.isPurchaseable;
    }
    if (params.key) {
      queryParameters['key'] = params.key;
    }
    if (params.bpmMin !== undefined) {
      queryParameters['bpm_min'] = params.bpmMin;
    }
    if (params.bpmMax !== undefined) {
      queryParameters['bpm_max'] = params.bpmMax;
    }
    if (params.sortMethod !== undefined) {
      queryParameters['sort_method'] = params.sortMethod;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/search/tags`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, jsonValue => SearchFullResponseFromJSON(jsonValue));
  }
  /**
   * Get Users/Tracks/Playlists/Albums that best match the provided tag
   */
  async searchTags() {
    let params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let initOverrides = arguments.length > 1 ? arguments[1] : undefined;
    const response = await this.searchTagsRaw(params, initOverrides);
    return await response.value();
  }
}
/**
 * @export
 */
const SearchKindEnum = {
  All: 'all',
  Users: 'users',
  Tracks: 'tracks',
  Playlists: 'playlists',
  Albums: 'albums'
};
/**
 * @export
 */
const SearchSortMethodEnum = {
  Relevant: 'relevant',
  Popular: 'popular',
  Recent: 'recent'
};
/**
 * @export
 */
const SearchAutocompleteKindEnum = {
  All: 'all',
  Users: 'users',
  Tracks: 'tracks',
  Playlists: 'playlists',
  Albums: 'albums'
};
/**
 * @export
 */
const SearchAutocompleteSortMethodEnum = {
  Relevant: 'relevant',
  Popular: 'popular',
  Recent: 'recent'
};
/**
 * @export
 */
const SearchTagsKindEnum = {
  All: 'all',
  Users: 'users',
  Tracks: 'tracks',
  Playlists: 'playlists',
  Albums: 'albums'
};
/**
 * @export
 */
const SearchTagsSortMethodEnum = {
  Relevant: 'relevant',
  Popular: 'popular',
  Recent: 'recent'
};

/* tslint:disable */
/**
 *
 */
class TipsApi extends BaseAPI {
  /**
   * @hidden
   * Gets the most recent tips on the network
   */
  async getTipsRaw(params, initOverrides) {
    const queryParameters = {};
    if (params.offset !== undefined) {
      queryParameters['offset'] = params.offset;
    }
    if (params.limit !== undefined) {
      queryParameters['limit'] = params.limit;
    }
    if (params.userId !== undefined) {
      queryParameters['user_id'] = params.userId;
    }
    if (params.receiverMinFollowers !== undefined) {
      queryParameters['receiver_min_followers'] = params.receiverMinFollowers;
    }
    if (params.receiverIsVerified !== undefined) {
      queryParameters['receiver_is_verified'] = params.receiverIsVerified;
    }
    if (params.currentUserFollows !== undefined) {
      queryParameters['current_user_follows'] = params.currentUserFollows;
    }
    if (params.uniqueBy !== undefined) {
      queryParameters['unique_by'] = params.uniqueBy;
    }
    if (params.minSlot !== undefined) {
      queryParameters['min_slot'] = params.minSlot;
    }
    if (params.maxSlot !== undefined) {
      queryParameters['max_slot'] = params.maxSlot;
    }
    if (params.txSignatures) {
      queryParameters['tx_signatures'] = params.txSignatures.join(COLLECTION_FORMATS["csv"]);
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/tips`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, jsonValue => GetTipsResponseFromJSON(jsonValue));
  }
  /**
   * Gets the most recent tips on the network
   */
  async getTips() {
    let params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let initOverrides = arguments.length > 1 ? arguments[1] : undefined;
    const response = await this.getTipsRaw(params, initOverrides);
    return await response.value();
  }
}
/**
 * @export
 */
const GetTipsCurrentUserFollowsEnum = {
  Sender: 'sender',
  Receiver: 'receiver',
  SenderOrReceiver: 'sender_or_receiver'
};
/**
 * @export
 */
const GetTipsUniqueByEnum = {
  Sender: 'sender',
  Receiver: 'receiver'
};

/* tslint:disable */
/**
 *
 */
class TracksApi$1 extends BaseAPI {
  /**
   * @hidden
   * Gets the tracks found on the \"Best New Releases\" smart playlist
   */
  async getBestNewReleasesRaw(params, initOverrides) {
    if (params.window === null || params.window === undefined) {
      throw new RequiredError('window', 'Required parameter params.window was null or undefined when calling getBestNewReleases.');
    }
    const queryParameters = {};
    if (params.userId !== undefined) {
      queryParameters['user_id'] = params.userId;
    }
    if (params.window !== undefined) {
      queryParameters['window'] = params.window;
    }
    if (params.limit !== undefined) {
      queryParameters['limit'] = params.limit;
    }
    if (params.withUsers !== undefined) {
      queryParameters['with_users'] = params.withUsers;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/tracks/best_new_releases`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, jsonValue => FullTracksResponseFromJSON(jsonValue));
  }
  /**
   * Gets the tracks found on the \"Best New Releases\" smart playlist
   */
  async getBestNewReleases(params, initOverrides) {
    const response = await this.getBestNewReleasesRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets a list of tracks using their IDs or permalinks
   */
  async getBulkTracksRaw(params, initOverrides) {
    const queryParameters = {};
    if (params.userId !== undefined) {
      queryParameters['user_id'] = params.userId;
    }
    if (params.permalink) {
      queryParameters['permalink'] = params.permalink;
    }
    if (params.id) {
      queryParameters['id'] = params.id;
    }
    if (params.isrc) {
      queryParameters['isrc'] = params.isrc;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/tracks`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, jsonValue => FullTracksResponseFromJSON(jsonValue));
  }
  /**
   * Gets a list of tracks using their IDs or permalinks
   */
  async getBulkTracks() {
    let params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let initOverrides = arguments.length > 1 ? arguments[1] : undefined;
    const response = await this.getBulkTracksRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets random tracks found on the \"Feeling Lucky\" smart playlist
   */
  async getFeelingLuckyTracksRaw(params, initOverrides) {
    const queryParameters = {};
    if (params.userId !== undefined) {
      queryParameters['user_id'] = params.userId;
    }
    if (params.limit !== undefined) {
      queryParameters['limit'] = params.limit;
    }
    if (params.withUsers !== undefined) {
      queryParameters['with_users'] = params.withUsers;
    }
    if (params.minFollowers !== undefined) {
      queryParameters['min_followers'] = params.minFollowers;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/tracks/feeling-lucky`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, jsonValue => FullTracksResponseFromJSON(jsonValue));
  }
  /**
   * Gets random tracks found on the \"Feeling Lucky\" smart playlist
   */
  async getFeelingLuckyTracks() {
    let params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let initOverrides = arguments.length > 1 ? arguments[1] : undefined;
    const response = await this.getFeelingLuckyTracksRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets the tracks found on the \"Most Loved\" smart playlist
   */
  async getMostLovedTracksRaw(params, initOverrides) {
    const queryParameters = {};
    if (params.userId !== undefined) {
      queryParameters['user_id'] = params.userId;
    }
    if (params.limit !== undefined) {
      queryParameters['limit'] = params.limit;
    }
    if (params.withUsers !== undefined) {
      queryParameters['with_users'] = params.withUsers;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/tracks/most_loved`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, jsonValue => FullTracksResponseFromJSON(jsonValue));
  }
  /**
   * Gets the tracks found on the \"Most Loved\" smart playlist
   */
  async getMostLovedTracks() {
    let params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let initOverrides = arguments.length > 1 ? arguments[1] : undefined;
    const response = await this.getMostLovedTracksRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets the most shared tracks for a given time range
   */
  async getMostSharedTracksRaw(params, initOverrides) {
    const queryParameters = {};
    if (params.userId !== undefined) {
      queryParameters['user_id'] = params.userId;
    }
    if (params.limit !== undefined) {
      queryParameters['limit'] = params.limit;
    }
    if (params.offset !== undefined) {
      queryParameters['offset'] = params.offset;
    }
    if (params.timeRange !== undefined) {
      queryParameters['time_range'] = params.timeRange;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/tracks/most-shared`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, jsonValue => FullTracksResponseFromJSON(jsonValue));
  }
  /**
   * Gets the most shared tracks for a given time range
   */
  async getMostSharedTracks() {
    let params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let initOverrides = arguments.length > 1 ? arguments[1] : undefined;
    const response = await this.getMostSharedTracksRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets the most recently listed premium tracks
   */
  async getRecentPremiumTracksRaw(params, initOverrides) {
    const queryParameters = {};
    if (params.offset !== undefined) {
      queryParameters['offset'] = params.offset;
    }
    if (params.limit !== undefined) {
      queryParameters['limit'] = params.limit;
    }
    if (params.userId !== undefined) {
      queryParameters['user_id'] = params.userId;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/tracks/recent-premium`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, jsonValue => FullTracksResponseFromJSON(jsonValue));
  }
  /**
   * Gets the most recently listed premium tracks
   */
  async getRecentPremiumTracks() {
    let params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let initOverrides = arguments.length > 1 ? arguments[1] : undefined;
    const response = await this.getRecentPremiumTracksRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Get recommended tracks
   */
  async getRecommendedTracksRaw(params, initOverrides) {
    const queryParameters = {};
    if (params.limit !== undefined) {
      queryParameters['limit'] = params.limit;
    }
    if (params.genre !== undefined) {
      queryParameters['genre'] = params.genre;
    }
    if (params.time !== undefined) {
      queryParameters['time'] = params.time;
    }
    if (params.exclusionList) {
      queryParameters['exclusion_list'] = params.exclusionList;
    }
    if (params.userId !== undefined) {
      queryParameters['user_id'] = params.userId;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/tracks/recommended`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, jsonValue => FullTracksResponseFromJSON(jsonValue));
  }
  /**
   * Get recommended tracks
   */
  async getRecommendedTracks() {
    let params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let initOverrides = arguments.length > 1 ? arguments[1] : undefined;
    const response = await this.getRecommendedTracksRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Get recommended tracks using the given trending strategy version
   */
  async getRecommendedTracksWithVersionRaw(params, initOverrides) {
    if (params.version === null || params.version === undefined) {
      throw new RequiredError('version', 'Required parameter params.version was null or undefined when calling getRecommendedTracksWithVersion.');
    }
    const queryParameters = {};
    if (params.limit !== undefined) {
      queryParameters['limit'] = params.limit;
    }
    if (params.genre !== undefined) {
      queryParameters['genre'] = params.genre;
    }
    if (params.time !== undefined) {
      queryParameters['time'] = params.time;
    }
    if (params.exclusionList) {
      queryParameters['exclusion_list'] = params.exclusionList;
    }
    if (params.userId !== undefined) {
      queryParameters['user_id'] = params.userId;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/tracks/recommended/{version}`.replace(`{${"version"}}`, encodeURIComponent(String(params.version))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, jsonValue => FullTracksResponseFromJSON(jsonValue));
  }
  /**
   * Get recommended tracks using the given trending strategy version
   */
  async getRecommendedTracksWithVersion(params, initOverrides) {
    const response = await this.getRecommendedTracksWithVersionRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets a list of tracks that have stems available for remixing
   */
  async getRemixableTracksRaw(params, initOverrides) {
    const queryParameters = {};
    if (params.limit !== undefined) {
      queryParameters['limit'] = params.limit;
    }
    if (params.userId !== undefined) {
      queryParameters['user_id'] = params.userId;
    }
    if (params.withUsers !== undefined) {
      queryParameters['with_users'] = params.withUsers;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/tracks/remixables`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, jsonValue => RemixablesResponseFromJSON(jsonValue));
  }
  /**
   * Gets a list of tracks that have stems available for remixing
   */
  async getRemixableTracks() {
    let params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let initOverrides = arguments.length > 1 ? arguments[1] : undefined;
    const response = await this.getRemixableTracksRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets a track by ID.
   */
  async getTrackRaw(params, initOverrides) {
    if (params.trackId === null || params.trackId === undefined) {
      throw new RequiredError('trackId', 'Required parameter params.trackId was null or undefined when calling getTrack.');
    }
    const queryParameters = {};
    if (params.userId !== undefined) {
      queryParameters['user_id'] = params.userId;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/tracks/{track_id}`.replace(`{${"track_id"}}`, encodeURIComponent(String(params.trackId))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, jsonValue => FullTrackResponseFromJSON(jsonValue));
  }
  /**
   * Gets a track by ID.
   */
  async getTrack(params, initOverrides) {
    const response = await this.getTrackRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Get a list of comments for a track
   */
  async getTrackCommentsRaw(params, initOverrides) {
    if (params.trackId === null || params.trackId === undefined) {
      throw new RequiredError('trackId', 'Required parameter params.trackId was null or undefined when calling getTrackComments.');
    }
    const queryParameters = {};
    if (params.offset !== undefined) {
      queryParameters['offset'] = params.offset;
    }
    if (params.limit !== undefined) {
      queryParameters['limit'] = params.limit;
    }
    if (params.userId !== undefined) {
      queryParameters['user_id'] = params.userId;
    }
    if (params.sortMethod !== undefined) {
      queryParameters['sort_method'] = params.sortMethod;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/tracks/{track_id}/comments`.replace(`{${"track_id"}}`, encodeURIComponent(String(params.trackId))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, jsonValue => TrackCommentsResponseFullFromJSON(jsonValue));
  }
  /**
   * Get a list of comments for a track
   */
  async getTrackComments(params, initOverrides) {
    const response = await this.getTrackCommentsRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets all the tracks that the given track remixes
   */
  async getTrackRemixParentsRaw(params, initOverrides) {
    if (params.trackId === null || params.trackId === undefined) {
      throw new RequiredError('trackId', 'Required parameter params.trackId was null or undefined when calling getTrackRemixParents.');
    }
    const queryParameters = {};
    if (params.offset !== undefined) {
      queryParameters['offset'] = params.offset;
    }
    if (params.limit !== undefined) {
      queryParameters['limit'] = params.limit;
    }
    if (params.userId !== undefined) {
      queryParameters['user_id'] = params.userId;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/tracks/{track_id}/remixing`.replace(`{${"track_id"}}`, encodeURIComponent(String(params.trackId))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, jsonValue => RemixingResponseFromJSON(jsonValue));
  }
  /**
   * Gets all the tracks that the given track remixes
   */
  async getTrackRemixParents(params, initOverrides) {
    const response = await this.getTrackRemixParentsRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Get all tracks that remix the given track
   */
  async getTrackRemixesRaw(params, initOverrides) {
    if (params.trackId === null || params.trackId === undefined) {
      throw new RequiredError('trackId', 'Required parameter params.trackId was null or undefined when calling getTrackRemixes.');
    }
    const queryParameters = {};
    if (params.offset !== undefined) {
      queryParameters['offset'] = params.offset;
    }
    if (params.limit !== undefined) {
      queryParameters['limit'] = params.limit;
    }
    if (params.userId !== undefined) {
      queryParameters['user_id'] = params.userId;
    }
    if (params.sortMethod !== undefined) {
      queryParameters['sort_method'] = params.sortMethod;
    }
    if (params.onlyCosigns !== undefined) {
      queryParameters['only_cosigns'] = params.onlyCosigns;
    }
    if (params.onlyContestEntries !== undefined) {
      queryParameters['only_contest_entries'] = params.onlyContestEntries;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/tracks/{track_id}/remixes`.replace(`{${"track_id"}}`, encodeURIComponent(String(params.trackId))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, jsonValue => RemixesResponseFullFromJSON(jsonValue));
  }
  /**
   * Get all tracks that remix the given track
   */
  async getTrackRemixes(params, initOverrides) {
    const response = await this.getTrackRemixesRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Get the remixable stems of a track
   */
  async getTrackStemsRaw(params, initOverrides) {
    if (params.trackId === null || params.trackId === undefined) {
      throw new RequiredError('trackId', 'Required parameter params.trackId was null or undefined when calling getTrackStems.');
    }
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/tracks/{track_id}/stems`.replace(`{${"track_id"}}`, encodeURIComponent(String(params.trackId))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, jsonValue => StemsResponseFromJSON(jsonValue));
  }
  /**
   * Get the remixable stems of a track
   */
  async getTrackStems(params, initOverrides) {
    const response = await this.getTrackStemsRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Get the users that have listened to a track the most
   */
  async getTrackTopListenersRaw(params, initOverrides) {
    if (params.trackId === null || params.trackId === undefined) {
      throw new RequiredError('trackId', 'Required parameter params.trackId was null or undefined when calling getTrackTopListeners.');
    }
    const queryParameters = {};
    if (params.offset !== undefined) {
      queryParameters['offset'] = params.offset;
    }
    if (params.limit !== undefined) {
      queryParameters['limit'] = params.limit;
    }
    if (params.userId !== undefined) {
      queryParameters['user_id'] = params.userId;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/tracks/{track_id}/top_listeners`.replace(`{${"track_id"}}`, encodeURIComponent(String(params.trackId))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, jsonValue => FullTopListenerFromJSON(jsonValue));
  }
  /**
   * Get the users that have listened to a track the most
   */
  async getTrackTopListeners(params, initOverrides) {
    const response = await this.getTrackTopListenersRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets the most recent tracks with active discussion
   */
  async getTracksWithRecentCommentsRaw(params, initOverrides) {
    const queryParameters = {};
    if (params.userId !== undefined) {
      queryParameters['user_id'] = params.userId;
    }
    if (params.limit !== undefined) {
      queryParameters['limit'] = params.limit;
    }
    if (params.offset !== undefined) {
      queryParameters['offset'] = params.offset;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/tracks/recent-comments`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, jsonValue => FullTracksResponseFromJSON(jsonValue));
  }
  /**
   * Gets the most recent tracks with active discussion
   */
  async getTracksWithRecentComments() {
    let params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let initOverrides = arguments.length > 1 ? arguments[1] : undefined;
    const response = await this.getTracksWithRecentCommentsRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets the track IDs of the top trending tracks on Audius
   */
  async getTrendingTrackIDsRaw(params, initOverrides) {
    const queryParameters = {};
    if (params.offset !== undefined) {
      queryParameters['offset'] = params.offset;
    }
    if (params.limit !== undefined) {
      queryParameters['limit'] = params.limit;
    }
    if (params.genre !== undefined) {
      queryParameters['genre'] = params.genre;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/tracks/trending/ids`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, jsonValue => TrendingIdsResponseFromJSON(jsonValue));
  }
  /**
   * Gets the track IDs of the top trending tracks on Audius
   */
  async getTrendingTrackIDs() {
    let params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let initOverrides = arguments.length > 1 ? arguments[1] : undefined;
    const response = await this.getTrendingTrackIDsRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets the top 100 trending (most popular) tracks on Audius
   */
  async getTrendingTracksRaw(params, initOverrides) {
    const queryParameters = {};
    if (params.offset !== undefined) {
      queryParameters['offset'] = params.offset;
    }
    if (params.limit !== undefined) {
      queryParameters['limit'] = params.limit;
    }
    if (params.userId !== undefined) {
      queryParameters['user_id'] = params.userId;
    }
    if (params.genre !== undefined) {
      queryParameters['genre'] = params.genre;
    }
    if (params.time !== undefined) {
      queryParameters['time'] = params.time;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/tracks/trending`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, jsonValue => FullTracksResponseFromJSON(jsonValue));
  }
  /**
   * Gets the top 100 trending (most popular) tracks on Audius
   */
  async getTrendingTracks() {
    let params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let initOverrides = arguments.length > 1 ? arguments[1] : undefined;
    const response = await this.getTrendingTracksRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets the track IDs of the top trending tracks on Audius based on the given trending strategy version
   */
  async getTrendingTracksIDsWithVersionRaw(params, initOverrides) {
    if (params.version === null || params.version === undefined) {
      throw new RequiredError('version', 'Required parameter params.version was null or undefined when calling getTrendingTracksIDsWithVersion.');
    }
    const queryParameters = {};
    if (params.offset !== undefined) {
      queryParameters['offset'] = params.offset;
    }
    if (params.limit !== undefined) {
      queryParameters['limit'] = params.limit;
    }
    if (params.genre !== undefined) {
      queryParameters['genre'] = params.genre;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/tracks/trending/ids/{version}`.replace(`{${"version"}}`, encodeURIComponent(String(params.version))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, jsonValue => TrendingIdsResponseFromJSON(jsonValue));
  }
  /**
   * Gets the track IDs of the top trending tracks on Audius based on the given trending strategy version
   */
  async getTrendingTracksIDsWithVersion(params, initOverrides) {
    const response = await this.getTrendingTracksIDsWithVersionRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets the top 100 trending (most popular) tracks on Audius using a given trending strategy version
   */
  async getTrendingTracksWithVersionRaw(params, initOverrides) {
    if (params.version === null || params.version === undefined) {
      throw new RequiredError('version', 'Required parameter params.version was null or undefined when calling getTrendingTracksWithVersion.');
    }
    const queryParameters = {};
    if (params.offset !== undefined) {
      queryParameters['offset'] = params.offset;
    }
    if (params.limit !== undefined) {
      queryParameters['limit'] = params.limit;
    }
    if (params.userId !== undefined) {
      queryParameters['user_id'] = params.userId;
    }
    if (params.genre !== undefined) {
      queryParameters['genre'] = params.genre;
    }
    if (params.time !== undefined) {
      queryParameters['time'] = params.time;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/tracks/trending/{version}`.replace(`{${"version"}}`, encodeURIComponent(String(params.version))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, jsonValue => FullTracksResponseFromJSON(jsonValue));
  }
  /**
   * Gets the top 100 trending (most popular) tracks on Audius using a given trending strategy version
   */
  async getTrendingTracksWithVersion(params, initOverrides) {
    const response = await this.getTrendingTracksWithVersionRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets the top trending (most popular) USDC purchase tracks on Audius
   */
  async getTrendingUSDCPurchaseTracksRaw(params, initOverrides) {
    const queryParameters = {};
    if (params.offset !== undefined) {
      queryParameters['offset'] = params.offset;
    }
    if (params.limit !== undefined) {
      queryParameters['limit'] = params.limit;
    }
    if (params.userId !== undefined) {
      queryParameters['user_id'] = params.userId;
    }
    if (params.genre !== undefined) {
      queryParameters['genre'] = params.genre;
    }
    if (params.time !== undefined) {
      queryParameters['time'] = params.time;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/tracks/usdc-purchase`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, jsonValue => FullTracksResponseFromJSON(jsonValue));
  }
  /**
   * Gets the top trending (most popular) USDC purchase tracks on Audius
   */
  async getTrendingUSDCPurchaseTracks() {
    let params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let initOverrides = arguments.length > 1 ? arguments[1] : undefined;
    const response = await this.getTrendingUSDCPurchaseTracksRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets the top trending (most popular) USDC purchase tracks on Audius using a given trending strategy version
   */
  async getTrendingUSDCPurchaseTracksWithVersionRaw(params, initOverrides) {
    if (params.version === null || params.version === undefined) {
      throw new RequiredError('version', 'Required parameter params.version was null or undefined when calling getTrendingUSDCPurchaseTracksWithVersion.');
    }
    const queryParameters = {};
    if (params.offset !== undefined) {
      queryParameters['offset'] = params.offset;
    }
    if (params.limit !== undefined) {
      queryParameters['limit'] = params.limit;
    }
    if (params.userId !== undefined) {
      queryParameters['user_id'] = params.userId;
    }
    if (params.genre !== undefined) {
      queryParameters['genre'] = params.genre;
    }
    if (params.time !== undefined) {
      queryParameters['time'] = params.time;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/tracks/usdc-purchase/{version}`.replace(`{${"version"}}`, encodeURIComponent(String(params.version))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, jsonValue => FullTracksResponseFromJSON(jsonValue));
  }
  /**
   * Gets the top trending (most popular) USDC purchase tracks on Audius using a given trending strategy version
   */
  async getTrendingUSDCPurchaseTracksWithVersion(params, initOverrides) {
    const response = await this.getTrendingUSDCPurchaseTracksWithVersionRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets the tracks found on the \"Under the Radar\" smart playlist
   */
  async getUnderTheRadarTracksRaw(params, initOverrides) {
    const queryParameters = {};
    if (params.offset !== undefined) {
      queryParameters['offset'] = params.offset;
    }
    if (params.limit !== undefined) {
      queryParameters['limit'] = params.limit;
    }
    if (params.userId !== undefined) {
      queryParameters['user_id'] = params.userId;
    }
    if (params.filter !== undefined) {
      queryParameters['filter'] = params.filter;
    }
    if (params.tracksOnly !== undefined) {
      queryParameters['tracks_only'] = params.tracksOnly;
    }
    if (params.withUsers !== undefined) {
      queryParameters['with_users'] = params.withUsers;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/tracks/under_the_radar`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, jsonValue => FullTracksResponseFromJSON(jsonValue));
  }
  /**
   * Gets the tracks found on the \"Under the Radar\" smart playlist
   */
  async getUnderTheRadarTracks() {
    let params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let initOverrides = arguments.length > 1 ? arguments[1] : undefined;
    const response = await this.getUnderTheRadarTracksRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets the top 100 trending underground tracks on Audius
   */
  async getUndergroundTrendingTracksRaw(params, initOverrides) {
    const queryParameters = {};
    if (params.offset !== undefined) {
      queryParameters['offset'] = params.offset;
    }
    if (params.limit !== undefined) {
      queryParameters['limit'] = params.limit;
    }
    if (params.userId !== undefined) {
      queryParameters['user_id'] = params.userId;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/tracks/trending/underground`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, jsonValue => FullTracksResponseFromJSON(jsonValue));
  }
  /**
   * Gets the top 100 trending underground tracks on Audius
   */
  async getUndergroundTrendingTracks() {
    let params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let initOverrides = arguments.length > 1 ? arguments[1] : undefined;
    const response = await this.getUndergroundTrendingTracksRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets the top 100 trending underground tracks on Audius using a given trending strategy version
   */
  async getUndergroundTrendingTracksWithVersionRaw(params, initOverrides) {
    if (params.version === null || params.version === undefined) {
      throw new RequiredError('version', 'Required parameter params.version was null or undefined when calling getUndergroundTrendingTracksWithVersion.');
    }
    const queryParameters = {};
    if (params.offset !== undefined) {
      queryParameters['offset'] = params.offset;
    }
    if (params.limit !== undefined) {
      queryParameters['limit'] = params.limit;
    }
    if (params.userId !== undefined) {
      queryParameters['user_id'] = params.userId;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/tracks/trending/underground/{version}`.replace(`{${"version"}}`, encodeURIComponent(String(params.version))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, jsonValue => FullTracksResponseFromJSON(jsonValue));
  }
  /**
   * Gets the top 100 trending underground tracks on Audius using a given trending strategy version
   */
  async getUndergroundTrendingTracksWithVersion(params, initOverrides) {
    const response = await this.getUndergroundTrendingTracksWithVersionRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Get users that favorited a track
   */
  async getUsersFromFavoritesRaw(params, initOverrides) {
    if (params.trackId === null || params.trackId === undefined) {
      throw new RequiredError('trackId', 'Required parameter params.trackId was null or undefined when calling getUsersFromFavorites.');
    }
    const queryParameters = {};
    if (params.offset !== undefined) {
      queryParameters['offset'] = params.offset;
    }
    if (params.limit !== undefined) {
      queryParameters['limit'] = params.limit;
    }
    if (params.userId !== undefined) {
      queryParameters['user_id'] = params.userId;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/tracks/{track_id}/favorites`.replace(`{${"track_id"}}`, encodeURIComponent(String(params.trackId))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, jsonValue => TrackFavoritesResponseFullFromJSON(jsonValue));
  }
  /**
   * Get users that favorited a track
   */
  async getUsersFromFavorites(params, initOverrides) {
    const response = await this.getUsersFromFavoritesRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Get the users that reposted a track
   */
  async getUsersFromRepostsRaw(params, initOverrides) {
    if (params.trackId === null || params.trackId === undefined) {
      throw new RequiredError('trackId', 'Required parameter params.trackId was null or undefined when calling getUsersFromReposts.');
    }
    const queryParameters = {};
    if (params.offset !== undefined) {
      queryParameters['offset'] = params.offset;
    }
    if (params.limit !== undefined) {
      queryParameters['limit'] = params.limit;
    }
    if (params.userId !== undefined) {
      queryParameters['user_id'] = params.userId;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/tracks/{track_id}/reposts`.replace(`{${"track_id"}}`, encodeURIComponent(String(params.trackId))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, jsonValue => TrackRepostsResponseFullFromJSON(jsonValue));
  }
  /**
   * Get the users that reposted a track
   */
  async getUsersFromReposts(params, initOverrides) {
    const response = await this.getUsersFromRepostsRaw(params, initOverrides);
    return await response.value();
  }
}
/**
 * @export
 */
const GetBestNewReleasesWindowEnum = {
  Week: 'week',
  Month: 'month',
  Year: 'year'
};
/**
 * @export
 */
const GetMostSharedTracksTimeRangeEnum = {
  Week: 'week',
  Month: 'month',
  AllTime: 'allTime'
};
/**
 * @export
 */
const GetRecommendedTracksTimeEnum = {
  Week: 'week',
  Month: 'month',
  Year: 'year',
  AllTime: 'allTime'
};
/**
 * @export
 */
const GetRecommendedTracksWithVersionTimeEnum = {
  Week: 'week',
  Month: 'month',
  Year: 'year',
  AllTime: 'allTime'
};
/**
 * @export
 */
const GetTrackCommentsSortMethodEnum = {
  Top: 'top',
  Newest: 'newest',
  Timestamp: 'timestamp'
};
/**
 * @export
 */
const GetTrackRemixesSortMethodEnum = {
  Likes: 'likes',
  Plays: 'plays',
  Recent: 'recent'
};
/**
 * @export
 */
const GetTrendingTracksTimeEnum = {
  Week: 'week',
  Month: 'month',
  Year: 'year',
  AllTime: 'allTime'
};
/**
 * @export
 */
const GetTrendingTracksWithVersionTimeEnum = {
  Week: 'week',
  Month: 'month',
  Year: 'year',
  AllTime: 'allTime'
};
/**
 * @export
 */
const GetTrendingUSDCPurchaseTracksTimeEnum = {
  Week: 'week',
  Month: 'month',
  Year: 'year',
  AllTime: 'allTime'
};
/**
 * @export
 */
const GetTrendingUSDCPurchaseTracksWithVersionTimeEnum = {
  Week: 'week',
  Month: 'month',
  Year: 'year',
  AllTime: 'allTime'
};
/**
 * @export
 */
const GetUnderTheRadarTracksFilterEnum = {
  All: 'all',
  Repost: 'repost',
  Original: 'original'
};

/* tslint:disable */
/**
 *
 */
class TransactionsApi extends BaseAPI {
  /**
   * @hidden
   * @deprecated
   * Deprecated: Use `/users/{id}/transactions/audio` or `sdk.full.users.getAudioTransactions()` instead.
   * Gets the user\'s $AUDIO transaction history within the App
   */
  async getAudioTransactionHistoryRaw(params, initOverrides) {
    const queryParameters = {};
    if (params.offset !== undefined) {
      queryParameters['offset'] = params.offset;
    }
    if (params.limit !== undefined) {
      queryParameters['limit'] = params.limit;
    }
    if (params.sortMethod !== undefined) {
      queryParameters['sort_method'] = params.sortMethod;
    }
    if (params.sortDirection !== undefined) {
      queryParameters['sort_direction'] = params.sortDirection;
    }
    const headerParameters = {};
    if (params.encodedDataMessage !== undefined && params.encodedDataMessage !== null) {
      headerParameters['Encoded-Data-Message'] = String(params.encodedDataMessage);
    }
    if (params.encodedDataSignature !== undefined && params.encodedDataSignature !== null) {
      headerParameters['Encoded-Data-Signature'] = String(params.encodedDataSignature);
    }
    const response = await this.request({
      path: `/transactions`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, jsonValue => TransactionHistoryResponseFromJSON(jsonValue));
  }
  /**
   * @deprecated
   * Deprecated: Use `/users/{id}/transactions/audio` or `sdk.full.users.getAudioTransactions()` instead.
   * Gets the user\'s $AUDIO transaction history within the App
   */
  async getAudioTransactionHistory() {
    let params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let initOverrides = arguments.length > 1 ? arguments[1] : undefined;
    const response = await this.getAudioTransactionHistoryRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * @deprecated
   * Deprecated: Use `/users/{id}/transactions/audio/count` or `sdk.full.users.getAudioTransactionCount()` instead.
   * Gets the count of the user\'s $AUDIO transaction history within the App
   */
  async getAudioTransactionHistoryCountRaw(params, initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    if (params.encodedDataMessage !== undefined && params.encodedDataMessage !== null) {
      headerParameters['Encoded-Data-Message'] = String(params.encodedDataMessage);
    }
    if (params.encodedDataSignature !== undefined && params.encodedDataSignature !== null) {
      headerParameters['Encoded-Data-Signature'] = String(params.encodedDataSignature);
    }
    const response = await this.request({
      path: `/transactions/count`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, jsonValue => TransactionHistoryCountResponseFromJSON(jsonValue));
  }
  /**
   * @deprecated
   * Deprecated: Use `/users/{id}/transactions/audio/count` or `sdk.full.users.getAudioTransactionCount()` instead.
   * Gets the count of the user\'s $AUDIO transaction history within the App
   */
  async getAudioTransactionHistoryCount() {
    let params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let initOverrides = arguments.length > 1 ? arguments[1] : undefined;
    const response = await this.getAudioTransactionHistoryCountRaw(params, initOverrides);
    return await response.value();
  }
}
/**
 * @export
 */
const GetAudioTransactionHistorySortMethodEnum = {
  Date: 'date',
  TransactionType: 'transaction_type'
};
/**
 * @export
 */
const GetAudioTransactionHistorySortDirectionEnum = {
  Asc: 'asc',
  Desc: 'desc'
};

/* tslint:disable */
/**
 *
 */
class UsersApi$1 extends BaseAPI {
  /**
   * @hidden
   * All users that subscribe to the provided users
   */
  async bulkGetSubscribersRaw(params, initOverrides) {
    if (params.ids === null || params.ids === undefined) {
      throw new RequiredError('ids', 'Required parameter params.ids was null or undefined when calling bulkGetSubscribers.');
    }
    const queryParameters = {};
    if (params.ids) {
      queryParameters['ids'] = params.ids.join(COLLECTION_FORMATS["csv"]);
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/users/subscribers`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, jsonValue => FullBulkSubscribersResponseFromJSON(jsonValue));
  }
  /**
   * All users that subscribe to the provided users
   */
  async bulkGetSubscribers(params, initOverrides) {
    const response = await this.bulkGetSubscribersRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Get all users that subscribe to the users listed in the JSON request
   */
  async bulkGetSubscribersViaJSONRequestRaw(params, initOverrides) {
    if (params.ids === null || params.ids === undefined) {
      throw new RequiredError('ids', 'Required parameter params.ids was null or undefined when calling bulkGetSubscribersViaJSONRequest.');
    }
    const queryParameters = {};
    if (params.ids) {
      queryParameters['ids'] = params.ids.join(COLLECTION_FORMATS["csv"]);
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/users/subscribers`,
      method: 'POST',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, jsonValue => FullBulkSubscribersResponseFromJSON(jsonValue));
  }
  /**
   * Get all users that subscribe to the users listed in the JSON request
   */
  async bulkGetSubscribersViaJSONRequest(params, initOverrides) {
    const response = await this.bulkGetSubscribersViaJSONRequestRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets the AI generated tracks attributed to a user using the user\'s handle
   */
  async getAIAttributedTracksByUserHandleRaw(params, initOverrides) {
    if (params.handle === null || params.handle === undefined) {
      throw new RequiredError('handle', 'Required parameter params.handle was null or undefined when calling getAIAttributedTracksByUserHandle.');
    }
    const queryParameters = {};
    if (params.offset !== undefined) {
      queryParameters['offset'] = params.offset;
    }
    if (params.limit !== undefined) {
      queryParameters['limit'] = params.limit;
    }
    if (params.userId !== undefined) {
      queryParameters['user_id'] = params.userId;
    }
    if (params.sort !== undefined) {
      queryParameters['sort'] = params.sort;
    }
    if (params.query !== undefined) {
      queryParameters['query'] = params.query;
    }
    if (params.sortMethod !== undefined) {
      queryParameters['sort_method'] = params.sortMethod;
    }
    if (params.sortDirection !== undefined) {
      queryParameters['sort_direction'] = params.sortDirection;
    }
    if (params.filterTracks !== undefined) {
      queryParameters['filter_tracks'] = params.filterTracks;
    }
    const headerParameters = {};
    if (params.encodedDataMessage !== undefined && params.encodedDataMessage !== null) {
      headerParameters['Encoded-Data-Message'] = String(params.encodedDataMessage);
    }
    if (params.encodedDataSignature !== undefined && params.encodedDataSignature !== null) {
      headerParameters['Encoded-Data-Signature'] = String(params.encodedDataSignature);
    }
    const response = await this.request({
      path: `/users/handle/{handle}/tracks/ai_attributed`.replace(`{${"handle"}}`, encodeURIComponent(String(params.handle))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, jsonValue => FullTracksFromJSON(jsonValue));
  }
  /**
   * Gets the AI generated tracks attributed to a user using the user\'s handle
   */
  async getAIAttributedTracksByUserHandle(params, initOverrides) {
    const response = await this.getAIAttributedTracksByUserHandleRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets the albums created by a user using their user ID
   */
  async getAlbumsByUserRaw(params, initOverrides) {
    if (params.id === null || params.id === undefined) {
      throw new RequiredError('id', 'Required parameter params.id was null or undefined when calling getAlbumsByUser.');
    }
    const queryParameters = {};
    if (params.offset !== undefined) {
      queryParameters['offset'] = params.offset;
    }
    if (params.limit !== undefined) {
      queryParameters['limit'] = params.limit;
    }
    if (params.userId !== undefined) {
      queryParameters['user_id'] = params.userId;
    }
    if (params.sortMethod !== undefined) {
      queryParameters['sort_method'] = params.sortMethod;
    }
    if (params.query !== undefined) {
      queryParameters['query'] = params.query;
    }
    const headerParameters = {};
    if (params.encodedDataMessage !== undefined && params.encodedDataMessage !== null) {
      headerParameters['Encoded-Data-Message'] = String(params.encodedDataMessage);
    }
    if (params.encodedDataSignature !== undefined && params.encodedDataSignature !== null) {
      headerParameters['Encoded-Data-Signature'] = String(params.encodedDataSignature);
    }
    const response = await this.request({
      path: `/users/{id}/albums`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, jsonValue => AlbumsResponseFullFromJSON(jsonValue));
  }
  /**
   * Gets the albums created by a user using their user ID
   */
  async getAlbumsByUser(params, initOverrides) {
    const response = await this.getAlbumsByUserRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets the count of the user\'s $AUDIO transaction history within the App
   */
  async getAudioTransactionCountRaw(params, initOverrides) {
    if (params.id === null || params.id === undefined) {
      throw new RequiredError('id', 'Required parameter params.id was null or undefined when calling getAudioTransactionCount.');
    }
    const queryParameters = {};
    const headerParameters = {};
    if (params.encodedDataMessage !== undefined && params.encodedDataMessage !== null) {
      headerParameters['Encoded-Data-Message'] = String(params.encodedDataMessage);
    }
    if (params.encodedDataSignature !== undefined && params.encodedDataSignature !== null) {
      headerParameters['Encoded-Data-Signature'] = String(params.encodedDataSignature);
    }
    const response = await this.request({
      path: `/users/{id}/transactions/audio/count`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, jsonValue => TransactionHistoryCountResponseFromJSON(jsonValue));
  }
  /**
   * Gets the count of the user\'s $AUDIO transaction history within the App
   */
  async getAudioTransactionCount(params, initOverrides) {
    const response = await this.getAudioTransactionCountRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets the user\'s $AUDIO transaction history within the App
   */
  async getAudioTransactionsRaw(params, initOverrides) {
    if (params.id === null || params.id === undefined) {
      throw new RequiredError('id', 'Required parameter params.id was null or undefined when calling getAudioTransactions.');
    }
    const queryParameters = {};
    if (params.offset !== undefined) {
      queryParameters['offset'] = params.offset;
    }
    if (params.limit !== undefined) {
      queryParameters['limit'] = params.limit;
    }
    if (params.sortMethod !== undefined) {
      queryParameters['sort_method'] = params.sortMethod;
    }
    if (params.sortDirection !== undefined) {
      queryParameters['sort_direction'] = params.sortDirection;
    }
    const headerParameters = {};
    if (params.encodedDataMessage !== undefined && params.encodedDataMessage !== null) {
      headerParameters['Encoded-Data-Message'] = String(params.encodedDataMessage);
    }
    if (params.encodedDataSignature !== undefined && params.encodedDataSignature !== null) {
      headerParameters['Encoded-Data-Signature'] = String(params.encodedDataSignature);
    }
    const response = await this.request({
      path: `/users/{id}/transactions/audio`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, jsonValue => TransactionHistoryResponseFromJSON(jsonValue));
  }
  /**
   * Gets the user\'s $AUDIO transaction history within the App
   */
  async getAudioTransactions(params, initOverrides) {
    const response = await this.getAudioTransactionsRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets a list of users by ID
   */
  async getBulkUsersRaw(params, initOverrides) {
    const queryParameters = {};
    if (params.userId !== undefined) {
      queryParameters['user_id'] = params.userId;
    }
    if (params.id) {
      queryParameters['id'] = params.id;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/users`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, jsonValue => FullUserResponseFromJSON(jsonValue));
  }
  /**
   * Gets a list of users by ID
   */
  async getBulkUsers() {
    let params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let initOverrides = arguments.length > 1 ? arguments[1] : undefined;
    const response = await this.getBulkUsersRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets a user\'s favorite tracks
   */
  async getFavoritesRaw(params, initOverrides) {
    if (params.id === null || params.id === undefined) {
      throw new RequiredError('id', 'Required parameter params.id was null or undefined when calling getFavorites.');
    }
    const queryParameters = {};
    if (params.offset !== undefined) {
      queryParameters['offset'] = params.offset;
    }
    if (params.limit !== undefined) {
      queryParameters['limit'] = params.limit;
    }
    if (params.userId !== undefined) {
      queryParameters['user_id'] = params.userId;
    }
    if (params.query !== undefined) {
      queryParameters['query'] = params.query;
    }
    if (params.sortMethod !== undefined) {
      queryParameters['sort_method'] = params.sortMethod;
    }
    if (params.sortDirection !== undefined) {
      queryParameters['sort_direction'] = params.sortDirection;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/users/{id}/favorites/tracks`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, jsonValue => TrackLibraryResponseFullFromJSON(jsonValue));
  }
  /**
   * Gets a user\'s favorite tracks
   */
  async getFavorites(params, initOverrides) {
    const response = await this.getFavoritesRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * All users that follow the provided user
   */
  async getFollowersRaw(params, initOverrides) {
    if (params.id === null || params.id === undefined) {
      throw new RequiredError('id', 'Required parameter params.id was null or undefined when calling getFollowers.');
    }
    const queryParameters = {};
    if (params.offset !== undefined) {
      queryParameters['offset'] = params.offset;
    }
    if (params.limit !== undefined) {
      queryParameters['limit'] = params.limit;
    }
    if (params.userId !== undefined) {
      queryParameters['user_id'] = params.userId;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/users/{id}/followers`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, jsonValue => FullFollowersResponseFromJSON(jsonValue));
  }
  /**
   * All users that follow the provided user
   */
  async getFollowers(params, initOverrides) {
    const response = await this.getFollowersRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * All users that the provided user follows
   */
  async getFollowingRaw(params, initOverrides) {
    if (params.id === null || params.id === undefined) {
      throw new RequiredError('id', 'Required parameter params.id was null or undefined when calling getFollowing.');
    }
    const queryParameters = {};
    if (params.offset !== undefined) {
      queryParameters['offset'] = params.offset;
    }
    if (params.limit !== undefined) {
      queryParameters['limit'] = params.limit;
    }
    if (params.userId !== undefined) {
      queryParameters['user_id'] = params.userId;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/users/{id}/following`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, jsonValue => FollowingResponseFullFromJSON(jsonValue));
  }
  /**
   * All users that the provided user follows
   */
  async getFollowing(params, initOverrides) {
    const response = await this.getFollowingRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets a list of users managed by the given user
   */
  async getManagedUsersRaw(params, initOverrides) {
    if (params.id === null || params.id === undefined) {
      throw new RequiredError('id', 'Required parameter params.id was null or undefined when calling getManagedUsers.');
    }
    const queryParameters = {};
    if (params.isApproved !== undefined) {
      queryParameters['is_approved'] = params.isApproved;
    }
    if (params.isRevoked !== undefined) {
      queryParameters['is_revoked'] = params.isRevoked;
    }
    const headerParameters = {};
    if (params.encodedDataMessage !== undefined && params.encodedDataMessage !== null) {
      headerParameters['Encoded-Data-Message'] = String(params.encodedDataMessage);
    }
    if (params.encodedDataSignature !== undefined && params.encodedDataSignature !== null) {
      headerParameters['Encoded-Data-Signature'] = String(params.encodedDataSignature);
    }
    const response = await this.request({
      path: `/users/{id}/managed_users`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, jsonValue => ManagedUsersResponseFromJSON(jsonValue));
  }
  /**
   * Gets a list of users managed by the given user
   */
  async getManagedUsers(params, initOverrides) {
    const response = await this.getManagedUsersRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets a list of users managing the given user
   */
  async getManagersRaw(params, initOverrides) {
    if (params.id === null || params.id === undefined) {
      throw new RequiredError('id', 'Required parameter params.id was null or undefined when calling getManagers.');
    }
    const queryParameters = {};
    if (params.isApproved !== undefined) {
      queryParameters['is_approved'] = params.isApproved;
    }
    if (params.isRevoked !== undefined) {
      queryParameters['is_revoked'] = params.isRevoked;
    }
    const headerParameters = {};
    if (params.encodedDataMessage !== undefined && params.encodedDataMessage !== null) {
      headerParameters['Encoded-Data-Message'] = String(params.encodedDataMessage);
    }
    if (params.encodedDataSignature !== undefined && params.encodedDataSignature !== null) {
      headerParameters['Encoded-Data-Signature'] = String(params.encodedDataSignature);
    }
    const response = await this.request({
      path: `/users/{id}/managers`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, jsonValue => ManagersResponseFromJSON(jsonValue));
  }
  /**
   * Gets a list of users managing the given user
   */
  async getManagers(params, initOverrides) {
    const response = await this.getManagersRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets users muted by the given user
   */
  async getMutedUsersRaw(params, initOverrides) {
    if (params.id === null || params.id === undefined) {
      throw new RequiredError('id', 'Required parameter params.id was null or undefined when calling getMutedUsers.');
    }
    const queryParameters = {};
    const headerParameters = {};
    if (params.encodedDataMessage !== undefined && params.encodedDataMessage !== null) {
      headerParameters['Encoded-Data-Message'] = String(params.encodedDataMessage);
    }
    if (params.encodedDataSignature !== undefined && params.encodedDataSignature !== null) {
      headerParameters['Encoded-Data-Signature'] = String(params.encodedDataSignature);
    }
    const response = await this.request({
      path: `/users/{id}/muted`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, jsonValue => FullUserResponseFromJSON(jsonValue));
  }
  /**
   * Gets users muted by the given user
   */
  async getMutedUsers(params, initOverrides) {
    const response = await this.getMutedUsersRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Get intersection of users that follow followeeUserId and users that are followed by followerUserId
   */
  async getMutualFollowersRaw(params, initOverrides) {
    if (params.id === null || params.id === undefined) {
      throw new RequiredError('id', 'Required parameter params.id was null or undefined when calling getMutualFollowers.');
    }
    const queryParameters = {};
    if (params.offset !== undefined) {
      queryParameters['offset'] = params.offset;
    }
    if (params.limit !== undefined) {
      queryParameters['limit'] = params.limit;
    }
    if (params.userId !== undefined) {
      queryParameters['user_id'] = params.userId;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/users/{id}/mutuals`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, jsonValue => FullMutualFollowersResponseFromJSON(jsonValue));
  }
  /**
   * Get intersection of users that follow followeeUserId and users that are followed by followerUserId
   */
  async getMutualFollowers(params, initOverrides) {
    const response = await this.getMutualFollowersRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets the playlists created by a user using their user ID
   */
  async getPlaylistsByUserRaw(params, initOverrides) {
    if (params.id === null || params.id === undefined) {
      throw new RequiredError('id', 'Required parameter params.id was null or undefined when calling getPlaylistsByUser.');
    }
    const queryParameters = {};
    if (params.offset !== undefined) {
      queryParameters['offset'] = params.offset;
    }
    if (params.limit !== undefined) {
      queryParameters['limit'] = params.limit;
    }
    if (params.userId !== undefined) {
      queryParameters['user_id'] = params.userId;
    }
    if (params.sortMethod !== undefined) {
      queryParameters['sort_method'] = params.sortMethod;
    }
    if (params.query !== undefined) {
      queryParameters['query'] = params.query;
    }
    const headerParameters = {};
    if (params.encodedDataMessage !== undefined && params.encodedDataMessage !== null) {
      headerParameters['Encoded-Data-Message'] = String(params.encodedDataMessage);
    }
    if (params.encodedDataSignature !== undefined && params.encodedDataSignature !== null) {
      headerParameters['Encoded-Data-Signature'] = String(params.encodedDataSignature);
    }
    const response = await this.request({
      path: `/users/{id}/playlists`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, jsonValue => PlaylistsResponseFullFromJSON(jsonValue));
  }
  /**
   * Gets the playlists created by a user using their user ID
   */
  async getPlaylistsByUser(params, initOverrides) {
    const response = await this.getPlaylistsByUserRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets the list of unique users who have purchased content by the given user
   */
  async getPurchasersRaw(params, initOverrides) {
    if (params.id === null || params.id === undefined) {
      throw new RequiredError('id', 'Required parameter params.id was null or undefined when calling getPurchasers.');
    }
    const queryParameters = {};
    if (params.offset !== undefined) {
      queryParameters['offset'] = params.offset;
    }
    if (params.limit !== undefined) {
      queryParameters['limit'] = params.limit;
    }
    if (params.userId !== undefined) {
      queryParameters['user_id'] = params.userId;
    }
    if (params.contentType !== undefined) {
      queryParameters['content_type'] = params.contentType;
    }
    if (params.contentId !== undefined) {
      queryParameters['content_id'] = params.contentId;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/users/{id}/purchasers`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, jsonValue => FullPurchasersResponseFromJSON(jsonValue));
  }
  /**
   * Gets the list of unique users who have purchased content by the given user
   */
  async getPurchasers(params, initOverrides) {
    const response = await this.getPurchasersRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets the list of users who have purchased content by the given user
   */
  async getPurchasersCountRaw(params, initOverrides) {
    if (params.id === null || params.id === undefined) {
      throw new RequiredError('id', 'Required parameter params.id was null or undefined when calling getPurchasersCount.');
    }
    const queryParameters = {};
    if (params.offset !== undefined) {
      queryParameters['offset'] = params.offset;
    }
    if (params.limit !== undefined) {
      queryParameters['limit'] = params.limit;
    }
    if (params.userId !== undefined) {
      queryParameters['user_id'] = params.userId;
    }
    if (params.contentType !== undefined) {
      queryParameters['content_type'] = params.contentType;
    }
    if (params.contentId !== undefined) {
      queryParameters['content_id'] = params.contentId;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/users/{id}/purchasers/count`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, jsonValue => PurchasersCountResponseFromJSON(jsonValue));
  }
  /**
   * Gets the list of users who have purchased content by the given user
   */
  async getPurchasersCount(params, initOverrides) {
    const response = await this.getPurchasersCountRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets the purchases the user has made
   */
  async getPurchasesRaw(params, initOverrides) {
    if (params.id === null || params.id === undefined) {
      throw new RequiredError('id', 'Required parameter params.id was null or undefined when calling getPurchases.');
    }
    const queryParameters = {};
    if (params.offset !== undefined) {
      queryParameters['offset'] = params.offset;
    }
    if (params.limit !== undefined) {
      queryParameters['limit'] = params.limit;
    }
    if (params.userId !== undefined) {
      queryParameters['user_id'] = params.userId;
    }
    if (params.sortMethod !== undefined) {
      queryParameters['sort_method'] = params.sortMethod;
    }
    if (params.sortDirection !== undefined) {
      queryParameters['sort_direction'] = params.sortDirection;
    }
    if (params.contentIds) {
      queryParameters['content_ids'] = params.contentIds;
    }
    const headerParameters = {};
    if (params.encodedDataMessage !== undefined && params.encodedDataMessage !== null) {
      headerParameters['Encoded-Data-Message'] = String(params.encodedDataMessage);
    }
    if (params.encodedDataSignature !== undefined && params.encodedDataSignature !== null) {
      headerParameters['Encoded-Data-Signature'] = String(params.encodedDataSignature);
    }
    const response = await this.request({
      path: `/users/{id}/purchases`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, jsonValue => PurchasesResponseFromJSON(jsonValue));
  }
  /**
   * Gets the purchases the user has made
   */
  async getPurchases(params, initOverrides) {
    const response = await this.getPurchasesRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets the count of purchases the user has made
   */
  async getPurchasesCountRaw(params, initOverrides) {
    if (params.id === null || params.id === undefined) {
      throw new RequiredError('id', 'Required parameter params.id was null or undefined when calling getPurchasesCount.');
    }
    const queryParameters = {};
    if (params.userId !== undefined) {
      queryParameters['user_id'] = params.userId;
    }
    if (params.contentIds) {
      queryParameters['content_ids'] = params.contentIds;
    }
    const headerParameters = {};
    if (params.encodedDataMessage !== undefined && params.encodedDataMessage !== null) {
      headerParameters['Encoded-Data-Message'] = String(params.encodedDataMessage);
    }
    if (params.encodedDataSignature !== undefined && params.encodedDataSignature !== null) {
      headerParameters['Encoded-Data-Signature'] = String(params.encodedDataSignature);
    }
    const response = await this.request({
      path: `/users/{id}/purchases/count`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, jsonValue => PurchasesCountResponseFromJSON(jsonValue));
  }
  /**
   * Gets the count of purchases the user has made
   */
  async getPurchasesCount(params, initOverrides) {
    const response = await this.getPurchasesCountRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets a list of users that might be of interest to followers of this user.
   */
  async getRelatedUsersRaw(params, initOverrides) {
    if (params.id === null || params.id === undefined) {
      throw new RequiredError('id', 'Required parameter params.id was null or undefined when calling getRelatedUsers.');
    }
    const queryParameters = {};
    if (params.offset !== undefined) {
      queryParameters['offset'] = params.offset;
    }
    if (params.limit !== undefined) {
      queryParameters['limit'] = params.limit;
    }
    if (params.userId !== undefined) {
      queryParameters['user_id'] = params.userId;
    }
    if (params.filterFollowed !== undefined) {
      queryParameters['filter_followed'] = params.filterFollowed;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/users/{id}/related`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, jsonValue => RelatedArtistResponseFullFromJSON(jsonValue));
  }
  /**
   * Gets a list of users that might be of interest to followers of this user.
   */
  async getRelatedUsers(params, initOverrides) {
    const response = await this.getRelatedUsersRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets the list of unique users who have remixed tracks by the given user, or a specific track by that user if provided
   */
  async getRemixersRaw(params, initOverrides) {
    if (params.id === null || params.id === undefined) {
      throw new RequiredError('id', 'Required parameter params.id was null or undefined when calling getRemixers.');
    }
    const queryParameters = {};
    if (params.offset !== undefined) {
      queryParameters['offset'] = params.offset;
    }
    if (params.limit !== undefined) {
      queryParameters['limit'] = params.limit;
    }
    if (params.userId !== undefined) {
      queryParameters['user_id'] = params.userId;
    }
    if (params.trackId !== undefined) {
      queryParameters['track_id'] = params.trackId;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/users/{id}/remixers`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, jsonValue => FullRemixersResponseFromJSON(jsonValue));
  }
  /**
   * Gets the list of unique users who have remixed tracks by the given user, or a specific track by that user if provided
   */
  async getRemixers(params, initOverrides) {
    const response = await this.getRemixersRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets the count of unique users who have remixed tracks by the given user, or a specific track by that user if provided
   */
  async getRemixersCountRaw(params, initOverrides) {
    if (params.id === null || params.id === undefined) {
      throw new RequiredError('id', 'Required parameter params.id was null or undefined when calling getRemixersCount.');
    }
    const queryParameters = {};
    if (params.userId !== undefined) {
      queryParameters['user_id'] = params.userId;
    }
    if (params.trackId !== undefined) {
      queryParameters['track_id'] = params.trackId;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/users/{id}/remixers/count`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, jsonValue => RemixersCountResponseFromJSON(jsonValue));
  }
  /**
   * Gets the count of unique users who have remixed tracks by the given user, or a specific track by that user if provided
   */
  async getRemixersCount(params, initOverrides) {
    const response = await this.getRemixersCountRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets the given user\'s reposts
   */
  async getRepostsRaw(params, initOverrides) {
    if (params.id === null || params.id === undefined) {
      throw new RequiredError('id', 'Required parameter params.id was null or undefined when calling getReposts.');
    }
    const queryParameters = {};
    if (params.offset !== undefined) {
      queryParameters['offset'] = params.offset;
    }
    if (params.limit !== undefined) {
      queryParameters['limit'] = params.limit;
    }
    if (params.userId !== undefined) {
      queryParameters['user_id'] = params.userId;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/users/{id}/reposts`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, jsonValue => FullRepostsFromJSON(jsonValue));
  }
  /**
   * Gets the given user\'s reposts
   */
  async getReposts(params, initOverrides) {
    const response = await this.getRepostsRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets the user\'s reposts by the user handle
   */
  async getRepostsByHandleRaw(params, initOverrides) {
    if (params.handle === null || params.handle === undefined) {
      throw new RequiredError('handle', 'Required parameter params.handle was null or undefined when calling getRepostsByHandle.');
    }
    const queryParameters = {};
    if (params.offset !== undefined) {
      queryParameters['offset'] = params.offset;
    }
    if (params.limit !== undefined) {
      queryParameters['limit'] = params.limit;
    }
    if (params.userId !== undefined) {
      queryParameters['user_id'] = params.userId;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/users/handle/{handle}/reposts`.replace(`{${"handle"}}`, encodeURIComponent(String(params.handle))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, jsonValue => FullRepostsFromJSON(jsonValue));
  }
  /**
   * Gets the user\'s reposts by the user handle
   */
  async getRepostsByHandle(params, initOverrides) {
    const response = await this.getRepostsByHandleRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets the sales the user has made
   */
  async getSalesRaw(params, initOverrides) {
    if (params.id === null || params.id === undefined) {
      throw new RequiredError('id', 'Required parameter params.id was null or undefined when calling getSales.');
    }
    const queryParameters = {};
    if (params.offset !== undefined) {
      queryParameters['offset'] = params.offset;
    }
    if (params.limit !== undefined) {
      queryParameters['limit'] = params.limit;
    }
    if (params.userId !== undefined) {
      queryParameters['user_id'] = params.userId;
    }
    if (params.sortMethod !== undefined) {
      queryParameters['sort_method'] = params.sortMethod;
    }
    if (params.sortDirection !== undefined) {
      queryParameters['sort_direction'] = params.sortDirection;
    }
    if (params.contentIds) {
      queryParameters['content_ids'] = params.contentIds;
    }
    const headerParameters = {};
    if (params.encodedDataMessage !== undefined && params.encodedDataMessage !== null) {
      headerParameters['Encoded-Data-Message'] = String(params.encodedDataMessage);
    }
    if (params.encodedDataSignature !== undefined && params.encodedDataSignature !== null) {
      headerParameters['Encoded-Data-Signature'] = String(params.encodedDataSignature);
    }
    const response = await this.request({
      path: `/users/{id}/sales`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, jsonValue => PurchasesResponseFromJSON(jsonValue));
  }
  /**
   * Gets the sales the user has made
   */
  async getSales(params, initOverrides) {
    const response = await this.getSalesRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets the count of sales the user has made
   */
  async getSalesCountRaw(params, initOverrides) {
    if (params.id === null || params.id === undefined) {
      throw new RequiredError('id', 'Required parameter params.id was null or undefined when calling getSalesCount.');
    }
    const queryParameters = {};
    if (params.userId !== undefined) {
      queryParameters['user_id'] = params.userId;
    }
    if (params.contentIds) {
      queryParameters['content_ids'] = params.contentIds;
    }
    const headerParameters = {};
    if (params.encodedDataMessage !== undefined && params.encodedDataMessage !== null) {
      headerParameters['Encoded-Data-Message'] = String(params.encodedDataMessage);
    }
    if (params.encodedDataSignature !== undefined && params.encodedDataSignature !== null) {
      headerParameters['Encoded-Data-Signature'] = String(params.encodedDataSignature);
    }
    const response = await this.request({
      path: `/users/{id}/sales/count`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, jsonValue => PurchasesCountResponseFromJSON(jsonValue));
  }
  /**
   * Gets the count of sales the user has made
   */
  async getSalesCount(params, initOverrides) {
    const response = await this.getSalesCountRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * All users that subscribe to the provided user
   */
  async getSubscribersRaw(params, initOverrides) {
    if (params.id === null || params.id === undefined) {
      throw new RequiredError('id', 'Required parameter params.id was null or undefined when calling getSubscribers.');
    }
    const queryParameters = {};
    if (params.offset !== undefined) {
      queryParameters['offset'] = params.offset;
    }
    if (params.limit !== undefined) {
      queryParameters['limit'] = params.limit;
    }
    if (params.userId !== undefined) {
      queryParameters['user_id'] = params.userId;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/users/{id}/subscribers`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, jsonValue => FullSubscribersResponseFromJSON(jsonValue));
  }
  /**
   * All users that subscribe to the provided user
   */
  async getSubscribers(params, initOverrides) {
    const response = await this.getSubscribersRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets the users that the given user supports
   */
  async getSupportedUsersRaw(params, initOverrides) {
    if (params.id === null || params.id === undefined) {
      throw new RequiredError('id', 'Required parameter params.id was null or undefined when calling getSupportedUsers.');
    }
    const queryParameters = {};
    if (params.offset !== undefined) {
      queryParameters['offset'] = params.offset;
    }
    if (params.limit !== undefined) {
      queryParameters['limit'] = params.limit;
    }
    if (params.userId !== undefined) {
      queryParameters['user_id'] = params.userId;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/users/{id}/supporting`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, jsonValue => FullGetSupportedUsersFromJSON(jsonValue));
  }
  /**
   * Gets the users that the given user supports
   */
  async getSupportedUsers(params, initOverrides) {
    const response = await this.getSupportedUsersRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets the specified supporter of the given user
   */
  async getSupporterRaw(params, initOverrides) {
    if (params.id === null || params.id === undefined) {
      throw new RequiredError('id', 'Required parameter params.id was null or undefined when calling getSupporter.');
    }
    if (params.supporterUserId === null || params.supporterUserId === undefined) {
      throw new RequiredError('supporterUserId', 'Required parameter params.supporterUserId was null or undefined when calling getSupporter.');
    }
    const queryParameters = {};
    if (params.userId !== undefined) {
      queryParameters['user_id'] = params.userId;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/users/{id}/supporters/{supporter_user_id}`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))).replace(`{${"supporter_user_id"}}`, encodeURIComponent(String(params.supporterUserId))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, jsonValue => FullGetSupporterFromJSON(jsonValue));
  }
  /**
   * Gets the specified supporter of the given user
   */
  async getSupporter(params, initOverrides) {
    const response = await this.getSupporterRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets the supporters of the given user
   */
  async getSupportersRaw(params, initOverrides) {
    if (params.id === null || params.id === undefined) {
      throw new RequiredError('id', 'Required parameter params.id was null or undefined when calling getSupporters.');
    }
    const queryParameters = {};
    if (params.offset !== undefined) {
      queryParameters['offset'] = params.offset;
    }
    if (params.limit !== undefined) {
      queryParameters['limit'] = params.limit;
    }
    if (params.userId !== undefined) {
      queryParameters['user_id'] = params.userId;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/users/{id}/supporters`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, jsonValue => FullGetSupportersFromJSON(jsonValue));
  }
  /**
   * Gets the supporters of the given user
   */
  async getSupporters(params, initOverrides) {
    const response = await this.getSupportersRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets the support from the given user to the supported user
   */
  async getSupportingRaw(params, initOverrides) {
    if (params.id === null || params.id === undefined) {
      throw new RequiredError('id', 'Required parameter params.id was null or undefined when calling getSupporting.');
    }
    if (params.supportedUserId === null || params.supportedUserId === undefined) {
      throw new RequiredError('supportedUserId', 'Required parameter params.supportedUserId was null or undefined when calling getSupporting.');
    }
    const queryParameters = {};
    if (params.userId !== undefined) {
      queryParameters['user_id'] = params.userId;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/users/{id}/supporting/{supported_user_id}`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))).replace(`{${"supported_user_id"}}`, encodeURIComponent(String(params.supportedUserId))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, jsonValue => FullGetSupportingFromJSON(jsonValue));
  }
  /**
   * Gets the support from the given user to the supported user
   */
  async getSupporting(params, initOverrides) {
    const response = await this.getSupportingRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Get the Top Users having at least one track by follower count
   */
  async getTopUsersRaw(params, initOverrides) {
    const queryParameters = {};
    if (params.offset !== undefined) {
      queryParameters['offset'] = params.offset;
    }
    if (params.limit !== undefined) {
      queryParameters['limit'] = params.limit;
    }
    if (params.userId !== undefined) {
      queryParameters['user_id'] = params.userId;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/users/top`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, jsonValue => TopUsersResponseFullFromJSON(jsonValue));
  }
  /**
   * Get the Top Users having at least one track by follower count
   */
  async getTopUsers() {
    let params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let initOverrides = arguments.length > 1 ? arguments[1] : undefined;
    const response = await this.getTopUsersRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Get the Top Users for a Given Genre
   */
  async getTopUsersInGenreRaw(params, initOverrides) {
    const queryParameters = {};
    if (params.offset !== undefined) {
      queryParameters['offset'] = params.offset;
    }
    if (params.limit !== undefined) {
      queryParameters['limit'] = params.limit;
    }
    if (params.genre) {
      queryParameters['genre'] = params.genre;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/users/genre/top`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, jsonValue => TopGenreUsersResponseFullFromJSON(jsonValue));
  }
  /**
   * Get the Top Users for a Given Genre
   */
  async getTopUsersInGenre() {
    let params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let initOverrides = arguments.length > 1 ? arguments[1] : undefined;
    const response = await this.getTopUsersInGenreRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets the tracks created by a user using their user ID
   */
  async getTracksByUserRaw(params, initOverrides) {
    if (params.id === null || params.id === undefined) {
      throw new RequiredError('id', 'Required parameter params.id was null or undefined when calling getTracksByUser.');
    }
    const queryParameters = {};
    if (params.offset !== undefined) {
      queryParameters['offset'] = params.offset;
    }
    if (params.limit !== undefined) {
      queryParameters['limit'] = params.limit;
    }
    if (params.userId !== undefined) {
      queryParameters['user_id'] = params.userId;
    }
    if (params.sort !== undefined) {
      queryParameters['sort'] = params.sort;
    }
    if (params.query !== undefined) {
      queryParameters['query'] = params.query;
    }
    if (params.sortMethod !== undefined) {
      queryParameters['sort_method'] = params.sortMethod;
    }
    if (params.sortDirection !== undefined) {
      queryParameters['sort_direction'] = params.sortDirection;
    }
    if (params.filterTracks !== undefined) {
      queryParameters['filter_tracks'] = params.filterTracks;
    }
    const headerParameters = {};
    if (params.encodedDataMessage !== undefined && params.encodedDataMessage !== null) {
      headerParameters['Encoded-Data-Message'] = String(params.encodedDataMessage);
    }
    if (params.encodedDataSignature !== undefined && params.encodedDataSignature !== null) {
      headerParameters['Encoded-Data-Signature'] = String(params.encodedDataSignature);
    }
    const response = await this.request({
      path: `/users/{id}/tracks`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, jsonValue => FullTracksFromJSON(jsonValue));
  }
  /**
   * Gets the tracks created by a user using their user ID
   */
  async getTracksByUser(params, initOverrides) {
    const response = await this.getTracksByUserRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets the tracks created by a user using the user\'s handle
   */
  async getTracksByUserHandleRaw(params, initOverrides) {
    if (params.handle === null || params.handle === undefined) {
      throw new RequiredError('handle', 'Required parameter params.handle was null or undefined when calling getTracksByUserHandle.');
    }
    const queryParameters = {};
    if (params.offset !== undefined) {
      queryParameters['offset'] = params.offset;
    }
    if (params.limit !== undefined) {
      queryParameters['limit'] = params.limit;
    }
    if (params.userId !== undefined) {
      queryParameters['user_id'] = params.userId;
    }
    if (params.sort !== undefined) {
      queryParameters['sort'] = params.sort;
    }
    if (params.query !== undefined) {
      queryParameters['query'] = params.query;
    }
    if (params.sortMethod !== undefined) {
      queryParameters['sort_method'] = params.sortMethod;
    }
    if (params.sortDirection !== undefined) {
      queryParameters['sort_direction'] = params.sortDirection;
    }
    if (params.filterTracks !== undefined) {
      queryParameters['filter_tracks'] = params.filterTracks;
    }
    const headerParameters = {};
    if (params.encodedDataMessage !== undefined && params.encodedDataMessage !== null) {
      headerParameters['Encoded-Data-Message'] = String(params.encodedDataMessage);
    }
    if (params.encodedDataSignature !== undefined && params.encodedDataSignature !== null) {
      headerParameters['Encoded-Data-Signature'] = String(params.encodedDataSignature);
    }
    const response = await this.request({
      path: `/users/handle/{handle}/tracks`.replace(`{${"handle"}}`, encodeURIComponent(String(params.handle))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, jsonValue => FullTracksFromJSON(jsonValue));
  }
  /**
   * Gets the tracks created by a user using the user\'s handle
   */
  async getTracksByUserHandle(params, initOverrides) {
    const response = await this.getTracksByUserHandleRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets the count of the user\'s $USDC transaction history within the App
   */
  async getUSDCTransactionCountRaw(params, initOverrides) {
    if (params.id === null || params.id === undefined) {
      throw new RequiredError('id', 'Required parameter params.id was null or undefined when calling getUSDCTransactionCount.');
    }
    const queryParameters = {};
    if (params.type) {
      queryParameters['type'] = params.type;
    }
    if (params.includeSystemTransactions !== undefined) {
      queryParameters['include_system_transactions'] = params.includeSystemTransactions;
    }
    if (params.method !== undefined) {
      queryParameters['method'] = params.method;
    }
    const headerParameters = {};
    if (params.encodedDataMessage !== undefined && params.encodedDataMessage !== null) {
      headerParameters['Encoded-Data-Message'] = String(params.encodedDataMessage);
    }
    if (params.encodedDataSignature !== undefined && params.encodedDataSignature !== null) {
      headerParameters['Encoded-Data-Signature'] = String(params.encodedDataSignature);
    }
    const response = await this.request({
      path: `/users/{id}/transactions/usdc/count`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, jsonValue => TransactionHistoryCountResponseFromJSON(jsonValue));
  }
  /**
   * Gets the count of the user\'s $USDC transaction history within the App
   */
  async getUSDCTransactionCount(params, initOverrides) {
    const response = await this.getUSDCTransactionCountRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets the user\'s $USDC transaction history within the App
   */
  async getUSDCTransactionsRaw(params, initOverrides) {
    if (params.id === null || params.id === undefined) {
      throw new RequiredError('id', 'Required parameter params.id was null or undefined when calling getUSDCTransactions.');
    }
    const queryParameters = {};
    if (params.offset !== undefined) {
      queryParameters['offset'] = params.offset;
    }
    if (params.limit !== undefined) {
      queryParameters['limit'] = params.limit;
    }
    if (params.sortMethod !== undefined) {
      queryParameters['sort_method'] = params.sortMethod;
    }
    if (params.sortDirection !== undefined) {
      queryParameters['sort_direction'] = params.sortDirection;
    }
    if (params.type) {
      queryParameters['type'] = params.type;
    }
    if (params.includeSystemTransactions !== undefined) {
      queryParameters['include_system_transactions'] = params.includeSystemTransactions;
    }
    if (params.method !== undefined) {
      queryParameters['method'] = params.method;
    }
    const headerParameters = {};
    if (params.encodedDataMessage !== undefined && params.encodedDataMessage !== null) {
      headerParameters['Encoded-Data-Message'] = String(params.encodedDataMessage);
    }
    if (params.encodedDataSignature !== undefined && params.encodedDataSignature !== null) {
      headerParameters['Encoded-Data-Signature'] = String(params.encodedDataSignature);
    }
    const response = await this.request({
      path: `/users/{id}/transactions/usdc`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, jsonValue => TransactionHistoryResponseFromJSON(jsonValue));
  }
  /**
   * Gets the user\'s $USDC transaction history within the App
   */
  async getUSDCTransactions(params, initOverrides) {
    const response = await this.getUSDCTransactionsRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets a single user by their user ID
   */
  async getUserRaw(params, initOverrides) {
    if (params.id === null || params.id === undefined) {
      throw new RequiredError('id', 'Required parameter params.id was null or undefined when calling getUser.');
    }
    const queryParameters = {};
    if (params.userId !== undefined) {
      queryParameters['user_id'] = params.userId;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/users/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, jsonValue => FullUserResponseFromJSON(jsonValue));
  }
  /**
   * Gets a single user by their user ID
   */
  async getUser(params, initOverrides) {
    const response = await this.getUserRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets the account for a given user
   */
  async getUserAccountRaw(params, initOverrides) {
    if (params.wallet === null || params.wallet === undefined) {
      throw new RequiredError('wallet', 'Required parameter params.wallet was null or undefined when calling getUserAccount.');
    }
    const queryParameters = {};
    const headerParameters = {};
    if (params.encodedDataMessage !== undefined && params.encodedDataMessage !== null) {
      headerParameters['Encoded-Data-Message'] = String(params.encodedDataMessage);
    }
    if (params.encodedDataSignature !== undefined && params.encodedDataSignature !== null) {
      headerParameters['Encoded-Data-Signature'] = String(params.encodedDataSignature);
    }
    const response = await this.request({
      path: `/users/account/{wallet}`.replace(`{${"wallet"}}`, encodeURIComponent(String(params.wallet))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, jsonValue => UserAccountResponseFullFromJSON(jsonValue));
  }
  /**
   * Gets the account for a given user
   */
  async getUserAccount(params, initOverrides) {
    const response = await this.getUserAccountRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets a single user by their handle
   */
  async getUserByHandleRaw(params, initOverrides) {
    if (params.handle === null || params.handle === undefined) {
      throw new RequiredError('handle', 'Required parameter params.handle was null or undefined when calling getUserByHandle.');
    }
    const queryParameters = {};
    if (params.userId !== undefined) {
      queryParameters['user_id'] = params.userId;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/users/handle/{handle}`.replace(`{${"handle"}}`, encodeURIComponent(String(params.handle))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, jsonValue => FullUserResponseFromJSON(jsonValue));
  }
  /**
   * Gets a single user by their handle
   */
  async getUserByHandle(params, initOverrides) {
    const response = await this.getUserByHandleRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Get user comment history
   */
  async getUserCommentsRaw(params, initOverrides) {
    if (params.id === null || params.id === undefined) {
      throw new RequiredError('id', 'Required parameter params.id was null or undefined when calling getUserComments.');
    }
    const queryParameters = {};
    if (params.offset !== undefined) {
      queryParameters['offset'] = params.offset;
    }
    if (params.limit !== undefined) {
      queryParameters['limit'] = params.limit;
    }
    if (params.userId !== undefined) {
      queryParameters['user_id'] = params.userId;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/users/{id}/comments`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, jsonValue => UserCommentsResponseFullFromJSON(jsonValue));
  }
  /**
   * Get user comment history
   */
  async getUserComments(params, initOverrides) {
    const response = await this.getUserCommentsRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets the feed for the user
   */
  async getUserFeedRaw(params, initOverrides) {
    if (params.id === null || params.id === undefined) {
      throw new RequiredError('id', 'Required parameter params.id was null or undefined when calling getUserFeed.');
    }
    const queryParameters = {};
    if (params.offset !== undefined) {
      queryParameters['offset'] = params.offset;
    }
    if (params.limit !== undefined) {
      queryParameters['limit'] = params.limit;
    }
    if (params.userId !== undefined) {
      queryParameters['user_id'] = params.userId;
    }
    if (params.filter !== undefined) {
      queryParameters['filter'] = params.filter;
    }
    if (params.tracksOnly !== undefined) {
      queryParameters['tracks_only'] = params.tracksOnly;
    }
    if (params.withUsers !== undefined) {
      queryParameters['with_users'] = params.withUsers;
    }
    if (params.followeeUserId) {
      queryParameters['followee_user_id'] = params.followeeUserId;
    }
    const headerParameters = {};
    if (params.encodedDataMessage !== undefined && params.encodedDataMessage !== null) {
      headerParameters['Encoded-Data-Message'] = String(params.encodedDataMessage);
    }
    if (params.encodedDataSignature !== undefined && params.encodedDataSignature !== null) {
      headerParameters['Encoded-Data-Signature'] = String(params.encodedDataSignature);
    }
    const response = await this.request({
      path: `/users/{id}/feed`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, jsonValue => UserFeedResponseFromJSON(jsonValue));
  }
  /**
   * Gets the feed for the user
   */
  async getUserFeed(params, initOverrides) {
    const response = await this.getUserFeedRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets a user\'s saved/reposted/purchased/all albums
   * Fetch a user\'s full library playlists
   */
  async getUserLibraryAlbumsRaw(params, initOverrides) {
    if (params.id === null || params.id === undefined) {
      throw new RequiredError('id', 'Required parameter params.id was null or undefined when calling getUserLibraryAlbums.');
    }
    const queryParameters = {};
    if (params.offset !== undefined) {
      queryParameters['offset'] = params.offset;
    }
    if (params.limit !== undefined) {
      queryParameters['limit'] = params.limit;
    }
    if (params.userId !== undefined) {
      queryParameters['user_id'] = params.userId;
    }
    if (params.query !== undefined) {
      queryParameters['query'] = params.query;
    }
    if (params.sortDirection !== undefined) {
      queryParameters['sort_direction'] = params.sortDirection;
    }
    if (params.type !== undefined) {
      queryParameters['type'] = params.type;
    }
    if (params.sortMethod !== undefined) {
      queryParameters['sort_method'] = params.sortMethod;
    }
    const headerParameters = {};
    if (params.encodedDataMessage !== undefined && params.encodedDataMessage !== null) {
      headerParameters['Encoded-Data-Message'] = String(params.encodedDataMessage);
    }
    if (params.encodedDataSignature !== undefined && params.encodedDataSignature !== null) {
      headerParameters['Encoded-Data-Signature'] = String(params.encodedDataSignature);
    }
    const response = await this.request({
      path: `/users/{id}/library/albums`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, jsonValue => CollectionLibraryResponseFullFromJSON(jsonValue));
  }
  /**
   * Gets a user\'s saved/reposted/purchased/all albums
   * Fetch a user\'s full library playlists
   */
  async getUserLibraryAlbums(params, initOverrides) {
    const response = await this.getUserLibraryAlbumsRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets a user\'s saved/reposted/purchased/all playlists
   * Fetch a user\'s full library playlists
   */
  async getUserLibraryPlaylistsRaw(params, initOverrides) {
    if (params.id === null || params.id === undefined) {
      throw new RequiredError('id', 'Required parameter params.id was null or undefined when calling getUserLibraryPlaylists.');
    }
    const queryParameters = {};
    if (params.offset !== undefined) {
      queryParameters['offset'] = params.offset;
    }
    if (params.limit !== undefined) {
      queryParameters['limit'] = params.limit;
    }
    if (params.userId !== undefined) {
      queryParameters['user_id'] = params.userId;
    }
    if (params.query !== undefined) {
      queryParameters['query'] = params.query;
    }
    if (params.sortDirection !== undefined) {
      queryParameters['sort_direction'] = params.sortDirection;
    }
    if (params.type !== undefined) {
      queryParameters['type'] = params.type;
    }
    if (params.sortMethod !== undefined) {
      queryParameters['sort_method'] = params.sortMethod;
    }
    const headerParameters = {};
    if (params.encodedDataMessage !== undefined && params.encodedDataMessage !== null) {
      headerParameters['Encoded-Data-Message'] = String(params.encodedDataMessage);
    }
    if (params.encodedDataSignature !== undefined && params.encodedDataSignature !== null) {
      headerParameters['Encoded-Data-Signature'] = String(params.encodedDataSignature);
    }
    const response = await this.request({
      path: `/users/{id}/library/playlists`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, jsonValue => CollectionLibraryResponseFullFromJSON(jsonValue));
  }
  /**
   * Gets a user\'s saved/reposted/purchased/all playlists
   * Fetch a user\'s full library playlists
   */
  async getUserLibraryPlaylists(params, initOverrides) {
    const response = await this.getUserLibraryPlaylistsRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets a user\'s saved/reposted/purchased/all tracks
   * Fetch a user\'s full library tracks
   */
  async getUserLibraryTracksRaw(params, initOverrides) {
    if (params.id === null || params.id === undefined) {
      throw new RequiredError('id', 'Required parameter params.id was null or undefined when calling getUserLibraryTracks.');
    }
    const queryParameters = {};
    if (params.offset !== undefined) {
      queryParameters['offset'] = params.offset;
    }
    if (params.limit !== undefined) {
      queryParameters['limit'] = params.limit;
    }
    if (params.userId !== undefined) {
      queryParameters['user_id'] = params.userId;
    }
    if (params.query !== undefined) {
      queryParameters['query'] = params.query;
    }
    if (params.sortMethod !== undefined) {
      queryParameters['sort_method'] = params.sortMethod;
    }
    if (params.sortDirection !== undefined) {
      queryParameters['sort_direction'] = params.sortDirection;
    }
    if (params.type !== undefined) {
      queryParameters['type'] = params.type;
    }
    const headerParameters = {};
    if (params.encodedDataMessage !== undefined && params.encodedDataMessage !== null) {
      headerParameters['Encoded-Data-Message'] = String(params.encodedDataMessage);
    }
    if (params.encodedDataSignature !== undefined && params.encodedDataSignature !== null) {
      headerParameters['Encoded-Data-Signature'] = String(params.encodedDataSignature);
    }
    const response = await this.request({
      path: `/users/{id}/library/tracks`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, jsonValue => TrackLibraryResponseFullFromJSON(jsonValue));
  }
  /**
   * Gets a user\'s saved/reposted/purchased/all tracks
   * Fetch a user\'s full library tracks
   */
  async getUserLibraryTracks(params, initOverrides) {
    const response = await this.getUserLibraryTracksRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Gets the recommended tracks for the user
   */
  async getUserRecommendedTracksRaw(params, initOverrides) {
    if (params.id === null || params.id === undefined) {
      throw new RequiredError('id', 'Required parameter params.id was null or undefined when calling getUserRecommendedTracks.');
    }
    const queryParameters = {};
    if (params.offset !== undefined) {
      queryParameters['offset'] = params.offset;
    }
    if (params.limit !== undefined) {
      queryParameters['limit'] = params.limit;
    }
    if (params.userId !== undefined) {
      queryParameters['user_id'] = params.userId;
    }
    if (params.timeRange !== undefined) {
      queryParameters['time_range'] = params.timeRange;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/users/{id}/recommended-tracks`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, jsonValue => FullTracksFromJSON(jsonValue));
  }
  /**
   * Gets the recommended tracks for the user
   */
  async getUserRecommendedTracks(params, initOverrides) {
    const response = await this.getUserRecommendedTracksRaw(params, initOverrides);
    return await response.value();
  }
  /**
   * @hidden
   * Get the tracks the user recently listened to.
   */
  async getUsersTrackHistoryRaw(params, initOverrides) {
    if (params.id === null || params.id === undefined) {
      throw new RequiredError('id', 'Required parameter params.id was null or undefined when calling getUsersTrackHistory.');
    }
    const queryParameters = {};
    if (params.offset !== undefined) {
      queryParameters['offset'] = params.offset;
    }
    if (params.limit !== undefined) {
      queryParameters['limit'] = params.limit;
    }
    if (params.query !== undefined) {
      queryParameters['query'] = params.query;
    }
    if (params.sortMethod !== undefined) {
      queryParameters['sort_method'] = params.sortMethod;
    }
    if (params.sortDirection !== undefined) {
      queryParameters['sort_direction'] = params.sortDirection;
    }
    if (params.userId !== undefined) {
      queryParameters['user_id'] = params.userId;
    }
    const headerParameters = {};
    if (params.encodedDataMessage !== undefined && params.encodedDataMessage !== null) {
      headerParameters['Encoded-Data-Message'] = String(params.encodedDataMessage);
    }
    if (params.encodedDataSignature !== undefined && params.encodedDataSignature !== null) {
      headerParameters['Encoded-Data-Signature'] = String(params.encodedDataSignature);
    }
    const response = await this.request({
      path: `/users/{id}/history/tracks`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, jsonValue => HistoryResponseFullFromJSON(jsonValue));
  }
  /**
   * Get the tracks the user recently listened to.
   */
  async getUsersTrackHistory(params, initOverrides) {
    const response = await this.getUsersTrackHistoryRaw(params, initOverrides);
    return await response.value();
  }
}
/**
 * @export
 */
const GetAIAttributedTracksByUserHandleSortEnum = {
  Date: 'date',
  Plays: 'plays'
};
/**
 * @export
 */
const GetAIAttributedTracksByUserHandleSortMethodEnum = {
  Title: 'title',
  ArtistName: 'artist_name',
  ReleaseDate: 'release_date',
  LastListenDate: 'last_listen_date',
  AddedDate: 'added_date',
  Plays: 'plays',
  Reposts: 'reposts',
  Saves: 'saves',
  MostListensByUser: 'most_listens_by_user'
};
/**
 * @export
 */
const GetAIAttributedTracksByUserHandleSortDirectionEnum = {
  Asc: 'asc',
  Desc: 'desc'
};
/**
 * @export
 */
const GetAIAttributedTracksByUserHandleFilterTracksEnum = {
  All: 'all',
  Public: 'public',
  Unlisted: 'unlisted'
};
/**
 * @export
 */
const GetAlbumsByUserSortMethodEnum = {
  Recent: 'recent',
  Popular: 'popular'
};
/**
 * @export
 */
const GetAudioTransactionsSortMethodEnum = {
  Date: 'date',
  TransactionType: 'transaction_type'
};
/**
 * @export
 */
const GetAudioTransactionsSortDirectionEnum = {
  Asc: 'asc',
  Desc: 'desc'
};
/**
 * @export
 */
const GetFavoritesSortMethodEnum = {
  Title: 'title',
  ArtistName: 'artist_name',
  ReleaseDate: 'release_date',
  LastListenDate: 'last_listen_date',
  AddedDate: 'added_date',
  Plays: 'plays',
  Reposts: 'reposts',
  Saves: 'saves',
  MostListensByUser: 'most_listens_by_user'
};
/**
 * @export
 */
const GetFavoritesSortDirectionEnum = {
  Asc: 'asc',
  Desc: 'desc'
};
/**
 * @export
 */
const GetPlaylistsByUserSortMethodEnum = {
  Recent: 'recent',
  Popular: 'popular'
};
/**
 * @export
 */
const GetPurchasesSortMethodEnum = {
  ContentTitle: 'content_title',
  ArtistName: 'artist_name',
  BuyerName: 'buyer_name',
  Date: 'date'
};
/**
 * @export
 */
const GetPurchasesSortDirectionEnum = {
  Asc: 'asc',
  Desc: 'desc'
};
/**
 * @export
 */
const GetSalesSortMethodEnum = {
  ContentTitle: 'content_title',
  ArtistName: 'artist_name',
  BuyerName: 'buyer_name',
  Date: 'date'
};
/**
 * @export
 */
const GetSalesSortDirectionEnum = {
  Asc: 'asc',
  Desc: 'desc'
};
/**
 * @export
 */
const GetTracksByUserSortEnum = {
  Date: 'date',
  Plays: 'plays'
};
/**
 * @export
 */
const GetTracksByUserSortMethodEnum = {
  Title: 'title',
  ArtistName: 'artist_name',
  ReleaseDate: 'release_date',
  LastListenDate: 'last_listen_date',
  AddedDate: 'added_date',
  Plays: 'plays',
  Reposts: 'reposts',
  Saves: 'saves',
  MostListensByUser: 'most_listens_by_user'
};
/**
 * @export
 */
const GetTracksByUserSortDirectionEnum = {
  Asc: 'asc',
  Desc: 'desc'
};
/**
 * @export
 */
const GetTracksByUserFilterTracksEnum = {
  All: 'all',
  Public: 'public',
  Unlisted: 'unlisted'
};
/**
 * @export
 */
const GetTracksByUserHandleSortEnum = {
  Date: 'date',
  Plays: 'plays'
};
/**
 * @export
 */
const GetTracksByUserHandleSortMethodEnum = {
  Title: 'title',
  ArtistName: 'artist_name',
  ReleaseDate: 'release_date',
  LastListenDate: 'last_listen_date',
  AddedDate: 'added_date',
  Plays: 'plays',
  Reposts: 'reposts',
  Saves: 'saves',
  MostListensByUser: 'most_listens_by_user'
};
/**
 * @export
 */
const GetTracksByUserHandleSortDirectionEnum = {
  Asc: 'asc',
  Desc: 'desc'
};
/**
 * @export
 */
const GetTracksByUserHandleFilterTracksEnum = {
  All: 'all',
  Public: 'public',
  Unlisted: 'unlisted'
};
/**
 * @export
 */
const GetUSDCTransactionCountTypeEnum = {
  PurchaseContent: 'purchase_content',
  Transfer: 'transfer',
  InternalTransfer: 'internal_transfer',
  PrepareWithdrawal: 'prepare_withdrawal',
  RecoverWithdrawal: 'recover_withdrawal',
  Withdrawal: 'withdrawal',
  PurchaseStripe: 'purchase_stripe'
};
/**
 * @export
 */
const GetUSDCTransactionCountMethodEnum = {
  Send: 'send',
  Receive: 'receive'
};
/**
 * @export
 */
const GetUSDCTransactionsSortMethodEnum = {
  Date: 'date',
  TransactionType: 'transaction_type'
};
/**
 * @export
 */
const GetUSDCTransactionsSortDirectionEnum = {
  Asc: 'asc',
  Desc: 'desc'
};
/**
 * @export
 */
const GetUSDCTransactionsTypeEnum = {
  PurchaseContent: 'purchase_content',
  Transfer: 'transfer',
  InternalTransfer: 'internal_transfer',
  PrepareWithdrawal: 'prepare_withdrawal',
  RecoverWithdrawal: 'recover_withdrawal',
  Withdrawal: 'withdrawal',
  PurchaseStripe: 'purchase_stripe'
};
/**
 * @export
 */
const GetUSDCTransactionsMethodEnum = {
  Send: 'send',
  Receive: 'receive'
};
/**
 * @export
 */
const GetUserFeedFilterEnum = {
  All: 'all',
  Repost: 'repost',
  Original: 'original'
};
/**
 * @export
 */
const GetUserLibraryAlbumsSortDirectionEnum = {
  Asc: 'asc',
  Desc: 'desc'
};
/**
 * @export
 */
const GetUserLibraryAlbumsTypeEnum = {
  All: 'all',
  Repost: 'repost',
  Favorite: 'favorite',
  Purchase: 'purchase'
};
/**
 * @export
 */
const GetUserLibraryAlbumsSortMethodEnum = {
  AddedDate: 'added_date',
  Reposts: 'reposts',
  Saves: 'saves'
};
/**
 * @export
 */
const GetUserLibraryPlaylistsSortDirectionEnum = {
  Asc: 'asc',
  Desc: 'desc'
};
/**
 * @export
 */
const GetUserLibraryPlaylistsTypeEnum = {
  All: 'all',
  Repost: 'repost',
  Favorite: 'favorite',
  Purchase: 'purchase'
};
/**
 * @export
 */
const GetUserLibraryPlaylistsSortMethodEnum = {
  AddedDate: 'added_date',
  Reposts: 'reposts',
  Saves: 'saves'
};
/**
 * @export
 */
const GetUserLibraryTracksSortMethodEnum = {
  Title: 'title',
  ArtistName: 'artist_name',
  ReleaseDate: 'release_date',
  LastListenDate: 'last_listen_date',
  AddedDate: 'added_date',
  Plays: 'plays',
  Reposts: 'reposts',
  Saves: 'saves',
  MostListensByUser: 'most_listens_by_user'
};
/**
 * @export
 */
const GetUserLibraryTracksSortDirectionEnum = {
  Asc: 'asc',
  Desc: 'desc'
};
/**
 * @export
 */
const GetUserLibraryTracksTypeEnum = {
  All: 'all',
  Repost: 'repost',
  Favorite: 'favorite',
  Purchase: 'purchase'
};
/**
 * @export
 */
const GetUserRecommendedTracksTimeRangeEnum = {
  Week: 'week',
  Month: 'month',
  AllTime: 'allTime'
};
/**
 * @export
 */
const GetUsersTrackHistorySortMethodEnum = {
  Title: 'title',
  ArtistName: 'artist_name',
  ReleaseDate: 'release_date',
  LastListenDate: 'last_listen_date',
  AddedDate: 'added_date',
  Plays: 'plays',
  Reposts: 'reposts',
  Saves: 'saves',
  MostListensByUser: 'most_listens_by_user'
};
/**
 * @export
 */
const GetUsersTrackHistorySortDirectionEnum = {
  Asc: 'asc',
  Desc: 'desc'
};

/* tslint:disable */

var index = /*#__PURE__*/Object.freeze({
    __proto__: null,
    BASE_PATH: BASE_PATH,
    Configuration: Configuration,
    DefaultConfig: DefaultConfig,
    BaseAPI: BaseAPI,
    ResponseError: ResponseError,
    FetchError: FetchError,
    RequiredError: RequiredError,
    COLLECTION_FORMATS: COLLECTION_FORMATS,
    exists: exists,
    querystring: querystring,
    mapValues: mapValues,
    canConsumeForm: canConsumeForm,
    JSONApiResponse: JSONApiResponse,
    VoidApiResponse: VoidApiResponse,
    BlobApiResponse: BlobApiResponse,
    TextApiResponse: TextApiResponse,
    ChallengesApi: ChallengesApi,
    CidDataApi: CidDataApi,
    CoinsApi: CoinsApi,
    GetCoinsSortMethodEnum: GetCoinsSortMethodEnum,
    GetCoinsSortDirectionEnum: GetCoinsSortDirectionEnum,
    CommentsApi: CommentsApi,
    ExploreApi: ExploreApi,
    GetFullBestSellingTypeEnum: GetFullBestSellingTypeEnum,
    NotificationsApi: NotificationsApi$1,
    GetNotificationsTypesEnum: GetNotificationsTypesEnum,
    PlaylistsApi: PlaylistsApi,
    GetTrendingPlaylistsTimeEnum: GetTrendingPlaylistsTimeEnum,
    GetTrendingPlaylistsTypeEnum: GetTrendingPlaylistsTypeEnum,
    GetTrendingPlaylistsWithVersionTimeEnum: GetTrendingPlaylistsWithVersionTimeEnum,
    ReactionsApi: ReactionsApi,
    SearchApi: SearchApi,
    SearchKindEnum: SearchKindEnum,
    SearchSortMethodEnum: SearchSortMethodEnum,
    SearchAutocompleteKindEnum: SearchAutocompleteKindEnum,
    SearchAutocompleteSortMethodEnum: SearchAutocompleteSortMethodEnum,
    SearchTagsKindEnum: SearchTagsKindEnum,
    SearchTagsSortMethodEnum: SearchTagsSortMethodEnum,
    TipsApi: TipsApi,
    GetTipsCurrentUserFollowsEnum: GetTipsCurrentUserFollowsEnum,
    GetTipsUniqueByEnum: GetTipsUniqueByEnum,
    TracksApi: TracksApi$1,
    GetBestNewReleasesWindowEnum: GetBestNewReleasesWindowEnum,
    GetMostSharedTracksTimeRangeEnum: GetMostSharedTracksTimeRangeEnum,
    GetRecommendedTracksTimeEnum: GetRecommendedTracksTimeEnum,
    GetRecommendedTracksWithVersionTimeEnum: GetRecommendedTracksWithVersionTimeEnum,
    GetTrackCommentsSortMethodEnum: GetTrackCommentsSortMethodEnum,
    GetTrackRemixesSortMethodEnum: GetTrackRemixesSortMethodEnum,
    GetTrendingTracksTimeEnum: GetTrendingTracksTimeEnum,
    GetTrendingTracksWithVersionTimeEnum: GetTrendingTracksWithVersionTimeEnum,
    GetTrendingUSDCPurchaseTracksTimeEnum: GetTrendingUSDCPurchaseTracksTimeEnum,
    GetTrendingUSDCPurchaseTracksWithVersionTimeEnum: GetTrendingUSDCPurchaseTracksWithVersionTimeEnum,
    GetUnderTheRadarTracksFilterEnum: GetUnderTheRadarTracksFilterEnum,
    TransactionsApi: TransactionsApi,
    GetAudioTransactionHistorySortMethodEnum: GetAudioTransactionHistorySortMethodEnum,
    GetAudioTransactionHistorySortDirectionEnum: GetAudioTransactionHistorySortDirectionEnum,
    UsersApi: UsersApi$1,
    GetAIAttributedTracksByUserHandleSortEnum: GetAIAttributedTracksByUserHandleSortEnum,
    GetAIAttributedTracksByUserHandleSortMethodEnum: GetAIAttributedTracksByUserHandleSortMethodEnum,
    GetAIAttributedTracksByUserHandleSortDirectionEnum: GetAIAttributedTracksByUserHandleSortDirectionEnum,
    GetAIAttributedTracksByUserHandleFilterTracksEnum: GetAIAttributedTracksByUserHandleFilterTracksEnum,
    GetAlbumsByUserSortMethodEnum: GetAlbumsByUserSortMethodEnum,
    GetAudioTransactionsSortMethodEnum: GetAudioTransactionsSortMethodEnum,
    GetAudioTransactionsSortDirectionEnum: GetAudioTransactionsSortDirectionEnum,
    GetFavoritesSortMethodEnum: GetFavoritesSortMethodEnum,
    GetFavoritesSortDirectionEnum: GetFavoritesSortDirectionEnum,
    GetPlaylistsByUserSortMethodEnum: GetPlaylistsByUserSortMethodEnum,
    GetPurchasesSortMethodEnum: GetPurchasesSortMethodEnum,
    GetPurchasesSortDirectionEnum: GetPurchasesSortDirectionEnum,
    GetSalesSortMethodEnum: GetSalesSortMethodEnum,
    GetSalesSortDirectionEnum: GetSalesSortDirectionEnum,
    GetTracksByUserSortEnum: GetTracksByUserSortEnum,
    GetTracksByUserSortMethodEnum: GetTracksByUserSortMethodEnum,
    GetTracksByUserSortDirectionEnum: GetTracksByUserSortDirectionEnum,
    GetTracksByUserFilterTracksEnum: GetTracksByUserFilterTracksEnum,
    GetTracksByUserHandleSortEnum: GetTracksByUserHandleSortEnum,
    GetTracksByUserHandleSortMethodEnum: GetTracksByUserHandleSortMethodEnum,
    GetTracksByUserHandleSortDirectionEnum: GetTracksByUserHandleSortDirectionEnum,
    GetTracksByUserHandleFilterTracksEnum: GetTracksByUserHandleFilterTracksEnum,
    GetUSDCTransactionCountTypeEnum: GetUSDCTransactionCountTypeEnum,
    GetUSDCTransactionCountMethodEnum: GetUSDCTransactionCountMethodEnum,
    GetUSDCTransactionsSortMethodEnum: GetUSDCTransactionsSortMethodEnum,
    GetUSDCTransactionsSortDirectionEnum: GetUSDCTransactionsSortDirectionEnum,
    GetUSDCTransactionsTypeEnum: GetUSDCTransactionsTypeEnum,
    GetUSDCTransactionsMethodEnum: GetUSDCTransactionsMethodEnum,
    GetUserFeedFilterEnum: GetUserFeedFilterEnum,
    GetUserLibraryAlbumsSortDirectionEnum: GetUserLibraryAlbumsSortDirectionEnum,
    GetUserLibraryAlbumsTypeEnum: GetUserLibraryAlbumsTypeEnum,
    GetUserLibraryAlbumsSortMethodEnum: GetUserLibraryAlbumsSortMethodEnum,
    GetUserLibraryPlaylistsSortDirectionEnum: GetUserLibraryPlaylistsSortDirectionEnum,
    GetUserLibraryPlaylistsTypeEnum: GetUserLibraryPlaylistsTypeEnum,
    GetUserLibraryPlaylistsSortMethodEnum: GetUserLibraryPlaylistsSortMethodEnum,
    GetUserLibraryTracksSortMethodEnum: GetUserLibraryTracksSortMethodEnum,
    GetUserLibraryTracksSortDirectionEnum: GetUserLibraryTracksSortDirectionEnum,
    GetUserLibraryTracksTypeEnum: GetUserLibraryTracksTypeEnum,
    GetUserRecommendedTracksTimeRangeEnum: GetUserRecommendedTracksTimeRangeEnum,
    GetUsersTrackHistorySortMethodEnum: GetUsersTrackHistorySortMethodEnum,
    GetUsersTrackHistorySortDirectionEnum: GetUsersTrackHistorySortDirectionEnum,
    instanceOfAccess: instanceOfAccess,
    AccessFromJSON: AccessFromJSON,
    AccessFromJSONTyped: AccessFromJSONTyped,
    AccessToJSON: AccessToJSON,
    AccessGateFromJSON: AccessGateFromJSON,
    AccessGateFromJSONTyped: AccessGateFromJSONTyped,
    AccessGateToJSON: AccessGateToJSON,
    instanceOfAccountCollection: instanceOfAccountCollection,
    AccountCollectionFromJSON: AccountCollectionFromJSON,
    AccountCollectionFromJSONTyped: AccountCollectionFromJSONTyped,
    AccountCollectionToJSON: AccountCollectionToJSON,
    instanceOfAccountCollectionUser: instanceOfAccountCollectionUser,
    AccountCollectionUserFromJSON: AccountCollectionUserFromJSON,
    AccountCollectionUserFromJSONTyped: AccountCollectionUserFromJSONTyped,
    AccountCollectionUserToJSON: AccountCollectionUserToJSON,
    instanceOfAccountFull: instanceOfAccountFull,
    AccountFullFromJSON: AccountFullFromJSON,
    AccountFullFromJSONTyped: AccountFullFromJSONTyped,
    AccountFullToJSON: AccountFullToJSON,
    ActivityFullItemTypeEnum: ActivityFullItemTypeEnum,
    instanceOfActivityFull: instanceOfActivityFull,
    ActivityFullFromJSON: ActivityFullFromJSON,
    ActivityFullFromJSONTyped: ActivityFullFromJSONTyped,
    ActivityFullToJSON: ActivityFullToJSON,
    instanceOfAlbumBacklink: instanceOfAlbumBacklink,
    AlbumBacklinkFromJSON: AlbumBacklinkFromJSON,
    AlbumBacklinkFromJSONTyped: AlbumBacklinkFromJSONTyped,
    AlbumBacklinkToJSON: AlbumBacklinkToJSON,
    instanceOfAlbumsResponseFull: instanceOfAlbumsResponseFull,
    AlbumsResponseFullFromJSON: AlbumsResponseFullFromJSON,
    AlbumsResponseFullFromJSONTyped: AlbumsResponseFullFromJSONTyped,
    AlbumsResponseFullToJSON: AlbumsResponseFullToJSON,
    instanceOfAnnouncementNotification: instanceOfAnnouncementNotification,
    AnnouncementNotificationFromJSON: AnnouncementNotificationFromJSON,
    AnnouncementNotificationFromJSONTyped: AnnouncementNotificationFromJSONTyped,
    AnnouncementNotificationToJSON: AnnouncementNotificationToJSON,
    instanceOfAnnouncementNotificationAction: instanceOfAnnouncementNotificationAction,
    AnnouncementNotificationActionFromJSON: AnnouncementNotificationActionFromJSON,
    AnnouncementNotificationActionFromJSONTyped: AnnouncementNotificationActionFromJSONTyped,
    AnnouncementNotificationActionToJSON: AnnouncementNotificationActionToJSON,
    instanceOfAnnouncementNotificationActionData: instanceOfAnnouncementNotificationActionData,
    AnnouncementNotificationActionDataFromJSON: AnnouncementNotificationActionDataFromJSON,
    AnnouncementNotificationActionDataFromJSONTyped: AnnouncementNotificationActionDataFromJSONTyped,
    AnnouncementNotificationActionDataToJSON: AnnouncementNotificationActionDataToJSON,
    instanceOfApproveManagerRequestNotification: instanceOfApproveManagerRequestNotification,
    ApproveManagerRequestNotificationFromJSON: ApproveManagerRequestNotificationFromJSON,
    ApproveManagerRequestNotificationFromJSONTyped: ApproveManagerRequestNotificationFromJSONTyped,
    ApproveManagerRequestNotificationToJSON: ApproveManagerRequestNotificationToJSON,
    instanceOfApproveManagerRequestNotificationAction: instanceOfApproveManagerRequestNotificationAction,
    ApproveManagerRequestNotificationActionFromJSON: ApproveManagerRequestNotificationActionFromJSON,
    ApproveManagerRequestNotificationActionFromJSONTyped: ApproveManagerRequestNotificationActionFromJSONTyped,
    ApproveManagerRequestNotificationActionToJSON: ApproveManagerRequestNotificationActionToJSON,
    instanceOfApproveManagerRequestNotificationActionData: instanceOfApproveManagerRequestNotificationActionData,
    ApproveManagerRequestNotificationActionDataFromJSON: ApproveManagerRequestNotificationActionDataFromJSON,
    ApproveManagerRequestNotificationActionDataFromJSONTyped: ApproveManagerRequestNotificationActionDataFromJSONTyped,
    ApproveManagerRequestNotificationActionDataToJSON: ApproveManagerRequestNotificationActionDataToJSON,
    instanceOfArtistRemixContestEndedNotification: instanceOfArtistRemixContestEndedNotification,
    ArtistRemixContestEndedNotificationFromJSON: ArtistRemixContestEndedNotificationFromJSON,
    ArtistRemixContestEndedNotificationFromJSONTyped: ArtistRemixContestEndedNotificationFromJSONTyped,
    ArtistRemixContestEndedNotificationToJSON: ArtistRemixContestEndedNotificationToJSON,
    instanceOfArtistRemixContestEndedNotificationAction: instanceOfArtistRemixContestEndedNotificationAction,
    ArtistRemixContestEndedNotificationActionFromJSON: ArtistRemixContestEndedNotificationActionFromJSON,
    ArtistRemixContestEndedNotificationActionFromJSONTyped: ArtistRemixContestEndedNotificationActionFromJSONTyped,
    ArtistRemixContestEndedNotificationActionToJSON: ArtistRemixContestEndedNotificationActionToJSON,
    instanceOfArtistRemixContestEndedNotificationActionData: instanceOfArtistRemixContestEndedNotificationActionData,
    ArtistRemixContestEndedNotificationActionDataFromJSON: ArtistRemixContestEndedNotificationActionDataFromJSON,
    ArtistRemixContestEndedNotificationActionDataFromJSONTyped: ArtistRemixContestEndedNotificationActionDataFromJSONTyped,
    ArtistRemixContestEndedNotificationActionDataToJSON: ArtistRemixContestEndedNotificationActionDataToJSON,
    instanceOfArtistRemixContestEndingSoonNotification: instanceOfArtistRemixContestEndingSoonNotification,
    ArtistRemixContestEndingSoonNotificationFromJSON: ArtistRemixContestEndingSoonNotificationFromJSON,
    ArtistRemixContestEndingSoonNotificationFromJSONTyped: ArtistRemixContestEndingSoonNotificationFromJSONTyped,
    ArtistRemixContestEndingSoonNotificationToJSON: ArtistRemixContestEndingSoonNotificationToJSON,
    instanceOfArtistRemixContestEndingSoonNotificationAction: instanceOfArtistRemixContestEndingSoonNotificationAction,
    ArtistRemixContestEndingSoonNotificationActionFromJSON: ArtistRemixContestEndingSoonNotificationActionFromJSON,
    ArtistRemixContestEndingSoonNotificationActionFromJSONTyped: ArtistRemixContestEndingSoonNotificationActionFromJSONTyped,
    ArtistRemixContestEndingSoonNotificationActionToJSON: ArtistRemixContestEndingSoonNotificationActionToJSON,
    instanceOfArtistRemixContestEndingSoonNotificationActionData: instanceOfArtistRemixContestEndingSoonNotificationActionData,
    ArtistRemixContestEndingSoonNotificationActionDataFromJSON: ArtistRemixContestEndingSoonNotificationActionDataFromJSON,
    ArtistRemixContestEndingSoonNotificationActionDataFromJSONTyped: ArtistRemixContestEndingSoonNotificationActionDataFromJSONTyped,
    ArtistRemixContestEndingSoonNotificationActionDataToJSON: ArtistRemixContestEndingSoonNotificationActionDataToJSON,
    instanceOfArtistRemixContestSubmissionsNotification: instanceOfArtistRemixContestSubmissionsNotification,
    ArtistRemixContestSubmissionsNotificationFromJSON: ArtistRemixContestSubmissionsNotificationFromJSON,
    ArtistRemixContestSubmissionsNotificationFromJSONTyped: ArtistRemixContestSubmissionsNotificationFromJSONTyped,
    ArtistRemixContestSubmissionsNotificationToJSON: ArtistRemixContestSubmissionsNotificationToJSON,
    instanceOfArtistRemixContestSubmissionsNotificationAction: instanceOfArtistRemixContestSubmissionsNotificationAction,
    ArtistRemixContestSubmissionsNotificationActionFromJSON: ArtistRemixContestSubmissionsNotificationActionFromJSON,
    ArtistRemixContestSubmissionsNotificationActionFromJSONTyped: ArtistRemixContestSubmissionsNotificationActionFromJSONTyped,
    ArtistRemixContestSubmissionsNotificationActionToJSON: ArtistRemixContestSubmissionsNotificationActionToJSON,
    instanceOfArtistRemixContestSubmissionsNotificationActionData: instanceOfArtistRemixContestSubmissionsNotificationActionData,
    ArtistRemixContestSubmissionsNotificationActionDataFromJSON: ArtistRemixContestSubmissionsNotificationActionDataFromJSON,
    ArtistRemixContestSubmissionsNotificationActionDataFromJSONTyped: ArtistRemixContestSubmissionsNotificationActionDataFromJSONTyped,
    ArtistRemixContestSubmissionsNotificationActionDataToJSON: ArtistRemixContestSubmissionsNotificationActionDataToJSON,
    instanceOfAttestation: instanceOfAttestation,
    AttestationFromJSON: AttestationFromJSON,
    AttestationFromJSONTyped: AttestationFromJSONTyped,
    AttestationToJSON: AttestationToJSON,
    instanceOfAttestationReponse: instanceOfAttestationReponse,
    AttestationReponseFromJSON: AttestationReponseFromJSON,
    AttestationReponseFromJSONTyped: AttestationReponseFromJSONTyped,
    AttestationReponseToJSON: AttestationReponseToJSON,
    instanceOfBestSellingFullResponse: instanceOfBestSellingFullResponse,
    BestSellingFullResponseFromJSON: BestSellingFullResponseFromJSON,
    BestSellingFullResponseFromJSONTyped: BestSellingFullResponseFromJSONTyped,
    BestSellingFullResponseToJSON: BestSellingFullResponseToJSON,
    BestSellingItemContentTypeEnum: BestSellingItemContentTypeEnum,
    instanceOfBestSellingItem: instanceOfBestSellingItem,
    BestSellingItemFromJSON: BestSellingItemFromJSON,
    BestSellingItemFromJSONTyped: BestSellingItemFromJSONTyped,
    BestSellingItemToJSON: BestSellingItemToJSON,
    instanceOfChallengeRewardNotification: instanceOfChallengeRewardNotification,
    ChallengeRewardNotificationFromJSON: ChallengeRewardNotificationFromJSON,
    ChallengeRewardNotificationFromJSONTyped: ChallengeRewardNotificationFromJSONTyped,
    ChallengeRewardNotificationToJSON: ChallengeRewardNotificationToJSON,
    instanceOfChallengeRewardNotificationAction: instanceOfChallengeRewardNotificationAction,
    ChallengeRewardNotificationActionFromJSON: ChallengeRewardNotificationActionFromJSON,
    ChallengeRewardNotificationActionFromJSONTyped: ChallengeRewardNotificationActionFromJSONTyped,
    ChallengeRewardNotificationActionToJSON: ChallengeRewardNotificationActionToJSON,
    instanceOfChallengeRewardNotificationActionData: instanceOfChallengeRewardNotificationActionData,
    ChallengeRewardNotificationActionDataFromJSON: ChallengeRewardNotificationActionDataFromJSON,
    ChallengeRewardNotificationActionDataFromJSONTyped: ChallengeRewardNotificationActionDataFromJSONTyped,
    ChallengeRewardNotificationActionDataToJSON: ChallengeRewardNotificationActionDataToJSON,
    instanceOfCidData: instanceOfCidData,
    CidDataFromJSON: CidDataFromJSON,
    CidDataFromJSONTyped: CidDataFromJSONTyped,
    CidDataToJSON: CidDataToJSON,
    instanceOfCidDataResponse: instanceOfCidDataResponse,
    CidDataResponseFromJSON: CidDataResponseFromJSON,
    CidDataResponseFromJSONTyped: CidDataResponseFromJSONTyped,
    CidDataResponseToJSON: CidDataResponseToJSON,
    instanceOfClaimableRewardNotification: instanceOfClaimableRewardNotification,
    ClaimableRewardNotificationFromJSON: ClaimableRewardNotificationFromJSON,
    ClaimableRewardNotificationFromJSONTyped: ClaimableRewardNotificationFromJSONTyped,
    ClaimableRewardNotificationToJSON: ClaimableRewardNotificationToJSON,
    instanceOfClaimableRewardNotificationAction: instanceOfClaimableRewardNotificationAction,
    ClaimableRewardNotificationActionFromJSON: ClaimableRewardNotificationActionFromJSON,
    ClaimableRewardNotificationActionFromJSONTyped: ClaimableRewardNotificationActionFromJSONTyped,
    ClaimableRewardNotificationActionToJSON: ClaimableRewardNotificationActionToJSON,
    instanceOfClaimableRewardNotificationActionData: instanceOfClaimableRewardNotificationActionData,
    ClaimableRewardNotificationActionDataFromJSON: ClaimableRewardNotificationActionDataFromJSON,
    ClaimableRewardNotificationActionDataFromJSONTyped: ClaimableRewardNotificationActionDataFromJSONTyped,
    ClaimableRewardNotificationActionDataToJSON: ClaimableRewardNotificationActionDataToJSON,
    instanceOfCoin: instanceOfCoin,
    CoinFromJSON: CoinFromJSON,
    CoinFromJSONTyped: CoinFromJSONTyped,
    CoinToJSON: CoinToJSON,
    instanceOfCoinResponse: instanceOfCoinResponse,
    CoinResponseFromJSON: CoinResponseFromJSON,
    CoinResponseFromJSONTyped: CoinResponseFromJSONTyped,
    CoinResponseToJSON: CoinResponseToJSON,
    instanceOfCoinsResponse: instanceOfCoinsResponse,
    CoinsResponseFromJSON: CoinsResponseFromJSON,
    CoinsResponseFromJSONTyped: CoinsResponseFromJSONTyped,
    CoinsResponseToJSON: CoinsResponseToJSON,
    CollectionActivityFullItemTypeEnum: CollectionActivityFullItemTypeEnum,
    instanceOfCollectionActivityFull: instanceOfCollectionActivityFull,
    CollectionActivityFullFromJSON: CollectionActivityFullFromJSON,
    CollectionActivityFullFromJSONTyped: CollectionActivityFullFromJSONTyped,
    CollectionActivityFullToJSON: CollectionActivityFullToJSON,
    CollectionActivityFullWithoutTracksItemTypeEnum: CollectionActivityFullWithoutTracksItemTypeEnum,
    instanceOfCollectionActivityFullWithoutTracks: instanceOfCollectionActivityFullWithoutTracks,
    CollectionActivityFullWithoutTracksFromJSON: CollectionActivityFullWithoutTracksFromJSON,
    CollectionActivityFullWithoutTracksFromJSONTyped: CollectionActivityFullWithoutTracksFromJSONTyped,
    CollectionActivityFullWithoutTracksToJSON: CollectionActivityFullWithoutTracksToJSON,
    instanceOfCollectionLibraryResponseFull: instanceOfCollectionLibraryResponseFull,
    CollectionLibraryResponseFullFromJSON: CollectionLibraryResponseFullFromJSON,
    CollectionLibraryResponseFullFromJSONTyped: CollectionLibraryResponseFullFromJSONTyped,
    CollectionLibraryResponseFullToJSON: CollectionLibraryResponseFullToJSON,
    instanceOfComment: instanceOfComment,
    CommentFromJSON: CommentFromJSON,
    CommentFromJSONTyped: CommentFromJSONTyped,
    CommentToJSON: CommentToJSON,
    instanceOfCommentMention: instanceOfCommentMention,
    CommentMentionFromJSON: CommentMentionFromJSON,
    CommentMentionFromJSONTyped: CommentMentionFromJSONTyped,
    CommentMentionToJSON: CommentMentionToJSON,
    instanceOfCommentMentionNotification: instanceOfCommentMentionNotification,
    CommentMentionNotificationFromJSON: CommentMentionNotificationFromJSON,
    CommentMentionNotificationFromJSONTyped: CommentMentionNotificationFromJSONTyped,
    CommentMentionNotificationToJSON: CommentMentionNotificationToJSON,
    instanceOfCommentMentionNotificationAction: instanceOfCommentMentionNotificationAction,
    CommentMentionNotificationActionFromJSON: CommentMentionNotificationActionFromJSON,
    CommentMentionNotificationActionFromJSONTyped: CommentMentionNotificationActionFromJSONTyped,
    CommentMentionNotificationActionToJSON: CommentMentionNotificationActionToJSON,
    CommentMentionNotificationActionDataTypeEnum: CommentMentionNotificationActionDataTypeEnum,
    instanceOfCommentMentionNotificationActionData: instanceOfCommentMentionNotificationActionData,
    CommentMentionNotificationActionDataFromJSON: CommentMentionNotificationActionDataFromJSON,
    CommentMentionNotificationActionDataFromJSONTyped: CommentMentionNotificationActionDataFromJSONTyped,
    CommentMentionNotificationActionDataToJSON: CommentMentionNotificationActionDataToJSON,
    instanceOfCommentNotification: instanceOfCommentNotification,
    CommentNotificationFromJSON: CommentNotificationFromJSON,
    CommentNotificationFromJSONTyped: CommentNotificationFromJSONTyped,
    CommentNotificationToJSON: CommentNotificationToJSON,
    instanceOfCommentNotificationAction: instanceOfCommentNotificationAction,
    CommentNotificationActionFromJSON: CommentNotificationActionFromJSON,
    CommentNotificationActionFromJSONTyped: CommentNotificationActionFromJSONTyped,
    CommentNotificationActionToJSON: CommentNotificationActionToJSON,
    CommentNotificationActionDataTypeEnum: CommentNotificationActionDataTypeEnum,
    instanceOfCommentNotificationActionData: instanceOfCommentNotificationActionData,
    CommentNotificationActionDataFromJSON: CommentNotificationActionDataFromJSON,
    CommentNotificationActionDataFromJSONTyped: CommentNotificationActionDataFromJSONTyped,
    CommentNotificationActionDataToJSON: CommentNotificationActionDataToJSON,
    instanceOfCommentReactionNotification: instanceOfCommentReactionNotification,
    CommentReactionNotificationFromJSON: CommentReactionNotificationFromJSON,
    CommentReactionNotificationFromJSONTyped: CommentReactionNotificationFromJSONTyped,
    CommentReactionNotificationToJSON: CommentReactionNotificationToJSON,
    instanceOfCommentReactionNotificationAction: instanceOfCommentReactionNotificationAction,
    CommentReactionNotificationActionFromJSON: CommentReactionNotificationActionFromJSON,
    CommentReactionNotificationActionFromJSONTyped: CommentReactionNotificationActionFromJSONTyped,
    CommentReactionNotificationActionToJSON: CommentReactionNotificationActionToJSON,
    CommentReactionNotificationActionDataTypeEnum: CommentReactionNotificationActionDataTypeEnum,
    instanceOfCommentReactionNotificationActionData: instanceOfCommentReactionNotificationActionData,
    CommentReactionNotificationActionDataFromJSON: CommentReactionNotificationActionDataFromJSON,
    CommentReactionNotificationActionDataFromJSONTyped: CommentReactionNotificationActionDataFromJSONTyped,
    CommentReactionNotificationActionDataToJSON: CommentReactionNotificationActionDataToJSON,
    instanceOfCommentRepliesResponse: instanceOfCommentRepliesResponse,
    CommentRepliesResponseFromJSON: CommentRepliesResponseFromJSON,
    CommentRepliesResponseFromJSONTyped: CommentRepliesResponseFromJSONTyped,
    CommentRepliesResponseToJSON: CommentRepliesResponseToJSON,
    instanceOfCommentResponse: instanceOfCommentResponse,
    CommentResponseFromJSON: CommentResponseFromJSON,
    CommentResponseFromJSONTyped: CommentResponseFromJSONTyped,
    CommentResponseToJSON: CommentResponseToJSON,
    instanceOfCommentThreadNotification: instanceOfCommentThreadNotification,
    CommentThreadNotificationFromJSON: CommentThreadNotificationFromJSON,
    CommentThreadNotificationFromJSONTyped: CommentThreadNotificationFromJSONTyped,
    CommentThreadNotificationToJSON: CommentThreadNotificationToJSON,
    instanceOfCommentThreadNotificationAction: instanceOfCommentThreadNotificationAction,
    CommentThreadNotificationActionFromJSON: CommentThreadNotificationActionFromJSON,
    CommentThreadNotificationActionFromJSONTyped: CommentThreadNotificationActionFromJSONTyped,
    CommentThreadNotificationActionToJSON: CommentThreadNotificationActionToJSON,
    CommentThreadNotificationActionDataTypeEnum: CommentThreadNotificationActionDataTypeEnum,
    instanceOfCommentThreadNotificationActionData: instanceOfCommentThreadNotificationActionData,
    CommentThreadNotificationActionDataFromJSON: CommentThreadNotificationActionDataFromJSON,
    CommentThreadNotificationActionDataFromJSONTyped: CommentThreadNotificationActionDataFromJSONTyped,
    CommentThreadNotificationActionDataToJSON: CommentThreadNotificationActionDataToJSON,
    instanceOfCosignNotification: instanceOfCosignNotification,
    CosignNotificationFromJSON: CosignNotificationFromJSON,
    CosignNotificationFromJSONTyped: CosignNotificationFromJSONTyped,
    CosignNotificationToJSON: CosignNotificationToJSON,
    instanceOfCosignNotificationAction: instanceOfCosignNotificationAction,
    CosignNotificationActionFromJSON: CosignNotificationActionFromJSON,
    CosignNotificationActionFromJSONTyped: CosignNotificationActionFromJSONTyped,
    CosignNotificationActionToJSON: CosignNotificationActionToJSON,
    instanceOfCosignNotificationActionData: instanceOfCosignNotificationActionData,
    CosignNotificationActionDataFromJSON: CosignNotificationActionDataFromJSON,
    CosignNotificationActionDataFromJSONTyped: CosignNotificationActionDataFromJSONTyped,
    CosignNotificationActionDataToJSON: CosignNotificationActionDataToJSON,
    instanceOfCoverArt: instanceOfCoverArt,
    CoverArtFromJSON: CoverArtFromJSON,
    CoverArtFromJSONTyped: CoverArtFromJSONTyped,
    CoverArtToJSON: CoverArtToJSON,
    instanceOfCoverPhoto: instanceOfCoverPhoto,
    CoverPhotoFromJSON: CoverPhotoFromJSON,
    CoverPhotoFromJSONTyped: CoverPhotoFromJSONTyped,
    CoverPhotoToJSON: CoverPhotoToJSON,
    instanceOfCoverPhotoFull: instanceOfCoverPhotoFull,
    CoverPhotoFullFromJSON: CoverPhotoFullFromJSON,
    CoverPhotoFullFromJSONTyped: CoverPhotoFullFromJSONTyped,
    CoverPhotoFullToJSON: CoverPhotoFullToJSON,
    instanceOfCreateCoinRequest: instanceOfCreateCoinRequest,
    CreateCoinRequestFromJSON: CreateCoinRequestFromJSON,
    CreateCoinRequestFromJSONTyped: CreateCoinRequestFromJSONTyped,
    CreateCoinRequestToJSON: CreateCoinRequestToJSON,
    instanceOfCreateCoinResponse: instanceOfCreateCoinResponse,
    CreateCoinResponseFromJSON: CreateCoinResponseFromJSON,
    CreateCoinResponseFromJSONTyped: CreateCoinResponseFromJSONTyped,
    CreateCoinResponseToJSON: CreateCoinResponseToJSON,
    instanceOfCreateCoinResponseData: instanceOfCreateCoinResponseData,
    CreateCoinResponseDataFromJSON: CreateCoinResponseDataFromJSON,
    CreateCoinResponseDataFromJSONTyped: CreateCoinResponseDataFromJSONTyped,
    CreateCoinResponseDataToJSON: CreateCoinResponseDataToJSON,
    instanceOfCreateNotification: instanceOfCreateNotification,
    CreateNotificationFromJSON: CreateNotificationFromJSON,
    CreateNotificationFromJSONTyped: CreateNotificationFromJSONTyped,
    CreateNotificationToJSON: CreateNotificationToJSON,
    instanceOfCreateNotificationAction: instanceOfCreateNotificationAction,
    CreateNotificationActionFromJSON: CreateNotificationActionFromJSON,
    CreateNotificationActionFromJSONTyped: CreateNotificationActionFromJSONTyped,
    CreateNotificationActionToJSON: CreateNotificationActionToJSON,
    CreateNotificationActionDataFromJSON: CreateNotificationActionDataFromJSON,
    CreateNotificationActionDataFromJSONTyped: CreateNotificationActionDataFromJSONTyped,
    CreateNotificationActionDataToJSON: CreateNotificationActionDataToJSON,
    instanceOfCreatePlaylistNotificationActionData: instanceOfCreatePlaylistNotificationActionData,
    CreatePlaylistNotificationActionDataFromJSON: CreatePlaylistNotificationActionDataFromJSON,
    CreatePlaylistNotificationActionDataFromJSONTyped: CreatePlaylistNotificationActionDataFromJSONTyped,
    CreatePlaylistNotificationActionDataToJSON: CreatePlaylistNotificationActionDataToJSON,
    instanceOfCreateTrackNotificationActionData: instanceOfCreateTrackNotificationActionData,
    CreateTrackNotificationActionDataFromJSON: CreateTrackNotificationActionDataFromJSON,
    CreateTrackNotificationActionDataFromJSONTyped: CreateTrackNotificationActionDataFromJSONTyped,
    CreateTrackNotificationActionDataToJSON: CreateTrackNotificationActionDataToJSON,
    instanceOfDataAndType: instanceOfDataAndType,
    DataAndTypeFromJSON: DataAndTypeFromJSON,
    DataAndTypeFromJSONTyped: DataAndTypeFromJSONTyped,
    DataAndTypeToJSON: DataAndTypeToJSON,
    instanceOfExtendedTokenGate: instanceOfExtendedTokenGate,
    ExtendedTokenGateFromJSON: ExtendedTokenGateFromJSON,
    ExtendedTokenGateFromJSONTyped: ExtendedTokenGateFromJSONTyped,
    ExtendedTokenGateToJSON: ExtendedTokenGateToJSON,
    instanceOfFanRemixContestEndedNotification: instanceOfFanRemixContestEndedNotification,
    FanRemixContestEndedNotificationFromJSON: FanRemixContestEndedNotificationFromJSON,
    FanRemixContestEndedNotificationFromJSONTyped: FanRemixContestEndedNotificationFromJSONTyped,
    FanRemixContestEndedNotificationToJSON: FanRemixContestEndedNotificationToJSON,
    instanceOfFanRemixContestEndedNotificationAction: instanceOfFanRemixContestEndedNotificationAction,
    FanRemixContestEndedNotificationActionFromJSON: FanRemixContestEndedNotificationActionFromJSON,
    FanRemixContestEndedNotificationActionFromJSONTyped: FanRemixContestEndedNotificationActionFromJSONTyped,
    FanRemixContestEndedNotificationActionToJSON: FanRemixContestEndedNotificationActionToJSON,
    instanceOfFanRemixContestEndedNotificationActionData: instanceOfFanRemixContestEndedNotificationActionData,
    FanRemixContestEndedNotificationActionDataFromJSON: FanRemixContestEndedNotificationActionDataFromJSON,
    FanRemixContestEndedNotificationActionDataFromJSONTyped: FanRemixContestEndedNotificationActionDataFromJSONTyped,
    FanRemixContestEndedNotificationActionDataToJSON: FanRemixContestEndedNotificationActionDataToJSON,
    instanceOfFanRemixContestEndingSoonNotification: instanceOfFanRemixContestEndingSoonNotification,
    FanRemixContestEndingSoonNotificationFromJSON: FanRemixContestEndingSoonNotificationFromJSON,
    FanRemixContestEndingSoonNotificationFromJSONTyped: FanRemixContestEndingSoonNotificationFromJSONTyped,
    FanRemixContestEndingSoonNotificationToJSON: FanRemixContestEndingSoonNotificationToJSON,
    instanceOfFanRemixContestEndingSoonNotificationAction: instanceOfFanRemixContestEndingSoonNotificationAction,
    FanRemixContestEndingSoonNotificationActionFromJSON: FanRemixContestEndingSoonNotificationActionFromJSON,
    FanRemixContestEndingSoonNotificationActionFromJSONTyped: FanRemixContestEndingSoonNotificationActionFromJSONTyped,
    FanRemixContestEndingSoonNotificationActionToJSON: FanRemixContestEndingSoonNotificationActionToJSON,
    instanceOfFanRemixContestEndingSoonNotificationActionData: instanceOfFanRemixContestEndingSoonNotificationActionData,
    FanRemixContestEndingSoonNotificationActionDataFromJSON: FanRemixContestEndingSoonNotificationActionDataFromJSON,
    FanRemixContestEndingSoonNotificationActionDataFromJSONTyped: FanRemixContestEndingSoonNotificationActionDataFromJSONTyped,
    FanRemixContestEndingSoonNotificationActionDataToJSON: FanRemixContestEndingSoonNotificationActionDataToJSON,
    instanceOfFanRemixContestStartedNotification: instanceOfFanRemixContestStartedNotification,
    FanRemixContestStartedNotificationFromJSON: FanRemixContestStartedNotificationFromJSON,
    FanRemixContestStartedNotificationFromJSONTyped: FanRemixContestStartedNotificationFromJSONTyped,
    FanRemixContestStartedNotificationToJSON: FanRemixContestStartedNotificationToJSON,
    instanceOfFanRemixContestStartedNotificationAction: instanceOfFanRemixContestStartedNotificationAction,
    FanRemixContestStartedNotificationActionFromJSON: FanRemixContestStartedNotificationActionFromJSON,
    FanRemixContestStartedNotificationActionFromJSONTyped: FanRemixContestStartedNotificationActionFromJSONTyped,
    FanRemixContestStartedNotificationActionToJSON: FanRemixContestStartedNotificationActionToJSON,
    instanceOfFanRemixContestStartedNotificationActionData: instanceOfFanRemixContestStartedNotificationActionData,
    FanRemixContestStartedNotificationActionDataFromJSON: FanRemixContestStartedNotificationActionDataFromJSON,
    FanRemixContestStartedNotificationActionDataFromJSONTyped: FanRemixContestStartedNotificationActionDataFromJSONTyped,
    FanRemixContestStartedNotificationActionDataToJSON: FanRemixContestStartedNotificationActionDataToJSON,
    instanceOfFanRemixContestWinnersSelectedNotification: instanceOfFanRemixContestWinnersSelectedNotification,
    FanRemixContestWinnersSelectedNotificationFromJSON: FanRemixContestWinnersSelectedNotificationFromJSON,
    FanRemixContestWinnersSelectedNotificationFromJSONTyped: FanRemixContestWinnersSelectedNotificationFromJSONTyped,
    FanRemixContestWinnersSelectedNotificationToJSON: FanRemixContestWinnersSelectedNotificationToJSON,
    instanceOfFanRemixContestWinnersSelectedNotificationAction: instanceOfFanRemixContestWinnersSelectedNotificationAction,
    FanRemixContestWinnersSelectedNotificationActionFromJSON: FanRemixContestWinnersSelectedNotificationActionFromJSON,
    FanRemixContestWinnersSelectedNotificationActionFromJSONTyped: FanRemixContestWinnersSelectedNotificationActionFromJSONTyped,
    FanRemixContestWinnersSelectedNotificationActionToJSON: FanRemixContestWinnersSelectedNotificationActionToJSON,
    instanceOfFanRemixContestWinnersSelectedNotificationActionData: instanceOfFanRemixContestWinnersSelectedNotificationActionData,
    FanRemixContestWinnersSelectedNotificationActionDataFromJSON: FanRemixContestWinnersSelectedNotificationActionDataFromJSON,
    FanRemixContestWinnersSelectedNotificationActionDataFromJSONTyped: FanRemixContestWinnersSelectedNotificationActionDataFromJSONTyped,
    FanRemixContestWinnersSelectedNotificationActionDataToJSON: FanRemixContestWinnersSelectedNotificationActionDataToJSON,
    instanceOfFavorite: instanceOfFavorite,
    FavoriteFromJSON: FavoriteFromJSON,
    FavoriteFromJSONTyped: FavoriteFromJSONTyped,
    FavoriteToJSON: FavoriteToJSON,
    instanceOfFieldVisibility: instanceOfFieldVisibility,
    FieldVisibilityFromJSON: FieldVisibilityFromJSON,
    FieldVisibilityFromJSONTyped: FieldVisibilityFromJSONTyped,
    FieldVisibilityToJSON: FieldVisibilityToJSON,
    instanceOfFollowGate: instanceOfFollowGate,
    FollowGateFromJSON: FollowGateFromJSON,
    FollowGateFromJSONTyped: FollowGateFromJSONTyped,
    FollowGateToJSON: FollowGateToJSON,
    instanceOfFollowNotification: instanceOfFollowNotification,
    FollowNotificationFromJSON: FollowNotificationFromJSON,
    FollowNotificationFromJSONTyped: FollowNotificationFromJSONTyped,
    FollowNotificationToJSON: FollowNotificationToJSON,
    instanceOfFollowNotificationAction: instanceOfFollowNotificationAction,
    FollowNotificationActionFromJSON: FollowNotificationActionFromJSON,
    FollowNotificationActionFromJSONTyped: FollowNotificationActionFromJSONTyped,
    FollowNotificationActionToJSON: FollowNotificationActionToJSON,
    instanceOfFollowNotificationActionData: instanceOfFollowNotificationActionData,
    FollowNotificationActionDataFromJSON: FollowNotificationActionDataFromJSON,
    FollowNotificationActionDataFromJSONTyped: FollowNotificationActionDataFromJSONTyped,
    FollowNotificationActionDataToJSON: FollowNotificationActionDataToJSON,
    instanceOfFollowingResponse: instanceOfFollowingResponse,
    FollowingResponseFromJSON: FollowingResponseFromJSON,
    FollowingResponseFromJSONTyped: FollowingResponseFromJSONTyped,
    FollowingResponseToJSON: FollowingResponseToJSON,
    instanceOfFollowingResponseFull: instanceOfFollowingResponseFull,
    FollowingResponseFullFromJSON: FollowingResponseFullFromJSON,
    FollowingResponseFullFromJSONTyped: FollowingResponseFullFromJSONTyped,
    FollowingResponseFullToJSON: FollowingResponseFullToJSON,
    instanceOfFullBulkSubscribersResponse: instanceOfFullBulkSubscribersResponse,
    FullBulkSubscribersResponseFromJSON: FullBulkSubscribersResponseFromJSON,
    FullBulkSubscribersResponseFromJSONTyped: FullBulkSubscribersResponseFromJSONTyped,
    FullBulkSubscribersResponseToJSON: FullBulkSubscribersResponseToJSON,
    instanceOfFullFollowersResponse: instanceOfFullFollowersResponse,
    FullFollowersResponseFromJSON: FullFollowersResponseFromJSON,
    FullFollowersResponseFromJSONTyped: FullFollowersResponseFromJSONTyped,
    FullFollowersResponseToJSON: FullFollowersResponseToJSON,
    instanceOfFullGetSupportedUsers: instanceOfFullGetSupportedUsers,
    FullGetSupportedUsersFromJSON: FullGetSupportedUsersFromJSON,
    FullGetSupportedUsersFromJSONTyped: FullGetSupportedUsersFromJSONTyped,
    FullGetSupportedUsersToJSON: FullGetSupportedUsersToJSON,
    instanceOfFullGetSupporter: instanceOfFullGetSupporter,
    FullGetSupporterFromJSON: FullGetSupporterFromJSON,
    FullGetSupporterFromJSONTyped: FullGetSupporterFromJSONTyped,
    FullGetSupporterToJSON: FullGetSupporterToJSON,
    instanceOfFullGetSupporters: instanceOfFullGetSupporters,
    FullGetSupportersFromJSON: FullGetSupportersFromJSON,
    FullGetSupportersFromJSONTyped: FullGetSupportersFromJSONTyped,
    FullGetSupportersToJSON: FullGetSupportersToJSON,
    instanceOfFullGetSupporting: instanceOfFullGetSupporting,
    FullGetSupportingFromJSON: FullGetSupportingFromJSON,
    FullGetSupportingFromJSONTyped: FullGetSupportingFromJSONTyped,
    FullGetSupportingToJSON: FullGetSupportingToJSON,
    instanceOfFullMutualFollowersResponse: instanceOfFullMutualFollowersResponse,
    FullMutualFollowersResponseFromJSON: FullMutualFollowersResponseFromJSON,
    FullMutualFollowersResponseFromJSONTyped: FullMutualFollowersResponseFromJSONTyped,
    FullMutualFollowersResponseToJSON: FullMutualFollowersResponseToJSON,
    instanceOfFullPlaylistResponse: instanceOfFullPlaylistResponse,
    FullPlaylistResponseFromJSON: FullPlaylistResponseFromJSON,
    FullPlaylistResponseFromJSONTyped: FullPlaylistResponseFromJSONTyped,
    FullPlaylistResponseToJSON: FullPlaylistResponseToJSON,
    instanceOfFullPlaylistTracksResponse: instanceOfFullPlaylistTracksResponse,
    FullPlaylistTracksResponseFromJSON: FullPlaylistTracksResponseFromJSON,
    FullPlaylistTracksResponseFromJSONTyped: FullPlaylistTracksResponseFromJSONTyped,
    FullPlaylistTracksResponseToJSON: FullPlaylistTracksResponseToJSON,
    instanceOfFullPurchasersResponse: instanceOfFullPurchasersResponse,
    FullPurchasersResponseFromJSON: FullPurchasersResponseFromJSON,
    FullPurchasersResponseFromJSONTyped: FullPurchasersResponseFromJSONTyped,
    FullPurchasersResponseToJSON: FullPurchasersResponseToJSON,
    instanceOfFullRemix: instanceOfFullRemix,
    FullRemixFromJSON: FullRemixFromJSON,
    FullRemixFromJSONTyped: FullRemixFromJSONTyped,
    FullRemixToJSON: FullRemixToJSON,
    instanceOfFullRemixParent: instanceOfFullRemixParent,
    FullRemixParentFromJSON: FullRemixParentFromJSON,
    FullRemixParentFromJSONTyped: FullRemixParentFromJSONTyped,
    FullRemixParentToJSON: FullRemixParentToJSON,
    instanceOfFullRemixersResponse: instanceOfFullRemixersResponse,
    FullRemixersResponseFromJSON: FullRemixersResponseFromJSON,
    FullRemixersResponseFromJSONTyped: FullRemixersResponseFromJSONTyped,
    FullRemixersResponseToJSON: FullRemixersResponseToJSON,
    instanceOfFullReposts: instanceOfFullReposts,
    FullRepostsFromJSON: FullRepostsFromJSON,
    FullRepostsFromJSONTyped: FullRepostsFromJSONTyped,
    FullRepostsToJSON: FullRepostsToJSON,
    instanceOfFullSubscribersResponse: instanceOfFullSubscribersResponse,
    FullSubscribersResponseFromJSON: FullSubscribersResponseFromJSON,
    FullSubscribersResponseFromJSONTyped: FullSubscribersResponseFromJSONTyped,
    FullSubscribersResponseToJSON: FullSubscribersResponseToJSON,
    instanceOfFullSupporter: instanceOfFullSupporter,
    FullSupporterFromJSON: FullSupporterFromJSON,
    FullSupporterFromJSONTyped: FullSupporterFromJSONTyped,
    FullSupporterToJSON: FullSupporterToJSON,
    instanceOfFullSupporting: instanceOfFullSupporting,
    FullSupportingFromJSON: FullSupportingFromJSON,
    FullSupportingFromJSONTyped: FullSupportingFromJSONTyped,
    FullSupportingToJSON: FullSupportingToJSON,
    instanceOfFullTip: instanceOfFullTip,
    FullTipFromJSON: FullTipFromJSON,
    FullTipFromJSONTyped: FullTipFromJSONTyped,
    FullTipToJSON: FullTipToJSON,
    instanceOfFullTopListener: instanceOfFullTopListener,
    FullTopListenerFromJSON: FullTopListenerFromJSON,
    FullTopListenerFromJSONTyped: FullTopListenerFromJSONTyped,
    FullTopListenerToJSON: FullTopListenerToJSON,
    instanceOfFullTrackResponse: instanceOfFullTrackResponse,
    FullTrackResponseFromJSON: FullTrackResponseFromJSON,
    FullTrackResponseFromJSONTyped: FullTrackResponseFromJSONTyped,
    FullTrackResponseToJSON: FullTrackResponseToJSON,
    instanceOfFullTracks: instanceOfFullTracks,
    FullTracksFromJSON: FullTracksFromJSON,
    FullTracksFromJSONTyped: FullTracksFromJSONTyped,
    FullTracksToJSON: FullTracksToJSON,
    instanceOfFullTracksResponse: instanceOfFullTracksResponse,
    FullTracksResponseFromJSON: FullTracksResponseFromJSON,
    FullTracksResponseFromJSONTyped: FullTracksResponseFromJSONTyped,
    FullTracksResponseToJSON: FullTracksResponseToJSON,
    instanceOfFullTrendingPlaylistsResponse: instanceOfFullTrendingPlaylistsResponse,
    FullTrendingPlaylistsResponseFromJSON: FullTrendingPlaylistsResponseFromJSON,
    FullTrendingPlaylistsResponseFromJSONTyped: FullTrendingPlaylistsResponseFromJSONTyped,
    FullTrendingPlaylistsResponseToJSON: FullTrendingPlaylistsResponseToJSON,
    instanceOfFullUserResponse: instanceOfFullUserResponse,
    FullUserResponseFromJSON: FullUserResponseFromJSON,
    FullUserResponseFromJSONTyped: FullUserResponseFromJSONTyped,
    FullUserResponseToJSON: FullUserResponseToJSON,
    instanceOfGetTipsResponse: instanceOfGetTipsResponse,
    GetTipsResponseFromJSON: GetTipsResponseFromJSON,
    GetTipsResponseFromJSONTyped: GetTipsResponseFromJSONTyped,
    GetTipsResponseToJSON: GetTipsResponseToJSON,
    instanceOfGrant: instanceOfGrant,
    GrantFromJSON: GrantFromJSON,
    GrantFromJSONTyped: GrantFromJSONTyped,
    GrantToJSON: GrantToJSON,
    instanceOfHistoryResponseFull: instanceOfHistoryResponseFull,
    HistoryResponseFullFromJSON: HistoryResponseFullFromJSON,
    HistoryResponseFullFromJSONTyped: HistoryResponseFullFromJSONTyped,
    HistoryResponseFullToJSON: HistoryResponseFullToJSON,
    instanceOfListenStreakReminderNotification: instanceOfListenStreakReminderNotification,
    ListenStreakReminderNotificationFromJSON: ListenStreakReminderNotificationFromJSON,
    ListenStreakReminderNotificationFromJSONTyped: ListenStreakReminderNotificationFromJSONTyped,
    ListenStreakReminderNotificationToJSON: ListenStreakReminderNotificationToJSON,
    instanceOfListenStreakReminderNotificationAction: instanceOfListenStreakReminderNotificationAction,
    ListenStreakReminderNotificationActionFromJSON: ListenStreakReminderNotificationActionFromJSON,
    ListenStreakReminderNotificationActionFromJSONTyped: ListenStreakReminderNotificationActionFromJSONTyped,
    ListenStreakReminderNotificationActionToJSON: ListenStreakReminderNotificationActionToJSON,
    instanceOfListenStreakReminderNotificationActionData: instanceOfListenStreakReminderNotificationActionData,
    ListenStreakReminderNotificationActionDataFromJSON: ListenStreakReminderNotificationActionDataFromJSON,
    ListenStreakReminderNotificationActionDataFromJSONTyped: ListenStreakReminderNotificationActionDataFromJSONTyped,
    ListenStreakReminderNotificationActionDataToJSON: ListenStreakReminderNotificationActionDataToJSON,
    instanceOfManagedUser: instanceOfManagedUser,
    ManagedUserFromJSON: ManagedUserFromJSON,
    ManagedUserFromJSONTyped: ManagedUserFromJSONTyped,
    ManagedUserToJSON: ManagedUserToJSON,
    instanceOfManagedUsersResponse: instanceOfManagedUsersResponse,
    ManagedUsersResponseFromJSON: ManagedUsersResponseFromJSON,
    ManagedUsersResponseFromJSONTyped: ManagedUsersResponseFromJSONTyped,
    ManagedUsersResponseToJSON: ManagedUsersResponseToJSON,
    instanceOfManagersResponse: instanceOfManagersResponse,
    ManagersResponseFromJSON: ManagersResponseFromJSON,
    ManagersResponseFromJSONTyped: ManagersResponseFromJSONTyped,
    ManagersResponseToJSON: ManagersResponseToJSON,
    instanceOfMilestoneNotification: instanceOfMilestoneNotification,
    MilestoneNotificationFromJSON: MilestoneNotificationFromJSON,
    MilestoneNotificationFromJSONTyped: MilestoneNotificationFromJSONTyped,
    MilestoneNotificationToJSON: MilestoneNotificationToJSON,
    instanceOfMilestoneNotificationAction: instanceOfMilestoneNotificationAction,
    MilestoneNotificationActionFromJSON: MilestoneNotificationActionFromJSON,
    MilestoneNotificationActionFromJSONTyped: MilestoneNotificationActionFromJSONTyped,
    MilestoneNotificationActionToJSON: MilestoneNotificationActionToJSON,
    MilestoneNotificationActionDataFromJSON: MilestoneNotificationActionDataFromJSON,
    MilestoneNotificationActionDataFromJSONTyped: MilestoneNotificationActionDataFromJSONTyped,
    MilestoneNotificationActionDataToJSON: MilestoneNotificationActionDataToJSON,
    NftCollectionChainEnum: NftCollectionChainEnum,
    NftCollectionStandardEnum: NftCollectionStandardEnum,
    instanceOfNftCollection: instanceOfNftCollection,
    NftCollectionFromJSON: NftCollectionFromJSON,
    NftCollectionFromJSONTyped: NftCollectionFromJSONTyped,
    NftCollectionToJSON: NftCollectionToJSON,
    instanceOfNftGate: instanceOfNftGate,
    NftGateFromJSON: NftGateFromJSON,
    NftGateFromJSONTyped: NftGateFromJSONTyped,
    NftGateToJSON: NftGateToJSON,
    NotificationFromJSON: NotificationFromJSON,
    NotificationFromJSONTyped: NotificationFromJSONTyped,
    NotificationToJSON: NotificationToJSON,
    instanceOfNotifications: instanceOfNotifications,
    NotificationsFromJSON: NotificationsFromJSON,
    NotificationsFromJSONTyped: NotificationsFromJSONTyped,
    NotificationsToJSON: NotificationsToJSON,
    instanceOfNotificationsResponse: instanceOfNotificationsResponse,
    NotificationsResponseFromJSON: NotificationsResponseFromJSON,
    NotificationsResponseFromJSONTyped: NotificationsResponseFromJSONTyped,
    NotificationsResponseToJSON: NotificationsResponseToJSON,
    instanceOfPlaylistAddedTimestamp: instanceOfPlaylistAddedTimestamp,
    PlaylistAddedTimestampFromJSON: PlaylistAddedTimestampFromJSON,
    PlaylistAddedTimestampFromJSONTyped: PlaylistAddedTimestampFromJSONTyped,
    PlaylistAddedTimestampToJSON: PlaylistAddedTimestampToJSON,
    instanceOfPlaylistArtwork: instanceOfPlaylistArtwork,
    PlaylistArtworkFromJSON: PlaylistArtworkFromJSON,
    PlaylistArtworkFromJSONTyped: PlaylistArtworkFromJSONTyped,
    PlaylistArtworkToJSON: PlaylistArtworkToJSON,
    instanceOfPlaylistArtworkFull: instanceOfPlaylistArtworkFull,
    PlaylistArtworkFullFromJSON: PlaylistArtworkFullFromJSON,
    PlaylistArtworkFullFromJSONTyped: PlaylistArtworkFullFromJSONTyped,
    PlaylistArtworkFullToJSON: PlaylistArtworkFullToJSON,
    instanceOfPlaylistFeedItem: instanceOfPlaylistFeedItem,
    PlaylistFeedItemFromJSON: PlaylistFeedItemFromJSON,
    PlaylistFeedItemFromJSONTyped: PlaylistFeedItemFromJSONTyped,
    PlaylistFeedItemToJSON: PlaylistFeedItemToJSON,
    instanceOfPlaylistFull: instanceOfPlaylistFull,
    PlaylistFullFromJSON: PlaylistFullFromJSON,
    PlaylistFullFromJSONTyped: PlaylistFullFromJSONTyped,
    PlaylistFullToJSON: PlaylistFullToJSON,
    instanceOfPlaylistFullWithoutTracks: instanceOfPlaylistFullWithoutTracks,
    PlaylistFullWithoutTracksFromJSON: PlaylistFullWithoutTracksFromJSON,
    PlaylistFullWithoutTracksFromJSONTyped: PlaylistFullWithoutTracksFromJSONTyped,
    PlaylistFullWithoutTracksToJSON: PlaylistFullWithoutTracksToJSON,
    instanceOfPlaylistLibrary: instanceOfPlaylistLibrary,
    PlaylistLibraryFromJSON: PlaylistLibraryFromJSON,
    PlaylistLibraryFromJSONTyped: PlaylistLibraryFromJSONTyped,
    PlaylistLibraryToJSON: PlaylistLibraryToJSON,
    instanceOfPlaylistMilestoneNotificationActionData: instanceOfPlaylistMilestoneNotificationActionData,
    PlaylistMilestoneNotificationActionDataFromJSON: PlaylistMilestoneNotificationActionDataFromJSON,
    PlaylistMilestoneNotificationActionDataFromJSONTyped: PlaylistMilestoneNotificationActionDataFromJSONTyped,
    PlaylistMilestoneNotificationActionDataToJSON: PlaylistMilestoneNotificationActionDataToJSON,
    instanceOfPlaylistUpdate: instanceOfPlaylistUpdate,
    PlaylistUpdateFromJSON: PlaylistUpdateFromJSON,
    PlaylistUpdateFromJSONTyped: PlaylistUpdateFromJSONTyped,
    PlaylistUpdateToJSON: PlaylistUpdateToJSON,
    instanceOfPlaylistUpdates: instanceOfPlaylistUpdates,
    PlaylistUpdatesFromJSON: PlaylistUpdatesFromJSON,
    PlaylistUpdatesFromJSONTyped: PlaylistUpdatesFromJSONTyped,
    PlaylistUpdatesToJSON: PlaylistUpdatesToJSON,
    instanceOfPlaylistUpdatesResponse: instanceOfPlaylistUpdatesResponse,
    PlaylistUpdatesResponseFromJSON: PlaylistUpdatesResponseFromJSON,
    PlaylistUpdatesResponseFromJSONTyped: PlaylistUpdatesResponseFromJSONTyped,
    PlaylistUpdatesResponseToJSON: PlaylistUpdatesResponseToJSON,
    instanceOfPlaylistsResponseFull: instanceOfPlaylistsResponseFull,
    PlaylistsResponseFullFromJSON: PlaylistsResponseFullFromJSON,
    PlaylistsResponseFullFromJSONTyped: PlaylistsResponseFullFromJSONTyped,
    PlaylistsResponseFullToJSON: PlaylistsResponseFullToJSON,
    instanceOfProfilePicture: instanceOfProfilePicture,
    ProfilePictureFromJSON: ProfilePictureFromJSON,
    ProfilePictureFromJSONTyped: ProfilePictureFromJSONTyped,
    ProfilePictureToJSON: ProfilePictureToJSON,
    instanceOfProfilePictureFull: instanceOfProfilePictureFull,
    ProfilePictureFullFromJSON: ProfilePictureFullFromJSON,
    ProfilePictureFullFromJSONTyped: ProfilePictureFullFromJSONTyped,
    ProfilePictureFullToJSON: ProfilePictureFullToJSON,
    instanceOfPurchase: instanceOfPurchase,
    PurchaseFromJSON: PurchaseFromJSON,
    PurchaseFromJSONTyped: PurchaseFromJSONTyped,
    PurchaseToJSON: PurchaseToJSON,
    instanceOfPurchaseGate: instanceOfPurchaseGate,
    PurchaseGateFromJSON: PurchaseGateFromJSON,
    PurchaseGateFromJSONTyped: PurchaseGateFromJSONTyped,
    PurchaseGateToJSON: PurchaseGateToJSON,
    instanceOfPurchaseSplit: instanceOfPurchaseSplit,
    PurchaseSplitFromJSON: PurchaseSplitFromJSON,
    PurchaseSplitFromJSONTyped: PurchaseSplitFromJSONTyped,
    PurchaseSplitToJSON: PurchaseSplitToJSON,
    instanceOfPurchasersCountResponse: instanceOfPurchasersCountResponse,
    PurchasersCountResponseFromJSON: PurchasersCountResponseFromJSON,
    PurchasersCountResponseFromJSONTyped: PurchasersCountResponseFromJSONTyped,
    PurchasersCountResponseToJSON: PurchasersCountResponseToJSON,
    instanceOfPurchasesCountResponse: instanceOfPurchasesCountResponse,
    PurchasesCountResponseFromJSON: PurchasesCountResponseFromJSON,
    PurchasesCountResponseFromJSONTyped: PurchasesCountResponseFromJSONTyped,
    PurchasesCountResponseToJSON: PurchasesCountResponseToJSON,
    instanceOfPurchasesResponse: instanceOfPurchasesResponse,
    PurchasesResponseFromJSON: PurchasesResponseFromJSON,
    PurchasesResponseFromJSONTyped: PurchasesResponseFromJSONTyped,
    PurchasesResponseToJSON: PurchasesResponseToJSON,
    instanceOfReaction: instanceOfReaction,
    ReactionFromJSON: ReactionFromJSON,
    ReactionFromJSONTyped: ReactionFromJSONTyped,
    ReactionToJSON: ReactionToJSON,
    instanceOfReactionNotification: instanceOfReactionNotification,
    ReactionNotificationFromJSON: ReactionNotificationFromJSON,
    ReactionNotificationFromJSONTyped: ReactionNotificationFromJSONTyped,
    ReactionNotificationToJSON: ReactionNotificationToJSON,
    instanceOfReactionNotificationAction: instanceOfReactionNotificationAction,
    ReactionNotificationActionFromJSON: ReactionNotificationActionFromJSON,
    ReactionNotificationActionFromJSONTyped: ReactionNotificationActionFromJSONTyped,
    ReactionNotificationActionToJSON: ReactionNotificationActionToJSON,
    instanceOfReactionNotificationActionData: instanceOfReactionNotificationActionData,
    ReactionNotificationActionDataFromJSON: ReactionNotificationActionDataFromJSON,
    ReactionNotificationActionDataFromJSONTyped: ReactionNotificationActionDataFromJSONTyped,
    ReactionNotificationActionDataToJSON: ReactionNotificationActionDataToJSON,
    instanceOfReactions: instanceOfReactions,
    ReactionsFromJSON: ReactionsFromJSON,
    ReactionsFromJSONTyped: ReactionsFromJSONTyped,
    ReactionsToJSON: ReactionsToJSON,
    instanceOfReceiveTipNotification: instanceOfReceiveTipNotification,
    ReceiveTipNotificationFromJSON: ReceiveTipNotificationFromJSON,
    ReceiveTipNotificationFromJSONTyped: ReceiveTipNotificationFromJSONTyped,
    ReceiveTipNotificationToJSON: ReceiveTipNotificationToJSON,
    instanceOfReceiveTipNotificationAction: instanceOfReceiveTipNotificationAction,
    ReceiveTipNotificationActionFromJSON: ReceiveTipNotificationActionFromJSON,
    ReceiveTipNotificationActionFromJSONTyped: ReceiveTipNotificationActionFromJSONTyped,
    ReceiveTipNotificationActionToJSON: ReceiveTipNotificationActionToJSON,
    instanceOfReceiveTipNotificationActionData: instanceOfReceiveTipNotificationActionData,
    ReceiveTipNotificationActionDataFromJSON: ReceiveTipNotificationActionDataFromJSON,
    ReceiveTipNotificationActionDataFromJSONTyped: ReceiveTipNotificationActionDataFromJSONTyped,
    ReceiveTipNotificationActionDataToJSON: ReceiveTipNotificationActionDataToJSON,
    instanceOfRelated: instanceOfRelated,
    RelatedFromJSON: RelatedFromJSON,
    RelatedFromJSONTyped: RelatedFromJSONTyped,
    RelatedToJSON: RelatedToJSON,
    instanceOfRelatedArtistResponseFull: instanceOfRelatedArtistResponseFull,
    RelatedArtistResponseFullFromJSON: RelatedArtistResponseFullFromJSON,
    RelatedArtistResponseFullFromJSONTyped: RelatedArtistResponseFullFromJSONTyped,
    RelatedArtistResponseFullToJSON: RelatedArtistResponseFullToJSON,
    instanceOfRemixNotification: instanceOfRemixNotification,
    RemixNotificationFromJSON: RemixNotificationFromJSON,
    RemixNotificationFromJSONTyped: RemixNotificationFromJSONTyped,
    RemixNotificationToJSON: RemixNotificationToJSON,
    instanceOfRemixNotificationAction: instanceOfRemixNotificationAction,
    RemixNotificationActionFromJSON: RemixNotificationActionFromJSON,
    RemixNotificationActionFromJSONTyped: RemixNotificationActionFromJSONTyped,
    RemixNotificationActionToJSON: RemixNotificationActionToJSON,
    instanceOfRemixNotificationActionData: instanceOfRemixNotificationActionData,
    RemixNotificationActionDataFromJSON: RemixNotificationActionDataFromJSON,
    RemixNotificationActionDataFromJSONTyped: RemixNotificationActionDataFromJSONTyped,
    RemixNotificationActionDataToJSON: RemixNotificationActionDataToJSON,
    instanceOfRemixablesResponse: instanceOfRemixablesResponse,
    RemixablesResponseFromJSON: RemixablesResponseFromJSON,
    RemixablesResponseFromJSONTyped: RemixablesResponseFromJSONTyped,
    RemixablesResponseToJSON: RemixablesResponseToJSON,
    instanceOfRemixersCountResponse: instanceOfRemixersCountResponse,
    RemixersCountResponseFromJSON: RemixersCountResponseFromJSON,
    RemixersCountResponseFromJSONTyped: RemixersCountResponseFromJSONTyped,
    RemixersCountResponseToJSON: RemixersCountResponseToJSON,
    instanceOfRemixesResponse: instanceOfRemixesResponse,
    RemixesResponseFromJSON: RemixesResponseFromJSON,
    RemixesResponseFromJSONTyped: RemixesResponseFromJSONTyped,
    RemixesResponseToJSON: RemixesResponseToJSON,
    instanceOfRemixesResponseFull: instanceOfRemixesResponseFull,
    RemixesResponseFullFromJSON: RemixesResponseFullFromJSON,
    RemixesResponseFullFromJSONTyped: RemixesResponseFullFromJSONTyped,
    RemixesResponseFullToJSON: RemixesResponseFullToJSON,
    instanceOfRemixingResponse: instanceOfRemixingResponse,
    RemixingResponseFromJSON: RemixingResponseFromJSON,
    RemixingResponseFromJSONTyped: RemixingResponseFromJSONTyped,
    RemixingResponseToJSON: RemixingResponseToJSON,
    instanceOfReplyComment: instanceOfReplyComment,
    ReplyCommentFromJSON: ReplyCommentFromJSON,
    ReplyCommentFromJSONTyped: ReplyCommentFromJSONTyped,
    ReplyCommentToJSON: ReplyCommentToJSON,
    instanceOfRepost: instanceOfRepost,
    RepostFromJSON: RepostFromJSON,
    RepostFromJSONTyped: RepostFromJSONTyped,
    RepostToJSON: RepostToJSON,
    instanceOfRepostNotification: instanceOfRepostNotification,
    RepostNotificationFromJSON: RepostNotificationFromJSON,
    RepostNotificationFromJSONTyped: RepostNotificationFromJSONTyped,
    RepostNotificationToJSON: RepostNotificationToJSON,
    instanceOfRepostNotificationAction: instanceOfRepostNotificationAction,
    RepostNotificationActionFromJSON: RepostNotificationActionFromJSON,
    RepostNotificationActionFromJSONTyped: RepostNotificationActionFromJSONTyped,
    RepostNotificationActionToJSON: RepostNotificationActionToJSON,
    RepostNotificationActionDataTypeEnum: RepostNotificationActionDataTypeEnum,
    instanceOfRepostNotificationActionData: instanceOfRepostNotificationActionData,
    RepostNotificationActionDataFromJSON: RepostNotificationActionDataFromJSON,
    RepostNotificationActionDataFromJSONTyped: RepostNotificationActionDataFromJSONTyped,
    RepostNotificationActionDataToJSON: RepostNotificationActionDataToJSON,
    instanceOfRepostOfRepostNotification: instanceOfRepostOfRepostNotification,
    RepostOfRepostNotificationFromJSON: RepostOfRepostNotificationFromJSON,
    RepostOfRepostNotificationFromJSONTyped: RepostOfRepostNotificationFromJSONTyped,
    RepostOfRepostNotificationToJSON: RepostOfRepostNotificationToJSON,
    instanceOfRepostOfRepostNotificationAction: instanceOfRepostOfRepostNotificationAction,
    RepostOfRepostNotificationActionFromJSON: RepostOfRepostNotificationActionFromJSON,
    RepostOfRepostNotificationActionFromJSONTyped: RepostOfRepostNotificationActionFromJSONTyped,
    RepostOfRepostNotificationActionToJSON: RepostOfRepostNotificationActionToJSON,
    RepostOfRepostNotificationActionDataTypeEnum: RepostOfRepostNotificationActionDataTypeEnum,
    instanceOfRepostOfRepostNotificationActionData: instanceOfRepostOfRepostNotificationActionData,
    RepostOfRepostNotificationActionDataFromJSON: RepostOfRepostNotificationActionDataFromJSON,
    RepostOfRepostNotificationActionDataFromJSONTyped: RepostOfRepostNotificationActionDataFromJSONTyped,
    RepostOfRepostNotificationActionDataToJSON: RepostOfRepostNotificationActionDataToJSON,
    instanceOfRequestManagerNotification: instanceOfRequestManagerNotification,
    RequestManagerNotificationFromJSON: RequestManagerNotificationFromJSON,
    RequestManagerNotificationFromJSONTyped: RequestManagerNotificationFromJSONTyped,
    RequestManagerNotificationToJSON: RequestManagerNotificationToJSON,
    instanceOfRequestManagerNotificationAction: instanceOfRequestManagerNotificationAction,
    RequestManagerNotificationActionFromJSON: RequestManagerNotificationActionFromJSON,
    RequestManagerNotificationActionFromJSONTyped: RequestManagerNotificationActionFromJSONTyped,
    RequestManagerNotificationActionToJSON: RequestManagerNotificationActionToJSON,
    instanceOfRequestManagerNotificationActionData: instanceOfRequestManagerNotificationActionData,
    RequestManagerNotificationActionDataFromJSON: RequestManagerNotificationActionDataFromJSON,
    RequestManagerNotificationActionDataFromJSONTyped: RequestManagerNotificationActionDataFromJSONTyped,
    RequestManagerNotificationActionDataToJSON: RequestManagerNotificationActionDataToJSON,
    instanceOfSaveNotification: instanceOfSaveNotification,
    SaveNotificationFromJSON: SaveNotificationFromJSON,
    SaveNotificationFromJSONTyped: SaveNotificationFromJSONTyped,
    SaveNotificationToJSON: SaveNotificationToJSON,
    instanceOfSaveNotificationAction: instanceOfSaveNotificationAction,
    SaveNotificationActionFromJSON: SaveNotificationActionFromJSON,
    SaveNotificationActionFromJSONTyped: SaveNotificationActionFromJSONTyped,
    SaveNotificationActionToJSON: SaveNotificationActionToJSON,
    SaveNotificationActionDataTypeEnum: SaveNotificationActionDataTypeEnum,
    instanceOfSaveNotificationActionData: instanceOfSaveNotificationActionData,
    SaveNotificationActionDataFromJSON: SaveNotificationActionDataFromJSON,
    SaveNotificationActionDataFromJSONTyped: SaveNotificationActionDataFromJSONTyped,
    SaveNotificationActionDataToJSON: SaveNotificationActionDataToJSON,
    instanceOfSaveOfRepostNotification: instanceOfSaveOfRepostNotification,
    SaveOfRepostNotificationFromJSON: SaveOfRepostNotificationFromJSON,
    SaveOfRepostNotificationFromJSONTyped: SaveOfRepostNotificationFromJSONTyped,
    SaveOfRepostNotificationToJSON: SaveOfRepostNotificationToJSON,
    instanceOfSaveOfRepostNotificationAction: instanceOfSaveOfRepostNotificationAction,
    SaveOfRepostNotificationActionFromJSON: SaveOfRepostNotificationActionFromJSON,
    SaveOfRepostNotificationActionFromJSONTyped: SaveOfRepostNotificationActionFromJSONTyped,
    SaveOfRepostNotificationActionToJSON: SaveOfRepostNotificationActionToJSON,
    SaveOfRepostNotificationActionDataTypeEnum: SaveOfRepostNotificationActionDataTypeEnum,
    instanceOfSaveOfRepostNotificationActionData: instanceOfSaveOfRepostNotificationActionData,
    SaveOfRepostNotificationActionDataFromJSON: SaveOfRepostNotificationActionDataFromJSON,
    SaveOfRepostNotificationActionDataFromJSONTyped: SaveOfRepostNotificationActionDataFromJSONTyped,
    SaveOfRepostNotificationActionDataToJSON: SaveOfRepostNotificationActionDataToJSON,
    instanceOfSearchAutocompleteResponse: instanceOfSearchAutocompleteResponse,
    SearchAutocompleteResponseFromJSON: SearchAutocompleteResponseFromJSON,
    SearchAutocompleteResponseFromJSONTyped: SearchAutocompleteResponseFromJSONTyped,
    SearchAutocompleteResponseToJSON: SearchAutocompleteResponseToJSON,
    instanceOfSearchFullResponse: instanceOfSearchFullResponse,
    SearchFullResponseFromJSON: SearchFullResponseFromJSON,
    SearchFullResponseFromJSONTyped: SearchFullResponseFromJSONTyped,
    SearchFullResponseToJSON: SearchFullResponseToJSON,
    instanceOfSearchModel: instanceOfSearchModel,
    SearchModelFromJSON: SearchModelFromJSON,
    SearchModelFromJSONTyped: SearchModelFromJSONTyped,
    SearchModelToJSON: SearchModelToJSON,
    instanceOfSearchPlaylistFull: instanceOfSearchPlaylistFull,
    SearchPlaylistFullFromJSON: SearchPlaylistFullFromJSON,
    SearchPlaylistFullFromJSONTyped: SearchPlaylistFullFromJSONTyped,
    SearchPlaylistFullToJSON: SearchPlaylistFullToJSON,
    instanceOfSearchTrackFull: instanceOfSearchTrackFull,
    SearchTrackFullFromJSON: SearchTrackFullFromJSON,
    SearchTrackFullFromJSONTyped: SearchTrackFullFromJSONTyped,
    SearchTrackFullToJSON: SearchTrackFullToJSON,
    instanceOfSendTipNotification: instanceOfSendTipNotification,
    SendTipNotificationFromJSON: SendTipNotificationFromJSON,
    SendTipNotificationFromJSONTyped: SendTipNotificationFromJSONTyped,
    SendTipNotificationToJSON: SendTipNotificationToJSON,
    instanceOfSendTipNotificationAction: instanceOfSendTipNotificationAction,
    SendTipNotificationActionFromJSON: SendTipNotificationActionFromJSON,
    SendTipNotificationActionFromJSONTyped: SendTipNotificationActionFromJSONTyped,
    SendTipNotificationActionToJSON: SendTipNotificationActionToJSON,
    instanceOfSendTipNotificationActionData: instanceOfSendTipNotificationActionData,
    SendTipNotificationActionDataFromJSON: SendTipNotificationActionDataFromJSON,
    SendTipNotificationActionDataFromJSONTyped: SendTipNotificationActionDataFromJSONTyped,
    SendTipNotificationActionDataToJSON: SendTipNotificationActionDataToJSON,
    instanceOfStemFull: instanceOfStemFull,
    StemFullFromJSON: StemFullFromJSON,
    StemFullFromJSONTyped: StemFullFromJSONTyped,
    StemFullToJSON: StemFullToJSON,
    instanceOfStemParent: instanceOfStemParent,
    StemParentFromJSON: StemParentFromJSON,
    StemParentFromJSONTyped: StemParentFromJSONTyped,
    StemParentToJSON: StemParentToJSON,
    instanceOfStemsResponse: instanceOfStemsResponse,
    StemsResponseFromJSON: StemsResponseFromJSON,
    StemsResponseFromJSONTyped: StemsResponseFromJSONTyped,
    StemsResponseToJSON: StemsResponseToJSON,
    instanceOfSupporterDethronedNotification: instanceOfSupporterDethronedNotification,
    SupporterDethronedNotificationFromJSON: SupporterDethronedNotificationFromJSON,
    SupporterDethronedNotificationFromJSONTyped: SupporterDethronedNotificationFromJSONTyped,
    SupporterDethronedNotificationToJSON: SupporterDethronedNotificationToJSON,
    instanceOfSupporterDethronedNotificationAction: instanceOfSupporterDethronedNotificationAction,
    SupporterDethronedNotificationActionFromJSON: SupporterDethronedNotificationActionFromJSON,
    SupporterDethronedNotificationActionFromJSONTyped: SupporterDethronedNotificationActionFromJSONTyped,
    SupporterDethronedNotificationActionToJSON: SupporterDethronedNotificationActionToJSON,
    instanceOfSupporterDethronedNotificationActionData: instanceOfSupporterDethronedNotificationActionData,
    SupporterDethronedNotificationActionDataFromJSON: SupporterDethronedNotificationActionDataFromJSON,
    SupporterDethronedNotificationActionDataFromJSONTyped: SupporterDethronedNotificationActionDataFromJSONTyped,
    SupporterDethronedNotificationActionDataToJSON: SupporterDethronedNotificationActionDataToJSON,
    instanceOfSupporterRankUpNotification: instanceOfSupporterRankUpNotification,
    SupporterRankUpNotificationFromJSON: SupporterRankUpNotificationFromJSON,
    SupporterRankUpNotificationFromJSONTyped: SupporterRankUpNotificationFromJSONTyped,
    SupporterRankUpNotificationToJSON: SupporterRankUpNotificationToJSON,
    instanceOfSupporterRankUpNotificationAction: instanceOfSupporterRankUpNotificationAction,
    SupporterRankUpNotificationActionFromJSON: SupporterRankUpNotificationActionFromJSON,
    SupporterRankUpNotificationActionFromJSONTyped: SupporterRankUpNotificationActionFromJSONTyped,
    SupporterRankUpNotificationActionToJSON: SupporterRankUpNotificationActionToJSON,
    instanceOfSupporterRankUpNotificationActionData: instanceOfSupporterRankUpNotificationActionData,
    SupporterRankUpNotificationActionDataFromJSON: SupporterRankUpNotificationActionDataFromJSON,
    SupporterRankUpNotificationActionDataFromJSONTyped: SupporterRankUpNotificationActionDataFromJSONTyped,
    SupporterRankUpNotificationActionDataToJSON: SupporterRankUpNotificationActionDataToJSON,
    instanceOfSupporterReference: instanceOfSupporterReference,
    SupporterReferenceFromJSON: SupporterReferenceFromJSON,
    SupporterReferenceFromJSONTyped: SupporterReferenceFromJSONTyped,
    SupporterReferenceToJSON: SupporterReferenceToJSON,
    instanceOfTastemakerNotification: instanceOfTastemakerNotification,
    TastemakerNotificationFromJSON: TastemakerNotificationFromJSON,
    TastemakerNotificationFromJSONTyped: TastemakerNotificationFromJSONTyped,
    TastemakerNotificationToJSON: TastemakerNotificationToJSON,
    instanceOfTastemakerNotificationAction: instanceOfTastemakerNotificationAction,
    TastemakerNotificationActionFromJSON: TastemakerNotificationActionFromJSON,
    TastemakerNotificationActionFromJSONTyped: TastemakerNotificationActionFromJSONTyped,
    TastemakerNotificationActionToJSON: TastemakerNotificationActionToJSON,
    instanceOfTastemakerNotificationActionData: instanceOfTastemakerNotificationActionData,
    TastemakerNotificationActionDataFromJSON: TastemakerNotificationActionDataFromJSON,
    TastemakerNotificationActionDataFromJSONTyped: TastemakerNotificationActionDataFromJSONTyped,
    TastemakerNotificationActionDataToJSON: TastemakerNotificationActionDataToJSON,
    instanceOfTierChangeNotification: instanceOfTierChangeNotification,
    TierChangeNotificationFromJSON: TierChangeNotificationFromJSON,
    TierChangeNotificationFromJSONTyped: TierChangeNotificationFromJSONTyped,
    TierChangeNotificationToJSON: TierChangeNotificationToJSON,
    instanceOfTierChangeNotificationAction: instanceOfTierChangeNotificationAction,
    TierChangeNotificationActionFromJSON: TierChangeNotificationActionFromJSON,
    TierChangeNotificationActionFromJSONTyped: TierChangeNotificationActionFromJSONTyped,
    TierChangeNotificationActionToJSON: TierChangeNotificationActionToJSON,
    instanceOfTierChangeNotificationActionData: instanceOfTierChangeNotificationActionData,
    TierChangeNotificationActionDataFromJSON: TierChangeNotificationActionDataFromJSON,
    TierChangeNotificationActionDataFromJSONTyped: TierChangeNotificationActionDataFromJSONTyped,
    TierChangeNotificationActionDataToJSON: TierChangeNotificationActionDataToJSON,
    instanceOfTipGate: instanceOfTipGate,
    TipGateFromJSON: TipGateFromJSON,
    TipGateFromJSONTyped: TipGateFromJSONTyped,
    TipGateToJSON: TipGateToJSON,
    instanceOfTokenGate: instanceOfTokenGate,
    TokenGateFromJSON: TokenGateFromJSON,
    TokenGateFromJSONTyped: TokenGateFromJSONTyped,
    TokenGateToJSON: TokenGateToJSON,
    instanceOfTopGenreUsersResponseFull: instanceOfTopGenreUsersResponseFull,
    TopGenreUsersResponseFullFromJSON: TopGenreUsersResponseFullFromJSON,
    TopGenreUsersResponseFullFromJSONTyped: TopGenreUsersResponseFullFromJSONTyped,
    TopGenreUsersResponseFullToJSON: TopGenreUsersResponseFullToJSON,
    instanceOfTopUsersResponseFull: instanceOfTopUsersResponseFull,
    TopUsersResponseFullFromJSON: TopUsersResponseFullFromJSON,
    TopUsersResponseFullFromJSONTyped: TopUsersResponseFullFromJSONTyped,
    TopUsersResponseFullToJSON: TopUsersResponseFullToJSON,
    TrackActivityFullItemTypeEnum: TrackActivityFullItemTypeEnum,
    instanceOfTrackActivityFull: instanceOfTrackActivityFull,
    TrackActivityFullFromJSON: TrackActivityFullFromJSON,
    TrackActivityFullFromJSONTyped: TrackActivityFullFromJSONTyped,
    TrackActivityFullToJSON: TrackActivityFullToJSON,
    instanceOfTrackAddedToPlaylistNotification: instanceOfTrackAddedToPlaylistNotification,
    TrackAddedToPlaylistNotificationFromJSON: TrackAddedToPlaylistNotificationFromJSON,
    TrackAddedToPlaylistNotificationFromJSONTyped: TrackAddedToPlaylistNotificationFromJSONTyped,
    TrackAddedToPlaylistNotificationToJSON: TrackAddedToPlaylistNotificationToJSON,
    instanceOfTrackAddedToPlaylistNotificationAction: instanceOfTrackAddedToPlaylistNotificationAction,
    TrackAddedToPlaylistNotificationActionFromJSON: TrackAddedToPlaylistNotificationActionFromJSON,
    TrackAddedToPlaylistNotificationActionFromJSONTyped: TrackAddedToPlaylistNotificationActionFromJSONTyped,
    TrackAddedToPlaylistNotificationActionToJSON: TrackAddedToPlaylistNotificationActionToJSON,
    instanceOfTrackAddedToPlaylistNotificationActionData: instanceOfTrackAddedToPlaylistNotificationActionData,
    TrackAddedToPlaylistNotificationActionDataFromJSON: TrackAddedToPlaylistNotificationActionDataFromJSON,
    TrackAddedToPlaylistNotificationActionDataFromJSONTyped: TrackAddedToPlaylistNotificationActionDataFromJSONTyped,
    TrackAddedToPlaylistNotificationActionDataToJSON: TrackAddedToPlaylistNotificationActionDataToJSON,
    instanceOfTrackAddedToPurchasedAlbumNotification: instanceOfTrackAddedToPurchasedAlbumNotification,
    TrackAddedToPurchasedAlbumNotificationFromJSON: TrackAddedToPurchasedAlbumNotificationFromJSON,
    TrackAddedToPurchasedAlbumNotificationFromJSONTyped: TrackAddedToPurchasedAlbumNotificationFromJSONTyped,
    TrackAddedToPurchasedAlbumNotificationToJSON: TrackAddedToPurchasedAlbumNotificationToJSON,
    instanceOfTrackAddedToPurchasedAlbumNotificationAction: instanceOfTrackAddedToPurchasedAlbumNotificationAction,
    TrackAddedToPurchasedAlbumNotificationActionFromJSON: TrackAddedToPurchasedAlbumNotificationActionFromJSON,
    TrackAddedToPurchasedAlbumNotificationActionFromJSONTyped: TrackAddedToPurchasedAlbumNotificationActionFromJSONTyped,
    TrackAddedToPurchasedAlbumNotificationActionToJSON: TrackAddedToPurchasedAlbumNotificationActionToJSON,
    instanceOfTrackAddedToPurchasedAlbumNotificationActionData: instanceOfTrackAddedToPurchasedAlbumNotificationActionData,
    TrackAddedToPurchasedAlbumNotificationActionDataFromJSON: TrackAddedToPurchasedAlbumNotificationActionDataFromJSON,
    TrackAddedToPurchasedAlbumNotificationActionDataFromJSONTyped: TrackAddedToPurchasedAlbumNotificationActionDataFromJSONTyped,
    TrackAddedToPurchasedAlbumNotificationActionDataToJSON: TrackAddedToPurchasedAlbumNotificationActionDataToJSON,
    instanceOfTrackArtworkFull: instanceOfTrackArtworkFull,
    TrackArtworkFullFromJSON: TrackArtworkFullFromJSON,
    TrackArtworkFullFromJSONTyped: TrackArtworkFullFromJSONTyped,
    TrackArtworkFullToJSON: TrackArtworkFullToJSON,
    instanceOfTrackCommentsResponseFull: instanceOfTrackCommentsResponseFull,
    TrackCommentsResponseFullFromJSON: TrackCommentsResponseFullFromJSON,
    TrackCommentsResponseFullFromJSONTyped: TrackCommentsResponseFullFromJSONTyped,
    TrackCommentsResponseFullToJSON: TrackCommentsResponseFullToJSON,
    instanceOfTrackFavoritesResponseFull: instanceOfTrackFavoritesResponseFull,
    TrackFavoritesResponseFullFromJSON: TrackFavoritesResponseFullFromJSON,
    TrackFavoritesResponseFullFromJSONTyped: TrackFavoritesResponseFullFromJSONTyped,
    TrackFavoritesResponseFullToJSON: TrackFavoritesResponseFullToJSON,
    instanceOfTrackFeedItem: instanceOfTrackFeedItem,
    TrackFeedItemFromJSON: TrackFeedItemFromJSON,
    TrackFeedItemFromJSONTyped: TrackFeedItemFromJSONTyped,
    TrackFeedItemToJSON: TrackFeedItemToJSON,
    instanceOfTrackFull: instanceOfTrackFull,
    TrackFullFromJSON: TrackFullFromJSON,
    TrackFullFromJSONTyped: TrackFullFromJSONTyped,
    TrackFullToJSON: TrackFullToJSON,
    instanceOfTrackId: instanceOfTrackId,
    TrackIdFromJSON: TrackIdFromJSON,
    TrackIdFromJSONTyped: TrackIdFromJSONTyped,
    TrackIdToJSON: TrackIdToJSON,
    instanceOfTrackLibraryResponseFull: instanceOfTrackLibraryResponseFull,
    TrackLibraryResponseFullFromJSON: TrackLibraryResponseFullFromJSON,
    TrackLibraryResponseFullFromJSONTyped: TrackLibraryResponseFullFromJSONTyped,
    TrackLibraryResponseFullToJSON: TrackLibraryResponseFullToJSON,
    instanceOfTrackMilestoneNotificationActionData: instanceOfTrackMilestoneNotificationActionData,
    TrackMilestoneNotificationActionDataFromJSON: TrackMilestoneNotificationActionDataFromJSON,
    TrackMilestoneNotificationActionDataFromJSONTyped: TrackMilestoneNotificationActionDataFromJSONTyped,
    TrackMilestoneNotificationActionDataToJSON: TrackMilestoneNotificationActionDataToJSON,
    instanceOfTrackRepostsResponseFull: instanceOfTrackRepostsResponseFull,
    TrackRepostsResponseFullFromJSON: TrackRepostsResponseFullFromJSON,
    TrackRepostsResponseFullFromJSONTyped: TrackRepostsResponseFullFromJSONTyped,
    TrackRepostsResponseFullToJSON: TrackRepostsResponseFullToJSON,
    instanceOfTrackSegment: instanceOfTrackSegment,
    TrackSegmentFromJSON: TrackSegmentFromJSON,
    TrackSegmentFromJSONTyped: TrackSegmentFromJSONTyped,
    TrackSegmentToJSON: TrackSegmentToJSON,
    instanceOfTransactionDetails: instanceOfTransactionDetails,
    TransactionDetailsFromJSON: TransactionDetailsFromJSON,
    TransactionDetailsFromJSONTyped: TransactionDetailsFromJSONTyped,
    TransactionDetailsToJSON: TransactionDetailsToJSON,
    instanceOfTransactionHistoryCountResponse: instanceOfTransactionHistoryCountResponse,
    TransactionHistoryCountResponseFromJSON: TransactionHistoryCountResponseFromJSON,
    TransactionHistoryCountResponseFromJSONTyped: TransactionHistoryCountResponseFromJSONTyped,
    TransactionHistoryCountResponseToJSON: TransactionHistoryCountResponseToJSON,
    instanceOfTransactionHistoryResponse: instanceOfTransactionHistoryResponse,
    TransactionHistoryResponseFromJSON: TransactionHistoryResponseFromJSON,
    TransactionHistoryResponseFromJSONTyped: TransactionHistoryResponseFromJSONTyped,
    TransactionHistoryResponseToJSON: TransactionHistoryResponseToJSON,
    instanceOfTrendingIdsResponse: instanceOfTrendingIdsResponse,
    TrendingIdsResponseFromJSON: TrendingIdsResponseFromJSON,
    TrendingIdsResponseFromJSONTyped: TrendingIdsResponseFromJSONTyped,
    TrendingIdsResponseToJSON: TrendingIdsResponseToJSON,
    instanceOfTrendingNotification: instanceOfTrendingNotification,
    TrendingNotificationFromJSON: TrendingNotificationFromJSON,
    TrendingNotificationFromJSONTyped: TrendingNotificationFromJSONTyped,
    TrendingNotificationToJSON: TrendingNotificationToJSON,
    instanceOfTrendingNotificationAction: instanceOfTrendingNotificationAction,
    TrendingNotificationActionFromJSON: TrendingNotificationActionFromJSON,
    TrendingNotificationActionFromJSONTyped: TrendingNotificationActionFromJSONTyped,
    TrendingNotificationActionToJSON: TrendingNotificationActionToJSON,
    TrendingNotificationActionDataTimeRangeEnum: TrendingNotificationActionDataTimeRangeEnum,
    instanceOfTrendingNotificationActionData: instanceOfTrendingNotificationActionData,
    TrendingNotificationActionDataFromJSON: TrendingNotificationActionDataFromJSON,
    TrendingNotificationActionDataFromJSONTyped: TrendingNotificationActionDataFromJSONTyped,
    TrendingNotificationActionDataToJSON: TrendingNotificationActionDataToJSON,
    instanceOfTrendingPlaylistNotification: instanceOfTrendingPlaylistNotification,
    TrendingPlaylistNotificationFromJSON: TrendingPlaylistNotificationFromJSON,
    TrendingPlaylistNotificationFromJSONTyped: TrendingPlaylistNotificationFromJSONTyped,
    TrendingPlaylistNotificationToJSON: TrendingPlaylistNotificationToJSON,
    instanceOfTrendingPlaylistNotificationAction: instanceOfTrendingPlaylistNotificationAction,
    TrendingPlaylistNotificationActionFromJSON: TrendingPlaylistNotificationActionFromJSON,
    TrendingPlaylistNotificationActionFromJSONTyped: TrendingPlaylistNotificationActionFromJSONTyped,
    TrendingPlaylistNotificationActionToJSON: TrendingPlaylistNotificationActionToJSON,
    TrendingPlaylistNotificationActionDataTimeRangeEnum: TrendingPlaylistNotificationActionDataTimeRangeEnum,
    instanceOfTrendingPlaylistNotificationActionData: instanceOfTrendingPlaylistNotificationActionData,
    TrendingPlaylistNotificationActionDataFromJSON: TrendingPlaylistNotificationActionDataFromJSON,
    TrendingPlaylistNotificationActionDataFromJSONTyped: TrendingPlaylistNotificationActionDataFromJSONTyped,
    TrendingPlaylistNotificationActionDataToJSON: TrendingPlaylistNotificationActionDataToJSON,
    instanceOfTrendingTimesIds: instanceOfTrendingTimesIds,
    TrendingTimesIdsFromJSON: TrendingTimesIdsFromJSON,
    TrendingTimesIdsFromJSONTyped: TrendingTimesIdsFromJSONTyped,
    TrendingTimesIdsToJSON: TrendingTimesIdsToJSON,
    instanceOfTrendingUndergroundNotification: instanceOfTrendingUndergroundNotification,
    TrendingUndergroundNotificationFromJSON: TrendingUndergroundNotificationFromJSON,
    TrendingUndergroundNotificationFromJSONTyped: TrendingUndergroundNotificationFromJSONTyped,
    TrendingUndergroundNotificationToJSON: TrendingUndergroundNotificationToJSON,
    instanceOfTrendingUndergroundNotificationAction: instanceOfTrendingUndergroundNotificationAction,
    TrendingUndergroundNotificationActionFromJSON: TrendingUndergroundNotificationActionFromJSON,
    TrendingUndergroundNotificationActionFromJSONTyped: TrendingUndergroundNotificationActionFromJSONTyped,
    TrendingUndergroundNotificationActionToJSON: TrendingUndergroundNotificationActionToJSON,
    TrendingUndergroundNotificationActionDataTimeRangeEnum: TrendingUndergroundNotificationActionDataTimeRangeEnum,
    instanceOfTrendingUndergroundNotificationActionData: instanceOfTrendingUndergroundNotificationActionData,
    TrendingUndergroundNotificationActionDataFromJSON: TrendingUndergroundNotificationActionDataFromJSON,
    TrendingUndergroundNotificationActionDataFromJSONTyped: TrendingUndergroundNotificationActionDataFromJSONTyped,
    TrendingUndergroundNotificationActionDataToJSON: TrendingUndergroundNotificationActionDataToJSON,
    instanceOfUpdateCoinRequest: instanceOfUpdateCoinRequest,
    UpdateCoinRequestFromJSON: UpdateCoinRequestFromJSON,
    UpdateCoinRequestFromJSONTyped: UpdateCoinRequestFromJSONTyped,
    UpdateCoinRequestToJSON: UpdateCoinRequestToJSON,
    instanceOfUpdateCoinResponse: instanceOfUpdateCoinResponse,
    UpdateCoinResponseFromJSON: UpdateCoinResponseFromJSON,
    UpdateCoinResponseFromJSONTyped: UpdateCoinResponseFromJSONTyped,
    UpdateCoinResponseToJSON: UpdateCoinResponseToJSON,
    instanceOfUrlWithMirrors: instanceOfUrlWithMirrors,
    UrlWithMirrorsFromJSON: UrlWithMirrorsFromJSON,
    UrlWithMirrorsFromJSONTyped: UrlWithMirrorsFromJSONTyped,
    UrlWithMirrorsToJSON: UrlWithMirrorsToJSON,
    instanceOfUsdcGate: instanceOfUsdcGate,
    UsdcGateFromJSON: UsdcGateFromJSON,
    UsdcGateFromJSONTyped: UsdcGateFromJSONTyped,
    UsdcGateToJSON: UsdcGateToJSON,
    instanceOfUsdcPurchaseBuyerNotification: instanceOfUsdcPurchaseBuyerNotification,
    UsdcPurchaseBuyerNotificationFromJSON: UsdcPurchaseBuyerNotificationFromJSON,
    UsdcPurchaseBuyerNotificationFromJSONTyped: UsdcPurchaseBuyerNotificationFromJSONTyped,
    UsdcPurchaseBuyerNotificationToJSON: UsdcPurchaseBuyerNotificationToJSON,
    instanceOfUsdcPurchaseBuyerNotificationAction: instanceOfUsdcPurchaseBuyerNotificationAction,
    UsdcPurchaseBuyerNotificationActionFromJSON: UsdcPurchaseBuyerNotificationActionFromJSON,
    UsdcPurchaseBuyerNotificationActionFromJSONTyped: UsdcPurchaseBuyerNotificationActionFromJSONTyped,
    UsdcPurchaseBuyerNotificationActionToJSON: UsdcPurchaseBuyerNotificationActionToJSON,
    instanceOfUsdcPurchaseBuyerNotificationActionData: instanceOfUsdcPurchaseBuyerNotificationActionData,
    UsdcPurchaseBuyerNotificationActionDataFromJSON: UsdcPurchaseBuyerNotificationActionDataFromJSON,
    UsdcPurchaseBuyerNotificationActionDataFromJSONTyped: UsdcPurchaseBuyerNotificationActionDataFromJSONTyped,
    UsdcPurchaseBuyerNotificationActionDataToJSON: UsdcPurchaseBuyerNotificationActionDataToJSON,
    instanceOfUsdcPurchaseSellerNotification: instanceOfUsdcPurchaseSellerNotification,
    UsdcPurchaseSellerNotificationFromJSON: UsdcPurchaseSellerNotificationFromJSON,
    UsdcPurchaseSellerNotificationFromJSONTyped: UsdcPurchaseSellerNotificationFromJSONTyped,
    UsdcPurchaseSellerNotificationToJSON: UsdcPurchaseSellerNotificationToJSON,
    instanceOfUsdcPurchaseSellerNotificationAction: instanceOfUsdcPurchaseSellerNotificationAction,
    UsdcPurchaseSellerNotificationActionFromJSON: UsdcPurchaseSellerNotificationActionFromJSON,
    UsdcPurchaseSellerNotificationActionFromJSONTyped: UsdcPurchaseSellerNotificationActionFromJSONTyped,
    UsdcPurchaseSellerNotificationActionToJSON: UsdcPurchaseSellerNotificationActionToJSON,
    instanceOfUsdcPurchaseSellerNotificationActionData: instanceOfUsdcPurchaseSellerNotificationActionData,
    UsdcPurchaseSellerNotificationActionDataFromJSON: UsdcPurchaseSellerNotificationActionDataFromJSON,
    UsdcPurchaseSellerNotificationActionDataFromJSONTyped: UsdcPurchaseSellerNotificationActionDataFromJSONTyped,
    UsdcPurchaseSellerNotificationActionDataToJSON: UsdcPurchaseSellerNotificationActionDataToJSON,
    instanceOfUserAccountResponseFull: instanceOfUserAccountResponseFull,
    UserAccountResponseFullFromJSON: UserAccountResponseFullFromJSON,
    UserAccountResponseFullFromJSONTyped: UserAccountResponseFullFromJSONTyped,
    UserAccountResponseFullToJSON: UserAccountResponseFullToJSON,
    instanceOfUserCommentsResponseFull: instanceOfUserCommentsResponseFull,
    UserCommentsResponseFullFromJSON: UserCommentsResponseFullFromJSON,
    UserCommentsResponseFullFromJSONTyped: UserCommentsResponseFullFromJSONTyped,
    UserCommentsResponseFullToJSON: UserCommentsResponseFullToJSON,
    UserFeedItemFromJSON: UserFeedItemFromJSON,
    UserFeedItemFromJSONTyped: UserFeedItemFromJSONTyped,
    UserFeedItemToJSON: UserFeedItemToJSON,
    instanceOfUserFeedResponse: instanceOfUserFeedResponse,
    UserFeedResponseFromJSON: UserFeedResponseFromJSON,
    UserFeedResponseFromJSONTyped: UserFeedResponseFromJSONTyped,
    UserFeedResponseToJSON: UserFeedResponseToJSON,
    instanceOfUserFull: instanceOfUserFull,
    UserFullFromJSON: UserFullFromJSON,
    UserFullFromJSONTyped: UserFullFromJSONTyped,
    UserFullToJSON: UserFullToJSON,
    instanceOfUserFullArtistCoinBadge: instanceOfUserFullArtistCoinBadge,
    UserFullArtistCoinBadgeFromJSON: UserFullArtistCoinBadgeFromJSON,
    UserFullArtistCoinBadgeFromJSONTyped: UserFullArtistCoinBadgeFromJSONTyped,
    UserFullArtistCoinBadgeToJSON: UserFullArtistCoinBadgeToJSON,
    instanceOfUserManager: instanceOfUserManager,
    UserManagerFromJSON: UserManagerFromJSON,
    UserManagerFromJSONTyped: UserManagerFromJSONTyped,
    UserManagerToJSON: UserManagerToJSON,
    instanceOfUserMilestoneNotificationActionData: instanceOfUserMilestoneNotificationActionData,
    UserMilestoneNotificationActionDataFromJSON: UserMilestoneNotificationActionDataFromJSON,
    UserMilestoneNotificationActionDataFromJSONTyped: UserMilestoneNotificationActionDataFromJSONTyped,
    UserMilestoneNotificationActionDataToJSON: UserMilestoneNotificationActionDataToJSON,
    instanceOfUserSubscribers: instanceOfUserSubscribers,
    UserSubscribersFromJSON: UserSubscribersFromJSON,
    UserSubscribersFromJSONTyped: UserSubscribersFromJSONTyped,
    UserSubscribersToJSON: UserSubscribersToJSON,
    instanceOfVersionMetadata: instanceOfVersionMetadata,
    VersionMetadataFromJSON: VersionMetadataFromJSON,
    VersionMetadataFromJSONTyped: VersionMetadataFromJSONTyped,
    VersionMetadataToJSON: VersionMetadataToJSON
});

const CreateGrantSchema = z.object({
  userId: HashId,
  appApiKey: z.custom(data => {
    return isApiKeyValid(data);
  })
});
const AddManagerSchema = z.object({
  userId: HashId,
  managerUserId: HashId
});
const RemoveManagerSchema = z.object({
  userId: HashId,
  managerUserId: HashId
});
const RevokeGrantSchema = z.object({
  userId: HashId,
  appApiKey: z.custom(data => {
    return isApiKeyValid(data);
  })
});
const ApproveGrantSchema = z.object({
  userId: HashId,
  grantorUserId: HashId
});

class GrantsApi {
  // eslint-disable-next-line no-useless-constructor
  constructor(_config, entityManager, usersApi) {
    _defineProperty$1(this, "entityManager", void 0);
    _defineProperty$1(this, "usersApi", void 0);
    this.entityManager = entityManager;
    this.usersApi = usersApi;
  }
  /**
   * When user authorizes app to perform actions on their behalf.
   * For user-to-user grants, use `addManager`.
   */
  async createGrant(params) {
    const {
      userId,
      appApiKey
    } = await parseParams('createGrant', CreateGrantSchema)(params);
    return await this.entityManager.manageEntity({
      userId,
      entityType: EntityType.GRANT,
      entityId: 0,
      action: Action.CREATE,
      metadata: JSON.stringify({
        grantee_address: `0x${appApiKey}`
      })
    });
  }
  /**
   * When user authorizes another user to perform actions on their behalf.
   * The grant has to be approved by the proposed manager.
   */
  async addManager(params) {
    const {
      userId,
      managerUserId
    } = await parseParams('addManager', AddManagerSchema)(params);
    let managerUser;
    try {
      managerUser = (await this.usersApi.getUser({
        id: encodeHashId(managerUserId)
      })).data;
      if (!managerUser) {
        throw new Error();
      }
    } catch (e) {
      throw new Error('`managerUserId` passed to `addManager` method is invalid.');
    }
    return await this.entityManager.manageEntity({
      userId,
      entityType: EntityType.GRANT,
      entityId: 0,
      action: Action.CREATE,
      metadata: JSON.stringify({
        grantee_address: managerUser.ercWallet
      })
    });
  }
  /**
   * Revokes a user's manager access - can either be called by the manager user or the child user
   */
  async removeManager(params) {
    const {
      userId,
      managerUserId
    } = await parseParams('addManager', AddManagerSchema)(params);
    let managerUser;
    try {
      managerUser = (await this.usersApi.getUser({
        id: encodeHashId(managerUserId)
      })).data;
      if (!managerUser) {
        throw new Error();
      }
    } catch (e) {
      throw new Error('`managerUserId` passed to `removeManager` method is invalid.');
    }
    return await this.entityManager.manageEntity({
      userId,
      entityType: EntityType.GRANT,
      entityId: 0,
      action: Action.DELETE,
      metadata: JSON.stringify({
        grantee_address: managerUser.ercWallet
      })
    });
  }
  /**
   * When user revokes an app's authorization to perform actions on their behalf
   */
  async revokeGrant(params) {
    const {
      userId,
      appApiKey
    } = await parseParams('revokeGrant', RevokeGrantSchema)(params);
    return await this.entityManager.manageEntity({
      userId,
      entityType: EntityType.GRANT,
      entityId: 0,
      action: Action.DELETE,
      metadata: JSON.stringify({
        grantee_address: `0x${appApiKey}`
      })
    });
  }
  /**
   * Approve manager request
   */
  async approveGrant(params) {
    const {
      userId,
      grantorUserId
    } = await parseParams('approveGrant', ApproveGrantSchema)(params);
    return await this.entityManager.manageEntity({
      userId,
      entityType: EntityType.GRANT,
      entityId: 0,
      action: Action.APPROVE,
      metadata: JSON.stringify({
        grantor_user_id: grantorUserId
      })
    });
  }
}

const MarkAllNotificationsAsViewedSchema = z.object({
  userId: HashId
});
const UpdatePlaylistLastViewedAtSchema = z.object({
  playlistId: HashId,
  userId: HashId
});
z.object({
  data: z.any()
});

class NotificationsApi {
  // eslint-disable-next-line no-useless-constructor
  constructor(_config, entityManager) {
    _defineProperty$1(this, "entityManager", void 0);
    this.entityManager = entityManager;
  }
  /**
   * When a user views all of their notifications
   */
  async markAllNotificationsAsViewed(params) {
    const {
      userId
    } = await parseParams('markAllNotificationsAsViewed', MarkAllNotificationsAsViewedSchema)(params);
    return await this.entityManager.manageEntity({
      userId,
      entityType: EntityType.NOTIFICATION,
      // In this case, we are the entityId since we are marking our own notifications as viewed
      entityId: userId,
      action: Action.VIEW,
      metadata: ''
    });
  }
  /**
   * When a user views a playlist
   */
  async updatePlaylistLastViewedAt(params) {
    const {
      playlistId,
      userId
    } = await parseParams('updatePlaylistLastViewedAt', UpdatePlaylistLastViewedAtSchema)(params);
    return await this.entityManager.manageEntity({
      userId,
      entityType: EntityType.NOTIFICATION,
      entityId: playlistId,
      action: Action.VIEW_PLAYLIST,
      metadata: ''
    });
  }
}

const ipApi = 'https://ipapi.co/json/';
/**
 * Helper to get location. Intended for client-side use only from unique
 * requesters.
 * @param logger
 * @returns { city, region, country}
 */
const getLocation = async function () {
  let {
    logger
  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  try {
    const res = await fetch(ipApi);
    const {
      city,
      region,
      country_name
    } = await res.json();
    return {
      city,
      region,
      // country from res is returned as ISO 2-alpha code and we want
      // full english name.
      country: country_name
    };
  } catch (e) {
    logger === null || logger === void 0 ? void 0 : logger.error(e);
    return null;
  }
};

// Extend that new class
class TracksApi extends TracksApi$2 {
  constructor(configuration, storage, entityManager, logger, claimableTokensClient, paymentRouterClient, solanaRelay, solanaClient) {
    super(configuration);
    _defineProperty$1(this, "storage", void 0);
    _defineProperty$1(this, "entityManager", void 0);
    _defineProperty$1(this, "logger", void 0);
    _defineProperty$1(this, "claimableTokensClient", void 0);
    _defineProperty$1(this, "paymentRouterClient", void 0);
    _defineProperty$1(this, "solanaRelay", void 0);
    _defineProperty$1(this, "solanaClient", void 0);
    _defineProperty$1(this, "trackUploadHelper", void 0);
    this.storage = storage;
    this.entityManager = entityManager;
    this.logger = logger;
    this.claimableTokensClient = claimableTokensClient;
    this.paymentRouterClient = paymentRouterClient;
    this.solanaRelay = solanaRelay;
    this.solanaClient = solanaClient;
    this.trackUploadHelper = new TrackUploadHelper(configuration);
    this.logger = logger.createPrefixedLogger('[tracks-api]');
  }
  /**
   * Get the url of the track's streamable mp3 file
   */
  async getTrackStreamUrl(params) {
    if (params.trackId === null || params.trackId === undefined) {
      throw new RequiredError$1('trackId', 'Required parameter params.trackId was null or undefined when calling getTrack.');
    }
    const queryParams = new URLSearchParams();
    if (params.userId) queryParams.append('user_id', params.userId);
    if (params.preview !== undefined) queryParams.append('preview', String(params.preview));
    if (params.userSignature) queryParams.append('user_signature', params.userSignature);
    if (params.userData) queryParams.append('user_data', params.userData);
    if (params.nftAccessSignature) queryParams.append('nft_access_signature', params.nftAccessSignature);
    if (params.skipPlayCount !== undefined) queryParams.append('skip_play_count', String(params.skipPlayCount));
    if (params.apiKey) queryParams.append('api_key', params.apiKey);
    if (params.skipCheck !== undefined) queryParams.append('skip_check', String(params.skipCheck));
    if (params.noRedirect !== undefined) queryParams.append('no_redirect', String(params.noRedirect));
    const path = `/tracks/{track_id}/stream`.replace(`{${'track_id'}}`, encodeURIComponent(String(params.trackId)));
    const queryString = queryParams.toString();
    return `${this.configuration.basePath}${path}${queryString ? '?' + queryString : ''}`;
  }
  /**
   * Get the url of the track's downloadable file
   */
  async getTrackDownloadUrl(params) {
    if (params.trackId === null || params.trackId === undefined) {
      throw new RequiredError$1('trackId', 'Required parameter params.trackId was null or undefined when calling getTrack.');
    }
    const queryParams = new URLSearchParams();
    if (params.userId) queryParams.append('user_id', params.userId);
    if (params.userSignature) queryParams.append('user_signature', params.userSignature);
    if (params.userData) queryParams.append('user_data', params.userData);
    if (params.nftAccessSignature) queryParams.append('nft_access_signature', params.nftAccessSignature);
    if (params.filename) queryParams.append('filename', params.filename);
    const path = `/tracks/{track_id}/download`.replace(`{${'track_id'}}`, encodeURIComponent(String(params.trackId)));
    const queryString = queryParams.toString();
    return `${this.configuration.basePath}${path}${queryString ? '?' + queryString : ''}`;
  }
  /** @hidden
   * Upload track files, does not write to chain
   */
  async uploadTrackFiles(params) {
    // Parse inputs
    this.logger.info('Parsing inputs');
    const {
      userId,
      trackFile,
      coverArtFile,
      metadata: parsedMetadata,
      onProgress
    } = await parseParams('uploadTrackFiles', UploadTrackFilesSchema)(params);
    // Transform metadata
    this.logger.info('Transforming metadata');
    const metadata = this.trackUploadHelper.transformTrackUploadMetadata(parsedMetadata, userId);
    // Upload track audio and cover art to storage node
    this.logger.info('Uploading track audio and cover art');
    const [coverArtResponse, audioResponse] = await Promise.all([coverArtFile ? retry3(async () => await this.storage.uploadFile({
      file: coverArtFile,
      onProgress,
      template: 'img_square'
    }), e => {
      this.logger.info('Retrying uploadTrackCoverArt', e);
    }) : Promise.resolve(undefined), retry3(async () => await this.storage.uploadFile({
      file: trackFile,
      onProgress,
      template: 'audio',
      options: this.trackUploadHelper.extractMediorumUploadOptions(metadata)
    }), e => {
      this.logger.info('Retrying uploadTrackAudio', e);
    })]);
    // Update metadata to include uploaded CIDs
    return this.trackUploadHelper.populateTrackMetadataWithUploadResponse(metadata, audioResponse, coverArtResponse);
  }
  /** @hidden
   * Write track upload to chain
   */
  async writeTrackToChain(userId, metadata, advancedOptions) {
    var _decodeHashId;
    // Write metadata to chain
    this.logger.info('Writing metadata to chain');
    const entityId = metadata.trackId || (await this.trackUploadHelper.generateId('track'));
    const decodedUserId = (_decodeHashId = decodeHashId(userId)) !== null && _decodeHashId !== void 0 ? _decodeHashId : undefined;
    if (!decodedUserId) {
      throw new Error('writeTrackToChain: userId could not be decoded');
    }
    const response = await this.entityManager.manageEntity({
      userId: decodedUserId,
      entityType: EntityType.TRACK,
      entityId,
      action: Action.CREATE,
      metadata: JSON.stringify({
        cid: '',
        data: {
          ...snakecaseKeys(metadata),
          download_conditions: metadata.downloadConditions && snakecaseKeys(metadata.downloadConditions),
          stream_conditions: metadata.streamConditions && snakecaseKeys(metadata.streamConditions),
          stem_of: metadata.stemOf && snakecaseKeys(metadata.stemOf)
        }
      }),
      ...advancedOptions
    });
    this.logger.info('Successfully uploaded track');
    return {
      ...response,
      trackId: encodeHashId(entityId)
    };
  }
  /** @hidden
   * Upload a track
   */
  async uploadTrack(params, advancedOptions) {
    // Validate inputs
    await parseParams('uploadTrack', UploadTrackSchema)(params);
    // Upload track files
    const metadata = await this.uploadTrackFiles(params);
    // Write track metadata to chain
    return this.writeTrackToChain(params.userId, metadata, advancedOptions);
  }
  /** @hidden
   * Update a track
   */
  async updateTrack(params, advancedOptions) {
    // Parse inputs
    const {
      userId,
      trackId,
      coverArtFile,
      metadata: parsedMetadata,
      onProgress,
      generatePreview
    } = await parseParams('updateTrack', UpdateTrackSchema)(params);
    // Transform metadata
    const metadata = this.trackUploadHelper.transformTrackUploadMetadata(parsedMetadata, userId);
    // Upload track cover art to storage node
    const coverArtResp = coverArtFile && (await retry3(async () => await this.storage.uploadFile({
      file: coverArtFile,
      onProgress,
      template: 'img_square'
    }), e => {
      this.logger.info('Retrying uploadTrackCoverArt', e);
    }));
    // Update metadata to include uploaded CIDs
    const updatedMetadata = {
      ...metadata,
      ...(coverArtResp ? {
        coverArtSizes: coverArtResp.id
      } : {})
    };
    if (generatePreview) {
      if (updatedMetadata.previewStartSeconds === undefined) {
        throw new Error('No track preview start time specified');
      }
      if (!updatedMetadata.audioUploadId) {
        throw new Error('Missing required audio_upload_id');
      }
      // Generate track preview
      const previewCid = await retry3(async () => await this.storage.generatePreview({
        cid: updatedMetadata.trackCid,
        secondOffset: updatedMetadata.previewStartSeconds
      }), e => {
        this.logger.info('Retrying generatePreview', e);
      });
      // Update metadata to include updated preview CID
      updatedMetadata.previewCid = previewCid;
    }
    // Write metadata to chain
    return await this.entityManager.manageEntity({
      userId,
      entityType: EntityType.TRACK,
      entityId: trackId,
      action: Action.UPDATE,
      metadata: JSON.stringify({
        cid: '',
        data: {
          ...snakecaseKeys(updatedMetadata),
          download_conditions: updatedMetadata.downloadConditions && snakecaseKeys(updatedMetadata.downloadConditions),
          stream_conditions: updatedMetadata.streamConditions && snakecaseKeys(updatedMetadata.streamConditions),
          stem_of: metadata.stemOf && snakecaseKeys(metadata.stemOf)
        }
      }),
      ...advancedOptions
    });
  }
  /** @hidden
   * Delete a track
   */
  async deleteTrack(params, advancedOptions) {
    // Parse inputs
    const {
      userId,
      trackId
    } = await parseParams('deleteTrack', DeleteTrackSchema)(params);
    return await this.entityManager.manageEntity({
      userId,
      entityType: EntityType.TRACK,
      entityId: trackId,
      action: Action.DELETE,
      ...advancedOptions
    });
  }
  /** @hidden
   * Favorite a track
   */
  async favoriteTrack(params, advancedOptions) {
    // Parse inputs
    const {
      userId,
      trackId,
      metadata
    } = await parseParams('favoriteTrack', FavoriteTrackSchema)(params);
    return await this.entityManager.manageEntity({
      userId,
      entityType: EntityType.TRACK,
      entityId: trackId,
      action: Action.SAVE,
      metadata: metadata && JSON.stringify(snakecaseKeys(metadata)),
      ...advancedOptions
    });
  }
  /** @hidden
   * Unfavorite a track
   */
  async unfavoriteTrack(params, advancedOptions) {
    // Parse inputs
    const {
      userId,
      trackId
    } = await parseParams('unfavoriteTrack', UnfavoriteTrackSchema)(params);
    return await this.entityManager.manageEntity({
      userId,
      entityType: EntityType.TRACK,
      entityId: trackId,
      action: Action.UNSAVE,
      ...advancedOptions
    });
  }
  /** @hidden
   * Share a track
   */
  async shareTrack(params, advancedOptions) {
    // Parse inputs
    const {
      userId,
      trackId
    } = await parseParams('shareTrack', ShareTrackSchema)(params);
    return await this.entityManager.manageEntity({
      userId,
      entityType: EntityType.TRACK,
      entityId: trackId,
      action: Action.SHARE,
      ...advancedOptions
    });
  }
  /** @hidden
   * Repost a track
   */
  async repostTrack(params, advancedOptions) {
    // Parse inputs
    const {
      userId,
      trackId,
      metadata
    } = await parseParams('respostTrack', RepostTrackSchema)(params);
    return await this.entityManager.manageEntity({
      userId,
      entityType: EntityType.TRACK,
      entityId: trackId,
      action: Action.REPOST,
      metadata: metadata && JSON.stringify(snakecaseKeys(metadata)),
      ...advancedOptions
    });
  }
  /** @hidden
   * Unrepost a track
   */
  async unrepostTrack(params, advancedOptions) {
    // Parse inputs
    const {
      userId,
      trackId
    } = await parseParams('unrepostTrack', UnrepostTrackSchema)(params);
    return await this.entityManager.manageEntity({
      userId,
      entityType: EntityType.TRACK,
      entityId: trackId,
      action: Action.UNREPOST,
      ...advancedOptions
    });
  }
  /**
   * @hidden
   *
   * Records that a track was downloaded.
   */
  async recordTrackDownload(params, advancedOptions) {
    const {
      userId,
      trackId
    } = await parseParams('downloadTrack', RecordTrackDownloadSchema)(params);
    const location = await getLocation({
      logger: this.logger
    });
    return await this.entityManager.manageEntity({
      userId,
      entityType: EntityType.TRACK,
      entityId: trackId,
      action: Action.DOWNLOAD,
      metadata: location ? JSON.stringify({
        cid: '',
        data: {
          city: location.city,
          region: location.region,
          country: location.country
        }
      }) : undefined,
      ...advancedOptions
    });
  }
  /**
   * Gets the Solana instructions that purchase the track
   *
   * @hidden
   */
  async getPurchaseTrackInstructions(params) {
    var _track$access, _track$access2;
    const {
      userId,
      trackId,
      price: priceNumber,
      extraAmount: extraAmountNumber = 0
    } = await parseParams('getPurchaseTrackInstructions', GetPurchaseTrackInstructionsSchema)(params);
    const contentType = 'track';
    const mint = 'USDC';
    // Fetch track
    this.logger.debug('Fetching track purchase info...', {
      trackId
    });
    const {
      data: track
    } = await this.getTrackAccessInfo({
      trackId: params.trackId,
      userId: params.userId // use hashed userId
    });
    // Validate purchase attempt
    if (!track) {
      throw new Error('Track not found.');
    }
    if (!track.isStreamGated && !track.isDownloadGated) {
      throw new Error('Attempted to purchase free track.');
    }
    if (track.userId === params.userId) {
      throw new Error('Attempted to purchase own track.');
    }
    let numberSplits = [];
    let centPrice;
    let accessType = 'stream';
    // Get conditions
    if (track.streamConditions && instanceOfExtendedPurchaseGate(track.streamConditions)) {
      centPrice = track.streamConditions.usdcPurchase.price;
      numberSplits = track.streamConditions.usdcPurchase.splits;
    } else if (track.downloadConditions && instanceOfExtendedPurchaseGate(track.downloadConditions)) {
      centPrice = track.downloadConditions.usdcPurchase.price;
      numberSplits = track.downloadConditions.usdcPurchase.splits;
      accessType = 'download';
    } else {
      throw new Error('Track is not available for purchase.');
    }
    // Check if already purchased
    if (accessType === 'download' && (_track$access = track.access) !== null && _track$access !== void 0 && _track$access.download || accessType === 'stream' && (_track$access2 = track.access) !== null && _track$access2 !== void 0 && _track$access2.stream) {
      throw new Error('Track already purchased');
    }
    // Check if price changed
    if (USDC(priceNumber).value < USDC(centPrice / 100).value) {
      throw new Error('Track price increased.');
    }
    const extraAmount = USDC(extraAmountNumber).value;
    const total = USDC(centPrice / 100.0).value + extraAmount;
    this.logger.debug('Purchase total:', total);
    const splits = await prepareSplits({
      splits: numberSplits,
      extraAmount,
      claimableTokensClient: this.claimableTokensClient,
      logger: this.logger
    });
    this.logger.debug('Calculated splits:', splits);
    const routeInstruction = await this.paymentRouterClient.createRouteInstruction({
      splits,
      total,
      mint
    });
    const memoInstruction = await this.paymentRouterClient.createPurchaseMemoInstruction({
      contentId: trackId,
      contentType,
      blockNumber: track.blocknumber,
      buyerUserId: userId,
      accessType
    });
    let locationMemoInstruction;
    try {
      locationMemoInstruction = await this.solanaRelay.getLocationInstruction();
    } catch (e) {
      this.logger.warn('Unable to compute location memo instruction');
    }
    return {
      instructions: {
        routeInstruction,
        memoInstruction,
        locationMemoInstruction
      },
      total
    };
  }
  /**
   * Purchases stream or download access to a track
   *
   * @hidden
   */
  async purchaseTrack(params) {
    const {
      wallet
    } = await parseParams('purchaseTrack', PurchaseTrackSchema)(params);
    const {
      // only send the base params to getPurchaseInstructions
      wallet: ignoredWallet,
      walletAdapter: ignoredWalletAdapter,
      ...baseParams
    } = params;
    const {
      instructions: {
        routeInstruction,
        memoInstruction,
        locationMemoInstruction
      },
      total
    } = await this.getPurchaseTrackInstructions(baseParams);
    let transaction;
    const mint = 'USDC';
    if (wallet) {
      this.logger.debug('Using provided wallet to purchase...', {
        wallet: wallet.toBase58()
      });
      // Use the specified Solana wallet
      const transferInstruction = await this.paymentRouterClient.createTransferInstruction({
        sourceWallet: wallet,
        total,
        mint
      });
      transaction = await this.solanaClient.buildTransaction({
        feePayer: wallet,
        instructions: [transferInstruction, routeInstruction, memoInstruction, locationMemoInstruction].filter(Boolean)
      });
    } else {
      // Use the authed wallet's userbank and relay
      this.logger.debug(`Using userBank ${await this.claimableTokensClient.deriveUserBank({
        mint: 'USDC'
      })} to purchase...`);
      const paymentRouterTokenAccount = await this.paymentRouterClient.getOrCreateProgramTokenAccount({
        mint
      });
      const transferSecpInstruction = await this.claimableTokensClient.createTransferSecpInstruction({
        destination: paymentRouterTokenAccount.address,
        mint,
        amount: total
      });
      const transferInstruction = await this.claimableTokensClient.createTransferInstruction({
        destination: paymentRouterTokenAccount.address,
        mint
      });
      transaction = await this.solanaClient.buildTransaction({
        feePayer: wallet,
        instructions: [transferSecpInstruction, transferInstruction, routeInstruction, memoInstruction, locationMemoInstruction].filter(Boolean)
      });
    }
    if (params.walletAdapter) {
      if (!params.walletAdapter.publicKey) {
        throw new Error('Param walletAdapter was specified, but no wallet selected');
      }
      return await params.walletAdapter.sendTransaction(transaction, this.solanaClient.connection);
    }
    return this.solanaClient.sendTransaction(transaction, {
      skipPreflight: true
    });
  }
  /**
   * Generates a new track ID
   *
   * @hidden
   */
  async generateTrackId() {
    return this.trackUploadHelper.generateId('track');
  }
}

function equals$1(aa, bb) {
  if (aa === bb) return true;
  if (aa.byteLength !== bb.byteLength) {
    return false;
  }
  for (let ii = 0; ii < aa.byteLength; ii++) {
    if (aa[ii] !== bb[ii]) {
      return false;
    }
  }
  return true;
}
function coerce(o) {
  if (o instanceof Uint8Array && o.constructor.name === 'Uint8Array') return o;
  if (o instanceof ArrayBuffer) return new Uint8Array(o);
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error('Unknown type, must be binary type');
}

/* eslint-disable */
// base-x encoding / decoding
// Copyright (c) 2018 base-x contributors
// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)
// Distributed under the MIT software license, see the accompanying
// file LICENSE or http://www.opensource.org/licenses/mit-license.php.
/**
 * @param {string} ALPHABET
 * @param {any} name
 */
function base(ALPHABET, name) {
  if (ALPHABET.length >= 255) {
    throw new TypeError('Alphabet too long');
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i = 0; i < ALPHABET.length; i++) {
    var x = ALPHABET.charAt(i);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + ' is ambiguous');
    }
    BASE_MAP[xc] = i;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256); // log(BASE) / log(256), rounded up
  var iFACTOR = Math.log(256) / Math.log(BASE); // log(256) / log(BASE), rounded up
  /**
   * @param {any[] | Iterable<number>} source
   */
  function encode(source) {
    // @ts-ignore
    if (source instanceof Uint8Array) ;else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError('Expected Uint8Array');
    }
    if (source.length === 0) {
      return '';
    }
    // Skip & count leading zeroes.
    var zeroes = 0;
    var length = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    // Allocate enough space in big-endian base58 representation.
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    // Process the bytes.
    while (pbegin !== pend) {
      var carry = source[pbegin];
      // Apply "b58 = b58 * 256 + ch".
      var i = 0;
      for (var it1 = size - 1; (carry !== 0 || i < length) && it1 !== -1; it1--, i++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error('Non-zero carry');
      }
      length = i;
      pbegin++;
    }
    // Skip leading zeroes in base58 result.
    var it2 = size - length;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    // Translate the result into a string.
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  /**
   * @param {string | string[]} source
   */
  function decodeUnsafe(source) {
    if (typeof source !== 'string') {
      throw new TypeError('Expected String');
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    // Skip leading spaces.
    if (source[psz] === ' ') {
      return;
    }
    // Skip and count leading '1's.
    var zeroes = 0;
    var length = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    // Allocate enough space in big-endian base256 representation.
    var size = (source.length - psz) * FACTOR + 1 >>> 0; // log(58) / log(256), rounded up.
    var b256 = new Uint8Array(size);
    // Process the characters.
    while (source[psz]) {
      // Decode character
      var carry = BASE_MAP[source.charCodeAt(psz)];
      // Invalid character
      if (carry === 255) {
        return;
      }
      var i = 0;
      for (var it3 = size - 1; (carry !== 0 || i < length) && it3 !== -1; it3--, i++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error('Non-zero carry');
      }
      length = i;
      psz++;
    }
    // Skip trailing spaces.
    if (source[psz] === ' ') {
      return;
    }
    // Skip leading zeroes in b256.
    var it4 = size - length;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j = zeroes;
    while (it4 !== size) {
      vch[j++] = b256[it4++];
    }
    return vch;
  }
  /**
   * @param {string | string[]} string
   */
  function decode(string) {
    var buffer = decodeUnsafe(string);
    if (buffer) {
      return buffer;
    }
    throw new Error(`Non-${name} character`);
  }
  return {
    encode: encode,
    decodeUnsafe: decodeUnsafe,
    decode: decode
  };
}
var src = base;
var _brrp__multiformats_scope_baseX = src;

/**
 * Class represents both BaseEncoder and MultibaseEncoder meaning it
 * can be used to encode to multibase or base encode without multibase
 * prefix.
 */
class Encoder {
  constructor(name, prefix, baseEncode) {
    _defineProperty$1(this, "name", void 0);
    _defineProperty$1(this, "prefix", void 0);
    _defineProperty$1(this, "baseEncode", void 0);
    this.name = name;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  encode(bytes) {
    if (bytes instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes)}`;
    } else {
      throw Error('Unknown type, must be binary type');
    }
  }
}
/**
 * Class represents both BaseDecoder and MultibaseDecoder so it could be used
 * to decode multibases (with matching prefix) or just base decode strings
 * with corresponding base encoding.
 */
class Decoder {
  constructor(name, prefix, baseDecode) {
    _defineProperty$1(this, "name", void 0);
    _defineProperty$1(this, "prefix", void 0);
    _defineProperty$1(this, "baseDecode", void 0);
    _defineProperty$1(this, "prefixCodePoint", void 0);
    this.name = name;
    this.prefix = prefix;
    const prefixCodePoint = prefix.codePointAt(0);
    /* c8 ignore next 3 */
    if (prefixCodePoint === undefined) {
      throw new Error('Invalid prefix character');
    }
    this.prefixCodePoint = prefixCodePoint;
    this.baseDecode = baseDecode;
  }
  decode(text) {
    if (typeof text === 'string') {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error('Can only multibase decode strings');
    }
  }
  or(decoder) {
    return or(this, decoder);
  }
}
class ComposedDecoder {
  constructor(decoders) {
    _defineProperty$1(this, "decoders", void 0);
    this.decoders = decoders;
  }
  or(decoder) {
    return or(this, decoder);
  }
  decode(input) {
    const prefix = input[0];
    const decoder = this.decoders[prefix];
    if (decoder != null) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
}
function or(left, right) {
  var _left$decoders, _right$decoders;
  // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
  return new ComposedDecoder({
    ...((_left$decoders = left.decoders) !== null && _left$decoders !== void 0 ? _left$decoders : {
      [left.prefix]: left
    }),
    ...((_right$decoders = right.decoders) !== null && _right$decoders !== void 0 ? _right$decoders : {
      [right.prefix]: right
    })
  });
}
class Codec {
  constructor(name, prefix, baseEncode, baseDecode) {
    _defineProperty$1(this, "name", void 0);
    _defineProperty$1(this, "prefix", void 0);
    _defineProperty$1(this, "baseEncode", void 0);
    _defineProperty$1(this, "baseDecode", void 0);
    _defineProperty$1(this, "encoder", void 0);
    _defineProperty$1(this, "decoder", void 0);
    this.name = name;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder(name, prefix, baseEncode);
    this.decoder = new Decoder(name, prefix, baseDecode);
  }
  encode(input) {
    return this.encoder.encode(input);
  }
  decode(input) {
    return this.decoder.decode(input);
  }
}
function from$1(_ref) {
  let {
    name,
    prefix,
    encode,
    decode
  } = _ref;
  return new Codec(name, prefix, encode, decode);
}
function baseX(_ref2) {
  let {
    name,
    prefix,
    alphabet
  } = _ref2;
  const {
    encode,
    decode
  } = _brrp__multiformats_scope_baseX(alphabet, name);
  return from$1({
    prefix,
    name,
    encode,
    decode: text => coerce(decode(text))
  });
}
function decode$3(string, alphabet, bitsPerChar, name) {
  // Build the character lookup table:
  const codes = {};
  for (let i = 0; i < alphabet.length; ++i) {
    codes[alphabet[i]] = i;
  }
  // Count the padding bytes:
  let end = string.length;
  while (string[end - 1] === '=') {
    --end;
  }
  // Allocate the output:
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  // Parse the data:
  let bits = 0; // Number of bits currently in the buffer
  let buffer = 0; // Bits waiting to be written out, MSB first
  let written = 0; // Next byte to write
  for (let i = 0; i < end; ++i) {
    // Read one character from the string:
    const value = codes[string[i]];
    if (value === undefined) {
      throw new SyntaxError(`Non-${name} character`);
    }
    // Append the bits to the buffer:
    buffer = buffer << bitsPerChar | value;
    bits += bitsPerChar;
    // Write out some bits if the buffer has a byte's worth:
    if (bits >= 8) {
      bits -= 8;
      out[written++] = 0xff & buffer >> bits;
    }
  }
  // Verify that we have received just enough bits:
  if (bits >= bitsPerChar || (0xff & buffer << 8 - bits) !== 0) {
    throw new SyntaxError('Unexpected end of data');
  }
  return out;
}
function encode$2(data, alphabet, bitsPerChar) {
  const pad = alphabet[alphabet.length - 1] === '=';
  const mask = (1 << bitsPerChar) - 1;
  let out = '';
  let bits = 0; // Number of bits currently in the buffer
  let buffer = 0; // Bits waiting to be written out, MSB first
  for (let i = 0; i < data.length; ++i) {
    // Slurp data into the buffer:
    buffer = buffer << 8 | data[i];
    bits += 8;
    // Write out as much as we can:
    while (bits > bitsPerChar) {
      bits -= bitsPerChar;
      out += alphabet[mask & buffer >> bits];
    }
  }
  // Partial character:
  if (bits !== 0) {
    out += alphabet[mask & buffer << bitsPerChar - bits];
  }
  // Add padding characters until we hit a byte boundary:
  if (pad) {
    while ((out.length * bitsPerChar & 7) !== 0) {
      out += '=';
    }
  }
  return out;
}
/**
 * RFC4648 Factory
 */
function rfc4648(_ref3) {
  let {
    name,
    prefix,
    bitsPerChar,
    alphabet
  } = _ref3;
  return from$1({
    prefix,
    name,
    encode(input) {
      return encode$2(input, alphabet, bitsPerChar);
    },
    decode(input) {
      return decode$3(input, alphabet, bitsPerChar, name);
    }
  });
}

const base32 = rfc4648({
  prefix: 'b',
  name: 'base32',
  alphabet: 'abcdefghijklmnopqrstuvwxyz234567',
  bitsPerChar: 5
});
rfc4648({
  prefix: 'B',
  name: 'base32upper',
  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567',
  bitsPerChar: 5
});
rfc4648({
  prefix: 'c',
  name: 'base32pad',
  alphabet: 'abcdefghijklmnopqrstuvwxyz234567=',
  bitsPerChar: 5
});
rfc4648({
  prefix: 'C',
  name: 'base32padupper',
  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=',
  bitsPerChar: 5
});
rfc4648({
  prefix: 'v',
  name: 'base32hex',
  alphabet: '0123456789abcdefghijklmnopqrstuv',
  bitsPerChar: 5
});
rfc4648({
  prefix: 'V',
  name: 'base32hexupper',
  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV',
  bitsPerChar: 5
});
rfc4648({
  prefix: 't',
  name: 'base32hexpad',
  alphabet: '0123456789abcdefghijklmnopqrstuv=',
  bitsPerChar: 5
});
rfc4648({
  prefix: 'T',
  name: 'base32hexpadupper',
  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV=',
  bitsPerChar: 5
});
rfc4648({
  prefix: 'h',
  name: 'base32z',
  alphabet: 'ybndrfg8ejkmcpqxot1uwisza345h769',
  bitsPerChar: 5
});

const base36 = baseX({
  prefix: 'k',
  name: 'base36',
  alphabet: '0123456789abcdefghijklmnopqrstuvwxyz'
});
baseX({
  prefix: 'K',
  name: 'base36upper',
  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'
});

const base58btc = baseX({
  name: 'base58btc',
  prefix: 'z',
  alphabet: '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'
});
baseX({
  name: 'base58flickr',
  prefix: 'Z',
  alphabet: '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'
});

/* eslint-disable */
var encode_1 = encode$1;
var MSB = 0x80,
  REST = 0x7F,
  MSBALL = ~REST,
  INT = Math.pow(2, 31);
/**
 * @param {number} num
 * @param {number[]} out
 * @param {number} offset
 */
function encode$1(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT) {
    out[offset++] = num & 0xFF | MSB;
    num /= 128;
  }
  while (num & MSBALL) {
    out[offset++] = num & 0xFF | MSB;
    num >>>= 7;
  }
  out[offset] = num | 0;
  // @ts-ignore
  encode$1.bytes = offset - oldOffset + 1;
  return out;
}
var decode$2 = read;
var MSB$1 = 0x80,
  REST$1 = 0x7F;
/**
 * @param {string | any[]} buf
 * @param {number} offset
 */
function read(buf, offset) {
  var res = 0,
    offset = offset || 0,
    shift = 0,
    counter = offset,
    b,
    l = buf.length;
  do {
    if (counter >= l) {
      // @ts-ignore
      read.bytes = 0;
      throw new RangeError('Could not decode varint');
    }
    b = buf[counter++];
    res += shift < 28 ? (b & REST$1) << shift : (b & REST$1) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$1);
  // @ts-ignore
  read.bytes = counter - offset;
  return res;
}
var N1 = Math.pow(2, 7);
var N2 = Math.pow(2, 14);
var N3 = Math.pow(2, 21);
var N4 = Math.pow(2, 28);
var N5 = Math.pow(2, 35);
var N6 = Math.pow(2, 42);
var N7 = Math.pow(2, 49);
var N8 = Math.pow(2, 56);
var N9 = Math.pow(2, 63);
var length = function (/** @type {number} */value) {
  return value < N1 ? 1 : value < N2 ? 2 : value < N3 ? 3 : value < N4 ? 4 : value < N5 ? 5 : value < N6 ? 6 : value < N7 ? 7 : value < N8 ? 8 : value < N9 ? 9 : 10;
};
var varint = {
  encode: encode_1,
  decode: decode$2,
  encodingLength: length
};
var _brrp_varint = varint;

function decode$1(data) {
  let offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  const code = _brrp_varint.decode(data, offset);
  return [code, _brrp_varint.decode.bytes];
}
function encodeTo(int, target) {
  let offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  _brrp_varint.encode(int, target, offset);
  return target;
}
function encodingLength(int) {
  return _brrp_varint.encodingLength(int);
}

/**
 * Creates a multihash digest.
 */
function create(code, digest) {
  const size = digest.byteLength;
  const sizeOffset = encodingLength(code);
  const digestOffset = sizeOffset + encodingLength(size);
  const bytes = new Uint8Array(digestOffset + size);
  encodeTo(code, bytes, 0);
  encodeTo(size, bytes, sizeOffset);
  bytes.set(digest, digestOffset);
  return new Digest(code, size, digest, bytes);
}
/**
 * Turns bytes representation of multihash digest into an instance.
 */
function decode(multihash) {
  const bytes = coerce(multihash);
  const [code, sizeOffset] = decode$1(bytes);
  const [size, digestOffset] = decode$1(bytes.subarray(sizeOffset));
  const digest = bytes.subarray(sizeOffset + digestOffset);
  if (digest.byteLength !== size) {
    throw new Error('Incorrect length');
  }
  return new Digest(code, size, digest, bytes);
}
function equals(a, b) {
  if (a === b) {
    return true;
  } else {
    const data = b;
    return a.code === data.code && a.size === data.size && data.bytes instanceof Uint8Array && equals$1(a.bytes, data.bytes);
  }
}
/**
 * Represents a multihash digest which carries information about the
 * hashing algorithm and an actual hash digest.
 */
class Digest {
  /**
   * Creates a multihash digest.
   */
  constructor(code, size, digest, bytes) {
    _defineProperty$1(this, "code", void 0);
    _defineProperty$1(this, "size", void 0);
    _defineProperty$1(this, "digest", void 0);
    _defineProperty$1(this, "bytes", void 0);
    this.code = code;
    this.size = size;
    this.digest = digest;
    this.bytes = bytes;
  }
}

function format(link, base) {
  const {
    bytes,
    version
  } = link;
  switch (version) {
    case 0:
      return toStringV0(bytes, baseCache(link), base !== null && base !== void 0 ? base : base58btc.encoder);
    default:
      return toStringV1(bytes, baseCache(link), base !== null && base !== void 0 ? base : base32.encoder);
  }
}
const cache = new WeakMap();
function baseCache(cid) {
  const baseCache = cache.get(cid);
  if (baseCache == null) {
    const baseCache = new Map();
    cache.set(cid, baseCache);
    return baseCache;
  }
  return baseCache;
}
class CID {
  /**
   * @param version - Version of the CID
   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param multihash - (Multi)hash of the of the content.
   */
  constructor(version, code, multihash, bytes) {
    _defineProperty$1(this, "code", void 0);
    _defineProperty$1(this, "version", void 0);
    _defineProperty$1(this, "multihash", void 0);
    _defineProperty$1(this, "bytes", void 0);
    _defineProperty$1(this, '/', void 0);
    _defineProperty$1(this, Symbol.toStringTag, 'CID');
    this.code = code;
    this.version = version;
    this.multihash = multihash;
    this.bytes = bytes;
    // flag to serializers that this is a CID and
    // should be treated specially
    this['/'] = bytes;
  }
  /**
   * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`
   * please either use `CID.asCID(cid)` or switch to new signalling mechanism
   *
   * @deprecated
   */
  get asCID() {
    return this;
  }
  // ArrayBufferView
  get byteOffset() {
    return this.bytes.byteOffset;
  }
  // ArrayBufferView
  get byteLength() {
    return this.bytes.byteLength;
  }
  toV0() {
    switch (this.version) {
      case 0:
        {
          return this;
        }
      case 1:
        {
          const {
            code,
            multihash
          } = this;
          if (code !== DAG_PB_CODE) {
            throw new Error('Cannot convert a non dag-pb CID to CIDv0');
          }
          // sha2-256
          if (multihash.code !== SHA_256_CODE) {
            throw new Error('Cannot convert non sha2-256 multihash CID to CIDv0');
          }
          return CID.createV0(multihash);
        }
      default:
        {
          throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
        }
    }
  }
  toV1() {
    switch (this.version) {
      case 0:
        {
          const {
            code,
            digest
          } = this.multihash;
          const multihash = create(code, digest);
          return CID.createV1(this.code, multihash);
        }
      case 1:
        {
          return this;
        }
      default:
        {
          throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`);
        }
    }
  }
  equals(other) {
    return CID.equals(this, other);
  }
  static equals(self, other) {
    const unknown = other;
    return unknown != null && self.code === unknown.code && self.version === unknown.version && equals(self.multihash, unknown.multihash);
  }
  toString(base) {
    return format(this, base);
  }
  toJSON() {
    return {
      '/': format(this)
    };
  }
  link() {
    return this;
  }
  // Legacy
  [Symbol.for('nodejs.util.inspect.custom')]() {
    return `CID(${this.toString()})`;
  }
  /**
   * Takes any input `value` and returns a `CID` instance if it was
   * a `CID` otherwise returns `null`. If `value` is instanceof `CID`
   * it will return value back. If `value` is not instance of this CID
   * class, but is compatible CID it will return new instance of this
   * `CID` class. Otherwise returns null.
   *
   * This allows two different incompatible versions of CID library to
   * co-exist and interop as long as binary interface is compatible.
   */
  static asCID(input) {
    if (input == null) {
      return null;
    }
    const value = input;
    if (value instanceof CID) {
      // If value is instance of CID then we're all set.
      return value;
    } else if (value['/'] != null && value['/'] === value.bytes || value.asCID === value) {
      // If value isn't instance of this CID class but `this.asCID === this` or
      // `value['/'] === value.bytes` is true it is CID instance coming from a
      // different implementation (diff version or duplicate). In that case we
      // rebase it to this `CID` implementation so caller is guaranteed to get
      // instance with expected API.
      const {
        version,
        code,
        multihash,
        bytes
      } = value;
      return new CID(version, code, multihash, bytes !== null && bytes !== void 0 ? bytes : encodeCID(version, code, multihash.bytes));
    } else if (value[cidSymbol] === true) {
      // If value is a CID from older implementation that used to be tagged via
      // symbol we still rebase it to the this `CID` implementation by
      // delegating that to a constructor.
      const {
        version,
        multihash,
        code
      } = value;
      const digest = decode(multihash);
      return CID.create(version, code, digest);
    } else {
      // Otherwise value is not a CID (or an incompatible version of it) in
      // which case we return `null`.
      return null;
    }
  }
  /**
   * @param version - Version of the CID
   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param digest - (Multi)hash of the of the content.
   */
  static create(version, code, digest) {
    if (typeof code !== 'number') {
      throw new Error('String codecs are no longer supported');
    }
    if (!(digest.bytes instanceof Uint8Array)) {
      throw new Error('Invalid digest');
    }
    switch (version) {
      case 0:
        {
          if (code !== DAG_PB_CODE) {
            throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`);
          } else {
            return new CID(version, code, digest, digest.bytes);
          }
        }
      case 1:
        {
          const bytes = encodeCID(version, code, digest.bytes);
          return new CID(version, code, digest, bytes);
        }
      default:
        {
          throw new Error('Invalid version');
        }
    }
  }
  /**
   * Simplified version of `create` for CIDv0.
   */
  static createV0(digest) {
    return CID.create(0, DAG_PB_CODE, digest);
  }
  /**
   * Simplified version of `create` for CIDv1.
   *
   * @param code - Content encoding format code.
   * @param digest - Multihash of the content.
   */
  static createV1(code, digest) {
    return CID.create(1, code, digest);
  }
  /**
   * Decoded a CID from its binary representation. The byte array must contain
   * only the CID with no additional bytes.
   *
   * An error will be thrown if the bytes provided do not contain a valid
   * binary representation of a CID.
   */
  static decode(bytes) {
    const [cid, remainder] = CID.decodeFirst(bytes);
    if (remainder.length !== 0) {
      throw new Error('Incorrect length');
    }
    return cid;
  }
  /**
   * Decoded a CID from its binary representation at the beginning of a byte
   * array.
   *
   * Returns an array with the first element containing the CID and the second
   * element containing the remainder of the original byte array. The remainder
   * will be a zero-length byte array if the provided bytes only contained a
   * binary CID representation.
   */
  static decodeFirst(bytes) {
    const specs = CID.inspectBytes(bytes);
    const prefixSize = specs.size - specs.multihashSize;
    const multihashBytes = coerce(bytes.subarray(prefixSize, prefixSize + specs.multihashSize));
    if (multihashBytes.byteLength !== specs.multihashSize) {
      throw new Error('Incorrect length');
    }
    const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
    const digest = new Digest(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
    const cid = specs.version === 0 ? CID.createV0(digest) : CID.createV1(specs.codec, digest);
    return [cid, bytes.subarray(specs.size)];
  }
  /**
   * Inspect the initial bytes of a CID to determine its properties.
   *
   * Involves decoding up to 4 varints. Typically this will require only 4 to 6
   * bytes but for larger multicodec code values and larger multihash digest
   * lengths these varints can be quite large. It is recommended that at least
   * 10 bytes be made available in the `initialBytes` argument for a complete
   * inspection.
   */
  static inspectBytes(initialBytes) {
    let offset = 0;
    const next = () => {
      const [i, length] = decode$1(initialBytes.subarray(offset));
      offset += length;
      return i;
    };
    let version = next();
    let codec = DAG_PB_CODE;
    if (version === 18) {
      // CIDv0
      version = 0;
      offset = 0;
    } else {
      codec = next();
    }
    if (version !== 0 && version !== 1) {
      throw new RangeError(`Invalid CID version ${version}`);
    }
    const prefixSize = offset;
    const multihashCode = next(); // multihash code
    const digestSize = next(); // multihash length
    const size = offset + digestSize;
    const multihashSize = size - prefixSize;
    return {
      version,
      codec,
      multihashCode,
      digestSize,
      multihashSize,
      size
    };
  }
  /**
   * Takes cid in a string representation and creates an instance. If `base`
   * decoder is not provided will use a default from the configuration. It will
   * throw an error if encoding of the CID is not compatible with supplied (or
   * a default decoder).
   */
  static parse(source, base) {
    const [prefix, bytes] = parseCIDtoBytes(source, base);
    const cid = CID.decode(bytes);
    if (cid.version === 0 && source[0] !== 'Q') {
      throw Error('Version 0 CID string must not include multibase prefix');
    }
    // Cache string representation to avoid computing it on `this.toString()`
    baseCache(cid).set(prefix, source);
    return cid;
  }
}
function parseCIDtoBytes(source, base) {
  switch (source[0]) {
    // CIDv0 is parsed differently
    case 'Q':
      {
        const decoder = base !== null && base !== void 0 ? base : base58btc;
        return [base58btc.prefix, decoder.decode(`${base58btc.prefix}${source}`)];
      }
    case base58btc.prefix:
      {
        const decoder = base !== null && base !== void 0 ? base : base58btc;
        return [base58btc.prefix, decoder.decode(source)];
      }
    case base32.prefix:
      {
        const decoder = base !== null && base !== void 0 ? base : base32;
        return [base32.prefix, decoder.decode(source)];
      }
    case base36.prefix:
      {
        const decoder = base !== null && base !== void 0 ? base : base36;
        return [base36.prefix, decoder.decode(source)];
      }
    default:
      {
        if (base == null) {
          throw Error('To parse non base32, base36 or base58btc encoded CID multibase decoder must be provided');
        }
        return [source[0], base.decode(source)];
      }
  }
}
function toStringV0(bytes, cache, base) {
  const {
    prefix
  } = base;
  if (prefix !== base58btc.prefix) {
    throw Error(`Cannot string encode V0 in ${base.name} encoding`);
  }
  const cid = cache.get(prefix);
  if (cid == null) {
    const cid = base.encode(bytes).slice(1);
    cache.set(prefix, cid);
    return cid;
  } else {
    return cid;
  }
}
function toStringV1(bytes, cache, base) {
  const {
    prefix
  } = base;
  const cid = cache.get(prefix);
  if (cid == null) {
    const cid = base.encode(bytes);
    cache.set(prefix, cid);
    return cid;
  } else {
    return cid;
  }
}
const DAG_PB_CODE = 0x70;
const SHA_256_CODE = 0x12;
function encodeCID(version, code, multihash) {
  const codeOffset = encodingLength(version);
  const hashOffset = codeOffset + encodingLength(code);
  const bytes = new Uint8Array(hashOffset + multihash.byteLength);
  encodeTo(version, bytes, 0);
  encodeTo(code, bytes, codeOffset);
  bytes.set(multihash, hashOffset);
  return bytes;
}
const cidSymbol = Symbol.for('@ipld/js-cid/CID');

const textEncoder = new TextEncoder();
new TextDecoder();
const code = 0x0200;
function encode(node) {
  return textEncoder.encode(JSON.stringify(node));
}

function from(_ref) {
  let {
    name,
    code,
    encode
  } = _ref;
  return new Hasher(name, code, encode);
}
/**
 * Hasher represents a hashing algorithm implementation that produces as
 * `MultihashDigest`.
 */
class Hasher {
  constructor(name, code, encode) {
    _defineProperty$1(this, "name", void 0);
    _defineProperty$1(this, "code", void 0);
    _defineProperty$1(this, "encode", void 0);
    this.name = name;
    this.code = code;
    this.encode = encode;
  }
  digest(input) {
    if (input instanceof Uint8Array) {
      const result = this.encode(input);
      return result instanceof Uint8Array ? create(this.code, result)
      /* c8 ignore next 1 */ : result.then(digest => create(this.code, digest));
    } else {
      throw Error('Unknown type, must be binary type');
      /* c8 ignore next 1 */
    }
  }
}

const sha256 = from({
  name: 'sha2-256',
  code: 0x12,
  encode: input => coerce(crypto$1.createHash('sha256').update(input).digest())
});
from({
  name: 'sha2-512',
  code: 0x13,
  encode: input => coerce(crypto$1.createHash('sha512').update(input).digest())
});

const generateMetadataCidV1 = async metadata => {
  const bytes = encode(metadata);
  const hash = await sha256.digest(bytes);
  return CID.create(1, code, hash);
};

const SolanaAddressSchema = z.string().regex(/^[1-9A-HJ-NP-Za-km-z]+$/, 'Solana address must only contain base58 characters').min(32, 'Solana address must be at least 32 characters').max(44, 'Solana address must not exceed 44 characters').refine(val => {
  try {
    // @ts-ignore - need an unused variable to check if the destinationWallet is valid
    const ignored = new PublicKey(val);
    return true;
  } catch (err) {
    console.debug(err);
    return false;
  }
});

const reactionsMap = {
  '': 1,
  '': 2,
  '': 3,
  '': 4
};
function getReaction(reaction) {
  if (typeof reaction === 'number') {
    return Object.keys(reactionsMap).find(key => reactionsMap[key] === reaction);
  }
  return reactionsMap[reaction];
}

const UserEventsSchema = z.object({
  referrer: z.optional(HashId),
  isMobileUser: z.optional(z.boolean())
});
const CreateUserSchema = z.object({
  profilePictureFile: z.optional(ImageFile),
  coverArtFile: z.optional(ImageFile),
  onProgress: z.optional(z.function()),
  metadata: z.object({
    allowAiAttribution: z.optional(z.boolean()),
    bio: z.optional(z.string()),
    coverPhotoSizes: z.optional(z.string()),
    donation: z.optional(z.string()),
    handle: z.optional(z.string()),
    events: z.optional(UserEventsSchema),
    location: z.optional(z.string()),
    name: z.optional(z.string()),
    profilePictureSizes: z.optional(z.string()),
    splUsdcPayoutWallet: z.optional(z.string()),
    wallet: z.string(),
    website: z.optional(z.string())
  }).strict()
});
const CreateAssociatedWalletsSchema = z.record(z.string(), z.object({
  signature: z.string()
}));
const CollectiblesMetadataSchema = z.union([z.object({
  order: z.array(z.string())
}).catchall(z.object({})), z.null()]);
const PlaylistIdentifierSchema = z.object({
  type: z.literal('playlist'),
  playlist_id: z.number()
});
const ExplorePlaylistIdentifierSchema = z.object({
  type: z.literal('explore_playlist'),
  playlist_id: z.string()
});
const PlaylistLibraryIdentifierSchema = z.union([PlaylistIdentifierSchema, ExplorePlaylistIdentifierSchema]);
const PlaylistLibraryFolderSchema = z.object({
  id: z.string(),
  type: z.literal('folder'),
  name: z.string(),
  contents: z.array(z.lazy(() => z.union([PlaylistLibraryFolderSchema, PlaylistLibraryIdentifierSchema])))
});
const PlaylistLibrarySchema = z.object({
  contents: z.array(z.union([PlaylistLibraryFolderSchema, PlaylistLibraryIdentifierSchema]))
});
const UpdateProfileSchema = z.object({
  userId: HashId,
  events: z.optional(UserEventsSchema),
  profilePictureFile: z.optional(ImageFile),
  coverArtFile: z.optional(ImageFile),
  onProgress: z.optional(z.function()),
  metadata: z.object({
    name: z.optional(z.string()),
    handle: z.optional(z.string()),
    bio: z.optional(z.string()),
    website: z.optional(z.string()),
    donation: z.optional(z.string()),
    location: z.optional(z.string()),
    profileType: z.optional(z.enum(['label']).nullable()),
    metadataMultihash: z.optional(z.string()),
    events: z.optional(UserEventsSchema),
    isDeactivated: z.optional(z.boolean()),
    artistPickTrackId: z.optional(HashId),
    allowAiAttribution: z.optional(z.boolean()),
    playlistLibrary: z.optional(PlaylistLibrarySchema),
    twitterHandle: z.optional(z.string()),
    instagramHandle: z.optional(z.string()),
    tiktokHandle: z.optional(z.string()),
    splUsdcPayoutWallet: z.optional(SolanaAddressSchema).nullable()
  }).strict()
}).strict();
const FollowUserSchema = z.object({
  userId: HashId,
  followeeUserId: HashId
}).strict();
const UnfollowUserSchema = z.object({
  userId: HashId,
  followeeUserId: HashId
}).strict();
const SubscribeToUserSchema = z.object({
  userId: HashId,
  subscribeeUserId: HashId
}).strict();
const UnsubscribeFromUserSchema = z.object({
  userId: HashId,
  subscribeeUserId: HashId
}).strict();
const SendTipSchema = z.object({
  amount: z.number().positive().int(),
  senderUserId: HashId,
  receiverUserId: HashId
}).strict();
const ReactionTypeSchema = z.custom(value => {
  const validReactions = Object.keys(reactionsMap);
  return validReactions.includes(value);
}, {
  message: 'Invalid reaction type'
}).transform((data, ctx) => {
  const value = getReaction(data);
  if (value === undefined) {
    ctx.addIssue({
      code: z.ZodIssueCode.custom,
      message: 'reactionValue invalid'
    });
    return z.NEVER;
  }
  return value;
});
const SendTipReactionRequestSchema = z.object({
  userId: HashId,
  metadata: z.object({
    reactedTo: z.string().nonempty(),
    reactionValue: ReactionTypeSchema
  })
});
const EmailSchema = z.object({
  emailOwnerUserId: z.number(),
  receivingUserId: z.number(),
  initialEmailEncryptionUuid: z.number(),
  granteeUserIds: z.array(z.string()).optional(),
  email: z.string()
});
const WalletSchema = z.discriminatedUnion('chain', [z.object({
  address: SolanaAddressSchema,
  chain: z.literal('sol')
}), z.object({
  // Relaxing type here so we can pass in a string and use EthAddressSchema to validate at runtime
  address: z.string().pipe(EthAddressSchema),
  chain: z.literal('eth')
})]);
const AddAssociatedWalletSchema = z.object({
  userId: HashId,
  wallet: WalletSchema,
  signature: z.string()
});
const RemoveAssociatedWalletSchema = z.object({
  userId: HashId,
  wallet: WalletSchema
});
const UpdateCollectiblesSchema = z.object({
  userId: HashId,
  collectibles: CollectiblesMetadataSchema
});

class UsersApi extends UsersApi$2 {
  constructor(configuration, storage, entityManager, logger, claimableTokens, solanaClient, emailEncryption) {
    super(configuration);
    _defineProperty$1(this, "storage", void 0);
    _defineProperty$1(this, "entityManager", void 0);
    _defineProperty$1(this, "logger", void 0);
    _defineProperty$1(this, "claimableTokens", void 0);
    _defineProperty$1(this, "solanaClient", void 0);
    _defineProperty$1(this, "emailEncryption", void 0);
    this.storage = storage;
    this.entityManager = entityManager;
    this.logger = logger;
    this.claimableTokens = claimableTokens;
    this.solanaClient = solanaClient;
    this.emailEncryption = emailEncryption;
    this.logger = logger.createPrefixedLogger('[users-api]');
  }
  /** @hidden
   * Generate a new user id for use in creation flow
   */
  async generateUserId() {
    const response = new JSONApiResponse$1(await this.request({
      path: '/users/unclaimed_id',
      method: 'GET',
      headers: {},
      query: {
        noCache: Math.floor(Math.random() * 1000).toString()
      }
    }));
    return await response.value();
  }
  /** @hidden
   * Create a user
   */
  async createUser(params, advancedOptions) {
    const {
      onProgress,
      profilePictureFile,
      coverArtFile,
      metadata
    } = await parseParams('createUser', CreateUserSchema)(params);
    const {
      data
    } = await this.generateUserId();
    if (!data) {
      throw new Error('Failed to generate userId');
    }
    const userId = HashId.parse(data);
    const [profilePictureResp, coverArtResp] = await Promise.all([profilePictureFile && retry3(async () => await this.storage.uploadFile({
      file: profilePictureFile,
      onProgress,
      template: 'img_square'
    }), e => {
      this.logger.info('Retrying uploadProfilePicture', e);
    }), coverArtFile && retry3(async () => await this.storage.uploadFile({
      file: coverArtFile,
      onProgress,
      template: 'img_backdrop'
    }), e => {
      this.logger.info('Retrying uploadProfileCoverArt', e);
    })]);
    const updatedMetadata = {
      ...metadata,
      userId,
      ...(profilePictureResp ? {
        profilePicture: profilePictureResp === null || profilePictureResp === void 0 ? void 0 : profilePictureResp.id,
        profilePictureSizes: profilePictureResp === null || profilePictureResp === void 0 ? void 0 : profilePictureResp.id
      } : {}),
      ...(coverArtResp ? {
        coverPhoto: coverArtResp === null || coverArtResp === void 0 ? void 0 : coverArtResp.id,
        coverPhotoSizes: coverArtResp === null || coverArtResp === void 0 ? void 0 : coverArtResp.id
      } : {})
    };
    const entityMetadata = snakecaseKeys(updatedMetadata);
    const cid = (await generateMetadataCidV1(entityMetadata)).toString();
    // Write metadata to chain
    const {
      blockHash,
      blockNumber
    } = await this.entityManager.manageEntity({
      userId,
      entityType: EntityType.USER,
      entityId: userId,
      action: Action.CREATE,
      metadata: JSON.stringify({
        cid,
        data: entityMetadata
      }),
      ...advancedOptions
    });
    return {
      blockHash,
      blockNumber,
      metadata: updatedMetadata
    };
  }
  /** @hidden
   * Creates a guest for guest checkout
   */
  async createGuestAccount(advancedOptions) {
    const {
      data
    } = await this.generateUserId();
    if (!data) {
      throw new Error('Failed to generate userId');
    }
    const userId = HashId.parse(data);
    const metadata = {
      userId
    };
    // Write metadata to chain
    const {
      blockHash,
      blockNumber
    } = await this.entityManager.manageEntity({
      userId,
      entityType: EntityType.USER,
      entityId: userId,
      action: Action.CREATE,
      metadata: JSON.stringify({
        cid: null,
        data: null
      }),
      ...advancedOptions
    });
    return {
      blockHash,
      blockNumber,
      metadata
    };
  }
  /** @hidden
   * Update a user profile
   */
  async updateProfile(params, advancedOptions) {
    // Parse inputs
    const {
      onProgress,
      profilePictureFile,
      coverArtFile,
      userId,
      metadata
    } = await parseParams('updateProfile', UpdateProfileSchema)(params);
    const [profilePictureResp, coverArtResp] = await Promise.all([profilePictureFile && retry3(async () => await this.storage.uploadFile({
      file: profilePictureFile,
      onProgress,
      template: 'img_square'
    }), e => {
      this.logger.info('Retrying uploadProfilePicture', e);
    }), coverArtFile && retry3(async () => await this.storage.uploadFile({
      file: coverArtFile,
      onProgress,
      template: 'img_backdrop'
    }), e => {
      this.logger.info('Retrying uploadProfileCoverArt', e);
    })]);
    const updatedMetadata = snakecaseKeys({
      ...metadata,
      ...(profilePictureResp ? {
        profilePicture: profilePictureResp === null || profilePictureResp === void 0 ? void 0 : profilePictureResp.id,
        profilePictureSizes: profilePictureResp === null || profilePictureResp === void 0 ? void 0 : profilePictureResp.id
      } : {}),
      ...(coverArtResp ? {
        coverPhoto: coverArtResp === null || coverArtResp === void 0 ? void 0 : coverArtResp.id,
        coverPhotoSizes: coverArtResp === null || coverArtResp === void 0 ? void 0 : coverArtResp.id
      } : {})
    });
    const cid = (await generateMetadataCidV1(updatedMetadata)).toString();
    // Write metadata to chain
    return await this.entityManager.manageEntity({
      userId,
      entityType: EntityType.USER,
      entityId: userId,
      action: Action.UPDATE,
      metadata: JSON.stringify({
        cid,
        data: updatedMetadata
      }),
      ...advancedOptions
    });
  }
  /** @hidden
   * Follow a user
   */
  async followUser(params, advancedOptions) {
    // Parse inputs
    const {
      userId,
      followeeUserId
    } = await parseParams('followUser', FollowUserSchema)(params);
    return await this.entityManager.manageEntity({
      userId,
      entityType: EntityType.USER,
      entityId: followeeUserId,
      action: Action.FOLLOW,
      ...advancedOptions
    });
  }
  /** @hidden
   * Unfollow a user
   */
  async unfollowUser(params, advancedOptions) {
    // Parse inputs
    const {
      userId,
      followeeUserId
    } = await parseParams('unfollowUser', UnfollowUserSchema)(params);
    return await this.entityManager.manageEntity({
      userId,
      entityType: EntityType.USER,
      entityId: followeeUserId,
      action: Action.UNFOLLOW,
      ...advancedOptions
    });
  }
  /** @hidden
   * Subscribe to a user
   */
  async subscribeToUser(params, advancedOptions) {
    // Parse inputs
    const {
      userId,
      subscribeeUserId
    } = await parseParams('subscribeToUser', SubscribeToUserSchema)(params);
    return await this.entityManager.manageEntity({
      userId,
      entityType: EntityType.USER,
      entityId: subscribeeUserId,
      action: Action.SUBSCRIBE,
      ...advancedOptions
    });
  }
  /** @hidden
   * Unsubscribe from a user
   */
  async unsubscribeFromUser(params, advancedOptions) {
    // Parse inputs
    const {
      userId,
      subscribeeUserId
    } = await parseParams('unsubscribeFromUser', UnsubscribeFromUserSchema)(params);
    return await this.entityManager.manageEntity({
      userId,
      entityType: EntityType.USER,
      entityId: subscribeeUserId,
      action: Action.UNSUBSCRIBE,
      ...advancedOptions
    });
  }
  /**
   * Downloads the sales the user has made as a CSV file.
   * Similar to generated raw method, but forced response type as blob
   */
  async downloadSalesAsCSVBlob(params) {
    if (params.id === null || params.id === undefined) {
      throw new RequiredError$1('id', 'Required parameter params.id was null or undefined when calling downloadSalesAsCSV.');
    }
    const queryParameters = {};
    if (params.userId !== undefined) {
      queryParameters.user_id = params.userId;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/users/{id}/sales/download`.replace(`{${'id'}}`, encodeURIComponent(String(params.id))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    });
    return await new BlobApiResponse$1(response).value();
  }
  /**
   * Downloads the purchases the user has made as a CSV file.
   * Similar to generated raw method, but forced response type as blob
   */
  async downloadPurchasesAsCSVBlob(params) {
    if (params.id === null || params.id === undefined) {
      throw new RequiredError$1('id', 'Required parameter params.id was null or undefined when calling downloadPurchasesAsCSV.');
    }
    const queryParameters = {};
    if (params.userId !== undefined) {
      queryParameters.user_id = params.userId;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/users/{id}/purchases/download`.replace(`{${'id'}}`, encodeURIComponent(String(params.id))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    });
    return await new BlobApiResponse$1(response).value();
  }
  /**
   * Downloads the USDC withdrawals the user has made as a CSV file
   * Similar to generated raw method, but forced response type as blob
   */
  async downloadUSDCWithdrawalsAsCSVBlob(params) {
    if (params.id === null || params.id === undefined) {
      throw new RequiredError$1('id', 'Required parameter params.id was null or undefined when calling downloadUSDCWithdrawalsAsCSV.');
    }
    const queryParameters = {};
    if (params.userId !== undefined) {
      queryParameters.user_id = params.userId;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/users/{id}/withdrawals/download`.replace(`{${'id'}}`, encodeURIComponent(String(params.id))),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters
    });
    return await new BlobApiResponse$1(response).value();
  }
  /**
   * Sends a wAUDIO tip from one user to another.
   * @hidden subject to change
   */
  async sendTip(request) {
    const {
      amount
    } = await parseParams('sendTip', SendTipSchema)(request);
    const {
      ethWallet
    } = await this.getWalletAndUserBank(request.senderUserId);
    const {
      ethWallet: receiverEthWallet,
      userBank: destination
    } = await this.getWalletAndUserBank(request.receiverUserId);
    if (!ethWallet) {
      throw new Error('Invalid sender: No Ethereum wallet found.');
    }
    if (!receiverEthWallet) {
      throw new Error('Invalid recipient: No Ethereum wallet found.');
    }
    if (!destination) {
      throw new Error('Invalid recipient: No user bank found.');
    }
    const secp = await this.claimableTokens.createTransferSecpInstruction({
      ethWallet,
      destination,
      amount: wAUDIO(amount).value,
      mint: 'wAUDIO'
    });
    const transfer = await this.claimableTokens.createTransferInstruction({
      ethWallet,
      destination,
      mint: 'wAUDIO'
    });
    const transaction = await this.solanaClient.buildTransaction({
      instructions: [secp, transfer]
    });
    return await this.claimableTokens.sendTransaction(transaction);
  }
  /**
   * Submits a reaction to a tip being received.
   * @hidden
   */
  async sendTipReaction(params, advancedOptions) {
    // Parse inputs
    const {
      userId,
      metadata
    } = await parseParams('sendTipReaction', SendTipReactionRequestSchema)(params);
    return await this.entityManager.manageEntity({
      userId,
      entityType: EntityType.TIP,
      entityId: userId,
      action: Action.UPDATE,
      metadata: JSON.stringify({
        cid: '',
        data: snakecaseKeys(metadata)
      }),
      ...advancedOptions
    });
  }
  /**
   * Helper function for sendTip that gets the user wallet and creates
   * or gets the wAUDIO user bank for given user ID.
   */
  async getWalletAndUserBank(id) {
    var _res$data;
    const res = await this.getUser({
      id
    });
    const ethWallet = (_res$data = res.data) === null || _res$data === void 0 ? void 0 : _res$data.ercWallet;
    if (!ethWallet) {
      return {
        ethWallet: null,
        userBank: null
      };
    }
    const {
      userBank
    } = await this.claimableTokens.getOrCreateUserBank({
      ethWallet,
      mint: 'wAUDIO'
    });
    return {
      ethWallet,
      userBank
    };
  }
  /** @hidden
   * Share an encrypted email with a user
   */
  async shareEmail(params, advancedOptions) {
    const {
      emailOwnerUserId,
      receivingUserId,
      email,
      granteeUserIds,
      initialEmailEncryptionUuid
    } = await parseParams('shareEmail', EmailSchema)(params);
    let symmetricKey;
    // Get hashed IDs and validate
    const emailOwnerUserIdHash = encodeHashId(emailOwnerUserId);
    const receivingUserIdHash = encodeHashId(receivingUserId);
    const initialEmailEncryptionUuidHash = encodeHashId(initialEmailEncryptionUuid);
    if (!emailOwnerUserIdHash || !receivingUserIdHash || !initialEmailEncryptionUuidHash) {
      throw new Error('Email owner user ID and receiving user ID are required');
    }
    const accessGrants = [];
    const {
      data: {
        encryptedKey: emailOwnerKey,
        isInitial
      } = {
        encryptedKey: '',
        isInitial: false
      }
    } = await this.getUserEmailKey({
      receivingUserId: emailOwnerUserIdHash,
      grantorUserId: emailOwnerUserIdHash
    });
    let action, entityType;
    if (emailOwnerKey) {
      symmetricKey = await this.emailEncryption.decryptSymmetricKey(emailOwnerKey, isInitial ? initialEmailEncryptionUuidHash : emailOwnerUserIdHash);
      action = Action.UPDATE;
      entityType = EntityType.EMAIL_ACCESS;
    } else {
      symmetricKey = this.emailEncryption.createSymmetricKey();
      // Create encrypted keys for owner and receiver
      const ownerEncryptedKey = await this.emailEncryption.encryptSymmetricKey(emailOwnerUserIdHash, symmetricKey);
      accessGrants.push({
        receiving_user_id: emailOwnerUserId,
        grantor_user_id: emailOwnerUserId,
        encrypted_key: ownerEncryptedKey
      });
      action = Action.ADD_EMAIL;
      entityType = EntityType.ENCRYPTED_EMAIL;
    }
    const encryptedEmail = await this.emailEncryption.encryptEmail(email, symmetricKey);
    const receiverEncryptedKey = await this.emailEncryption.encryptSymmetricKey(receivingUserIdHash, symmetricKey);
    accessGrants.push({
      receiving_user_id: receivingUserId,
      grantor_user_id: emailOwnerUserId,
      encrypted_key: receiverEncryptedKey
    });
    if (granteeUserIds !== null && granteeUserIds !== void 0 && granteeUserIds.length) {
      await Promise.all(granteeUserIds.map(async granteeUserIdHash => {
        const granteeEncryptedKey = await this.emailEncryption.encryptSymmetricKey(granteeUserIdHash, symmetricKey);
        accessGrants.push({
          receiving_user_id: decodeHashId(granteeUserIdHash),
          grantor_user_id: receivingUserId,
          encrypted_key: granteeEncryptedKey
        });
      }));
    }
    const metadata = {
      email_owner_user_id: emailOwnerUserId,
      encrypted_email: encryptedEmail,
      access_grants: accessGrants
    };
    return await this.entityManager.manageEntity({
      userId: emailOwnerUserId,
      entityType,
      entityId: emailOwnerUserId,
      action,
      metadata: JSON.stringify({
        cid: '',
        data: metadata
      }),
      ...advancedOptions
    });
  }
  /** @hidden
   * Associate a new wallet with a user
   */
  async addAssociatedWallet(params, advancedOptions) {
    const {
      userId,
      wallet: {
        address: wallet_address,
        chain
      },
      signature
    } = await parseParams('addAssociatedWallet', AddAssociatedWalletSchema)(params);
    return await this.entityManager.manageEntity({
      userId,
      entityType: EntityType.ASSOCIATED_WALLET,
      entityId: 0,
      action: Action.CREATE,
      metadata: JSON.stringify({
        cid: '',
        data: {
          wallet_address,
          chain,
          signature
        }
      }),
      ...advancedOptions
    });
  }
  /** @hidden
   * Remove a wallet from a user
   */
  async removeAssociatedWallet(params) {
    const {
      userId,
      wallet: {
        address: wallet_address,
        chain
      }
    } = await parseParams('removeAssociatedWallet', RemoveAssociatedWalletSchema)(params);
    return await this.entityManager.manageEntity({
      userId,
      entityType: EntityType.ASSOCIATED_WALLET,
      entityId: 0,
      action: Action.DELETE,
      metadata: JSON.stringify({
        cid: '',
        data: {
          wallet_address,
          chain
        }
      })
    });
  }
  /** @hidden
   * Update user collectibles preferences
   */
  async updateCollectibles(params) {
    const {
      userId,
      collectibles
    } = await parseParams('updateCollectibles', UpdateCollectiblesSchema)(params);
    return await this.entityManager.manageEntity({
      userId,
      entityType: EntityType.COLLECTIBLES,
      entityId: 0,
      action: Action.UPDATE,
      metadata: JSON.stringify({
        cid: '',
        data: {
          collectibles: collectibles !== null && collectibles !== void 0 ? collectibles : {}
        }
      })
    });
  }
}

const developmentConfig = {
  network: {
    minVersion: '0.0.0',
    apiEndpoint: 'http://audius-api',
    storageNodes: [{
      delegateOwnerWallet: '0x0D38e653eC28bdea5A2296fD5940aaB2D0B8875c',
      endpoint: 'http://audius-creator-node-1'
    }],
    antiAbuseOracleNodes: {
      endpoints: ['http://audius-anti-abuse-oracle-1:8000'],
      registeredAddresses: ['0xF0D5BC18421fa04D0a2A2ef540ba5A9f04014BE3']
    },
    identityService: 'http://audius-identity-service-1'
  },
  acdc: {
    entityManagerContractAddress: '0x254dffcd3277C0b1660F6d42EFbB754edaBAbC2B',
    chainId: 1337
  },
  solana: {
    claimableTokensProgramAddress: 'testHKV1B56fbvop4w6f2cTGEub9dRQ2Euta5VmqdX9',
    rewardManagerProgramAddress: 'testLsJKtyABc9UXJF8JWFKf1YH4LmqCWBC42c6akPb',
    rewardManagerStateAddress: 'DJPzVothq58SmkpRb1ATn5ddN2Rpv1j2TcGvM3XsHf1c',
    paymentRouterProgramAddress: 'apaySbqV1XAmuiGszeN4NyWrXkkMrnuJVoNhzmS1AMa',
    stakingBridgeProgramAddress: '',
    rpcEndpoint: 'http://audius-solana-test-validator-1',
    usdcTokenMint: '26Q7gP8UfkDzi7GMFEQxTJaNJ8D2ybCUjex58M5MLu8y',
    wAudioTokenMint: '37RCjhgV1qGV2Q54EHFScdxZ22ydRMdKMtVgod47fDP3',
    bonkTokenMint: 'DezXAZ8z7PnrnRJjz3wXBoRgixCa6xjnB7YaB1pPB263',
    rewardManagerLookupTableAddress: 'GNHKVSmHvoRBt1JJCxz7RSMfzDQGDGhGEjmhHyxb3K5J'
  },
  ethereum: {
    rpcEndpoint: 'http://audius-eth-ganache-1',
    addresses: {
      ethRewardsManagerAddress: '0x',
      serviceProviderFactoryAddress: '0x',
      serviceTypeManagerAddress: '0x',
      audiusTokenAddress: '0xdcB2fC9469808630DD0744b0adf97C0003fC29B2',
      audiusWormholeAddress: '0x',
      delegateManagerAddress: '0x',
      stakingAddress: '0x'
    }
  }
};

const stagingConfig = {
  network: {
    minVersion: '0.6.0',
    apiEndpoint: 'https://api.staging.audius.co',
    storageNodes: [{
      endpoint: 'https://creatornode12.staging.audius.co',
      delegateOwnerWallet: '0x6b52969934076318863243fb92E9C4b3A08267b5'
    }, {
      endpoint: 'https://creatornode5.staging.audius.co',
      delegateOwnerWallet: '0xDC2BDF1F23381CA2eC9e9c70D4FD96CD8645D090'
    }, {
      endpoint: 'https://creatornode6.staging.audius.co',
      delegateOwnerWallet: '0x68039d001D87E7A5E6B06fe0825EA7871C1Cd6C2'
    }, {
      endpoint: 'https://creatornode7.staging.audius.co',
      delegateOwnerWallet: '0x1F8e7aF58086992Ef4c4fc0371446974BBbC0D9F'
    }, {
      endpoint: 'https://creatornode9.staging.audius.co',
      delegateOwnerWallet: '0x140eD283b33be2145ed7d9d15f1fE7bF1E0B2Ac3'
    }, {
      endpoint: 'https://creatornode11.staging.audius.co',
      delegateOwnerWallet: '0x4c88d2c0f4c4586b41621aD6e98882ae904B98f6'
    }],
    antiAbuseOracleNodes: {
      endpoints: ['https://discoveryprovider.staging.audius.co'],
      registeredAddresses: ['0x00b6462e955dA5841b6D9e1E2529B830F00f31Bf', '0x57B57efFA54ba37DBF8A06B9c42E7611e84BDe6F', '0xF617bbc0913bAE0a13f6D4A19eCDE5Aa07B0fF0A']
    },
    identityService: 'https://identityservice.staging.audius.co'
  },
  acdc: {
    entityManagerContractAddress: '0x1Cd8a543596D499B9b6E7a6eC15ECd2B7857Fd64',
    chainId: 1056801
  },
  solana: {
    claimableTokensProgramAddress: '2sjQNmUfkV6yKKi4dPR8gWRgtyma5aiymE3aXL2RAZww',
    rewardManagerProgramAddress: 'CDpzvz7DfgbF95jSSCHLX3ERkugyfgn9Fw8ypNZ1hfXp',
    rewardManagerStateAddress: 'GaiG9LDYHfZGqeNaoGRzFEnLiwUT7WiC6sA6FDJX9ZPq',
    paymentRouterProgramAddress: 'sp28KA2bTnTA4oSZ3r9tTSKfmiXZtZQHnYYQqWfUyVa',
    stakingBridgeProgramAddress: 'stkuyR7dTzxV1YnoDo5tfuBmkuKn7zDatimYRDTmQvj',
    rpcEndpoint: 'https://audius-fe.rpcpool.com',
    usdcTokenMint: 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v',
    wAudioTokenMint: 'BELGiMZQ34SDE6x2FUaML2UHDAgBLS64xvhXjX5tBBZo',
    bonkTokenMint: 'DezXAZ8z7PnrnRJjz3wXBoRgixCa6xjnB7YaB1pPB263',
    rewardManagerLookupTableAddress: 'ChFCWjeFxM6SRySTfT46zXn2K7m89TJsft4HWzEtkB4J'
  },
  ethereum: {
    rpcEndpoint: 'https://eth-client.staging.audius.co',
    addresses: {
      ethRewardsManagerAddress: '0x563483ccD66a49Ca730275F8cf37Dd3E6Da864f1',
      serviceProviderFactoryAddress: '0x377BE01aD31360d0DFB16035A4515954395A8185',
      serviceTypeManagerAddress: '0x9fd76d2cD48022526F3a164541E6552291F4a862',
      audiusTokenAddress: '0x1376180Ee935AA64A27780F4BE97726Df7B0e2B2',
      audiusWormholeAddress: '0xf6f45e4d836da1d4ecd43bb1074620bfb0b7e0d7',
      delegateManagerAddress: '0xDA74d6FfbF268Ac441404f5a61f01103451E8697',
      stakingAddress: '0x5bcF21A4D5Bab9B0869B9c55D233f80135C814C6'
    }
  }
};

let appName;
let apiKey;
/**
 * Appends the configured app_name to the query string for tracking API usage
 * @param options the middleware options
 * @param {string} options.appName the name of the app using the SDK
 */
const addAppInfoMiddleware = _ref => {
  let {
    apiKey: providedApiKey,
    appName: providedAppName,
    services,
    basePath
  } = _ref;
  apiKey = providedApiKey;
  appName = providedAppName;
  return {
    pre: async context => {
      var _appName, _apiKey;
      // If an app name is not provided, fetch the name from the dev app
      if (!providedAppName) {
        const apiClientConfig = new Configuration$1({
          fetchApi: fetch$1,
          basePath
        });
        const developerApps = new DeveloperAppsApi(apiClientConfig, services.entityManager);
        apiKey = providedApiKey !== null && providedApiKey !== void 0 ? providedApiKey : (await services.audiusWalletClient.getAddresses())[0];
        if (apiKey) {
          var _await$developerApps$;
          appName = (_await$developerApps$ = (await developerApps.getDeveloperApp({
            address: apiKey
          })).data) === null || _await$developerApps$ === void 0 ? void 0 : _await$developerApps$.name;
        }
      }
      if (!appName && !apiKey) {
        throw new Error('No appName or apiKey provided');
      }
      return {
        ...context,
        url: context.url + (context.url.includes('?') ? '&' : '?') + querystring$1({
          app_name: (_appName = appName) !== null && _appName !== void 0 ? _appName : '',
          api_key: (_apiKey = apiKey) !== null && _apiKey !== void 0 ? _apiKey : ''
        }),
        init: {
          ...context.init
        }
      };
    }
  };
};

const SIGNATURE_EXPIRY_MS = 24 /* hr */ * 60 /* min */ * 60 /* sec */ * 1000; /* ms */ // 1 day
const MESSAGE_HEADER = 'Encoded-Data-Message';
const SIGNATURE_HEADER = 'Encoded-Data-Signature';
/**
 * Appends request authentication headers to a request.
 * Request headers are computed only every SIGNATURE_EXPIRY_MS or when the value returned by `auth.getAddress()` changes.
 * @param options the middleware options
 */
const addRequestSignatureMiddleware = _ref => {
  let {
    services,
    apiKey,
    apiSecret
  } = _ref;
  const mutex = new Mutex();
  let message = null;
  let signatureAddress = null;
  let signature = null;
  let timestamp = null;
  let appWalletClient = null;
  const getSignature = async () => {
    // Run this exclusively to prevent multiple requests from updating the signature at the same time
    // and reverting to an older signature
    return mutex.runExclusive(async () => {
      const {
        audiusWalletClient,
        logger
      } = services;
      try {
        // Prefer signing with audiusWalletClient if provided
        if (apiSecret && !audiusWalletClient) {
          appWalletClient = createAppWalletClient({
            apiKey: apiKey !== null && apiKey !== void 0 ? apiKey : '0x0000000000000000000000000000000000000000',
            apiSecret
          });
        }
        const signingClient = audiusWalletClient !== null && audiusWalletClient !== void 0 ? audiusWalletClient : appWalletClient;
        const [currentAddress] = await signingClient.getAddresses();
        const currentTimestamp = new Date().getTime();
        const isExpired = !timestamp || timestamp + SIGNATURE_EXPIRY_MS < currentTimestamp;
        const needsUpdate = !message || !signature || isExpired || signatureAddress !== currentAddress;
        if (needsUpdate) {
          if (!currentAddress) {
            throw new Error('Could not get a wallet address.');
          }
          signatureAddress = currentAddress;
          const m = `signature:${currentTimestamp}`;
          signature = await signingClient.signMessage({
            message: m
          });
          // Cache the new signature and message
          message = m;
          timestamp = currentTimestamp;
        }
      } catch (e) {
        // Don't log a warning for HedgehogWalletNotFoundError as it's expected when user is logged out
        if (!(e instanceof HedgehogWalletNotFoundError)) {
          logger.warn(`Unable to add request signature: ${e}`);
        }
      }
      return {
        message,
        signature
      };
    });
  };
  return {
    pre: async context => {
      // If request already has a signature, skip adding it
      const existingHeaders = context.init.headers;
      if (existingHeaders[MESSAGE_HEADER] && existingHeaders[SIGNATURE_HEADER]) {
        return context;
      }
      const {
        message,
        signature
      } = await getSignature();
      // Return the updated request with the signature in the headers
      return !!message && !!signature ? {
        ...context,
        url: context.url,
        init: {
          ...context.init,
          headers: {
            ...context.init.headers,
            [MESSAGE_HEADER]: message,
            [SIGNATURE_HEADER]: signature
          }
        }
      } : context;
    }
  };
};

const isOAuthScopeValid = scope => {
  const validScopes = new Set(OAUTH_SCOPE_OPTIONS);
  return scope.findIndex(s => !validScopes.has(s)) === -1;
};
const isWriteOnceParams = object => {
  return 'tx' in object && object.tx === 'connect_dashboard_wallet' && 'wallet' in object || object.tx === 'disconnect_dashboard_wallet' && 'wallet' in object;
};

const IsWriteAccessGrantedSchema = z.object({
  userId: z.string(),
  apiKey: z.optional(z.custom(data => {
    return isApiKeyValid(data);
  }))
});
const OAUTH_SCOPE_OPTIONS = ['read', 'write', 'write_once'];
const OAUTH_URL = {
  production: 'https://audius.co/oauth/auth',
  staging: 'https://staging.audius.co/oauth/auth'
};

const CSS = `
.audiusLoginButton {
  cursor: pointer;
  font-family: Helvetica, Arial, sans-serif;
  text-align: center;
  color: #FFFFFF;
  font-weight: 700;
  font-size: 14px;
  line-height: 100%;
  align-items: center;
  display: flex;
  border: 0;
  height: 28px;
  justify-content: center;
  padding: 0px 16px;
  background: #CC0FE0;
  border-radius: 4px;
  transition: all 0.07s ease-in-out;
}

.audiusLoginButton:hover {
  background: #D127E3;
  transform: perspective(1px) scale3d(1.04, 1.04, 1.04);
}

.audiusLoginButton.disableHoverGrow:hover {
  transform: none;
}

.audiusLoginButton:active {
  background: #A30CB3;
}

.audiusLoginButton.pill {
  border-radius: 99px;
}

.audiusLoginButton.fullWidth {
  width: 100%;
}

.audiusLoginButton.small {
  height: 20px;
  font-size: 11px;
  padding: 0px 32px;
}

.audiusLoginButton.large {
  height: 40px;
  font-size: 18px;
  padding: 0px 18px;
}
`;
// From https://stackoverflow.com/a/27747377
const generateId = () => {
  const arr = new Uint8Array(40 / 2) // Result of function will be 40 chars long
  ;
  (window.crypto || window.msCrypto).getRandomValues(arr);
  return Array.from(arr, function dec2hex(dec) {
    return dec.toString(16).padStart(2, '0');
  }).join('');
};
const generateAudiusLogoSvg = size => {
  let height;
  let paddingRight;
  if (size === 'small') {
    height = 16;
    paddingRight = 5;
  } else if (size === 'medium') {
    height = 18;
    paddingRight = 5;
  } else {
    height = 24;
    paddingRight = 10;
  }
  return `<svg width="${height}px" height="${height}px" viewBox="0 0 56 48" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" style="padding-right: ${paddingRight}px;">
<g id="Assets" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
    <g id="assets" transform="translate(-1555.000000, -2588.000000)">
        <g id="audiusLogoGlyph" transform="translate(1555.000000, 2588.000000)">
            <path d="M55.8191698,46.0362519 L42.4551012,23.3458831 L36.1870263,12.7036635 L29.0910326,0.65551431 C28.5766233,-0.217848954 27.2890668,-0.218676884 26.7734944,0.654065432 L13.3787621,23.3270477 L7.90582764,32.5909699 C7.39025522,33.4637122 8.03324043,34.5553386 9.06332791,34.5560631 L19.4031138,34.56279 C19.881044,34.5631005 20.3230236,34.3136864 20.5623059,33.9087249 L25.9362708,24.8122516 L26.7580568,23.4212248 C26.790518,23.3662709 26.8260456,23.3149392 26.8641108,23.2669192 C27.4325516,22.5520012 28.5935412,22.6041608 29.0755951,23.4226737 L34.6514114,32.8894388 L35.682239,34.6396841 C35.7412402,34.7399672 35.7843808,34.8430445 35.813987,34.9470533 C36.0430129,35.7492145 35.4339691,36.6039494 34.5220954,36.6034319 L22.3586676,36.5954631 C21.8806317,36.5951526 21.4387578,36.8445667 21.1994756,37.2496317 L16.0236614,46.0105861 C15.5080889,46.8833284 16.1510741,47.9749548 17.1810559,47.9756793 L27.9002253,47.9827167 L41.2664086,47.9913065 L54.6590261,47.9999997 C55.6892193,48.0006207 56.3335791,46.9096152 55.8191698,46.0362519" id="Audius-Logo" fill="#ffffff" fill-rule="evenodd"></path>
            <rect id="bound" x="0" y="0" width="56" height="48"></rect>
        </g>
    </g>
</g>
</svg>`;
};
const CSRF_TOKEN_KEY = 'audiusOauthState';
class OAuth {
  constructor(config) {
    var _config$apiKey;
    _defineProperty$1(this, "config", void 0);
    _defineProperty$1(this, "activePopupWindow", void 0);
    _defineProperty$1(this, "popupCheckInterval", void 0);
    _defineProperty$1(this, "loginSuccessCallback", void 0);
    _defineProperty$1(this, "loginErrorCallback", void 0);
    _defineProperty$1(this, "apiKey", void 0);
    _defineProperty$1(this, "env", 'production');
    _defineProperty$1(this, "logger", void 0);
    this.config = config;
    if (typeof window === 'undefined') {
      throw new Error('Audius OAuth SDK functions are only available in browser. Refer to our documentation to learn how to implement Audius OAuth manually: https://docs.audius.org/developers/log-in-with-audius#manual-implementation.');
    }
    this.apiKey = (_config$apiKey = config.apiKey) !== null && _config$apiKey !== void 0 ? _config$apiKey : null;
    this.activePopupWindow = null;
    this.loginSuccessCallback = null;
    this.loginErrorCallback = null;
    this.popupCheckInterval = null;
    this.logger = config.logger.createPrefixedLogger('[oauth]');
  }
  init(_ref) {
    let {
      successCallback,
      errorCallback,
      env = 'production'
    } = _ref;
    this.loginSuccessCallback = successCallback;
    this.loginErrorCallback = errorCallback !== null && errorCallback !== void 0 ? errorCallback : null;
    this.env = env;
    window.addEventListener('message', e => {
      this._receiveMessage(e);
    }, false);
  }
  async isWriteAccessGranted(params) {
    var _authorizedApps$data;
    const {
      userId,
      apiKey
    } = await parseParams('isWriteAccessGranted', IsWriteAccessGrantedSchema)(params);
    if (!this.apiKey && !apiKey) {
      this._surfaceError('Need to init Audius SDK with API key or pass in API Key directly to oauth.isWriteAccessGranted.');
    }
    const authorizedApps = await this.config.usersApi.getAuthorizedApps({
      id: userId
    });
    const foundIndex = (_authorizedApps$data = authorizedApps.data) === null || _authorizedApps$data === void 0 ? void 0 : _authorizedApps$data.findIndex(a => a.address.toLowerCase() === `0x${(apiKey || this.apiKey).toLowerCase()}`);
    return foundIndex !== undefined && foundIndex > -1;
  }
  login(_ref2) {
    let {
      scope = 'read',
      params,
      redirectUri = 'postMessage',
      display = 'popup',
      responseMode = 'fragment'
    } = _ref2;
    const scopeFormatted = typeof scope === 'string' ? [scope] : scope;
    if (!this.config.appName && !this.apiKey) {
      this._surfaceError('App name not set (set with `init` method).');
      return;
    }
    if (scopeFormatted.includes('write') && !this.apiKey) {
      this._surfaceError("The 'write' scope requires Audius SDK to be initialized with an API key");
    }
    if (!this.loginSuccessCallback) {
      this._surfaceError('Login success callback not set (set with `init` method).');
      return;
    }
    if (!isOAuthScopeValid(scopeFormatted)) {
      this._surfaceError('Scope must be `read` or `write`.');
      return;
    }
    const effectiveScope = scopeFormatted.includes('write') ? 'write' : scopeFormatted.includes('write_once') ? 'write_once' : 'read';
    if (effectiveScope === 'write_once' && !isWriteOnceParams(params)) {
      this._surfaceError('Missing correct params for `oauth.login`.');
      return;
    }
    const csrfToken = generateId();
    window.localStorage.setItem(CSRF_TOKEN_KEY, csrfToken);
    const windowOptions = 'toolbar=no, location=no, directories=no, status=no, menubar=no, scrollbars=no, resizable=no, copyhistory=no, width=375, height=785, top=100, left=100';
    const originURISafe = encodeURIComponent(window.location.origin);
    const appIdURISafe = encodeURIComponent(this.apiKey || this.config.appName);
    const writeOnceParams = effectiveScope !== 'write_once' ? '' : `&tx=${encodeURIComponent(params.tx)}&wallet=${encodeURIComponent(params.wallet)}`;
    const appIdURIParam = `${this.apiKey ? 'api_key' : 'app_name'}=${appIdURISafe}`;
    const responseModeParam = `response_mode=${responseMode}`;
    const fullOauthUrl = `${OAUTH_URL[this.env]}?scope=${effectiveScope}&state=${csrfToken}&redirect_uri=${redirectUri}&origin=${originURISafe}&${responseModeParam}&${appIdURIParam}${writeOnceParams}&display=${display}`;
    if (redirectUri === 'postMessage') {
      this.activePopupWindow = window.open(fullOauthUrl, '', windowOptions);
      this._clearPopupCheckInterval();
      this.popupCheckInterval = setInterval(() => {
        var _this$activePopupWind;
        if ((_this$activePopupWind = this.activePopupWindow) !== null && _this$activePopupWind !== void 0 && _this$activePopupWind.closed) {
          this._surfaceError('The login popup was closed prematurely.');
          if (this.popupCheckInterval) {
            clearInterval(this.popupCheckInterval);
          }
        }
      }, 500);
    } else {
      window.location.href = fullOauthUrl;
    }
  }
  renderButton(_ref3) {
    var _buttonOptions$size, _buttonOptions$custom;
    let {
      element,
      scope = 'read',
      buttonOptions
    } = _ref3;
    if (!element) {
      this.logger.error('Target element for Audius OAuth button is empty.');
    }
    const style = document.createElement('style');
    style.textContent = CSS;
    document.head.appendChild(style);
    const button = document.createElement('button');
    button.id = 'audius-login-button';
    button.classList.add('audiusLoginButton');
    if ((buttonOptions === null || buttonOptions === void 0 ? void 0 : buttonOptions.corners) === 'pill') {
      button.classList.add('pill');
    }
    if ((buttonOptions === null || buttonOptions === void 0 ? void 0 : buttonOptions.size) === 'small') {
      button.classList.add('small');
    }
    if ((buttonOptions === null || buttonOptions === void 0 ? void 0 : buttonOptions.size) === 'large') {
      button.classList.add('large');
    }
    if (buttonOptions !== null && buttonOptions !== void 0 && buttonOptions.fullWidth) {
      button.classList.add('fullWidth');
    }
    if (buttonOptions !== null && buttonOptions !== void 0 && buttonOptions.disableHoverGrow) {
      button.classList.add('disableHoverGrow');
    }
    button.innerHTML = `${generateAudiusLogoSvg((_buttonOptions$size = buttonOptions === null || buttonOptions === void 0 ? void 0 : buttonOptions.size) !== null && _buttonOptions$size !== void 0 ? _buttonOptions$size : 'medium')} ${(_buttonOptions$custom = buttonOptions === null || buttonOptions === void 0 ? void 0 : buttonOptions.customText) !== null && _buttonOptions$custom !== void 0 ? _buttonOptions$custom : 'Continue With Audius'}`;
    button.onclick = () => {
      this.login({
        scope
      });
    };
    element.replaceWith(button);
  }
  /**
   * Verify if the given jwt ID token was signed by the subject (user) in the payload
   * @deprecated see `UsersApi.verifyIDToken`
   * @param token the token to verify
   * @returns
   */
  async verifyToken(token) {
    return await this.config.usersApi.verifyIDToken({
      token
    });
  }
  getCsrfToken() {
    return window.localStorage.getItem(CSRF_TOKEN_KEY);
  }
  /* ------- INTERNAL FUNCTIONS ------- */
  _surfaceError(errorMessage) {
    if (this.loginErrorCallback) {
      this.loginErrorCallback(errorMessage);
    } else {
      this.logger.error(errorMessage);
    }
  }
  _clearPopupCheckInterval() {
    if (this.popupCheckInterval) {
      clearInterval(this.popupCheckInterval);
    }
  }
  async _receiveMessage(event) {
    const oauthOrigin = new URL(OAUTH_URL[this.env]).origin;
    if (event.origin !== oauthOrigin || event.source !== this.activePopupWindow || !event.data.state || !event.data.token) {
      return;
    }
    this._clearPopupCheckInterval();
    if (this.activePopupWindow) {
      if (!this.activePopupWindow.closed) {
        this.activePopupWindow.close();
      }
      this.activePopupWindow = null;
    }
    if (this.getCsrfToken() !== event.data.state) {
      this._surfaceError('State mismatch.');
    }
    // Verify token and decode
    const decodedJwt = await this.verifyToken(event.data.token);
    if (decodedJwt !== null && decodedJwt !== void 0 && decodedJwt.data) {
      if (this.loginSuccessCallback) {
        this.loginSuccessCallback(decodedJwt.data, event.data.token);
      }
    } else {
      this._surfaceError('The token was invalid.');
    }
  }
}

/**
 * SDK configuration schema that requires API keypairs
 */
const DevAppSchema = z.object({
  /**
   * Your app name
   */
  appName: z.optional(z.string()),
  /**
   * Services injection
   */
  services: z.optional(z.custom()),
  /**
   * API key, required for writes
   */
  apiKey: z.string().min(1),
  /**
   * API secret, required for writes
   */
  apiSecret: z.optional(z.string().min(1)),
  /**
   * Target environment
   * @internal
   */
  environment: z.enum(['development', 'staging', 'production']).optional()
});
const CustomAppSchema = z.object({
  /**
   * Your app name
   */
  appName: z.string().min(1),
  /**
   * Services injection
   */
  services: z.optional(z.custom()),
  /**
   * API key, required for writes
   */
  apiKey: z.optional(z.string().min(1)),
  /**
   * API secret, required for writes
   */
  apiSecret: z.optional(z.string().min(1)),
  /**
   * Target environment
   * @internal
   */
  environment: z.enum(['development', 'staging', 'production']).optional()
});
const SdkConfigSchema = z.union([DevAppSchema, CustomAppSchema]);

/**
 * The Audius SDK
 */
const sdk = config => {
  SdkConfigSchema.parse(config);
  const {
    appName,
    apiKey
  } = config;
  // Initialize services
  const services = initializeServices(config);
  // Initialize APIs
  const apis = initializeApis({
    config,
    apiKey,
    appName,
    services
  });
  // Initialize OAuth
  const oauth = typeof window !== 'undefined' ? new OAuth({
    appName,
    apiKey,
    usersApi: apis.users,
    logger: services.logger
  }) : undefined;
  return {
    oauth,
    ...apis
  };
};
const initializeServices = config => {
  var _config$services$logg, _config$services, _config$services$audi, _config$services2, _config$apiKey, _config$services$ethP, _config$services3, _config$services$ethW, _config$services4, _config$services$stor, _config$services5, _config$services$enti, _config$services6, _config$services$stor2, _config$services7, _config$services$anti, _config$services8, _config$services$anti2, _config$services9, _config$services0, _config$services1, _config$services$emai, _config$services10, _config$services$sola, _config$services11, _config$services$sola2, _config$services12, _config$services$clai, _config$services13, _config$services$rewa, _config$services14, _config$services$paym, _config$services15, _config$services$audi2, _config$services16, _config$services$clai2, _config$services17, _config$services$dele, _config$services18, _config$services$stak, _config$services19, _config$services$trus, _config$services20, _config$services$audi3, _config$services21, _config$services$regi, _config$services22, _config$services$gove, _config$services23, _config$services$serv, _config$services24, _config$services$serv2, _config$services25, _config$services$ethR, _config$services26;
  const servicesConfig = config.environment === 'development' ? developmentConfig : config.environment === 'staging' ? stagingConfig : productionConfig;
  const defaultLogger = new Logger({
    logLevel: config.environment !== 'production' ? 'debug' : undefined
  });
  const logger = (_config$services$logg = (_config$services = config.services) === null || _config$services === void 0 ? void 0 : _config$services.logger) !== null && _config$services$logg !== void 0 ? _config$services$logg : defaultLogger;
  const isBrowser = typeof window !== 'undefined' && typeof window.document !== 'undefined';
  if (config.apiSecret && isBrowser) {
    logger.warn("apiSecret should only be provided server side so that it isn't exposed");
  }
  const audiusWalletClient = (_config$services$audi = (_config$services2 = config.services) === null || _config$services2 === void 0 ? void 0 : _config$services2.audiusWalletClient) !== null && _config$services$audi !== void 0 ? _config$services$audi : createAppWalletClient({
    // Allow undefined apiKey for now, use dummy wallet
    apiKey: (_config$apiKey = config.apiKey) !== null && _config$apiKey !== void 0 ? _config$apiKey : '0x0000000000000000000000000000000000000000',
    apiSecret: config.apiSecret
  });
  const ethPublicClient = (_config$services$ethP = (_config$services3 = config.services) === null || _config$services3 === void 0 ? void 0 : _config$services3.ethPublicClient) !== null && _config$services$ethP !== void 0 ? _config$services$ethP : createPublicClient({
    chain: mainnet,
    transport: http(servicesConfig.ethereum.rpcEndpoint)
  });
  const ethWalletClient = (_config$services$ethW = (_config$services4 = config.services) === null || _config$services4 === void 0 ? void 0 : _config$services4.ethWalletClient) !== null && _config$services$ethW !== void 0 ? _config$services$ethW : createWalletClient({
    chain: mainnet,
    transport: http(servicesConfig.ethereum.rpcEndpoint)
  });
  const storageNodeSelector = (_config$services$stor = (_config$services5 = config.services) === null || _config$services5 === void 0 ? void 0 : _config$services5.storageNodeSelector) !== null && _config$services$stor !== void 0 ? _config$services$stor : new StorageNodeSelector({
    ...getDefaultStorageNodeSelectorConfig(servicesConfig),
    logger
  });
  const entityManager = (_config$services$enti = (_config$services6 = config.services) === null || _config$services6 === void 0 ? void 0 : _config$services6.entityManager) !== null && _config$services$enti !== void 0 ? _config$services$enti : new EntityManagerClient({
    ...getDefaultEntityManagerConfig(servicesConfig),
    audiusWalletClient,
    logger
  });
  const storage = (_config$services$stor2 = (_config$services7 = config.services) === null || _config$services7 === void 0 ? void 0 : _config$services7.storage) !== null && _config$services$stor2 !== void 0 ? _config$services$stor2 : new Storage({
    ...getDefaultStorageServiceConfig(),
    storageNodeSelector,
    logger
  });
  const antiAbuseOracleSelector = (_config$services$anti = (_config$services8 = config.services) === null || _config$services8 === void 0 ? void 0 : _config$services8.antiAbuseOracleSelector) !== null && _config$services$anti !== void 0 ? _config$services$anti : new AntiAbuseOracleSelector({
    ...getDefaultAntiAbuseOracleSelectorConfig(servicesConfig),
    logger
  });
  const antiAbuseOracle = (_config$services$anti2 = (_config$services9 = config.services) === null || _config$services9 === void 0 ? void 0 : _config$services9.antiAbuseOracle) !== null && _config$services$anti2 !== void 0 ? _config$services$anti2 : new AntiAbuseOracle({
    antiAbuseOracleSelector
  });
  const middleware = [addRequestSignatureMiddleware({
    services: {
      audiusWalletClient,
      logger
    },
    apiKey: config.apiKey,
    apiSecret: config.apiSecret
  })];
  /* Solana Programs */
  const solanaRelay = (_config$services0 = config.services) !== null && _config$services0 !== void 0 && _config$services0.solanaRelay ? config.services.solanaRelay.withMiddleware(addRequestSignatureMiddleware({
    services: {
      audiusWalletClient,
      logger
    },
    apiKey: config.apiKey,
    apiSecret: config.apiSecret
  })) : new SolanaRelay(new Configuration$1({
    middleware
  }));
  const archiverService = (_config$services1 = config.services) !== null && _config$services1 !== void 0 && _config$services1.archiverService ? config.services.archiverService.withMiddleware(addRequestSignatureMiddleware({
    services: {
      audiusWalletClient,
      logger
    },
    apiKey: config.apiKey,
    apiSecret: config.apiSecret
  })) : undefined;
  const emailEncryptionService = (_config$services$emai = (_config$services10 = config.services) === null || _config$services10 === void 0 ? void 0 : _config$services10.emailEncryptionService) !== null && _config$services$emai !== void 0 ? _config$services$emai : new EmailEncryptionService(new Configuration$1({
    fetchApi: fetch$1,
    basePath: '',
    middleware
  }), audiusWalletClient);
  const solanaWalletAdapter = (_config$services$sola = (_config$services11 = config.services) === null || _config$services11 === void 0 ? void 0 : _config$services11.solanaWalletAdapter) !== null && _config$services$sola !== void 0 ? _config$services$sola : new SolanaRelayWalletAdapter({
    solanaRelay
  });
  const solanaClient = (_config$services$sola2 = (_config$services12 = config.services) === null || _config$services12 === void 0 ? void 0 : _config$services12.solanaClient) !== null && _config$services$sola2 !== void 0 ? _config$services$sola2 : new SolanaClient({
    ...getDefaultSolanaClientConfig(servicesConfig),
    solanaWalletAdapter,
    logger
  });
  const claimableTokensClient = (_config$services$clai = (_config$services13 = config.services) === null || _config$services13 === void 0 ? void 0 : _config$services13.claimableTokensClient) !== null && _config$services$clai !== void 0 ? _config$services$clai : new ClaimableTokensClient({
    ...getDefaultClaimableTokensConfig(servicesConfig),
    solanaClient,
    audiusWalletClient,
    logger
  });
  const rewardManagerClient = (_config$services$rewa = (_config$services14 = config.services) === null || _config$services14 === void 0 ? void 0 : _config$services14.rewardManagerClient) !== null && _config$services$rewa !== void 0 ? _config$services$rewa : new RewardManagerClient({
    ...getDefaultRewardManagerClentConfig(servicesConfig),
    solanaClient,
    logger
  });
  const paymentRouterClient = (_config$services$paym = (_config$services15 = config.services) === null || _config$services15 === void 0 ? void 0 : _config$services15.paymentRouterClient) !== null && _config$services$paym !== void 0 ? _config$services$paym : new PaymentRouterClient({
    ...getDefaultPaymentRouterClientConfig(servicesConfig),
    solanaClient
  });
  /* Ethereum Contracts */
  const audiusTokenClient = (_config$services$audi2 = (_config$services16 = config.services) === null || _config$services16 === void 0 ? void 0 : _config$services16.audiusTokenClient) !== null && _config$services$audi2 !== void 0 ? _config$services$audi2 : new AudiusTokenClient({
    audiusWalletClient,
    ethPublicClient,
    ethWalletClient,
    ...getDefaultAudiusTokenConfig(servicesConfig)
  });
  const claimsManagerClient = (_config$services$clai2 = (_config$services17 = config.services) === null || _config$services17 === void 0 ? void 0 : _config$services17.claimsManagerClient) !== null && _config$services$clai2 !== void 0 ? _config$services$clai2 : new ClaimsManagerClient({
    ...getDefaultClaimsManagerConfig(servicesConfig)
  });
  const delegateManagerClient = (_config$services$dele = (_config$services18 = config.services) === null || _config$services18 === void 0 ? void 0 : _config$services18.delegateManagerClient) !== null && _config$services$dele !== void 0 ? _config$services$dele : new DelegateManagerClient({
    audiusWalletClient,
    ethPublicClient,
    ethWalletClient,
    ...getDefaultDelegateManagerConfig(servicesConfig)
  });
  const stakingClient = (_config$services$stak = (_config$services19 = config.services) === null || _config$services19 === void 0 ? void 0 : _config$services19.stakingClient) !== null && _config$services$stak !== void 0 ? _config$services$stak : new StakingClient({
    audiusWalletClient,
    ethPublicClient,
    ethWalletClient,
    ...getDefaultStakingConfig(servicesConfig)
  });
  const trustedNotifierManagerClient = (_config$services$trus = (_config$services20 = config.services) === null || _config$services20 === void 0 ? void 0 : _config$services20.trustedNotifierManagerClient) !== null && _config$services$trus !== void 0 ? _config$services$trus : new TrustedNotifierManagerClient({
    ...getDefaultTrustedNotifierManagerConfig(servicesConfig)
  });
  const audiusWormholeClient = (_config$services$audi3 = (_config$services21 = config.services) === null || _config$services21 === void 0 ? void 0 : _config$services21.audiusWormholeClient) !== null && _config$services$audi3 !== void 0 ? _config$services$audi3 : new AudiusWormholeClient({
    audiusWalletClient,
    ethPublicClient,
    ethWalletClient,
    ...getDefaultWormholeConfig(servicesConfig)
  });
  const registryClient = (_config$services$regi = (_config$services22 = config.services) === null || _config$services22 === void 0 ? void 0 : _config$services22.registryClient) !== null && _config$services$regi !== void 0 ? _config$services$regi : new RegistryClient({
    ...getDefaultRegistryConfig(servicesConfig)
  });
  const governanceClient = (_config$services$gove = (_config$services23 = config.services) === null || _config$services23 === void 0 ? void 0 : _config$services23.governanceClient) !== null && _config$services$gove !== void 0 ? _config$services$gove : new GovernanceClient({
    ...getDefaultGovernanceConfig(servicesConfig)
  });
  const serviceTypeManagerClient = (_config$services$serv = (_config$services24 = config.services) === null || _config$services24 === void 0 ? void 0 : _config$services24.serviceTypeManagerClient) !== null && _config$services$serv !== void 0 ? _config$services$serv : new ServiceTypeManagerClient({
    ...getDefaultServiceTypeManagerConfig(servicesConfig)
  });
  const serviceProviderFactoryClient = (_config$services$serv2 = (_config$services25 = config.services) === null || _config$services25 === void 0 ? void 0 : _config$services25.serviceProviderFactoryClient) !== null && _config$services$serv2 !== void 0 ? _config$services$serv2 : new ServiceProviderFactoryClient({
    ...getDefaultServiceProviderFactoryConfig(servicesConfig)
  });
  const ethRewardsManagerClient = (_config$services$ethR = (_config$services26 = config.services) === null || _config$services26 === void 0 ? void 0 : _config$services26.ethRewardsManagerClient) !== null && _config$services$ethR !== void 0 ? _config$services$ethR : new EthRewardsManagerClient({
    ...getDefaultEthRewardsManagerConfig(servicesConfig)
  });
  const services = {
    storageNodeSelector,
    antiAbuseOracleSelector,
    entityManager,
    storage,
    audiusWalletClient,
    ethPublicClient,
    ethWalletClient,
    claimableTokensClient,
    rewardManagerClient,
    paymentRouterClient,
    solanaClient,
    solanaWalletAdapter,
    solanaRelay,
    antiAbuseOracle,
    audiusTokenClient,
    claimsManagerClient,
    delegateManagerClient,
    stakingClient,
    trustedNotifierManagerClient,
    audiusWormholeClient,
    registryClient,
    governanceClient,
    serviceTypeManagerClient,
    serviceProviderFactoryClient,
    ethRewardsManagerClient,
    emailEncryptionService,
    archiverService,
    logger
  };
  return services;
};
const initializeApis = _ref => {
  let {
    config,
    apiKey,
    appName,
    services
  } = _ref;
  const apiEndpoint = config.environment === 'development' ? developmentConfig.network.apiEndpoint : config.environment === 'staging' ? stagingConfig.network.apiEndpoint : productionConfig.network.apiEndpoint;
  const basePath = `${apiEndpoint}/v1`;
  const middleware = [addAppInfoMiddleware({
    apiKey,
    appName,
    services,
    basePath
  }), addRequestSignatureMiddleware({
    services,
    apiKey,
    apiSecret: config.apiSecret
  })];
  const apiClientConfig = new Configuration$1({
    fetchApi: fetch$1,
    middleware,
    basePath
  });
  const tracks = new TracksApi(apiClientConfig, services.storage, services.entityManager, services.logger, services.claimableTokensClient, services.paymentRouterClient, services.solanaRelay, services.solanaClient);
  const users = new UsersApi(apiClientConfig, services.storage, services.entityManager, services.logger, services.claimableTokensClient, services.solanaClient, services.emailEncryptionService);
  const albums = new AlbumsApi(apiClientConfig, services.storage, services.entityManager, services.logger, services.claimableTokensClient, services.paymentRouterClient, services.solanaRelay, services.solanaClient);
  const playlists = new PlaylistsApi$1(apiClientConfig, services.storage, services.entityManager, services.logger);
  const comments = new CommentsApi$1(apiClientConfig, services.entityManager, services.logger);
  const challenges = new ChallengesApi$1(apiClientConfig);
  const coins = new CoinsApi$1(apiClientConfig);
  const tips = new TipsApi$1(apiClientConfig);
  const resolveApi = new ResolveApi(apiClientConfig);
  const rewards = new RewardsApi(apiClientConfig);
  const resolve = resolveApi.resolve.bind(resolveApi);
  const chats = new ChatsApi(new Configuration$1({
    basePath: apiEndpoint,
    fetchApi: fetch$1,
    middleware
  }), services.audiusWalletClient, services.logger);
  const grants = new GrantsApi(apiClientConfig, services.entityManager, users);
  const developerApps = new DeveloperAppsApi(apiClientConfig, services.entityManager);
  const dashboardWalletUsers = new DashboardWalletUsersApi(apiClientConfig, services.entityManager);
  const notifications = new NotificationsApi(apiClientConfig, services.entityManager);
  const generatedApiClientConfigFull = new Configuration({
    basePath: `${basePath}/full`,
    fetchApi: fetch$1,
    middleware
  });
  const events = new EventsApi(apiClientConfig, services.entityManager, services.logger);
  const explore = new ExploreApi$1(apiClientConfig);
  const full = {
    tracks: new TracksApi$1(generatedApiClientConfigFull),
    users: new UsersApi$1(generatedApiClientConfigFull),
    search: new SearchApi(generatedApiClientConfigFull),
    playlists: new PlaylistsApi(generatedApiClientConfigFull),
    reactions: new ReactionsApi(generatedApiClientConfigFull),
    tips: new TipsApi(generatedApiClientConfigFull),
    transactions: new TransactionsApi(generatedApiClientConfigFull),
    notifications: new NotificationsApi$1(generatedApiClientConfigFull),
    cidData: new CidDataApi(generatedApiClientConfigFull),
    comments: new CommentsApi(generatedApiClientConfigFull),
    explore: new ExploreApi(generatedApiClientConfigFull)
  };
  return {
    tracks,
    users,
    albums,
    playlists,
    tips,
    resolve,
    full,
    chats,
    grants,
    developerApps,
    dashboardWalletUsers,
    rewards,
    services,
    comments,
    notifications,
    events,
    explore,
    coins,
    challenges
  };
};

class MissingOtpUserAuthError extends Error {
  constructor(message) {
    super(message);
    Object.setPrototypeOf(this, MissingOtpUserAuthError.prototype);
  }
}
class AntiAbuseOracleAttestationError extends Error {
  constructor(code, message) {
    super(message);
    _defineProperty$1(this, "code", void 0);
    _defineProperty$1(this, "name", 'AntiAbuseOracleAttestationError');
    this.code = code;
    Object.setPrototypeOf(this, AntiAbuseOracleAttestationError.prototype);
  }
}

var errors = /*#__PURE__*/Object.freeze({
    __proto__: null,
    MissingOtpUserAuthError: MissingOtpUserAuthError,
    AntiAbuseOracleAttestationError: AntiAbuseOracleAttestationError
});

export { ALLOWED_AUDIO_MIME_TYPES_REGEX, ALLOWED_IMAGE_MIME_TYPES, AccessFromJSON$1 as AccessFromJSON, AccessFromJSONTyped$1 as AccessFromJSONTyped, AccessInfoResponseFromJSON, AccessInfoResponseFromJSONTyped, AccessInfoResponseToJSON, AccessToJSON$1 as AccessToJSON, ActivityFromJSON, ActivityFromJSONTyped, ActivityItemTypeEnum, ActivityToJSON, AddAssociatedWalletSchema, AddManagerSchema, AddTrackToPlaylistSchema, AlbumBacklinkFromJSON$1 as AlbumBacklinkFromJSON, AlbumBacklinkFromJSONTyped$1 as AlbumBacklinkFromJSONTyped, AlbumBacklinkToJSON$1 as AlbumBacklinkToJSON, AlbumsApi, AlbumsResponseFromJSON, AlbumsResponseFromJSONTyped, AlbumsResponseToJSON, AntiAbuseOracle, AntiAbuseOracleSelector, ApproveGrantSchema, ArchiverService, AudioFile, AudiusTokenClient, AudiusWormholeClient, AuthorizedAppFromJSON, AuthorizedAppFromJSONTyped, AuthorizedAppToJSON, AuthorizedAppsFromJSON, AuthorizedAppsFromJSONTyped, AuthorizedAppsToJSON, BASE_PATH$1 as BASE_PATH, BaseAPI$1 as BaseAPI, BestSellingItemContentTypeEnum$1 as BestSellingItemContentTypeEnum, BestSellingItemFromJSON$1 as BestSellingItemFromJSON, BestSellingItemFromJSONTyped$1 as BestSellingItemFromJSONTyped, BestSellingItemToJSON$1 as BestSellingItemToJSON, BestSellingResponseFromJSON, BestSellingResponseFromJSONTyped, BestSellingResponseToJSON, BlobApiResponse$1 as BlobApiResponse, BlobInfoFromJSON, BlobInfoFromJSONTyped, BlobInfoToJSON, COLLECTION_FORMATS$1 as COLLECTION_FORMATS, ChallengeId, ChallengeResponseFromJSON, ChallengeResponseFromJSONTyped, ChallengeResponseToJSON, ChallengesApi$1 as ChallengesApi, ChatBlastAudience, ChatBlastMessageRequestSchema, ChatBlockRequestSchema, ChatCreateRequestSchema, ChatDeleteRequestSchema, ChatGetAllRequestSchema, ChatGetBlockersRequestSchema, ChatGetMessagesRequestSchema, ChatGetPermissionRequestSchema, ChatGetRequestSchema, ChatGetUnreadCountRequestSchema, ChatInviteRequestSchema, ChatMessageRequestSchema, ChatPermission, ChatPermitRequestSchema, ChatReactRequestSchema, ChatReadRequestSchema, ChatUnfurlRequestSchema, ChatValidateCanCreateRequestSchema, ClaimRewardsRequestFromJSON, ClaimRewardsRequestFromJSONTyped, ClaimRewardsRequestToJSON, ClaimRewardsResponseDataInnerFromJSON, ClaimRewardsResponseDataInnerFromJSONTyped, ClaimRewardsResponseDataInnerToJSON, ClaimRewardsResponseFromJSON, ClaimRewardsResponseFromJSONTyped, ClaimRewardsResponseToJSON, ClaimableTokensClient, ClaimsManagerClient, CoinDynamicBondingCurveFromJSON, CoinDynamicBondingCurveFromJSONTyped, CoinDynamicBondingCurveToJSON, CoinExtensionsFromJSON, CoinExtensionsFromJSONTyped, CoinExtensionsToJSON, CoinFromJSON$1 as CoinFromJSON, CoinFromJSONTyped$1 as CoinFromJSONTyped, CoinInsightsFromJSON, CoinInsightsFromJSONTyped, CoinInsightsResponseFromJSON, CoinInsightsResponseFromJSONTyped, CoinInsightsResponseToJSON, CoinInsightsToJSON, CoinMemberFromJSON, CoinMemberFromJSONTyped, CoinMemberToJSON, CoinMembersResponseFromJSON, CoinMembersResponseFromJSONTyped, CoinMembersResponseToJSON, CoinResponseFromJSON$1 as CoinResponseFromJSON, CoinResponseFromJSONTyped$1 as CoinResponseFromJSONTyped, CoinResponseToJSON$1 as CoinResponseToJSON, CoinToJSON$1 as CoinToJSON, CoinsApi$1 as CoinsApi, CoinsResponseFromJSON$1 as CoinsResponseFromJSON, CoinsResponseFromJSONTyped$1 as CoinsResponseFromJSONTyped, CoinsResponseToJSON$1 as CoinsResponseToJSON, CollectibleGatedConditions, CollectiblesFromJSON, CollectiblesFromJSONTyped, CollectiblesResponseFromJSON, CollectiblesResponseFromJSONTyped, CollectiblesResponseToJSON, CollectiblesToJSON, CollectionActivityFromJSON, CollectionActivityFromJSONTyped, CollectionActivityItemTypeEnum, CollectionActivityToJSON, CommentFromJSON$1 as CommentFromJSON, CommentFromJSONTyped$1 as CommentFromJSONTyped, CommentMentionFromJSON$1 as CommentMentionFromJSON, CommentMentionFromJSONTyped$1 as CommentMentionFromJSONTyped, CommentMentionToJSON$1 as CommentMentionToJSON, CommentNotificationSettingFromJSON, CommentNotificationSettingFromJSONTyped, CommentNotificationSettingToJSON, CommentRepliesResponseFromJSON$1 as CommentRepliesResponseFromJSON, CommentRepliesResponseFromJSONTyped$1 as CommentRepliesResponseFromJSONTyped, CommentRepliesResponseToJSON$1 as CommentRepliesResponseToJSON, CommentResponseFromJSON$1 as CommentResponseFromJSON, CommentResponseFromJSONTyped$1 as CommentResponseFromJSONTyped, CommentResponseToJSON$1 as CommentResponseToJSON, CommentToJSON$1 as CommentToJSON, CommentsApi$1 as CommentsApi, Configuration$1 as Configuration, ConnectedWalletsFromJSON, ConnectedWalletsFromJSONTyped, ConnectedWalletsResponseFromJSON, ConnectedWalletsResponseFromJSONTyped, ConnectedWalletsResponseToJSON, ConnectedWalletsToJSON, CoverPhotoFromJSON$1 as CoverPhotoFromJSON, CoverPhotoFromJSONTyped$1 as CoverPhotoFromJSONTyped, CoverPhotoToJSON$1 as CoverPhotoToJSON, CreateAlbumMetadataSchema, CreateAlbumSchema, CreateAssociatedWalletsSchema, CreateCoinRequestFromJSON$1 as CreateCoinRequestFromJSON, CreateCoinRequestFromJSONTyped$1 as CreateCoinRequestFromJSONTyped, CreateCoinRequestToJSON$1 as CreateCoinRequestToJSON, CreateCoinResponseDataFromJSON$1 as CreateCoinResponseDataFromJSON, CreateCoinResponseDataFromJSONTyped$1 as CreateCoinResponseDataFromJSONTyped, CreateCoinResponseDataToJSON$1 as CreateCoinResponseDataToJSON, CreateCoinResponseFromJSON$1 as CreateCoinResponseFromJSON, CreateCoinResponseFromJSONTyped$1 as CreateCoinResponseFromJSONTyped, CreateCoinResponseToJSON$1 as CreateCoinResponseToJSON, CreateDashboardWalletUser, CreateDeveloperAppSchema, CreateGrantSchema, CreateMemoInstructionSchema, CreatePlaylistSchema, CreatePurchaseContentInstructionsSchema, CreateRouteInstructionSchema, CreateTransferInstructionSchema, CreateUserSchema, CrossPlatformFileSchema, DashboardWalletUserFromJSON, DashboardWalletUserFromJSONTyped, DashboardWalletUserToJSON, DashboardWalletUsersApi, DashboardWalletUsersResponseFromJSON, DashboardWalletUsersResponseFromJSONTyped, DashboardWalletUsersResponseToJSON, DecodedUserTokenFromJSON, DecodedUserTokenFromJSONTyped, DecodedUserTokenToJSON, DefaultConfig$1 as DefaultConfig, DelegateManagerClient, DeleteAlbumSchema, DeleteDashboardWalletUserSchema, DeleteDeveloperAppSchema, DeletePlaylistSchema, DeleteTrackSchema, DeveloperAppFromJSON, DeveloperAppFromJSONTyped, DeveloperAppResponseFromJSON, DeveloperAppResponseFromJSONTyped, DeveloperAppResponseToJSON, DeveloperAppToJSON, DeveloperAppsApi, DeveloperAppsFromJSON, DeveloperAppsFromJSONTyped, DeveloperAppsToJSON, EmailAccessFromJSON, EmailAccessFromJSONTyped, EmailAccessResponseFromJSON, EmailAccessResponseFromJSONTyped, EmailAccessResponseToJSON, EmailAccessToJSON, EmailEncryptionService, EmailSchema, Action as EntityManagerAction, EntityManagerClient, EntityType, errors as Errors, EthCollectibleGatedConditions, EthRewardsManagerClient, EventEntityTypeEnum, EventEventTypeEnum, EventFromJSON, EventFromJSONTyped, EventToJSON, EventsApi, EventsResponseFromJSON, EventsResponseFromJSONTyped, EventsResponseToJSON, ExploreApi$1 as ExploreApi, ExtendedAccessGateFromJSON, ExtendedAccessGateFromJSONTyped, ExtendedAccessGateToJSON, ExtendedPaymentSplitFromJSON, ExtendedPaymentSplitFromJSONTyped, ExtendedPaymentSplitToJSON, ExtendedPurchaseGateFromJSON, ExtendedPurchaseGateFromJSONTyped, ExtendedPurchaseGateToJSON, ExtendedTokenGateFromJSON$1 as ExtendedTokenGateFromJSON, ExtendedTokenGateFromJSONTyped$1 as ExtendedTokenGateFromJSONTyped, ExtendedTokenGateToJSON$1 as ExtendedTokenGateToJSON, ExtendedUsdcGateFromJSON, ExtendedUsdcGateFromJSONTyped, ExtendedUsdcGateToJSON, FavoriteAlbumSchema, FavoriteFromJSON$1 as FavoriteFromJSON, FavoriteFromJSONTyped$1 as FavoriteFromJSONTyped, FavoritePlaylistSchema, FavoriteToJSON$1 as FavoriteToJSON, FavoriteTrackSchema, FavoritesResponseFromJSON, FavoritesResponseFromJSONTyped, FavoritesResponseToJSON, FetchError$1 as FetchError, FollowGateFromJSON$1 as FollowGateFromJSON, FollowGateFromJSONTyped$1 as FollowGateFromJSONTyped, FollowGateToJSON$1 as FollowGateToJSON, FollowGatedConditions, FollowUserSchema, FollowersResponseFromJSON, FollowersResponseFromJSONTyped, FollowersResponseToJSON, FollowingResponseFromJSON$1 as FollowingResponseFromJSON, FollowingResponseFromJSONTyped$1 as FollowingResponseFromJSONTyped, FollowingResponseToJSON$1 as FollowingResponseToJSON, Genre, GetAIAttributedTracksByUserHandleFilterTracksEnum$1 as GetAIAttributedTracksByUserHandleFilterTracksEnum, GetAIAttributedTracksByUserHandleSortDirectionEnum$1 as GetAIAttributedTracksByUserHandleSortDirectionEnum, GetAIAttributedTracksByUserHandleSortEnum$1 as GetAIAttributedTracksByUserHandleSortEnum, GetAIAttributedTracksByUserHandleSortMethodEnum$1 as GetAIAttributedTracksByUserHandleSortMethodEnum, GetAlbumsByUserSortMethodEnum$1 as GetAlbumsByUserSortMethodEnum, GetAllEventsEventTypeEnum, GetAllEventsSortMethodEnum, GetAudioTransactionHistorySortDirectionEnum, GetAudioTransactionHistorySortMethodEnum, GetBestSellingTypeEnum, GetBulkEventsEventTypeEnum, GetChallengesFromJSON, GetChallengesFromJSONTyped, GetChallengesToJSON, GetCoinMembersSortDirectionEnum, GetCoinsSortDirectionEnum$1 as GetCoinsSortDirectionEnum, GetCoinsSortMethodEnum$1 as GetCoinsSortMethodEnum, GetEntityEventsEntityTypeEnum, GetMostSharedTracksTimeRangeEnum$1 as GetMostSharedTracksTimeRangeEnum, GetNotificationsTypesEnum, GetOrCreateProgramTokenAccountSchema, GetPlaylistsByUserSortMethodEnum$1 as GetPlaylistsByUserSortMethodEnum, GetPurchaseAlbumInstructionsSchema, GetPurchaseTrackInstructionsSchema, GetSupportedUsersFromJSON, GetSupportedUsersFromJSONTyped, GetSupportedUsersToJSON, GetSupportersFromJSON, GetSupportersFromJSONTyped, GetSupportersToJSON, GetTipsCurrentUserFollowsEnum$1 as GetTipsCurrentUserFollowsEnum, GetTipsResponseFromJSON$1 as GetTipsResponseFromJSON, GetTipsResponseFromJSONTyped$1 as GetTipsResponseFromJSONTyped, GetTipsResponseToJSON$1 as GetTipsResponseToJSON, GetTipsUniqueByEnum$1 as GetTipsUniqueByEnum, GetTrackCommentsSortMethodEnum$1 as GetTrackCommentsSortMethodEnum, GetTracksByUserFilterTracksEnum$1 as GetTracksByUserFilterTracksEnum, GetTracksByUserSortDirectionEnum$1 as GetTracksByUserSortDirectionEnum, GetTracksByUserSortEnum$1 as GetTracksByUserSortEnum, GetTracksByUserSortMethodEnum$1 as GetTracksByUserSortMethodEnum, GetTrendingPlaylistsTimeEnum$1 as GetTrendingPlaylistsTimeEnum, GetTrendingPlaylistsTypeEnum$1 as GetTrendingPlaylistsTypeEnum, GetTrendingTracksTimeEnum$1 as GetTrendingTracksTimeEnum, GetUserRecommendedTracksTimeRangeEnum$1 as GetUserRecommendedTracksTimeRangeEnum, GetUsersTrackHistorySortDirectionEnum$1 as GetUsersTrackHistorySortDirectionEnum, GetUsersTrackHistorySortMethodEnum$1 as GetUsersTrackHistorySortMethodEnum, GovernanceClient, GrantsApi, HashId, HedgehogWalletNotFoundError, HistoryResponseFromJSON, HistoryResponseFromJSONTyped, HistoryResponseToJSON, Id, ImageFile, IsWriteAccessGrantedSchema, JSONApiResponse$1 as JSONApiResponse, LaunchCoinSchema, ListenCountFromJSON, ListenCountFromJSONTyped, ListenCountToJSON, Logger, MAX_DESCRIPTION_LENGTH, MintSchema, MonthlyAggregatePlayFromJSON, MonthlyAggregatePlayFromJSONTyped, MonthlyAggregatePlayToJSON, Mood, MutualFollowersResponseFromJSON, MutualFollowersResponseFromJSONTyped, MutualFollowersResponseToJSON, NftCollectionChainEnum$1 as NftCollectionChainEnum, NftCollectionFromJSON$1 as NftCollectionFromJSON, NftCollectionFromJSONTyped$1 as NftCollectionFromJSONTyped, NftCollectionStandardEnum$1 as NftCollectionStandardEnum, NftCollectionToJSON$1 as NftCollectionToJSON, NftGateFromJSON$1 as NftGateFromJSON, NftGateFromJSONTyped$1 as NftGateFromJSONTyped, NftGateToJSON$1 as NftGateToJSON, OAUTH_SCOPE_OPTIONS, OAUTH_URL, OptionalHashId, OptionalId, ParseRequestError, PaymentRouterClient, PlaylistAddedTimestampFromJSON$1 as PlaylistAddedTimestampFromJSON, PlaylistAddedTimestampFromJSONTyped$1 as PlaylistAddedTimestampFromJSONTyped, PlaylistAddedTimestampToJSON$1 as PlaylistAddedTimestampToJSON, PlaylistArtworkFromJSON$1 as PlaylistArtworkFromJSON, PlaylistArtworkFromJSONTyped$1 as PlaylistArtworkFromJSONTyped, PlaylistArtworkToJSON$1 as PlaylistArtworkToJSON, PlaylistFromJSON, PlaylistFromJSONTyped, PlaylistResponseFromJSON, PlaylistResponseFromJSONTyped, PlaylistResponseToJSON, PlaylistSearchResultFromJSON, PlaylistSearchResultFromJSONTyped, PlaylistSearchResultToJSON, PlaylistToJSON, PlaylistTracksResponseFromJSON, PlaylistTracksResponseFromJSONTyped, PlaylistTracksResponseToJSON, PlaylistsApi$1 as PlaylistsApi, PlaylistsResponseFromJSON, PlaylistsResponseFromJSONTyped, PlaylistsResponseToJSON, ProfilePictureFromJSON$1 as ProfilePictureFromJSON, ProfilePictureFromJSONTyped$1 as ProfilePictureFromJSONTyped, ProfilePictureToJSON$1 as ProfilePictureToJSON, PublicKeySchema, PublishPlaylistSchema, PurchaseAlbumSchema, PurchaseTrackSchema, PurchasersResponseFromJSON, PurchasersResponseFromJSONTyped, PurchasersResponseToJSON, RecordTrackDownloadSchema, RegistryClient, RelatedArtistResponseFromJSON, RelatedArtistResponseFromJSONTyped, RelatedArtistResponseToJSON, RelaySchema, RemixParentFromJSON, RemixParentFromJSONTyped, RemixParentToJSON, RemixedTrackAggregateFromJSON, RemixedTrackAggregateFromJSONTyped, RemixedTrackAggregateToJSON, RemixersResponseFromJSON, RemixersResponseFromJSONTyped, RemixersResponseToJSON, RemoveAssociatedWalletSchema, RemoveManagerSchema, RemoveTrackFromPlaylistSchema, RendezvousHash, ReplyCommentFromJSON$1 as ReplyCommentFromJSON, ReplyCommentFromJSONTyped$1 as ReplyCommentFromJSONTyped, ReplyCommentToJSON$1 as ReplyCommentToJSON, RepostAlbumSchema, RepostPlaylistSchema, RepostTrackSchema, RepostsFromJSON, RepostsFromJSONTyped, RepostsToJSON, RequiredError$1 as RequiredError, ResolveApi, ResponseError$1 as ResponseError, RevokeGrantSchema, RewardManagerClient, RewardManagerError, RewardsApi, SaleJsonFromJSON, SaleJsonFromJSONTyped, SaleJsonToJSON, SalesAggregateFromJSON, SalesAggregateFromJSONTyped, SalesAggregateResponseFromJSON, SalesAggregateResponseFromJSONTyped, SalesAggregateResponseToJSON, SalesAggregateToJSON, SalesJsonContentFromJSON, SalesJsonContentFromJSONTyped, SalesJsonContentToJSON, SalesJsonResponseFromJSON, SalesJsonResponseFromJSONTyped, SalesJsonResponseToJSON, SearchPlaylistsSortMethodEnum, SearchTracksSortMethodEnum, SearchUsersSortMethodEnum, SendTipReactionRequestSchema, SendTipSchema, ServiceProviderFactoryClient, ServiceTypeManagerClient, SharePlaylistSchema, ShareTrackSchema, SolCollectibleGatedConditions, SolanaClient, SolanaRelay, SolanaRelayWalletAdapter, StakingClient, StemCategory, StemFromJSON, StemFromJSONTyped, StemToJSON, StemsResponseFromJSON$1 as StemsResponseFromJSON, StemsResponseFromJSONTyped$1 as StemsResponseFromJSONTyped, StemsResponseToJSON$1 as StemsResponseToJSON, Storage, StorageNodeSelector, StreamUrlResponseFromJSON, StreamUrlResponseFromJSONTyped, StreamUrlResponseToJSON, SubscribeToUserSchema, SubscribersResponseFromJSON, SubscribersResponseFromJSONTyped, SubscribersResponseToJSON, SupporterFromJSON, SupporterFromJSONTyped, SupporterToJSON, SupportingFromJSON, SupportingFromJSONTyped, SupportingToJSON, TagsResponseFromJSON, TagsResponseFromJSONTyped, TagsResponseToJSON, TextApiResponse$1 as TextApiResponse, TipFromJSON, TipFromJSONTyped, TipGateFromJSON$1 as TipGateFromJSON, TipGateFromJSONTyped$1 as TipGateFromJSONTyped, TipGateToJSON$1 as TipGateToJSON, TipGatedConditions, TipToJSON, TipsApi$1 as TipsApi, TokenGateFromJSON$1 as TokenGateFromJSON, TokenGateFromJSONTyped$1 as TokenGateFromJSONTyped, TokenGateToJSON$1 as TokenGateToJSON, TokenGatedConditions, TokenNameSchema, TopListenerFromJSON, TopListenerFromJSONTyped, TopListenerToJSON, TrackAccessInfoFromJSON, TrackAccessInfoFromJSONTyped, TrackAccessInfoToJSON, TrackActivityFromJSON, TrackActivityFromJSONTyped, TrackActivityItemTypeEnum, TrackActivityToJSON, TrackArtworkFromJSON, TrackArtworkFromJSONTyped, TrackArtworkToJSON, TrackCommentCountResponseFromJSON, TrackCommentCountResponseFromJSONTyped, TrackCommentCountResponseToJSON, TrackCommentNotificationResponseFromJSON, TrackCommentNotificationResponseFromJSONTyped, TrackCommentNotificationResponseToJSON, TrackCommentsResponseFromJSON, TrackCommentsResponseFromJSONTyped, TrackCommentsResponseToJSON, TrackElementFromJSON, TrackElementFromJSONTyped, TrackElementToJSON, TrackFromJSON, TrackFromJSONTyped, TrackInspectFromJSON, TrackInspectFromJSONTyped, TrackInspectListFromJSON, TrackInspectListFromJSONTyped, TrackInspectListToJSON, TrackInspectToJSON, TrackResponseFromJSON, TrackResponseFromJSONTyped, TrackResponseToJSON, TrackSearchFromJSON, TrackSearchFromJSONTyped, TrackSearchToJSON, TrackToJSON, TracksApi, TracksResponseFromJSON, TracksResponseFromJSONTyped, TracksResponseToJSON, TrendingPlaylistsResponseFromJSON, TrendingPlaylistsResponseFromJSONTyped, TrendingPlaylistsResponseToJSON, TrustedNotifierManagerClient, USDCPurchaseConditions, UnclaimedIdResponseFromJSON, UnclaimedIdResponseFromJSONTyped, UnclaimedIdResponseToJSON, UndisbursedChallengeFromJSON, UndisbursedChallengeFromJSONTyped, UndisbursedChallengeToJSON, UndisbursedChallengesFromJSON, UndisbursedChallengesFromJSONTyped, UndisbursedChallengesToJSON, UnfavoriteAlbumSchema, UnfavoritePlaylistSchema, UnfavoriteTrackSchema, UnfollowUserSchema, UnrepostAlbumSchema, UnrepostPlaylistSchema, UnrepostTrackSchema, UnsubscribeFromUserSchema, UpdateAlbumMetadataSchema, UpdateAlbumSchema, UpdateCoinRequestFromJSON$1 as UpdateCoinRequestFromJSON, UpdateCoinRequestFromJSONTyped$1 as UpdateCoinRequestFromJSONTyped, UpdateCoinRequestToJSON$1 as UpdateCoinRequestToJSON, UpdateCoinResponseFromJSON$1 as UpdateCoinResponseFromJSON, UpdateCoinResponseFromJSONTyped$1 as UpdateCoinResponseFromJSONTyped, UpdateCoinResponseToJSON$1 as UpdateCoinResponseToJSON, UpdateCollectiblesSchema, UpdateDeveloperAppSchema, UpdatePlaylistMetadataSchema, UpdatePlaylistSchema, UpdateProfileSchema, UpdateTrackSchema, UploadAlbumMetadataSchema, UploadAlbumSchema, UploadPlaylistMetadataSchema, UploadPlaylistSchema, UploadTrackFilesSchema, UploadTrackMetadataSchema, UploadTrackSchema, UserCoinAccountFromJSON, UserCoinAccountFromJSONTyped, UserCoinAccountToJSON, UserCoinFromJSON, UserCoinFromJSONTyped, UserCoinResponseFromJSON, UserCoinResponseFromJSONTyped, UserCoinResponseToJSON, UserCoinToJSON, UserCoinWithAccountsFromJSON, UserCoinWithAccountsFromJSONTyped, UserCoinWithAccountsToJSON, UserCoinsResponseFromJSON, UserCoinsResponseFromJSONTyped, UserCoinsResponseToJSON, UserCommentsResponseFromJSON, UserCommentsResponseFromJSONTyped, UserCommentsResponseToJSON, UserEventsSchema, UserFromJSON, UserFromJSONTyped, UserIdAddressFromJSON, UserIdAddressFromJSONTyped, UserIdAddressToJSON, UserIdsAddressesResponseFromJSON, UserIdsAddressesResponseFromJSONTyped, UserIdsAddressesResponseToJSON, UserResponseFromJSON, UserResponseFromJSONTyped, UserResponseToJSON, UserSearchFromJSON, UserSearchFromJSONTyped, UserSearchToJSON, UserToJSON, UserTrackListenCountsResponseFromJSON, UserTrackListenCountsResponseFromJSONTyped, UserTrackListenCountsResponseToJSON, UserTracksRemixedResponseFromJSON, UserTracksRemixedResponseFromJSONTyped, UserTracksRemixedResponseToJSON, UsersApi, UsersResponseFromJSON, UsersResponseFromJSONTyped, UsersResponseToJSON, VerifyTokenFromJSON, VerifyTokenFromJSONTyped, VerifyTokenToJSON, VoidApiResponse$1 as VoidApiResponse, WalletSchema, addAppInfoMiddleware, addRequestSignatureMiddleware, audiusWalletActions, canConsumeForm$1 as canConsumeForm, createAppWalletClient, createHedgehogWalletClient, decodeHashId, developmentConfig, encodeHashId, exists$2 as exists, index as full, getAlbumSchema, getAlbumTracksSchema, getAlbumsSchema, getDefaultAntiAbuseOracleSelectorConfig, getDefaultAudiusTokenConfig, getDefaultClaimableTokensConfig, getDefaultClaimsManagerConfig, getDefaultDelegateManagerConfig, getDefaultEntityManagerConfig, getDefaultEthRewardsManagerConfig, getDefaultGovernanceConfig, getDefaultPaymentRouterClientConfig, getDefaultRegistryConfig, getDefaultRewardManagerClentConfig, getDefaultServiceProviderFactoryConfig, getDefaultServiceTypeManagerConfig, getDefaultStakingConfig, getDefaultStorageNodeSelectorConfig, getDefaultStorageServiceConfig, getDefaultTrustedNotifierManagerConfig, getDefaultWormholeConfig, instanceOfAccess$1 as instanceOfAccess, instanceOfAccessInfoResponse, instanceOfActivity, instanceOfAlbumBacklink$1 as instanceOfAlbumBacklink, instanceOfAlbumsResponse, instanceOfAuthorizedApp, instanceOfAuthorizedApps, instanceOfBestSellingItem$1 as instanceOfBestSellingItem, instanceOfBestSellingResponse, instanceOfBlobInfo, instanceOfChallengeResponse, instanceOfClaimRewardsRequest, instanceOfClaimRewardsResponse, instanceOfClaimRewardsResponseDataInner, instanceOfCoin$1 as instanceOfCoin, instanceOfCoinDynamicBondingCurve, instanceOfCoinExtensions, instanceOfCoinInsights, instanceOfCoinInsightsResponse, instanceOfCoinMember, instanceOfCoinMembersResponse, instanceOfCoinResponse$1 as instanceOfCoinResponse, instanceOfCoinsResponse$1 as instanceOfCoinsResponse, instanceOfCollectibles, instanceOfCollectiblesResponse, instanceOfCollectionActivity, instanceOfComment$1 as instanceOfComment, instanceOfCommentMention$1 as instanceOfCommentMention, instanceOfCommentNotificationSetting, instanceOfCommentRepliesResponse$1 as instanceOfCommentRepliesResponse, instanceOfCommentResponse$1 as instanceOfCommentResponse, instanceOfConnectedWallets, instanceOfConnectedWalletsResponse, instanceOfCoverPhoto$1 as instanceOfCoverPhoto, instanceOfCreateCoinRequest$1 as instanceOfCreateCoinRequest, instanceOfCreateCoinResponse$1 as instanceOfCreateCoinResponse, instanceOfCreateCoinResponseData$1 as instanceOfCreateCoinResponseData, instanceOfDashboardWalletUser, instanceOfDashboardWalletUsersResponse, instanceOfDecodedUserToken, instanceOfDeveloperApp, instanceOfDeveloperAppResponse, instanceOfDeveloperApps, instanceOfEmailAccess, instanceOfEmailAccessResponse, instanceOfEvent, instanceOfEventsResponse, instanceOfExtendedPaymentSplit, instanceOfExtendedPurchaseGate, instanceOfExtendedTokenGate$1 as instanceOfExtendedTokenGate, instanceOfExtendedUsdcGate, instanceOfFavorite$1 as instanceOfFavorite, instanceOfFavoritesResponse, instanceOfFollowGate$1 as instanceOfFollowGate, instanceOfFollowersResponse, instanceOfFollowingResponse$1 as instanceOfFollowingResponse, instanceOfGetChallenges, instanceOfGetSupportedUsers, instanceOfGetSupporters, instanceOfGetTipsResponse$1 as instanceOfGetTipsResponse, instanceOfHistoryResponse, instanceOfListenCount, instanceOfMonthlyAggregatePlay, instanceOfMutualFollowersResponse, instanceOfNftCollection$1 as instanceOfNftCollection, instanceOfNftGate$1 as instanceOfNftGate, instanceOfPlaylist, instanceOfPlaylistAddedTimestamp$1 as instanceOfPlaylistAddedTimestamp, instanceOfPlaylistArtwork$1 as instanceOfPlaylistArtwork, instanceOfPlaylistResponse, instanceOfPlaylistSearchResult, instanceOfPlaylistTracksResponse, instanceOfPlaylistsResponse, instanceOfProfilePicture$1 as instanceOfProfilePicture, instanceOfPurchasersResponse, instanceOfRelatedArtistResponse, instanceOfRemixParent, instanceOfRemixedTrackAggregate, instanceOfRemixersResponse, instanceOfReplyComment$1 as instanceOfReplyComment, instanceOfReposts, instanceOfSaleJson, instanceOfSalesAggregate, instanceOfSalesAggregateResponse, instanceOfSalesJsonContent, instanceOfSalesJsonResponse, instanceOfStem, instanceOfStemsResponse$1 as instanceOfStemsResponse, instanceOfStreamUrlResponse, instanceOfSubscribersResponse, instanceOfSupporter, instanceOfSupporting, instanceOfTagsResponse, instanceOfTip, instanceOfTipGate$1 as instanceOfTipGate, instanceOfTokenGate$1 as instanceOfTokenGate, instanceOfTopListener, instanceOfTrack, instanceOfTrackAccessInfo, instanceOfTrackActivity, instanceOfTrackArtwork, instanceOfTrackCommentCountResponse, instanceOfTrackCommentNotificationResponse, instanceOfTrackCommentsResponse, instanceOfTrackElement, instanceOfTrackInspect, instanceOfTrackInspectList, instanceOfTrackResponse, instanceOfTrackSearch, instanceOfTracksResponse, instanceOfTrendingPlaylistsResponse, instanceOfUnclaimedIdResponse, instanceOfUndisbursedChallenge, instanceOfUndisbursedChallenges, instanceOfUpdateCoinRequest$1 as instanceOfUpdateCoinRequest, instanceOfUpdateCoinResponse$1 as instanceOfUpdateCoinResponse, instanceOfUser, instanceOfUserCoin, instanceOfUserCoinAccount, instanceOfUserCoinResponse, instanceOfUserCoinWithAccounts, instanceOfUserCoinsResponse, instanceOfUserCommentsResponse, instanceOfUserIdAddress, instanceOfUserIdsAddressesResponse, instanceOfUserResponse, instanceOfUserSearch, instanceOfUserTrackListenCountsResponse, instanceOfUserTracksRemixedResponse, instanceOfUsersResponse, instanceOfVerifyToken, isNativeFile, isNodeFile, mapValues$1 as mapValues, productionConfig, querystring$1 as querystring, sdk, stagingConfig };
//# sourceMappingURL=index.native.js.map
