'use strict';

var require$$0 = require('readable-stream');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

function _mergeNamespaces(n, m) {
    m.forEach(function (e) {
        e && typeof e !== 'string' && !Array.isArray(e) && Object.keys(e).forEach(function (k) {
            if (k !== 'default' && !(k in n)) {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    });
    return Object.freeze(n);
}

var require$$0__default = /*#__PURE__*/_interopDefaultLegacy(require$$0);

var browser$2 = {exports: {}};

var lib$2 = {};

Object.defineProperty(lib$2, "__esModule", {
  value: true
});
lib$2.ReadableWebToNodeStream = void 0;
const readable_stream_1 = require$$0__default["default"];
/**
 * Converts a Web-API stream into Node stream.Readable class
 * Node stream readable: https://nodejs.org/api/stream.html#stream_readable_streams
 * Web API readable-stream: https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream
 * Node readable stream: https://nodejs.org/api/stream.html#stream_readable_streams
 */
class ReadableWebToNodeStream extends readable_stream_1.Readable {
  /**
   *
   * @param stream Readable​Stream: https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream
   */
  constructor(stream) {
    super();
    this.bytesRead = 0;
    this.released = false;
    this.reader = stream.getReader();
  }
  /**
   * Implementation of readable._read(size).
   * When readable._read() is called, if data is available from the resource,
   * the implementation should begin pushing that data into the read queue
   * https://nodejs.org/api/stream.html#stream_readable_read_size_1
   */
  async _read() {
    // Should start pushing data into the queue
    // Read data from the underlying Web-API-readable-stream
    if (this.released) {
      this.push(null); // Signal EOF
      return;
    }
    this.pendingRead = this.reader.read();
    const data = await this.pendingRead;
    // clear the promise before pushing pushing new data to the queue and allow sequential calls to _read()
    delete this.pendingRead;
    if (data.done || this.released) {
      this.push(null); // Signal EOF
    } else {
      this.bytesRead += data.value.length;
      this.push(data.value); // Push new data to the queue
    }
  }
  /**
   * If there is no unresolved read call to Web-API Readable​Stream immediately returns;
   * otherwise will wait until the read is resolved.
   */
  async waitForReadToComplete() {
    if (this.pendingRead) {
      await this.pendingRead;
    }
  }
  /**
   * Close wrapper
   */
  async close() {
    await this.syncAndRelease();
  }
  async syncAndRelease() {
    this.released = true;
    await this.waitForReadToComplete();
    await this.reader.releaseLock();
  }
}
lib$2.ReadableWebToNodeStream = ReadableWebToNodeStream;

var lib$1 = {};

var ieee754 = {};

/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
ieee754.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? nBytes - 1 : 0;
  var d = isLE ? -1 : 1;
  var s = buffer[offset + i];
  i += d;
  e = s & (1 << -nBits) - 1;
  s >>= -nBits;
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}
  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}
  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : (s ? -1 : 1) * Infinity;
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};
ieee754.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i = isLE ? 0 : nBytes - 1;
  var d = isLE ? 1 : -1;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  value = Math.abs(value);
  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }
    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }
  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}
  e = e << mLen | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}
  buffer[offset + i - d] |= s * 128;
};

(function (exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.AnsiStringType = exports.StringType = exports.BufferType = exports.Uint8ArrayType = exports.IgnoreType = exports.Float80_LE = exports.Float80_BE = exports.Float64_LE = exports.Float64_BE = exports.Float32_LE = exports.Float32_BE = exports.Float16_LE = exports.Float16_BE = exports.INT64_BE = exports.UINT64_BE = exports.INT64_LE = exports.UINT64_LE = exports.INT32_LE = exports.INT32_BE = exports.INT24_BE = exports.INT24_LE = exports.INT16_LE = exports.INT16_BE = exports.INT8 = exports.UINT32_BE = exports.UINT32_LE = exports.UINT24_BE = exports.UINT24_LE = exports.UINT16_BE = exports.UINT16_LE = exports.UINT8 = void 0;
  const ieee754$1 = ieee754;
  // Primitive types
  function dv(array) {
    return new DataView(array.buffer, array.byteOffset);
  }
  /**
   * 8-bit unsigned integer
   */
  exports.UINT8 = {
    len: 1,
    get(array, offset) {
      return dv(array).getUint8(offset);
    },
    put(array, offset, value) {
      dv(array).setUint8(offset, value);
      return offset + 1;
    }
  };
  /**
   * 16-bit unsigned integer, Little Endian byte order
   */
  exports.UINT16_LE = {
    len: 2,
    get(array, offset) {
      return dv(array).getUint16(offset, true);
    },
    put(array, offset, value) {
      dv(array).setUint16(offset, value, true);
      return offset + 2;
    }
  };
  /**
   * 16-bit unsigned integer, Big Endian byte order
   */
  exports.UINT16_BE = {
    len: 2,
    get(array, offset) {
      return dv(array).getUint16(offset);
    },
    put(array, offset, value) {
      dv(array).setUint16(offset, value);
      return offset + 2;
    }
  };
  /**
   * 24-bit unsigned integer, Little Endian byte order
   */
  exports.UINT24_LE = {
    len: 3,
    get(array, offset) {
      const dataView = dv(array);
      return dataView.getUint8(offset) + (dataView.getUint16(offset + 1, true) << 8);
    },
    put(array, offset, value) {
      const dataView = dv(array);
      dataView.setUint8(offset, value & 0xff);
      dataView.setUint16(offset + 1, value >> 8, true);
      return offset + 3;
    }
  };
  /**
   * 24-bit unsigned integer, Big Endian byte order
   */
  exports.UINT24_BE = {
    len: 3,
    get(array, offset) {
      const dataView = dv(array);
      return (dataView.getUint16(offset) << 8) + dataView.getUint8(offset + 2);
    },
    put(array, offset, value) {
      const dataView = dv(array);
      dataView.setUint16(offset, value >> 8);
      dataView.setUint8(offset + 2, value & 0xff);
      return offset + 3;
    }
  };
  /**
   * 32-bit unsigned integer, Little Endian byte order
   */
  exports.UINT32_LE = {
    len: 4,
    get(array, offset) {
      return dv(array).getUint32(offset, true);
    },
    put(array, offset, value) {
      dv(array).setUint32(offset, value, true);
      return offset + 4;
    }
  };
  /**
   * 32-bit unsigned integer, Big Endian byte order
   */
  exports.UINT32_BE = {
    len: 4,
    get(array, offset) {
      return dv(array).getUint32(offset);
    },
    put(array, offset, value) {
      dv(array).setUint32(offset, value);
      return offset + 4;
    }
  };
  /**
   * 8-bit signed integer
   */
  exports.INT8 = {
    len: 1,
    get(array, offset) {
      return dv(array).getInt8(offset);
    },
    put(array, offset, value) {
      dv(array).setInt8(offset, value);
      return offset + 1;
    }
  };
  /**
   * 16-bit signed integer, Big Endian byte order
   */
  exports.INT16_BE = {
    len: 2,
    get(array, offset) {
      return dv(array).getInt16(offset);
    },
    put(array, offset, value) {
      dv(array).setInt16(offset, value);
      return offset + 2;
    }
  };
  /**
   * 16-bit signed integer, Little Endian byte order
   */
  exports.INT16_LE = {
    len: 2,
    get(array, offset) {
      return dv(array).getInt16(offset, true);
    },
    put(array, offset, value) {
      dv(array).setInt16(offset, value, true);
      return offset + 2;
    }
  };
  /**
   * 24-bit signed integer, Little Endian byte order
   */
  exports.INT24_LE = {
    len: 3,
    get(array, offset) {
      const unsigned = exports.UINT24_LE.get(array, offset);
      return unsigned > 0x7fffff ? unsigned - 0x1000000 : unsigned;
    },
    put(array, offset, value) {
      const dataView = dv(array);
      dataView.setUint8(offset, value & 0xff);
      dataView.setUint16(offset + 1, value >> 8, true);
      return offset + 3;
    }
  };
  /**
   * 24-bit signed integer, Big Endian byte order
   */
  exports.INT24_BE = {
    len: 3,
    get(array, offset) {
      const unsigned = exports.UINT24_BE.get(array, offset);
      return unsigned > 0x7fffff ? unsigned - 0x1000000 : unsigned;
    },
    put(array, offset, value) {
      const dataView = dv(array);
      dataView.setUint16(offset, value >> 8);
      dataView.setUint8(offset + 2, value & 0xff);
      return offset + 3;
    }
  };
  /**
   * 32-bit signed integer, Big Endian byte order
   */
  exports.INT32_BE = {
    len: 4,
    get(array, offset) {
      return dv(array).getInt32(offset);
    },
    put(array, offset, value) {
      dv(array).setInt32(offset, value);
      return offset + 4;
    }
  };
  /**
   * 32-bit signed integer, Big Endian byte order
   */
  exports.INT32_LE = {
    len: 4,
    get(array, offset) {
      return dv(array).getInt32(offset, true);
    },
    put(array, offset, value) {
      dv(array).setInt32(offset, value, true);
      return offset + 4;
    }
  };
  /**
   * 64-bit unsigned integer, Little Endian byte order
   */
  exports.UINT64_LE = {
    len: 8,
    get(array, offset) {
      return dv(array).getBigUint64(offset, true);
    },
    put(array, offset, value) {
      dv(array).setBigUint64(offset, value, true);
      return offset + 8;
    }
  };
  /**
   * 64-bit signed integer, Little Endian byte order
   */
  exports.INT64_LE = {
    len: 8,
    get(array, offset) {
      return dv(array).getBigInt64(offset, true);
    },
    put(array, offset, value) {
      dv(array).setBigInt64(offset, value, true);
      return offset + 8;
    }
  };
  /**
   * 64-bit unsigned integer, Big Endian byte order
   */
  exports.UINT64_BE = {
    len: 8,
    get(array, offset) {
      return dv(array).getBigUint64(offset);
    },
    put(array, offset, value) {
      dv(array).setBigUint64(offset, value);
      return offset + 8;
    }
  };
  /**
   * 64-bit signed integer, Big Endian byte order
   */
  exports.INT64_BE = {
    len: 8,
    get(array, offset) {
      return dv(array).getBigInt64(offset);
    },
    put(array, offset, value) {
      dv(array).setBigInt64(offset, value);
      return offset + 8;
    }
  };
  /**
   * IEEE 754 16-bit (half precision) float, big endian
   */
  exports.Float16_BE = {
    len: 2,
    get(dataView, offset) {
      return ieee754$1.read(dataView, offset, false, 10, this.len);
    },
    put(dataView, offset, value) {
      ieee754$1.write(dataView, value, offset, false, 10, this.len);
      return offset + this.len;
    }
  };
  /**
   * IEEE 754 16-bit (half precision) float, little endian
   */
  exports.Float16_LE = {
    len: 2,
    get(array, offset) {
      return ieee754$1.read(array, offset, true, 10, this.len);
    },
    put(array, offset, value) {
      ieee754$1.write(array, value, offset, true, 10, this.len);
      return offset + this.len;
    }
  };
  /**
   * IEEE 754 32-bit (single precision) float, big endian
   */
  exports.Float32_BE = {
    len: 4,
    get(array, offset) {
      return dv(array).getFloat32(offset);
    },
    put(array, offset, value) {
      dv(array).setFloat32(offset, value);
      return offset + 4;
    }
  };
  /**
   * IEEE 754 32-bit (single precision) float, little endian
   */
  exports.Float32_LE = {
    len: 4,
    get(array, offset) {
      return dv(array).getFloat32(offset, true);
    },
    put(array, offset, value) {
      dv(array).setFloat32(offset, value, true);
      return offset + 4;
    }
  };
  /**
   * IEEE 754 64-bit (double precision) float, big endian
   */
  exports.Float64_BE = {
    len: 8,
    get(array, offset) {
      return dv(array).getFloat64(offset);
    },
    put(array, offset, value) {
      dv(array).setFloat64(offset, value);
      return offset + 8;
    }
  };
  /**
   * IEEE 754 64-bit (double precision) float, little endian
   */
  exports.Float64_LE = {
    len: 8,
    get(array, offset) {
      return dv(array).getFloat64(offset, true);
    },
    put(array, offset, value) {
      dv(array).setFloat64(offset, value, true);
      return offset + 8;
    }
  };
  /**
   * IEEE 754 80-bit (extended precision) float, big endian
   */
  exports.Float80_BE = {
    len: 10,
    get(array, offset) {
      return ieee754$1.read(array, offset, false, 63, this.len);
    },
    put(array, offset, value) {
      ieee754$1.write(array, value, offset, false, 63, this.len);
      return offset + this.len;
    }
  };
  /**
   * IEEE 754 80-bit (extended precision) float, little endian
   */
  exports.Float80_LE = {
    len: 10,
    get(array, offset) {
      return ieee754$1.read(array, offset, true, 63, this.len);
    },
    put(array, offset, value) {
      ieee754$1.write(array, value, offset, true, 63, this.len);
      return offset + this.len;
    }
  };
  /**
   * Ignore a given number of bytes
   */
  class IgnoreType {
    /**
     * @param len number of bytes to ignore
     */
    constructor(len) {
      this.len = len;
    }
    // ToDo: don't read, but skip data
    get(array, off) {}
  }
  exports.IgnoreType = IgnoreType;
  class Uint8ArrayType {
    constructor(len) {
      this.len = len;
    }
    get(array, offset) {
      return array.subarray(offset, offset + this.len);
    }
  }
  exports.Uint8ArrayType = Uint8ArrayType;
  class BufferType {
    constructor(len) {
      this.len = len;
    }
    get(uint8Array, off) {
      return Buffer.from(uint8Array.subarray(off, off + this.len));
    }
  }
  exports.BufferType = BufferType;
  /**
   * Consume a fixed number of bytes from the stream and return a string with a specified encoding.
   */
  class StringType {
    constructor(len, encoding) {
      this.len = len;
      this.encoding = encoding;
    }
    get(uint8Array, offset) {
      return Buffer.from(uint8Array).toString(this.encoding, offset, offset + this.len);
    }
  }
  exports.StringType = StringType;
  /**
   * ANSI Latin 1 String
   * Using windows-1252 / ISO 8859-1 decoding
   */
  class AnsiStringType {
    constructor(len) {
      this.len = len;
    }
    static decode(buffer, offset, until) {
      let str = '';
      for (let i = offset; i < until; ++i) {
        str += AnsiStringType.codePointToString(AnsiStringType.singleByteDecoder(buffer[i]));
      }
      return str;
    }
    static inRange(a, min, max) {
      return min <= a && a <= max;
    }
    static codePointToString(cp) {
      if (cp <= 0xFFFF) {
        return String.fromCharCode(cp);
      } else {
        cp -= 0x10000;
        return String.fromCharCode((cp >> 10) + 0xD800, (cp & 0x3FF) + 0xDC00);
      }
    }
    static singleByteDecoder(bite) {
      if (AnsiStringType.inRange(bite, 0x00, 0x7F)) {
        return bite;
      }
      const codePoint = AnsiStringType.windows1252[bite - 0x80];
      if (codePoint === null) {
        throw Error('invaliding encoding');
      }
      return codePoint;
    }
    get(buffer) {
      let offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      return AnsiStringType.decode(buffer, offset, offset + this.len);
    }
  }
  exports.AnsiStringType = AnsiStringType;
  AnsiStringType.windows1252 = [8364, 129, 8218, 402, 8222, 8230, 8224, 8225, 710, 8240, 352, 8249, 338, 141, 381, 143, 144, 8216, 8217, 8220, 8221, 8226, 8211, 8212, 732, 8482, 353, 8250, 339, 157, 382, 376, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255];
})(lib$1);

var core$1 = {};

var ReadStreamTokenizer$1 = {};

var AbstractTokenizer$1 = {};

var lib = {};

var EndOfFileStream = {};

(function (exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.EndOfStreamError = exports.defaultMessages = void 0;
  exports.defaultMessages = 'End-Of-Stream';
  /**
   * Thrown on read operation of the end of file or stream has been reached
   */
  class EndOfStreamError extends Error {
    constructor() {
      super(exports.defaultMessages);
    }
  }
  exports.EndOfStreamError = EndOfStreamError;
})(EndOfFileStream);

var StreamReader = {};

var Deferred$1 = {};

Object.defineProperty(Deferred$1, "__esModule", {
  value: true
});
Deferred$1.Deferred = void 0;
class Deferred {
  constructor() {
    this.resolve = () => null;
    this.reject = () => null;
    this.promise = new Promise((resolve, reject) => {
      this.reject = reject;
      this.resolve = resolve;
    });
  }
}
Deferred$1.Deferred = Deferred;

(function (exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.StreamReader = exports.EndOfStreamError = void 0;
  const EndOfFileStream_1 = EndOfFileStream;
  const Deferred_1 = Deferred$1;
  var EndOfFileStream_2 = EndOfFileStream;
  Object.defineProperty(exports, "EndOfStreamError", {
    enumerable: true,
    get: function () {
      return EndOfFileStream_2.EndOfStreamError;
    }
  });
  const maxStreamReadSize = 1 * 1024 * 1024; // Maximum request length on read-stream operation
  class StreamReader {
    constructor(s) {
      this.s = s;
      /**
       * Deferred used for postponed read request (as not data is yet available to read)
       */
      this.deferred = null;
      this.endOfStream = false;
      /**
       * Store peeked data
       * @type {Array}
       */
      this.peekQueue = [];
      if (!s.read || !s.once) {
        throw new Error('Expected an instance of stream.Readable');
      }
      this.s.once('end', () => this.reject(new EndOfFileStream_1.EndOfStreamError()));
      this.s.once('error', err => this.reject(err));
      this.s.once('close', () => this.reject(new Error('Stream closed')));
    }
    /**
     * Read ahead (peek) from stream. Subsequent read or peeks will return the same data
     * @param uint8Array - Uint8Array (or Buffer) to store data read from stream in
     * @param offset - Offset target
     * @param length - Number of bytes to read
     * @returns Number of bytes peeked
     */
    async peek(uint8Array, offset, length) {
      const bytesRead = await this.read(uint8Array, offset, length);
      this.peekQueue.push(uint8Array.subarray(offset, offset + bytesRead)); // Put read data back to peek buffer
      return bytesRead;
    }
    /**
     * Read chunk from stream
     * @param buffer - Target Uint8Array (or Buffer) to store data read from stream in
     * @param offset - Offset target
     * @param length - Number of bytes to read
     * @returns Number of bytes read
     */
    async read(buffer, offset, length) {
      if (length === 0) {
        return 0;
      }
      if (this.peekQueue.length === 0 && this.endOfStream) {
        throw new EndOfFileStream_1.EndOfStreamError();
      }
      let remaining = length;
      let bytesRead = 0;
      // consume peeked data first
      while (this.peekQueue.length > 0 && remaining > 0) {
        const peekData = this.peekQueue.pop(); // Front of queue
        if (!peekData) throw new Error('peekData should be defined');
        const lenCopy = Math.min(peekData.length, remaining);
        buffer.set(peekData.subarray(0, lenCopy), offset + bytesRead);
        bytesRead += lenCopy;
        remaining -= lenCopy;
        if (lenCopy < peekData.length) {
          // remainder back to queue
          this.peekQueue.push(peekData.subarray(lenCopy));
        }
      }
      // continue reading from stream if required
      while (remaining > 0 && !this.endOfStream) {
        const reqLen = Math.min(remaining, maxStreamReadSize);
        const chunkLen = await this.readFromStream(buffer, offset + bytesRead, reqLen);
        bytesRead += chunkLen;
        if (chunkLen < reqLen) break;
        remaining -= chunkLen;
      }
      return bytesRead;
    }
    /**
     * Read chunk from stream
     * @param buffer Target Uint8Array (or Buffer) to store data read from stream in
     * @param offset Offset target
     * @param length Number of bytes to read
     * @returns Number of bytes read
     */
    async readFromStream(buffer, offset, length) {
      const readBuffer = this.s.read(length);
      if (readBuffer) {
        buffer.set(readBuffer, offset);
        return readBuffer.length;
      } else {
        const request = {
          buffer,
          offset,
          length,
          deferred: new Deferred_1.Deferred()
        };
        this.deferred = request.deferred;
        this.s.once('readable', () => {
          this.readDeferred(request);
        });
        return request.deferred.promise;
      }
    }
    /**
     * Process deferred read request
     * @param request Deferred read request
     */
    readDeferred(request) {
      const readBuffer = this.s.read(request.length);
      if (readBuffer) {
        request.buffer.set(readBuffer, request.offset);
        request.deferred.resolve(readBuffer.length);
        this.deferred = null;
      } else {
        this.s.once('readable', () => {
          this.readDeferred(request);
        });
      }
    }
    reject(err) {
      this.endOfStream = true;
      if (this.deferred) {
        this.deferred.reject(err);
        this.deferred = null;
      }
    }
  }
  exports.StreamReader = StreamReader;
})(StreamReader);

(function (exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.StreamReader = exports.EndOfStreamError = void 0;
  var EndOfFileStream_1 = EndOfFileStream;
  Object.defineProperty(exports, "EndOfStreamError", {
    enumerable: true,
    get: function () {
      return EndOfFileStream_1.EndOfStreamError;
    }
  });
  var StreamReader_1 = StreamReader;
  Object.defineProperty(exports, "StreamReader", {
    enumerable: true,
    get: function () {
      return StreamReader_1.StreamReader;
    }
  });
})(lib);

Object.defineProperty(AbstractTokenizer$1, "__esModule", {
  value: true
});
AbstractTokenizer$1.AbstractTokenizer = void 0;
const peek_readable_1$2 = lib;
/**
 * Core tokenizer
 */
class AbstractTokenizer {
  constructor(fileInfo) {
    /**
     * Tokenizer-stream position
     */
    this.position = 0;
    this.numBuffer = new Uint8Array(8);
    this.fileInfo = fileInfo ? fileInfo : {};
  }
  /**
   * Read a token from the tokenizer-stream
   * @param token - The token to read
   * @param position - If provided, the desired position in the tokenizer-stream
   * @returns Promise with token data
   */
  async readToken(token) {
    let position = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.position;
    const uint8Array = Buffer.alloc(token.len);
    const len = await this.readBuffer(uint8Array, {
      position
    });
    if (len < token.len) throw new peek_readable_1$2.EndOfStreamError();
    return token.get(uint8Array, 0);
  }
  /**
   * Peek a token from the tokenizer-stream.
   * @param token - Token to peek from the tokenizer-stream.
   * @param position - Offset where to begin reading within the file. If position is null, data will be read from the current file position.
   * @returns Promise with token data
   */
  async peekToken(token) {
    let position = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.position;
    const uint8Array = Buffer.alloc(token.len);
    const len = await this.peekBuffer(uint8Array, {
      position
    });
    if (len < token.len) throw new peek_readable_1$2.EndOfStreamError();
    return token.get(uint8Array, 0);
  }
  /**
   * Read a numeric token from the stream
   * @param token - Numeric token
   * @returns Promise with number
   */
  async readNumber(token) {
    const len = await this.readBuffer(this.numBuffer, {
      length: token.len
    });
    if (len < token.len) throw new peek_readable_1$2.EndOfStreamError();
    return token.get(this.numBuffer, 0);
  }
  /**
   * Read a numeric token from the stream
   * @param token - Numeric token
   * @returns Promise with number
   */
  async peekNumber(token) {
    const len = await this.peekBuffer(this.numBuffer, {
      length: token.len
    });
    if (len < token.len) throw new peek_readable_1$2.EndOfStreamError();
    return token.get(this.numBuffer, 0);
  }
  /**
   * Ignore number of bytes, advances the pointer in under tokenizer-stream.
   * @param length - Number of bytes to ignore
   * @return resolves the number of bytes ignored, equals length if this available, otherwise the number of bytes available
   */
  async ignore(length) {
    if (this.fileInfo.size !== undefined) {
      const bytesLeft = this.fileInfo.size - this.position;
      if (length > bytesLeft) {
        this.position += bytesLeft;
        return bytesLeft;
      }
    }
    this.position += length;
    return length;
  }
  async close() {
    // empty
  }
  normalizeOptions(uint8Array, options) {
    if (options && options.position !== undefined && options.position < this.position) {
      throw new Error('`options.position` must be equal or greater than `tokenizer.position`');
    }
    if (options) {
      return {
        mayBeLess: options.mayBeLess === true,
        offset: options.offset ? options.offset : 0,
        length: options.length ? options.length : uint8Array.length - (options.offset ? options.offset : 0),
        position: options.position ? options.position : this.position
      };
    }
    return {
      mayBeLess: false,
      offset: 0,
      length: uint8Array.length,
      position: this.position
    };
  }
}
AbstractTokenizer$1.AbstractTokenizer = AbstractTokenizer;

Object.defineProperty(ReadStreamTokenizer$1, "__esModule", {
  value: true
});
ReadStreamTokenizer$1.ReadStreamTokenizer = void 0;
const AbstractTokenizer_1$1 = AbstractTokenizer$1;
const peek_readable_1$1 = lib;
const maxBufferSize = 256000;
class ReadStreamTokenizer extends AbstractTokenizer_1$1.AbstractTokenizer {
  constructor(stream, fileInfo) {
    super(fileInfo);
    this.streamReader = new peek_readable_1$1.StreamReader(stream);
  }
  /**
   * Get file information, an HTTP-client may implement this doing a HEAD request
   * @return Promise with file information
   */
  async getFileInfo() {
    return this.fileInfo;
  }
  /**
   * Read buffer from tokenizer
   * @param uint8Array - Target Uint8Array to fill with data read from the tokenizer-stream
   * @param options - Read behaviour options
   * @returns Promise with number of bytes read
   */
  async readBuffer(uint8Array, options) {
    const normOptions = this.normalizeOptions(uint8Array, options);
    const skipBytes = normOptions.position - this.position;
    if (skipBytes > 0) {
      await this.ignore(skipBytes);
      return this.readBuffer(uint8Array, options);
    } else if (skipBytes < 0) {
      throw new Error('`options.position` must be equal or greater than `tokenizer.position`');
    }
    if (normOptions.length === 0) {
      return 0;
    }
    const bytesRead = await this.streamReader.read(uint8Array, normOptions.offset, normOptions.length);
    this.position += bytesRead;
    if ((!options || !options.mayBeLess) && bytesRead < normOptions.length) {
      throw new peek_readable_1$1.EndOfStreamError();
    }
    return bytesRead;
  }
  /**
   * Peek (read ahead) buffer from tokenizer
   * @param uint8Array - Uint8Array (or Buffer) to write data to
   * @param options - Read behaviour options
   * @returns Promise with number of bytes peeked
   */
  async peekBuffer(uint8Array, options) {
    const normOptions = this.normalizeOptions(uint8Array, options);
    let bytesRead = 0;
    if (normOptions.position) {
      const skipBytes = normOptions.position - this.position;
      if (skipBytes > 0) {
        const skipBuffer = new Uint8Array(normOptions.length + skipBytes);
        bytesRead = await this.peekBuffer(skipBuffer, {
          mayBeLess: normOptions.mayBeLess
        });
        uint8Array.set(skipBuffer.subarray(skipBytes), normOptions.offset);
        return bytesRead - skipBytes;
      } else if (skipBytes < 0) {
        throw new Error('Cannot peek from a negative offset in a stream');
      }
    }
    if (normOptions.length > 0) {
      try {
        bytesRead = await this.streamReader.peek(uint8Array, normOptions.offset, normOptions.length);
      } catch (err) {
        if (options && options.mayBeLess && err instanceof peek_readable_1$1.EndOfStreamError) {
          return 0;
        }
        throw err;
      }
      if (!normOptions.mayBeLess && bytesRead < normOptions.length) {
        throw new peek_readable_1$1.EndOfStreamError();
      }
    }
    return bytesRead;
  }
  async ignore(length) {
    // debug(`ignore ${this.position}...${this.position + length - 1}`);
    const bufSize = Math.min(maxBufferSize, length);
    const buf = new Uint8Array(bufSize);
    let totBytesRead = 0;
    while (totBytesRead < length) {
      const remaining = length - totBytesRead;
      const bytesRead = await this.readBuffer(buf, {
        length: Math.min(bufSize, remaining)
      });
      if (bytesRead < 0) {
        return bytesRead;
      }
      totBytesRead += bytesRead;
    }
    return totBytesRead;
  }
}
ReadStreamTokenizer$1.ReadStreamTokenizer = ReadStreamTokenizer;

var BufferTokenizer$1 = {};

Object.defineProperty(BufferTokenizer$1, "__esModule", {
  value: true
});
BufferTokenizer$1.BufferTokenizer = void 0;
const peek_readable_1 = lib;
const AbstractTokenizer_1 = AbstractTokenizer$1;
class BufferTokenizer extends AbstractTokenizer_1.AbstractTokenizer {
  /**
   * Construct BufferTokenizer
   * @param uint8Array - Uint8Array to tokenize
   * @param fileInfo - Pass additional file information to the tokenizer
   */
  constructor(uint8Array, fileInfo) {
    super(fileInfo);
    this.uint8Array = uint8Array;
    this.fileInfo.size = this.fileInfo.size ? this.fileInfo.size : uint8Array.length;
  }
  /**
   * Read buffer from tokenizer
   * @param uint8Array - Uint8Array to tokenize
   * @param options - Read behaviour options
   * @returns {Promise<number>}
   */
  async readBuffer(uint8Array, options) {
    if (options && options.position) {
      if (options.position < this.position) {
        throw new Error('`options.position` must be equal or greater than `tokenizer.position`');
      }
      this.position = options.position;
    }
    const bytesRead = await this.peekBuffer(uint8Array, options);
    this.position += bytesRead;
    return bytesRead;
  }
  /**
   * Peek (read ahead) buffer from tokenizer
   * @param uint8Array
   * @param options - Read behaviour options
   * @returns {Promise<number>}
   */
  async peekBuffer(uint8Array, options) {
    const normOptions = this.normalizeOptions(uint8Array, options);
    const bytes2read = Math.min(this.uint8Array.length - normOptions.position, normOptions.length);
    if (!normOptions.mayBeLess && bytes2read < normOptions.length) {
      throw new peek_readable_1.EndOfStreamError();
    } else {
      uint8Array.set(this.uint8Array.subarray(normOptions.position, normOptions.position + bytes2read), normOptions.offset);
      return bytes2read;
    }
  }
  async close() {
    // empty
  }
}
BufferTokenizer$1.BufferTokenizer = BufferTokenizer;

(function (exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.fromBuffer = exports.fromStream = exports.EndOfStreamError = void 0;
  const ReadStreamTokenizer_1 = ReadStreamTokenizer$1;
  const BufferTokenizer_1 = BufferTokenizer$1;
  var peek_readable_1 = lib;
  Object.defineProperty(exports, "EndOfStreamError", {
    enumerable: true,
    get: function () {
      return peek_readable_1.EndOfStreamError;
    }
  });
  /**
   * Construct ReadStreamTokenizer from given Stream.
   * Will set fileSize, if provided given Stream has set the .path property/
   * @param stream - Read from Node.js Stream.Readable
   * @param fileInfo - Pass the file information, like size and MIME-type of the corresponding stream.
   * @returns ReadStreamTokenizer
   */
  function fromStream(stream, fileInfo) {
    fileInfo = fileInfo ? fileInfo : {};
    return new ReadStreamTokenizer_1.ReadStreamTokenizer(stream, fileInfo);
  }
  exports.fromStream = fromStream;
  /**
   * Construct ReadStreamTokenizer from given Buffer.
   * @param uint8Array - Uint8Array to tokenize
   * @param fileInfo - Pass additional file information to the tokenizer
   * @returns BufferTokenizer
   */
  function fromBuffer(uint8Array, fileInfo) {
    return new BufferTokenizer_1.BufferTokenizer(uint8Array, fileInfo);
  }
  exports.fromBuffer = fromBuffer;
})(core$1);

var util = {};

util.stringToBytes = string => [...string].map(character => character.charCodeAt(0));

/**
Checks whether the TAR checksum is valid.

@param {Buffer} buffer - The TAR header `[offset ... offset + 512]`.
@param {number} offset - TAR header offset.
@returns {boolean} `true` if the TAR checksum is valid, otherwise `false`.
*/
util.tarHeaderChecksumMatches = function (buffer) {
  let offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  const readSum = parseInt(buffer.toString('utf8', 148, 154).replace(/\0.*$/, '').trim(), 8); // Read sum in header
  if (isNaN(readSum)) {
    return false;
  }
  let sum = 8 * 0x20; // Initialize signed bit sum

  for (let i = offset; i < offset + 148; i++) {
    sum += buffer[i];
  }
  for (let i = offset + 156; i < offset + 512; i++) {
    sum += buffer[i];
  }
  return readSum === sum;
};

/**
ID3 UINT32 sync-safe tokenizer token.
28 bits (representing up to 256MB) integer, the msb is 0 to avoid "false syncsignals".
*/
util.uint32SyncSafeToken = {
  get: (buffer, offset) => {
    return buffer[offset + 3] & 0x7F | buffer[offset + 2] << 7 | buffer[offset + 1] << 14 | buffer[offset] << 21;
  },
  len: 4
};

var supported$1 = {
  extensions: ['jpg', 'png', 'apng', 'gif', 'webp', 'flif', 'xcf', 'cr2', 'cr3', 'orf', 'arw', 'dng', 'nef', 'rw2', 'raf', 'tif', 'bmp', 'icns', 'jxr', 'psd', 'indd', 'zip', 'tar', 'rar', 'gz', 'bz2', '7z', 'dmg', 'mp4', 'mid', 'mkv', 'webm', 'mov', 'avi', 'mpg', 'mp2', 'mp3', 'm4a', 'oga', 'ogg', 'ogv', 'opus', 'flac', 'wav', 'spx', 'amr', 'pdf', 'epub', 'exe', 'swf', 'rtf', 'wasm', 'woff', 'woff2', 'eot', 'ttf', 'otf', 'ico', 'flv', 'ps', 'xz', 'sqlite', 'nes', 'crx', 'xpi', 'cab', 'deb', 'ar', 'rpm', 'Z', 'lz', 'cfb', 'mxf', 'mts', 'blend', 'bpg', 'docx', 'pptx', 'xlsx', '3gp', '3g2', 'jp2', 'jpm', 'jpx', 'mj2', 'aif', 'qcp', 'odt', 'ods', 'odp', 'xml', 'mobi', 'heic', 'cur', 'ktx', 'ape', 'wv', 'dcm', 'ics', 'glb', 'pcap', 'dsf', 'lnk', 'alias', 'voc', 'ac3', 'm4v', 'm4p', 'm4b', 'f4v', 'f4p', 'f4b', 'f4a', 'mie', 'asf', 'ogm', 'ogx', 'mpc', 'arrow', 'shp', 'aac', 'mp1', 'it', 's3m', 'xm', 'ai', 'skp', 'avif', 'eps', 'lzh', 'pgp', 'asar', 'stl', 'chm', '3mf', 'zst', 'jxl', 'vcf'],
  mimeTypes: ['image/jpeg', 'image/png', 'image/gif', 'image/webp', 'image/flif', 'image/x-xcf', 'image/x-canon-cr2', 'image/x-canon-cr3', 'image/tiff', 'image/bmp', 'image/vnd.ms-photo', 'image/vnd.adobe.photoshop', 'application/x-indesign', 'application/epub+zip', 'application/x-xpinstall', 'application/vnd.oasis.opendocument.text', 'application/vnd.oasis.opendocument.spreadsheet', 'application/vnd.oasis.opendocument.presentation', 'application/vnd.openxmlformats-officedocument.wordprocessingml.document', 'application/vnd.openxmlformats-officedocument.presentationml.presentation', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet', 'application/zip', 'application/x-tar', 'application/x-rar-compressed', 'application/gzip', 'application/x-bzip2', 'application/x-7z-compressed', 'application/x-apple-diskimage', 'application/x-apache-arrow', 'video/mp4', 'audio/midi', 'video/x-matroska', 'video/webm', 'video/quicktime', 'video/vnd.avi', 'audio/vnd.wave', 'audio/qcelp', 'audio/x-ms-asf', 'video/x-ms-asf', 'application/vnd.ms-asf', 'video/mpeg', 'video/3gpp', 'audio/mpeg', 'audio/mp4',
  // RFC 4337
  'audio/opus', 'video/ogg', 'audio/ogg', 'application/ogg', 'audio/x-flac', 'audio/ape', 'audio/wavpack', 'audio/amr', 'application/pdf', 'application/x-msdownload', 'application/x-shockwave-flash', 'application/rtf', 'application/wasm', 'font/woff', 'font/woff2', 'application/vnd.ms-fontobject', 'font/ttf', 'font/otf', 'image/x-icon', 'video/x-flv', 'application/postscript', 'application/eps', 'application/x-xz', 'application/x-sqlite3', 'application/x-nintendo-nes-rom', 'application/x-google-chrome-extension', 'application/vnd.ms-cab-compressed', 'application/x-deb', 'application/x-unix-archive', 'application/x-rpm', 'application/x-compress', 'application/x-lzip', 'application/x-cfb', 'application/x-mie', 'application/mxf', 'video/mp2t', 'application/x-blender', 'image/bpg', 'image/jp2', 'image/jpx', 'image/jpm', 'image/mj2', 'audio/aiff', 'application/xml', 'application/x-mobipocket-ebook', 'image/heif', 'image/heif-sequence', 'image/heic', 'image/heic-sequence', 'image/icns', 'image/ktx', 'application/dicom', 'audio/x-musepack', 'text/calendar', 'text/vcard', 'model/gltf-binary', 'application/vnd.tcpdump.pcap', 'audio/x-dsf',
  // Non-standard
  'application/x.ms.shortcut',
  // Invented by us
  'application/x.apple.alias',
  // Invented by us
  'audio/x-voc', 'audio/vnd.dolby.dd-raw', 'audio/x-m4a', 'image/apng', 'image/x-olympus-orf', 'image/x-sony-arw', 'image/x-adobe-dng', 'image/x-nikon-nef', 'image/x-panasonic-rw2', 'image/x-fujifilm-raf', 'video/x-m4v', 'video/3gpp2', 'application/x-esri-shape', 'audio/aac', 'audio/x-it', 'audio/x-s3m', 'audio/x-xm', 'video/MP1S', 'video/MP2P', 'application/vnd.sketchup.skp', 'image/avif', 'application/x-lzh-compressed', 'application/pgp-encrypted', 'application/x-asar', 'model/stl', 'application/vnd.ms-htmlhelp', 'model/3mf', 'image/jxl', 'application/zstd']
};

const Token = lib$1;
const strtok3 = core$1;
const {
  stringToBytes,
  tarHeaderChecksumMatches,
  uint32SyncSafeToken
} = util;
const supported = supported$1;
const minimumBytes = 4100; // A fair amount of file-types are detectable within this range

async function fromStream(stream) {
  const tokenizer = await strtok3.fromStream(stream);
  try {
    return await fromTokenizer(tokenizer);
  } finally {
    await tokenizer.close();
  }
}
async function fromBuffer(input) {
  if (!(input instanceof Uint8Array || input instanceof ArrayBuffer || Buffer.isBuffer(input))) {
    throw new TypeError(`Expected the \`input\` argument to be of type \`Uint8Array\` or \`Buffer\` or \`ArrayBuffer\`, got \`${typeof input}\``);
  }
  const buffer = input instanceof Buffer ? input : Buffer.from(input);
  if (!(buffer && buffer.length > 1)) {
    return;
  }
  const tokenizer = strtok3.fromBuffer(buffer);
  return fromTokenizer(tokenizer);
}
function _check(buffer, headers, options) {
  options = {
    offset: 0,
    ...options
  };
  for (const [index, header] of headers.entries()) {
    // If a bitmask is set
    if (options.mask) {
      // If header doesn't equal `buf` with bits masked off
      if (header !== (options.mask[index] & buffer[index + options.offset])) {
        return false;
      }
    } else if (header !== buffer[index + options.offset]) {
      return false;
    }
  }
  return true;
}
async function fromTokenizer(tokenizer) {
  try {
    return _fromTokenizer(tokenizer);
  } catch (error) {
    if (!(error instanceof strtok3.EndOfStreamError)) {
      throw error;
    }
  }
}
async function _fromTokenizer(tokenizer) {
  let buffer = Buffer.alloc(minimumBytes);
  const bytesRead = 12;
  const check = (header, options) => _check(buffer, header, options);
  const checkString = (header, options) => check(stringToBytes(header), options);

  // Keep reading until EOF if the file size is unknown.
  if (!tokenizer.fileInfo.size) {
    tokenizer.fileInfo.size = Number.MAX_SAFE_INTEGER;
  }
  await tokenizer.peekBuffer(buffer, {
    length: bytesRead,
    mayBeLess: true
  });

  // -- 2-byte signatures --

  if (check([0x42, 0x4D])) {
    return {
      ext: 'bmp',
      mime: 'image/bmp'
    };
  }
  if (check([0x0B, 0x77])) {
    return {
      ext: 'ac3',
      mime: 'audio/vnd.dolby.dd-raw'
    };
  }
  if (check([0x78, 0x01])) {
    return {
      ext: 'dmg',
      mime: 'application/x-apple-diskimage'
    };
  }
  if (check([0x4D, 0x5A])) {
    return {
      ext: 'exe',
      mime: 'application/x-msdownload'
    };
  }
  if (check([0x25, 0x21])) {
    await tokenizer.peekBuffer(buffer, {
      length: 24,
      mayBeLess: true
    });
    if (checkString('PS-Adobe-', {
      offset: 2
    }) && checkString(' EPSF-', {
      offset: 14
    })) {
      return {
        ext: 'eps',
        mime: 'application/eps'
      };
    }
    return {
      ext: 'ps',
      mime: 'application/postscript'
    };
  }
  if (check([0x1F, 0xA0]) || check([0x1F, 0x9D])) {
    return {
      ext: 'Z',
      mime: 'application/x-compress'
    };
  }

  // -- 3-byte signatures --

  if (check([0xFF, 0xD8, 0xFF])) {
    return {
      ext: 'jpg',
      mime: 'image/jpeg'
    };
  }
  if (check([0x49, 0x49, 0xBC])) {
    return {
      ext: 'jxr',
      mime: 'image/vnd.ms-photo'
    };
  }
  if (check([0x1F, 0x8B, 0x8])) {
    return {
      ext: 'gz',
      mime: 'application/gzip'
    };
  }
  if (check([0x42, 0x5A, 0x68])) {
    return {
      ext: 'bz2',
      mime: 'application/x-bzip2'
    };
  }
  if (checkString('ID3')) {
    await tokenizer.ignore(6); // Skip ID3 header until the header size
    const id3HeaderLen = await tokenizer.readToken(uint32SyncSafeToken);
    if (tokenizer.position + id3HeaderLen > tokenizer.fileInfo.size) {
      // Guess file type based on ID3 header for backward compatibility
      return {
        ext: 'mp3',
        mime: 'audio/mpeg'
      };
    }
    await tokenizer.ignore(id3HeaderLen);
    return fromTokenizer(tokenizer); // Skip ID3 header, recursion
  }

  // Musepack, SV7
  if (checkString('MP+')) {
    return {
      ext: 'mpc',
      mime: 'audio/x-musepack'
    };
  }
  if ((buffer[0] === 0x43 || buffer[0] === 0x46) && check([0x57, 0x53], {
    offset: 1
  })) {
    return {
      ext: 'swf',
      mime: 'application/x-shockwave-flash'
    };
  }

  // -- 4-byte signatures --

  if (check([0x47, 0x49, 0x46])) {
    return {
      ext: 'gif',
      mime: 'image/gif'
    };
  }
  if (checkString('FLIF')) {
    return {
      ext: 'flif',
      mime: 'image/flif'
    };
  }
  if (checkString('8BPS')) {
    return {
      ext: 'psd',
      mime: 'image/vnd.adobe.photoshop'
    };
  }
  if (checkString('WEBP', {
    offset: 8
  })) {
    return {
      ext: 'webp',
      mime: 'image/webp'
    };
  }

  // Musepack, SV8
  if (checkString('MPCK')) {
    return {
      ext: 'mpc',
      mime: 'audio/x-musepack'
    };
  }
  if (checkString('FORM')) {
    return {
      ext: 'aif',
      mime: 'audio/aiff'
    };
  }
  if (checkString('icns', {
    offset: 0
  })) {
    return {
      ext: 'icns',
      mime: 'image/icns'
    };
  }

  // Zip-based file formats
  // Need to be before the `zip` check
  if (check([0x50, 0x4B, 0x3, 0x4])) {
    // Local file header signature
    try {
      while (tokenizer.position + 30 < tokenizer.fileInfo.size) {
        await tokenizer.readBuffer(buffer, {
          length: 30
        });

        // https://en.wikipedia.org/wiki/Zip_(file_format)#File_headers
        const zipHeader = {
          compressedSize: buffer.readUInt32LE(18),
          uncompressedSize: buffer.readUInt32LE(22),
          filenameLength: buffer.readUInt16LE(26),
          extraFieldLength: buffer.readUInt16LE(28)
        };
        zipHeader.filename = await tokenizer.readToken(new Token.StringType(zipHeader.filenameLength, 'utf-8'));
        await tokenizer.ignore(zipHeader.extraFieldLength);

        // Assumes signed `.xpi` from addons.mozilla.org
        if (zipHeader.filename === 'META-INF/mozilla.rsa') {
          return {
            ext: 'xpi',
            mime: 'application/x-xpinstall'
          };
        }
        if (zipHeader.filename.endsWith('.rels') || zipHeader.filename.endsWith('.xml')) {
          const type = zipHeader.filename.split('/')[0];
          switch (type) {
            case '_rels':
              break;
            case 'word':
              return {
                ext: 'docx',
                mime: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document'
              };
            case 'ppt':
              return {
                ext: 'pptx',
                mime: 'application/vnd.openxmlformats-officedocument.presentationml.presentation'
              };
            case 'xl':
              return {
                ext: 'xlsx',
                mime: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
              };
            default:
              break;
          }
        }
        if (zipHeader.filename.startsWith('xl/')) {
          return {
            ext: 'xlsx',
            mime: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
          };
        }
        if (zipHeader.filename.startsWith('3D/') && zipHeader.filename.endsWith('.model')) {
          return {
            ext: '3mf',
            mime: 'model/3mf'
          };
        }

        // The docx, xlsx and pptx file types extend the Office Open XML file format:
        // https://en.wikipedia.org/wiki/Office_Open_XML_file_formats
        // We look for:
        // - one entry named '[Content_Types].xml' or '_rels/.rels',
        // - one entry indicating specific type of file.
        // MS Office, OpenOffice and LibreOffice may put the parts in different order, so the check should not rely on it.
        if (zipHeader.filename === 'mimetype' && zipHeader.compressedSize === zipHeader.uncompressedSize) {
          const mimeType = await tokenizer.readToken(new Token.StringType(zipHeader.compressedSize, 'utf-8'));
          switch (mimeType) {
            case 'application/epub+zip':
              return {
                ext: 'epub',
                mime: 'application/epub+zip'
              };
            case 'application/vnd.oasis.opendocument.text':
              return {
                ext: 'odt',
                mime: 'application/vnd.oasis.opendocument.text'
              };
            case 'application/vnd.oasis.opendocument.spreadsheet':
              return {
                ext: 'ods',
                mime: 'application/vnd.oasis.opendocument.spreadsheet'
              };
            case 'application/vnd.oasis.opendocument.presentation':
              return {
                ext: 'odp',
                mime: 'application/vnd.oasis.opendocument.presentation'
              };
            default:
          }
        }

        // Try to find next header manually when current one is corrupted
        if (zipHeader.compressedSize === 0) {
          let nextHeaderIndex = -1;
          while (nextHeaderIndex < 0 && tokenizer.position < tokenizer.fileInfo.size) {
            await tokenizer.peekBuffer(buffer, {
              mayBeLess: true
            });
            nextHeaderIndex = buffer.indexOf('504B0304', 0, 'hex');
            // Move position to the next header if found, skip the whole buffer otherwise
            await tokenizer.ignore(nextHeaderIndex >= 0 ? nextHeaderIndex : buffer.length);
          }
        } else {
          await tokenizer.ignore(zipHeader.compressedSize);
        }
      }
    } catch (error) {
      if (!(error instanceof strtok3.EndOfStreamError)) {
        throw error;
      }
    }
    return {
      ext: 'zip',
      mime: 'application/zip'
    };
  }
  if (checkString('OggS')) {
    // This is an OGG container
    await tokenizer.ignore(28);
    const type = Buffer.alloc(8);
    await tokenizer.readBuffer(type);

    // Needs to be before `ogg` check
    if (_check(type, [0x4F, 0x70, 0x75, 0x73, 0x48, 0x65, 0x61, 0x64])) {
      return {
        ext: 'opus',
        mime: 'audio/opus'
      };
    }

    // If ' theora' in header.
    if (_check(type, [0x80, 0x74, 0x68, 0x65, 0x6F, 0x72, 0x61])) {
      return {
        ext: 'ogv',
        mime: 'video/ogg'
      };
    }

    // If '\x01video' in header.
    if (_check(type, [0x01, 0x76, 0x69, 0x64, 0x65, 0x6F, 0x00])) {
      return {
        ext: 'ogm',
        mime: 'video/ogg'
      };
    }

    // If ' FLAC' in header  https://xiph.org/flac/faq.html
    if (_check(type, [0x7F, 0x46, 0x4C, 0x41, 0x43])) {
      return {
        ext: 'oga',
        mime: 'audio/ogg'
      };
    }

    // 'Speex  ' in header https://en.wikipedia.org/wiki/Speex
    if (_check(type, [0x53, 0x70, 0x65, 0x65, 0x78, 0x20, 0x20])) {
      return {
        ext: 'spx',
        mime: 'audio/ogg'
      };
    }

    // If '\x01vorbis' in header
    if (_check(type, [0x01, 0x76, 0x6F, 0x72, 0x62, 0x69, 0x73])) {
      return {
        ext: 'ogg',
        mime: 'audio/ogg'
      };
    }

    // Default OGG container https://www.iana.org/assignments/media-types/application/ogg
    return {
      ext: 'ogx',
      mime: 'application/ogg'
    };
  }
  if (check([0x50, 0x4B]) && (buffer[2] === 0x3 || buffer[2] === 0x5 || buffer[2] === 0x7) && (buffer[3] === 0x4 || buffer[3] === 0x6 || buffer[3] === 0x8)) {
    return {
      ext: 'zip',
      mime: 'application/zip'
    };
  }

  //

  // File Type Box (https://en.wikipedia.org/wiki/ISO_base_media_file_format)
  // It's not required to be first, but it's recommended to be. Almost all ISO base media files start with `ftyp` box.
  // `ftyp` box must contain a brand major identifier, which must consist of ISO 8859-1 printable characters.
  // Here we check for 8859-1 printable characters (for simplicity, it's a mask which also catches one non-printable character).
  if (checkString('ftyp', {
    offset: 4
  }) && (buffer[8] & 0x60) !== 0x00 // Brand major, first character ASCII?
  ) {
    // They all can have MIME `video/mp4` except `application/mp4` special-case which is hard to detect.
    // For some cases, we're specific, everything else falls to `video/mp4` with `mp4` extension.
    const brandMajor = buffer.toString('binary', 8, 12).replace('\0', ' ').trim();
    switch (brandMajor) {
      case 'avif':
        return {
          ext: 'avif',
          mime: 'image/avif'
        };
      case 'mif1':
        return {
          ext: 'heic',
          mime: 'image/heif'
        };
      case 'msf1':
        return {
          ext: 'heic',
          mime: 'image/heif-sequence'
        };
      case 'heic':
      case 'heix':
        return {
          ext: 'heic',
          mime: 'image/heic'
        };
      case 'hevc':
      case 'hevx':
        return {
          ext: 'heic',
          mime: 'image/heic-sequence'
        };
      case 'qt':
        return {
          ext: 'mov',
          mime: 'video/quicktime'
        };
      case 'M4V':
      case 'M4VH':
      case 'M4VP':
        return {
          ext: 'm4v',
          mime: 'video/x-m4v'
        };
      case 'M4P':
        return {
          ext: 'm4p',
          mime: 'video/mp4'
        };
      case 'M4B':
        return {
          ext: 'm4b',
          mime: 'audio/mp4'
        };
      case 'M4A':
        return {
          ext: 'm4a',
          mime: 'audio/x-m4a'
        };
      case 'F4V':
        return {
          ext: 'f4v',
          mime: 'video/mp4'
        };
      case 'F4P':
        return {
          ext: 'f4p',
          mime: 'video/mp4'
        };
      case 'F4A':
        return {
          ext: 'f4a',
          mime: 'audio/mp4'
        };
      case 'F4B':
        return {
          ext: 'f4b',
          mime: 'audio/mp4'
        };
      case 'crx':
        return {
          ext: 'cr3',
          mime: 'image/x-canon-cr3'
        };
      default:
        if (brandMajor.startsWith('3g')) {
          if (brandMajor.startsWith('3g2')) {
            return {
              ext: '3g2',
              mime: 'video/3gpp2'
            };
          }
          return {
            ext: '3gp',
            mime: 'video/3gpp'
          };
        }
        return {
          ext: 'mp4',
          mime: 'video/mp4'
        };
    }
  }
  if (checkString('MThd')) {
    return {
      ext: 'mid',
      mime: 'audio/midi'
    };
  }
  if (checkString('wOFF') && (check([0x00, 0x01, 0x00, 0x00], {
    offset: 4
  }) || checkString('OTTO', {
    offset: 4
  }))) {
    return {
      ext: 'woff',
      mime: 'font/woff'
    };
  }
  if (checkString('wOF2') && (check([0x00, 0x01, 0x00, 0x00], {
    offset: 4
  }) || checkString('OTTO', {
    offset: 4
  }))) {
    return {
      ext: 'woff2',
      mime: 'font/woff2'
    };
  }
  if (check([0xD4, 0xC3, 0xB2, 0xA1]) || check([0xA1, 0xB2, 0xC3, 0xD4])) {
    return {
      ext: 'pcap',
      mime: 'application/vnd.tcpdump.pcap'
    };
  }

  // Sony DSD Stream File (DSF)
  if (checkString('DSD ')) {
    return {
      ext: 'dsf',
      mime: 'audio/x-dsf' // Non-standard
    };
  }
  if (checkString('LZIP')) {
    return {
      ext: 'lz',
      mime: 'application/x-lzip'
    };
  }
  if (checkString('fLaC')) {
    return {
      ext: 'flac',
      mime: 'audio/x-flac'
    };
  }
  if (check([0x42, 0x50, 0x47, 0xFB])) {
    return {
      ext: 'bpg',
      mime: 'image/bpg'
    };
  }
  if (checkString('wvpk')) {
    return {
      ext: 'wv',
      mime: 'audio/wavpack'
    };
  }
  if (checkString('%PDF')) {
    await tokenizer.ignore(1350);
    const maxBufferSize = 10 * 1024 * 1024;
    const buffer = Buffer.alloc(Math.min(maxBufferSize, tokenizer.fileInfo.size));
    await tokenizer.readBuffer(buffer, {
      mayBeLess: true
    });

    // Check if this is an Adobe Illustrator file
    if (buffer.includes(Buffer.from('AIPrivateData'))) {
      return {
        ext: 'ai',
        mime: 'application/postscript'
      };
    }

    // Assume this is just a normal PDF
    return {
      ext: 'pdf',
      mime: 'application/pdf'
    };
  }
  if (check([0x00, 0x61, 0x73, 0x6D])) {
    return {
      ext: 'wasm',
      mime: 'application/wasm'
    };
  }

  // TIFF, little-endian type
  if (check([0x49, 0x49, 0x2A, 0x0])) {
    if (checkString('CR', {
      offset: 8
    })) {
      return {
        ext: 'cr2',
        mime: 'image/x-canon-cr2'
      };
    }
    if (check([0x1C, 0x00, 0xFE, 0x00], {
      offset: 8
    }) || check([0x1F, 0x00, 0x0B, 0x00], {
      offset: 8
    })) {
      return {
        ext: 'nef',
        mime: 'image/x-nikon-nef'
      };
    }
    if (check([0x08, 0x00, 0x00, 0x00], {
      offset: 4
    }) && (check([0x2D, 0x00, 0xFE, 0x00], {
      offset: 8
    }) || check([0x27, 0x00, 0xFE, 0x00], {
      offset: 8
    }))) {
      return {
        ext: 'dng',
        mime: 'image/x-adobe-dng'
      };
    }
    buffer = Buffer.alloc(24);
    await tokenizer.peekBuffer(buffer);
    if ((check([0x10, 0xFB, 0x86, 0x01], {
      offset: 4
    }) || check([0x08, 0x00, 0x00, 0x00], {
      offset: 4
    })) &&
    // This pattern differentiates ARW from other TIFF-ish file types:
    check([0x00, 0xFE, 0x00, 0x04, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x03, 0x01], {
      offset: 9
    })) {
      return {
        ext: 'arw',
        mime: 'image/x-sony-arw'
      };
    }
    return {
      ext: 'tif',
      mime: 'image/tiff'
    };
  }

  // TIFF, big-endian type
  if (check([0x4D, 0x4D, 0x0, 0x2A])) {
    return {
      ext: 'tif',
      mime: 'image/tiff'
    };
  }
  if (checkString('MAC ')) {
    return {
      ext: 'ape',
      mime: 'audio/ape'
    };
  }

  // https://github.com/threatstack/libmagic/blob/master/magic/Magdir/matroska
  if (check([0x1A, 0x45, 0xDF, 0xA3])) {
    // Root element: EBML
    async function readField() {
      const msb = await tokenizer.peekNumber(Token.UINT8);
      let mask = 0x80;
      let ic = 0; // 0 = A, 1 = B, 2 = C, 3 = D

      while ((msb & mask) === 0) {
        ++ic;
        mask >>= 1;
      }
      const id = Buffer.alloc(ic + 1);
      await tokenizer.readBuffer(id);
      return id;
    }
    async function readElement() {
      const id = await readField();
      const lenField = await readField();
      lenField[0] ^= 0x80 >> lenField.length - 1;
      const nrLen = Math.min(6, lenField.length); // JavaScript can max read 6 bytes integer
      return {
        id: id.readUIntBE(0, id.length),
        len: lenField.readUIntBE(lenField.length - nrLen, nrLen)
      };
    }
    async function readChildren(level, children) {
      while (children > 0) {
        const e = await readElement();
        if (e.id === 0x4282) {
          return tokenizer.readToken(new Token.StringType(e.len, 'utf-8')); // Return DocType
        }
        await tokenizer.ignore(e.len); // ignore payload
        --children;
      }
    }
    const re = await readElement();
    const docType = await readChildren(1, re.len);
    switch (docType) {
      case 'webm':
        return {
          ext: 'webm',
          mime: 'video/webm'
        };
      case 'matroska':
        return {
          ext: 'mkv',
          mime: 'video/x-matroska'
        };
      default:
        return;
    }
  }

  // RIFF file format which might be AVI, WAV, QCP, etc
  if (check([0x52, 0x49, 0x46, 0x46])) {
    if (check([0x41, 0x56, 0x49], {
      offset: 8
    })) {
      return {
        ext: 'avi',
        mime: 'video/vnd.avi'
      };
    }
    if (check([0x57, 0x41, 0x56, 0x45], {
      offset: 8
    })) {
      return {
        ext: 'wav',
        mime: 'audio/vnd.wave'
      };
    }

    // QLCM, QCP file
    if (check([0x51, 0x4C, 0x43, 0x4D], {
      offset: 8
    })) {
      return {
        ext: 'qcp',
        mime: 'audio/qcelp'
      };
    }
  }
  if (checkString('SQLi')) {
    return {
      ext: 'sqlite',
      mime: 'application/x-sqlite3'
    };
  }
  if (check([0x4E, 0x45, 0x53, 0x1A])) {
    return {
      ext: 'nes',
      mime: 'application/x-nintendo-nes-rom'
    };
  }
  if (checkString('Cr24')) {
    return {
      ext: 'crx',
      mime: 'application/x-google-chrome-extension'
    };
  }
  if (checkString('MSCF') || checkString('ISc(')) {
    return {
      ext: 'cab',
      mime: 'application/vnd.ms-cab-compressed'
    };
  }
  if (check([0xED, 0xAB, 0xEE, 0xDB])) {
    return {
      ext: 'rpm',
      mime: 'application/x-rpm'
    };
  }
  if (check([0xC5, 0xD0, 0xD3, 0xC6])) {
    return {
      ext: 'eps',
      mime: 'application/eps'
    };
  }
  if (check([0x28, 0xB5, 0x2F, 0xFD])) {
    return {
      ext: 'zst',
      mime: 'application/zstd'
    };
  }

  // -- 5-byte signatures --

  if (check([0x4F, 0x54, 0x54, 0x4F, 0x00])) {
    return {
      ext: 'otf',
      mime: 'font/otf'
    };
  }
  if (checkString('#!AMR')) {
    return {
      ext: 'amr',
      mime: 'audio/amr'
    };
  }
  if (checkString('{\\rtf')) {
    return {
      ext: 'rtf',
      mime: 'application/rtf'
    };
  }
  if (check([0x46, 0x4C, 0x56, 0x01])) {
    return {
      ext: 'flv',
      mime: 'video/x-flv'
    };
  }
  if (checkString('IMPM')) {
    return {
      ext: 'it',
      mime: 'audio/x-it'
    };
  }
  if (checkString('-lh0-', {
    offset: 2
  }) || checkString('-lh1-', {
    offset: 2
  }) || checkString('-lh2-', {
    offset: 2
  }) || checkString('-lh3-', {
    offset: 2
  }) || checkString('-lh4-', {
    offset: 2
  }) || checkString('-lh5-', {
    offset: 2
  }) || checkString('-lh6-', {
    offset: 2
  }) || checkString('-lh7-', {
    offset: 2
  }) || checkString('-lzs-', {
    offset: 2
  }) || checkString('-lz4-', {
    offset: 2
  }) || checkString('-lz5-', {
    offset: 2
  }) || checkString('-lhd-', {
    offset: 2
  })) {
    return {
      ext: 'lzh',
      mime: 'application/x-lzh-compressed'
    };
  }

  // MPEG program stream (PS or MPEG-PS)
  if (check([0x00, 0x00, 0x01, 0xBA])) {
    //  MPEG-PS, MPEG-1 Part 1
    if (check([0x21], {
      offset: 4,
      mask: [0xF1]
    })) {
      return {
        ext: 'mpg',
        // May also be .ps, .mpeg
        mime: 'video/MP1S'
      };
    }

    // MPEG-PS, MPEG-2 Part 1
    if (check([0x44], {
      offset: 4,
      mask: [0xC4]
    })) {
      return {
        ext: 'mpg',
        // May also be .mpg, .m2p, .vob or .sub
        mime: 'video/MP2P'
      };
    }
  }
  if (checkString('ITSF')) {
    return {
      ext: 'chm',
      mime: 'application/vnd.ms-htmlhelp'
    };
  }

  // -- 6-byte signatures --

  if (check([0xFD, 0x37, 0x7A, 0x58, 0x5A, 0x00])) {
    return {
      ext: 'xz',
      mime: 'application/x-xz'
    };
  }
  if (checkString('<?xml ')) {
    return {
      ext: 'xml',
      mime: 'application/xml'
    };
  }
  if (check([0x37, 0x7A, 0xBC, 0xAF, 0x27, 0x1C])) {
    return {
      ext: '7z',
      mime: 'application/x-7z-compressed'
    };
  }
  if (check([0x52, 0x61, 0x72, 0x21, 0x1A, 0x7]) && (buffer[6] === 0x0 || buffer[6] === 0x1)) {
    return {
      ext: 'rar',
      mime: 'application/x-rar-compressed'
    };
  }
  if (checkString('solid ')) {
    return {
      ext: 'stl',
      mime: 'model/stl'
    };
  }

  // -- 7-byte signatures --

  if (checkString('BLENDER')) {
    return {
      ext: 'blend',
      mime: 'application/x-blender'
    };
  }
  if (checkString('!<arch>')) {
    await tokenizer.ignore(8);
    const str = await tokenizer.readToken(new Token.StringType(13, 'ascii'));
    if (str === 'debian-binary') {
      return {
        ext: 'deb',
        mime: 'application/x-deb'
      };
    }
    return {
      ext: 'ar',
      mime: 'application/x-unix-archive'
    };
  }

  // -- 8-byte signatures --

  if (check([0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A])) {
    // APNG format (https://wiki.mozilla.org/APNG_Specification)
    // 1. Find the first IDAT (image data) chunk (49 44 41 54)
    // 2. Check if there is an "acTL" chunk before the IDAT one (61 63 54 4C)

    // Offset calculated as follows:
    // - 8 bytes: PNG signature
    // - 4 (length) + 4 (chunk type) + 13 (chunk data) + 4 (CRC): IHDR chunk

    await tokenizer.ignore(8); // ignore PNG signature

    async function readChunkHeader() {
      return {
        length: await tokenizer.readToken(Token.INT32_BE),
        type: await tokenizer.readToken(new Token.StringType(4, 'binary'))
      };
    }
    do {
      const chunk = await readChunkHeader();
      if (chunk.length < 0) {
        return; // Invalid chunk length
      }
      switch (chunk.type) {
        case 'IDAT':
          return {
            ext: 'png',
            mime: 'image/png'
          };
        case 'acTL':
          return {
            ext: 'apng',
            mime: 'image/apng'
          };
        default:
          await tokenizer.ignore(chunk.length + 4);
        // Ignore chunk-data + CRC
      }
    } while (tokenizer.position + 8 < tokenizer.fileInfo.size);
    return {
      ext: 'png',
      mime: 'image/png'
    };
  }
  if (check([0x41, 0x52, 0x52, 0x4F, 0x57, 0x31, 0x00, 0x00])) {
    return {
      ext: 'arrow',
      mime: 'application/x-apache-arrow'
    };
  }
  if (check([0x67, 0x6C, 0x54, 0x46, 0x02, 0x00, 0x00, 0x00])) {
    return {
      ext: 'glb',
      mime: 'model/gltf-binary'
    };
  }

  // `mov` format variants
  if (check([0x66, 0x72, 0x65, 0x65], {
    offset: 4
  }) ||
  // `free`
  check([0x6D, 0x64, 0x61, 0x74], {
    offset: 4
  }) ||
  // `mdat` MJPEG
  check([0x6D, 0x6F, 0x6F, 0x76], {
    offset: 4
  }) ||
  // `moov`
  check([0x77, 0x69, 0x64, 0x65], {
    offset: 4
  }) // `wide`
  ) {
    return {
      ext: 'mov',
      mime: 'video/quicktime'
    };
  }

  // -- 9-byte signatures --

  if (check([0x49, 0x49, 0x52, 0x4F, 0x08, 0x00, 0x00, 0x00, 0x18])) {
    return {
      ext: 'orf',
      mime: 'image/x-olympus-orf'
    };
  }
  if (checkString('gimp xcf ')) {
    return {
      ext: 'xcf',
      mime: 'image/x-xcf'
    };
  }

  // -- 12-byte signatures --

  if (check([0x49, 0x49, 0x55, 0x00, 0x18, 0x00, 0x00, 0x00, 0x88, 0xE7, 0x74, 0xD8])) {
    return {
      ext: 'rw2',
      mime: 'image/x-panasonic-rw2'
    };
  }

  // ASF_Header_Object first 80 bytes
  if (check([0x30, 0x26, 0xB2, 0x75, 0x8E, 0x66, 0xCF, 0x11, 0xA6, 0xD9])) {
    async function readHeader() {
      const guid = Buffer.alloc(16);
      await tokenizer.readBuffer(guid);
      return {
        id: guid,
        size: Number(await tokenizer.readToken(Token.UINT64_LE))
      };
    }
    await tokenizer.ignore(30);
    // Search for header should be in first 1KB of file.
    while (tokenizer.position + 24 < tokenizer.fileInfo.size) {
      const header = await readHeader();
      let payload = header.size - 24;
      if (_check(header.id, [0x91, 0x07, 0xDC, 0xB7, 0xB7, 0xA9, 0xCF, 0x11, 0x8E, 0xE6, 0x00, 0xC0, 0x0C, 0x20, 0x53, 0x65])) {
        // Sync on Stream-Properties-Object (B7DC0791-A9B7-11CF-8EE6-00C00C205365)
        const typeId = Buffer.alloc(16);
        payload -= await tokenizer.readBuffer(typeId);
        if (_check(typeId, [0x40, 0x9E, 0x69, 0xF8, 0x4D, 0x5B, 0xCF, 0x11, 0xA8, 0xFD, 0x00, 0x80, 0x5F, 0x5C, 0x44, 0x2B])) {
          // Found audio:
          return {
            ext: 'asf',
            mime: 'audio/x-ms-asf'
          };
        }
        if (_check(typeId, [0xC0, 0xEF, 0x19, 0xBC, 0x4D, 0x5B, 0xCF, 0x11, 0xA8, 0xFD, 0x00, 0x80, 0x5F, 0x5C, 0x44, 0x2B])) {
          // Found video:
          return {
            ext: 'asf',
            mime: 'video/x-ms-asf'
          };
        }
        break;
      }
      await tokenizer.ignore(payload);
    }

    // Default to ASF generic extension
    return {
      ext: 'asf',
      mime: 'application/vnd.ms-asf'
    };
  }
  if (check([0xAB, 0x4B, 0x54, 0x58, 0x20, 0x31, 0x31, 0xBB, 0x0D, 0x0A, 0x1A, 0x0A])) {
    return {
      ext: 'ktx',
      mime: 'image/ktx'
    };
  }
  if ((check([0x7E, 0x10, 0x04]) || check([0x7E, 0x18, 0x04])) && check([0x30, 0x4D, 0x49, 0x45], {
    offset: 4
  })) {
    return {
      ext: 'mie',
      mime: 'application/x-mie'
    };
  }
  if (check([0x27, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], {
    offset: 2
  })) {
    return {
      ext: 'shp',
      mime: 'application/x-esri-shape'
    };
  }
  if (check([0x00, 0x00, 0x00, 0x0C, 0x6A, 0x50, 0x20, 0x20, 0x0D, 0x0A, 0x87, 0x0A])) {
    // JPEG-2000 family

    await tokenizer.ignore(20);
    const type = await tokenizer.readToken(new Token.StringType(4, 'ascii'));
    switch (type) {
      case 'jp2 ':
        return {
          ext: 'jp2',
          mime: 'image/jp2'
        };
      case 'jpx ':
        return {
          ext: 'jpx',
          mime: 'image/jpx'
        };
      case 'jpm ':
        return {
          ext: 'jpm',
          mime: 'image/jpm'
        };
      case 'mjp2':
        return {
          ext: 'mj2',
          mime: 'image/mj2'
        };
      default:
        return;
    }
  }
  if (check([0xFF, 0x0A]) || check([0x00, 0x00, 0x00, 0x0C, 0x4A, 0x58, 0x4C, 0x20, 0x0D, 0x0A, 0x87, 0x0A])) {
    return {
      ext: 'jxl',
      mime: 'image/jxl'
    };
  }

  // -- Unsafe signatures --

  if (check([0x0, 0x0, 0x1, 0xBA]) || check([0x0, 0x0, 0x1, 0xB3])) {
    return {
      ext: 'mpg',
      mime: 'video/mpeg'
    };
  }
  if (check([0x00, 0x01, 0x00, 0x00, 0x00])) {
    return {
      ext: 'ttf',
      mime: 'font/ttf'
    };
  }
  if (check([0x00, 0x00, 0x01, 0x00])) {
    return {
      ext: 'ico',
      mime: 'image/x-icon'
    };
  }
  if (check([0x00, 0x00, 0x02, 0x00])) {
    return {
      ext: 'cur',
      mime: 'image/x-icon'
    };
  }
  if (check([0xD0, 0xCF, 0x11, 0xE0, 0xA1, 0xB1, 0x1A, 0xE1])) {
    // Detected Microsoft Compound File Binary File (MS-CFB) Format.
    return {
      ext: 'cfb',
      mime: 'application/x-cfb'
    };
  }

  // Increase sample size from 12 to 256.
  await tokenizer.peekBuffer(buffer, {
    length: Math.min(256, tokenizer.fileInfo.size),
    mayBeLess: true
  });

  // -- 15-byte signatures --

  if (checkString('BEGIN:')) {
    if (checkString('VCARD', {
      offset: 6
    })) {
      return {
        ext: 'vcf',
        mime: 'text/vcard'
      };
    }
    if (checkString('VCALENDAR', {
      offset: 6
    })) {
      return {
        ext: 'ics',
        mime: 'text/calendar'
      };
    }
  }

  // `raf` is here just to keep all the raw image detectors together.
  if (checkString('FUJIFILMCCD-RAW')) {
    return {
      ext: 'raf',
      mime: 'image/x-fujifilm-raf'
    };
  }
  if (checkString('Extended Module:')) {
    return {
      ext: 'xm',
      mime: 'audio/x-xm'
    };
  }
  if (checkString('Creative Voice File')) {
    return {
      ext: 'voc',
      mime: 'audio/x-voc'
    };
  }
  if (check([0x04, 0x00, 0x00, 0x00]) && buffer.length >= 16) {
    // Rough & quick check Pickle/ASAR
    const jsonSize = buffer.readUInt32LE(12);
    if (jsonSize > 12 && buffer.length >= jsonSize + 16) {
      try {
        const header = buffer.slice(16, jsonSize + 16).toString();
        const json = JSON.parse(header);
        // Check if Pickle is ASAR
        if (json.files) {
          // Final check, assuring Pickle/ASAR format
          return {
            ext: 'asar',
            mime: 'application/x-asar'
          };
        }
      } catch (_) {}
    }
  }
  if (check([0x06, 0x0E, 0x2B, 0x34, 0x02, 0x05, 0x01, 0x01, 0x0D, 0x01, 0x02, 0x01, 0x01, 0x02])) {
    return {
      ext: 'mxf',
      mime: 'application/mxf'
    };
  }
  if (checkString('SCRM', {
    offset: 44
  })) {
    return {
      ext: 's3m',
      mime: 'audio/x-s3m'
    };
  }
  if (check([0x47], {
    offset: 4
  }) && (check([0x47], {
    offset: 192
  }) || check([0x47], {
    offset: 196
  }))) {
    return {
      ext: 'mts',
      mime: 'video/mp2t'
    };
  }
  if (check([0x42, 0x4F, 0x4F, 0x4B, 0x4D, 0x4F, 0x42, 0x49], {
    offset: 60
  })) {
    return {
      ext: 'mobi',
      mime: 'application/x-mobipocket-ebook'
    };
  }
  if (check([0x44, 0x49, 0x43, 0x4D], {
    offset: 128
  })) {
    return {
      ext: 'dcm',
      mime: 'application/dicom'
    };
  }
  if (check([0x4C, 0x00, 0x00, 0x00, 0x01, 0x14, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46])) {
    return {
      ext: 'lnk',
      mime: 'application/x.ms.shortcut' // Invented by us
    };
  }
  if (check([0x62, 0x6F, 0x6F, 0x6B, 0x00, 0x00, 0x00, 0x00, 0x6D, 0x61, 0x72, 0x6B, 0x00, 0x00, 0x00, 0x00])) {
    return {
      ext: 'alias',
      mime: 'application/x.apple.alias' // Invented by us
    };
  }
  if (check([0x4C, 0x50], {
    offset: 34
  }) && (check([0x00, 0x00, 0x01], {
    offset: 8
  }) || check([0x01, 0x00, 0x02], {
    offset: 8
  }) || check([0x02, 0x00, 0x02], {
    offset: 8
  }))) {
    return {
      ext: 'eot',
      mime: 'application/vnd.ms-fontobject'
    };
  }
  if (check([0x06, 0x06, 0xED, 0xF5, 0xD8, 0x1D, 0x46, 0xE5, 0xBD, 0x31, 0xEF, 0xE7, 0xFE, 0x74, 0xB7, 0x1D])) {
    return {
      ext: 'indd',
      mime: 'application/x-indesign'
    };
  }

  // Increase sample size from 256 to 512
  await tokenizer.peekBuffer(buffer, {
    length: Math.min(512, tokenizer.fileInfo.size),
    mayBeLess: true
  });

  // Requires a buffer size of 512 bytes
  if (tarHeaderChecksumMatches(buffer)) {
    return {
      ext: 'tar',
      mime: 'application/x-tar'
    };
  }
  if (check([0xFF, 0xFE, 0xFF, 0x0E, 0x53, 0x00, 0x6B, 0x00, 0x65, 0x00, 0x74, 0x00, 0x63, 0x00, 0x68, 0x00, 0x55, 0x00, 0x70, 0x00, 0x20, 0x00, 0x4D, 0x00, 0x6F, 0x00, 0x64, 0x00, 0x65, 0x00, 0x6C, 0x00])) {
    return {
      ext: 'skp',
      mime: 'application/vnd.sketchup.skp'
    };
  }
  if (checkString('-----BEGIN PGP MESSAGE-----')) {
    return {
      ext: 'pgp',
      mime: 'application/pgp-encrypted'
    };
  }

  // Check MPEG 1 or 2 Layer 3 header, or 'layer 0' for ADTS (MPEG sync-word 0xFFE)
  if (buffer.length >= 2 && check([0xFF, 0xE0], {
    offset: 0,
    mask: [0xFF, 0xE0]
  })) {
    if (check([0x10], {
      offset: 1,
      mask: [0x16]
    })) {
      // Check for (ADTS) MPEG-2
      if (check([0x08], {
        offset: 1,
        mask: [0x08]
      })) {
        return {
          ext: 'aac',
          mime: 'audio/aac'
        };
      }

      // Must be (ADTS) MPEG-4
      return {
        ext: 'aac',
        mime: 'audio/aac'
      };
    }

    // MPEG 1 or 2 Layer 3 header
    // Check for MPEG layer 3
    if (check([0x02], {
      offset: 1,
      mask: [0x06]
    })) {
      return {
        ext: 'mp3',
        mime: 'audio/mpeg'
      };
    }

    // Check for MPEG layer 2
    if (check([0x04], {
      offset: 1,
      mask: [0x06]
    })) {
      return {
        ext: 'mp2',
        mime: 'audio/mpeg'
      };
    }

    // Check for MPEG layer 1
    if (check([0x06], {
      offset: 1,
      mask: [0x06]
    })) {
      return {
        ext: 'mp1',
        mime: 'audio/mpeg'
      };
    }
  }
}
const stream = readableStream => new Promise((resolve, reject) => {
  // Using `eval` to work around issues when bundling with Webpack
  const stream = eval('require')('stream'); // eslint-disable-line no-eval

  readableStream.on('error', reject);
  readableStream.once('readable', async () => {
    // Set up output stream
    const pass = new stream.PassThrough();
    let outputStream;
    if (stream.pipeline) {
      outputStream = stream.pipeline(readableStream, pass, () => {});
    } else {
      outputStream = readableStream.pipe(pass);
    }

    // Read the input stream and detect the filetype
    const chunk = readableStream.read(minimumBytes) || readableStream.read() || Buffer.alloc(0);
    try {
      const fileType = await fromBuffer(chunk);
      pass.fileType = fileType;
    } catch (error) {
      reject(error);
    }
    resolve(outputStream);
  });
});
const fileType = {
  fromStream,
  fromTokenizer,
  fromBuffer,
  stream
};
Object.defineProperty(fileType, 'extensions', {
  get() {
    return new Set(supported.extensions);
  }
});
Object.defineProperty(fileType, 'mimeTypes', {
  get() {
    return new Set(supported.mimeTypes);
  }
});
var core = fileType;

(function (module) {

  const {
    ReadableWebToNodeStream
  } = lib$2;
  const core$1 = core;
  async function fromStream(stream) {
    const readableWebToNodeStream = new ReadableWebToNodeStream(stream);
    const fileType = await core$1.fromStream(readableWebToNodeStream);
    await readableWebToNodeStream.close();
    return fileType;
  }
  async function fromBlob(blob) {
    const buffer = await blobToArrayBuffer(blob);
    return core$1.fromBuffer(Buffer.from(buffer));
  }

  /**
  Convert Blobs to ArrayBuffer.
  @param {Blob} blob - Web API Blob.
  @returns {Promise<ArrayBuffer>}
  */
  function blobToArrayBuffer(blob) {
    if (blob.arrayBuffer) {
      return blob.arrayBuffer();
    }

    // TODO: Remove when stop supporting older environments
    return new Promise((resolve, reject) => {
      const fileReader = new FileReader();
      fileReader.addEventListener('loadend', event => {
        resolve(event.target.result);
      });
      fileReader.addEventListener('error', event => {
        reject(new Error(event.message));
      });
      fileReader.addEventListener('abort', event => {
        reject(new Error(event.type));
      });
      fileReader.readAsArrayBuffer(blob);
    });
  }
  Object.assign(module.exports, core$1, {
    fromStream,
    fromBlob
  });
})(browser$2);
var browser = browser$2.exports;

var browser$1 = /*#__PURE__*/_mergeNamespaces({
    __proto__: null,
    'default': browser
}, [browser$2.exports]);

exports.browser = browser$1;
//# sourceMappingURL=browser-f8aa3bca.js.map
