"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Secp256k1Program = void 0;
const sha3_1 = require("@noble/hashes/sha3");
const secp = __importStar(require("@noble/secp256k1"));
const buffer_layout_1 = require("@solana/buffer-layout");
const web3_js_1 = require("@solana/web3.js");
/**
 * The layout of Secp256k1 instruction data. Copied from @solana/web3.js because
 * it isn't exported there.
 *
 * @see {@link https://github.com/solana-labs/solana-web3.js/blob/d0d4d3e4d96f4fc7a4a9adf24e189be60183f460/packages/library-legacy/src/programs/secp256k1.ts#L47 SECP256K1_INSTRUCTION_LAYOUT}
 */
const SECP256K1_INSTRUCTION_LAYOUT = (0, buffer_layout_1.struct)([
    (0, buffer_layout_1.u8)('numSignatures'),
    (0, buffer_layout_1.u16)('signatureOffset'),
    (0, buffer_layout_1.u8)('signatureInstructionIndex'),
    (0, buffer_layout_1.u16)('ethAddressOffset'),
    (0, buffer_layout_1.u8)('ethAddressInstructionIndex'),
    (0, buffer_layout_1.u16)('messageDataOffset'),
    (0, buffer_layout_1.u16)('messageDataSize'),
    (0, buffer_layout_1.u8)('messageInstructionIndex'),
    (0, buffer_layout_1.blob)(20, 'ethAddress'),
    (0, buffer_layout_1.blob)(64, 'signature'),
    (0, buffer_layout_1.u8)('recoveryId')
]);
/**
 * Extends the @solana/web3.js Secp256k1Program API with a decode method
 * and other useful utilities.
 */
class Secp256k1Program extends web3_js_1.Secp256k1Program {
    /**
     * Decodes an Secp256k1 instruction data into a Typescript object.
     * Useful for debugging.
     */
    static decode(instructionOrData) {
        const data = 'data' in instructionOrData ? instructionOrData.data : instructionOrData;
        const decoded = SECP256K1_INSTRUCTION_LAYOUT.decode(data);
        const message = data.subarray(decoded.messageDataOffset, decoded.messageDataOffset + decoded.messageDataSize);
        return Object.assign(Object.assign({}, decoded), { message });
    }
    /**
     * Creates an Ethereum address from a secp256k1 public key.
     *
     * Port of the secp256k1 program's Rust code.
     * @see {@link https://github.com/solana-labs/solana/blob/27eff8408b7223bb3c4ab70523f8a8dca3ca6645/sdk/src/secp256k1_instruction.rs#L906C1-L914C2 construct_eth_pubkey}
     */
    static constructEthPubkey(pubkey) {
        return (0, sha3_1.keccak_256)(Buffer.from(pubkey.subarray(1))).subarray(12);
    }
    /**
     * Recovers the true signer for a decoded instruction.
     */
    static recoverSigner(decoded) {
        const messageHash = (0, sha3_1.keccak_256)(decoded.message);
        return secp.recoverPublicKey(messageHash, decoded.signature, decoded.recoveryId);
    }
    /**
     * Verifies the true signer for a decoded instruction matches the one
     * in the instruction data.
     */
    static verifySignature(decoded) {
        const signer = Secp256k1Program.recoverSigner(decoded);
        const address = Secp256k1Program.constructEthPubkey(signer);
        for (let i = 0; i < address.length; i++) {
            if (address.at(i) !== decoded.ethAddress.at(i)) {
                return false;
            }
        }
        return address.byteLength === decoded.ethAddress.byteLength;
    }
}
exports.Secp256k1Program = Secp256k1Program;
//# sourceMappingURL=Secp256k1Program.js.map