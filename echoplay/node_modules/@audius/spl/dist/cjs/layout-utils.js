"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.borshString = exports.ethAddress = exports.BorshString = exports.EthereumAddress = void 0;
const buffer_layout_1 = require("@solana/buffer-layout");
/**
 * Wrapper that makes Ethereum wallet addresses encoded and decoded as 20 byte blobs
 */
class EthereumAddress extends buffer_layout_1.Layout {
    constructor(property) {
        super(20, property);
        this.blob = (0, buffer_layout_1.blob)(20, property);
    }
    /** @override */
    getSpan(b, offset) {
        return this.blob.getSpan(b, offset);
    }
    /**
     * Proxies the decoding to the underlying Blob, then
     * converts the buffer to hex and prepends '0x'.
     * @override
     * */
    decode(b, offset = 0) {
        const buffer = this.blob.decode(b, offset);
        return '0x' + Buffer.from(buffer).toString('hex');
    }
    /**
     * Strips the 0x and converts the address to a buffer, then
     * proxies the encoding to the underlying Blob.
     * @override
     * */
    encode(src, b, offset = 0) {
        const strippedEthAddress = src.replace('0x', '');
        // Need to pad the array to length 20 - otherwise, hex eth keys starting with '0' would
        // result in truncated arrays, while eth spec is always 20 bytes
        const buf = Buffer.from(strippedEthAddress, 'hex');
        const fixedBuf = Buffer.alloc(20, 0);
        buf.copy(fixedBuf, 20 - buf.length);
        return this.blob.encode(buf, b, offset);
    }
}
exports.EthereumAddress = EthereumAddress;
/**
 * Wrapper that encodes strings the way Borsh does, with the length prepended
 */
class BorshString extends buffer_layout_1.Layout {
    constructor(maxLength, property) {
        super(-1, property);
        this.maxLength = maxLength;
    }
    getSpan(b, offset = 0) {
        if (!b) {
            return (0, buffer_layout_1.u32)().span + this.maxLength;
        }
        const length = (0, buffer_layout_1.u32)().decode(b, offset);
        return (0, buffer_layout_1.u32)().span + length;
    }
    decode(b, offset = 0) {
        const length = (0, buffer_layout_1.u32)().decode(b, offset);
        const value = (0, buffer_layout_1.blob)(length).decode(b, offset + (0, buffer_layout_1.u32)().span);
        return (0, buffer_layout_1.uint8ArrayToBuffer)(value).toString('utf-8');
    }
    encode(src, b, offset) {
        const srcb = Buffer.from(src, 'utf-8');
        if (srcb.length > this.maxLength) {
            throw new RangeError('text exceeds maxLength');
        }
        if (offset + srcb.length > b.length) {
            throw new RangeError('text length exceeds buffer');
        }
        return ((0, buffer_layout_1.u32)().encode(srcb.length, b, offset) +
            (0, buffer_layout_1.blob)(srcb.length).encode(srcb, b, offset + (0, buffer_layout_1.u32)().span));
    }
}
exports.BorshString = BorshString;
/** Factory for EthereumAddress layouts */
const ethAddress = (property) => new EthereumAddress(property);
exports.ethAddress = ethAddress;
/** Factory for BorshString layouts */
const borshString = (maxLength, property) => new BorshString(maxLength, property);
exports.borshString = borshString;
//# sourceMappingURL=layout-utils.js.map