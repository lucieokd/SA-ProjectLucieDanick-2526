"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ClaimableTokensProgram = void 0;
const buffer_layout_1 = require("@solana/buffer-layout");
const buffer_layout_utils_1 = require("@solana/buffer-layout-utils");
const spl_token_1 = require("@solana/spl-token");
const web3_js_1 = require("@solana/web3.js");
const bs58_1 = __importDefault(require("bs58"));
const layout_utils_1 = require("../layout-utils");
const constants_1 = require("./constants");
const TRANSFER_NONCE_PREFIX = 'N_';
const TRANSFER_NONCE_PREFIX_BYTES = new TextEncoder().encode(TRANSFER_NONCE_PREFIX);
/** @see {@link https://github.com/solana-labs/solana-web3.js/blob/974193946d5e6fade11b96d141f21ebe8f3ff5e2/packages/library-legacy/src/programs/secp256k1.ts#L47C11-L47C11 SECP256K1_INSTRUCTION_LAYOUT} */
const SECP256K1_INSTRUCTION_MESSAGE_DATA_START = 97;
/**
 * The Claimable Tokens Program is responsible for the creation and control of
 * "user banks", which are accounts that are owned by the program itself but
 * controlled by users' Ethereum wallet addresses.
 *
 * Unlike normal Associated Token Accounts, the user bank accounts are owned
 * by the program, not a user's wallet. The only way for a user to transfer
 * tokens out of their user bank is by using this program method paired with
 * a signed Secp256k1 instruction from their Ethereum wallet specifying the
 * destination and amount.
 *
 * A user can have multiple user banks, one for each token mint.
 */
class ClaimableTokensProgram {
    static createAccountInstruction({ ethAddress, payer, mint, authority, userBank, programId = ClaimableTokensProgram.programId, tokenProgramId = spl_token_1.TOKEN_PROGRAM_ID }) {
        const data = Buffer.alloc(ClaimableTokensProgram.layouts.createAccountInstructionData.span);
        ClaimableTokensProgram.layouts.createAccountInstructionData.encode({ instruction: constants_1.ClaimableTokensInstruction.Create, ethAddress }, data);
        const keys = [
            { pubkey: payer, isSigner: true, isWritable: true },
            { pubkey: mint, isSigner: false, isWritable: false },
            { pubkey: authority, isSigner: false, isWritable: false },
            { pubkey: userBank, isSigner: false, isWritable: true },
            { pubkey: web3_js_1.SYSVAR_RENT_PUBKEY, isSigner: false, isWritable: false },
            { pubkey: tokenProgramId, isSigner: false, isWritable: false },
            { pubkey: web3_js_1.SystemProgram.programId, isSigner: false, isWritable: false }
        ];
        return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    static decodeCreateAccountInstruction({ programId, keys: [payer, mint, authority, userBank, rent, tokenProgramId, systemProgramId], data }) {
        return {
            programId,
            keys: {
                payer,
                mint,
                authority,
                userBank,
                rent,
                tokenProgramId,
                systemProgramId
            },
            data: ClaimableTokensProgram.layouts.createAccountInstructionData.decode(data)
        };
    }
    static createTransferInstruction({ payer, sourceEthAddress, sourceUserBank, destination, nonceAccount, authority, programId = ClaimableTokensProgram.programId, tokenProgramId = spl_token_1.TOKEN_PROGRAM_ID }) {
        const data = Buffer.alloc(ClaimableTokensProgram.layouts.unsignedTransferInstructionData.span);
        ClaimableTokensProgram.layouts.unsignedTransferInstructionData.encode({
            instruction: constants_1.ClaimableTokensInstruction.Transfer,
            sender: sourceEthAddress
        }, data);
        const keys = [
            { pubkey: payer, isSigner: true, isWritable: true },
            { pubkey: sourceUserBank, isSigner: false, isWritable: true },
            { pubkey: destination, isSigner: false, isWritable: true },
            { pubkey: nonceAccount, isSigner: false, isWritable: true },
            { pubkey: authority, isSigner: false, isWritable: false },
            { pubkey: web3_js_1.SYSVAR_RENT_PUBKEY, isSigner: false, isWritable: false },
            {
                pubkey: web3_js_1.SYSVAR_INSTRUCTIONS_PUBKEY,
                isSigner: false,
                isWritable: false
            },
            { pubkey: web3_js_1.SystemProgram.programId, isSigner: false, isWritable: false },
            { pubkey: tokenProgramId, isSigner: false, isWritable: false }
        ];
        return new web3_js_1.TransactionInstruction({ programId, keys, data });
    }
    static decodeTransferInstruction({ programId, keys: [payer, sourceUserBank, destination, nonceAccount, authority, rent, sysvarInstructions, systemProgramId, tokenProgramId], data }) {
        return {
            programId,
            keys: {
                payer,
                sourceUserBank,
                destination,
                nonceAccount,
                authority,
                rent,
                sysvarInstructions,
                systemProgramId,
                tokenProgramId
            },
            data: ClaimableTokensProgram.layouts.unsignedTransferInstructionData.decode(data)
        };
    }
    static decodeInstruction(instruction) {
        switch (instruction.data[0]) {
            case constants_1.ClaimableTokensInstruction.Create:
                return ClaimableTokensProgram.decodeCreateAccountInstruction(instruction);
            case constants_1.ClaimableTokensInstruction.Transfer:
                return ClaimableTokensProgram.decodeTransferInstruction(instruction);
            default:
                throw new Error('Invalid Claimable Token Program Instruction');
        }
    }
    static isCreateAccountInstruction(decoded) {
        return decoded.data.instruction === constants_1.ClaimableTokensInstruction.Create;
    }
    static isTransferInstruction(decoded) {
        return decoded.data.instruction === constants_1.ClaimableTokensInstruction.Transfer;
    }
    static createSignedTransferInstructionData({ destination, amount, nonce }) {
        const data = Buffer.alloc(ClaimableTokensProgram.layouts.signedTransferInstructionData.span);
        ClaimableTokensProgram.layouts.signedTransferInstructionData.encode({
            destination,
            amount,
            nonce
        }, data);
        return data;
    }
    static decodeSignedTransferInstructionData(instruction) {
        return ClaimableTokensProgram.layouts.signedTransferInstructionData.decode(Uint8Array.from(instruction.data).slice(SECP256K1_INSTRUCTION_MESSAGE_DATA_START));
    }
    static deriveNonce({ ethAddress: wallet, programId, authority }) {
        const ethAdddressData = (0, layout_utils_1.ethAddress)();
        const buffer = Buffer.alloc(ethAdddressData.span);
        ethAdddressData.encode(wallet, buffer);
        const seed = Uint8Array.from([...TRANSFER_NONCE_PREFIX_BYTES, ...buffer]);
        return web3_js_1.PublicKey.findProgramAddressSync([authority.toBytes().slice(0, 32), seed], programId)[0];
    }
    static deriveUserBank({ ethAddress: wallet, claimableTokensPDA, tokenProgramId = spl_token_1.TOKEN_PROGRAM_ID }) {
        return __awaiter(this, void 0, void 0, function* () {
            const ethAddressData = (0, layout_utils_1.ethAddress)();
            const buffer = Buffer.alloc(ethAddressData.span);
            ethAddressData.encode(wallet, buffer);
            const seed = bs58_1.default.encode(buffer);
            return yield web3_js_1.PublicKey.createWithSeed(claimableTokensPDA, seed, tokenProgramId);
        });
    }
}
ClaimableTokensProgram.programId = new web3_js_1.PublicKey('Ewkv3JahEFRKkcJmpoKB7pXbnUHwjAyXiwEo4ZY2rezQ');
ClaimableTokensProgram.layouts = {
    createAccountInstructionData: (0, buffer_layout_1.struct)([
        (0, buffer_layout_1.u8)('instruction'),
        (0, layout_utils_1.ethAddress)('ethAddress')
    ]),
    unsignedTransferInstructionData: (0, buffer_layout_1.struct)([
        (0, buffer_layout_1.u8)('instruction'),
        (0, layout_utils_1.ethAddress)('sender')
    ]),
    signedTransferInstructionData: (0, buffer_layout_1.struct)([
        (0, buffer_layout_utils_1.publicKey)('destination'),
        (0, buffer_layout_utils_1.u64)('amount'),
        (0, buffer_layout_utils_1.u64)('nonce')
    ]),
    nonceAccountData: (0, buffer_layout_1.struct)([(0, buffer_layout_1.u8)('version'), (0, buffer_layout_utils_1.u64)('nonce')])
};
ClaimableTokensProgram.deriveAuthority = ({ programId, mint }) => {
    return web3_js_1.PublicKey.findProgramAddressSync([mint.toBytes().slice(0, 32)], programId)[0];
};
exports.ClaimableTokensProgram = ClaimableTokensProgram;
//# sourceMappingURL=ClaimableTokensProgram.js.map