var _a;
import { blob, seq, struct, u8 } from '@solana/buffer-layout';
import { publicKey, u64 } from '@solana/buffer-layout-utils';
import { TOKEN_PROGRAM_ID } from '@solana/spl-token';
import { PublicKey, SYSVAR_INSTRUCTIONS_PUBKEY, SYSVAR_RENT_PUBKEY, SystemProgram, TransactionInstruction } from '@solana/web3.js';
import { borshString, ethAddress } from '../layout-utils';
import { attestationLayout } from './AttestationLayout';
import { senderAttestationLayout } from './SenderAttestationLayout';
import { RewardManagerInstruction } from './constants';
const encoder = new TextEncoder();
const SENDER_SEED_PREFIX = 'S_';
const SENDER_SEED_PREFIX_BYTES = encoder.encode(SENDER_SEED_PREFIX);
const ATTESTATIONS_SEED_PREFIX = 'V_';
const ATTESTATIONS_SEED_PREFIX_BYTES = encoder.encode(ATTESTATIONS_SEED_PREFIX);
const DISBURSEMENT_SEED_PREFIX = 'T_';
const DISBURSEMENT_SEED_PREFIX_BYTES = encoder.encode(DISBURSEMENT_SEED_PREFIX);
class RewardManagerProgram {
    static createSenderInstruction({ senderEthAddress, operatorEthAddress, rewardManagerState, manager, authority, payer, sender, rewardManagerProgramId = RewardManagerProgram.programId }) {
        const data = Buffer.alloc(RewardManagerProgram.layouts.createSenderInstructionData.span);
        RewardManagerProgram.layouts.createSenderInstructionData.encode({
            instruction: RewardManagerInstruction.CreateSender,
            senderEthAddress,
            operatorEthAddress
        }, data);
        const keys = [
            { pubkey: rewardManagerState, isSigner: false, isWritable: false },
            { pubkey: manager, isSigner: true, isWritable: false },
            { pubkey: authority, isSigner: false, isWritable: false },
            { pubkey: payer, isSigner: true, isWritable: false },
            { pubkey: sender, isSigner: false, isWritable: true },
            { pubkey: SystemProgram.programId, isSigner: false, isWritable: false },
            { pubkey: SYSVAR_RENT_PUBKEY, isSigner: false, isWritable: false }
        ];
        return new TransactionInstruction({
            programId: rewardManagerProgramId,
            keys,
            data
        });
    }
    static decodeCreateSenderInstruction({ programId, keys: [rewardManagerState, manager, authority, payer, sender, systemProgramId, rent], data }) {
        return {
            programId,
            keys: {
                rewardManagerState,
                manager,
                authority,
                payer,
                sender,
                systemProgramId,
                rent
            },
            data: RewardManagerProgram.layouts.createSenderInstructionData.decode(data)
        };
    }
    static createSenderPublicInstruction({ senderEthAddress, operatorEthAddress, rewardManagerState, authority, payer, sender, existingSenders, rewardManagerProgramId }) {
        const data = Buffer.alloc(RewardManagerProgram.layouts.createSenderPublicInstructionData.span);
        RewardManagerProgram.layouts.createSenderPublicInstructionData.encode({
            instruction: RewardManagerInstruction.CreateSenderPublic,
            senderEthAddress,
            operatorEthAddress
        }, data);
        const keys = [
            { pubkey: rewardManagerState, isSigner: false, isWritable: false },
            { pubkey: authority, isSigner: false, isWritable: false },
            { pubkey: payer, isSigner: true, isWritable: true },
            { pubkey: sender, isSigner: false, isWritable: true },
            {
                pubkey: SYSVAR_INSTRUCTIONS_PUBKEY,
                isSigner: false,
                isWritable: false
            },
            { pubkey: SYSVAR_RENT_PUBKEY, isSigner: false, isWritable: false },
            { pubkey: SystemProgram.programId, isSigner: false, isWritable: false },
            ...existingSenders.map((pubkey) => ({
                pubkey,
                isSigner: false,
                isWritable: false
            }))
        ];
        return new TransactionInstruction({
            programId: rewardManagerProgramId,
            keys,
            data
        });
    }
    static decodeCreateSenderPublicInstruction({ programId, keys: [rewardManagerState, authority, payer, sender, sysvarInstructions, rent, systemProgramId, ...existingSenders], data }) {
        return {
            programId,
            keys: {
                rewardManagerState,
                authority,
                payer,
                sender,
                sysvarInstructions,
                rent,
                systemProgramId,
                existingSenders
            },
            data: RewardManagerProgram.layouts.createSenderPublicInstructionData.decode(data)
        };
    }
    static decodeDeleteSenderPublicInstruction({ programId, keys: [rewardManagerState, sender, refunder, sysvarInstructions, ...existingSenders] }) {
        return {
            programId,
            keys: {
                rewardManagerState,
                sender,
                refunder,
                sysvarInstructions,
                existingSenders
            },
            data: {
                instruction: RewardManagerInstruction.DeleteSenderPublic
            }
        };
    }
    static decodeSubmitAttestationInstruction({ programId, keys: [attestations, rewardManagerState, authority, payer, sender, rent, sysvarInstructions, systemProgramId], data }) {
        return {
            programId,
            keys: {
                attestations,
                rewardManagerState,
                authority,
                payer,
                sender,
                rent,
                sysvarInstructions,
                systemProgramId
            },
            data: RewardManagerProgram.layouts.submitAttestationInstructionData.decode(data)
        };
    }
    static decodeEvaluateAttestationsInstruction({ programId, keys: [attestations, rewardManagerState, authority, rewardManagerTokenSource, destinationUserbank, disbursementAccount, antiAbuseOracle, payer, rent, tokenProgramId, systemProgramId], data }) {
        return {
            programId,
            keys: {
                attestations,
                rewardManagerState,
                authority,
                rewardManagerTokenSource,
                destinationUserbank,
                disbursementAccount,
                antiAbuseOracle,
                payer,
                rent,
                tokenProgramId,
                systemProgramId
            },
            data: RewardManagerProgram.layouts.evaluateAttestationsInstructionData.decode(data)
        };
    }
    static decodeInstruction(instruction) {
        switch (instruction.data[0]) {
            case RewardManagerInstruction.Init:
            case RewardManagerInstruction.ChangeManagerAccount:
                throw new Error('Not Implemented');
            case RewardManagerInstruction.CreateSender:
                return RewardManagerProgram.decodeCreateSenderInstruction(instruction);
            case RewardManagerInstruction.DeleteSender:
                throw new Error('Not Implemented');
            case RewardManagerInstruction.CreateSenderPublic:
                return RewardManagerProgram.decodeCreateSenderPublicInstruction(instruction);
            case RewardManagerInstruction.DeleteSenderPublic:
                return RewardManagerProgram.decodeDeleteSenderPublicInstruction(instruction);
            case RewardManagerInstruction.SubmitAttestation:
                return RewardManagerProgram.decodeSubmitAttestationInstruction(instruction);
            case RewardManagerInstruction.EvaluateAttestations:
                return RewardManagerProgram.decodeEvaluateAttestationsInstruction(instruction);
            default:
                throw new Error('Invalid RewardManager Instruction');
        }
    }
    static isCreateSenderInstruction(decoded) {
        return decoded.data.instruction === RewardManagerInstruction.CreateSender;
    }
    static isCreateSenderPublicInstruction(decoded) {
        return (decoded.data.instruction === RewardManagerInstruction.CreateSenderPublic);
    }
    static isDeleteSenderPublicInstruction(decoded) {
        return (decoded.data.instruction === RewardManagerInstruction.DeleteSenderPublic);
    }
    static isSubmitAttestationInstruction(decoded) {
        return (decoded.data.instruction === RewardManagerInstruction.SubmitAttestation);
    }
    static isEvaluateAttestationsInstruction(decoded) {
        return (decoded.data.instruction === RewardManagerInstruction.EvaluateAttestations);
    }
    static encodeAttestation(attestation) {
        const data = Buffer.alloc(attestationLayout().span);
        const span = attestationLayout().encode(attestation, data);
        return data.subarray(0, span);
    }
    static decodeAttestation(data) {
        return attestationLayout().decode(data);
    }
    static decodeAttestationsAccountData(maxAttestations, data) {
        const decoded = this.layouts
            .attestationsAccountData(maxAttestations)
            .decode(data);
        decoded.messages = decoded.messages.slice(0, decoded.count);
        for (let i = 0; i < decoded.messages.length; i++) {
            if (decoded.messages[i].attestation.antiAbuseOracleEthAddress ===
                '0x0000000000000000000000000000000000000000') {
                decoded.messages[i].attestation.antiAbuseOracleEthAddress = null;
            }
        }
        return decoded;
    }
    static deriveAuthority({ programId, rewardManagerState }) {
        return PublicKey.findProgramAddressSync([rewardManagerState.toBytes().slice(0, 32)], programId)[0];
    }
    static deriveSender({ ethAddress: wallet, programId, authority }) {
        const ethAddressData = ethAddress(wallet);
        const buffer = Buffer.alloc(ethAddressData.span);
        ethAddressData.encode(wallet, buffer);
        const seed = Uint8Array.from([...SENDER_SEED_PREFIX_BYTES, ...buffer]);
        return PublicKey.findProgramAddressSync([authority.toBytes().slice(0, 32), seed], programId)[0];
    }
    static deriveAttestations({ disbursementId, programId, authority }) {
        const encoder = new TextEncoder();
        const seed = Uint8Array.from([
            ...ATTESTATIONS_SEED_PREFIX_BYTES,
            ...encoder.encode(disbursementId)
        ]);
        return PublicKey.findProgramAddressSync([authority.toBytes().slice(0, 32), seed], programId)[0];
    }
    static deriveDisbursement({ disbursementId, programId, authority }) {
        const encoder = new TextEncoder();
        const seed = Uint8Array.from([
            ...DISBURSEMENT_SEED_PREFIX_BYTES,
            ...encoder.encode(disbursementId)
        ]);
        return PublicKey.findProgramAddressSync([authority.toBytes().slice(0, 32), seed], programId)[0];
    }
    static encodeSignature(signature) {
        const recoveryIdString = signature.slice(-2);
        const recoveryIdBuffer = Buffer.from(recoveryIdString, 'hex');
        const strippedSignature = signature
            .substring(0, signature.length - 2)
            .replace('0x', '')
            .padStart(128, '0')
            .substring(0, 128);
        const signatureBuffer = Buffer.from(strippedSignature, 'hex');
        return {
            signature: signatureBuffer,
            recoveryId: recoveryIdBuffer.readInt8()
        };
    }
    static decodeRewardManagerState(accountData) {
        return RewardManagerProgram.layouts.rewardManagerStateData.decode(accountData);
    }
    static encodeSenderAttestation(attestation) {
        const data = Buffer.alloc(senderAttestationLayout().span);
        const span = senderAttestationLayout().encode(attestation, data);
        return data.subarray(0, span);
    }
}
_a = RewardManagerProgram;
RewardManagerProgram.programId = new PublicKey('DDZDcYdQFEMwcu2Mwo75yGFjJ1mUQyyXLWzhZLEVFcei');
RewardManagerProgram.layouts = {
    createSenderInstructionData: struct([
        u8('instruction'),
        ethAddress('senderEthAddress'),
        ethAddress('operatorEthAddress')
    ]),
    createSenderPublicInstructionData: struct([
        u8('instruction'),
        ethAddress('senderEthAddress'),
        ethAddress('operatorEthAddress')
    ]),
    evaluateAttestationsInstructionData: struct([
        u8('instruction'),
        u64('amount'),
        borshString(32, 'disbursementId'),
        ethAddress('recipientEthAddress')
    ]),
    submitAttestationInstructionData: struct([
        u8('instruction'),
        borshString(32, 'disbursementId')
    ]),
    rewardManagerStateData: struct([
        u8('version'),
        publicKey('tokenAccount'),
        publicKey('manager'),
        u8('minVotes')
    ]),
    attestationsAccountData: (maxAttestations) => struct([
        u8('version'),
        publicKey('rewardManagerState'),
        u8('count'),
        seq(struct([
            ethAddress('senderEthAddress'),
            attestationLayout('attestation'),
            // Though the actual attestation message is only 83 bytes, we allocate
            // 128 bytes for each element of this array on the program side.
            // Thus we add 45 bytes of padding here to be consistent.
            // See: https://github.com/AudiusProject/audius-protocol/blob/dde78ad7e26d9f6fb358fef5d240c5c7e2d25c66/solana-programs/reward-manager/program/src/state/verified_messages.rs#L99
            blob(45),
            ethAddress('operator')
        ]), maxAttestations, 'messages')
    ])
};
RewardManagerProgram.createSubmitAttestationInstruction = ({ disbursementId, attestations, rewardManagerState, authority, payer, sender, rewardManagerProgramId = RewardManagerProgram.programId }) => {
    const b = Buffer.alloc(_a.layouts.submitAttestationInstructionData.span);
    const length = _a.layouts.submitAttestationInstructionData.encode({
        instruction: RewardManagerInstruction.SubmitAttestation,
        disbursementId
    }, b);
    const data = b.subarray(0, length);
    const keys = [
        { pubkey: attestations, isSigner: false, isWritable: true },
        { pubkey: rewardManagerState, isSigner: false, isWritable: false },
        { pubkey: authority, isSigner: false, isWritable: false },
        { pubkey: payer, isSigner: true, isWritable: true },
        { pubkey: sender, isSigner: false, isWritable: false },
        { pubkey: SYSVAR_RENT_PUBKEY, isSigner: false, isWritable: false },
        {
            pubkey: SYSVAR_INSTRUCTIONS_PUBKEY,
            isSigner: false,
            isWritable: false
        },
        { pubkey: SystemProgram.programId, isSigner: false, isWritable: false }
    ];
    return new TransactionInstruction({
        programId: rewardManagerProgramId,
        keys,
        data
    });
};
RewardManagerProgram.createEvaluateAttestationsInstruction = ({ disbursementId, recipientEthAddress, amount, attestations, rewardManagerState, authority, rewardManagerTokenSource, destinationUserBank, disbursementAccount, antiAbuseOracle, payer, tokenProgramId = TOKEN_PROGRAM_ID, rewardManagerProgramId = RewardManagerProgram.programId }) => {
    const b = Buffer.alloc(RewardManagerProgram.layouts.evaluateAttestationsInstructionData.span);
    const length = RewardManagerProgram.layouts.evaluateAttestationsInstructionData.encode({
        instruction: RewardManagerInstruction.EvaluateAttestations,
        disbursementId,
        amount,
        recipientEthAddress
    }, b);
    const data = b.subarray(0, length);
    const keys = [
        { pubkey: attestations, isSigner: false, isWritable: true },
        { pubkey: rewardManagerState, isSigner: false, isWritable: false },
        { pubkey: authority, isSigner: false, isWritable: false },
        { pubkey: rewardManagerTokenSource, isSigner: false, isWritable: true },
        { pubkey: destinationUserBank, isSigner: false, isWritable: true },
        { pubkey: disbursementAccount, isSigner: false, isWritable: true },
        { pubkey: antiAbuseOracle, isSigner: false, isWritable: false },
        { pubkey: payer, isSigner: true, isWritable: true },
        { pubkey: SYSVAR_RENT_PUBKEY, isSigner: false, isWritable: false },
        { pubkey: tokenProgramId, isSigner: false, isWritable: false },
        { pubkey: SystemProgram.programId, isSigner: false, isWritable: false }
    ];
    return new TransactionInstruction({
        programId: rewardManagerProgramId,
        keys,
        data
    });
};
export { RewardManagerProgram };
//# sourceMappingURL=RewardManagerProgram.js.map