'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var crypto = require('crypto');
var bip39 = require('bip39');
var ethereumjsWallet = require('ethereumjs-wallet');
var randomBytes = require('randombytes');
var Cipher = require('browserify-cipher/browser');
var safeBuffer = require('safe-buffer');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var crypto__default = /*#__PURE__*/_interopDefaultLegacy(crypto);
var randomBytes__default = /*#__PURE__*/_interopDefaultLegacy(randomBytes);
var Cipher__default = /*#__PURE__*/_interopDefaultLegacy(Cipher);

// https://stackoverflow.com/questions/38987784/how-to-convert-a-hexadecimal-string-to-uint8array-and-back-in-javascript
function bufferFromHexString(hexString) {
    const byteArray = hexString
        .match(/.{1,2}/g)
        ?.map((byte) => parseInt(byte, 16));
    return new Uint8Array(byteArray);
}
function WebWorker(worker) {
    if (typeof window !== "undefined" && window.Worker) {
        const code = worker.toString();
        const blob = new Blob(["(" + code + ")()"]);
        return new window.Worker(URL.createObjectURL(blob));
    }
    else
        throw new Error("Cannot call web worker on the server");
}
/**
 * Fallback for localStorage that works in node and the browser
 */
function getPlatformLocalStorage() {
    if (isNodeEnv()) {
        const LocalStorage = require("node-localstorage").LocalStorage;
        return new LocalStorage("./local-storage");
    }
    if (isWebEnv()) {
        return window.localStorage;
    }
    throw new Error("Please pass in valid localStorage object into the Hedgehog constructor");
}
function isReactNativeEnv() {
    return (typeof navigator !== "undefined" && navigator.product === "ReactNative");
}
function isWebEnv() {
    return (typeof window !== "undefined" &&
        window &&
        window.Worker &&
        !isReactNativeEnv());
}
function isNodeEnv() {
    return typeof window === "undefined" || window === null;
}
function getPlatformCreateKey() {
    /**
     * Given a user encryptStr and initialization vector, generate a private key
     * @param encryptStr String to encrypt (can be user password or some kind of lookup key)
     * @param ivHex hex string iv value
     */
    const createKey = async (encryptStr, ivHex) => {
        if (isWebEnv()) {
            return new Promise((resolve) => {
                const worker = WebWorker(require("./authWorker.js").toString());
                worker.postMessage(JSON.stringify({ encryptStr, ivHex }));
                worker.onmessage = (event) => {
                    resolve(event.data);
                };
            });
        }
        if (isNodeEnv()) {
            return new Promise((resolve, reject) => {
                const N = 32768;
                const r = 8;
                const p = 1;
                const dkLen = 32;
                const encryptStrBuffer = Buffer.from(encryptStr);
                const ivBuffer = Buffer.from(ivHex);
                // https://github.com/nodejs/node/issues/21524#issuecomment-400012811
                const maxmem = 128 * p * r + 128 * (2 + N) * r;
                crypto__default["default"].scrypt(encryptStrBuffer, ivBuffer, dkLen, { N, r, p, maxmem }, (err, derivedKey) => {
                    if (err) {
                        reject(err);
                    }
                    else {
                        const keyHex = derivedKey.toString("hex");
                        // This is the private key
                        const keyBuffer = bufferFromHexString(keyHex);
                        resolve({ keyHex, keyBuffer });
                    }
                });
            });
        }
        throw new Error("Please pass in valid createKey function into the Hedgehog constructor");
    };
    return createKey;
}
function waitUntil(condition) {
    return new Promise((resolve) => {
        const interval = setInterval(() => {
            if (!condition()) {
                return;
            }
            clearInterval(interval);
            resolve();
        }, 100);
    });
}

/**
 * WARNING!
 * This file should NOT be modified unless you know what you're doing.
 * All public functions are exposed via hedgehog.js and walletManager.js
 */
const mode = "aes-256-cbc";
const encryptPrefixStr = "hedgehog-entropy:::";
class Authentication {
    /**
     * Given an entropy string and a HD wallet path, return the wallet address
     * @param entropy Hex string generated by generateMnemonicAndEntropy()
     *                         Looks like `47b0e5e107cccc3297d88647c6e84a9f`
     * @param path Path for hierarchical deterministic wallet
     *                      Looks like `m/44'/60'/0'/0/0`
     * @returns ethereumjs-wallet wallet object
     */
    static async generateWalletFromEntropy(entropy, path) {
        const seed = await bip39.mnemonicToSeed(bip39.entropyToMnemonic(entropy));
        // generate HD wallet, not necessary for authentication
        const hdwallet = ethereumjsWallet.hdkey.fromMasterSeed(seed);
        // wallet is an ethereumjs-wallet object
        const wallet = hdwallet.derivePath(path).getWallet();
        return wallet;
    }
    /**
     * Creates a random mnemonic and creates an entropy string from the mnemonic
     * @returns `{mnemonic: '...mnemonic string...', entropy: '47b0e5e107cccc3297d88647c6e84a9f'}`
     */
    static generateMnemonicAndEntropy() {
        const mnemonic = bip39.generateMnemonic();
        // this is what we encrypt as private key
        const entropy = bip39.mnemonicToEntropy(mnemonic);
        return { mnemonic: mnemonic, entropy: entropy };
    }
    /**
     * Generate a 16 byte initialization vector and returns it as both a hex string and a buffer
     */
    static createIV() {
        const ivBuffer = randomBytes__default["default"](16);
        const ivHex = ivBuffer.toString("hex");
        return { ivHex, ivBuffer };
    }
    /**
     * Given a iv buffer and key buffer, generate a ciphertext
     * @param entropy Hex string of entropy
     * @param ivBuffer Buffer version of iv
     * @param keyBuffer Buffer version of key
     */
    static encrypt(entropy, ivBuffer, keyBuffer) {
        let encryptFn = Cipher__default["default"].createCipheriv(mode, keyBuffer, ivBuffer);
        const entropyBuffer = createEncryptBuffer(entropy);
        let cipherText = safeBuffer.Buffer.concat([
            encryptFn.update(entropyBuffer),
            encryptFn.final(),
        ]);
        let cipherTextHex = cipherText.toString("hex");
        return { cipherText: cipherText, cipherTextHex: cipherTextHex };
    }
    /**
     * Given an iv buffer, key buffer and ciphertext, decrypt the plaintext value of the entropy
     * @param ivBuffer Buffer version of iv
     * @param keyBuffer Buffer version of key
     * @param cipherTextHex Hex string of the ciphertext
     * @returns Hex string of the entropy. If everything is correct, this should be the same
     *                   as the input entropy, allowing us to check that the generated wallet address
     *                   is the same as the current wallet address for the user
     */
    static decrypt(ivBuffer, keyBuffer, cipherTextHex) {
        const decryptFn = Cipher__default["default"].createDecipheriv(mode, keyBuffer, ivBuffer);
        const cipherText = safeBuffer.Buffer.from(bufferFromHexString(cipherTextHex));
        const decryptedEntropyBuffer = safeBuffer.Buffer.concat([
            decryptFn.update(cipherText),
            decryptFn.final(),
        ]);
        const decryptedEntropy = verifyDecryptString(decryptedEntropyBuffer);
        return decryptedEntropy;
    }
}
/**
 * This prepends the encryptPrefixStr to the entropy, converts it to a buffer and returns the buffer
 * @param entropy hex string of entropy
 * @returns buffer ready to encrypt via encryptFn
 */
function createEncryptBuffer(entropy) {
    let buff = safeBuffer.Buffer.from(encryptPrefixStr + entropy, "utf8");
    return buff;
}
/**
 * This converts the buffer returned by the `decrypt` function to string, checks that the
 * integrity of the string to check if the encryptPrefixStr exists so we know that the same encrypted value has
 * been decrypted, parses the entropy and returns
 * @param decryptedEntropyBuffer value returned by decryptFn decryption
 * @returns entropy hex string
 */
function verifyDecryptString(decryptedEntropyBuffer) {
    let decryptedEntrophy = decryptedEntropyBuffer.toString("utf8");
    if (decryptedEntrophy && decryptedEntrophy.indexOf(encryptPrefixStr) === 0) {
        return decryptedEntrophy.split(encryptPrefixStr)[1];
    }
    else
        throw new Error("Could not verify integrity of decrypted string");
}

// primary account management key for HD wallet
// TODO - make these options that can be overridden
const PATH = "m/44'/60'/0'/0/0";
const hedgehogEntropyKey = "hedgehog-entropy-key";
// Contains functions to help create and maintain user accounts client side
// The reason many functions return both buffer and hex strings is because different
// packages expect different formats. So if a value is used in multiple formats, all
// the formats are returned by the generation function
class WalletManager {
    static async createWalletObj(password, entropyOverride = null, localStorage, createKey) {
        let self = this;
        let entropy;
        if (!password)
            return new Error("Missing property: password");
        const { ivBuffer, ivHex } = Authentication.createIV();
        const { keyBuffer } = await createKey(password, ivHex);
        if (!entropyOverride) {
            entropy = Authentication.generateMnemonicAndEntropy()["entropy"];
        }
        else {
            entropy = entropyOverride;
        }
        let walletObj = await Authentication.generateWalletFromEntropy(entropy, PATH);
        const { cipherTextHex } = Authentication.encrypt(entropy, ivBuffer, keyBuffer);
        await self.setEntropyInLocalStorage(entropy, localStorage);
        return {
            ivHex: ivHex,
            cipherTextHex: cipherTextHex,
            walletObj: walletObj,
            entropy: entropy,
        };
    }
    static async decryptCipherTextAndRetrieveWallet(password, ivHex, cipherTextHex, createKey) {
        const { keyBuffer } = await createKey(password, ivHex);
        const ivBuffer = bufferFromHexString(ivHex);
        const decryptedEntrophy = Authentication.decrypt(ivBuffer, keyBuffer, cipherTextHex);
        const walletObj = await Authentication.generateWalletFromEntropy(decryptedEntrophy, PATH);
        return { walletObj, entropy: decryptedEntrophy };
    }
    static async createAuthLookupKey(username, password, createKey) {
        // lowercase username so the lookupKey is consistently generated to search in the database
        username = username.toLowerCase();
        // This iv is hardcoded because the auth lookup key should be deterministically
        // generated given the same username and password
        const ivHex = "0x4f7242b39969c3ac4c6712524d633ce9";
        const { keyHex } = await createKey(username + ":::" + password, ivHex);
        return keyHex;
    }
    static async getEntropyFromLocalStorage(localStorage) {
        let entropy = await localStorage.getItem(hedgehogEntropyKey);
        // Sometimes the string 'undefined' was being written to localstorage
        // this is an explicit check for that
        if (entropy && entropy !== "undefined") {
            return entropy;
        }
        else
            return null;
    }
    static async getWalletObjFromLocalStorageIfExists(localStorage) {
        let entropy = await this.getEntropyFromLocalStorage(localStorage);
        if (entropy) {
            const walletObj = await Authentication.generateWalletFromEntropy(entropy, PATH);
            if (walletObj)
                return walletObj;
            else
                return null;
        }
        else
            return null;
    }
    static async setEntropyInLocalStorage(entropy, localStorage) {
        await localStorage.setItem(hedgehogEntropyKey, entropy);
    }
    static async deleteEntropyFromLocalStorage(localStorage) {
        await localStorage.removeItem(hedgehogEntropyKey);
    }
}

class Hedgehog {
    constructor(getFn, setAuthFn, setUserFn, useLocalStorage = true, localStorage = getPlatformLocalStorage(), createKey = getPlatformCreateKey()) {
        if (getFn && setAuthFn && setUserFn) {
            this.getFn = getFn;
            this.setAuthFn = setAuthFn;
            this.setUserFn = setUserFn;
            this.wallet = null;
            this.localStorage = localStorage;
            this.createKey = createKey;
            this.ready = false;
            // If there's entropy in localStorage, recover that and create a wallet object and put it
            // on the wallet property in the class
            if (useLocalStorage) {
                this.restoreLocalWallet().then(() => {
                    this.ready = true;
                });
            }
            else {
                this.ready = true;
            }
        }
        else {
            throw new Error("Please pass in valid getFn, setAuthFn and setUserFn parameters into the Hedgehog constructor");
        }
    }
    /**
     * Helper function to check if Hedgehog instance is ready.
     * Only needed if `useLocalStorage = true`
     * Otherwise, Hedgehog will be ready as soon as it is constructed.
     */
    isReady() {
        return this.ready;
    }
    /**
     * Helper function to wait until Hedgehog instance is ready.
     * Only needed if `useLocalStorage = true`
     * Otherwise, Hedgehog will be ready as soon as it is constructed.
     */
    async waitUntilReady() {
        await waitUntil(() => this.isReady());
    }
    /**
     * Given user credentials, create a client side wallet and all other authentication artifacts,
     * call setFn to persist the artifacts to a server and return the wallet object
     * @returns ethereumjs-wallet wallet object
     */
    async signUp({ username, password, ...optionalParams }) {
        let self = this;
        const createWalletPromise = WalletManager.createWalletObj(password, null, this.localStorage, this.createKey);
        const lookupKeyPromise = WalletManager.createAuthLookupKey(username, password, this.createKey);
        try {
            const [walletResult, lookupKey] = await Promise.all([
                createWalletPromise,
                lookupKeyPromise,
            ]);
            if (walletResult instanceof Error)
                throw walletResult;
            const { ivHex, cipherTextHex, walletObj } = walletResult;
            const walletAddress = walletObj.getAddressString();
            const authData = {
                ...optionalParams,
                iv: ivHex,
                cipherText: cipherTextHex,
                wallet: walletObj,
                lookupKey: lookupKey
            };
            const userData = {
                ...optionalParams,
                username: username,
                walletAddress: walletAddress,
            };
            await self.setUserFn(userData);
            await self.setAuthFn(authData);
            // set the wallet at the very end to make sure the isLoggedIn() function doesn't return true
            self.wallet = walletObj;
            return walletObj;
        }
        catch (e) {
            await self.logout();
            throw e;
        }
    }
    /**
     * Generate new set of auth credentials to allow login
     * If the old password is included, the setAuthFn will include the old lookup key for deletion
     */
    async resetPassword({ username, password, ...optionalParams }) {
        let self = this;
        let entropy = await WalletManager.getEntropyFromLocalStorage(this.localStorage);
        if (entropy === null) {
            throw new Error("resetPassword - missing entropy");
        }
        const createWalletPromise = WalletManager.createWalletObj(password, entropy, this.localStorage, this.createKey);
        const lookupKeyPromise = WalletManager.createAuthLookupKey(username, password, this.createKey);
        try {
            const [walletResult, lookupKey] = await Promise.all([
                createWalletPromise,
                lookupKeyPromise,
            ]);
            if (walletResult instanceof Error)
                throw walletResult;
            const { ivHex, cipherTextHex, walletObj } = walletResult;
            const authData = {
                ...optionalParams,
                iv: ivHex,
                cipherText: cipherTextHex,
                wallet: walletObj,
                lookupKey: lookupKey,
            };
            await self.setAuthFn(authData);
            self.wallet = walletObj;
        }
        catch (e) {
            await self.logout();
            throw e;
        }
    }
    /**
     * Generate new set of auth credentials to allow login and remove the old credentials
     * Note: Doesn't log out on error
     */
    async changeCredentials({ newUsername, newPassword, oldUsername, oldPassword, ...optionalParams }) {
        let self = this;
        let entropy = await WalletManager.getEntropyFromLocalStorage(this.localStorage);
        if (entropy === null) {
            throw new Error("changePassword - missing entropy");
        }
        const createWalletPromise = WalletManager.createWalletObj(newPassword, entropy, this.localStorage, this.createKey);
        const lookupKeyPromise = WalletManager.createAuthLookupKey(newUsername, newPassword, this.createKey);
        const oldLookupKeyPromise = WalletManager.createAuthLookupKey(oldUsername !== undefined ? oldUsername : newUsername, oldPassword, this.createKey);
        try {
            let [walletResult, lookupKey, oldLookupKey] = await Promise.all([
                createWalletPromise,
                lookupKeyPromise,
                oldLookupKeyPromise,
            ]);
            if (walletResult instanceof Error)
                throw walletResult;
            const { ivHex, cipherTextHex, walletObj } = walletResult;
            const authData = {
                ...optionalParams,
                iv: ivHex,
                cipherText: cipherTextHex,
                lookupKey: lookupKey,
                wallet: walletObj,
                oldLookupKey: oldLookupKey
            };
            await self.setAuthFn(authData);
            self.wallet = walletObj;
        }
        catch (e) {
            throw e;
        }
    }
    /**
     * Given user credentials, attempt to get authentication artifacts from server using
     * getFn, create the private key using the artifacts and the user password
     * @returns ethereumjs-wallet wallet object
     */
    async login({ username, password, ...optionalParams }) {
        let self = this;
        let lookupKey = await WalletManager.createAuthLookupKey(username, password, this.createKey);
        let data = await self.getFn({ ...optionalParams, lookupKey });
        if (data && data.iv && data.cipherText) {
            const { walletObj, entropy } = await WalletManager.decryptCipherTextAndRetrieveWallet(password, data.iv, data.cipherText, this.createKey);
            // set wallet property on the class
            self.wallet = walletObj;
            // set entropy in localStorage
            await WalletManager.setEntropyInLocalStorage(entropy, this.localStorage);
            return walletObj;
        }
        else {
            throw new Error("No account record for user");
        }
    }
    /**
     * Confirms the user credentials given generate the same entropy after using artifacts from the server
     * @returns whether or not the credentials are valid for the current user
     */
    async confirmCredentials({ username, password, ...optionalParams }) {
        const self = this;
        const existingEntropy = await WalletManager.getEntropyFromLocalStorage(this.localStorage);
        if (!existingEntropy)
            return false; // not logged in yet
        const lookupKey = await WalletManager.createAuthLookupKey(username, password, this.createKey);
        const data = await self.getFn({ ...optionalParams, lookupKey });
        if (data && data.iv && data.cipherText) {
            const { walletObj, entropy } = await WalletManager.decryptCipherTextAndRetrieveWallet(password, data.iv, data.cipherText, this.createKey);
            // test against current entropy in localStorage and current wallet
            return (entropy === existingEntropy &&
                self.wallet !== null &&
                self.wallet.getAddressString() === walletObj.getAddressString());
        }
        return false;
    }
    /**
     * Deletes the local client side wallet including entropy and all associated
     * authentication artifacts
     */
    async logout() {
        this.wallet = null;
        await WalletManager.deleteEntropyFromLocalStorage(this.localStorage);
    }
    /**
     * Returns is the user has a client side wallet. If they do, calls can be made against
     * that wallet, if they don't the user has to login or signup
     * @returns true if the user has a client side wallet, false otherwise
     */
    isLoggedIn() {
        return !!this.wallet;
    }
    /**
     * Returns the current user wallet
     * @returns ethereumjs-wallet wallet object if a wallet exists, otherwise null
     */
    getWallet() {
        return this.wallet;
    }
    /**
     * If a user refreshes or navigates away from the page and comes back later, this attempts
     * to restore the client side wallet from localStorage, if it exists
     * @returns If the user has a wallet client side, the wallet object is returned,
     *                        otherwise null is returned
     */
    async restoreLocalWallet() {
        const walletObj = await WalletManager.getWalletObjFromLocalStorageIfExists(this.localStorage);
        if (walletObj) {
            this.wallet = walletObj;
            return walletObj;
        }
        else
            return null;
    }
    /**
     * Create a new client side wallet object without going through the signup flow. This is useful
     * if you need a temporary, read-only wallet that is ephemeral and does not need to be persisted
     * @param password user password
     * @returns ethereumjs-wallet wallet object
     */
    async createWalletObj(password) {
        if (password) {
            const walletResult = await WalletManager.createWalletObj(password, null, this.localStorage, this.createKey);
            if (walletResult instanceof Error)
                throw walletResult;
            const { walletObj, entropy } = walletResult;
            this.wallet = walletObj;
            await WalletManager.setEntropyInLocalStorage(entropy, this.localStorage);
            return walletObj;
        }
        else {
            throw new Error("Please pass in a valid password");
        }
    }
}

exports.Authentication = Authentication;
exports.Hedgehog = Hedgehog;
exports.WalletManager = WalletManager;
exports.WebWorker = WebWorker;
exports.bufferFromHexString = bufferFromHexString;
exports.getPlatformCreateKey = getPlatformCreateKey;
exports.getPlatformLocalStorage = getPlatformLocalStorage;
exports.waitUntil = waitUntil;
//# sourceMappingURL=index.js.map
